
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/bktown/p/18775589/tauri-newbie-shellcode-loader-based-on-lsb-steganography-zfguxj" title="发布于 2025-03-16 20:36">
    <span role="heading" aria-level="2">Tauri新手向 - 基于LSB隐写的shellcode加载器</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102918284-2094946170.jpg" alt="image" loading="lazy"></p>
<blockquote>
<p>此篇是记录自己初次学习tauri开发工具，包含遇到的一些问题以及基本的知识，也给想上手rust tauri的师傅们一些小小的参考。此项目为保持免杀性暂不开源，希望各位师傅多多支持，反响可以的话后续会放出代码大家一起交流学习。</p>
</blockquote>
<blockquote>
<p>ShadowMeld - 基于图像隐写技术的载荷生成框架</p>
<p>通过将加密的二进制指令集嵌入到常规图片的像素数据中，生成具备合法外观的载体文件。配套生成的加载程序（Loader）会自动解析图片中的隐藏数据，在内存中完成指令重组与执行，实现无文件形态的隐蔽通信。</p>
<p>项目地址： <a href="https://github.com/BKLockly/ShadowMeld" target="_blank" rel="noopener nofollow">https://github.com/BKLockly/ShadowMeld</a>，记录和开发不易，还望多多支持。</p>
</blockquote>
<p>‍</p>
<h2 id="1-1-初始化">1. 1. 初始化</h2>
<h3 id="11-11-创建项目">1.1 1.1 创建项目</h3>
<pre><code class="language-toml">npm create tauri-app@latest
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102919177-15518319.png" alt="image" title="选项填写示例" loading="lazy"></p>
<p>安装依赖以初始化，接着调试。</p>
<pre><code class="language-powershell">cd tauri-app
npm install
npm run tauri dev
</code></pre>
<p>‍</p>
<h3 id="12-12-解决报错">1.2 1.2 解决报错</h3>
<p>遇到以下报错：</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102920448-2027019049.png" alt="image" title="运行报错" loading="lazy"></p>
<p>查到的方案：编辑<code>.cargo/config.toml</code>​ 文件，添加以下内容以抑制特定警告以及版本锁定，避免 ICU 库的符号冲突：</p>
<pre><code class="language-toml">[build]
rustflags = [
  "-C", "link-arg=/IGNORE:4078",  # 忽略 .drectve 警告
  "-C", "link-arg=/NODEFAULTLIB:LIBCMT.lib" # 解决 ICU 库冲突
]

[dependencies]
icu_provider = "1.3.0"
icu_locid = "1.3.0"
</code></pre>
<p>还有报错，deepseek提示可能是MSVC工具链时缺少必要的Visual Studio构建工具。</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102922119-1076869680.png" alt="image" title="MSVC工具链有问题" loading="lazy"></p>
<p>重新更新一下生成工具，注意勾选：</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102922700-764296663.png" alt="image" title="更新时的注意选项" loading="lazy"></p>
<p>最后再次尝试就完成了基本的初始化了。</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102923605-1626529475.png" alt="image" title="成功启动页面" loading="lazy"></p>
<p>‍</p>
<h2 id="2-2-前端构建">2. 2. 前端构建</h2>
<h3 id="21-21-安装组件">2.1 2.1 安装组件</h3>
<p>UI组件我使用<a href="https://www.antdv.com/docs/vue/introduce-cn" target="_blank" rel="noopener nofollow">Ant Design Vue</a>，在根目录下执行以安装：</p>
<pre><code class="language-powershell">npm install ant-design-vue@4.x --save
</code></pre>
<p>之后在<code>main.ts</code>​中使用并引入样式：</p>
<pre><code class="language-typescript">import { createApp } from "vue";
import App from "./App.vue";
import { DatePicker } from 'ant-design-vue';
import 'ant-design-vue/dist/reset.css';

const app = createApp(App);
app.use(DatePicker);
app.mount("#app");
</code></pre>
<p>接着安装图标：</p>
<pre><code class="language-powershell">npm install --save @ant-design/icons-vue
</code></pre>
<p>图标的使用也很简单，例如：</p>
<pre><code class="language-typescript">import { GithubOutlined } from '@ant-design/icons-vue';
 &lt;GithubOutlined title="点击打开项目主页" @click="openGitHub"/&gt;
</code></pre>
<p>于此处查看其他图标：<a href="https://www.antdv.com/components/icon-cn" target="_blank" rel="noopener nofollow">传送门</a></p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102924181-2014150367.png" alt="image" title="ant-design官方文档" loading="lazy"></p>
<p>‍</p>
<h3 id="01-22-按需引入">0.1 2.2 按需引入</h3>
<p>使用<code>unplugin-vue-components</code>​来导入所使用到的组件，就不需要全部打包进来来节省体积：</p>
<pre><code class="language-powershell">npm install unplugin-vue-components -D
</code></pre>
<p>之后编辑<code>vite.config.js</code>​，添加如下行数以启用：</p>
<pre><code class="language-diff">import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
+ import Components from 'unplugin-vue-components/vite';
+ import { AntDesignVueResolver } from 'unplugin-vue-components/resolvers';

// @ts-expect-error process is a nodejs global
const host = process.env.TAURI_DEV_HOST;

// https://vitejs.dev/config/
export default defineConfig(async () =&gt; ({
  plugins: [
      vue(),
+      Components({
+          resolvers: [
+             AntDesignVueResolver({
+                  importStyle: false, // css in js
+              }),
+          ],
+      }),
  ],

  // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
  //
  // 1. prevent vite from obscuring rust errors
  clearScreen: false,
  // 2. tauri expects a fixed port, fail if that port is not available
  server: {
    port: 1420,
    strictPort: true,
    host: host || false,
    hmr: host
      ? {
          protocol: "ws",
          host,
          port: 1421,
        }
      : undefined,
    watch: {
      // 3. tell vite to ignore watching `src-tauri`
      ignored: ["**/src-tauri/**"],
    },
  },
}));

</code></pre>
<p>测试一下能否正常使用组件，直接在App.vue中添加，可以看到新添加的按钮就完成了。</p>
<pre><code class="language-diff">+ &lt;a-button type="primary" html-type="submit"&gt;test&lt;/a-button&gt;
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102924495-903770272.png" alt="image" title="展示UI的组件使用" loading="lazy"></p>
<p>‍</p>
<h3 id="02-23-路径指向">0.2 2.3 路径指向</h3>
<p>等会准备页面时将会拆分成各部分组件再引入，这里配置@来引用各部分组件，首先先安装<code>@types/node</code>​：</p>
<pre><code class="language-poowershell">npm install @types/node
</code></pre>
<p>接着配置<code>vite.config.ts</code>​：</p>
<pre><code class="language-diff">+import { resolve } from 'path';

const host = process.env.TAURI_DEV_HOST;

export default defineConfig(async () =&gt; ({
  plugins: [
      vue(),
      Components({
          resolvers: [
              AntDesignVueResolver({
                  importStyle: false,
              }),
          ],
      }),
  ], 
+  resolve: {
+   alias: [
+      {
+        find: '@',
+          replacement: resolve(__dirname, './src')
+     }
+    ]
+  },
</code></pre>
<p>根目录下<code>tsconfig.json</code>​文件中接着配置：</p>
<pre><code class="language-diff">{
   /*注意添加在这里*/ 
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

+   "baseUrl": ".",
+   "paths": {
+      "@/*": ["src/*"]
+    }
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

</code></pre>
<p>验证一下，新建一个目录：<code>/src/components</code>​并将前面测试ui组件的代码单独放入一个组件：</p>
<pre><code class="language-vue">&lt;script setup lang="ts"&gt;
&lt;/script&gt;

&lt;template&gt;
  &lt;a-button type="primary" html-type="submit"&gt;test&lt;/a-b
utton&gt;
&lt;/template&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>然后在<code>App.vue</code>​中引入方式修改：</p>
<pre><code class="language-diff">- import { Button } from 'ant-design-vue';
+ import Test from "@/components/Test.vue";

- &lt;Button type="primary" html-type="submit"&gt;test&lt;/Button&gt;
+ &lt;Test /&gt;
</code></pre>
<p>显示的效果是一样的，相比使用../这种相对路径引入，因为@指向绝对路径，从项目根目录开始解析，所以在以后移动文件时就不用修改路径。</p>
<p>‍</p>
<h3 id="03-24-页面布局">0.3 2.4 页面布局</h3>
<p>将<code>App.vue</code>​中的内容清空，先设定一个大概的布局，如下划分：</p>
<pre><code class="language-html">&lt;script setup lang="ts"&gt;
const headerStyle = { backgroundColor: 'aquamarine' }
const contentStyle = { backgroundColor: 'aqua', padding: '10px' }
const footerStyle = { backgroundColor: 'chartreuse' }
&lt;/script&gt;

&lt;template&gt;
  &lt;a-layout style="height: 100vh;"&gt;
    &lt;a-layout-header :style="headerStyle"&gt;
      Header
    &lt;/a-layout-header&gt;

    &lt;a-layout-content :style="contentStyle"&gt;
      Content
    &lt;/a-layout-content&gt;

    &lt;a-layout-footer :style="footerStyle"&gt;
      Footer
    &lt;/a-layout-footer&gt;
  &lt;/a-layout&gt;
&lt;/template&gt;
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102924780-1313164519.png" alt="image" title="确定大致的布局结构" loading="lazy"></p>
<p>在components目录下创建三个组件： <code>Footer.vue</code>​，<code>Content.vue</code>​， <code>Header.vue</code>​，这里以footer为例：</p>
<pre><code class="language-html">&lt;script setup lang="ts"&gt;
&lt;/script&gt;

&lt;template&gt;
  &lt;a-flex gap="middle" justify="space-between"&gt;
    &lt;span&gt;By Lockly&lt;/span&gt;
    &lt;a-badge status="success" text="v1.0.0"/&gt;
  &lt;/a-flex&gt;
&lt;/template&gt;

&lt;style scoped&gt;
&lt;/style&gt;
</code></pre>
<p>‍</p>
<h3 id="04-25-全局主题">0.4 2.5 全局主题</h3>
<p>颜狗时刻，由于这个4.0 版本中默认提供了三套预设算法，这里就使用默认+紧凑的组合（当然还有暗色，看自己喜好，具体内容参见<a href="https://www.antdv.com/docs/vue/customize-theme-cn" target="_blank" rel="noopener nofollow">官方文档</a>），让页面美观些：</p>
<pre><code class="language-html">  &lt;a-configProvider :theme="{
      algorithm: [defaultAlgorithm, compactAlgorithm],
    }"
  &gt;
	&lt;!-- ... 自己的内容 --&gt;
&lt;/a-configProvider&gt;
</code></pre>
<p>‍</p>
<p>‍</p>
<h2 id="1-3-后端实现">1. 3. 后端实现</h2>
<h3 id="11-31-命令调用">1.1 3.1 命令调用</h3>
<p>前面是将版本和作者都写死在前端，接下来看怎么和后端通讯来获取。还是以footer为例，版本号和作者在<code>src-tauri/Cargo.toml</code>​中是有定义的，修改环境变量：</p>
<pre><code class="language-toml">[package]
name = "shadowmeld"
version = "0.1.0"
description = "A Tauri App"
authors = ["Lockly"]
edition = "2024"
</code></pre>
<p>然后可以使用<code>env! </code>​宏来获取 <code>version</code>​ 和 <code>authors</code>​ 字段，Tauri 官方推荐的核心通信方式是使用命令调用，即使用 <code>#[tauri::command]</code>​ 宏定义函数，并注册到 Tauri 上下文：</p>
<pre><code class="language-rust">#[tauri::command]
fn get_version() -&gt; String {
    env!("CARGO_PKG_VERSION").to_string()
}

#[tauri::command]
fn get_author() -&gt; String {
    env!("CARGO_PKG_AUTHORS").to_string()
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .invoke_handler(tauri::generate_handler![get_version, get_author]) // 在这里注册命令
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
</code></pre>
<p>这样就可以在前端使用 <code>invoke</code>​ 方法来调用Rust函数，这是支持异步的：</p>
<pre><code class="language-rust">&lt;script setup lang="ts"&gt;
import { onMounted, ref, computed } from 'vue'
import { invoke } from "@tauri-apps/api/core";

const version = ref('')
const author = ref('')

const formattedVersion = computed(() =&gt; `V ${version.value}`)

onMounted(async () =&gt; {
  try {
    author.value = await invoke('get_author')
    version.value = await invoke('get_version')
  } catch (error) {
    console.error('Error fetching version or author:', error)
  }
})
&lt;/script&gt;

&lt;template&gt;
  &lt;a-flex gap="middle" justify="space-between"&gt;
    &lt;span&gt;By {{author}}&lt;/span&gt;
    &lt;a-badge status="success" :text="formattedVersion"/&gt;
  &lt;/a-flex&gt;
&lt;/template&gt;

&lt;style scoped&gt;

&lt;/style&gt;
</code></pre>
<p>页面能正常得到后端数据并显示：</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102925111-188008315.png" alt="image" title="以Footer的实现为示例" loading="lazy"></p>
<p>‍</p>
<h3 id="12-32-事件机制">1.2 3.2 事件机制</h3>
<p>涉及到状态栏的变化实现，首先头部应该是提示使用者完善表单，当校验无误后点击执行，此时头部应该显示为加载中，这一点就需要后端向前端发送事件，前端监听响应。这点就需要用到<code>事件机制</code>​，他是实现前端（Web 页面）与后端（Rust 代码）双向通信的核心方式。</p>
<p>首先在前端先监听响应，则需要用到<code>@tauri-apps/api/event</code>​中的<code>listen</code>​。例如假设show用于控制某个组件的显隐：</p>
<pre><code class="language-html">import { listen } from '@tauri-apps/api/event';

listen('backend-event', (event) =&gt; {
  if (event.payload === 1 ) {
	show.value == true;
  } else {
	show.value == false;
  }
});
</code></pre>
<p>在这里定义了一个事件名称<code>backend-event</code>​，命名规范并且前后对应就好。然后来到后端在我们需要发送消息的地方使用：</p>
<pre><code class="language-rust">window.emit("backend-event", 1).unwrap();
</code></pre>
<p>这里我是传一个1过去，此处可传空消息或者json序列化的内容。然后window怎么定义的呢，同前面的app一样，比如我这个调用方法为<code>process_files</code>​，如下：</p>
<pre><code class="language-diff">#[tauri::command]
fn process_files(
      app: tauri::AppHandle,
+     window: tauri::Window,
   	  image_path: String,
 	  shellcode_path: String,
      secret_key: String,
) -&gt; String {
	window.emit("backend-event", "hi").unwrap();
}
</code></pre>
<p>以上是后向前，前向后的通信我此处用不上，但还是写一些。从前端发送就是注意它会自动序列化为json，比如：</p>
<pre><code class="language-typescript">import { emit } from '@tauri-apps/api/event';

// 无数据
await emit('frontend-to-backend-event');

// 自动序列化为 JSON
await emit('user-login', { username: 'Lockly', token: '123' });
</code></pre>
<p>后端通过 <code>AppHandle</code>​ 或事件循环监听：</p>
<pre><code class="language-rust">use tauri::{AppHandle, Manager, Event};

// 监听所有frontend-to-backend-event
app.listen_global("frontend-to-backend-event", |event| {
    println!("收到前端事件，数据: {:?}", event.payload());
});


app.window().listen("user-login", |event| {
    let payload: Option&lt;LoginData&gt; = event.payload(); // 自动反序列化
    // ...
});
</code></pre>
<p>至于多窗口此处不涉及就不接着写了。</p>
<p>‍</p>
<h3 id="13-33-功能实现">1.3 3.3 功能实现</h3>
<h4 id="131-331-打开外部链接">1.3.1 3.3.1 打开外部链接</h4>
<p>因为工具简单也没必要留个关于页面，索性就直接打开GitHub链接，这一点跟wails一样也已经有现成的api： <code>shell</code>​。先安装插件：</p>
<pre><code class="language-powershell">npm run tauri add shell
</code></pre>
<p>在<code>foot.vue</code>​中使用<code>open</code>​即可：</p>
<pre><code class="language-typescript">import { open } from '@tauri-apps/plugin-shell';

const openGitHub = async () =&gt; { 
  await open('https://github.com/BKLockly/ShadowMeld'); 
}
</code></pre>
<p>‍</p>
<p>‍</p>
<h4 id="132-332-获取本地图片路径">1.3.2 3.3.2 获取本地图片路径</h4>
<p>要获取本地图片的绝对路径会用到dialog插件，先添加依赖：</p>
<pre><code class="language-powershell">npm run tauri add dialog
</code></pre>
<p>如官方给出的例子这样使用可获得路径：</p>
<pre><code class="language-typescript">import { open } from '@tauri-apps/plugin-dialog';

// Open a dialog
const file = await open({
  multiple: false,
  directory: false,
});
console.log(file);
// Prints file path and name to the console
</code></pre>
<p>而对于在rust中使用dialog的例子如下：</p>
<pre><code class="language-typescript">use tauri_plugin_dialog::DialogExt;

let file_path = app.dialog().file().blocking_pick_file();
// return a file_path `Option`, or `None` if the user closes the dialog
</code></pre>
<p>这里可能会有疑问这个app是怎么定义的呢？他的类型为AppHandle ，是通过 Tauri 的运行时自动传递的，不能直接在函数中初始化。得通过 Tauri 的上下文来获取，那么直接传入即可例如：<code>fn process_files(app: tauri::AppHandle, image_path: String, shellcode_path: String) -&gt; String {...}</code>​ 而在前端invoke时只需要传入后两个参数即可。</p>
<p>‍</p>
<h4 id="133-333-图片转换">1.3.3 3.3.3 图片转换</h4>
<p>得到图片的绝对路径后现在的问题是前端是无法访问的，但tauri中提供了api，即使用<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Ftauri.app%2Fv1%2Fapi%2Fjs%2Ftauri%2F%23convertfilesrc" title="https://tauri.app/v1/api/js/tauri/#convertfilesrc" target="_blank" rel="noopener nofollow">convertFileSrc</a></strong>，首先安装一下插件：</p>
<pre><code class="language-powershell">npm add @tauri-apps/api
</code></pre>
<p>他可以将一个将本地文件路径转换为可在 Webview 中安全加载的 URL。但是我此时搜到的在<code>tauri.conf.json</code>​中的配置都是过时的（用不了了），比如：</p>
<pre><code class="language-json">{
    "allowlist": {
        "dialog": {
            "all": true,
            "open": true
        },
        "protocol": {
            "all": false,
            "asset": true,
            "assetScope": [
                "$PICTURE"
            ]
        }
    },
    "security": {
        "csp": "default-src 'self'; img-src 'self'; asset: https://asset.localhost"
    }
}
</code></pre>
<p>这样配置必定爆： <code>Error tauri.conf.json error on app: Additional properties are not allowed ('allowlist' was unexpected)</code>​。说明如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102925519-1986387150.png" alt="image" title="官方文档说明" loading="lazy"></p>
<p>首先是配置csp以允许加载本地资源和特定域名的图片</p>
<pre><code class="language-json">"csp": "default-src 'self'; img-src 'self' data: blob: asset: https://asset.localhost"
</code></pre>
<p>然后配置层级结果已经发生改变，应如下：</p>
<pre><code class="language-json">  "app": {
    "windows": [
      {
        "title": "ShadowMeld",
        "width": 450,
        "height": 600
      }
    ],
    "security": {
      "assetProtocol": {
        "enable": true
      },
      "csp": "default-src 'self' 'unsafe-inline' 'unsafe-eval'; img-src 'self' asset://localhost data:; font-src 'self' asset://localhost data:; asset: https://asset.localhost"
    }
  },
</code></pre>
<p>回到前端看：</p>
<pre><code class="language-typescript"> const filePath = await open({
      multiple: false,
      filters: [
        { name: 'Image Files', extensions: ['png', 'jpeg', 'jpg'], },
      ]
    })

    if (filePath) {
      formState.imagePath = filePath

      preview.value = convertFileSrc(filePath)
      console.log(preview.value)
    }
// ...
&lt;img :src="preview"/&gt;
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102926214-1444572855.png" alt="image" title="本地图片展示效果" loading="lazy"></p>
<p>‍</p>
<h3 id="14-34-核心功能">1.4 3.4 核心功能</h3>
<p>这次自私一点，暂时不发布源码保证时效性。后续如果使用和支持的人多了再放出来一起学习交流。核心功能主要实现以下两点：</p>
<p>‍</p>
<h3 id="15-35-lsb隐写">1.5 3.5 LSB隐写</h3>
<p>主要实现将shellcode隐匿于图片之中，如果只是简单的直接将shellcode写入图片的RGBA通道的alpha通道中，那就会导致alpha通道的分布不均匀，容易被检测出来。</p>
<p>要提高隐蔽性的话，在这点上就得做出变动。不光只是使用alpha通道，而是把数据分散到所有四个通道，然后采用LSB（最低有效位）隐写。</p>
<p>以目前的效果来试着简单看看对比，用 Stegsolve 的 Image Combiner 来对比一下，xor（将两张图片的像素按位异或。若两张图片完全相同，所有像素异或结果为 <code>0</code>​，即全黑）效果如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102926713-377111733.png" alt="image" title="两图xor的结果" loading="lazy"></p>
<p>这里看着几乎全黑，没有零星的白点。可能是修改的像素点比较少，太稀疏了看不出来。那换用sub，即用一张图减去另一张图的结果：</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102927227-718599650.png" alt="image" title="两图sub的结果" loading="lazy"></p>
<p>原本透明的背景变成了绿色，如果是同一图片，所有像素差值应为0并显示全黑。但这也有意外：</p>
<ul>
<li><strong>Alpha 通道干扰</strong>：如果图片包含透明区域（Alpha 通道为 <code>0</code>​），某些工具在减法计算时会忽略 Alpha 通道，导致透明区域的 RGB 差值被错误解析（例如显示绿色）。</li>
<li><strong>工具处理误差</strong>：Stegsolve 在处理完全相同的图片时，可能因像素格式转换误差（如 RGB 与 RGBA 混用）显示假色。</li>
</ul>
<p>对比原图发现也是这样，目前通过这样比对还是看不出区别，还需要去提取数据和使用其他进行对比，这里不深究了。</p>
<p>‍</p>
<h3 id="16-36-模版生成">1.6 3.6 模版生成</h3>
<p>上面完成了将shellcode写入图片之中，接下来到loader的流程其实就是分离加载，提取出shellcode来执行。但shellcode不能直接写入要进行加密，加密和提取当前目录下的哪张图片是变量，如果每次都要使用者自己修改再编译一次也太过麻烦。</p>
<p>另外考虑到很多人都没有配置rust环境，故使用特殊字符包裹两个变量 image_name 和 key，例如 <code>###IMAGE_NAME###</code>​ 和 <code>###KEY###</code>​。编译模板 loader时，用这些特征值作为占位符。之后就读取模板 文件，查找特征值并替换为新的 image_name 和 key。预先确定一个足够的长度，确保替换后的数据长度与占位符长度一致，避免破坏 EXE 结构。不足的位数用空白填充使用时剥离即可。</p>
<p>‍</p>
<h2 id="2-4-其他">2. 4. 其他</h2>
<h3 id="21-41-更换图标">2.1 4.1 更换图标</h3>
<p>准备一个尺寸为1240 x 1240 的 PNG（图片必须是正方形的，有必要转换一下可以<a href="https://www.aconvert.com/cn/image/jpg-to-png/" target="_blank" rel="noopener nofollow">跳转</a>) ，命名为<code>app-icon.png</code>​，将图片文件放置在项目的根目录。</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102927604-105852859.png" alt="image" title="放置目录的结构示意" loading="lazy"></p>
<p>在根目录下执行后会生成相关尺寸的图标。</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102928529-741983074.png" alt="image" title="npm run tauri icon " loading="lazy"></p>
<p>生成的图标将放置于<code>src-tauri\icons\</code>​，之后tauri会自动使用它。</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102929889-299528861.png" alt="image" title="生成图标的放置目录" loading="lazy"></p>
<p>‍</p>
<h3 id="22-42-12-编译优化">2.2 4.2 1.2 编译优化</h3>
<p>通用方案来缩小一下生成的loader的大小，在<code>cargo.toml</code>​中如下配置：</p>
<pre><code class="language-toml">[profile.release]
codegen-units = 1 
# 允许 LLVM 执行更好的优化。
lto = true 
# 启用链接时优化。
opt-level = "s"
 # 优先考虑小的二进制文件大小。
panic = "abort" 
# 通过禁用 panic 处理程序来提高性能。
strip = true 
# 确保移除调试符号。
</code></pre>
<p>最后使用<code>--release</code>​模式来编译：</p>
<pre><code class="language-powershell">cargo build --release
</code></pre>
<p>‍</p>
<h3 id="23-43-13-打包问题">2.3 4.3 1.3 打包问题</h3>
<p>编译打包成exe后运行发现有问题，但很奇怪但我同时开起<code>npm run tauri dev</code>​后，再刷新页面又正常了。</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102930547-174190102.png" alt="image" title="前端界面无法加载" loading="lazy"></p>
<p>搜了半天没有结果，到后面发现是我根本没注意到打包命令有误，我直接用的<code>cargo build --release</code>​，这样只会对后端代码进行优化编译，而不会处理前端资源的打包。正确的应该使用：</p>
<pre><code class="language-powershell">npm run tauri build
</code></pre>
<p>‍</p>
<h4 id="231-431-131-wix314">2.3.1 4.3.1 1.3.1 Wix314</h4>
<p>但运行后报错，“invalid peer certificate: UnknownIssuer” 提示<strong>Tauri构建过程中无法验证GitHub的SSL证书</strong>，导致下载<code>wix314-binaries.zip</code>​失败。</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102931543-176073460.png" alt="image" title="wix314-binaries.zip下载失败" loading="lazy"></p>
<p>直接下载提示的<a href="https://github.com/wixtoolset/wix3/releases/download/wix3141rtm/wix314-binaries.zip" target="_blank" rel="noopener nofollow">链接</a>内容，将其解压于<code>$USERPROFILE\AppData\Local\tarui\WixTools314</code>​：</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102933512-1048313957.png" alt="image" title="目录结构示意" loading="lazy"></p>
<p>清理掉残留的旧文件然后再次尝试打包，但因为要使用发布模式来减小生成物体积故加上参数<code>'-- --release'</code>​：</p>
<pre><code class="language-powershell">cls; cargo clean; npm run tauri build '-- --release'
</code></pre>
<p>‍</p>
<h4 id="232-432-132-nsis">2.3.2 4.3.2 1.3.2 NSIS</h4>
<p>但遇到同样的问题如下：</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102936039-356592374.png" alt="image" title="NSIS下载失败" loading="lazy"></p>
<p>同样的操作先自行下载<a href="https://github.com/tauri-apps/binary-releases/releases/download/nsis-3/nsis-3.zip" target="_blank" rel="noopener nofollow">链接</a>内容，解压至最终如下（注意目录名为<strong>NSIS</strong>）：</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102937598-466617649.png" alt="image" title="目录结构示意" loading="lazy"></p>
<p>接着还需要下载<a href="https://github.com/tauri-apps/binary-releases/releases/download/nsis-plugins-v0/NSIS-ApplicationID.zip" target="_blank" rel="noopener nofollow">NSIS-ApplicationID</a>插件，解压至<code>NSIS/Plugin</code>​目录下：</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102939130-1051339811.png" alt="image" title="目录结构示意" loading="lazy"></p>
<p>接着将<code>NSIS-ApplicationID\\ReleaseUnicode\\ApplicationID.dll</code>​复制到<code>NSIS/Plugins/x86-unicode</code>​下。</p>
<p>然后下载<a href="https://github.com/tauri-apps/nsis-tauri-utils/releases/download/nsis_tauri_utils-v0.4.2/nsis_tauri_utils.dll" target="_blank" rel="noopener nofollow"><code>nsis\\\_tauri\\\_utils.dll</code></a>​复制到<code>NSIS/Plugins/x86-unicode</code>​下（这里的链接可能会更新，根据他报错提示的来就好，同样的报错我不贴图了），最后再试一次ok，大约6MB：</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102940391-2121685977.png" alt="image" title="最终生成物以及大小" loading="lazy"></p>
<p>‍</p>
<h2 id="3-5-2-效果">3. 5. 2. 效果</h2>
<p>以下测试均<u><strong>不包含任何</strong></u>反沙箱手段，加载shellcode的方式也仅为传统直接的创建线程执行。loader本体不压缩不添加资源和签名，接下来loader和图片都直接裸奔测试。</p>
<p>‍</p>
<h3 id="31-21-沙箱">3.1 2.1 沙箱</h3>
<h4 id="311-211-virustotal">3.1.1 2.1.1 VirusTotal</h4>
<p>vt检出loader为<code>1/73</code>​， 图片为<code>0/61</code>​:</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102941237-1672694754.png" alt="image" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102941779-1837747311.png" alt="image" loading="lazy"></p>
<p>‍</p>
<h3 id="360云沙箱">360云沙箱</h3>
<p>均未检出。</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102942248-1312444613.png" alt="image" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102942751-1009166086.png" alt="image" loading="lazy"></p>
<p>‍</p>
<h4 id="312-微步云沙箱">3.1.2 微步云沙箱</h4>
<p>这里提到检测出url -&gt; <code>http://ns.adobe</code>​, 问了deepseek说原因可能如下：</p>
<ol>
<li>图像元数据残留：使用了 image 库处理 PNG 文件。PNG 格式可能包含 XMP 元数据（Adobe 的标准元数据格式），这些字符串会被 image 库读取到内存中。</li>
<li>依赖库的隐式行为：image 库在解码 PNG 时，可能触发对 Adobe 命名空间（如 <a href="http://ns.adobe.com/xap/1.0/%EF%BC%89%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%8C%E5%B0%A4%E5%85%B6%E6%98%AF%E5%A4%84%E7%90%86%E7%94%B1" target="_blank" rel="noopener nofollow">http://ns.adobe.com/xap/1.0/）的引用，尤其是处理由</a> Photoshop 生成的 PNG 文件时。</li>
</ol>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102943267-1364828073.png" alt="image" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102943847-459886715.png" alt="image" loading="lazy"></p>
<p>‍</p>
<p>‍</p>
<h4 id="313-安恒云沙箱">3.1.3 安恒云沙箱</h4>
<p>图片和loader均报告安全：</p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102944460-1713962600.png" alt="image" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102945251-1610934838.png" alt="image" loading="lazy"></p>
<p>‍</p>
<h3 id="32-上线测试">3.2 上线测试</h3>
<p>尽管没有使用任何反沙箱手段，甚至都还弹黑框，但如下所示测试动静态均已通过。</p>
<p>‍</p>
<h4 id="321-腾讯电脑管家">3.2.1 腾讯电脑管家</h4>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102946105-1830594389.png" alt="image" loading="lazy"></p>
<p>‍</p>
<h4 id="322-火绒">3.2.2 火绒</h4>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102946847-900428375.png" alt="image" loading="lazy"></p>
<p>‍</p>
<h4 id="323-360">3.2.3 360</h4>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102947859-2101203649.png" alt="image" loading="lazy"></p>
<p>‍</p>
<h4 id="324-defender">3.2.4 Defender</h4>
<p><img src="https://img2023.cnblogs.com/blog/3038812/202503/3038812-20250317102948550-1109597194.png" alt="image" loading="lazy"></p>
<p>‍</p>
<p>‍</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.32608586886689817" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-17 10:30">2025-03-16 20:36</span>&nbsp;
<a href="https://www.cnblogs.com/bktown">lockly</a>&nbsp;
阅读(<span id="post_view_count">95</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18775589" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18775589);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18775589', targetLink: 'https://www.cnblogs.com/bktown/p/18775589/tauri-newbie-shellcode-loader-based-on-lsb-steganography-zfguxj', title: 'Tauri新手向 - 基于LSB隐写的shellcode加载器' })">举报</a>
</div>
        