
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Sinktank/p/19045786" title="发布于 2025-08-19 07:53">
    <span role="heading" aria-level="2">[笔记]CDQ 分治</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        曾经拥有真的太好了
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前">前</h2>
<p><strong>CDQ 分治</strong>是一种分治算法，或者说是一种思想，其主要内容是：将序列通过递归的方式分给左右两个区间，每一个子问题<strong>只处理跨左右区间的贡献</strong>。</p>
<p>使用 CDQ 分治建立在排序的基础上，这也说明 CDQ 分治必须离线使用。</p>
<p>CDQ 分治可以解决的问题：</p>
<ul>
<li>与点对有关的问题（数点 &amp; 偏序）。</li>
<li>将带修改 &amp; 查询的动态问题，转化为静态问题。</li>
<li>优化 1D / 1D 动态规划的转移。</li>
</ul>
<p>本质上，这些问题都属于“点对之间的贡献问题”。</p>
<h2 id="点对有关问题">点对有关问题</h2>
<h3 id="一些概念">一些概念</h3>
<h4 id="偏序">偏序</h4>
<p><strong><span class="math inline">\(k\)</span> 维偏序问题</strong>，即在一个由 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(k\)</span> 元组构成的集合 <span class="math inline">\(\{(a_{1,1},\dots,a_{1,k}),\dots,(a_{n,1},\dots,a_{n,k})\}\)</span> 中，求与 <span class="math inline">\((a_{i,1},\dots,a_{i,k})\)</span> 满足某种偏序关系，即 <span class="math inline">\((a_{i,1},\dots,a_{i,k})\prec(a_{j,1},\dots,a_{j,k})\)</span> 的 <span class="math inline">\(j\)</span> 的个数。</p>
<p>这其中，“<span class="math inline">\(\prec\)</span>” 是一种具有<strong>自反性、反对称性、传递性</strong>的二元关系，例如：</p>
<ul>
<li>二维偏序 <span class="math inline">\((a,b)\)</span> 中，<span class="math inline">\(a_i\le a_j,\ b_i&lt;b_j\)</span></li>
<li>三维偏序 <span class="math inline">\((a,b,c)\)</span> 中，<span class="math inline">\(a_i&gt;a_j,\ b_i\le b_j,c_i\le c_j\)</span></li>
<li><span class="math inline">\(\dots\)</span></li>
</ul>
<p>逆序对就是常见的二维偏序问题，此时这个集合可以写为 <span class="math inline">\(\{(1,a_1),\dots,(n,a_n)\}\)</span>。</p>
<h4 id="数点">数点</h4>
<p><strong><span class="math inline">\(k\)</span> 维数点问题</strong>，即在一个由 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(k\)</span> 元组构成的集合 <span class="math inline">\(\{(a_{1,1},\dots,a_{1,k}),\dots,(a_{n,1},\dots,a_{n,k})\}\)</span> 中，求满足下列条件的 <span class="math inline">\(k\)</span> 元组 <span class="math inline">\((a_{j,1},\dots,a_{j,k})\)</span> 的个数 / 权值和：</p>
<ul>
<li><span class="math inline">\(l_1\le a_{j,1}\le r_1\)</span></li>
<li><span class="math inline">\(\dots\)</span></li>
<li><span class="math inline">\(l_n\le a_{j,n}\le r_n\)</span></li>
</ul>
<p>可以理解为在 <span class="math inline">\(k\)</span> 维平面上给定若干点，查询某个区域内点的个数。</p>
<h3 id="二维偏序">二维偏序</h3>
<blockquote>
<p>例 <span class="math inline">\(1\)</span>：给定 <span class="math inline">\(n\)</span> 个二元组，对每一组 <span class="math inline">\((x_i,y_i)\)</span>，求满足 <span class="math inline">\(x_j&lt;x_i,y_j&lt;y_i\)</span> 的 <span class="math inline">\(j\)</span> 的个数（为了方便，我们假定 <span class="math inline">\(x\)</span> 两两不同）。</p>
</blockquote>
<p>比较暴力的方法就是枚举 <span class="math inline">\(i,j\)</span> 并统计，这样子解决 <span class="math inline">\(k\)</span> 维偏序的时间复杂度是 <span class="math inline">\(O(n^2k)\)</span>。</p>
<p>我们有很多策略来优化这个时间复杂度，而这些策略有一个共同的思想 —— <strong>降维</strong>。</p>
<p>实现降维，我们有很多方式，例如：</p>
<ul>
<li>排序</li>
<li>数据结构</li>
<li>CDQ 分治</li>
</ul>
<p>这些东西可以结合起来使用，每使用一个就会降掉一维。拿该问题举例：</p>
<ul>
<li><strong>排序 + 数据结构</strong>：先按 <span class="math inline">\(x\)</span> 从小到大排序，然后依次遍历每一个 <span class="math inline">\(y_i\)</span>，先查询树状数组中 <span class="math inline">\(&lt;y_i\)</span> 的个数，作为 <span class="math inline">\(i\)</span> 的答案，再将 <span class="math inline">\(y_i\)</span> 扔进树状数组。</li>
<li><strong>数据结构 + 数据结构</strong>：<a href="https://www.cnblogs.com/Sinktank/p/18962079" target="_blank">树套树</a>，外层维护 <span class="math inline">\(x\)</span>，内层维护 <span class="math inline">\(y\)</span>。</li>
<li><strong>排序 + CDQ 分治</strong>：见下。</li>
</ul>
<p>一般来说，排序仅能使用一次，放在最外层；而数据结构如果嵌套超过 <span class="math inline">\(1\)</span> 层，就会带来较大的常数 &amp; 空间消耗（例如树套树的空间一般是 <span class="math inline">\(O(n\log^2 n)\)</span> 的，题目卡空间的话就没办法了）。因此应对更高维的偏序，可嵌套且时空常数小的 CDQ 分治是必不可少的。</p>
<p>CDQ 分治必须配合排序使用，为此我们先按 <span class="math inline">\(x\)</span> 从小到大为这些二元组排序。</p>
<p>接下来我们从 <span class="math inline">\([1,n]\)</span> 开始，逐层递归，分出子问题来求解。</p>
<p>具体来说，对于 <span class="math inline">\([l,r]\)</span> 这个子问题：</p>
<ul>
<li>令 <span class="math inline">\(mid\)</span> 为 <span class="math inline">\(l,r\)</span> 的中点。</li>
<li>递归地解决 <span class="math inline">\([l,mid],[mid+1,r]\)</span>。</li>
<li>统计 <span class="math inline">\([l,mid]\)</span> 对 <span class="math inline">\([mid+1,r]\)</span> 的贡献。</li>
</ul>
<p>其中第三步，我们可以将左右区间分别按 <span class="math inline">\(y\)</span> 从小到大排序，并用双指针 <span class="math inline">\(i,j\)</span> 分别指向 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(mid+1\)</span>，即两个区间的开头。</p>
<p>尽管这样破坏了 <span class="math inline">\(x\)</span> 的顺序，但由于是左右区间内部的排序，所以对于所有 <span class="math inline">\(i\in [l,mid],j\in [mid+1,r]\)</span>，总有 <span class="math inline">\(x_i&lt;x_j\)</span>。</p>
<p>第一维的限制已经被开始时的排序解决掉了。</p>
<p>所以，我们仅需统计 <span class="math inline">\(y_i&lt;y_j\)</span> 的个数。这个用双指针扫一遍即可：</p>
<pre><code class="language-cpp">struct Node{int x,y,id;}a[N];
inline bool cmpx(Node&amp; a,Node&amp; b){return a.x&lt;b.x;};
inline bool cmpy(Node&amp; a,Node&amp; b){return a.y&lt;b.y;};
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j;
	cdq(l,mid),cdq(mid+1,r);
	sort(a+l,a+mid+1,cmpy),sort(a+mid+1,a+r+1,cmpy);
	for(i=l,j=mid+1;j&lt;=r;j++){
		while(i&lt;=mid&amp;&amp;a[i].y&lt;a[j].y) i++;
		ans[a[j].id]+=i-l;
	}
}
//main
sort(a+1,a+1+n,cmpx);
cdq(1,n);
</code></pre>
<p>这样做时间复杂度是 <span class="math inline">\(O(n\log^2 n)\)</span> 的。</p>
<p>一个常用的技巧是在递归的过程中进行 <span class="math inline">\(y\)</span> 的归并排序，这样就优化为 <span class="math inline">\(O(n\log n)\)</span> 了。</p>
<pre><code class="language-cpp">struct Node{int x,y,id;}a[N];
inline bool cmpx(Node&amp; a,Node&amp; b){return a.x&lt;b.x;};
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		while(i&lt;=mid&amp;&amp;a[i].y&lt;a[j].y) t[k++]=a[i++];
		ans[a[j].id]+=i-l,t[k++]=a[j++];
	}
	while(i&lt;=mid) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
//main
sort(a+1,a+1+n,cmpx);
cdq(1,n);
</code></pre>
<p>看上去有点熟悉？其实这就是归并排序求逆序对啦～</p>
<p>归并排序求逆序对在本质上可以看做 CDQ 分治的一个简单应用。</p>
<p>这样子先按 <span class="math inline">\(x\)</span> 排序，再按 <span class="math inline">\(y\)</span> 的顺序进行合并，我们称之为“对 <span class="math inline">\(x\)</span> 分治，按照 <span class="math inline">\(y\)</span> 合并”。</p>
<blockquote>
<p>例 <span class="math inline">\(2\)</span>：给定 <span class="math inline">\(n\)</span> 个二元组，对每一组 <span class="math inline">\((x_i,y_i)\)</span>，求满足 <span class="math inline">\(x_j\le x_i,y_j\le y_i\)</span> 的 <span class="math inline">\(j\)</span> 的个数。</p>
</blockquote>
<p>思路是一样的，不过要注意两个细节问题：</p>
<ul>
<li>
<p>从上面的代码，我们发现到 CDQ 分治始终是单向统计贡献（一般令左区间给右区间），双向的贡献无法用 CDQ 很好地维护。</p>
<p>而在此题条件下，重复的元素会相互产生贡献。为此我们将原数组进行去重，并记录每个元素在原序列的出现次数。</p>
</li>
<li>
<p>另外由于 <span class="math inline">\(x\)</span> 可能有重复元素，所以我们在主函数的排序过程中，<span class="math inline">\(x\)</span> 相等时要再按 <span class="math inline">\(y\)</span> 进行排序。否则可能有两个 <span class="math inline">\(x\)</span> 相同的元素，<span class="math inline">\(y\)</span> 小的被放在右区间，<span class="math inline">\(y\)</span> 大的被放在左区间，这样前者永远无法为后者提供贡献，就错了。</p>
</li>
</ul>
<pre><code class="language-cpp">int idx,w[N];//w记录去重后每个元素在原序列的出现次数
struct Node{int x,y,id;}a[N];
inline bool cmpx(Node&amp; a,Node&amp; b){return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;};
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k,c=0;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		while(i&lt;=mid&amp;&amp;a[i].y&lt;=a[j].y) c+=w[a[i].id],t[k++]=a[i++];//记入贡献
		//1.注意条件是&lt;=  2.加的不是1而是w
		ans[a[j].id]+=i-l,t[k++]=a[j++];//统计贡献
	}
	while(i&lt;=mid) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
//main
sort(a+1,a+1+n,cmpx);
for(int i=1;i&lt;=n;i++){//相同元素合并起来
	if(a[i].x==a[idx].x&amp;&amp;a[i].y==a[idx].y) w[idx]++;
	else a[++idx]=a[i],a[idx].id=idx,w[idx]=1;
}
for(int i=1;i&lt;=idx;i++) ans[i]=w[i];
cdq(1,idx);
</code></pre>
<blockquote>
<p>需要留心的是，在例 <span class="math inline">\(1\)</span> 中，我们假定了 <span class="math inline">\(x\)</span> 值互不相同。</p>
<p>如果存在相同的 <span class="math inline">\(x\)</span>，就无法保证“左区间的 <span class="math inline">\(x\)</span> <span class="math inline">\(&lt;\)</span> 右区间的 <span class="math inline">\(x\)</span>”，因此不能完全套用上面的做法。</p>
<p>因为题目一般不会严苛到 <span class="math inline">\(k\)</span> 个维度都限制“关系严格小于，且有重复元素”，所以这个问题基本不会遇到，我们可以先不管。</p>
<p>然而作为 CDQ 分治的一个 corner case，这样的小问题是不容忽视的，我们会在文章后的“细节” 部分讨论该问题的解决方法。</p>
</blockquote>
<h3 id="三维偏序">三维偏序</h3>
<p><a href="https://www.luogu.com.cn/problem/P3810" class="dif6" rel="noopener nofollow">P3810 【模板】三维偏序（陌上花开）</a></p>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 个三元组，记 <span class="math inline">\(f(i)\)</span> 为满足 <span class="math inline">\(a_j\le a_i,b_j\le b_i,c_j\le c_i\)</span> 且 <span class="math inline">\(j\ne i\)</span> 的 <span class="math inline">\(j\)</span> 的个数。</p>
<p>对于 <span class="math inline">\(d\in[0,n)\)</span>，求满足 <span class="math inline">\(f(i)=d\)</span> 的 <span class="math inline">\(i\)</span> 的个数。</p>
</blockquote>
<p>比较常见的做法：</p>
<ul>
<li><strong>排序 + 数据结构 + 数据结构</strong>：先通过排序将第一维离线，剩下就是二维偏序了，树套树即可解决。</li>
<li><strong>排序 + CDQ 分治 + 数据结构</strong>：见下。</li>
<li><strong>排序 + CDQ 分治 + 分治</strong>：见下。</li>
</ul>
<h4 id="排序--cdq-分治--数据结构">排序 + CDQ 分治 + 数据结构</h4>
<p>我们不妨对 <span class="math inline">\(a\)</span> 分治，按 <span class="math inline">\(b\)</span> 合并。</p>
<p>这样，在 <span class="math inline">\(j\)</span> 指针统计贡献时，左区间内被记入的贡献已经满足了 <span class="math inline">\(a_i\le a_j,b_i\le b_j\)</span>，怎么统计 <span class="math inline">\(c_i\le c_j\)</span> 的 <span class="math inline">\(i\)</span> 的个数呢？</p>
<p>很自然地想到用数据结构来维护。左指针 <span class="math inline">\(i\)</span> 记入贡献时，在其上修改 <span class="math inline">\(c_i\)</span> 处的值；右指针 <span class="math inline">\(j\)</span> 统计贡献时，在其上查询 <span class="math inline">\(\le c_j\)</span> 的总和即可。</p>
<p>所选的数据结构只需要支持单点修改、前缀查询，果断选择树状数组。毕竟常数才是制胜之法～</p>
<p>同样需要注意两个细节：</p>
<ul>
<li>
<p>不要忘记去重～</p>
</li>
<li>
<p>主函数中要按 <span class="math inline">\(a,b,c\)</span> 三个关键字排序，<span class="math inline">\(b,c\)</span> 顺序无所谓。</p>
<p>想一想，<code>cdq</code> 内部对 <span class="math inline">\(b\)</span> 的排序时，如果 <span class="math inline">\(b\)</span> 相等还需要按 <span class="math inline">\(c\)</span> 排吗？</p>
<p>这个是不需要的，因为 <span class="math inline">\(b\)</span> 值相同时，无论 <span class="math inline">\(c\)</span> 顺序如何，记入贡献总是在统计贡献之前，对答案不影响。</p>
</li>
</ul>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/229522693" rel="noopener nofollow">R229522693</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e5+10,V=2e5+10;
int n,k,w[N],f[N],idx,ans[N];
struct Node{int a,b,c,id;}a[N],t[N];
inline bool cmpa(Node&amp; a,Node&amp; b){return a.a==b.a?(a.b==b.b?a.c&lt;b.c:a.b&lt;b.b):a.a&lt;b.a;}
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[V];
	inline void chp(int x,int v){for(;x&lt;=k;x+=lb(x)) s[x]+=v;}
	inline void clr(int x){for(;x&lt;=k;x+=lb(x)) if(s[x]) s[x]=0;else return;}
	//注意clr不能单独使用，因为经过的位置全部置为0会破坏树状数组的性质（另外这个小优化亲测是有效果的）
	inline int query(int x){int ans=0;for(;x;x-=lb(x)) ans+=s[x];return ans;}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;j++){
		while(i&lt;=mid&amp;&amp;a[i].b&lt;=a[j].b) bit.chp(a[i].c,w[a[i].id]),t[k++]=a[i++];
		f[a[j].id]+=bit.query(a[j].c),t[k++]=a[j];
	}
	for(j=l;j&lt;i;j++) bit.clr(a[j].c);//记得清空
	while(i&lt;=mid) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;k;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].a&gt;&gt;a[i].b&gt;&gt;a[i].c;
	sort(a+1,a+1+n,cmpa);
	for(int i=1;i&lt;=n;i++){
		if(a[i].a==a[idx].a&amp;&amp;a[i].b==a[idx].b&amp;&amp;a[i].c==a[idx].c) w[idx]++;
		else a[++idx]=a[i],a[idx].id=idx,w[idx]=1;
	}
	cdq(1,idx);
	for(int i=1;i&lt;=idx;i++) ans[f[a[i].id]+w[a[i].id]-1]+=w[a[i].id];
	//这里注意，需要额外统计w-1的贡献
	for(int i=0;i&lt;n;i++) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="排序--cdq-分治--cdq-分治">排序 + CDQ 分治 + CDQ 分治</h4>
<p>就效率来说，CDQ 分治的确比不过常数更小的树状数组。</p>
<p>我们在这里用两层 CDQ 分治来解决，是为了展示 CDQ 分治的可嵌套性，并且为接下来的四维偏序做个铺垫。</p>
<p>回顾我们刚才分治的思路。在对 <span class="math inline">\(a\)</span> 分治的过程中，每一个子问题将其管辖的 <span class="math inline">\(a\)</span> 归为两类，左区间编号为 <span class="math inline">\(L_a\)</span>，右区间编号为 <span class="math inline">\(R_a\)</span>。按 <span class="math inline">\(b\)</span> 合并的过程中，我们规定只有 <span class="math inline">\((L_a,b,c)\)</span> 能对 <span class="math inline">\((R_a,b,c)\)</span> 产生贡献。</p>
<p>放在这个做法，如果一个子问题的 <span class="math inline">\(a\)</span> 已经被分类为了 <span class="math inline">\(L_a,R_a\)</span>，我们就对这些三元组再按 <span class="math inline">\(b\)</span> 排序，左区间编号为 <span class="math inline">\(L_b\)</span>，右区间编号为 <span class="math inline">\(R_b\)</span>。在按 <span class="math inline">\(c\)</span> 合并的过程中，我们规定只有 <span class="math inline">\((L_a,L_b,c)\)</span> 能对 <span class="math inline">\((R_a,R_b,c)\)</span> 产生贡献。</p>
<p>总结一下实现步骤：</p>
<ul>
<li>第一层 CDQ 按 <span class="math inline">\(a\)</span> 分治，按 <span class="math inline">\(b\)</span> 合并，并编号 <span class="math inline">\(L_a,R_a\)</span>，将编号记录在结构体数组中。</li>
<li>第二层 CDQ 按 <span class="math inline">\(b\)</span> 分治，按 <span class="math inline">\(c\)</span> 合并，此时左区间是 <span class="math inline">\(L_b\)</span>，右区间是 <span class="math inline">\(R_b\)</span>。计算贡献时，额外限制只有带 <span class="math inline">\(L_a\)</span> 编号的 <span class="math inline">\(i\)</span> 能记入贡献；带 <span class="math inline">\(R_a\)</span> 编号的 <span class="math inline">\(j\)</span> 能统计贡献。</li>
</ul>
<p>实现细节：</p>
<ul>
<li>
<p>注意去重。</p>
</li>
<li>
<p>主函数中要按 <span class="math inline">\(a,b,c\)</span> 三个关键字排序，<span class="math inline">\(b,c\)</span> 顺序无所谓。</p>
<p><code>cdq2d</code> 中要按 <span class="math inline">\(b,c,a\)</span> 三个关键字排序，<span class="math inline">\(a,c\)</span> 顺序无所谓。之所以要顾及 <span class="math inline">\(a,c\)</span>，是因为 <code>cdq3d</code> 中我们要用到 <span class="math inline">\(a\)</span> 所属的编号以及 <span class="math inline">\(c\)</span>。与之前同理，我们同样要让可能计入贡献的元素尽可能放在左边。</p>
<blockquote>
<p><span id="anchor1"></span><code>stable_sort</code> 是稳定排序，能保证在自定义的排序规则下，相等的元素在排序后<strong>相对顺序不变</strong>。因此，如果你使用 <code>stable_sort</code>，那么 <code>cmp</code> 函数就仅需比较 <span class="math inline">\(b\)</span> 了。</p>
<p><code>stable_sort</code> 的底层实现是归并排序。这也是为什么如果你在 CDQ 的过程中进行归并排序，同样只需比较当前合并的属性。</p>
<p>有关 <code>sort</code> 和 <code>stable_sort</code> 的使用，我们会在“细节” 部分进一步讨论。</p>
</blockquote>
<p><code>cdq3d</code> 中按 <span class="math inline">\(c\)</span> 排序即可。</p>
</li>
</ul>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/229537875" rel="noopener nofollow">R229537875</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e5+10,V=2e5+10;
int n,k,w[N],f[N],idx,ans[N];
struct Node{int a,b,c,id;bool s;}a[N],t2d[N],t3d[N];//s=0/1 对应 Lx/Rx
inline bool cmpa(Node&amp; a,Node&amp; b){return a.a==b.a?(a.b==b.b?a.c&lt;b.c:a.b&lt;b.b):a.a&lt;b.a;}
void cdq3d(int l,int r){//按第3维合并
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k,c=0;
	cdq3d(l,mid),cdq3d(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;j++){
		while(i&lt;=mid&amp;&amp;t2d[i].c&lt;=t2d[j].c){
			if(!t2d[i].s) c+=w[t2d[i].id];//Lx,Ly才能记入贡献
			t3d[k++]=t2d[i++];
		}
		if(t2d[j].s) f[t2d[j].id]+=c;//Rx,Ry才能统计贡献
		t3d[k++]=t2d[j];
	}
	while(i&lt;=mid) t3d[k++]=t2d[i++];
	for(i=l;i&lt;=r;i++) t2d[i]=t3d[i];
}
void cdq2d(int l,int r){//按第2维合并
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq2d(l,mid),cdq2d(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){//仅为x编号，不统计贡献
		while(i&lt;=mid&amp;&amp;a[i].b&lt;=a[j].b) a[i].s=0,t2d[k++]=a[i++];
		a[j].s=1,t2d[k++]=a[j++];
	}
	while(i&lt;=mid) a[i].s=0,t2d[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t2d[i];
	cdq3d(l,r);
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;k;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].a&gt;&gt;a[i].b&gt;&gt;a[i].c;
	sort(a+1,a+1+n,cmpa);
	for(int i=1;i&lt;=n;i++){
		if(a[i].a==a[idx].a&amp;&amp;a[i].b==a[idx].b&amp;&amp;a[i].c==a[idx].c) w[idx]++;
		else a[++idx]=a[i],a[idx].id=idx,w[idx]=1;
	}
	cdq2d(1,idx);
	for(int i=1;i&lt;=idx;i++) ans[f[a[i].id]+w[a[i].id]-1]+=w[a[i].id];
	for(int i=0;i&lt;n;i++) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<blockquote>
<p>经过测试，三种方法的用时分别为：1090ms、320ms、700ms。</p>
</blockquote>
<h3 id="四维偏序">四维偏序</h3>
<p><a href="https://www.luogu.com.cn/problem/U322249" class="dif6" rel="noopener nofollow">U322249 【模板】四维偏序</a></p>
<p>理论上 CDQ 是可以无限嵌套的，你可以照上面的分析写三重 CDQ 来实现。</p>
<p>不过我们这里只提一种，也是最常用、效率相对较高的。</p>
<h4 id="排序--cdq-分治--cdq-分治--数据结构">排序 + CDQ 分治 + CDQ 分治 + 数据结构</h4>
<p>将三维偏序的两个方法结合一下，有了前面的铺垫应该不难理解。</p>
<p>实现步骤：</p>
<ul>
<li>第一层 CDQ 按 <span class="math inline">\(a\)</span> 分治，按 <span class="math inline">\(b\)</span> 合并，并编号 <span class="math inline">\(L_a,R_a\)</span>，将编号记录在结构体数组中。</li>
<li>第二层 CDQ 按 <span class="math inline">\(b\)</span> 分治，按 <span class="math inline">\(c\)</span> 合并，此时左区间是 <span class="math inline">\(L_b\)</span>，右区间是 <span class="math inline">\(R_b\)</span>。计算贡献时，对于带 <span class="math inline">\(L_a\)</span> 编号的 <span class="math inline">\(i\)</span>，将 <span class="math inline">\(d_i\)</span> 加入树状数组；对于带 <span class="math inline">\(R_a\)</span> 编号的 <span class="math inline">\(j\)</span>，在树状数组上查询 <span class="math inline">\(\le d_j\)</span> 的元素个数，并统入 <span class="math inline">\(j\)</span> 的答案。</li>
</ul>
<p>实现细节与上面相同，额外注意树状数组维护的那一维要离散化。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^3 n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/229587835" rel="noopener nofollow">R229587835</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#include&lt;ext/pb_ds/assoc_container.hpp&gt;
#include&lt;ext/pb_ds/hash_policy.hpp&gt;
using namespace std;
using namespace __gnu_pbds;
const int N=1e5+10;
struct Node{int d1,d2,d3,d4,id;bool s;}a[N],t2d[N],t3d[N];
inline bool cmp(Node&amp; a,Node&amp; b){return a.d1==b.d1?(a.d2==b.d2?(a.d3==b.d3?a.d4&lt;b.d4:a.d3&lt;b.d3):a.d2&lt;b.d2):a.d1&lt;b.d1;}
gp_hash_table&lt;int,int&gt; ma;//起到和umap相同的作用，效率一般更高
int n,k,tn,b[N],idx,w[N],f[N],ans[N];
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[N];
	inline void chp(int x,int v){for(;x&lt;=tn;x+=lb(x)) s[x]+=v;}
	inline void clr(int x){for(;x&lt;=tn;x+=lb(x)) if(!s[x]) break;else s[x]=0;}
	inline int query(int x){int ans=0;for(;x;x-=lb(x)) ans+=s[x];return ans;}
}bit;
void cdq3d(int l,int r){//按第3维合并
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq3d(l,mid),cdq3d(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;j++){
		while(i&lt;=mid&amp;&amp;t2d[i].d3&lt;=t2d[j].d3){
			if(!t2d[i].s) bit.chp(t2d[i].d4,w[t2d[i].id]);
			t3d[k++]=t2d[i++];
		}
		if(t2d[j].s) f[t2d[j].id]+=bit.query(t2d[j].d4);
		t3d[k++]=t2d[j];
	}
	for(j=l;j&lt;i;j++) if(!t2d[j].s) bit.clr(t2d[j].d4);
	while(i&lt;=mid) t3d[k++]=t2d[i++];
	for(i=l;i&lt;=r;i++) t2d[i]=t3d[i];
}
void cdq2d(int l,int r){//按第2维合并
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,s;
	cdq2d(l,mid),cdq2d(mid+1,r);
	for(i=s=l,j=mid+1;j&lt;=r;j++){
		while(i&lt;=mid&amp;&amp;a[i].d2&lt;=a[j].d2) a[i].s=0,t2d[s++]=a[i++];
		a[j].s=1,t2d[s++]=a[j];
	}
	while(i&lt;=mid) a[i].s=0,t2d[s++]=a[i++];
	for(int i=l;i&lt;=r;i++) a[i]=t2d[i];
	cdq3d(l,r);
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;k;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].d1&gt;&gt;a[i].d2&gt;&gt;a[i].d3&gt;&gt;a[i].d4,b[i]=a[i].d4;
	sort(b+1,b+1+n),tn=unique(b+1,b+1+n)-b-1;
	for(int i=1;i&lt;=tn;i++) ma[b[i]]=i;
	sort(a+1,a+1+n,cmp);
	for(int i=1;i&lt;=n;i++){
		if(a[i].d1==a[idx].d1&amp;&amp;a[i].d2==a[idx].d2&amp;&amp;a[i].d3==a[idx].d3&amp;&amp;a[i].d4==a[idx].d4) w[idx]++;
		else a[++idx]=a[i],a[idx].id=idx,w[idx]=1;
	}
	for(int i=1;i&lt;=idx;i++) a[i].d4=ma[a[i].d4];
	cdq2d(1,idx);
	for(int i=1;i&lt;=idx;i++) ans[f[a[i].id]+w[a[i].id]-1]+=w[a[i].id];
	for(int i=0;i&lt;n;i++) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<blockquote>
<p>CDQ 嵌套，理论可以做任意维的偏序。</p>
<p>不过常数也会随嵌套而累乘，面对很高维的偏序，CDQ 分治甚至可能劣于 <span class="math inline">\(O(n^2k)\)</span> 的暴力（并未实测）。</p>
<p>题外话：如果维数超过 <span class="math inline">\(5\)</span>，我们一般会采用 <code>bitset</code> 优化的暴力，可达到 <span class="math inline">\(O(\frac{1}{\omega}n^2)\)</span> 的时间复杂度，其中 <span class="math inline">\(\omega=32\)</span>（计算机的位数）。</p>
</blockquote>
<h3 id="数点-1">数点</h3>
<p><span class="math inline">\(k\)</span> 维偏序本质上是在处理 <span class="math inline">\(k\)</span> 维的前缀查询。</p>
<p>我们通过差分，将原查询拆成若干个（<span class="math inline">\(2^k\)</span> 个）前缀查询即可，为每个元素添加 <code>c</code> 属性，值为 <span class="math inline">\(\pm1\)</span>，表示对答案的累加 / 累减。</p>
<p>偏序问题每个元素，既是一个修改，也是一个查询。意味着一个元素既可以计入贡献，又可以统计贡献，取决于其所在的区间。</p>
<p>而数点问题将查询独立出来了，也就是说只有左区间的<strong>修改操作</strong>能计入贡献，右区间的<strong>查询操作</strong>能统计贡献。加粗的部分需要额外限制一下。</p>
<h3 id="例题">例题</h3>
<h4 id="p2163-shoi2007-园丁的烦恼"><a href="https://www.luogu.com.cn/problem/P2163" class="dif4" rel="noopener nofollow">P2163 [SHOI2007] 园丁的烦恼</a></h4>
<p>二维数点模板题。</p>
<p>思路就是二维差分，将矩形 <span class="math inline">\((x_1,y_1,x_2,y_2)\)</span> 拆成四个前缀的查询：</p>
<ul>
<li>加上 <span class="math inline">\((x_2,y_2)\)</span></li>
<li>减去 <span class="math inline">\((x_1-1,y_2)\)</span></li>
<li>减去 <span class="math inline">\((x_2,y_1-1)\)</span></li>
<li>加上 <span class="math inline">\((x_1-1,y_1-1)\)</span></li>
</ul>
<p>时间复杂度 <span class="math inline">\(O((n+m)\log(n+m))\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/229760252" rel="noopener nofollow">R229760252</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=5e5+10,M=5e5+10;
struct Node{int id,x,y,c,k;}a[N+4*M],t[N+4*M];//c=1/-1 表示累加/累减，k=0/1 表示修改/查询
inline bool cmpx(Node&amp; a,Node&amp; b){return a.x==b.x?a.id&lt;b.id:a.x&lt;b.x;}
int n,m,idx,ans[M];
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k,s=0;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;j++){
		for(;i&lt;=mid&amp;&amp;a[i].y&lt;=a[j].y;i++){
			s+=a[i].k;
			t[k++]=a[i];
		}
		ans[a[j].id]+=a[j].c*s;
		t[k++]=a[j];
	}
	while(i&lt;=mid) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;m,idx=n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].x&gt;&gt;a[i].y,a[i].k=1;
	for(int i=1,x,y,xx,yy;i&lt;=m;i++){
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;xx&gt;&gt;yy;//一个询问拆成4个
		a[++idx]={i,xx,yy,1,0};
		a[++idx]={i,xx,y-1,-1,0};
		a[++idx]={i,x-1,yy,-1,0};
		a[++idx]={i,x-1,y-1,1,0};
	}
	sort(a+1,a+1+idx,cmpx);
	cdq(1,idx);
	for(int i=1;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p8575-dtoi-2星之河"><a href="https://www.luogu.com.cn/problem/P8575" class="dif6" rel="noopener nofollow">P8575 「DTOI-2」星之河</a></h4>
<p>将点用 DFS 序重新编号，这样“<span class="math inline">\(i\)</span> 在 <span class="math inline">\(j\)</span> 子树中” 的条件就转化为“<span class="math inline">\(dfn_i\in [dfn_j,dfn_j+siz_j-1]\)</span>”。</p>
<p>再加上 <span class="math inline">\(\text{Red,Blue}\)</span> 两个属性，就是超级板子的三维数点了。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/229316575" rel="noopener nofollow">R229316575</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=2e5+10;
int n,head[N],idx,tim,dfn[N],ans[N];
struct Edge{int nxt,to;}e[N&lt;&lt;1];
struct Node{int l,r,a,b;}a[N],t[N];
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[N];
	inline void chp(int x,int v){for(;x&lt;=n;x+=lb(x)) s[x]+=v;}
	inline void clr(int x){for(;x&lt;=n;x+=lb(x)) if(s[x]) s[x]=0;else return;}
	inline int qry(int x){int a=0;for(;x;x-=lb(x)) a+=s[x];return a;}
}bit;
inline bool cmpa(Node&amp; a,Node&amp; b){return a.a==b.a?a.b==b.b?a.l&gt;b.l:a.b&lt;b.b:a.a&lt;b.a;}
inline void add(int u,int v){e[++idx]={head[u],v},head[u]=idx;}
void dfs(int u,int fa){
	a[u].l=dfn[u]=++tim;
	for(int i=head[u],v;i;i=e[i].nxt) if((v=e[i].to)!=fa) dfs(v,u);
	a[u].r=tim;
}
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		for(;i&lt;=mid&amp;&amp;a[i].b&lt;=a[j].b;){
			bit.chp(a[i].l,1);
			t[k++]=a[i++];
		}
		ans[a[j].l]+=bit.qry(a[j].r)-bit.qry(a[j].l);
		t[k++]=a[j++];
	}
	for(j=l;j&lt;i;j++) bit.clr(a[j].l);
	while(i&lt;=mid) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n;
	for(int i=1,u,v;i&lt;n;i++) cin&gt;&gt;u&gt;&gt;v,add(u,v),add(v,u);
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].a&gt;&gt;a[i].b;
	dfs(1,0);
	sort(a+1,a+1+n,cmpa);
	cdq(1,n);
	for(int i=1;i&lt;=n;i++) if(ans[dfn[i]]) cout&lt;&lt;ans[dfn[i]]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="cf1311f-moving-points"><a hrref="https://www.luogu.com.cn/problem/CF1311F" class="dif5">CF1311F Moving Points</a></h4>
<p>不难发现，<span class="math inline">\(i,j\)</span> 两点对答案有贡献，当且仅当 <span class="math inline">\(x_i&lt;x_j,v_i\le v_j\)</span>，此时贡献为 <span class="math inline">\(x_j-x_i\)</span>。</p>
<p>这样就是二维偏序问题，统计时向答案累加 <span class="math inline">\((i-l)\times x_j-s\)</span>，其中 <span class="math inline">\(s=\sum\limits_{i=l}^{i-1} x_i\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://codeforces.com/contest/1311/submission/332472535" rel="noopener nofollow">#332472535</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int N=2e5+10;
struct Node{int x,v;}a[N],t[N];
bool cmp(Node&amp; a,Node&amp; b){return a.x==b.x?a.v&lt;b.v:a.x&lt;b.x;}
int n,ans;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k,sum=0;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		for(;i&lt;=mid&amp;&amp;a[i].v&lt;=a[j].v;) sum+=a[i].x,t[k++]=a[i++];
		ans+=(i-l)*a[j].x-sum,t[k++]=a[j++];
	}
	while(i&lt;=mid) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
signed main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].x;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].v;
	sort(a+1,a+1+n,cmp);
	cdq(1,n);
	cout&lt;&lt;ans&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p5459-bjoi2016-回转寿司"><a href="https://www.luogu.com.cn/problem/P5459" class="dif4" rel="noopener nofollow">P5459 [BJOI2016] 回转寿司</a></h4>
<p>题意就是统计有多少个 <span class="math inline">\([l,r]\)</span> 使得 <span class="math inline">\(\sum\limits_{i=l}^r a_i\in [L,R]\)</span>。</p>
<p>令 <span class="math inline">\(s\)</span> 为 <span class="math inline">\(a\)</span> 的前缀和数组，我们要找的就是满足下列条件的 <span class="math inline">\((i,j)\)</span> 个数：</p>
<ul>
<li><span class="math inline">\(id_i&lt;id_j\)</span></li>
<li><span class="math inline">\(s_j-s_i\in[L,R]\)</span>。</li>
</ul>
<p><span class="math inline">\(s\)</span> 的限制是一个区间，不能放在最外层排序。因此我们对 <span class="math inline">\(id\)</span> 分治，并按 <span class="math inline">\(s\)</span> 合并。</p>
<p><span class="math inline">\(s\)</span> 的限制可以在合并时使用差分，即将指针 <span class="math inline">\(i\)</span> 拆成两个 <span class="math inline">\(i_1,i_2\)</span>，分别记录 <span class="math inline">\(s_j-s_i\ge L\)</span> 和 <span class="math inline">\(s_j-s_i&gt;R\)</span> 的贡献，两个 <span class="math inline">\(i\)</span> 的贡献作差即可。</p>
<p>由于 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(s_i\)</span> 初始均有序，所以不需要进行任何排序。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/231273824" rel="noopener nofollow">R231273824</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int N=5e5+10;
int n,L,R,a[N],ans,t[N];
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i1,i2,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=i1=i2=k=l,j=mid+1;j&lt;=r;){
		while(i1&lt;=mid&amp;&amp;a[j]-a[i1]&gt;=L) i1++;
		while(i2&lt;=mid&amp;&amp;a[j]-a[i2]&gt;R) i2++;
		while(i&lt;=mid&amp;&amp;a[i]&lt;=a[j]) t[k++]=a[i++];
		ans+=i1-i2,t[k++]=a[j++];
	}
	while(i&lt;=mid) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
signed main(){
	cin&gt;&gt;n&gt;&gt;L&gt;&gt;R;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],a[i]+=a[i-1];
	cdq(0,n);
	cout&lt;&lt;ans&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p1972-sdoi2009-hh-的项链"><a href="https://www.luogu.com.cn/problem/P1972" class="dif5" rel="noopener nofollow">P1972 [SDOI2009] HH 的项链</a></h4>
<p>区间数颜色，我们有一个很标准的技巧。</p>
<p>令 <span class="math inline">\(pre_i\)</span> 为 <span class="math inline">\(a_i\)</span> 上一次出现的位置，若不存在则为 <span class="math inline">\(0\)</span>。</p>
<p>则找 <span class="math inline">\([l,r]\)</span> 内有多少种颜色，等价于统计满足下列条件的 <span class="math inline">\(j\)</span> 的个数：</p>
<ul>
<li><span class="math inline">\(j\in [l,r]\)</span></li>
<li><span class="math inline">\(pre_j\in [0,l)\)</span></li>
</ul>
<p>这就转化成二维数点了。</p>
<p>由于 <span class="math inline">\(pre\)</span> 的询问已经是一个前缀，所以一个查询拆成俩就可以。</p>
<p>时间复杂度 <span class="math inline">\(O((n+m)\log (n+m))\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/230545952" rel="noopener nofollow">R230545952</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e6+10,M=1e6+10;
struct Node{int d1,d2,d3,c;}a[N+2*M],t[N+2*M];//两个操作：(0,lst_i,i,0)、(i,limit_lst,limit_i,统计时的权重)
bool cmp(Node&amp; a,Node &amp;b){return a.d2==b.d2?a.d3==b.d3?a.d1&lt;b.d1:a.d3&lt;b.d3:a.d2&lt;b.d2;}
unordered_map&lt;int,int&gt; lst;
int n,m,idx,ans[M];
inline int lb(int x){return x&amp;-x;}
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k,c=0;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		for(;i&lt;=mid&amp;&amp;a[i].d3&lt;=a[j].d3;){
			if(!a[i].d1) c++;
			t[k++]=a[i++];
		}
		if(a[j].d1) ans[a[j].d1]+=c*a[j].c;
		t[k++]=a[j++];
	}
	for(;i&lt;=mid;) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n,idx=n;
	for(int i=1,x;i&lt;=n;i++) cin&gt;&gt;x,a[i].d2=lst[x],lst[x]=a[i].d3=i;
	cin&gt;&gt;m;
	for(int i=1,l,r;i&lt;=m;i++) cin&gt;&gt;l&gt;&gt;r,a[++idx]={i,l-1,r,1},a[++idx]={i,l-1,l-1,-1};
	sort(a+1,a+1+idx,cmp),cdq(1,idx);
	for(int i=1;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h5 id="另解">另解</h5>
<p>我们之所以要将询问拆分，是因为分治和排序仅能处理一个前缀。不过树状数组等数据结构，本身就支持一个区间的查询。</p>
<p>因此，我尝试在 CDQ 的基础上嵌套了一层树状数组，来维护下标的区间查询，这样有两个好处：</p>
<ul>
<li>无需拆分询问，操作总数从 <span class="math inline">\(n+2m\)</span> 变成了 <span class="math inline">\(n+m\)</span>。</li>
<li>节点不需要再记录 <code>c</code>（统计倍率）属性，减少了转移负担。</li>
</ul>
<p>虽然理论复杂度会添一只 <span class="math inline">\(\log n\)</span>，但是实测居然跑得更快一些（12.18s <span class="math inline">\(\rightarrow\)</span> 11.53s）。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/230552064" rel="noopener nofollow">R230552064</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e6+10,M=1e6+10;
struct Node{int d1,d2,d3;}a[N+M],t[N+M];//两个操作：(0,lst_i,i)、(i,l_i,r_i)
unordered_map&lt;int,int&gt; lst;
int n,m,idx,ans[M];
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[N];
	void chp(int x,int v){for(;x&lt;=n;x+=lb(x)) s[x]+=v;}
	void clr(int x){for(;x&lt;=n;x+=lb(x)) if(s[x]) s[x]=0;else return;}
	int qry(int x){int a=0;for(;x;x-=lb(x)) a+=s[x];return a;}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k,s;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=s=l,j=mid+1;j&lt;=r;){
		for(;s&lt;=mid&amp;&amp;a[s].d2&lt;=a[j].d2-1;s++) if(!a[s].d1) bit.chp(a[s].d3,1);
		for(;i&lt;=mid&amp;&amp;a[i].d2&lt;=a[j].d2;) t[k++]=a[i++];
		if(a[j].d1) ans[a[j].d1]+=bit.qry(a[j].d3)-bit.qry(a[j].d2-1);
		t[k++]=a[j++];
	}
	for(j=l;j&lt;i;j++) bit.clr(a[j].d3);
	for(;i&lt;=mid;) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n,idx=n;
	for(int i=1,x;i&lt;=n;i++) cin&gt;&gt;x,a[i].d2=lst[x],lst[x]=a[i].d3=i;
	cin&gt;&gt;m;
	for(int i=1,l,r;i&lt;=m;i++) cin&gt;&gt;l&gt;&gt;r,a[++idx]={i,l,r};
	cdq(1,idx);
	for(int i=1;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p11197-cots-2021-赛狗游戏-tiket"><a href="P11197 [COTS 2021] 赛狗游戏 Tiket" class="dif6" rel="noopener nofollow">P11197 [COTS 2021] 赛狗游戏 Tiket</a></h4>
<p>令 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(T,A,B,C\)</span> 中出现的位置分别为 <span class="math inline">\(p_i,a_i,b_i,c_i\)</span>，则 <span class="math inline">\((i,j)\)</span> 产生贡献条件很容易写：</p>
<ul>
<li><span class="math inline">\(p_i&lt;p_j\land a_i&lt;a_j\land b_i&lt;b_j\land c_i&lt;c_j\)</span> 或者</li>
<li><span class="math inline">\(p_i&gt;p_j\land a_i&lt;a_j\land b_i&lt;b_j\land c_i&lt;c_j\)</span></li>
</ul>
<p>看起来是四维偏序？可如果你写四维偏序，可能会像我一样 <a href="https://www.luogu.com.cn/record/231693205" target="_blank" rel="noopener nofollow">TLE 36pts</a>。</p>
<p>其实我们不难发现 <span class="math inline">\(p_i&lt;p_j,p_i&gt;p_j\)</span> 一定恰有一式成立。</p>
<p>所以 <span class="math inline">\(p\)</span> 的限制相当于没有。</p>
<p>题意转化为求 <span class="math inline">\(a_i&lt;a_j\land b_i&lt;b_j\land c_i&lt;c_j\)</span> 的 <span class="math inline">\((i,j)\)</span> 数量，三维偏序板子。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/231691122" rel="noopener nofollow">R231691122</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int N=5e5+10;
struct Node{int a,b,c;}a[N],t[N];
int n,ans;
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[N];
	inline void chp(int x,int v){for(;x&lt;=n;x+=lb(x)) s[x]+=v;}
	inline void clr(int x){for(;x&lt;=n;x+=lb(x)) if(s[x]) s[x]=0;else return;}
	inline int qry(int x){int a=0;for(;x;x-=lb(x)) a+=s[x];return a;}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		for(;i&lt;=mid&amp;&amp;a[i].b&lt;a[j].b;){
			bit.chp(a[i].c,1);
			t[k++]=a[i++];
		}
		ans+=bit.qry(a[j].c-1);
		t[k++]=a[j++];
	}
	for(j=l;j&lt;i;j++) bit.clr(a[j].c);
	for(;i&lt;=mid;) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n;
	for(int i=1,x;i&lt;=n;i++) cin&gt;&gt;x;
	for(int i=1,x;i&lt;=n;i++) cin&gt;&gt;x,a[x].a=i;
	for(int i=1,x;i&lt;=n;i++) cin&gt;&gt;x,a[x].b=i;
	for(int i=1,x;i&lt;=n;i++) cin&gt;&gt;x,a[x].c=i;
	sort(a+1,a+1+n,[](Node&amp; a,Node&amp; b){return a.a&lt;b.a;});
	cdq(1,n);
	cout&lt;&lt;ans&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p5094-usaco04open-moofest-g-加强版"><a href="https://www.luogu.com.cn/problem/P5094" class="dif4" rel="noopener nofollow">P5094 [USACO04OPEN] MooFest G 加强版</a></h4>
<p>题目给我们的式子带 <span class="math inline">\(\max\)</span> 还带绝对值，考虑将其简化。</p>
<p>其中 <span class="math inline">\(\max\)</span>，我们对 <span class="math inline">\(v\)</span> 排个序就解决了。</p>
<p>而与 <span class="math inline">\(x\)</span> 相关的绝对值，我们一般有两种对策：</p>
<ul>
<li>将 <span class="math inline">\(x\)</span> 扔到树状数组上处理。</li>
<li>按 <span class="math inline">\(x\)</span> 合并的同时处理。</li>
</ul>
<p>因为这道题只有两维，所以两种方法其实就是<strong>排序 + 数据结构</strong> 和 <strong>排序 + CDQ 分治</strong>。</p>
<h5 id="排序--数据结构">排序 + 数据结构</h5>
<p>这个可能相对好想一些。</p>
<p>将二元组 <span class="math inline">\((x,v)\)</span> 按 <span class="math inline">\(v\)</span> 从小到大排序，依次遍历每个二元组，对于 <span class="math inline">\((x_j,v_j)\)</span>：</p>
<ol>
<li>
<p>将满足 <span class="math inline">\(i&lt;j,x_i&lt;x_j\)</span> 的 <span class="math inline">\(i\)</span> 的个数记为 <span class="math inline">\(c\)</span>，这些 <span class="math inline">\(x_i\)</span> 的总和记为 <span class="math inline">\(s\)</span>。</p>
<p>对答案产生 <span class="math inline">\((c\times x_j-s)\times v_j\)</span> 的贡献。</p>
</li>
<li>
<p>将满足 <span class="math inline">\(i&lt;j,x_i&gt;x_j\)</span> 的 <span class="math inline">\(i\)</span> 的个数记为 <span class="math inline">\(c\)</span>，这些 <span class="math inline">\(x_i\)</span> 的总和记为 <span class="math inline">\(s\)</span>。</p>
<p>对答案产生 <span class="math inline">\((s-c\times x_j)\times v_j\)</span> 的贡献。</p>
</li>
</ol>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/227554505" rel="noopener nofollow">R227554505</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int N=5e4+10,Ve=5e4,V=Ve+10;//e=exact
int n,ans;
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[V],c[V];
	void chp(int x,int v){for(;x&lt;=Ve;x+=lb(x)) s[x]+=v,c[x]++;}
	void qry(int x,int y,int&amp; _s,int&amp; _c){
		_s=_c=0,x--;
		for(;y;y-=lb(y)) _s+=s[y],_c+=c[y];
		for(;x;x-=lb(x)) _s-=s[x],_c-=c[x];
	}
}bit;
struct Node{int a,v;}a[N];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].v&gt;&gt;a[i].a;
	sort(a+1,a+1+n,[](Node a,Node b){return a.v&lt;b.v;});
	for(int i=1,s,c;i&lt;=n;i++){
		bit.qry(1,a[i].a-1,s,c);
		ans+=a[i].v*(c*a[i].a-s);
		bit.qry(a[i].a+1,Ve,s,c);
		ans+=a[i].v*(s-c*a[i].a);
		bit.chp(a[i].a,a[i].a);
	}
	cout&lt;&lt;ans&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h5 id="排序--cdq-分治">排序 + CDQ 分治</h5>
<p>我们按 <span class="math inline">\(v\)</span> 从大到小的排序分治，这样就恒有 <span class="math inline">\(v_j\ge v_i\)</span>，<span class="math inline">\(\max\)</span> 始终落在 <span class="math inline">\(v_j\)</span>。</p>
<p>按 <span class="math inline">\(x\)</span> 合并。</p>
<p>对于某一时刻的 <span class="math inline">\(j\)</span> 指针，假定 <span class="math inline">\(i\)</span> 已经跑完了 <code>while</code> 循环。</p>
<p>那么此时 <span class="math inline">\([l,i)\)</span> 内的 <span class="math inline">\(x\)</span> 值全部 <span class="math inline">\(&lt;x_j\)</span>，<span class="math inline">\([i,mid]\)</span> 内的 <span class="math inline">\(x\)</span> 值全部 <span class="math inline">\(\ge x_j\)</span>。</p>
<p>这样就可以拆掉绝对值了，此时对答案的贡献是：</p>
<p></p><div class="math display">\[v_i\times\big[(i-l)\times x_j-(\sum\limits_{k=l}^{i-1} x_k)+(\sum\limits_{k=i}^{mid} x_k)-(mid+1-i)\times x_j\big]
\]</div><p></p><p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/227561662" rel="noopener nofollow">R227561662</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int N=5e4+10;
int n,ans;
struct Node{int a,v;}a[N],t[N];
int cdq(int l,int r){//返回值为[l,r]内a的和
	if(l==r) return a[l].a;
	int mid=(l+r)&gt;&gt;1,i,j,k,s=0,ss=cdq(l,mid),tmp=cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;j++){
		while(i&lt;=mid&amp;&amp;a[i].a&lt;a[j].a) s+=a[i].a,t[k++]=a[i++];
		ans+=a[j].v*(((i-l)*a[j].a-s)+((ss-s)-(mid+1-i)*a[j].a));
		t[k++]=a[j];
	}
	while(i&lt;=mid) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
	return ss+tmp;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].v&gt;&gt;a[i].a;
	sort(a+1,a+1+n,[](Node&amp; a,Node&amp; b){return a.v&lt;b.v;});
	cdq(1,n);
	cout&lt;&lt;ans&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p3658-usaco17feb-why-did-the-cow-cross-the-road-iii-p"><a href="https://www.luogu.com.cn/problem/P3658" class="dif6" rel="noopener nofollow">P3658 [USACO17FEB] Why Did the Cow Cross the Road III P</a></h4>
<p>令 <span class="math inline">\(a_i\)</span> 为 <span class="math inline">\(i\)</span> 在左侧的出现位置，<span class="math inline">\(b_i\)</span> 为 <span class="math inline">\(i\)</span> 在右侧的出现位置。</p>
<p><span class="math inline">\(i\)</span> 对 <span class="math inline">\(j\)</span> 产生贡献，当且仅当：</p>
<ul>
<li>
<p><span class="math inline">\(a_i&lt;a_j\)</span></p>
</li>
<li>
<p><span class="math inline">\(b_i&gt;b_j\)</span></p>
</li>
<li>
<p><span class="math inline">\(|id_i-id_j|&gt;K\)</span></p>
<p> 即 <span class="math inline">\(id_i&gt;id_j+K\)</span> 或 <span class="math inline">\(id_i&lt;id_j-K\)</span></p>
</li>
</ul>
<p>从上一题我们知道，处理绝对值大致有两种方法。</p>
<p>这里两种做法都是可用的，即：</p>
<ul>
<li>按 <span class="math inline">\(a\)</span> 分治，按 <span class="math inline">\(b\)</span> 合并，树状数组维护 <span class="math inline">\(id\)</span>。</li>
<li>按 <span class="math inline">\(a\)</span> 分治，按 <span class="math inline">\(id\)</span> 合并，树状数组维护 <span class="math inline">\(b\)</span>。</li>
</ul>
<p>提一嘴第二种写法。</p>
<p>我们的限制条件是 <span class="math inline">\(id_i&gt;id_j+K\)</span> 或 <span class="math inline">\(id_i&lt;id_j-K\)</span>，而 <span class="math inline">\(K\)</span> 是一个常数。所以随着 <span class="math inline">\(j\)</span> 的增加，限制 <span class="math inline">\(id_i\)</span> 的两个端点也是单调不降的。这就可以用双指针来差分一下，具体见代码。</p>
<p>假如 <span class="math inline">\(K\)</span> 不是常数，那么两个端点就未必单调移动，此时就只能使用第一种写法，将 <span class="math inline">\(id\)</span> 放在树状数组上维护。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>，后者可能常数大一些，码起来也稍微绕一点。</p>
<details>
<summary>实现 1 - <a href="https://www.luogu.com.cn/record/227870178" rel="noopener nofollow">R227870178</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int N=1e5+10;
struct Data{int id,a,b;}a[N],t[N];
inline bool cmp(Data&amp; a,Data&amp; b){return a.a&lt;b.a;}
int n,kk,ans;
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[N];
	inline void chp(int x,int v){for(;x&lt;=n;x+=lb(x)) s[x]+=v;}
	inline void clr(int x){for(;x&lt;=n;x+=lb(x)) if(s[x]) s[x]=0;else break;}
	inline int qry(int x){int a=0;for(;x;x-=lb(x)) a+=s[x];return a;}
	inline int qry(int x,int y){return x&gt;y?0:qry(y)-qry(x-1);}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;j++){
		for(;i&lt;=mid&amp;&amp;a[i].b&gt;a[j].b;i++) bit.chp(a[i].id,1),t[k++]=a[i];
		ans+=bit.qry(a[j].id+kk+1,n)+bit.qry(1,a[j].id-kk-1),t[k++]=a[j];
	}
	for(j=l;j&lt;i;j++) bit.clr(a[j].id);
	while(i&lt;=mid) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;kk;
	for(int i=1,x;i&lt;=n;i++) cin&gt;&gt;x,a[x].a=a[i].id=i;
	for(int i=1,x;i&lt;=n;i++) cin&gt;&gt;x,a[x].b=i;
	sort(a+1,a+1+n,cmp),cdq(1,n);
	cout&lt;&lt;ans&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<details>
<summary>实现 2 - <a href="https://www.luogu.com.cn/record/229753185" rel="noopener nofollow">R229753185</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int N=1e5+10;
struct Data{int id,a,b;}a[N],t[N];
inline bool cmp(Data&amp; a,Data&amp; b){return a.a&gt;b.a;}//a从大到小排序
int n,kk,ans;
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[N];
	inline void chp(int x,int v){for(;x&lt;=n;x+=lb(x)) s[x]+=v;}
	inline void clr(int x){for(;x&lt;=n;x+=lb(x)) if(s[x]) s[x]=0;else break;}
	inline int qry(int x){int a=0;for(;x;x-=lb(x)) a+=s[x];return a;}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k,L,R;
	cdq(l,mid),cdq(mid+1,r);
	for(i=l;i&lt;=mid;i++) bit.chp(a[i].b,1);//初始所有b都加入，随后双指针剔除id在[id_j-K,id_j+K]内的b
	for(i=k=L=R=l,j=mid+1;j&lt;=r;){
		for(;R&lt;=mid&amp;&amp;a[R].id&lt;=a[j].id+kk;) bit.chp(a[R++].b,-1);
		for(;L&lt;=mid&amp;&amp;a[L].id&lt;a[j].id-kk;) bit.chp(a[L++].b,1);
		for(;i&lt;=mid&amp;&amp;a[i].id&lt;a[j].id;) t[k++]=a[i++];
		ans+=bit.qry(a[j].b),t[k++]=a[j++];
	}
	for(j=l;j&lt;=mid;j++) bit.clr(a[j].b);
	while(i&lt;=mid) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;kk;
	for(int i=1,x;i&lt;=n;i++) cin&gt;&gt;x,a[x].a=a[i].id=i;
	for(int i=1,x;i&lt;=n;i++) cin&gt;&gt;x,a[x].b=i;
	sort(a+1,a+1+n,cmp),cdq(1,n);
	cout&lt;&lt;ans&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="cf1045g-ai-robots"><a href="https://www.luogu.com.cn/problem/CF1045G" class="dif6" rel="noopener nofollow">CF1045G AI robots</a></h4>
<p>相当于给定 <span class="math inline">\(n\)</span> 个三元组 <span class="math inline">\((x_i,r_i,q_i)\)</span>，统计满足“能互相看见” 且“智商差距 <span class="math inline">\(\le K\)</span>” 的点对数量。</p>
<p>其中“能互相看见” 的条件写成式子十分复杂，既带 <span class="math inline">\(\min\)</span> 又有绝对值，因此首先考虑将它简化。</p>
<p>按之前的套路，我们先按视野 <span class="math inline">\(r\)</span> 从大到小的排序分治。这样就恒有 <span class="math inline">\(r_j\le r_i\)</span>，<span class="math inline">\(\min\)</span> 始终落在 <span class="math inline">\(r_j\)</span>。</p>
<p>这样“能互相看见” 的条件被简化为 <span class="math inline">\(|x_i-x_j|\le r_j\)</span>，即 <span class="math inline">\(x_i\in [x_j-r_j,x_j+r_j]\)</span>。</p>
<p>我们发现，随着 <span class="math inline">\(j\)</span> 的增加，限制 <span class="math inline">\(x_i\)</span> 的两个端点并不单调变化，不能简单地用双指针解决掉，必须按 <span class="math inline">\(q\)</span> 合并，而将 <span class="math inline">\(x\)</span> 扔到树状数组里维护。这样每个 <span class="math inline">\(j\)</span> 我们仅需在树状数组上查询 <span class="math inline">\(x_i\in[x_j-r_j,x_j+r_j]\)</span> 的个数就好了。</p>
<p>最后只剩下“智商差距 <span class="math inline">\(\le K\)</span>”，即 <span class="math inline">\(|q_i-q_j|\le K\)</span>，也即 <span class="math inline">\(q_i\in [q_j-K,q_j+K]\)</span>。</p>
<p>这个式子与 <span class="math inline">\(K\)</span> 有关，而 <span class="math inline">\(K\)</span> 是一个常数。所以随着 <span class="math inline">\(j\)</span> 的增加，左右端点是单调变化的，正好可以按 <span class="math inline">\(q\)</span> 合并，使用双指针差分来解决。即 <span class="math inline">\(q_i\le q_j+K\)</span> 的答案，再减去 <span class="math inline">\(q_i \le q_j-K-1\)</span> 的答案。</p>
<p>所以总体思路是按 <span class="math inline">\(r\)</span> 分治，按 <span class="math inline">\(q\)</span> 合并，<span class="math inline">\(x\)</span> 扔到树状数组上维护。</p>
<p>思路很巧妙的一道题，感觉就像为 CDQ 而设计的一样（不过 cf 题解给的是线段树，时空复杂度分别是 <span class="math inline">\(O(Kn\log n),O(n\log n)\)</span>）。</p>
<p>代码离散化用到了 <code>gp_hash_table</code>，然而交上去 TLE on #13，说明 cf 卡这个了，因此借用了<a href="https://www.cnblogs.com/week-end/articles/17652672.html" target="_blank">此文 by week_end</a> 中的自定义哈希函数。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://codeforces.com/contest/1045/submission/332029170" rel="noopener nofollow">#332029170</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#include&lt;ext/pb_ds/assoc_container.hpp&gt;
#include&lt;ext/pb_ds/hash_policy.hpp&gt;
#define int long long
using namespace std;
using namespace __gnu_pbds;
const int N=1e5+10;
int n,kk,ans,b[3*N],tn;
struct Node{int x,r,q,lp,rp;}a[N],t[N];
inline bool cmpr(Node a,Node b){return a.r==b.r?(a.q==b.q?a.x&lt;b.x:a.q&lt;b.q):a.r&gt;b.r;}
struct custom_hash{
	static uint64_t splitmix64(uint64_t x){
		x+=0x9e3779b97f4a7c15;
		x=(x^(x&gt;&gt;30))*0xbf58476d1ce4e5b9;
		x=(x^(x&gt;&gt;27))*0x94d049bb133111eb;
		return x^(x&gt;&gt;31);
	}
	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM=chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x+FIXED_RANDOM);
	}
};
gp_hash_table&lt;int,int,custom_hash&gt; ma;
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[3*N];
	void chp(int x,int v){for(;x&lt;=tn;x+=lb(x)) s[x]+=v;}
	void clr(int x){for(;x&lt;=tn;x+=lb(x)) if(s[x]) s[x]=0;else return;}
	int qry(int x){int a=0;for(;x;x-=lb(x)) a+=s[x];return a;}
	int qry(int x,int y){return qry(y)-qry(x-1);}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,L,R,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(L=R=i=k=l,j=mid+1;j&lt;=r;j++){
		for(;R&lt;=mid&amp;&amp;a[R].q-a[j].q&lt;=kk;R++) bit.chp(a[R].x,1);
		for(;L&lt;=mid&amp;&amp;a[L].q-a[j].q&lt;-kk;L++) bit.chp(a[L].x,-1);
		for(;i&lt;=mid&amp;&amp;a[i].q&lt;=a[j].q;i++) t[k++]=a[i];
		ans+=bit.qry(a[j].lp,a[j].rp),t[k++]=a[j];
	}
	for(j=L;j&lt;R;j++) bit.clr(a[j].x);
	while(i&lt;=mid) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;kk;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;a[i].x&gt;&gt;a[i].r&gt;&gt;a[i].q;
		b[++tn]=a[i].x;
		b[++tn]=a[i].lp=a[i].x-a[i].r;
		b[++tn]=a[i].rp=a[i].x+a[i].r;
	}
	sort(b+1,b+1+tn),tn=unique(b+1,b+1+tn)-b-1;
	for(int i=1;i&lt;=tn;i++) ma[b[i]]=i;
	for(int i=1;i&lt;=n;i++) a[i].x=ma[a[i].x],a[i].lp=ma[a[i].lp],a[i].rp=ma[a[i].rp];
	sort(a+1,a+1+n,cmpr),cdq(1,n);
	cout&lt;&lt;ans&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h2 id="动态转静态">动态转静态</h2>
<p>所谓动态转静态，本质上就是为所有操作额外加了一个属性 —— 时间戳 <span class="math inline">\(tim\)</span>。</p>
<p><span class="math inline">\(i\)</span> 能对 <span class="math inline">\(j\)</span> 产生贡献，当且仅当：</p>
<ul>
<li><span class="math inline">\(tim_i&lt;tim_j\)</span></li>
<li><span class="math inline">\(i\)</span> 是修改操作</li>
<li><span class="math inline">\(j\)</span> 是查询操作</li>
<li>……（更多限制 依题目而定）</li>
</ul>
<p>动态问题，本质上是在静态问题的基础上添加了 <span class="math inline">\(tim\)</span> 这一维。</p>
<p>对输入的操作序列离线后，<span class="math inline">\(tim\)</span> 是天然不降的。所以我们一般采用对 <span class="math inline">\(tim\)</span>，也就是<strong>时间轴</strong>分治的策略。</p>
<p>需要注意的一点是，若询问之间<strong>相互独立</strong>，那么我们无需处理“左区间内部贡献”“右区间内部贡献”“跨区间贡献” 之间的时序关系。比如说 <span class="math inline">\(tim_i&lt;tim_j&lt;tim_k\)</span>，<span class="math inline">\(i,j\)</span> 两个单点加操作都对查询 <span class="math inline">\(k\)</span> 有贡献，那么处理 <span class="math inline">\(i,j\)</span> 的时间是随意的。</p>
<p>然而如果是单点赋值这样有<strong>时序依赖关系</strong>的操作，我们就必须先处理 <span class="math inline">\(i\)</span> 的贡献，再处理 <span class="math inline">\(j\)</span> 的贡献。放在代码实现中，我们必须对时间轴分治，且分治时要先调用 <code>cdq(l,mid)</code>，再统计跨区间贡献，最后调用 <code>cdq(mid+1,r)</code>。</p>
<p>这样相当于对 CDQ 的递归树做<strong>中序遍历</strong>。可以发现，为某个节点提供贡献的点一定是按时间单调的，所以正确性可以保证。</p>
<p>如下图，绿色部分是要统计贡献的点，橙色部分是所有为其提供贡献的子问题（很像线段树上拆成的 <span class="math inline">\(O(\log n)\)</span> 个区间），必须依照标号的顺序来提供贡献。</p>
<img src="https://img2024.cnblogs.com/blog/3322276/202508/3322276-20250813160749098-1068878689.png" style="width: 600px">
<p>不过中序遍历会破坏归并排序的结构，使得我们写归并比较困难。因此为了降低代码复杂度，我们通常对合并的那一维使用 <code>sort</code>，这个在 DP 优化部分会很常见。</p>
<h3 id="例题-1">例题</h3>
<h4 id="p3374-模板树状数组-1"><a href="https://www.luogu.com.cn/problem/P3374" class="dif3" rel="noopener nofollow">P3374 【模板】树状数组 1</a></h4>
<p>动态一维数点。</p>
<p>我们将查询拆成两个前缀 <span class="math inline">\(r,l-1\)</span> 作差的形式。</p>
<p>这样，修改 <span class="math inline">\((tim_i,x_i,v_i)\)</span> 能对查询 <span class="math inline">\((tim_j,x_j)\)</span> 产生贡献，除了上面的条件以外，仅需再满足 <span class="math inline">\(x_i\le x_j\)</span>。</p>
<p>考虑到输入给定的序列已经天然地按 <span class="math inline">\(tim\)</span> 不降了，所以不妨对 <span class="math inline">\(tim\)</span> 分治，按 <span class="math inline">\(x\)</span> 合并。</p>
<p>时间复杂度 <span class="math inline">\(O((n+m)\log(n+m))\)</span>。</p>
<p>一个小优化，初始序列没有必要拆成 <span class="math inline">\(n\)</span> 次修改操作，只需要在初始序列为 <span class="math inline">\(0\)</span> 的答案上，额外累加 <span class="math inline">\(a_{l,r}\)</span> 的总和即可。时间复杂度优化到 <span class="math inline">\(O(n+m\log m)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/231360817" rel="noopener nofollow">R231360817</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=5e5+10,M=5e5+10;
struct Node{int id,x,k,c;}q[2*M],t[2*M];//id为询问编号，修改则是0
int n,m,a[N],idx,ans[M],qidx;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k,s=0;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		for(;i&lt;=mid&amp;&amp;q[i].x&lt;=q[j].x;) s+=q[i].k,t[k++]=q[i++];
		ans[q[j].id]+=q[j].c*s;
		t[k++]=q[j++];
	}
	while(i&lt;=mid) t[k++]=q[i++];
	for(i=l;i&lt;=r;i++) q[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],a[i]+=a[i-1];
	for(int i=1,op,x,y;i&lt;=m;i++){
		cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;
		if(op==1){
			q[++idx]={0,x,y,0};
		}else{
			++qidx;
			q[++idx]={qidx,y,0,1};
			q[++idx]={qidx,x-1,0,-1};
			ans[qidx]=a[y]-a[x-1];
		}
	}
	cdq(1,idx);
	for(int i=1;i&lt;=qidx;i++) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p4390-balkanoi-2007-mokia-摩基亚"><a href="https://www.luogu.com.cn/problem/P4390" class="dif6" rel="noopener nofollow">P4390 [BalkanOI 2007] Mokia 摩基亚</a></h4>
<p>动态二维数点。</p>
<p>时间复杂度 <span class="math inline">\(O((n+m)\log(n+m)\log n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/231361299" rel="noopener nofollow">R231361299</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=2e6+5,Q=1.8e5+5;
struct Node{int id,x,y,yr,c,k;}a[Q];//(tim,x,y)
int n,idx,ans[Q],qidx,p[Q],t[Q];
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[N];
	inline void chp(int x,int v){for(;x&lt;=n;x+=lb(x)) s[x]+=v;}
	inline void clr(int x){for(;x&lt;=n;x+=lb(x)) if(s[x]) s[x]=0;else break;}
	inline int qry(int x){int a=0;for(;x;x-=lb(x)) a+=s[x];return a;}
	inline int qry(int x,int y){return qry(y)-qry(x-1);}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;j++){
		for(;i&lt;=mid&amp;&amp;a[p[i]].x&lt;=a[p[j]].x;i++){
			if(a[p[i]].k) bit.chp(a[p[i]].y,a[p[i]].k);
			t[k++]=p[i];
		}
		if(a[p[j]].c) ans[a[p[j]].id]+=a[p[j]].c*bit.qry(a[p[j]].y,a[p[j]].yr);
		t[k++]=p[j];
	}
	for(j=l;j&lt;i;j++) if(a[p[j]].k) bit.clr(a[p[j]].y);
	while(i&lt;=mid) t[k++]=p[i++];
	for(i=l;i&lt;=r;i++) p[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;n;
	int op,x,y,xx,yy;
	while(cin&gt;&gt;op){
		if(op==1){
			cin&gt;&gt;x&gt;&gt;y&gt;&gt;xx;
			a[++idx]={0,x,y,0,0,xx};
		}else if(op==2){
			++qidx;
			cin&gt;&gt;x&gt;&gt;y&gt;&gt;xx&gt;&gt;yy;
			a[++idx]={qidx,xx,y,yy,1,0};
			a[++idx]={qidx,x-1,y,yy,-1,0};
		}else break;
	}
	for(int i=1;i&lt;=idx;i++) p[i]=i;
	cdq(1,idx);
	for(int i=1;i&lt;=qidx;i++) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p3157-cqoi2011-动态逆序对"><a href="https://www.luogu.com.cn/problem/P3157" class="dif5" rel="noopener nofollow">P3157 [CQOI2011] 动态逆序对</a></h4>
<p>先求出初始状态的逆序对，再考虑删除操作带来的贡献。</p>
<p>令 <span class="math inline">\(tim_i\)</span> 为 <span class="math inline">\(a_i\)</span> 被删除的时间点，若未被删除则记为 <span class="math inline">\(m+1\)</span>。</p>
<p>删除第 <span class="math inline">\(i\)</span> 个元素，答案将会减少满足下面条件的 <span class="math inline">\(j\)</span> 的个数：</p>
<ul>
<li><span class="math inline">\(tim_j&gt;tim_i\)</span></li>
<li><span class="math inline">\(x_j&lt;x_i,v_j&gt;v_i\)</span> 或 <span class="math inline">\(x_j&gt;x_i,v_j&lt;v_i\)</span></li>
</ul>
<p>由于 <span class="math inline">\(x,v\)</span> 有两种关系需要讨论，所以 CDQ 过程中正反各遍历一次。</p>
<p>时间复杂度 <span class="math inline">\(O(m+n\log n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/229862409" rel="noopener nofollow">R229862409</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int N=1e5+10,M=5e4+10;
struct Node{int tim,x,v;}q[N],t[N];
inline bool cmp(Node&amp; a,Node&amp; b){return a.tim&gt;b.tim;}
int n,m,cur,a[N],p[N],ans[M];
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[N];
	inline void chp(int x,int v){for(;x&lt;=n;x+=lb(x)) s[x]+=v;}
	inline void clr(int x){for(;x&lt;=n;x+=lb(x)) if(s[x]) s[x]=0;else return;}
	inline int qry(int x){int a=0;for(;x;x-=lb(x)) a+=s[x];return a;}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k,c=0;
	cdq(l,mid),cdq(mid+1,r);
	for(i=mid,j=r;j&gt;mid;j--){
		for(;i&gt;=l&amp;&amp;q[i].x&gt;q[j].x;i--) bit.chp(q[i].v,1);
		ans[q[j].tim]+=bit.qry(q[j].v);
	}
	for(j=mid;j&gt;i;j--) bit.clr(q[j].v);
	for(i=k=l,j=mid+1;j&lt;=r;j++){
		for(;i&lt;=mid&amp;&amp;q[i].x&lt;q[j].x;i++){
			bit.chp(q[i].v,1),c++;
			t[k++]=q[i];
		}
		ans[q[j].tim]+=c-bit.qry(q[j].v);
		t[k++]=q[j];
	}
	for(j=l;j&lt;i;j++) bit.clr(q[j].v);
	while(i&lt;=mid) t[k++]=q[i++];
	for(i=l;i&lt;=r;i++) q[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],p[a[i]]=i,q[i]={m+1,i,a[i]};
	for(int i=n;i;i--) cur+=bit.qry(a[i]-1),bit.chp(a[i],1);
	for(int i=1;i&lt;=n;i++) bit.clr(a[i]);
	for(int i=1,x;i&lt;=m;i++) cin&gt;&gt;x,q[p[x]].tim=i;
	sort(q+1,q+1+n,cmp),cdq(1,n);
	for(int i=1;i&lt;=m;i++) cout&lt;&lt;cur&lt;&lt;"\n",cur-=ans[i];
	return 0;
}
</code></pre>
</details>
<h4 id="p12685-国家集训队-排队-加强版"><a href="https://www.luogu.com.cn/problem/P12685" class="dif5" rel="noopener nofollow">P12685 [国家集训队] 排队 加强版</a></h4>
<p>转化一下，这道题就是一个动态的二维数点问题。</p>
<p>我们将每个元素视作二维平面上的点 <span class="math inline">\((i,a_i)\)</span>。</p>
<p>每次交换 <span class="math inline">\(l,r\)</span> 两个元素时（<span class="math inline">\(l&lt;r\)</span>），都同时发生了修改操作和查询操作。</p>
<p>修改操作，就是将 <span class="math inline">\((l,a_l),(r,a_r)\)</span> 处 <span class="math inline">\(-1\)</span>，<span class="math inline">\((l,a_r),(r,a_l)\)</span> 处 <span class="math inline">\(+1\)</span>。</p>
<p>查询操作，即对答案的贡献为：</p>
<ul>
<li>加上满足 <span class="math inline">\(j\in (l,r)\)</span> 且 <span class="math inline">\(a_j&lt;a_r\)</span> 的 <span class="math inline">\(j\)</span> 的个数。</li>
<li>减去满足 <span class="math inline">\(j\in (l,r)\)</span> 且 <span class="math inline">\(a_j&gt;a_r\)</span> 的 <span class="math inline">\(j\)</span> 的个数。</li>
<li>加上满足 <span class="math inline">\(j\in (l,r)\)</span> 且 <span class="math inline">\(a_j&gt;a_l\)</span> 的 <span class="math inline">\(j\)</span> 的个数。</li>
<li>减去满足 <span class="math inline">\(j\in (l,r)\)</span> 且 <span class="math inline">\(a_j&lt;a_l\)</span> 的 <span class="math inline">\(j\)</span> 的个数。</li>
<li>交换前若 <span class="math inline">\(a_l&lt;a_r\)</span> 则产生 <span class="math inline">\(1\)</span> 的贡献，若 <span class="math inline">\(a_l&gt;a_r\)</span> 则产生 <span class="math inline">\(-1\)</span> 的贡献。</li>
</ul>
<p>再差分一下，每次交换带来的贡献可以写成 <span class="math inline">\(10\)</span> 个前缀查询加减的形式，具体见代码。</p>
<p>每次交换，修改查询相互独立，两者顺序无所谓。</p>
<p>时间复杂度 <span class="math inline">\(O((n+m)\log (n+m)\log n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/229135369" rel="noopener nofollow">R229135369</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
#define eb emplace_back
using namespace std;
const int N=2e5+10,M=2e5+10;
int n,m,a[N],b[N],tn,idx,cur,ans[M];
struct Qr{bool op;int x,ix,c,id;}q[N+16*M],t[N+16*M];
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[N];
	inline void chp(int x,int v){for(;x&lt;=tn;x+=lb(x)) s[x]+=v;}
	inline void clr(int x){for(;x&lt;=tn;x+=lb(x)) if(s[x]) s[x]=0;else return;}
	inline int qry(int x){int a=0;for(;x;x-=lb(x)) a+=s[x];return a;}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		for(;i&lt;=mid&amp;&amp;q[i].x&lt;=q[j].x;){
			if(!q[i].op) bit.chp(q[i].ix,q[i].c);
			t[k++]=q[i++];
		}
		if(q[j].op) ans[q[j].id]+=q[j].c*bit.qry(q[j].ix);
		t[k++]=q[j++];
	}
	for(j=l;j&lt;i;j++) if(!q[j].op) bit.clr(q[j].ix);
	while(i&lt;=mid) t[k++]=q[i++];
	for(i=l;i&lt;=r;i++) q[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],b[i]=a[i];
	sort(b+1,b+1+n),tn=unique(b+1,b+1+n)-b-1;
	for(int i=n;i;i--){
		a[i]=lower_bound(b+1,b+1+tn,a[i])-b;
		cur+=bit.qry(a[i]-1),q[++idx]={0,i,a[i],1,0};
		bit.chp(a[i],1);
	}
	for(int i=n;i;i--) bit.clr(a[i]);
	cin&gt;&gt;m;
	int l,r;
	for(int i=1;i&lt;=m;i++){
		cin&gt;&gt;l&gt;&gt;r;
		if(a[l]==a[r]) continue;
		if(l&gt;r) swap(l,r);
		q[++idx]={0,l,a[l],-1,i},q[++idx]={0,r,a[r],-1,i};
		q[++idx]={0,l,a[r],1,i},q[++idx]={0,r,a[l],1,i};
		if(l+1&lt;r){
			if(a[r])
				q[++idx]={1,r-1,a[r]-1,1,i},q[++idx]={1,l,a[r]-1,-1,i};
			if(a[r]&lt;tn)
				q[++idx]={1,r-1,tn,-1,i},q[++idx]={1,l,tn,1,i},
				q[++idx]={1,r-1,a[r],1,i},q[++idx]={1,l,a[r],-1,i};
			if(a[l])
				q[++idx]={1,r-1,a[l]-1,-1,i},q[++idx]={1,l,a[l]-1,1,i};
			if(a[l]&lt;tn)
				q[++idx]={1,r-1,tn,1,i},q[++idx]={1,l,tn,-1,i},
				q[++idx]={1,r-1,a[l],-1,i},q[++idx]={1,l,a[l],1,i};
		}
		ans[i]=(a[l]&lt;a[r]?1:-1),swap(a[l],a[r]);
	}
	cdq(1,idx);
	cout&lt;&lt;cur&lt;&lt;"\n";
	for(int i=1;i&lt;=m;i++) cout&lt;&lt;(cur+=ans[i])&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<p>树状数组维护的那一维，可以不拆成前缀，因为树状数组上本身就可以查询一个区间的信息。</p>
<p>这样拆分数量就从 <span class="math inline">\(10\)</span> 个降到了 <span class="math inline">\(8\)</span> 个，分治的元素总数减少了，不过相应地结构体要额外加一个属性，存储树状数组上查询的另一个端点，这可能会增加一些转移负担。不过实测起来，效率的确有所提升（24.96s <span class="math inline">\(\rightarrow\)</span> 21.80s）。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/229890062" rel="noopener nofollow">R229890062</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
#define eb emplace_back
using namespace std;
const int N=2e5+10,M=2e5+10;
int n,m,a[N],b[N],tn,idx,cur,ans[M];
struct Qr{bool op;int x,ix,iy,c,id;}q[N+12*M],t[N+12*M];
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[N];
	inline void chp(int x,int v){for(;x&lt;=tn;x+=lb(x)) s[x]+=v;}
	inline void clr(int x){for(;x&lt;=tn;x+=lb(x)) if(s[x]) s[x]=0;else return;}
	inline int qry(int x){int a=0;for(;x;x-=lb(x)) a+=s[x];return a;}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		for(;i&lt;=mid&amp;&amp;q[i].x&lt;=q[j].x;){
			if(!q[i].op) bit.chp(q[i].ix,q[i].c);
			t[k++]=q[i++];
		}
		if(q[j].op) ans[q[j].id]+=q[j].c*(bit.qry(q[j].iy)-bit.qry(q[j].ix-1));
		t[k++]=q[j++];
	}
	for(j=l;j&lt;i;j++) if(!q[j].op) bit.clr(q[j].ix);
	while(i&lt;=mid) t[k++]=q[i++];
	for(i=l;i&lt;=r;i++) q[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],b[i]=a[i];
	sort(b+1,b+1+n),tn=unique(b+1,b+1+n)-b-1;
	for(int i=n;i;i--){
		a[i]=lower_bound(b+1,b+1+tn,a[i])-b;
		cur+=bit.qry(a[i]-1),q[++idx]={0,i,a[i],0,1,0};
		bit.chp(a[i],1);
	}
	for(int i=n;i;i--) bit.clr(a[i]);
	cin&gt;&gt;m;
	int l,r;
	for(int i=1;i&lt;=m;i++){
		cin&gt;&gt;l&gt;&gt;r;
		if(a[l]==a[r]) continue;
		if(l&gt;r) swap(l,r);
		q[++idx]={0,l,a[l],0,-1,i},q[++idx]={0,r,a[r],0,-1,i};
		q[++idx]={0,l,a[r],0,1,i},q[++idx]={0,r,a[l],0,1,i};
		if(l+1&lt;r){
			if(a[r])
				q[++idx]={1, r-1, 1,      a[r]-1, 1,  i},
				q[++idx]={1, l,   1,      a[r]-1, -1, i};
			if(a[r]&lt;tn)
				q[++idx]={1, r-1, a[r]+1, tn,     -1, i},
				q[++idx]={1, l,   a[r]+1, tn,     1,  i};
			if(a[l]&lt;tn)
				q[++idx]={1, r-1, a[l]+1, tn,     1,  i},
				q[++idx]={1, l,   a[l]+1, tn,     -1, i};
			if(a[l])
				q[++idx]={1, r-1, 1,      a[l]-1, -1, i},
				q[++idx]={1, l,   1,      a[l]-1, 1,  i};
		}
		ans[i]=(a[l]&lt;a[r]?1:-1),swap(a[l],a[r]);
	}
	cdq(1,idx);
	cout&lt;&lt;cur&lt;&lt;"\n";
	for(int i=1;i&lt;=m;i++) cout&lt;&lt;(cur+=ans[i])&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p4169-violet-天使玩偶--sjy-摆棋子"><a href="https://www.luogu.com.cn/problem/P4169" class="dif6" rel="noopener nofollow">P4169 [Violet] 天使玩偶 / SJY 摆棋子</a></h4>
<p>先考虑只统计 <span class="math inline">\((x_i,y_i)\)</span> 左下角的点应该如何做。</p>
<p>对于 <span class="math inline">\((x_j,y_j)\)</span> 这个点，由于 <span class="math inline">\(x_j\le x_i,y_j\le y_i\)</span>，所以绝对值可以拆开：</p>
<p></p><div class="math display">\[(x_i+y_i)-(x_j+y_j)
\]</div><p></p><p>为了让其最小，我们要维护 <span class="math inline">\((x_j+y_j)\)</span> 的 <span class="math inline">\(\max\)</span> 值。</p>
<p>为了考虑所有的方向，我们用同样的方式跑 <span class="math inline">\(4\)</span> 次 CDQ 分治，每跑完一次就将坐标系旋转 <span class="math inline">\(90^\circ\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O((n+m)\log (n+m)\log V)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/230522698" rel="noopener nofollow">R230522698</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=3e5+10,M=3e5+10,Ve=1e6,V=Ve+10;
struct Node{int d1,d2,d3;bool op;}a[N+M],t[N+M];
bool cmpd1(Node a,Node b){return a.d1&lt;b.d1;}
int n,m,idx,ans[M];
inline int lb(int x){return x&amp;-x;}
void rot(){for(int i=1;i&lt;=idx;i++) swap(a[i].d2,a[i].d3),a[i].d2=Ve-a[i].d2;}
struct BIT{
	int s[V];
	void chp(int x,int v){for(++x;x&lt;V;x+=lb(x)) s[x]=max(s[x],v);}
	void clr(int x){for(++x;x&lt;V;x+=lb(x)) if(s[x]) s[x]=0;else break;}
	int qry(int x){int a=0;for(++x;x;x-=lb(x)) a=max(a,s[x]);return a?a:-3e6;}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		while(i&lt;=mid&amp;&amp;a[i].d2&lt;=a[j].d2){
			if(!a[i].op) bit.chp(a[i].d3,a[i].d2+a[i].d3);
			t[k++]=a[i++];
		}
		if(a[j].op) ans[a[j].d1]=min(ans[a[j].d1],a[j].d2+a[j].d3-bit.qry(a[j].d3)); 
		t[k++]=a[j++];
	}
	for(j=l;j&lt;i;j++) if(!a[j].op) bit.clr(a[j].d3);
	while(i&lt;=mid) t[k++]=a[i++];
	for(i=l;i&lt;=r;i++) a[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;m,idx=n;
	memset(ans,0x3f,sizeof ans);
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].d2&gt;&gt;a[i].d3;
	for(int i=1,op,x,y;i&lt;=m;i++) cin&gt;&gt;op&gt;&gt;x&gt;&gt;y,a[++idx]={i,x,y,op-1};
	for(int i=0;i&lt;4;i++){
		if(i) rot(),sort(a+1,a+idx+1,cmpd1);
		cdq(1,idx);
	}
	for(int i=1;i&lt;=m;i++) if(ans[i]!=ans[0]) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p10633-bzoj2989-数列--bzoj4170-极光"><a href="https://www.luogu.com.cn/problem/P10633" class="dif5" rel="noopener nofollow">P10633 BZOJ2989 数列 / BZOJ4170 极光</a></h4>
<p>我们将每个元素视作二维平面上的点 <span class="math inline">\((i,a_i)\)</span>。</p>
<p>查询操作就是求到某个点曼哈顿距离 <span class="math inline">\(\le k\)</span> 的点的个数。</p>
<p>限制条件写成两个绝对值相加的形式实在不好做。</p>
<p>但是我们发现，到某个点的曼哈顿距离为定值 <span class="math inline">\(k\)</span> 的点集，画出来是一个斜 <span class="math inline">\(45^\circ\)</span> 的正方形。</p>
<p>也就是说，如果我们将坐标轴旋转 <span class="math inline">\(45^\circ\)</span> 并放大 <span class="math inline">\(\sqrt{2}\)</span> 倍，将每个点 <span class="math inline">\((x,y)\)</span> 映射到 <span class="math inline">\((x+y,-x-y)\)</span>，那么查询的区间就变成了一个以 <span class="math inline">\((x,y)\)</span> 为中心，边长为 <span class="math inline">\(2k\)</span> 的正方形，且它与 <span class="math inline">\(x,y\)</span> 轴平行。</p>
<p>这其实就是曼哈顿距离和切比雪夫距离之间的转化，我们刚才从数形结合的角度理解了这一过程。OI Wiki 上有<a href="https://oi-wiki.org/geometry/distance/#%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB%E4%B8%8E%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96" target="_blank" rel="noopener nofollow">更为严谨的证明</a>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/231365554" rel="noopener nofollow">R231365554</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=6e4+10,M=1.1e5,Ve=1e5,V=Ve+N;
struct Node{int id,x,il,ir,c;}q[4*M+N],t[4*M+N];
int n,m,idx,a[N],ans[M],qidx;
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[V];
	inline void chp(int x,int v){for(;x&lt;V;x+=lb(x)) s[x]+=v;}
	inline void clr(int x){for(;x&lt;V;x+=lb(x)) if(s[x]) s[x]=0;else return;}
	inline int qry(int x){int a=0;for(x=min(x,V-1),x=max(x,0);x;x-=lb(x)) a+=s[x];return a;}
	inline int qry(int x,int y){return qry(y)-qry(x-1);}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		for(;i&lt;=mid&amp;&amp;q[i].x&lt;=q[j].x;){
			if(!q[i].c) bit.chp(q[i].il,1);
			t[k++]=q[i++];
		}
		if(q[j].c) ans[q[j].id]+=q[j].c*bit.qry(q[j].il,q[j].ir);
		t[k++]=q[j++];
	}
	for(j=l;j&lt;i;j++) if(!q[j].c) bit.clr(q[j].il);
	while(i&lt;=mid) t[k++]=q[i++];
	for(i=l;i&lt;=r;i++) q[i]=t[i];
}
signed main(){
	cin&gt;&gt;n&gt;&gt;m,idx=n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],q[i]={0,a[i]+i,a[i]-i+n,0,0};
	string op;int x,k;
	for(int i=1;i&lt;=m;i++){
		cin&gt;&gt;op&gt;&gt;x&gt;&gt;k;
		if(op[0]=='M'){
			a[x]=k;
			q[++idx]={0,k+x,k-x+n,0,0};//由于可能出现负数，所有y坐标都进行了+n处理
		}else{
			qidx++;
			q[++idx]={qidx,a[x]+x+k,a[x]-x-k+n,a[x]-x+k+n,1};
			q[++idx]={qidx,a[x]+x-k-1,a[x]-x-k+n,a[x]-x+k+n,-1};
		}
	}
	cdq(1,idx);
	for(int i=1;i&lt;=qidx;i++) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="cf848c-goodbye-souvenir"><a href="https://www.luogu.com.cn/problem/CF848C" class="dif6" rel="noopener nofollow">CF848C Goodbye Souvenir</a></h4>
<p>“每种颜色最右边 <span class="math inline">\(−\)</span> 最左边求和” 看起来不好直接维护，但是可以转化为“相邻同色位置的下标差求和”。</p>
<p>也就是说，如果令 <span class="math inline">\(pre_i\)</span> 表示 <span class="math inline">\(a_i\)</span> 上一次出现的位置（不存在则为 <span class="math inline">\(0\)</span>），那么 <span class="math inline">\([l,r]\)</span> 的答案就是：</p>
<p></p><div class="math display">\[\sum\limits_{i\le r,pre_i\ge l} i-pre_i
\]</div><p></p><p>将 <span class="math inline">\((i,pre_i)\)</span> 看作二维平面上的点，就是二维数点了。</p>
<p>不过还有一点，单点修改时，可能受影响的 <span class="math inline">\(pre\)</span> 值有哪些？</p>
<ul>
<li>被修改的位置。</li>
<li>与旧颜色相同的后一位。</li>
<li>与新颜色相同的后一位。</li>
</ul>
<p>我们可以用 <code>set</code> 很方便地维护这些位置信息。</p>
<details>
<summary>点击查看代码 - <a href="https://codeforces.com/problemset/submission/848/334206726" rel="noopener nofollow">#334206726</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int N=1e5+10,M=1e5+10,V=1e5+10;
int n,m,a[N],idx,qidx;ll ans[M];
set&lt;int&gt; p[V];
struct Node{int id,p,pre,k;}q[N+6*M],t[N+6*M];
inline int lb(int x){return x&amp;-x;}
struct BIT{//后缀BIT，值域[0,n)
	ll s[N];
	void chp(int x,int v){for(;x;x-=lb(x)) s[x]+=v;}
	void clr(int x){for(;x;x-=lb(x)) if(s[x]) s[x]=0;else return;}
	int qry(int x){int a=0;for(;x&lt;n;x+=lb(x)) a+=s[x];return a;}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		for(;i&lt;=mid&amp;&amp;q[i].p&lt;=q[j].p;){
			if(!q[i].id) bit.chp(q[i].pre,q[i].k);
			t[k++]=q[i++];
		}
		if(q[j].id) ans[q[j].id]+=bit.qry(q[j].pre);//查询&gt;=q[j].pre
		t[k++]=q[j++];
	}
	for(j=l;j&lt;i;j++) bit.clr(q[j].pre);
	while(i&lt;=mid) t[k++]=q[i++];
	for(i=l;i&lt;=r;i++) q[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1,pre;i&lt;=n;i++){
		cin&gt;&gt;a[i];
		pre=p[a[i]].empty()?0:(*p[a[i]].rbegin());
		q[++idx]={0,i,pre,i-pre};
		p[a[i]].insert(i);
	}
	int op,x,y,pre,nxt;
	set&lt;int&gt;::iterator it;
	for(int i=1;i&lt;=m;i++){
		cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;
		if(op==1){
			if(a[x]==y) continue;
			p[a[x]].erase(x);
			it=p[y].lower_bound(x+1),pre=0;//1.与新颜色相同的后一位
			if(it!=p[y].begin()) pre=*(--it);
			it=p[y].upper_bound(x);
			if(it!=p[y].end()){
				nxt=*it;
				q[++idx]={0,nxt,x,nxt-x};
				q[++idx]={0,nxt,pre,pre-nxt};
			}
			it=p[a[x]].lower_bound(x+1),pre=0;//2.与旧颜色相同的后一位
			if(it!=p[a[x]].begin()) pre=*(--it);
			it=p[a[x]].upper_bound(x);
			if(it!=p[a[x]].end()){
				nxt=*it;
				q[++idx]={0,nxt,pre,nxt-pre};
				q[++idx]={0,nxt,x,x-nxt};
			}
			q[++idx]={0,x,pre,pre-x};//3.被修改的位置
			a[x]=y,pre=0;
			it=p[y].lower_bound(x+1);
			if(it!=p[y].begin()) pre=*(--it);
			p[y].insert(x);
			q[++idx]={0,x,pre,x-pre};
		}else{
			q[++idx]={++qidx,y,x,0};//第一维∈[1,y]，第二维∈[x,n]
		}
	}
	cdq(1,idx);
	for(int i=1;i&lt;=qidx;i++) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p1903-国家集训队-数颜色--维护队列"><a href="https://www.luogu.com.cn/problem/P1903" class="dif5" rel="noopener nofollow">P1903 [国家集训队] 数颜色 / 维护队列</a></h4>
<p>本质上是 <a href="https://www.luogu.com.cn/problem/P1972" target="_blank" rel="noopener nofollow">P1972 [SDOI2009] HH 的项链</a>加了个点修。</p>
<p>我们沿用其思路来做。考虑单点修改时，可能受影响的 <span class="math inline">\(pre\)</span> 值有哪些？</p>
<ul>
<li>被修改的位置。</li>
<li>与旧颜色相同的后一位。</li>
<li>与新颜色相同的后一位。</li>
</ul>
<p>我们可以用 <code>set</code> 很方便地维护这些位置信息。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/231365969" rel="noopener nofollow">R231365969</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=133333+10,M=133333+10;
int n,m,tn,a[N],b[N+M],idx,qidx,ans[M];
unordered_map&lt;int,int&gt; ma;
set&lt;int&gt; p[N+M];
struct Query{char op;int x,y;}tq[M];
struct Node{int id,x,y,c;}q[N+6*M],t[N+6*M];
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[N];
	void chp(int x,int v){for(;x&lt;=n;x+=lb(x)) s[x]+=v;}
	void clr(int x){for(;x&lt;=n;x+=lb(x)) if(s[x]) s[x]=0;else return;}
	int qry(int x){int a=0;for(;x;x-=lb(x)) a+=s[x];return a;}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		for(;i&lt;=mid&amp;&amp;q[i].y&lt;=q[j].y;){
			if(!q[i].id) bit.chp(q[i].x,q[i].c);
			t[k++]=q[i++];
		}
		if(q[j].id) ans[q[j].id]+=q[j].c*bit.qry(q[j].x);
		t[k++]=q[j++];
	}
	for(j=l;j&lt;i;j++) bit.clr(q[j].x);
	for(;i&lt;=mid;) t[k++]=q[i++];
	for(i=l;i&lt;=r;i++) q[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],b[++tn]=a[i];
	for(int i=1;i&lt;=m;i++){
		cin&gt;&gt;tq[i].op&gt;&gt;tq[i].x&gt;&gt;tq[i].y;
		if(tq[i].op=='R') b[++tn]=tq[i].y;
	}
	sort(b+1,b+1+tn),tn=unique(b+1,b+1+tn)-b-1;
	for(int i=1;i&lt;=tn;i++) ma[b[i]]=i;
	for(int i=1,pre;i&lt;=n;i++){
		a[i]=ma[a[i]];
		pre=p[a[i]].empty()?0:(*p[a[i]].rbegin());
		q[++idx]={0,i,pre,1};
		p[a[i]].insert(i);
	}
	set&lt;int&gt;::iterator it;
	for(int i=1,pre,nxt;i&lt;=m;i++){
		auto [op,x,y]=tq[i];//仅c++17及以上可用，请勿在NOIp等考场上使用！
		if(op=='Q'){
			qidx++;
			q[++idx]={qidx,y,x-1,1};
			q[++idx]={qidx,x-1,x-1,-1};
		}else{
			y=ma[y];
			p[a[x]].erase(x);
			it=p[y].lower_bound(x+1),pre=0;//1.与新颜色相同的后一位
			if(it!=p[y].begin()) pre=*(--it);
			it=p[y].upper_bound(x);
			if(it!=p[y].end()){
				nxt=*it;
				q[++idx]={0,nxt,x,1};
				q[++idx]={0,nxt,pre,-1};
			}
			it=p[a[x]].lower_bound(x+1),pre=0;//2.与旧颜色相同的后一位
			if(it!=p[a[x]].begin()) pre=*(--it);
			it=p[a[x]].upper_bound(x);
			if(it!=p[a[x]].end()){
				nxt=*it;
				q[++idx]={0,nxt,x,-1};
				q[++idx]={0,nxt,pre,1};
			}
			q[++idx]={0,x,pre,-1};//3.被修改的位置
			a[x]=y,pre=0;
			it=p[y].lower_bound(x+1);
			if(it!=p[y].begin()) pre=*(--it);
			p[y].insert(x);
			q[++idx]={0,x,pre,1};
		}
	}
	cdq(1,idx);
	for(int i=1;i&lt;=qidx;i++) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p4690-ynoi-easy-round-2016-镜中的昆虫"><a href="https://www.luogu.com.cn/problem/P4690" class="dif7" rel="noopener nofollow">P4690 [Ynoi Easy Round 2016] 镜中的昆虫</a></h4>
<p>本质上是将上题的点修变成区修。</p>
<p>继续沿用上题的思路，就 <span class="math inline">\(pre\)</span> 数组进行分析。查询和上题相同，我们主要分析区间赋值。</p>
<p>先给结论：对长度为 <span class="math inline">\(n\)</span> 的序列进行 <span class="math inline">\(m\)</span> 次区间赋值操作后，<span class="math inline">\(pre\)</span> 数组的变化次数为 <span class="math inline">\(O(n+m)\)</span> 级别。</p>
<p>简单证明一下：</p>
<p>如果我们将同色连续段称作一个<strong>块</strong>，那么不难发现，除了块的开头，其他位置的 <span class="math inline">\(pre\)</span> 值全部都是其下标 <span class="math inline">\(-1\)</span>。</p>
<p>而每次区修一定可以拆成若干个块拼起来（若不能恰好取到左右端点，则将左右端点所在的块分裂），修改完成后这些小的块会被消掉，变成一个大的块。则此过程中发生变化的 <span class="math inline">\(pre\)</span> 值仅有：</p>
<ul>
<li>这些块开头的 <span class="math inline">\(pre\)</span> 值。</li>
<li>所操作的区间右侧，与各个块原颜色相同的第一个位置。</li>
</ul>
<p>两者同阶，故每次操作 <span class="math inline">\(pre\)</span> 的变化次数是 <span class="math inline">\(O(\text{删去的块的个数})\)</span>，而每次我们最多添加 <span class="math inline">\(3\)</span> 个块（左右端点所在的块分裂算 <span class="math inline">\(2\)</span> 个，最后的大块算 <span class="math inline">\(1\)</span> 个），所以删去的块的个数是 <span class="math inline">\(O(n+m)\)</span> 数量级的，这样就得证了。</p>
<hr>
<p>我们可以用 <code>set</code> 来维护每个块，对 <span class="math inline">\(pre\)</span> 值的操作直接 CDQ 处理。</p>
<p>时间复杂度 <span class="math inline">\(O((n+m)\log^2 (n+m))\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/227633778" rel="noopener nofollow">R227633778</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#include&lt;ext/pb_ds/hash_policy.hpp&gt;
#include&lt;ext/pb_ds/assoc_container.hpp&gt;
using namespace std;
using namespace __gnu_pbds;
const int N=1e5+1,M=1e5+1;
int n,m,tn,a[N],b[N+M],pre[N],lst[N+M],st[N+M],top,idx,ans[M];
bitset&lt;N+M&gt; in;
struct Que{int l,r,x;}q[M];
gp_hash_table&lt;int,int&gt; ma;
set&lt;int&gt; ra,p[N+M];//ra记录所有块的左端点，p[i]记录颜色为i的所有块的左端点
struct Node{int d1,d2,d3,c,k;}c[10*N],t[10*N];//(d1,d2,d3,c,k)=(tim,i,pre_i,统计时的权重(±1),点修的参数)
bool cmp(Node a,Node b){return a.d1==b.d1?(a.d3==b.d3?a.d2&lt;b.d2:a.d3&lt;b.d3):a.d1&lt;b.d1;}
void solve(int tim,int l,int r,int x){//将[l,r]置为x
	auto lp=--ra.lower_bound(l+1),rp=ra.upper_bound(r),tmp=lp;//左闭右开
	if(*lp!=l) p[a[*lp]].insert(l),pre[l]=l-1,a[l]=a[*lp],lp=ra.insert(l).first;//分裂左端点所在区间
	if(*rp!=r+1) p[a[*prev(rp)]].insert(r+1),pre[r+1]=r,a[r+1]=a[*prev(rp)],rp=ra.insert(r+1).first;//右端点
	in[st[++top]=x]=1;//st记录修改区间右侧需要更新的颜色
	for(bool f=1;lp!=rp;ra.erase(lp++)){//lp=ra.erase(lp)也可以
		p[a[*lp]].erase(*lp);
		c[++idx]={tim,*lp,pre[*lp],0,-1};
		if(f) f=0,c[++idx]={tim,*lp,pre[*lp]=((tmp=p[x].lower_bound(*lp))==p[x].begin()?0:*(ra.upper_bound(*(--tmp)))-1),0,1};
		else c[++idx]={tim,*lp,pre[*lp]=*lp-1,0,1};//最左边的段需要查找前面的同色位置，其他段修改为i-1即可
		if(!in[a[*lp]]) in[st[++top]=a[*lp]]=1;
		a[*lp]=x;//由于每次访问都是在块的开头，所以更新也只操作块的开头元素即可
	}
	ra.insert(l),p[x].insert(l);
	int z;
	while(top){//处理修改区间右侧的pre
		in[z=st[top--]]=0;
		auto nxt=p[z].upper_bound(r);
		if(nxt!=p[z].end()){
			c[++idx]={tim,*nxt,pre[*nxt],0,-1};
			c[++idx]={tim,*nxt,pre[*nxt]=((tmp=p[z].lower_bound(*nxt))==p[z].begin()?0:*(ra.upper_bound(*(--tmp)))-1),0,1};
		}
	}
}
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[N];
	void chp(int x,int v){for(;x&lt;=n;x+=lb(x)) s[x]+=v;}
	void clr(int x){for(;x&lt;=n;x+=lb(x)) if(s[x]) s[x]=0;else break;}
	int qry(int x){int a=0;for(;x;x-=lb(x)) a+=s[x];return a;}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid),cdq(mid+1,r);
	for(i=k=l,j=mid+1;j&lt;=r;){
		while(i&lt;=mid&amp;&amp;c[i].d3&lt;=c[j].d3){
			if(c[i].k) bit.chp(c[i].d2,c[i].k);
			t[k++]=c[i++];
		}
		if(!c[j].k) ans[c[j].d1]+=c[j].c*bit.qry(c[j].d2);
		t[k++]=c[j++];
	}
	for(j=l;j&lt;i;j++) if(c[j].k) bit.clr(c[j].d2);
	while(i&lt;=mid) t[k++]=c[i++];
	for(i=l;i&lt;=r;i++) c[i]=t[i];
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;m,tn=n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],b[i]=a[i];
	for(int i=1,o;i&lt;=m;i++){
		cin&gt;&gt;o&gt;&gt;q[i].l&gt;&gt;q[i].r;
		if(2-o) cin&gt;&gt;q[i].x,b[++tn]=q[i].x;
	}
	sort(b+1,b+1+tn),tn=unique(b+1,b+1+tn)-b-1;
	for(int i=1;i&lt;=tn;i++) ma[b[i]]=i;
	for(int i=1;i&lt;=n;i++){
		a[i]=ma[a[i]];
		c[++idx]={0,i,pre[i]=lst[a[i]],0,1},lst[a[i]]=i;
		if(a[i]!=a[i-1]) ra.insert(i),p[a[i]].insert(i);
	}
	ra.insert(0),ra.insert(n+1);
	for(int i=1;i&lt;=m;i++){
		auto [l,r,x]=q[i];
		if(l&gt;r) continue;
		if(x) solve(i,l,r,ma[x]);
		else c[++idx]={i,r,l-1,1,0},c[++idx]={i,l-1,l-1,-1,0};
	}
	cdq(1,idx);
	for(int i=1;i&lt;=m;i++) if(ans[i]) cout&lt;&lt;ans[i]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<p>惊了，居然拿了洛谷最优解<sub>（现在不是了）</sub>？我也妹卡常啊 ( o o</p>
<p>总之 <code>solve()</code> 是真的难写难调啊。</p>
<p>在 LOJ 上看到了实现出人意料简洁的代码，见 <a href="https://loj.ac/s/1748229" target="_blank" rel="noopener nofollow">#1748229</a>。实现方法也是 CDQ 分治，如果有兴趣可以去学习一下。</p>
<h2 id="优化-1d--1d-动态规划的转移">优化 1D / 1D 动态规划的转移</h2>
<blockquote>
<p><strong>1D / 1D 动态规划</strong>指的是一类特定的 DP 问题，该类题目的特征是 DP 数组是一维的，转移是 <span class="math inline">\(O(n)\)</span> 的。如果条件良好的话，有时可以通过 CDQ 分治来把它们的时间复杂度由 <span class="math inline">\(O(n^2)\)</span> 降至 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<div style="text-align: right">—— <a href="https://oi-wiki.org/misc/cdq-divide/#cdq-%E5%88%86%E6%B2%BB%E4%BC%98%E5%8C%96-1d1d-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%BD%AC%E7%A7%BB" rel="noopener nofollow">OI Wiki</a></div>
</blockquote>
<p>举个例子，对于长度为 <span class="math inline">\(n\)</span> 的序列，每个元素有属性 <span class="math inline">\(a,b\)</span>。</p>
<p><span class="math inline">\(f_i=1+\max_j f_j\)</span>，其中 <span class="math inline">\(j\)</span> 满足 <span class="math inline">\(a_j&lt;a_i,b_j&lt;b_i\)</span>（<span class="math inline">\(a\)</span> 互不相同）。</p>
<p>本质上还是点对间的互相贡献，因此考虑使用 CDQ 分治。</p>
<p>贡献的记入和统计和之前是相同的，不再赘述。</p>
<p>不过需要注意，这里的转移是有严格的顺序要求的，一个位置要想参与转移，其本身的 DP 值必须已经被计算好。</p>
<p>这和动转静问题中处理“有时序依赖关系” 操作时遇到的问题是一样的。</p>
<p>所以我们仍需要采取中序遍历的方法，先 <code>cdq(l,mid)</code>，再跨区间转移，最后 <code>cdq(mid+1,r)</code>。</p>
<p>这样，在 <code>cdq(l,r)</code> 结束时，<span class="math inline">\(f_l,f_{l+1},\dots,f_r\)</span> 应该都被计算完毕。</p>
<p>上部分也提到过，中序遍历会破坏分治排序的结构，这种情况下我们一般对合并的那一位使用 <code>sort</code>，毕竟为了防止“代码过于复杂” 导致的各种错误，舍弃一点效率也是可以的。</p>
<p>况且如果你使用数据结构维护了某一维，时间复杂度的瓶颈就不止是 <code>sort</code> 了，还有数据结构。所以就算不用 <code>sort</code> 也仅仅是减小了常数而已。</p>
<p>所以说下文中我们会用到大量的 <code>sort</code>，如果你有“<code>cmp</code> 函数为什么这样写” 之类的疑惑的话，请到文章末尾看看关于 <code>cmp</code> 函数的说明。结合前文的分析应该不难理解这样做的正确性。</p>
<h3 id="例题-2">例题</h3>
<h4 id="b3637-最长上升子序列"><a href="https://www.luogu.com.cn/problem/B3637" class="dif2" rel="noopener nofollow">B3637 最长上升子序列</a></h4>
<p>可以结合代码来理解。</p>
<p>令 <span class="math inline">\(f_i\)</span> 为以 <span class="math inline">\(i\)</span> 结尾的最长上升子序列长度，则有转移：</p>
<p></p><div class="math display">\[f_j=1+\max_i f_i
\]</div><p></p><p>其中 <span class="math inline">\(i\)</span> 满足：</p>
<ul>
<li><span class="math inline">\(id_i&lt;id_j\)</span></li>
<li><span class="math inline">\(x_i&lt;x_j\)</span></li>
</ul>
<p>我们对 <span class="math inline">\(id\)</span> 分治，按 <span class="math inline">\(x\)</span> 合并。</p>
<p>由于我们没有归并排序，所以时间复杂度是 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/231707004" rel="noopener nofollow">R231707004</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=5e3+10;
int n,f[N];
struct Node{int id,x;}a[N],t[N];
bool cmp_id(const Node&amp; a,const Node&amp; b){return a.id&lt;b.id;}
bool cmp_x(const Node&amp; a,const Node&amp; b){return a.x&lt;b.x;}
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,mx=0;
	cdq(l,mid);
	for(i=mid+1;i&lt;=r;i++) t[i]=a[i];
	sort(a+l,a+mid+1,cmp_x),sort(a+mid+1,a+r+1,cmp_x);//对x排序
	for(i=l,j=mid+1;j&lt;=r;j++){//按x合并
		while(i&lt;=mid&amp;&amp;a[i].x&lt;a[j].x) mx=max(mx,f[a[i++].id]);
		f[a[j].id]=max(f[a[j].id],mx+1);
	}
	for(i=mid+1;i&lt;=r;i++) a[i]=t[i];//注意需要将右区间还原成id有序的状态
	cdq(mid+1,r);
}
signed main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].x,a[i].id=i;
	f[1]=1;
	cdq(1,n);
	cout&lt;&lt;*max_element(f+1,f+1+n)&lt;&lt;"\n";
	return 0;
}return 0;
}
</code></pre>
</details>
<h4 id="p4093-heoi2016--tjoi2016-序列"><a href="https://www.luogu.com.cn/problem/P4093" class="dif6" rel="noopener nofollow">P4093 [HEOI2016 / TJOI2016] 序列</a></h4>
<p>我们用 <span class="math inline">\(mn_i\)</span> 表示 <span class="math inline">\(a_i\)</span> 能够变到的最小值，<span class="math inline">\(mx_i\)</span> 表示能变到的最大值，<span class="math inline">\(f_i\)</span> 为以 <span class="math inline">\(i\)</span> 结尾的最长子序列长度，则有转移：</p>
<p></p><div class="math display">\[f_j=1+\max_i f_i
\]</div><p></p><p>其中 <span class="math inline">\(i\)</span> 满足：</p>
<ul>
<li><span class="math inline">\(id_i&lt;id_j\)</span></li>
<li><span class="math inline">\(x_i\le mn_j\)</span></li>
<li><span class="math inline">\(mx_i\le x_j\)</span></li>
</ul>
<p>我们可以对 <span class="math inline">\(id\)</span> 分治，解决第一维。</p>
<p>左区间按 <span class="math inline">\(x\)</span> 排序，右区间按 <span class="math inline">\(mn\)</span> 排序，双指针解决第二维。</p>
<p>树状数组维护第三维。具体来说，记入贡献时将第 <span class="math inline">\(mx_i\)</span> 位与 <span class="math inline">\(x_j\)</span> 取 <span class="math inline">\(\max\)</span>，统计贡献时查询 <span class="math inline">\(\le x_j\)</span> 位置的 <span class="math inline">\(\max\)</span>。</p>
<p>尽管 <span class="math inline">\(\max\)</span> 不可差分，但我们查询的区间始终是一个前缀，所以可以用树状数组来维护。</p>
<p>时间复杂度 <span class="math inline">\(O(m+n\log^2 n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/231708020" rel="noopener nofollow">R231708020</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e5+10,V=1e5+10;
int n,m,f[N];
struct Node{int id,x,mx,mn;}a[N],t[N];
inline bool cmpid(Node&amp; a,Node&amp; b){return a.id&lt;b.id;}
inline bool cmpx(Node&amp; a,Node&amp; b){return a.x&lt;b.x;}
inline bool cmpmx(Node&amp; a,Node&amp; b){return a.mx&lt;b.mx;}
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int mx[V];
	inline void chp(int x,int v){for(;x&lt;V;x+=lb(x)) mx[x]=max(mx[x],v);}
	inline void clr(int x){for(;x&lt;V;x+=lb(x)) if(mx[x]) mx[x]=0;else return;}
	inline int qry(int x){int a=0;for(;x;x-=lb(x)) a=max(a,mx[x]);return a;}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j;
	cdq(l,mid);
	for(i=mid+1;i&lt;=r;i++) t[i]=a[i];
	sort(a+l,a+mid+1,cmpmx),sort(a+mid+1,a+r+1,cmpx);
	for(i=l,j=mid+1;j&lt;=r;j++){
		for(;i&lt;=mid&amp;&amp;a[i].mx&lt;=a[j].x;i++) bit.chp(a[i].x,f[a[i].id]);
		f[a[j].id]=max(f[a[j].id],bit.qry(a[j].mn)+1);
	}
	for(j=l;j&lt;i;j++) bit.clr(a[j].x);
	for(i=mid+1;i&lt;=r;i++) a[i]=t[i];
	cdq(mid+1,r);
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1,x;i&lt;=n;i++) cin&gt;&gt;x,a[i]={i,x,x,x};
	for(int i=1,x,y;i&lt;=m;i++){
		cin&gt;&gt;x&gt;&gt;y;
		a[x].mx=max(a[x].mx,y);
		a[x].mn=min(a[x].mn,y);
	}
	f[1]=1;
	cdq(1,n);
	cout&lt;&lt;*max_element(f+1,f+1+n)&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p3364-cool-loves-touli"><a href="https://www.luogu.com.cn/problem/P3364" class="dif6" rel="noopener nofollow">P3364 Cool loves touli</a></h4>
<p>用 <span class="math inline">\(a_i,b_i,c_i\)</span> 分别表示每个英雄的 <span class="math inline">\(3\)</span> 个属性，用 <span class="math inline">\(f_i\)</span> 表示以 <span class="math inline">\(i\)</span> 结尾的最长子序列长度，则有转移：</p>
<p></p><div class="math display">\[f_j=1+\max_i f_i
\]</div><p></p><p>其中 <span class="math inline">\(i\)</span> 满足：</p>
<ul>
<li><span class="math inline">\(id_i&lt;id_j\)</span></li>
<li><span class="math inline">\(c_i\le a_j\)</span></li>
<li><span class="math inline">\(b_i\le c_j\)</span></li>
</ul>
<p>转移和上题完全一样。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/231708552" rel="noopener nofollow">R231708552</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#include&lt;ext/pb_ds/assoc_container.hpp&gt;
#include&lt;ext/pb_ds/hash_policy.hpp&gt;
using namespace std;
using namespace __gnu_pbds;
const int N=1e5+10;
gp_hash_table&lt;int,int&gt; ma;
struct Node{int d1,d2,d3,d4,id;}a[N],t[N];
bool cmpd1(Node a,Node b){return a.d1&lt;b.d1;}
bool cmpd3(Node a,Node b){return a.d3&lt;b.d3;}
bool cmpd4(Node a,Node b){return a.d4&lt;b.d4;}
int n,w[N],f[N],b[3*N],tn;
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[3*N];
	void chp(int x,int v){for(;x&lt;=tn;x+=lb(x)) s[x]=max(s[x],v);}
	void clr(int x){for(;x&lt;=tn;x+=lb(x)) if(s[x]) s[x]=0;else break;}
	int qry(int x){int a=0;for(;x;x-=lb(x)) a=max(a,s[x]);return a;}
}bit;
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq(l,mid);
	for(i=mid+1;i&lt;=r;i++) t[i]=a[i];
	sort(a+l,a+mid+1,cmpd3),sort(a+mid+1,a+r+1,cmpd4);
	for(i=k=l,j=mid+1;j&lt;=r;j++){
		for(;i&lt;=mid&amp;&amp;a[i].d3&lt;=a[j].d4;i++) bit.chp(a[i].d4,f[a[i].id]);
		f[a[j].id]=max(f[a[j].id],bit.qry(a[j].d2)+1);
	}
	for(j=l;j&lt;i;j++) bit.clr(a[j].d4);
	for(i=mid+1;i&lt;=r;i++) a[i]=t[i];
	cdq(mid+1,r);
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].d1&gt;&gt;a[i].d2&gt;&gt;a[i].d3&gt;&gt;a[i].d4,a[i].id=i,b[++tn]=a[i].d2,b[++tn]=a[i].d3,b[++tn]=a[i].d4;
	sort(b+1,b+1+tn),tn=unique(b+1,b+1+tn)-b-1;
	for(int i=1;i&lt;=tn;i++) ma[b[i]]=i;
	for(int i=1;i&lt;=n;i++) a[i].d2=ma[a[i].d2],a[i].d3=ma[a[i].d3],a[i].d4=ma[a[i].d4],f[i]=1;
	sort(a+1,a+1+n,cmpd1),cdq(1,n);
	cout&lt;&lt;*max_element(f+1,f+1+n)&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h4 id="p5621-dboi2019-德丽莎世界第一可爱"><a href="https://www.luogu.com.cn/problem/P5621" class="dif6" rel="noopener nofollow">P5621 [DBOI2019] 德丽莎世界第一可爱</a></h4>
<p><span class="math inline">\(i\)</span> 转移到 <span class="math inline">\(j\)</span> 需要满足四个属性均 <span class="math inline">\(\le j\)</span>。</p>
<p>仿照四维偏序来写，没什么可说的，注意两层 CDQ 都要按中序遍历进行。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^3 n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/231709287" rel="noopener nofollow">R231709287</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int N=5e4+10,V=2e5+2,O=1e5+1;
int n,s[N],f[N];
struct Node{int d1,d2,d3,d4,id;bool s;}a[N],t2d[N],t3d[N];
inline bool cmpd1(Node a,Node b){return a.d1==b.d1?(a.d2==b.d2?(a.d3==b.d3?(a.d4==b.d4?a.id&lt;b.id:a.d4&lt;b.d4):a.d3&lt;b.d3):a.d2&lt;b.d2):a.d1&lt;b.d1;}
inline bool cmpd2(Node a,Node b){return a.d2==b.d2?(a.d3==b.d3?(a.d4==b.d4?(a.d1==b.d1?a.id&lt;b.id:a.d1&lt;b.d1):a.d4&lt;b.d4):a.d3&lt;b.d3):a.d2&lt;b.d2;}
inline bool cmpd3(Node a,Node b){return a.d3&lt;b.d3;}
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int s[V];
	inline void init(){memset(s,-0x3f,sizeof s);}
	inline void chp(int x,int v){for(x+=O;x&lt;V;x+=lb(x)) s[x]=max(s[x],v);}
	inline void clr(int x){for(x+=O;x&lt;V;x+=lb(x)) if(s[x]!=s[0]) s[x]=s[0];else return;}
	inline int qry(int x){int a=0;for(x+=O;x;x-=lb(x)) a=max(a,s[x]);return a;}
}bit;
void cdq3d(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k;
	cdq3d(l,mid);
	for(i=mid+1;i&lt;=r;i++) t3d[i]=t2d[i];
	sort(t2d+l,t2d+mid+1,cmpd3),sort(t2d+mid+1,t2d+r+1,cmpd3);
	for(i=k=l,j=mid+1;j&lt;=r;j++){
		for(;i&lt;=mid&amp;&amp;t2d[i].d3&lt;=t2d[j].d3;i++) if(!t2d[i].s) bit.chp(t2d[i].d4,f[t2d[i].id]);
		if(t2d[j].s) f[t2d[j].id]=max(f[t2d[j].id],bit.qry(t2d[j].d4)+s[t2d[j].id]);
	}
	for(j=l;j&lt;i;j++) if(!t2d[j].s) bit.clr(t2d[j].d4);
	for(i=mid+1;i&lt;=r;i++) t2d[i]=t3d[i];
	cdq3d(mid+1,r);
}
void cdq2d(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i;
	cdq2d(l,mid);
	for(i=l;i&lt;=mid;i++) a[i].s=0,t2d[i]=a[i];
	for(i=mid+1;i&lt;=r;i++) a[i].s=1,t2d[i]=a[i];
	sort(t2d+l,t2d+r+1,cmpd2),cdq3d(l,r);
	cdq2d(mid+1,r);
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	bit.init();
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].d1&gt;&gt;a[i].d2&gt;&gt;a[i].d3&gt;&gt;a[i].d4&gt;&gt;s[i],a[i].id=i;
	for(int i=1;i&lt;=n;i++) f[i]=s[i];
	sort(a+1,a+1+n,cmpd1),cdq2d(1,n);
	cout&lt;&lt;*max_element(f+1,f+1+n);
	return 0;
}
</code></pre>
</details>
<h4 id="p2487-sdoi2011-拦截导弹"><a href="https://www.luogu.com.cn/problem/P2487" class="dif6" rel="noopener nofollow">P2487 [SDOI2011] 拦截导弹</a></h4>
<p>这道题有两问，第一问是一个二维最长不降子序列，加上 <span class="math inline">\(tim\)</span> 相当于三维偏序，直接 DP 就行。</p>
<p>第二问是每个元素被选入最长不降子序列的概率。</p>
<p>我们记 <span class="math inline">\(f_1[i],g_1[i]\)</span> 分别为以 <span class="math inline">\(i\)</span> 结尾的长度和方案数，<span class="math inline">\(f_2[i],g_2[i]\)</span> 分别为以 <span class="math inline">\(i\)</span> 开头的长度和方案数。</p>
<p>则一个元素有可能属于某个最长不降子序列，当且仅当 <span class="math inline">\(f_1[i]+f_2[i]-1=f_1[n]\)</span>。</p>
<p>计算概率则为 <span class="math inline">\(\Large\frac{g_1[i]\times g_2[i]}{\sum g_1[i]}\)</span>。</p>
<p><span class="math inline">\(g\)</span> 的计算，仅需在 <span class="math inline">\(f\)</span> 转移的过程中判定：</p>
<ul>
<li>如果 <span class="math inline">\(f_{i}+1=f_{j}\)</span>，则 <span class="math inline">\(g_{j}\leftarrow g_{j}+g_{i}\)</span>。</li>
<li>如果 <span class="math inline">\(f_{i}+1&gt;f_{j}\)</span>，则 <span class="math inline">\(g_{j}\leftarrow g_{i}\)</span>。</li>
</ul>
<p>代码实现要跑两次 CDQ，一个算结尾，一个算开头。</p>
<p>为了减少码量，我将“以 <span class="math inline">\(i\)</span> 开头的最长不降子序列” 的答案转化为了“数组反转后，以 <span class="math inline">\(j\)</span> 开头的最长不增子序列”。这样我们仅需写一个 CDQ，根据 CDQ 的轮次更改比较规则，并在第二次 CDQ 之前反转一下原数组即可。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log^2 n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/231709847" rel="noopener nofollow">R231709847</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=5e4+10;
int n,f[2][N];
bool flg;
struct Node{int id,a,b;}a[N],t[N];
double sum,g[2][N];
inline int lb(int x){return x&amp;-x;}
struct BIT{
	int mx[N];double c[N];
	void chp(int x,int _mx,double _c){for(;x&lt;=n;x+=lb(x)) if(_mx==mx[x]) c[x]+=_c;else if(_mx&gt;mx[x]) c[x]=_c,mx[x]=_mx;}
	void clr(int x){for(;x&lt;=n;x+=lb(x)) if(mx[x]) mx[x]=c[x]=0;else break;}
	void qry(int x,int &amp;_mx,double &amp;_c){
		_mx=_c=0;
		for(;x;x-=lb(x)) if(mx[x]==_mx) _c+=c[x];else if(mx[x]&gt;_mx) _c=c[x],_mx=mx[x];
	}
}bit;
inline bool cmpb(Node a,Node b){return flg?a.b&lt;b.b:a.b&gt;b.b;}
inline bool cmpa(Node a,Node b){
	return a.a==b.a?a.id&lt;b.id:(flg?a.a&lt;b.a:a.a&gt;b.a);
}
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,mx;double c;
	cdq(l,mid);
	for(i=mid+1;i&lt;=r;i++) t[i]=a[i];
	sort(a+l,a+mid+1,cmpb),sort(a+mid+1,a+r+1,cmpb);
	for(i=l,j=mid+1;j&lt;=r;j++){
		while(i&lt;=mid&amp;&amp;(a[i].b==a[j].b||cmpb(a[i],a[j]))) bit.chp(a[i].id,f[flg][a[i].id],g[flg][a[i].id]),i++;
		bit.qry(a[j].id-1,mx,c);
		if(mx+1==f[flg][a[j].id]) g[flg][a[j].id]+=c;
		else if(mx+1&gt;f[flg][a[j].id]) f[flg][a[j].id]=mx+1,g[flg][a[j].id]=c;
	}
	for(i=l;i&lt;=mid;i++) bit.clr(a[i].id);
	for(i=mid+1;i&lt;=r;i++) a[i]=t[i];
	cdq(mid+1,r);
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i].a&gt;&gt;a[i].b,a[i].id=i,g[0][i]=g[1][i]=f[0][i]=f[1][i]=1;
	flg=0,sort(a+1,a+1+n,cmpa),cdq(1,n);
	for(int i=1;i&lt;=n;i++) a[i].id=n-a[i].id+1;
	flg=1,sort(a+1,a+1+n,cmpa),cdq(1,n);//由于id反转，所以f[1],g[1]也是反着存的
	int mx=*max_element(f[0]+1,f[0]+n+1);
	for(int i=1;i&lt;=n;i++) if(f[0][i]==mx) sum+=g[0][i];
	cout&lt;&lt;mx&lt;&lt;"\n";
	for(int i=1;i&lt;=n;i++){
		if(f[0][i]+f[1][n-i+1]-1==mx) cout&lt;&lt;fixed&lt;&lt;setprecision(5)&lt;&lt;g[0][i]*g[1][n-i+1]/sum&lt;&lt;" ";
		else cout&lt;&lt;"0.00000 ";
	}
	return 0;
}
</code></pre>
</details>
<h4 id="p6007-usaco20jan-springboards-g"><a href="https://www.luogu.com.cn/problem/P6007" class="dif5" rel="noopener nofollow">P6007 [USACO20JAN] Springboards G</a></h4>
<p>令 <span class="math inline">\(f_i\)</span> 为走到第 <span class="math inline">\(i\)</span> 个跳板的终点，最多能省下多少路程。</p>
<p>则有转移：</p>
<p></p><div class="math display">\[f_j=w_j+\max_i f_i
\]</div><p></p><p>其中 <span class="math inline">\(w_i\)</span> 为跳板 <span class="math inline">\(i\)</span> 能跨越的路程，即 <span class="math inline">\(x_2[i]-x_1[i]+y_2[i]-y_1[i]\)</span>。</p>
<p><span class="math inline">\(i\)</span> 需要满足：</p>
<ul>
<li><span class="math inline">\(x_2[i]\le x_1[j]\)</span></li>
<li><span class="math inline">\(y_2[i]\le y_1[j]\)</span></li>
</ul>
<p>不过代码实现中，为了减少单个节点存储的属性个数，我把一个跳板拆成两个点了，这样转移时：</p>
<ul>
<li><span class="math inline">\(x_i\le x_j\)</span></li>
<li><span class="math inline">\(y_i\le y_j\)</span></li>
<li><span class="math inline">\(i\)</span> 是一个跳板的终点</li>
<li><span class="math inline">\(j\)</span> 是一个跳板的起点</li>
</ul>
<p>这样限制一下就可以了。</p>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<details>
<summary>点击查看代码 - <a href="https://www.luogu.com.cn/record/231705070" rel="noopener nofollow">R231705070</a></summary>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e5+10;
struct Node{int x,y,id;bool t;}a[N&lt;&lt;1],t[N&lt;&lt;1];
inline bool cmpx(Node a,Node b){return a.x==b.x?(a.y==b.y?a.t&gt;b.t:a.y&lt;b.y):a.x&lt;b.x;}
inline bool cmpy(Node a,Node b){return a.y&lt;b.y;}// ↑ 注意位置相同时要将统计贡献放在记入贡献的后面
int k,n,idx,w[N],f[N];
void cdq(int l,int r){
	if(l==r) return;
	int mid=(l+r)&gt;&gt;1,i,j,k,mx=INT_MIN;
	cdq(l,mid);
	for(i=mid+1;i&lt;=r;i++) t[i]=a[i];
	sort(a+l,a+mid+1,cmpy),sort(a+mid+1,a+r+1,cmpy);
	for(i=k=l,j=mid+1;j&lt;=r;j++){
		for(;i&lt;=mid&amp;&amp;a[i].y&lt;=a[j].y;i++){
			if(a[i].t) mx=max(mx,f[a[i].id]);
		}
		if(!a[j].t) f[a[j].id]=max(f[a[j].id],mx+w[a[j].id]);
	}
	for(i=mid+1;i&lt;=r;i++) a[i]=t[i];
	cdq(mid+1,r);
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin&gt;&gt;k&gt;&gt;n;
	for(int i=1,x,y,xx,yy;i&lt;=n;i++){
		cin&gt;&gt;x&gt;&gt;y&gt;&gt;xx&gt;&gt;yy;
		a[++idx]={x,y,i,0};
		a[++idx]={xx,yy,i,1};
		w[i]=f[i]=xx+yy-x-y;
	}
	a[++idx]={k,k,0,0};
	sort(a+1,a+1+idx,cmpx),cdq(1,idx);
	cout&lt;&lt;2*k-f[0]&lt;&lt;"\n";
	return 0;
}
</code></pre>
</details>
<h2 id="细节">细节</h2>
<h3 id="小-trick">小 Trick</h3>
<p>随时更新。</p>
<ul>
<li>卡常小技巧：拿三维偏序举例，CDQ 过程中每个区间都存在 <span class="math inline">\(O((r-l+1)^2)\)</span> 的暴力，因此如果 <span class="math inline">\(r-l+1&lt;\log n\)</span> 的话可以直接暴力。</li>
<li>用于分治的那一维（比如时间戳）若已经自然有序，可以直接不存储这个属性。</li>
<li>可以将值域小的属性丢给树状数组，值域大的属性丢给排序 / 分治，这样有时可以省去离散化。</li>
<li><a href="https://www.cnblogs.com/flashhu/p/9381075.html" target="_blank">Flash_Hu 的博客</a>提到，我们可以不对每个元素封装 <code>struct</code>，而是用数组来存每个属性，仅记录每个元素的索引。这样排序时转移的也是若干整数，而非若干结构体变量。可以减少转移负担，不过相应的增加了数组的访问。或许只有属性较多的情况下才能体现出优势来，不过这个我也没有实测。</li>
<li>UOJ 群里说 <code>cdq</code> 做动态问题，当下主流的写法是仅对修改操作分治，查询操作用 <code>vector</code> 挂在修改操作的后面。我没怎么写过，如果有兴趣可以参考 <a href="https://www.luogu.com.cn/record/219336112" target="_blank" rel="noopener nofollow">这份代码</a>，效率并未实测。</li>
<li><a href="https://www.cnblogs.com/YunQianQwQ/p/16364951.html" target="_blank">云浅 的博客</a>中给出了一种 <span class="math inline">\(O(n\log n)\)</span> 计算三维偏序的算法。不过其有一定局限性，不能算出特定三元组产生的贡献，并且偏序条件必须包含 <code>=</code>。由于和 CDQ 关系不大，这里就不加说明了。</li>
</ul>
<h3 id="关于所有维度都严格小于的偏序问题">关于所有维度都严格小于的偏序问题</h3>
<p>前文我们提到，在这种条件下，我们只能对没有重复值的那一维进行分治，否则不能保证“左区间的该属性 <span class="math inline">\(&lt;\)</span> 右区间的该属性”。</p>
<p>可如果恰好所有维度都有重复元素呢？</p>
<p>不知道你有没有见过这样的题，反正我是没见过，所以我造了几道。</p>
<p><a href="https://www.luogu.com.cn/problem/U593161" class="dif3" rel="noopener nofollow">二维偏序（严格小于）</a> ~ <a href="https://www.luogu.com.cn/problem/U593267" class="dif6" rel="noopener nofollow">三维偏序（严格小于）</a> ~ <a href="https://www.luogu.com.cn/problem/U593329" class="dif6" rel="noopener nofollow">四维偏序（严格小于）</a></p>
<p>经过 vuqa 和谷讨论区，我得到了一个可行的解决方法（from lzyqwq）。</p>
<p>就是将询问单独提出来，就是额外加 <span class="math inline">\(n\)</span> 个点，每个查询形如“第一维 <span class="math inline">\(\le a_i-1\)</span>，第二维 <span class="math inline">\(\le b_i-1\)</span>，……”，就是数点问题了。</p>
<p>std 放在每个题面的下方了。</p>
<h3 id="关于-cmp-函数">关于 <code>cmp</code> 函数</h3>
<p>写 <code>cmp</code> 的宗旨就是：对于一个元素，把所有为它提供贡献的元素放在它的左边。</p>
<p>这个原理我们很容易理解，但是真正落实到代码上，我们可能会有很多困惑（尤其是我）。</p>
<blockquote>
<p>这 <code>cmp</code> 到底该怎么写？</p>
<p>什么时候判等号，什么时候需要顾及更高维的属性，什么时候比较当前这一维就可以了？</p>
</blockquote>
<p>简单来说：</p>
<ul>
<li>
<p>用于分治的最内层的属性，排序是只考虑自己的值就可以了。</p>
</li>
<li>
<p>其他属性，排序时都需要额外考虑其他属性（作为第 <span class="math inline">\(2,3,\dots\)</span> 关键字，顺序无所谓）。</p>
<p>特别地，若某一属性无重复元素，则只需额外考虑这一个属性（相当于把不必要的等号去掉了）。</p>
</li>
</ul>
<h3 id="关于-sort-和-stable_sort">关于 <code>sort</code> 和 <code>stable_sort</code></h3>
<p>在<a href="#anchor1" rel="noopener nofollow">前文</a>我们提及了 <code>stable_sort</code> 的作用，在这里比较一下两个函数的使用。</p>
<p>如果你使用 <code>sort</code>：</p>
<ul>
<li>需要预先处理完全相同的元素（如果有的话）：去重，或者添加一个互不相同的属性。</li>
<li><code>cmp</code> 函数要按上面第二条的规则来写。</li>
</ul>
<p>如果你使用 <code>stable_sort</code> / 归并：</p>
<ul>
<li>
<p>无需处理重复元素问题。</p>
</li>
<li>
<p><code>cmp</code> 函数仅需在主函数的排序中按上面的规则来写，其他属性只需要考虑自己这一维就行了。</p>
<p>原因前文提到过：自定义规则下相等的元素，在 <code>stable_sort</code> 中会保持相对顺序不变。</p>
</li>
</ul>
<h2 id="后">后</h2>
<p>本文较长，难免有疏漏和谬误<del style="color: rgba(128, 128, 128, 0.5)">（有超级奇怪的表述也说不定呢）</del>。如果有疑问或者修正或者补充说明，请发在评论区，我会认真阅读的！</p>
<p>CDQ 套斜率优化什么的……如果有空会写（逃）</p>
<details>
<summary>后话</summary>
<div style="padding: 16px; background-color: var(--vbg-color)">
<p>从初识这个算法到完成这篇笔记（7/20~8/18），已经过去了将近一个月的时间。</p>
<p>这段时间内，我学习的途径完全来自网络。阅读各路大神的博客，与谷 u 讨论，在 UOJ 裙求助……</p>
<p>虽然信竞是一门十分依赖选手之间交流的竞赛，不过我发觉到网络上的知识是十分零散的（“细节” 部分的内容几乎没有博客单独提出来强调），要想真正解答疑惑，请教别人是必不可少的过程。除此之外还要对当下主流的算法达到熟练掌握（例如那个挂 <code>vector</code> 的写法）。我想这也印证了信息竞赛正在成为“圈子竞赛” 这个观点吧。</p>
<p>在求助于别人和自己的思考当中，我逐渐理清了算法的各种细节，也理清了我混乱的思路。</p>
<p>但同时，也深深感觉到，自己已经落下别人太远了。</p>
<p>不仅在算法、数据结构的掌握方面，更在于自己的思维、策略方面。</p>
<p>同校的信竞大神已经在初二初三就开始参加省选的集训了，同为初三（准高一）的我，相比之下完全不算有天赋、有实力的人，努力也绝对比不上他们，所以不能走得太远，打完今年的 NOIp 我应该就退役了（如果能够省一的话）；文化课方面处处爆杀我的也大有人在。因此我常常感到无可适从，不过总会到头的，毕竟信竞陪伴我的时间可能已经开始倒计时了。</p>
<p>有人和我说，一个注定了留不住的东西，你还要在上面做什么文章？专心弄文化课，或者至少在 NOIp 前把你提高级的知识点搞好就很厉害了。</p>
<p>不知道大家如何，反正我做一件事情，一旦在中途产生对“目的” 的疑惑，整个人就会变得空虚、迷茫。</p>
<p>开这个坑后的一段时间，这种感觉时不时缠绕着我，或许是出于退役前的倔强吧，这种时候越是需要冷静，我就越往前死磕，一天下来除了做了几道题之外，自己悟透了什么？好像没有。</p>
<p>不过在这篇博客完成过半时，我找到了自己开始写博客的初衷。</p>
<p>我写这些博客，不光是为了自己，更是为了像现在的我这样困惑的后人。不会有人永远困惑，但永远都会有人困惑。</p>
<p>想到了稗田阿求，为了“先代” 也好，为了“人类” 也好，总要有东西支持她义无反顾地完成这一切（无端联想）。</p>
<img src="https://img2024.cnblogs.com/blog/3322276/202508/3322276-20250818175359098-530630954.png" style="width: 200px">
<div style="color: rgba(128, 128, 128, 0.5)"><del>牛逼！又多活一天</del></div>
<p>还有一部分原因，应该就是为了给自己留下一点回忆吧。虽然现在还是心存不舍，不过这样一想，选择了这条路的自己和选择了那条路的自己，到底还是一个人嘛。</p>
<p>至少，我心念的旧物，曾带给了我过什么，或许是解题的思维，或许是 AC 的喜悦，或许是一路同行的伙伴。</p>
<p>我一定也在这方面为别人带来了什么，或许是知识，或许是答疑解惑，或许是将互相<s>产生</s>贡献的精神传承了一下。</p>
<p>心有这个念想足矣，在我重新起步的时候，我会坦然地说：</p>
<p>曾经拥有它真的太好了。</p>
<hr>
<p>我会尽力的。希望大学还能回来！</p>
</div>
</details>
<p>引用致谢：</p>
<ul>
<li><a href="https://oi-wiki.org/misc/cdq-divide/" target="_blank" rel="noopener nofollow">OI Wiki - CDQ 分治</a></li>
<li><a href="https://www.cnblogs.com/mlystdcall/p/6232324.html" target="_blank">mlystdcall - 【教程】CDQ 套 CDQ—— 四维偏序问题</a></li>
<li><a href="https://www.luogu.com.cn/article/gkc5phm3" target="_blank" rel="noopener nofollow">complete_binary_tree - 题解：P3810 【模板】三维偏序（陌上花开）</a></li>
<li><a href="https://www.cnblogs.com/flashhu/p/9381075.html" target="_blank">Flash_Hu - CDQ 分治总结（CDQ，树状数组，归并排序）</a></li>
</ul>
<p></p><div class="math display">\[\Large\underline{\text{CDQ Divide}}_{\text{ last update on 2025/8/18}}\\
\]</div><p></p><p></p><div class="math display">\[\small\text{～　冷　氣　開　放　注　意　～}
\]</div><p></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-19 07:54">2025-08-19 07:53</span>&nbsp;
<a href="https://www.cnblogs.com/Sinktank">Sinktank</a>&nbsp;
阅读(<span id="post_view_count">18</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19045786);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19045786', targetLink: 'https://www.cnblogs.com/Sinktank/p/19045786', title: '[笔记]CDQ 分治' })">举报</a>
</div>
        