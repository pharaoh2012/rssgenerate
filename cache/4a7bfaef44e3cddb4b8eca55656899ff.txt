
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hunterxiong/p/19025904" title="发布于 2025-08-06 21:28">
    <span role="heading" aria-level="2">Golang笔记之Redis</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>本文首发于公众号：Hunter后端</p>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/ugf55evehQd9a1fa8GFiOQ" target="_blank" rel="noopener nofollow">Golang笔记之Redis</a></p>
</blockquote>
<p>这一篇笔记主要介绍 Golang 连接和使用 Redis，以下是本篇笔记目录：</p>
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1安装模块" rel="noopener nofollow">1、安装模块</a></li><li><a href="#2连接-redis" rel="noopener nofollow">2、连接 Redis</a></li><li><a href="#3字符串" rel="noopener nofollow">3、字符串</a><ul><li><a href="#1-字符串写入" rel="noopener nofollow">1. 字符串写入</a></li><li><a href="#2-字符串读取" rel="noopener nofollow">2. 字符串读取</a></li></ul></li><li><a href="#4哈希" rel="noopener nofollow">4、哈希</a><ul><li><a href="#1-写入" rel="noopener nofollow">1. 写入</a><ul><li><a href="#1-单字段写入" rel="noopener nofollow">1) 单字段写入</a></li><li><a href="#2-多字段写入" rel="noopener nofollow">2) 多字段写入</a></li></ul></li><li><a href="#2-读取" rel="noopener nofollow">2. 读取</a><ul><li><a href="#1-单字段读取" rel="noopener nofollow">1) 单字段读取</a></li><li><a href="#2-多字段读取" rel="noopener nofollow">2) 多字段读取</a></li></ul></li><li><a href="#3-删除字段" rel="noopener nofollow">3. 删除字段</a></li><li><a href="#4-检查字段是否存在" rel="noopener nofollow">4. 检查字段是否存在</a></li></ul></li><li><a href="#5列表" rel="noopener nofollow">5、列表</a><ul><li><a href="#1-数据写入" rel="noopener nofollow">1. 数据写入</a><ul><li><a href="#1-rpush-从列表右边写入" rel="noopener nofollow">1) RPush-从列表右边写入</a></li><li><a href="#2-linsert-在指定元素位置前后插入" rel="noopener nofollow">2) LInsert-在指定元素位置前后插入</a></li><li><a href="#3-linsterbeforelinsterafter-在指定元素位置前后插入" rel="noopener nofollow">3) LInsterBefore/LInsterAfter-在指定元素位置前/后插入</a></li></ul></li><li><a href="#2-数据查看" rel="noopener nofollow">2. 数据查看</a><ul><li><a href="#1-lrange-指定范围查看数据" rel="noopener nofollow">1) LRange-指定范围查看数据</a></li><li><a href="#2-lindex-指定索引查看数据" rel="noopener nofollow">2) LIndex-指定索引查看数据</a></li><li><a href="#3-llen-查看列表长度" rel="noopener nofollow">3) LLen-查看列表长度</a></li></ul></li><li><a href="#3-数据删除与修改" rel="noopener nofollow">3. 数据删除与修改</a><ul><li><a href="#1-lpop-弹出最左边的元素" rel="noopener nofollow">1) LPop-弹出最左边的元素</a></li><li><a href="#2-lpopcount-从左边弹出指定数量的元素" rel="noopener nofollow">2) LPopCount-从左边弹出指定数量的元素</a></li><li><a href="#3-lrem-遍历删除指定个数的指定元素" rel="noopener nofollow">3) LRem-遍历删除指定个数的指定元素</a></li><li><a href="#4-ltrim-按照索引范围修剪列表" rel="noopener nofollow">4) LTrim-按照索引范围修剪列表</a></li><li><a href="#5-lset-指定位置修改元素" rel="noopener nofollow">5) LSet-指定位置修改元素</a></li></ul></li></ul></li><li><a href="#6集合" rel="noopener nofollow">6、集合</a><ul><li><a href="#1-写入数据" rel="noopener nofollow">1. 写入数据</a></li><li><a href="#2-读取数据" rel="noopener nofollow">2. 读取数据</a><ul><li><a href="#1-smembers-获取集合全部元素" rel="noopener nofollow">1) SMembers-获取集合全部元素</a></li><li><a href="#2-scard-获取集合元素总数" rel="noopener nofollow">2) SCard-获取集合元素总数</a></li><li><a href="#3-srandmember-随机取出集合中元素" rel="noopener nofollow">3) SRandMember-随机取出集合中元素</a></li><li><a href="#4-srandmembern-随机取出集合中-n-个元素" rel="noopener nofollow">4) SRandMemberN-随机取出集合中 N 个元素</a></li></ul></li><li><a href="#3-删除元素" rel="noopener nofollow">3. 删除元素</a><ul><li><a href="#1-srem-移除指定元素" rel="noopener nofollow">1) SRem-移除指定元素</a></li><li><a href="#2-spop-移除随机元素" rel="noopener nofollow">2) SPop-移除随机元素</a></li></ul></li><li><a href="#4-集合间操作" rel="noopener nofollow">4. 集合间操作</a><ul><li><a href="#1-sdiff-集合差集" rel="noopener nofollow">1) SDiff-集合差集</a></li><li><a href="#2-sinter-集合交集" rel="noopener nofollow">2) SInter-集合交集</a></li><li><a href="#3-sunion-集合并集" rel="noopener nofollow">3) SUnion-集合并集</a></li></ul></li></ul></li><li><a href="#7有序集合" rel="noopener nofollow">7、有序集合</a><ul><li><a href="#1-数据写入-1" rel="noopener nofollow">1. 数据写入</a></li><li><a href="#2-数据查询" rel="noopener nofollow">2. 数据查询</a><ul><li><a href="#1-zrangewithscores-返回指定排序范围的分值和元素" rel="noopener nofollow">1) ZRangeWithScores-返回指定排序范围的分值和元素</a></li><li><a href="#2-zrange-返回指定排序范围的元素" rel="noopener nofollow">2) ZRange-返回指定排序范围的元素</a></li><li><a href="#3-zrangebyscore-返回指定-score-分值范围排序的元素" rel="noopener nofollow">3) ZRangeByScore-返回指定 score 分值范围排序的元素</a></li><li><a href="#4-zscore-返回指定元素的-score" rel="noopener nofollow">4) ZScore-返回指定元素的 score</a></li><li><a href="#5-zrank-返回指定元素的排序数" rel="noopener nofollow">5) ZRank-返回指定元素的排序数</a></li><li><a href="#6-zcard-返回指定-key-的元素总数" rel="noopener nofollow">6) ZCard-返回指定 key 的元素总数</a></li><li><a href="#7-zcount-返回-key-指定-score-范围的元素总数" rel="noopener nofollow">7) ZCount-返回 key 指定 score 范围的元素总数</a></li></ul></li><li><a href="#3-删除操作" rel="noopener nofollow">3. 删除操作</a><ul><li><a href="#1-zrem-指定元素删除" rel="noopener nofollow">1) ZRem-指定元素删除</a></li><li><a href="#2-zremrangebyscore-删除指定-score-范围内的元素" rel="noopener nofollow">2) ZRemRangeByScore-删除指定 score 范围内的元素</a></li><li><a href="#3-zremrangebyrank-删除指定排序范围内的元素" rel="noopener nofollow">3) ZRemRangeByRank-删除指定排序范围内的元素</a></li><li><a href="#4-zpopmin-按照-score-从有序集合中弹出指定个数的元素" rel="noopener nofollow">4) ZPopMin-按照 score 从有序集合中弹出指定个数的元素</a></li></ul></li></ul></li><li><a href="#8-通用命令" rel="noopener nofollow">8、 通用命令</a><ul><li><a href="#1-exists-判断-key-是否存在" rel="noopener nofollow">1. Exists-判断 key 是否存在</a></li><li><a href="#2-expire-设置过期时间" rel="noopener nofollow">2. Expire-设置过期时间</a></li><li><a href="#3-del-删除-key" rel="noopener nofollow">3. Del-删除 key</a></li><li><a href="#4-ttl-查看过期时间" rel="noopener nofollow">4. TTL-查看过期时间</a></li></ul></li></ul></div><p></p>
<ol>
<li>安装模块</li>
<li>连接 Redis</li>
<li>字符串</li>
<li>哈希</li>
<li>列表</li>
<li>集合</li>
<li>有序集合</li>
<li>通用命令</li>
</ol>
<h3 id="1安装模块">1、安装模块</h3>
<p>首先需要安装一下用到的第三方库：</p>
<pre><code class="language-go">go get github.com/go-redis/redis/v8
</code></pre>
<h3 id="2连接-redis">2、连接 Redis</h3>
<p>接下来连接 Redis 并测试连接情况，如下是代码：</p>
<pre><code class="language-go">package main

import (
    "context"
    "fmt"

    "github.com/go-redis/redis/v8"
)

var ctx = context.Background()
    
func GetRedisClient() *redis.Client {
    redisClient := redis.NewClient(&amp;redis.Options{
        Addr:     "localhost:6379",
        Password: "",
        DB:       0,
    })


    pong, err := redisClient.Ping(ctx).Result()
    if err != nil {
        fmt.Println("连接失败: ", err)
        return nil
    }
    fmt.Println("连接成功: ", pong)
    return redisClient
}
</code></pre>
<h3 id="3字符串">3、字符串</h3>
<h4 id="1-字符串写入">1. 字符串写入</h4>
<p>字符串写入 Redis 的操作如下：</p>
<pre><code class="language-go">redisClient.Set(ctx, key, value, expire)
</code></pre>
<p><code>ctx</code> 是 context 上下文，<code>key</code> 和 <code>value</code> 是需要设置的键和值，<code>expire</code> 是一个 <code>time.Duration</code> 类型，表示过期时间，如果设为小于等于 0 则表示永不过期。</p>
<p>下面是字符串写入 Redis 的使用示例：</p>
<pre><code class="language-go">func SetString(redisClient *redis.Client, ctx context.Context, key, value string, expire time.Duration) error {
    err := redisClient.Set(ctx, key, value, expire).Err()
    if err != nil {
        fmt.Println("设置失败: ", err)
        return err
    }
    fmt.Println("设置成功")
    return nil
}

func main(){
    redisClient := GetRedisClient()
    defer redisClient.Close()
    ctx := context.Background()
    key := "test_key"
    value := "test_value"
    err := SetString(redisClient, ctx, key, value, 10*time.Second)
    if err != nil {
        fmt.Printf("key:%s set value:%s, error:%v\n", key, value, err)
    }
}
</code></pre>
<h4 id="2-字符串读取">2. 字符串读取</h4>
<p>从 Redis 中读取字符串的操作如下：</p>
<pre><code class="language-go">val, err := redisClient.Get(ctx, key).Result()
</code></pre>
<p>其中，<code>val</code> 为返回的值，<code>err</code> 表示读取过程中是否有错误。</p>
<p>这里需要注意下，如果对应的 key 没有值，也会返回 <code>error</code>，其结果是 <code>redis.Nil</code>，可以做一下单独的判断处理。</p>
<p>下面是一个使用示例：</p>
<pre><code class="language-go">func main(){
    redisClient := GetRedisClient()
    ctx := context.Background()
    key := "test_key"

    val, err := redisClient.Get(ctx, key).Result()
    if err != nil {
        if err == redis.Nil {
            fmt.Printf("key:%s, has no value\n", key)
        } else {
            fmt.Printf("get key:%s, error: %v\n", key, err)
        }
    }
    fmt.Printf("key:%s, value:%s\n", key, val)
}
</code></pre>
<h3 id="4哈希">4、哈希</h3>
<h4 id="1-写入">1. 写入</h4>
<h5 id="1-单字段写入">1) 单字段写入</h5>
<p>哈希类型的数据单个字段写入的操作如下：</p>
<pre><code class="language-go">val, err := redisClient.HSet(ctx, key, field, value).Result()
</code></pre>
<p>这里返回的 <code>val</code> 类型是 <code>int64</code>，值表示设置成功写入的数量，<code>HSet()</code> 方法这里介绍的是单字段写入，后面再介绍多字段写入。</p>
<p>使用代码示例如下：</p>
<pre><code class="language-go">func HSetField(redisClient *redis.Client, ctx context.Context, key, field, value string) {
    val, err := redisClient.HSet(ctx, key, field, value).Result()
    if err != nil {
        fmt.Println("哈希单个字段设置错误: ", err)
    } else {
        if val == 1 {
            fmt.Println("哈希单个字段设置成功：", val)
        } else {
            fmt.Println("哈希单个字段更新成功：", val)
        }
    }
}

func main() {
    redisClient := GetRedisClient()
    defer redisClient.Close()

    ctx := context.Background()
    key := "test_hash_key"

    HSetField(redisClient, ctx, key, "field1", "value1")
}
</code></pre>
<h5 id="2-多字段写入">2) 多字段写入</h5>
<p>多字段写入可以使用 <code>HMSet()</code> 操作，但 <code>HSet()</code> 也支持多字段写入。</p>
<p><code>HMSet()</code> 操作是一个已弃用的版本，为了兼容 Redis 3 版本。</p>
<p>而 <code>HSet()</code> 操作只有 Redis 4 及以上才支持多字段的写入。</p>
<p>使用 <code>HMSet()</code> 的代码的几种操作如下：</p>
<pre><code class="language-go">// 操作 1
val, err := redisClient.HMSet(ctx, key, "field1", "value1", "field2", "value2").Result()

// 操作2
field_value_slice := []string{"field1", "value1", "field2", "value2"}
val, err := redisClient.HMSet(ctx, key, field_value_slice).Result()

// 操作3
m := map[string]interface{}{"field1": "value1", "field2": "value2"}
val, err := redisClient.HMSet(ctx, key, m).Result()
</code></pre>
<p>这里支持输入的操作包括直接使用多个字符串，切片和 map，返回的结果 val 是 bool 类型，表示是否设置成功。</p>
<p>而 <code>HSet()</code> 支持的参数与 <code>HMSet()</code> 完全相同，但是返回的 val 是一个 <code>int64</code>，表示成功写入的字段数量。</p>
<p>以下是 <code>HSet()</code> 的操作示例：</p>
<pre><code class="language-go">// 操作 1
val, err := redisClient.HSet(ctx, key, "field1", "value1", "field2", "value2").Result()

// 操作2
field_value_slice := []string{"field1", "value1", "field2", "value2"}
val, err := redisClient.HSet(ctx, key, field_value_slice).Result()

// 操作3
m := map[string]interface{}{"field1": "value1", "field2": "value2"}
val, err := redisClient.HSet(ctx, key, m).Result()
</code></pre>
<p>这里返回的 val 是 int64 类型，表示成功写入数据的数量，如果更新字段，字段数量不会计入。</p>
<h4 id="2-读取">2. 读取</h4>
<h5 id="1-单字段读取">1) 单字段读取</h5>
<p>哈希数据单个字段的读取用 <code>HGet()</code> 操作：</p>
<pre><code class="language-go">val, err := redisClient.HGet(ctx, key, field).Result()
</code></pre>
<p>获取的 val 就是对应字段的值。</p>
<p>这里有两种特殊情况，一种是 key 不存在，一种是 field 不存在。</p>
<p>key 或者 field 不存在和之前的字符串读取的 err 的值一样，是 <code>redis.Nil</code>。</p>
<p>代码操作示例如下：</p>
<pre><code class="language-go">func HGetField(redisClient *redis.Client, ctx context.Context, key, field string) {
    val, err := redisClient.HGet(ctx, key, field).Result()
    if err != nil {
        if err == redis.Nil {
            fmt.Println("key 或者 field 不存在")
        } else {
            fmt.Println("哈希单个字段获取错误: ", err)
        }
    } else {
        fmt.Println("哈希单个字段获取成功：", val)
    }
    fmt.Printf("%T, %v\n", val, val)
}

func main() {
    redisClient := GetRedisClient()
    defer redisClient.Close()

    ctx := context.Background()
    key := "test_hash_key"

    HGetField(redisClient, ctx, key, "field1")
}
</code></pre>
<h5 id="2-多字段读取">2) 多字段读取</h5>
<p><strong>获取多个字段值</strong></p>
<p>指定多个字段读取哈希数据用 <code>HMGet()</code> 操作，需要读取的多个 field 可以直接作为参数加在后面，也可以使用切片传入：</p>
<pre><code class="language-go">val, err := redisClient.HMGet(ctx, key, "field1", "field2", "field3", "field4").Result()

fields := []string{"field1", "field2", "field3", "field14"}
val, err := redisClient.HMGet(ctx, key, fields...).Result()
</code></pre>
<p>其返回的 val 是一个 <code>[]interface</code> 结构，其中每个元素都是对应的 field 的 value，比如上面的操作结果如下：</p>
<pre><code class="language-go">[value11 value12 value2 &lt;nil&gt;]
</code></pre>
<p>对应的 field 没有 value 的话，其值就是 <code>nil</code>。</p>
<p>在获取对应的 value 进行处理的时候需要转一下：</p>
<pre><code class="language-go">val[0].(string)
</code></pre>
<p><strong>获取全部字段和值</strong></p>
<p>如果想获取 key 下全部的 field 和对应的 value，可以使用 <code>HGetAll()</code>，其操作如下：</p>
<pre><code class="language-go">val := redisClient.HGetAll(ctx, key).Val()
</code></pre>
<p>返回的 val 类型是 <code>map[string]string</code>：</p>
<pre><code class="language-go">fmt.Println(val)
// map[field1:value11 field2:value12 field3:value2]
</code></pre>
<p><strong>获取全部字段</strong></p>
<p>获取哈希数据下全部的 field 的操作如下：</p>
<pre><code class="language-go">fieldSlice := redisClient.HKeys(ctx, key).Val()
</code></pre>
<p>返回的数据是一个字符串切片 <code>[]string</code>，如果对应的 key 没有数据，返回的结果是空的字符串切片。</p>
<p><strong>获取全部值</strong></p>
<p>获取哈希数据下全部 field 对应的 value 的操作如下：</p>
<pre><code class="language-go">valueSlice := redisClient.HVals(ctx, key).Val()
</code></pre>
<p>返回的数据是一个字符串切片 <code>[]string</code>，如果 key 下没有数据，返回的结果是空的字符串切片。</p>
<p><strong>获取字段长度</strong></p>
<p>获取哈希数据下有多少个 field 的操作如下：</p>
<pre><code class="language-go">fieldLength := redisClient.HLen(ctx, key).Val()
</code></pre>
<p>返回的结果是一个 int64 类型。</p>
<h4 id="3-删除字段">3. 删除字段</h4>
<p>如果要删除哈希数据下某一个或多个 field，可以使用 <code>HDel()</code> 方法。</p>
<pre><code class="language-go">// 删除一个 field
val := redisClient.HDel(ctx, key, "field1").Val()

// 删除多个 field
val := redisClient.HDel(ctx, key, "field1", "field2", "field3").Val()

// 删除多个 field
fieldSlice := []string{"field1", "field2"}
val := redisClient.HDel(ctx, key, fieldSlice...).Val()
</code></pre>
<p>返回的 val 是 int64 类型，表示删除了多少个 field。</p>
<h4 id="4-检查字段是否存在">4. 检查字段是否存在</h4>
<p><code>HExists()</code> 方法可以用于检测某个字段是否存在。</p>
<pre><code class="language-go">val := redisClient.HExists(ctx, key, "field1").Val()
</code></pre>
<p>返回的结果是一个 bool 型，表示是否存在。</p>
<h3 id="5列表">5、列表</h3>
<h4 id="1-数据写入">1. 数据写入</h4>
<h5 id="1-rpush-从列表右边写入">1) RPush-从列表右边写入</h5>
<p><code>RPush()</code> 方法支持从列表右边写入一个或多个数据，使用示例如下：</p>
<pre><code class="language-go">// 右边推入一条数据
res := redisClient.RPush(ctx, key, "a").Val()

// 右边推入多条数据
res := redisClient.RPush(ctx, key, "a", "b", "c").Val()

// slice 形式推入多条数据
stringSlice := []string{"a", "b", "c"}
res := redisClient.RPush(ctx, key, stringSlice).Val()
</code></pre>
<p>返回的结果是一个 int64 类型，表示数据推入列表后，列表当前一共有多少个元素。</p>
<p>如果是从左边推入，则使用对应的 <code>LPush()</code> 方法。</p>
<p><strong>注意</strong>： 这里需要注意一下从左边推入和右边推入的元素顺序，比如通用的是 <code>["a", "b", "c"]</code>，从右边推入的结果是 <code>["a", "b", "c"]</code>，但是从左边推入的结果是 <code>["c", "b", "a"]</code></p>
<p>还有个 <code>LPushX</code> 和 <code>RPushX</code> 方法，表示仅当有 key 这个列表的时候可以写入数据，如果 key 不存在，则不会写入数据。</p>
<h5 id="2-linsert-在指定元素位置前后插入">2) LInsert-在指定元素位置前后插入</h5>
<p><code>LInsert()</code> 方法支持在指定元素的前后插入一条数据，比如原始的列表数据是 <code>["a", "b", "c"]</code>，想要元素 <code>b</code> 前面插入一个元素，其操作如下：</p>
<pre><code class="language-go">res := redisClient.LInsert(ctx, key, "before", "b", "before_b").Val()
</code></pre>
<p>插入成功后列表的元素就会变成 <code>["a", "before_b", "b", "c"]</code>。</p>
<p><code>LInsert()</code> 方法的第三个参数是可选的，可选值有 <code>before</code> 和 <code>after</code> 分别表示在指定元素的前面还是后面插入。</p>
<p>第四个参数是指定的元素，第五个参数是需要插入的元素。</p>
<p>方法的返回值是个 int64，表示插入成功后当前列表的元素总数。</p>
<p>而如果第四个参数指定的元素不存在，那么将找不到插入的位置，则会插入失败，返回的 res 的值就会是 -1，可以通过这个返回值监控是否插入成功。</p>
<h5 id="3-linsterbeforelinsterafter-在指定元素位置前后插入">3) LInsterBefore/LInsterAfter-在指定元素位置前/后插入</h5>
<p><code>LInsterBefore()</code> 和 <code>LInsterAfter()</code> 则是 <code>LInsert()</code> 方法的指定版本，直接在方法层面确认了在指定元素前还是后插入元素。</p>
<p>比如在元素 c 前插入元素：</p>
<pre><code class="language-go">res := redisClient.LInsertBefore(ctx, key, "c", "before_c").Val()
</code></pre>
<p>返回的 res 是 int64，表示插入后当前列表的元素总和。</p>
<p>而如果指定的元素不存在，则会返回 -1。</p>
<h4 id="2-数据查看">2. 数据查看</h4>
<h5 id="1-lrange-指定范围查看数据">1) LRange-指定范围查看数据</h5>
<p>可以通过 <code>LRange()</code> 方法指定索引的范围来查看列表数据：</p>
<pre><code class="language-go">valueSlice, err := redisClient.LRange(ctx, key, 0, 1).Result()
</code></pre>
<p>输入的参数后两个为开始和结束索引，上面这个示例表示获取从 0 到 1 的闭区间列表数据。</p>
<p>返回两个值，<code>valueSlice</code> 是一个字符串切片，err 表示返回的错误</p>
<p>下面是使用示例：</p>
<pre><code class="language-go">valueSlice, err := redisClient.LRange(ctx, key, 0, 1).Result()
if err != nil {
    fmt.Println("error: ", err)
} else {
    fmt.Printf("%T, %v\n", valueSlice, valueSlice)
}
</code></pre>
<p>与之前的获取逻辑不太一样的地方是，如果 key 对应的列表数据不存在，err 值还是为 nil，只是返回的 <code>valueSlice</code> 是一个长度为 0 的字符串切片。</p>
<p>如果结束位置的索引大于列表的长度，也不会报错，而是会返回全部的列表数据。</p>
<p>而如果我们直接想获取全部的列表数据，可以把结束位置的索引值变成 -1：</p>
<pre><code class="language-go">valueSlice, err := redisClient.LRange(ctx, key, 0, -1).Result()
</code></pre>
<h5 id="2-lindex-指定索引查看数据">2) LIndex-指定索引查看数据</h5>
<p>使用示例如下：</p>
<pre><code class="language-go">value, err := redisClient.LIndex(ctx, key, 1).Result()
</code></pre>
<p>返回的结果 value 为指定位置的元素。</p>
<p>LIndex() 方法支持负数索引，比如想获取倒数第二个元素可以如下操作：</p>
<pre><code class="language-go">value, err := redisClient.LIndex(ctx, key, -1).Result()
</code></pre>
<p>而如果指定的索引位置超出了列表的长度，则 err 信息会是 <code>redis.Nil</code>，下面是操作示例：</p>
<pre><code class="language-go">value, err := redisClient.LIndex(ctx, key, 8).Result()
if err != nil {
    if err == redis.Nil {
        fmt.Println("索引位置的结果不存在")
    } else {
        fmt.Println("error: ", err)
    }
} else {
    fmt.Printf("%T, %v\n", value, value)
}
</code></pre>
<h5 id="3-llen-查看列表长度">3) LLen-查看列表长度</h5>
<p>使用示例如下：</p>
<pre><code class="language-go">value := redisClient.LLen(ctx, key).Val()
</code></pre>
<p>返回的结果是一个 int64，表示列表长度，而过 key 不存在，则会返回 0。</p>
<h4 id="3-数据删除与修改">3. 数据删除与修改</h4>
<h5 id="1-lpop-弹出最左边的元素">1) LPop-弹出最左边的元素</h5>
<p><code>LPop()</code> 方法的作用是弹出最左边的元素，操作示例如下：</p>
<pre><code class="language-go">val, err := redisClient.LPop(ctx, key).Result()
</code></pre>
<p>其中 val 是弹出的元素，是 string 类型。</p>
<p>如果列表已经为空，err 的值就是 <code>redis.Nil</code>。</p>
<p>同理，如果是想弹出最右边的元素，可以使用 <code>RPop()</code> 方法。</p>
<h5 id="2-lpopcount-从左边弹出指定数量的元素">2) LPopCount-从左边弹出指定数量的元素</h5>
<p>使用示例如下：</p>
<pre><code class="language-go">val, err := redisClient.LPopCount(ctx, key, 5).Result()
</code></pre>
<p>返回的 val 是一个 <code>[]string</code>，如果指定的 count，也就是第三个参数大于列表中的元素个数，则会将元素全部弹出。</p>
<p>如果列表中已经没有元素可以弹出了，err 的值是 <code>redis.Nil</code>。</p>
<h5 id="3-lrem-遍历删除指定个数的指定元素">3) LRem-遍历删除指定个数的指定元素</h5>
<p>其操作方法如下：</p>
<pre><code class="language-go">val, err := redisClient.LRem(ctx, key, 2, "c").Result()
</code></pre>
<p>上面的操作表示从列表左边开始删除 key 对应的列表中两个元素为 <code>c</code> 的元素，返回的 val 表示实际删除的个数。</p>
<p>如果我们想删除全部指定元素，可以将第三个参数设置为 0：</p>
<pre><code class="language-go">val, err := redisClient.LRem(ctx, key, 0, "c").Result()
</code></pre>
<p>上面的操作表示删除列表中全部元素为 <code>c</code> 的数据。</p>
<h5 id="4-ltrim-按照索引范围修剪列表">4) LTrim-按照索引范围修剪列表</h5>
<p>操作代码如下：</p>
<pre><code class="language-go">val, err := redisClient.LTrim(ctx, key, 0, 2).Result()
</code></pre>
<p>上面的操作表示只保留列表中 0 到 2 的索引的三个元素，返回的 val 是 string 类型，内容为 <code>OK</code> 表示修剪成功。</p>
<h5 id="5-lset-指定位置修改元素">5) LSet-指定位置修改元素</h5>
<p><code>LSet()</code> 方法表示修改指定位置的元素内容，比如需要修改索引为 1 的元素内容：</p>
<pre><code class="language-go">val, err := redisClient.LSet(ctx, key, 1, "index_1_change").Result()
</code></pre>
<p>返回的 val 是个字符串，内容 <code>OK</code> 表示修改成功，如果指定的索引超出了原有列表的范围，则会返回 err。</p>
<h3 id="6集合">6、集合</h3>
<h4 id="1-写入数据">1. 写入数据</h4>
<p>往一个集合中写入的方法是 <code>SAdd()</code>，可以往里面写入单个或者多个元素：</p>
<pre><code class="language-go">// 写入单个元素
val := redisClient.SAdd(ctx, key, "a").Val()

// 写入多个元素
stringSlice := []string{"d", "e"}
val := redisClient.SAdd(ctx, key, stringSlice).Val()
</code></pre>
<p>返回的结果 val 是 int64，表示写入的元素个数，如果元素之前已经在集合，则不会计入其中。</p>
<h4 id="2-读取数据">2. 读取数据</h4>
<h5 id="1-smembers-获取集合全部元素">1) SMembers-获取集合全部元素</h5>
<p>使用代码如下：</p>
<pre><code class="language-go">res, err := redisClient.SMembers(ctx, key).Result()
</code></pre>
<p>返回的 res 是一个 <code>[]string</code>，内容为集合的全部元素。</p>
<p>如果 key 对应的集合不存在，返回的 res 为空切片。</p>
<h5 id="2-scard-获取集合元素总数">2) SCard-获取集合元素总数</h5>
<p>使用代码如下：</p>
<pre><code class="language-go">res, err := redisClient.SCard(ctx, key).Result()
</code></pre>
<p>返回的 res 类型是 <code>int64</code>，内容是 key 对应的集合的元素总数。</p>
<p>如果 key 对应的集合不存在，返回的 res 结果是 0。</p>
<h5 id="3-srandmember-随机取出集合中元素">3) SRandMember-随机取出集合中元素</h5>
<p>使用代码如下：</p>
<pre><code class="language-go">res, err := redisClient.SRandMember(ctx, key).Result()
if err == redis.Nil {
    fmt.Printf("key:%s 对应的集合不存在\n", key)
}
</code></pre>
<p>返回的 res 是集合中随机一个元素。</p>
<p>如果 key 对应的集合不存在，返回 err 的值是 <code>redis.Nil</code>。</p>
<h5 id="4-srandmembern-随机取出集合中-n-个元素">4) SRandMemberN-随机取出集合中 N 个元素</h5>
<p>使用代码如下：</p>
<pre><code class="language-go">res, err := redisClient.SRandMemberN(ctx, key, 3).Result()
</code></pre>
<p>上面的代码表示从集合中随机取出 3 个元素，返回的 res 是 <code>[]string</code>。</p>
<p>如果 key 对应的集合不存在，返回的是一个空切片，err 为 <code>nil</code>。</p>
<p>如果指定返回的元素个数大于集合总个数，则会返回全部集合元素。</p>
<h4 id="3-删除元素">3. 删除元素</h4>
<h5 id="1-srem-移除指定元素">1) SRem-移除指定元素</h5>
<p><code>SRem()</code> 方法可以用于移除指定的一个多个元素，使用示例如下：</p>
<pre><code class="language-go">// 删除一个指定元素
res, err := redisClient.SRem(ctx, key, "a").Result()

// 删除多个指定元素
res, err := redisClient.SRem(ctx, key, "a", "b").Result()

stringSlice := []string{"a", "b"}
res, err := redisClient.SRem(ctx, key, stringSlice).Result()
</code></pre>
<p>返回的结果 res 是一个 int64，表示移除的元素个数。</p>
<h5 id="2-spop-移除随机元素">2) SPop-移除随机元素</h5>
<p><code>SPop()</code> 方法用于随机移除集合中的元素。</p>
<pre><code class="language-go">res, err := redisClient.SPop(ctx, key).Result()
</code></pre>
<p>res 是返回的移除的元素。</p>
<p>而 <code>SPopN()</code> 用于移除 N 个随机元素：</p>
<pre><code class="language-go">res, err := redisClient.SPopN(ctx, key, 2).Result()
</code></pre>
<p>返回的 res 是一个 <code>[]string</code>。</p>
<h4 id="4-集合间操作">4. 集合间操作</h4>
<h5 id="1-sdiff-集合差集">1) SDiff-集合差集</h5>
<p><code>SDiff()</code> 方法用于求取集合之间的差集，使用示例如下：</p>
<pre><code class="language-go">redisClient.SAdd(ctx, "s1", "a", "b", "c")
redisClient.SAdd(ctx, "s2", "a")

res, err := redisClient.SDiff(ctx, "s1", "s2").Result()
</code></pre>
<p>返回的 res 是一个 <code>[]string</code>，是集合之间的差集。</p>
<p><code>SDiffStore()</code> 可以将集合间的差集存储到一个新的 key 中，使用方法如下：</p>
<pre><code class="language-go">redisClient.SDiffStore(ctx, "s3", "s1", "s2")
</code></pre>
<p>上面的操作表示将 s1 和 s2 之间的差集存储到 s3 中。</p>
<h5 id="2-sinter-集合交集">2) SInter-集合交集</h5>
<p><code>SInter()</code> 方法用于求取集合之间的交集，使用示例如下：</p>
<pre><code class="language-go">redisClient.SAdd(ctx, "s1", "a", "b", "c")
redisClient.SAdd(ctx, "s2", "a")

res, err := redisClient.SInter(ctx, "s1", "s2").Result()
</code></pre>
<p>返回的 res 是一个 <code>[]string</code>，是集合之间的交集。</p>
<p><code>SInterStore()</code> 可以将集合间的交集存储到一个新的 key 中，使用方法如下：</p>
<pre><code class="language-go">redisClient.SInterStore(ctx, "s3", "s1", "s2")
</code></pre>
<p>上面的操作表示将 s1 和 s2 之间的交集存储到 s3 中。</p>
<h5 id="3-sunion-集合并集">3) SUnion-集合并集</h5>
<p><code>SUnion()</code> 方法用于求取集合之间的并集，使用示例如下：</p>
<pre><code class="language-go">redisClient.SAdd(ctx, "s1", "a", "b", "c")
redisClient.SAdd(ctx, "s2", "a", "e")

res, err := redisClient.SUnion(ctx, "s1", "s2").Result()
</code></pre>
<p>返回的 res 是一个 <code>[]string</code>，是集合之间的并集。</p>
<p><code>SUnionStore()</code> 可以将集合间的并集存储到一个新的 key 中，使用方法如下：</p>
<pre><code class="language-go">redisClient.SUnionStore(ctx, "s3", "s1", "s2")
</code></pre>
<p>上面的操作表示将 s1 和 s2 之间的并集存储到 s3 中。</p>
<h3 id="7有序集合">7、有序集合</h3>
<h4 id="1-数据写入-1">1. 数据写入</h4>
<p>有序集合数据的写入可以使用 <code>ZAdd()</code>，使用的示例如下：</p>
<pre><code class="language-go">res, err := redisClient.ZAdd(ctx, key, &amp;redis.Z{Score: 100, Member: "Golang"}).Result()
</code></pre>
<p>输入的第三个参数是 <code>redis.Z</code> 类型，其结构如下：</p>
<pre><code class="language-go">type Z struct {
    Score  float64
    Member interface{}
}
</code></pre>
<p><code>Score</code> 是元素用于排序的分数，<code>Member</code> 是有序集合的元素。</p>
<p>除了单个元素，还可以写入多个元素：</p>
<pre><code class="language-go">zList := []*redis.Z{
    {Score: 101, Member: "Golang"},
    {Score: 221, Member: "Python"},
    {Score: 445, Member: "Java"},
}
res, err := redisClient.ZAdd(ctx, key, zList...)
</code></pre>
<p>返回的 res 类型是 int64，表示插入数据的个数。</p>
<h4 id="2-数据查询">2. 数据查询</h4>
<h5 id="1-zrangewithscores-返回指定排序范围的分值和元素">1) ZRangeWithScores-返回指定排序范围的分值和元素</h5>
<p><code>ZRangeWithScores()</code> 方法用于返回指定排序范围的分值和元素，比如需要返回前三位的数据，使用示例如下：</p>
<pre><code class="language-go">res1, err := redisClient.ZRangeWithScores(ctx, key, 0, 2).Result()
for _, item := range res1 {
    fmt.Printf("score:%f, member:%s\n", item.Score, item.Member)
}
</code></pre>
<p>其返回的 res1 类型是 <code>[]Z</code>，数据按照 score 从小到大排列。</p>
<p>如果想要获取有序集合中全部元素，可以将指定的范围写成 0 和 -1：</p>
<pre><code class="language-go">res1, err := redisClient.ZRangeWithScores(ctx, key, 0, -1).Result()
</code></pre>
<p>通过，有一个逆序方法 <code>ZRevRangeWithScores()</code>，比如获取从最后往前三位的数据：</p>
<pre><code class="language-go">res1, err := redisClient.ZRangeWithScores(ctx, key, 0, 2).Result()
</code></pre>
<h5 id="2-zrange-返回指定排序范围的元素">2) ZRange-返回指定排序范围的元素</h5>
<p><code>ZRange()</code> 方法用于返回指定排序范围的元素，，比如需要返回前三位的数据，使用示例如下：</p>
<pre><code class="language-go">res1, err := redisClient.ZRange(ctx, key, 0, 2).Result()
</code></pre>
<p>返回的 res1 类型是 <code>[]string</code>，元素是有序集合的元素，按照 score 从小到大排列。</p>
<p>如果想要获取有序集合中全部元素，可以将指定的范围写成 0 和 -1。</p>
<p>同理，有一个逆序的获取方法 <code>ZRevRange()</code>，比如获取从最后往前三位的数据，操作如下：</p>
<pre><code class="language-go">res1, err := redisClient.ZRevRange(ctx, key, 0, 2).Result()
</code></pre>
<h5 id="3-zrangebyscore-返回指定-score-分值范围排序的元素">3) ZRangeByScore-返回指定 score 分值范围排序的元素</h5>
<p><code>ZRangeByScore</code> 传入的参数是 <code>redis.ZRangeBy</code>，其数据结构如下：</p>
<pre><code class="language-go">type ZRangeBy struct {
    Min, Max      string
    Offset, Count int64
}
</code></pre>
<p><code>Min</code> 和 <code>Max</code> 表示 score 分值的范围，如果想获取这个范围内的全部元素，<code>Offset</code> 和 <code>Count</code> 参数置为 0 即可。</p>
<p>如果想要获取类似分页的操作，可以对 <code>Offset</code> 和 <code>Count</code> 进行赋值，<code>Count</code> 表示需要获取的总数，<code>Offset</code> 表示从 <code>Min</code> 开始的偏移量。</p>
<p>使用示例如下：</p>
<pre><code class="language-go">zRangeBy := &amp;redis.ZRangeBy{
    Min: "1",
    Max: "500",
}
res1, err := redisClient.ZRangeByScore(ctx, key, zRangeBy).Result()
</code></pre>
<p>上面的示例表示获取 key 对应的有序集合 score 从 1 到 500 之间的全部元素，返回的 res1 类型是 <code>[]string</code>。</p>
<p>其对应的逆序获取方法为 <code>ZRevRangeByScore()</code>，操作示例如下：</p>
<pre><code class="language-go">res1, err := redisClient.ZRevRangeByScore(ctx, key, zRangeBy).Result()
</code></pre>
<h5 id="4-zscore-返回指定元素的-score">4) ZScore-返回指定元素的 score</h5>
<p>使用示例如下：</p>
<pre><code class="language-go">elementName := "Golang"
res1, err := redisClient.ZScore(ctx, key, elementName).Result()
if err != nil {
    if err == redis.Nil {
        fmt.Printf("key:%s 或者元素: %s 不存在\n", key, elementName)
    } else {
        fmt.Println("err: ", err)
    }
} else {
    fmt.Printf("key:%s, 元素:%s 的分值是%f\n", key, elementName, res1)
}
</code></pre>
<p>返回的 res1 类型是 float64，表示指定元素的 score，如果 key 或者指定的元素不存在，err 的值是 <code>redis.Nil</code>。</p>
<p>另一个方法 <code>ZMScore()</code> 可以获取多个指定元素的 score：</p>
<pre><code class="language-go">elementSlice := []string{"Golang", "Python"}
res1, err := redisClient.ZMScore(ctx, key, elementSlice...).Result()
</code></pre>
<p>返回的 res1 是一个 <code>[]float64</code>，返回的是对应的 <code>elementSlice</code> 对应位置元素的 score。</p>
<p>如果元素不存在，则对应的位置会返回 0。</p>
<h5 id="5-zrank-返回指定元素的排序数">5) ZRank-返回指定元素的排序数</h5>
<p>使用代码示例如下：</p>
<pre><code class="language-go">elementName := "Golang"
res1, err := redisClient.ZRank(ctx, key, elementName).Result()
if err != nil {
    if err == redis.Nil {
        fmt.Printf("key:%s 或者元素: %s 不存在\n", key, elementName)
    } else {
        fmt.Println("err: ", err)
    }
} else {
    fmt.Printf("key:%s, 元素:%s 的排序是%d\n", key, elementName, res1)
}
</code></pre>
<p>返回的 res1 类型是 int64，表示指定元素的排序数，排序数从 0 开始，如果 key 或者指定的元素不存在，err 的值是 <code>redis.Nil</code>。</p>
<p><code>ZRevRank()</code> 方法表示逆序获取，使用方法和 <code>ZRank()</code> 方法一致：</p>
<pre><code class="language-go">res1, err := redisClient.ZRevRank(ctx, key, elementName).Result()
</code></pre>
<h5 id="6-zcard-返回指定-key-的元素总数">6) ZCard-返回指定 key 的元素总数</h5>
<p>使用示例如下：</p>
<pre><code class="language-go">res1, err := redisClient.ZCard(ctx, key).Result()
</code></pre>
<p><code>ZCard()</code> 方法返回指定 key 的元素总数，res1 类型是 <code>int64</code>，表示指定 key 的元素总数。</p>
<p>如果对应的 key 不存在，结果为 0，err 为 <code>nil</code>。</p>
<h5 id="7-zcount-返回-key-指定-score-范围的元素总数">7) ZCount-返回 key 指定 score 范围的元素总数</h5>
<p>使用示例如下：</p>
<pre><code class="language-go">res1, err := redisClient.ZCount(ctx, key, "1", "4").Result()
</code></pre>
<p><code>ZCount()</code> 方法输入的第三、四个参数是 score 分值的最小和最大值，类型是字符串。</p>
<p>返回的 res1 类型是 <code>int64</code>，如果 key 不存在，结果为 0。</p>
<h4 id="3-删除操作">3. 删除操作</h4>
<h5 id="1-zrem-指定元素删除">1) ZRem-指定元素删除</h5>
<p><code>ZRem()</code> 方法用于有序集合指定元素删除操作，可以删除一个或多个元素：</p>
<pre><code class="language-go">res1, err := redisClient.ZRem(ctx, key, []string{"Java", "Golang"}).Result()
</code></pre>
<p>返回的 res1 类型是 <code>int64</code>，表示删除的元素个数。</p>
<h5 id="2-zremrangebyscore-删除指定-score-范围内的元素">2) ZRemRangeByScore-删除指定 score 范围内的元素</h5>
<p><code>ZRemRangeByScore()</code> 方法用于删除指定 score 范围内的元素，第三、四个参数是有序集合的 score 的最小值和最大值，类型是 <code>string</code>，使用示例如下：</p>
<pre><code class="language-go">res1, err := redisClient.ZRemRangeByScore(ctx, key, "0", "23").Result()
</code></pre>
<p>上述示例表示删除指定 key 的 score 在 0 到 23 之间的闭区间的元素，res1 类型是 int64，表示删除的元素个数。</p>
<h5 id="3-zremrangebyrank-删除指定排序范围内的元素">3) ZRemRangeByRank-删除指定排序范围内的元素</h5>
<p><code>ZRemRangeByRank()</code> 方法用于删除指定排序范围内的元素，第三、四个参数是有序集合的排序位的范围，类型是 <code>int64</code>，比如向删除有序集合排在前两位的数据，操作如下：</p>
<pre><code class="language-go">res1, err := redisClient.ZRemRangeByRank(ctx, key, 0, 1).Result()
</code></pre>
<p>返回的 res1 类型是 int64，表示删除的元素个数。</p>
<h5 id="4-zpopmin-按照-score-从有序集合中弹出指定个数的元素">4) ZPopMin-按照 score 从有序集合中弹出指定个数的元素</h5>
<p>如果想按照 score 从小到大排列，弹出某个有序集合中排在前两位的元素，操作如下：</p>
<pre><code class="language-go">res1, err := redisClient.ZPopMin(ctx, key, 2).Result()
for _, item := range res1 {
    fmt.Println(item.Score, item.Member)
}
</code></pre>
<p>返回的 res1 类型是 <code>[]Z</code>。</p>
<p>而如果想按照 score 从大到小排列并弹出指定个数的元素，可以使用 <code>ZPopMax()</code> 方法，使用方式与 <code>ZPopMin()</code> 方法一致。</p>
<h3 id="8-通用命令">8、 通用命令</h3>
<h4 id="1-exists-判断-key-是否存在">1. Exists-判断 key 是否存在</h4>
<p><code>Exists()</code> 方法用于判断指定 key 是否存在，使用示例如下：</p>
<pre><code class="language-go">res, err := redisClient.Exists(ctx, "a").Result()
</code></pre>
<p>返回的 res 类型是 <code>int64</code>，如果指定 key 存在，则 res 为 1，否则为 0。</p>
<h4 id="2-expire-设置过期时间">2. Expire-设置过期时间</h4>
<p><code>Expire()</code> 方法用于给指定 key 设置过期时间，使用示例如下：</p>
<pre><code class="language-go">res1, err := redisClient.Expire(ctx, key, 20*time.Minute).Result()
</code></pre>
<p>返回的 res1 类型是 <code>bool</code>，如果 key 存在且设置过期时间成功，返回的 res1 为 <code>true</code>，否则为 <code>false</code>。</p>
<h4 id="3-del-删除-key">3. Del-删除 key</h4>
<p><code>Del()</code> 方法用于删除一个或多个 key，使用示例如下：</p>
<pre><code class="language-go">// 删除一个 key
res1, err := redisClient.Del(ctx, "d").Result()

// 删除多个 key
res1, err := redisClient.Del(ctx, []string{"a", "b", "c"}...).Result()
</code></pre>
<p>返回的 res1 类型是 <code>int64</code>，表示删除的 key 的个数。</p>
<h4 id="4-ttl-查看过期时间">4. TTL-查看过期时间</h4>
<p><code>TTL()</code> 方法用于查看指定 key 的过期时间，使用示例如下：</p>
<pre><code class="language-go">res1, err := redisClient.TTL(ctx, "a").Result()
if err != nil {
    fmt.Println("error: ", err)
    return
}
if res1 == -1 {
    fmt.Println("指定 key 永不过期")
} else if res1 == -2 {
    fmt.Println("指定 key 不存在")
} else {
    fmt.Println("key 在指定时间后过期: ", res1)
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-06 21:29">2025-08-06 21:28</span>&nbsp;
<a href="https://www.cnblogs.com/hunterxiong">XHunter</a>&nbsp;
阅读(<span id="post_view_count">12</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19025904);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19025904', targetLink: 'https://www.cnblogs.com/hunterxiong/p/19025904', title: 'Golang笔记之Redis' })">举报</a>
</div>
        