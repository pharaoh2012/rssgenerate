
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kongsq/p/18787191" title="发布于 2025-03-22 21:53">
    <span role="heading" aria-level="2">虚拟电商-延迟任务系统的微服务改造（一）改造需求及技术选型</span>
    

</a>

	</div>
	    <div id="cnblogs_post_description" style="display: none">
        
        延迟任务系统的微服务改造，微服务改造需求及技术选型
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>一、微服务改造需求及技术选型</h1>
<p><br>　　延迟任务系统进行微服务的改造，改造需求和技术选型。</p>
<p>　　虽然程序目前做了各种优化，接口的缓存优化，接口的线程优化，但它还是单机版，所以需要改造成微服务（分布式），对于分布式而言，分布式本质是进程之间通信，和服务治理（比如服务的注册与发现，服务的降级，服务的容错）。</p>
<p><img src="https://img2024.cnblogs.com/blog/527658/202503/527658-20250322214905454-465876002.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<p><br>目前主流两种方案：</p>
<p>　　1 基于dubbo协议的 将业务层封装成Dubbo接口供其他服务调用</p>
<p>&nbsp;<img src="https://img2024.cnblogs.com/blog/527658/202503/527658-20250322214924631-1656296482.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<p>　　2 基于http协议的 springcloud 全家桶封装成微服务</p>
<p>&nbsp;<img src="https://img2024.cnblogs.com/blog/527658/202503/527658-20250322214934942-1732409404.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<p><strong>　　tcp ，http 性能哪个高？</strong><br>　　tcp性能高，http是基于tcp的应用层协议</p>
<p><strong>　　dubbo 和springcloud 区别?</strong><br>​<br>　　1:<strong>Spring Cloud抛弃了Dubbo 的RPC通信，采用的是基于HTTP的REST方式。</strong>严格来说，这两种方式各有优劣。虽然在一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适。<br>　　2:<strong>Dubbo和Spring Cloud并不是完全的竞争关系</strong>，两者所解决的问题域不一样：Dubbo的定位始终是一款RPC框架，而Spring Cloud的目的是微服务架构下的一站式解决方案。<br>　　3:非要比较的话，Dubbo可以类比到Netflix OSS技术栈，而Spring Cloud集成了Netflix OSS作为分布式服务治理解决方案，但除此之外Spring Cloud还提供了包括config、stream、security、sleuth等分布式服务解决方案。当前由于RPC协议、注册中心元数据不匹配等问题，在面临微服务基础框架选型时Dubbo与Spring Cloud只能二选一，这也是两者总拿来做对比的原因。Dubbo之后会积极寻求适配到Spring Cloud生态，比如作为SpringCloud的二进制通讯方案来发挥Dubbo的性能优势，或者Dubbo通过模块化以及对http的支持适配到Spring Cloud</p>
<p>&nbsp;<img src="https://img2024.cnblogs.com/blog/527658/202503/527658-20250322215024766-1126634065.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<h1>二、延迟任务web层接口开发</h1>
<p><br>　　对比了当前比较流行的两套微服务技术解决方案。通过对比的结果我们发现，Dubbo在很多领域，这个解决方案其实并不完善，因此在延迟任务系统进行微服务改造的时候。 我们选择基于http协议的springcloud全家桶封装成微服务。这种形式我们开发起来比较顺手，因为springcloud是基于Http协议，进行服务之间调用的，说白了开发起来就相当于，开发传统的SSM项目，我们只需要编写controller、service以及我们的mapper，有了controller之后我们就可以使用Http进行调用。我们来开发web层接口 （ controller接口）。</p>
<p>　　应用技术： SpringBoot， SpringCloud，Consul ，Redis ，MySQL ， Feign， Junit ， PostMan</p>
<p>　　1：统一Controller接口的返回数据格式，在chongba_common的com.chongba.entity包下添加如下两个类：<br>此处返回结果代码。</p>
<p>　　2：在chongba__schedule_service中创建包：com.chongba.schedule.controller 在该包下创建TaskCtroller类，依次编写：添加任务，消费任务，取消任务的方法</p>
<p>添加任务：pushTask</p>
<p>消费任务：pollTask</p>
<p>取消任务：cancelTask</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">package</span><span style="color: rgba(0, 0, 0, 1)"> com.chongba.schedule.controller;
​
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> com.chongba.entity.ResponseMessage;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> com.chongba.entity.Task;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> com.chongba.schedule.inf.TaskService;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> lombok.extern.slf4j.Slf4j;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.springframework.beans.factory.annotation.Autowired;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> org.springframework.util.Assert;
</span><span style="color: rgba(0, 0, 255, 1)">import</span> org.springframework.web.bind.annotation.*<span style="color: rgba(0, 0, 0, 1)">;
​
@Slf4j
@RestController
@RequestMapping(</span>"/task"<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> TaskController {
    
    @Autowired
    </span><span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> TaskService taskService;
    
    @PostMapping(</span>"/push"<span style="color: rgba(0, 0, 0, 1)">)
    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> ResponseMessage pushTask(@RequestBody Task task){
        log.info(</span>"add task {}"<span style="color: rgba(0, 0, 0, 1)">,task);
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">参数校验</span>
            Assert.notNull(task.getTaskType(),"任务类型不能为空"<span style="color: rgba(0, 0, 0, 1)">);
            Assert.notNull(task.getPriority(),</span>"任务优先级不能为空"<span style="color: rgba(0, 0, 0, 1)">);
            Assert.notNull(task.getExecuteTime(),</span>"任务执行时间不能为空"<span style="color: rgba(0, 0, 0, 1)">);
            Long taskId </span>=<span style="color: rgba(0, 0, 0, 1)"> taskService.addTask(task);
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> ResponseMessage.ok(taskId);
        }</span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e){
            log.error(</span>"push task exception {}"<span style="color: rgba(0, 0, 0, 1)">,task);
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> ResponseMessage.error(e.getMessage());
        }
    }
    
    @GetMapping(</span>"/poll/{type}/{priority}"<span style="color: rgba(0, 0, 0, 1)">)
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> ResponseMessage pollTask(@PathVariable("type") Integer type, @PathVariable("priority"<span style="color: rgba(0, 0, 0, 1)">) Integer priority){
        log.info(</span>"poll task {},{}"<span style="color: rgba(0, 0, 0, 1)">,type,priority);
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            Assert.notNull(type,</span>"任务类型不能为空"<span style="color: rgba(0, 0, 0, 1)">);
            Assert.notNull(priority,</span>"任务优先级不能为空"<span style="color: rgba(0, 0, 0, 1)">);
            Task task </span>=<span style="color: rgba(0, 0, 0, 1)"> taskService.poll(type, priority);
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> ResponseMessage.ok(task);
        } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e) {
            log.error(</span>"poll task exception {},{}"<span style="color: rgba(0, 0, 0, 1)">,type,priority);
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> ResponseMessage.error(e.getMessage());
        }
    }
    
    @PostMapping(</span>"/cancel"<span style="color: rgba(0, 0, 0, 1)">)
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> ResponseMessage cancelTask(@RequestParam("taskId"<span style="color: rgba(0, 0, 0, 1)">) Long taskId){
        log.info(</span>"cancel task {}"<span style="color: rgba(0, 0, 0, 1)">,taskId);
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            Assert.notNull(taskId,</span>"任务id不能为空"<span style="color: rgba(0, 0, 0, 1)">);
            </span><span style="color: rgba(0, 0, 255, 1)">boolean</span> success =<span style="color: rgba(0, 0, 0, 1)"> taskService.cancelTask(taskId);
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> ResponseMessage.ok(success);
        } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e) {
            log.error(</span>"cancel task exception {}"<span style="color: rgba(0, 0, 0, 1)">,taskId);
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> ResponseMessage.error(e.getMessage());
        }
​
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>三、打开postman工具进行测试</h1>
<p><br>　　测试添加任务接口需要传递一个json格式的对象数据，我们可以使用如下的代码来生成一个json数据而无需手动编写，在chongba_schedule_service工程中的测试包com.chongba.schedule下创建测试类TaskToJson，添加如下方法生成json数据，</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">package</span><span style="color: rgba(0, 0, 0, 1)"> com.chongba.schedule;
​
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> com.alibaba.fastjson.JSON;
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> com.chongba.entity.Task;
​
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> java.util.Date;
​
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> TaskToJson {
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> main(String[] args) {
        Task task </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Task();
        task.setTaskType(</span>1001<span style="color: rgba(0, 0, 0, 1)">);
        task.setPriority(</span>1<span style="color: rgba(0, 0, 0, 1)">);
        task.setExecuteTime(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Date().getTime());
        System.out.println(JSON.toJSONString(task));
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>　　测试1：添加方法测试，查看数据库和缓存中是否有任务数据！<br>打开Postman进行添加方法测试：</p>
<p><img src="https://img2024.cnblogs.com/blog/527658/202503/527658-20250322215240532-2144596975.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<p><br><br></p>
<p>　　测试2：取消任务测试，先运行一下添加方法保证系统中有任务，然后在测试取消，查看任务是否被取消！<br>打开PostMan进行取消任务测试：</p>
<p><img src="https://img2024.cnblogs.com/blog/527658/202503/527658-20250322215250003-2111884744.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<p><br><br></p>
<p>　　测试3：消费方法测试，查看缓存中的任务是否被消费，数据库中的数据状态！<br>打开PostMan进行消费方法测试</p>
<p>&nbsp;<img src="https://img2024.cnblogs.com/blog/527658/202503/527658-20250322215300848-801244525.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<p><br><br></p>
</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.6854327229386574" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-22 21:53">2025-03-22 21:53</span>&nbsp;
<a href="https://www.cnblogs.com/kongsq">努力--坚持</a>&nbsp;
阅读(<span id="post_view_count">70</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18787191" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18787191);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18787191', targetLink: 'https://www.cnblogs.com/kongsq/p/18787191', title: '虚拟电商-延迟任务系统的微服务改造（一）改造需求及技术选型' })">举报</a>
</div>
