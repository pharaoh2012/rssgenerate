
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/leason001/p/18663467" title="发布于 2025-01-10 10:19">
    <span role="heading" aria-level="2">Pod的优雅上下线</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Pod的优雅上下线依赖k8s的监控检查机制，以及 Pod lifecycle Hooks，通过这些kubernetes的机制，配合服务发现的流量管理机制，实现业务的优雅上下线。</p>
<h2 id="基础概念">基础概念</h2>
<h3 id="pod-健康检查">Pod 健康检查</h3>
<p>Pod的健康状态由两类探针来检查：LivenessProbe和ReadinessProbe。</p>
<ol>
<li>livenessProbe(存活探针)
<ul>
<li>表明容器是否正在运行。</li>
<li>如果存活探测失败，则 kubelet 会杀死容器，并且容器将受到其 重启策略的影响。</li>
<li>如果容器不提供存活探针，则默认状态为 Success。</li>
</ul>
</li>
<li>readinessProbe(就绪探针)
<ul>
<li>表明容器是否可以正常接受请求。</li>
<li>如果就绪探测失败，端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址。</li>
<li>初始延迟之前的就绪状态默认为 Failure。</li>
<li>如果容器不提供就绪探针，则默认状态为 Success。</li>
</ul>
</li>
<li>StartupProbe（这个 1.16 版本增加的）
<ul>
<li>如果三个探针同时存在，先执行 StartupProbe 探针，其他两个探针将会被暂时禁用，直到 pod 满足 StartupProbe 探针配置的条件，其他 2 个探针启动，如果不满足按照规则重启容器。</li>
</ul>
</li>
</ol>
<p>两种探针的区别<br>
总的来说 ReadinessProbe 和 LivenessProbe 是使用相同探测的方式，只是探测后对 Pod 的处置方式不同：</p>
<ul>
<li>ReadinessProbe： 当检测失败后，将 Pod 的 IP:Port 从对应 Service 关联的 EndPoint 地址列表中删除。</li>
<li>LivenessProbe： 当检测失败后将杀死容器，并根据 Pod 的重启策略来决定作出对应的措施。</li>
</ul>
<p>例子</p>
<pre><code class="language-yaml">livenessProbe:
  failureThreshold: 3
  initialDelaySeconds: 600
  periodSeconds: 5
  successThreshold: 1
  tcpSocket:
    port: 7800
  timeoutSeconds: 1
  
readinessProbe:
  failureThreshold: 3
  httpGet:
    path: /ready
    port: 7800
    scheme: HTTP
  periodSeconds: 5
  successThreshold: 1
  timeoutSeconds: 3
</code></pre>
<h3 id="pod-lifecycle-hooks">Pod lifecycle Hooks</h3>
<p><img src="https://img2024.cnblogs.com/other/3300446/202501/3300446-20250110101931011-1816775902.png" alt="file" loading="lazy"></p>
<ol>
<li>PostStart<br>
PostStart hook在容器启动的时候运行，但并不保证该hook一定会比容器指定的ENTRYPOINT命令先运行。就是说PostStart和ENTRYPOINT都会在容器启动后运行，至于谁先运行，谁先结束，并不一定，是随机的。如果容器启动的时候，PostStart没有成功，容器不会处于running状态。</li>
<li>PreStop<br>
PreStop会在kubelet给Pod发送TERM信号之前执行。一般API Server会给kubelet发送结束Pod的信号，或者Pod的liveness/startup探针失败，或其它原因导致Pod失败，kubelet会尝试发送TERM信号给Pod里主进程。如果PreStop存在，kubelet则会优先启动PreStop，待PreStop结束之后再发送TERM信号给Pod。但从API Server将Pod标记为Terminating状态开始，整个Pod停止时间不能超过terminationGracePeriodSeconds所设置的时间，如果超过，kubelet需要发送KILL信号给Pod所有的进程。</li>
</ol>
<p>例子：</p>
<pre><code class="language-yaml">lifecycle:
      postStart:
        exec:
          command:
          - /bin/sh
          - -c
          - ./online.sh
      preStop:
        exec:
          command:
          - /bin/sh
          - -c
          - ./offline.sh
</code></pre>
<h2 id="实现">实现</h2>
<p><img src="https://img2024.cnblogs.com/other/3300446/202501/3300446-20250110101931235-190897315.png" alt="file" loading="lazy"></p>
<p>优雅上线的实现：</p>
<ul>
<li>Pod启动后，在服务治理框架（sidecar）中开始注册服务，服务注册中心收到服务治理框架的成功注册消息。</li>
<li>同时服务注册中心管理系统会watch应用的Service的Endpoint，当Pod的IP出现时，服务治理框架会任务当前Pod状态ready可以上线服务了，当然Pod的IP出现在Endpoint列表中，本质也是就绪探针成功，这取决于服务治理框架的实现，一般服务治理框架需要提供探针健康检查的接口。</li>
<li>服务注册中心会向上下游通知当前节点上线。</li>
</ul>
<p>Pod下线：</p>
<ul>
<li>Pod的IP从Endpoint列表中消失，服务治理框架会通知应用，应用需要下线服务。</li>
<li>Pod pre stop hook执行后，服务治理框架会通知服务注册中心，服务注册中心会广播此节点下线，停止路由新调用，同时pre stop hook还可以确保服务内已经获得的请求都处理完毕，Pod才可以被回收。</li>
</ul>
<p><a href="https://leason.top/Pod%E7%9A%84%E4%BC%98%E9%9B%85%E4%B8%8A%E4%B8%8B%E7%BA%BF.html#more" target="_blank" rel="noopener nofollow">更多文章</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5822306741400463" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-10 10:20">2025-01-10 10:19</span>&nbsp;
<a href="https://www.cnblogs.com/leason001">leason001</a>&nbsp;
阅读(<span id="post_view_count">180</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18663467" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18663467);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18663467', targetLink: 'https://www.cnblogs.com/leason001/p/18663467', title: 'Pod的优雅上下线' })">举报</a>
</div>
        