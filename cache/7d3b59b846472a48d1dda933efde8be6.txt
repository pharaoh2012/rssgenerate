
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/powertoolsteam/p/19060243" title="发布于 2025-08-27 08:46">
    <span role="heading" aria-level="2">理解 SOLID 原则：编写更简洁的 JavaScript 代码</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>编写简洁、可维护的代码是构建可扩展应用的关键。由罗伯特·C·马丁（Bob 大叔）提出的 SOLID 原则，是五条核心设计准则，能帮助开发者更好地组织代码、减少漏洞，并降低后续修改的难度。</p>
<p>本文将逐一拆解每条原则，用简单的 JavaScript 示例演示，并解释其重要性。</p>
<p><strong>🧱 SOLID 分别代表什么？</strong></p>
<p>SOLID 是五条面向对象设计原则的首字母缩写：</p>
<ul>
<li><strong>S</strong> — 单一职责原则（Single Responsibility Principle, SRP）</li>
<li><strong>O</strong> — 开闭原则（Open/Closed Principle, OCP）</li>
<li><strong>L</strong> — 里氏替换原则（Liskov Substitution Principle, LSP）</li>
<li><strong>I</strong> — 接口隔离原则（Interface Segregation Principle, ISP）</li>
<li><strong>D</strong> — 依赖倒置原则（Dependency Inversion Principle, DIP）</li>
</ul>
<p>下面我们逐一展开讲解。</p>
<p><strong>✅ 1. 单一职责原则（Single Responsibility Principle, SRP）</strong></p>
<p><strong>定义</strong>：一个模块、类或函数，只应有一个修改的理由。</p>
<p><strong>通俗理解</strong>：每个函数或类只做一件事。这能让代码更易测试、复用性更高，且更易维护。</p>
<p>我们先看一个违反 SRP 的反面示例，再对比遵循原则的重构版本。</p>
<p><strong>🚫 反面示例：违反 SRP</strong></p>
<pre><code class="language-JavaScript">function processUserRegistration(userData) {
  // 1. 验证输入
  if (!userData.email.includes('@')) {
    throw new Error('Invalid email');
  }

  // 2. 保存用户到数据库（模拟操作）
  const userId = Math.floor(Math.random() * 1000);

  // 3. 发送欢迎邮件（模拟操作）
  console.log(`Sending welcome email to ${userData.email}`);

  return userId;
}
</code></pre>
<p>❌ <strong>问题所在</strong>：<br>
这个函数同时承担了三个职责：</p>
<ol>
<li>验证输入合法性</li>
<li>保存数据到数据库</li>
<li>发送欢迎邮件</li>
</ol>
<p>每个职责的修改理由都不同（比如业务规则变更、数据库逻辑调整、邮件服务升级），违背了“单一职责”的核心要求。</p>
<p><strong>✅ 正面示例：遵循 SRP</strong></p>
<p>将不同职责拆分到独立函数中：</p>
<pre><code class="language-JavaScript">// 职责1：仅验证用户输入
function validateUser(userData) {
  if (!userData.email.includes('@')) {
    throw new Error('Invalid email');
  }
}

// 职责2：仅负责数据库存储
function saveUserToDatabase(userData) {
  const userId = Math.floor(Math.random() * 1000);
  // 模拟数据库调用
  console.log(`User saved with ID ${userId}`);
  return userId;
}

// 职责3：仅处理邮件发送
function sendWelcomeEmail(email) {
  console.log(`Sending welcome email to ${email}`);
}

// 协调函数：整合流程，不承担具体职责
function registerUser(userData) {
  validateUser(userData);
  const userId = saveUserToDatabase(userData);
  sendWelcomeEmail(userData.email);
  return userId;
}
</code></pre>
<p>✅ <strong>优势</strong>：</p>
<ul>
<li>每个函数目标明确，职责单一</li>
<li>可独立测试（如单独测试输入验证逻辑）</li>
<li>若邮件逻辑变更，只需修改 sendWelcomeEmail，不影响其他功能</li>
</ul>
<p><strong>🧪 使用示例</strong></p>
<pre><code class="language-JavaScript">const user = { email: 'alice@example.com' };
const userId = registerUser(user);
console.log(`New user ID: ${userId}`);
</code></pre>
<p>遵循 SRP 能让代码：</p>
<ul>
<li>更易阅读和重构</li>
<li>模块化程度更高，复用性更强</li>
<li>需求变更时，引入漏洞的风险更低</li>
</ul>
<p>即使在小型 JavaScript 项目中，SRP 也能培养良好的编码习惯，提升长期可维护性。编写代码时，不妨多问自己：“这个函数是不是做了不止一件事？”如果答案是肯定的，就拆分它。</p>
<p><strong>✅ 2. 开闭原则（Open/Closed Principle, OCP）</strong></p>
<p><strong>定义</strong>：由伯特兰·迈耶提出，是 SOLID 原则的第二条，核心要求为：<br>
<strong>软件实体应对扩展开放，对修改关闭</strong>。</p>
<p><strong>通俗理解</strong>：添加新功能时，无需修改已有代码。这种方式能减少引入漏洞的风险，同时提升代码复用性和灵活性。</p>
<p>下面通过 JavaScript 示例，对比违反和遵循 OCP 的实现方式。</p>
<p><strong>❌ 反面示例（违反 OCP）</strong></p>
<pre><code class="language-JavaScript">function getDiscountedPrice(customerType, price) {
  if (customerType === 'regular') {
    return price * 0.9; // 普通用户 9 折
  } else if (customerType === 'vip') {
    return price * 0.8; // VIP 用户 8 折
  } else if (customerType === 'platinum') {
    return price * 0.7; // 铂金用户 7 折
  } else {
    return price; // 无折扣
  }
}
</code></pre>
<p>❌ <strong>问题所在</strong>：</p>
<ul>
<li>新增用户类型（如“黄金用户”）时，必须修改 getDiscountedPrice 函数</li>
<li>违反“对修改关闭”的要求，修改过程可能破坏已有逻辑</li>
<li>逻辑高度耦合，扩展性差</li>
</ul>
<p><strong>✅ 正面示例（遵循 OCP）</strong></p>
<p>通过“策略模式”重构，用类的继承实现扩展：</p>
<pre><code class="language-JavaScript">// 抽象基类：定义折扣策略接口
class DiscountStrategy {
  getDiscount(price) {
    return price; // 默认无折扣
  }
}

// 普通用户折扣策略（扩展）
class RegularCustomerDiscount extends DiscountStrategy {
  getDiscount(price) {
    return price * 0.9;
  }
}

// VIP 用户折扣策略（扩展）
class VIPCustomerDiscount extends DiscountStrategy {
  getDiscount(price) {
    return price * 0.8;
  }
}

// 铂金用户折扣策略（扩展）
class PlatinumCustomerDiscount extends DiscountStrategy {
  getDiscount(price) {
    return price * 0.7;
  }
}

// 使用入口：对修改关闭，仅依赖抽象基类
function getDiscountedPrice(discountStrategy, price) {
  return discountStrategy.getDiscount(price);
}

// 实际使用
const customer = new VIPCustomerDiscount();
console.log(getDiscountedPrice(customer, 100)); // 输出 80（8 折）
</code></pre>
<p>✅ <strong>优化点在哪里</strong>：</p>
<ul>
<li>新增折扣策略时，只需创建新的子类继承 DiscountStrategy，无需修改已有代码</li>
<li>符合 OCP 核心：getDiscountedPrice 函数对修改关闭，对扩展开放（通过多态实现）</li>
<li>逻辑解耦，易测试、易扩展</li>
</ul>
<p><strong>🚀 OCP 在 JavaScript 中的实际应用</strong></p>
<ul>
<li><strong>中间件系统</strong>（如 Express.js）：添加新中间件时，无需修改框架核心逻辑</li>
<li><strong>插件架构</strong>（如 Webpack、ESLint）：通过插件扩展功能，不改动工具内部代码</li>
<li><strong>表单验证库</strong>：新增验证规则时，只需注册规则，无需重写验证器核心</li>
</ul>
<p><strong>✅ 3. 里氏替换原则（Liskov Substitution Principle, LSP）</strong></p>
<p><strong>定义</strong>：由芭芭拉·里氏提出，是 SOLID 原则的第三条，核心要求为：<br>
<strong>子类对象应能替换父类对象，且不影响程序的正确性</strong>。</p>
<p><strong>通俗理解</strong>：子类的行为应与父类一致。如果需要检查对象类型，或重写方法时破坏了预期行为，就可能违反 LSP。</p>
<p>下面用 JavaScript 示例演示 LSP 的应用。</p>
<p><strong>❌ 反面示例（违反 LSP）</strong></p>
<pre><code class="language-JavaScript">// 父类：定义“鸟”的行为
class Bird {
  fly() {
    console.log('Flying');
  }
}

// 子类：企鹅（继承自鸟，但无法飞行）
class Penguin extends Bird {
  fly() {
    throw new Error("Penguins can't fly!"); // 重写方法但破坏预期行为
  }
}

// 通用函数：假设所有“鸟”都能飞行
function makeBirdFly(bird) {
  bird.fly();
}

// 测试
const genericBird = new Bird();
const penguin = new Penguin();

makeBirdFly(genericBird); // ✅ 输出 "Flying"
makeBirdFly(penguin);     // ❌ 抛出错误
</code></pre>
<p>❌ <strong>问题所在</strong>：</p>
<ul>
<li>Penguin 继承自 Bird，但重写的 fly 方法与父类预期行为冲突（父类默认“能飞”）</li>
<li>makeBirdFly 函数依赖“鸟能飞”的假设，但 Penguin 无法满足，导致程序出错</li>
<li>违反 LSP：子类不能安全替换父类</li>
</ul>
<p><strong>✅ 正面示例（遵循 LSP）</strong></p>
<p>按“行为”设计继承结构，而非单纯按“类型”：</p>
<pre><code class="language-JavaScript">// 父类：定义“鸟”的通用行为（所有鸟都会下蛋）
class Bird {
  layEgg() {
    console.log('Laying an egg');
  }
}

// 子类：会飞的鸟（拆分“飞行”行为）
class FlyingBird extends Bird {
  fly() {
    console.log('Flying');
  }
}

// 子类：企鹅（不会飞，仅继承鸟的通用行为）
class Penguin extends Bird {
  swim() {
    console.log('Swimming');
  }
}

// 子类：麻雀（会飞，继承 FlyingBird）
class Sparrow extends FlyingBird {}

// 通用函数：仅接收“会飞的鸟”
function letBirdFly(bird) {
  bird.fly();
}

// 测试
const sparrow = new Sparrow();
letBirdFly(sparrow); // ✅ 输出 "Flying"

const penguin = new Penguin();
// letBirdFly(penguin); ❌ 若调用会报错，但设计上已避免这种用法
</code></pre>
<p>✅ <strong>优化点在哪里</strong>：</p>
<ul>
<li>拆分 Bird 和 FlyingBird，确保只有“会飞的鸟”才会被传入 letBirdFly</li>
<li>Penguin 仍属于 Bird，但不承担“飞行”职责，符合实际行为</li>
<li>子类未破坏父类的行为预期，可安全替换父类使用</li>
</ul>
<p><strong>🚀 LSP 在 JavaScript 中的实际应用</strong></p>
<ul>
<li><strong>React 组件</strong>：组件继承基类或使用 Hooks 时，不应破坏复用或组合的预期行为</li>
<li><strong>Promise 链</strong>：返回值需符合预期类型（如不随意混合同步/异步逻辑）</li>
<li><strong>事件处理器/中间件</strong>：需遵守约定（如 Express 中间件需调用 next()）</li>
</ul>
<p><strong>✅ 核心要点</strong></p>
<p>在 JavaScript 中遵循 LSP，需注意：</p>
<ol>
<li>子类不应重写方法以抛出错误或大幅改变行为</li>
<li>用“鸭子类型”（Duck Typing）非正式地定义接口，确保行为一致性</li>
<li>按“能力”设计，而非按“类型”（如拆分 FlyingBird 和 Bird）</li>
</ol>
<p>即使没有静态类型检查，JavaScript 开发者也能通过合理设计类层级、明确行为约定和可替换性，从 LSP 中获益。</p>
<p><strong>✅ 4. 接口隔离原则（Interface Segregation Principle, ISP）</strong></p>
<p><strong>定义</strong>：SOLID 原则的第四条，核心要求为：<br>
<strong>客户端不应被迫依赖它不需要的接口</strong>。</p>
<p><strong>JavaScript 场景理解</strong>：不要让函数、类或对象实现无用的功能。应将庞大、通用的接口拆分为小型、针对性的接口。</p>
<p>这种设计能提升可维护性、避免代码臃肿，并让单个行为的扩展和测试更简单。</p>
<p><strong>❌ 反面示例（违反 ISP）</strong></p>
<pre><code class="language-JavaScript">// 庞大的“机器”接口：包含打印、扫描、传真功能
class Machine {
  print() {
    throw new Error('Not implemented');
  }

  scan() {
    throw new Error('Not implemented');
  }

  fax() {
    throw new Error('Not implemented');
  }
}

// 老式打印机：仅支持打印，但被迫继承所有方法
class OldPrinter extends Machine {
  print() {
    console.log('Printing...');
  }

  // scan() 和 fax() 未实现，却必须继承
}
</code></pre>
<p>❌ <strong>问题所在</strong>：</p>
<ul>
<li>OldPrinter 仅支持打印，却被迫继承 scan 和 fax 方法</li>
<li>无用方法需保留空实现或抛出错误，易导致运行时混乱</li>
<li>违反 ISP：客户端被迫依赖不需要的接口</li>
</ul>
<p><strong>✅ 正面示例（遵循 ISP）</strong></p>
<p>按职责拆分接口，用“组合”替代“继承”：</p>
<pre><code class="language-JavaScript">// 小型接口1：仅处理打印
class Printer {
  print() {
    console.log('Printing...');
  }
}

// 小型接口2：仅处理扫描
class Scanner {
  scan() {
    console.log('Scanning...');
  }
}

// 小型接口3：仅处理传真
class FaxMachine {
  fax() {
    console.log('Faxing...');
  }
}

// 现代打印机：组合多个接口，拥有完整功能
class ModernPrinter {
  constructor() {
    this.printer = new Printer();
    this.scanner = new Scanner();
    this.faxMachine = new FaxMachine();
  }

  print() {
    this.printer.print();
  }

  scan() {
    this.scanner.scan();
  }

  fax() {
    this.faxMachine.fax();
  }
}

// 基础打印机：仅组合“打印”接口
class BasicPrinter {
  constructor() {
    this.printer = new Printer();
  }

  print() {
    this.printer.print();
  }
}
</code></pre>
<p>✅ <strong>优化点在哪里</strong>：</p>
<ul>
<li>功能模块化：每个接口小型且目标明确</li>
<li>BasicPrinter 仅依赖所需的“打印”功能，无冗余</li>
<li>ModernPrinter 通过组合扩展功能，无需继承无用方法</li>
<li>符合 ISP：没有类被迫实现不需要的功能</li>
</ul>
<p><strong>🚀 ISP 在 JavaScript 中的实际应用</strong></p>
<ul>
<li><strong>React 组件</strong>：避免传递庞大的 props 对象，只传组件必需的属性</li>
<li><strong>模块化服务</strong>：拆分服务职责（如 StorageService 不应包含 sendEmail 方法）</li>
<li><strong>Node.js 模块</strong>：按用途拆分工具函数（如 mathUtils.js 不应包含 parseQueryString）</li>
</ul>
<p><strong>✂️ 保持接口精简且目标明确</strong></p>
<p>在 JavaScript 中遵循 ISP，可遵循以下建议：</p>
<ol>
<li>将庞大的接口（或对象）拆分为小型、用途单一的单元</li>
<li>不强迫组件、函数或类实现超出需求的功能</li>
<li>尽可能用“组合”替代“继承”</li>
</ol>
<p>应用 ISP 后，代码会更简洁、聚焦，且随着项目增长，可维护性会显著提升。</p>
<p><strong>✅ 5. 依赖倒置原则（Dependency Inversion Principle, DIP）</strong></p>
<p><strong>定义</strong>：SOLID 原则的最后一条，核心要求为：</p>
<ol>
<li>高层模块不应依赖低层模块，两者都应依赖抽象；</li>
<li>抽象不应依赖细节，细节应依赖抽象。</li>
</ol>
<p><strong>🧠 通俗解释</strong></p>
<p>核心业务逻辑（高层代码）不应与具体实现细节（如 API、数据库）强耦合。相反，两者都应依赖统一的抽象（如接口、基类）。</p>
<p>这种设计能提升灵活性、可测试性，并实现关注点分离。</p>
<p><strong>❌ 反面示例（违反 DIP）</strong></p>
<pre><code class="language-JavaScript">// 低层模块：具体的 MySQL 数据库实现
class MySQLDatabase {
  save(data) {
    console.log('Saving data to MySQL:', data);
  }
}

// 高层模块：用户服务（强耦合 MySQL 实现）
class UserService {
  constructor() {
    this.db = new MySQLDatabase(); // 硬编码依赖低层模块
  }

  registerUser(user) {
    this.db.save(user);
  }
}
</code></pre>
<p>❌ <strong>问题所在</strong>：</p>
<ul>
<li>UserService 与 MySQLDatabase 强耦合，无法替换数据库（如切换到 MongoDB）</li>
<li>测试困难：模拟 MySQLDatabase 需修改核心逻辑</li>
<li>违反 DIP：高层模块直接依赖低层模块的具体实现</li>
</ul>
<p><strong>✅ 正面示例（遵循 DIP）</strong></p>
<p>通过“抽象基类”解耦，让高层和低层都依赖抽象：</p>
<pre><code class="language-JavaScript">// 抽象基类（抽象）：定义数据库接口
class Database {
  save(data) {
    throw new Error('Not implemented'); // 抽象方法，由子类实现
  }
}

// 低层实现1：MySQL 数据库（依赖抽象）
class MySQLDatabase extends Database {
  save(data) {
    console.log('Saving data to MySQL:', data);
  }
}

// 低层实现2：内存数据库（依赖抽象，用于测试）
class InMemoryDatabase extends Database {
  constructor() {
    super();
    this.data = [];
  }

  save(data) {
    this.data.push(data);
    console.log('Saved in memory:', data);
  }
}

// 高层模块：用户服务（依赖抽象，不依赖具体实现）
class UserService {
  constructor(database) {
    this.db = database; // 通过构造函数注入依赖
  }

  registerUser(user) {
    this.db.save(user);
  }
}
</code></pre>
<p><strong>使用示例</strong></p>
<pre><code class="language-JavaScript">// 可灵活切换数据库实现，无需修改 UserService
const db = new MySQLDatabase(); // 或 new InMemoryDatabase()
const userService = new UserService(db);
userService.registerUser({ name: 'Eve' });
</code></pre>
<p><strong>🎯 优化点在哪里</strong></p>
<ol>
<li>UserService 可适配任何遵循 Database 抽象的实现（MySQL、MongoDB 等）</li>
<li>替换数据库时，无需修改核心业务逻辑</li>
<li>测试更简单：用 InMemoryDatabase 模拟数据库，无需真实环境</li>
</ol>
<p><strong>🧭 依赖倒置原则总结</strong></p>
<p>依赖倒置原则通过以下方式提升代码灵活性和可维护性：</p>
<ul>
<li>优先依赖抽象类/接口，而非具体类</li>
<li>降低层间耦合（高层与低层不直接关联）</li>
<li>便于单元测试（可轻松模拟依赖）</li>
<li>支持依赖替换（实际场景中灵活切换实现）</li>
</ul>
<p>通过围绕抽象设计，能构建组件可替换、代码易演进的系统。</p>
<p><strong>📦 SOLID 原则最终总结</strong></p>
<p>SOLID 原则并非纯理论，而是经过验证的、实用的面向对象代码设计准则。遵循这些原则，你将获得：</p>
<ul>
<li>更简洁、模块化的代码</li>
<li>更易测试和调试的逻辑</li>
<li>更低的漏洞引入风险</li>
<li>更高的扩展性和灵活性</li>
</ul>
<p><strong>SOLID 原则核心要点速查表</strong></p>
<table>
<thead>
<tr>
<th>原则</th>
<th>核心思想</th>
</tr>
</thead>
<tbody>
<tr>
<td>SRP（单一职责）</td>
<td>一个函数/类只负责一件事</td>
</tr>
<tr>
<td>OCP（开闭）</td>
<td>扩展功能无需修改已有代码</td>
</tr>
<tr>
<td>LSP（里氏替换）</td>
<td>子类可替换父类，且不破坏程序正确性</td>
</tr>
<tr>
<td>ISP（接口隔离）</td>
<td>不强迫客户端依赖无用接口</td>
</tr>
<tr>
<td>DIP（依赖倒置）</td>
<td>依赖抽象，而非具体实现</td>
</tr>
</tbody>
</table>
<p>这五条原则共同构成了可维护、可适配、可扩展 JavaScript 应用的基础——即使在小型项目中，也能发挥重要作用。</p>
<p><strong>💼 关于 SOLID 的常见面试题</strong></p>
<p>若你正在准备面试，或想深化对 SOLID 的理解，以下是常见的相关问题及解答思路：</p>
<p><strong>1. SOLID 原则是什么？</strong></p>
<p>SOLID 是五条面向对象设计原则的首字母缩写，包括：</p>
<ul>
<li>S：单一职责原则（SRP）</li>
<li>O：开闭原则（OCP）</li>
<li>L：里氏替换原则（LSP）</li>
<li>I：接口隔离原则（ISP）</li>
<li>D：依赖倒置原则（DIP）</li>
</ul>
<p>它们的核心目标是帮助开发者编写可扩展、可维护、低耦合的代码。</p>
<p><strong>2. 为什么单一职责原则很重要？</strong></p>
<p>SRP 确保模块/类/函数只有一个修改理由，能降低耦合度、提升可维护性。<br>
在 JavaScript 中，常见应用场景是拆分验证、数据存储、通信等逻辑（如用户注册时，分别处理输入校验、数据库保存、邮件发送）。</p>
<p><strong>3. 如何在 JavaScript 中实现开闭原则？</strong></p>
<p>通过多态或高阶函数实现，例如“策略模式”：<br>
定义抽象基类/接口，新增功能时创建子类/新策略，而非修改已有代码。<br>
示例：不同用户的折扣计算（新增“黄金用户”时，只需添加新的折扣策略类）。</p>
<p><strong>4. 里氏替换原则在实际应用中是什么意思？</strong></p>
<p>子类应能替代父类使用，且不改变程序行为。<br>
在 JavaScript 中，继承类时需确保重写的方法符合父类约定（如返回类型、参数格式、行为预期）。例如，Penguin 不应继承 Bird 的 fly 方法后抛出错误。</p>
<p><strong>5. 没有正式接口的 JavaScript，如何应用接口隔离原则？</strong></p>
<p>即使没有静态接口，仍可通过“小型、聚焦的抽象”遵循 ISP：</p>
<ul>
<li>避免设计包含冗余功能的大对象/类</li>
<li>用组合替代继承，按需整合功能</li>
<li>传递 props 或参数时，只传必需的内容（如 React 组件不接收无用 props）</li>
</ul>
<p><strong>6. 依赖倒置原则是什么？如何在 JavaScript 中应用？</strong></p>
<p>DIP 要求高层模块不依赖低层模块，两者都依赖抽象。<br>
在 JavaScript 中，可通过“依赖注入”实现：将低层模块（如数据库、邮件服务）作为参数传入高层模块，而非硬编码。例如，UserService 接收 Database 实例，而非直接创建 MySQLDatabase。</p>
<p><strong>7. 能否举一个 JavaScript 中应用 SOLID 原则的实际例子？</strong></p>
<p>以 Express.js 应用为例：</p>
<ul>
<li><strong>SRP</strong>：路由处理、参数验证、业务逻辑拆分到不同模块</li>
<li><strong>OCP</strong>：新增接口时，通过添加中间件扩展功能，不修改核心逻辑</li>
<li><strong>LSP</strong>：不同认证策略（如 JWT、OAuth）的子类，可替换使用</li>
<li><strong>ISP</strong>：服务接口聚焦（如 EmailService 只处理邮件，不包含存储逻辑）</li>
<li><strong>DIP</strong>：控制器通过依赖注入接收数据库服务，而非直接导入</li>
</ul>
<p>✅ <strong>面试技巧</strong>：深入理解 SOLID 原则，需能做到三点——解释原则定义、识别代码中的违反情况、演示重构优化方法。面试官通常关注这三方面的能力。</p>
<h2 id="扩展链接">扩展链接</h2>
<p><a href="https://demo.grapecity.com.cn/spreadjs/help/docs/spreadjs_designer_component/designer-javaScript-frameworks" target="_blank" rel="noopener nofollow">SpreadJS如何支持JavaScript框架</a></p>

</div>
<div id="MySignature" role="contentinfo">
    <hr>
<br>
<p style="font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000">本文是由葡萄城技术开发团队发布，转载请注明出处：<a href="https://www.grapecity.com.cn/" target="_blank">葡萄城官网</a></p>
<!--p style="font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000">了解企业级低代码开发平台，请前往<a href="https://www.grapecity.com.cn/solutions/huozige" target="_blank">活字格</a>
</p><p style="font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000">了解可嵌入您系统的在线 Excel，请前往<a href="https://www.grapecity.com.cn/developer/spreadjs" target="_blank">SpreadJS纯前端表格控件</a></p>
<p style="font-size: 16px; font-family: 微软雅黑, 黑体, Arial; color: #000">了解嵌入式的商业智能和报表软件，请前往<a href="https://www.grapecity.com.cn/solutions/wyn" target="_blank">Wyn Enterprise
</a></p-->

<br>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-27 08:47">2025-08-27 08:46</span>&nbsp;
<a href="https://www.cnblogs.com/powertoolsteam">葡萄城技术团队</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19060243);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19060243', targetLink: 'https://www.cnblogs.com/powertoolsteam/p/19060243', title: '理解 SOLID 原则：编写更简洁的 JavaScript 代码' })">举报</a>
</div>
        