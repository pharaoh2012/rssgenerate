
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ysmc/p/18798097" title="发布于 2025-03-28 15:02">
    <span role="heading" aria-level="2">C#异步编程的好处</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>原文链接：<a class="ng-star-inserted" href="https://www.cnblogs.com/ysmc/p/18798097" rel="noopener" target="_blank">https://www.cnblogs.com/ysmc/p/18798097</a></p>
<h1>C# 异步编程的好处</h1>
<p>异步编程是C#中非常重要的特性，它能让你的程序更高效、更流畅。我来用简单的方式解释它的好处：</p>
<h2>1. 七窍玲珑心<strong>&nbsp;- "边敲代码边和女朋友通话"</strong></h2>
<ul>
<li>
<p>同步代码就像你敲代码时必须双手离开键盘才能接女朋友的电话</p>
</li>
<li>
<p>异步代码让你可以边敲代码边和女朋友通话，不影响写bug，女朋友也哄不好</p>
</li>
</ul>
<h2>2. 人力资源合理应用<strong>&nbsp;- "餐厅服务员"</strong></h2>
<ul>
<li>
<p>同步就像服务员一次只服务一桌，其他桌干等着</p>
</li>
<li>
<p>异步就像服务员点完一桌菜就去服务下一桌，等菜好了再回来</p>
</li>
</ul>
<h2>3.&nbsp;<strong>人员合理化运用 - "不浪费线程"</strong></h2>
<ul>
<li>
<p>同步会占用线程傻等（像雇人站着等水烧开）</p>
</li>
<li>
<p>异步在等待时释放线程去做其他事（让工人去干别的活）</p>
</li>
</ul>
<h2>4. 客户至上<strong>&nbsp;- "不转圈圈"</strong></h2>
<ul>
<li>
<p>同步操作时用户界面会冻结（转圈圈）</p>
</li>
<li>
<p>异步操作时界面保持响应（可以继续操作）</p>
</li>
</ul>
<h2>5.&nbsp;<strong>适合IO操作 - "快递驿站"</strong></h2>
<ul>
<li>
<p>读取文件、网络请求等IO操作特别适合异步</p>
</li>
<li>
<p>你不需要等着快递的到来，让快递员放驿站，你空了再去拿好了</p>
</li>
</ul>
<h2>简单代码对比</h2>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> TestService
</span><span style="color: rgba(0, 128, 128, 1)"> 2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 3</span>     <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> IHttpClientFactory _httpClientFactory;
</span><span style="color: rgba(0, 128, 128, 1)"> 4</span> 
<span style="color: rgba(0, 128, 128, 1)"> 5</span>     <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> TestService(IHttpClientFactory httpClientFactory)
</span><span style="color: rgba(0, 128, 128, 1)"> 6</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)"> 7</span>         _httpClientFactory =<span style="color: rgba(0, 0, 0, 1)"> httpClientFactory;
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 9</span> 
<span style="color: rgba(0, 128, 128, 1)">10</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 同步方式 - 会卡住UI</span>
<span style="color: rgba(0, 128, 128, 1)">11</span>     <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">object</span><span style="color: rgba(0, 0, 0, 1)"> GetData()
</span><span style="color: rgba(0, 128, 128, 1)">12</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">13</span>         <span style="color: rgba(0, 0, 255, 1)">using</span> <span style="color: rgba(0, 0, 255, 1)">var</span> httpClient =<span style="color: rgba(0, 0, 0, 1)"> _httpClientFactory.CreateClient();
</span><span style="color: rgba(0, 128, 128, 1)">14</span>         <span style="color: rgba(0, 0, 255, 1)">var</span> data = httpClient.GetByteArrayAsync(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">https://example.com</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">15</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 在获取完成前什么都做不了</span>
<span style="color: rgba(0, 128, 128, 1)">16</span>         <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> data;
</span><span style="color: rgba(0, 128, 128, 1)">17</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">18</span> 
<span style="color: rgba(0, 128, 128, 1)">19</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 异步方式 - 不会卡住UI</span>
<span style="color: rgba(0, 128, 128, 1)">20</span>     <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span> Task&lt;<span style="color: rgba(0, 0, 255, 1)">object</span>&gt;<span style="color: rgba(0, 0, 0, 1)"> GetDataAsync()
</span><span style="color: rgba(0, 128, 128, 1)">21</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">22</span>         <span style="color: rgba(0, 0, 255, 1)">using</span> <span style="color: rgba(0, 0, 255, 1)">var</span> httpClient =<span style="color: rgba(0, 0, 0, 1)"> _httpClientFactory.CreateClient();
</span><span style="color: rgba(0, 128, 128, 1)">23</span>         <span style="color: rgba(0, 0, 255, 1)">var</span> data = <span style="color: rgba(0, 0, 255, 1)">await</span> httpClient.GetByteArrayAsync(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">https://example.com</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">24</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 在获取过程中程序可以干别的</span>
<span style="color: rgba(0, 128, 128, 1)">25</span>         <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> data;
</span><span style="color: rgba(0, 128, 128, 1)">26</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">27</span> }</pre>
</div>
<p>同样感谢大佬们的观看！</p>
</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/ysmc/" target="_blank">一事冇诚</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/ysmc/p/18798097" target="_blank">https://www.cnblogs.com/ysmc/p/18798097</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="9.890431081346065" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-28 15:02">2025-03-28 15:02</span>&nbsp;
<a href="https://www.cnblogs.com/ysmc">一事冇诚</a>&nbsp;
阅读(<span id="post_view_count">6336</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18798097" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18798097);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18798097', targetLink: 'https://www.cnblogs.com/ysmc/p/18798097', title: 'C#异步编程的好处' })">举报</a>
</div>
        