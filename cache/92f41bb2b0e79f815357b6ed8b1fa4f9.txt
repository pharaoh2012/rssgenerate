
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chenshibao/p/18813390" title="发布于 2025-04-07 19:31">
    <span role="heading" aria-level="2">TCP传输控制协议的简谈</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1说明">1.说明</h2>
<p>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<h3 id="11-tcp特点">1.1 TCP特点</h3>
<ul>
<li>基于流的方式；</li>
<li>面向连接；</li>
<li>可靠通信方式；</li>
<li>在网络状况不佳的时候尽量降低系统由于重传带来的带宽开销；</li>
<li>通信连接维护是面向通信的两个端点的，而不考虑中间网段和节点。</li>
</ul>
<h2 id="2简历连接">2.简历连接</h2>
<h3 id="tcp三次握手的过程如下">TCP三次握手的过程如下：</h3>
<ol>
<li>客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。</li>
<li>服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK（ACK=x+1）报文，进入SYN_RECV状态。</li>
<li>客户端收到服务器端的SYN报文，回应一个ACK（ACK=y+1）报文，进入Established状态。<br>
三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250407192731512-1948600375.png" alt="image" loading="lazy"></p>
<h2 id="3断开连接">3.断开连接</h2>
<p>建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。具体过程如下图所示。</p>
<ol>
<li>某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。</li>
<li>接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。</li>
<li>一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。</li>
<li>接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。</li>
</ol>
<p>注意：</p>
<pre><code>FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。
</code></pre>
<p>既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。</p>
<p>注意：</p>
<ol>
<li>“通常”是指，某些情况下，步骤1的FIN随数据一起发送，另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。</li>
<li>在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的，这称为“半关闭”（half-close）。</li>
<li>当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN。<br>
无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202504/2212230-20250407193000883-251772943.png" alt="image" loading="lazy"></p>
<h2 id="4发送">4.发送</h2>
<p>当调用Send函数时，实际上在Socket内部会做以下事项：</p>
<ol>
<li>检查Send数据的有效性。例如是否为null，长度是否为0等。</li>
<li>检查发送缓存区是否有空闲，如果有，将需要发送的数据复制到缓存区，并且返回已复制的字节数。如果没有空闲，则会一直等待。</li>
</ol>
<p>通过上述两个步骤，我们会明白，Send函数的返回，仅仅是保证数据被复制到了发送缓存区，而不是已被接收方收到。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="2.7012134389907407" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-07 19:31">2025-04-07 19:31</span>&nbsp;
<a href="https://www.cnblogs.com/chenshibao">似梦亦非梦</a>&nbsp;
阅读(<span id="post_view_count">29</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18813390" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18813390);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18813390', targetLink: 'https://www.cnblogs.com/chenshibao/p/18813390', title: 'TCP传输控制协议的简谈' })">举报</a>
</div>
        