
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cicada-smile/p/18965103" title="发布于 2025-07-04 10:05">
    <span role="heading" aria-level="2">SpringBoot3集成多款主流大模型</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1691717/202507/1691717-20250704095513743-1637752712.png" alt="SpringBoot3集成多款主流大模型" class="desc_img">
        第一款尝试的产品自然是AI方向，此前不具备专业的产品经验，所以只能更多的依赖大模型的能力。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><strong>集成：DeepSeek，豆包，混元，通义千问。</strong></p>
<h1 id="一简介">一、简介</h1>
<p>2025年7月份，开始转型独立开发者。</p>
<p>第一款尝试的产品自然是AI方向，此前不具备专业的产品经验，所以只能更多的依赖大模型的能力。</p>
<p>年初DeepSeek成功证明模型即产品的理念，所以第一款产品尽量降低传统的产品设计思维，会把场景和流程交给大模型去处理，通过反复测试来调整干预的权重，找到一个相对平衡的比例。</p>
<p>有时候在反思，自己的脑回路会不会限制AI的发挥。</p>
<p>在产品的初期，先选择接入四款大模型，深度求索的DeepSeek，字节跳动的豆包，腾讯的混元，阿里的通义千问。</p>
<p>模型即产品，那产品是什么？</p>
<p>当然每家的大模型，都有自己的能力特点，这里只是从产品的整体功能考量，这几款模型可能更适合，后续可能也会在实践中做动态调整。</p>
<h1 id="二大模型自评">二、大模型自评</h1>
<p>如何快速熟悉大模型的能力？多提问题，多和它来回拉扯。</p>
<p>首先给这几款大模型，抛出一个灵魂拷问：</p>
<p>作为一款很强的大模型，请你客观的分析DeepSeek，豆包，千问，混元，这四款大模型的差异，并从综合能力的角度给个排序。</p>
<p>看热闹不嫌事大，先让大模型自我分析一把，验证一下自己对它们的预期。</p>
<p><strong>DeepSeek回答：</strong></p>
<p><img alt="1" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1691717/202507/1691717-20250704095303473-680924038.png" class="lazyload"></p>
<p><strong>豆包回答：</strong></p>
<p><img alt="2" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1691717/202507/1691717-20250704095307907-675578175.png" class="lazyload"></p>
<p><strong>通义千问回答：</strong></p>
<p><img alt="3" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1691717/202507/1691717-20250704095312451-831755785.png" class="lazyload"></p>
<p><strong>混元回答：</strong></p>
<p><img alt="4" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1691717/202507/1691717-20250704095319953-1815761245.png" class="lazyload"></p>
<p>各个大模型对于能力的排序，权当个热闹看一看。</p>
<p>不过有个结论可以得出来的：不同平台的业务和数据有很大差异，所以训练出来的模型能力也有差异。</p>
<p>此前文章中写过DeepSeek的代码测评，确实很惊艳；豆包的产品化能力，方便解决很多生活问题；混元经常用来分析行业热门事件；通义千问常用来提供业务设计的参考。</p>
<p>所以产品的不同功能，交给不同的大模型来处理，是比较合理的策略。</p>
<h1 id="三springboot集成">三、SpringBoot集成</h1>
<p>从产品的业务需求出发，来设计后端框架的模型对接，既然需要集成多款大模型，自然是通用的组件更方便管理，通过测试对比个人倾向使用<code>spring-ai-openai</code>依赖包。</p>
<p>这几款模型的使用文档，都适配了OpenAI的接口规范，只是豆包有轻微的细节差异。</p>
<h2 id="31-版本依赖">3.1 版本依赖</h2>
<p>这里说一下简单的思路，是先敲定<code>spring-ai-openai</code>组件的版本，在这个组件中依赖<code>spring-boot</code>的<code>3.3.6</code>版本，以此定了后端的框架和版本。</p>
<pre><code class="language-xml">&lt;spring-boot.version&gt;3.3.6&lt;/spring-boot.version&gt;
&lt;spring-ai-openai.version&gt;1.0.0-M5&lt;/spring-ai-openai.version&gt;

&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
    &lt;artifactId&gt;spring-ai-openai-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;${spring-ai-openai.version}&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;!-- SpringBoot依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;${spring-boot.version}&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
    &lt;scope&gt;import&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="32-配置和测试">3.2 配置和测试</h2>
<p>首先看基础的<code>Yaml</code>配置文件，比较常见的就是请求的地址和方法，然后指定大模型使用的版本名称，这里要注意豆包配置的差异，千问和混元也是一样的方式。</p>
<pre><code class="language-yaml">spring:
  # 大模型配置
  ai:
    openai:
      base-url: https://api.deepseek.com
      api-key: sk-deep-seek
      chat:
        # 默认配置
        # 豆包大模型使用：/api/v3/chat/completions
        completions-path: /v1/chat/completions
        options:
          model: deepseek-chat
</code></pre>
<p>简单做个测试的用例，构建<code>ChatClient</code>类，传入自定义的提示词，请求DeepSeek大模型，没有使用流式输出，所以请求响应的时间比较长。</p>
<pre><code class="language-java">@RestController
public class TestModelWeb {

    private final ChatClient chatClient ;

    public TestModelWeb(ChatClient.Builder chatClientBuilder) {
        this.chatClient = chatClientBuilder.build();
    }

    @GetMapping(value = "/client")
    public String chatClient() {
        String message = "讲个笑话，最好能把我听哭的那一种。";
        return  chatClient.prompt(new Prompt(message)).call().content();
    }
}
</code></pre>
<h2 id="33-多模型封装">3.3 多模型封装</h2>
<p>通过配置文件管理模型的集成虽然简单高效，但是产品的场景中有模型动态选择的功能，所以做个简单的封装，在容器中存<code>ChatClient</code>类，选中哪款调用哪款。</p>
<pre><code class="language-java">/**
 * 大模型工厂
 * @author 七号楼
 * @since 2025-07-02 13:48
 */
@Component
public class ModelFactory {

    private static volatile Map&lt;String, ChatClient&gt; modelMap = new HashMap&lt;&gt;();

    /**
     * 获取模型
     * @since 2025-07-03 10:53
     */
    public static ChatClient getModel (String modelName){
        return modelMap.get(modelName);
    }

    /**
     * 移除模型
     * @since 2025-07-03 10:53
     */
    public static void removeModel (String modelName){
        if (CollUtil.contains(modelMap.keySet(),modelName)){
            modelMap.remove(modelName);
        }
    }
    /**
     * 添加模型
     * @since 2025-07-03 10:53
     */
    public static void putModel (OpenAiChatProperties properties,OpenAiChatOptions options){
        ChatClient buildClient = buildChatClient(properties,options);
        modelMap.put(options.getModel(),buildClient);
    }
    /**
     * 构建ChatClient对话客户端
     * @param properties 基础配置
     * @param options 选项配置
     * @return ChatClient
     */
    private static ChatClient buildChatClient(OpenAiChatProperties properties,OpenAiChatOptions options) {
        properties.setOptions(options);
        OpenAiApi openAiApi = new OpenAiApi(
                properties.getBaseUrl(),
                properties.getApiKey(),
                properties.getCompletionsPath(),
                "/v1/embeddings",
                RestClient.builder(),
                WebClient.builder(),
                RetryUtils.DEFAULT_RESPONSE_ERROR_HANDLER);
        OpenAiChatModel chatModel = new OpenAiChatModel(openAiApi,options);
        return ChatClient.builder(chatModel).build();
    }
}
</code></pre>
<p>多款大模型的配置信息，统一维护在表中即可，在服务启动时加载一次，初始化<code>ModelFactory</code>中的<code>Map</code>容器。</p>
<pre><code class="language-java">@Service
public class ModelConfigServiceImpl extends ServiceImpl&lt;ModelConfigMapper, ModelConfig&gt; implements ModelConfigService {

    @PostConstruct
    public void init (){
        List&lt;ModelConfig&gt; modelList = this.list();
        if (CollUtil.isNotEmpty(modelList)){
            for (ModelConfig modelConfig:modelList) {
                // 基础配置
                OpenAiChatProperties properties = new OpenAiChatProperties();
                properties.setBaseUrl(modelConfig.getBaseUrl());
                properties.setCompletionsPath(modelConfig.getCompletionsPath());
                properties.setApiKey(modelConfig.getApiKey());
                // 选项配置
                OpenAiChatOptions options = OpenAiChatOptions.builder()
                        .model(modelConfig.getModelVersion())
                        .temperature(modelConfig.getTemperature())
                        .build();
                // 模型工厂
                ModelFactory.putModel(properties,options);
            }
        }
    }
}
</code></pre>
<p>简单的测试一下模型动态选择的封装。</p>
<pre><code class="language-java">@RestController
public class TestModelWeb {
    @GetMapping(value = "/completion")
    public String completion() {
        String message = "你是哪个公司开发的？当前使用的是哪个版本的模型？";
        return  ModelFactory.getModel("qwen").prompt(new Prompt(message)).call().content()
                +"&lt;br/&gt;&lt;br/&gt;"+
                ModelFactory.getModel("hunyuan").prompt(new Prompt(message)).call().content();
    }
}
</code></pre>
<h1 id="四最后总结">四、最后总结</h1>
<p>产品在完成大模型集成后，测试具体的业务场景时，可以先不考虑自定义的干预策略，就看一看大模型能发挥到什么程度。</p>
<p>如果效果不符合预期，再逐步的加入自定义的策略，直到产品和大模型这个"产品"形成默契的配合，建议测试过程放在模型官网的对话框进行。</p>
<p>毕竟独立开发者的收入，已经独立了。</p>
<pre><code class="language-plain">文档仓库：
https://gitee.com/cicadasmile/butte-java-note

源码仓库：
https://gitee.com/cicadasmile/butte-mound
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    
互联网十年民工，现在转身独立开发者。<b> | </b><a href="https://mp.weixin.qq.com/s/F7JBEFCeZgdYakgRxNb35w"> 公众号-主页 </a> <b> | </b> <a href="https://www.xiaohongshu.com/user/profile/67fa1b1700000000080140b8"> 小红书-主页 </a> <b> | </b> <a href="https://www.douyin.com/user/MS4wLjABAAAAQO0vbcMnMeUE8OLGtmd9dbh-5dPcPL7_o3v8M0U_BwBUoBZIz2suph5gsDf63Okk"> 抖音-主页 </a> <b> | </b> <a href="https://gitee.com/cicadasmile">Git仓库-主页</a> <b> | </b>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-04 10:06">2025-07-04 10:05</span>&nbsp;
<a href="https://www.cnblogs.com/cicada-smile">七号楼</a>&nbsp;
阅读(<span id="post_view_count">247</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18965103);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18965103', targetLink: 'https://www.cnblogs.com/cicada-smile/p/18965103', title: 'SpringBoot3集成多款主流大模型' })">举报</a>
</div>
        