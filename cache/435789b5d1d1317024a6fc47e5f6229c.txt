
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/diamondhusky/p/18650702" title="发布于 2025-01-03 18:12">
    <span role="heading" aria-level="2">继续聊一聊sqlsugar的一个机制问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>几个月前换了新工作，从技术负责人的岗位上下来，继续回归码农写代码，在新公司中，我不是技术负责人，没太多的话语权。</p>
<p>公司这边项目统一都是使用了SqlSguar这个orm，我也跟着使用了几个月，期间碰见了不少奇奇怪怪的问题，甚至之前特意写文章“骂”过，但是今天要聊的这个问题，至今快月余，依旧让我记忆深刻，以至于控制不住自己要再写一篇文章来聊聊这件事。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="准备工作">准备工作</h1>
<p>我准备了这样一张表来进行模拟：</p>
<p><img src="https://img2024.cnblogs.com/blog/1553709/202501/1553709-20250103143722655-227922124.png" alt="image" loading="lazy"></p>
<p>显而易见，address里面存储的是一个json对象。 这张表对应的实体是这样的：</p>
<pre><code>
    [SugarTable("students", "学生表")]
    public class Student
    {
        [SugarColumn(ColumnName = "id", IsPrimaryKey = true, IsIdentity = true)]
        public int Id { get; set; }

        [SugarColumn(ColumnName = "name")]
        public string Name { get; set; }

        [SugarColumn(ColumnName = "address", IsJson = true)]
        public Address Address { get; set; }
    }

    public class Address
    {
        public string Province { get; set; }

        public string City { get; set; }

        public string Street { get; set; }
    }
</code></pre>
<p>只是作演示使用，所以就没有按照规范写注释，请大家谅解。</p>
<p>有一个Dto对象：</p>
<pre><code> public class StudentDto
 {
     public int StudentId { get; set; }

     public string StudentName { get; set; }

     public Address StudentAddress { get; set; }
 }
</code></pre>
<h1 id="起因">起因</h1>
<p>为了模拟我当时的情况，准备了下面几行代码：</p>
<pre><code>  var entity= client.Queryable&lt;Student&gt;().Where(t=&gt;t.Name=="张三").First();

  Console.WriteLine($"entity:{JsonConvert.SerializeObject(entity)}");

  var dto = client.Queryable&lt;Student&gt;().Where(t =&gt; t.Name == "张三").Select(t =&gt; new StudentDto()
  {
      StudentId = t.Id,
      StudentName = t.Name,
      StudentAddress = t.Address
  }).First();

  Console.WriteLine($"dto:{JsonConvert.SerializeObject(dto)}");
</code></pre>
<p>然后得到了下面的输出结果：</p>
<pre><code>entity:{"Id":1,"Name":"张三","Address":{"Province":"湖北省","City":"武汉市","Street":"发展大道234号"}}

dto:{"StudentId":1,"StudentName":"张三","StudentAddress":null}
</code></pre>
<p><strong>Why？？？？ 为什么 <code>dto</code>的<code>StudentAddress</code>的值会是<code>NULL</code>？？？</strong></p>
<p>我尝试了半个多小时，依旧没有解决这个问题，也没找出原因，最后在万能的群友的帮助下，我找到了解决办法：<strong><font color="red">在dto的StudentAddress属性上，加上这样一个特性标记：[SugarColumn(IsJson = true)]</font></strong></p>
<pre><code> public class StudentDto
 {
     public int StudentId { get; set; }

     public string StudentName { get; set; }

     [SugarColumn(IsJson = true)]
     public Address StudentAddress { get; set; }
 }
</code></pre>
<p>我再试了一下，问题解决：</p>
<pre><code>entity:{"Id":1,"Name":"张三","Address":{"Province":"湖北省","City":"武汉市","Street":"发展大道234号"}}

dto:{"StudentId":1,"StudentName":"张三","StudentAddress":{"Province":"湖北省","City":"武汉市","Street":"发展大道234号"}}
</code></pre>
<h1 id="问题真的解决了吗">问题真的解决了吗？</h1>
<p>说实话，这个解决方案我是不太满意的。<br>
首先，<code>StudentDto</code>是一个dto对象，它的属性为何非要被打上<code>SugarColumn</code>特性标记？它又不是数据表对应的实体对象。<br>
其次，现在的开发框架体系，无论是多层架构，还是基于DDD模式的那一套，dto对象通常都是单独的一层,(一般命名为 shard或者contract等)，这一层不会去引用基础设施层或者是持久化层(Repository)，那该如何给dto打上<code>SugarColumn</code>特性标记？强行引用，就破坏了项目的整体引用结构。我不知道你们是不是能接受，反正我这个中度处女座强迫症洁癖症患者是真接受不了。<br>
最后，<strong>这种解决方式，真的很违反直觉</strong>。</p>
<h1 id="刨根问底">刨根问底</h1>
<blockquote>
<p>我打算空闲了，去研究研究Sqlsugar的源码，看看有没有办法优雅的解决掉这个问题。</p>
</blockquote>
<p>后面我在群里吹下了牛逼，为了不被打脸，我花了点时间研究源码，好戏正式开始：</p>
<blockquote>
<p>调试过程较为繁琐，这里就只展示结果以及部分关键点</p>
</blockquote>
<p>开始之前，先把DTO恢复到最开始的样子：</p>
<pre><code>public class StudentDto
{
    public int StudentId { get; set; }

    public string StudentName { get; set; }

    public Address StudentAddress { get; set; }
}
</code></pre>
<h2 id="1釜底抽薪先找到最后赋值的地方看看是根据如何进行的数据绑定">1.釜底抽薪，先找到最后赋值的地方，看看是根据如何进行的数据绑定</h2>
<p>经过繁琐的调试，最后找到了关键的地方，在<code>IDataReaderEntityBuilder</code>文件的第300行，<code>CreateBuilder</code>方法里面，找到了数据行的处理逻辑。(该文件在 <code>SqlSugar</code>项目的<code>Abstract\DbBindProvider</code>文件夹内)</p>
<p><img src="https://img2024.cnblogs.com/blog/1553709/202501/1553709-20250103155529651-1029871737.png" alt="image" loading="lazy"></p>
<p>上图有一个非常重要的信息：<br>
<font color="red" size="4"> sqlguar将dto当作了跟数据表对应的实体类型，并且将其属性包装成了<code>EntityColumnInfo</code>类型。</font><br>
上图中那个foreach 循环的源码如下：</p>
<pre><code> foreach (var columnInfo in columnInfos)
 {
     string fileName = columnInfo.DbColumnName ?? columnInfo.PropertyName;
     if (columnInfo.IsIgnore &amp;&amp; !this.ReaderKeys.Any(it =&gt; it.Equals(fileName, StringComparison.CurrentCultureIgnoreCase)))
     {
         continue;
     }
     else if (columnInfo.ForOwnsOnePropertyInfo!=null) 
     {
         continue;
     }
     if (columnInfo != null &amp;&amp; columnInfo.PropertyInfo.GetSetMethod(true) != null)
     {
         var isGemo = columnInfo.PropertyInfo?.PropertyType?.FullName=="NetTopologySuite.Geometries.Geometry";
         if (!isGemo&amp;&amp;columnInfo.PropertyInfo.PropertyType.IsClass() &amp;&amp; columnInfo.PropertyInfo.PropertyType != UtilConstants.ByteArrayType &amp;&amp; columnInfo.PropertyInfo.PropertyType != UtilConstants.ObjType)
         {
             if (this.ReaderKeys.Any(it =&gt; it.Equals(fileName, StringComparison.CurrentCultureIgnoreCase)))
             {
                 BindClass(generator, result, columnInfo, ReaderKeys.First(it =&gt; it.Equals(fileName, StringComparison.CurrentCultureIgnoreCase)));
             }
             else if (this.ReaderKeys.Any(it =&gt; it.Equals(columnInfo.PropertyName, StringComparison.CurrentCultureIgnoreCase)))
             {
                 BindClass(generator, result, columnInfo, ReaderKeys.First(it =&gt; it.Equals(columnInfo.PropertyName, StringComparison.CurrentCultureIgnoreCase)));
             }
         }
         else if (!isGemo &amp;&amp; columnInfo.IsJson &amp;&amp; columnInfo.PropertyInfo.PropertyType != UtilConstants.StringType)
         {   //json is struct
             if (this.ReaderKeys.Any(it =&gt; it.Equals(fileName, StringComparison.CurrentCultureIgnoreCase)))
             {
                 BindClass(generator, result, columnInfo, ReaderKeys.First(it =&gt; it.Equals(fileName, StringComparison.CurrentCultureIgnoreCase)));
             }
         }
         else
         {
             if (this.ReaderKeys.Any(it =&gt; it.Equals(fileName, StringComparison.CurrentCultureIgnoreCase)))
             {
                 BindField(generator, result, columnInfo, ReaderKeys.First(it =&gt; it.Equals(fileName, StringComparison.CurrentCultureIgnoreCase)));
             }
             else if (this.ReaderKeys.Any(it =&gt; it.Equals(columnInfo.PropertyName, StringComparison.CurrentCultureIgnoreCase)))
             {
                 BindField(generator, result, columnInfo, ReaderKeys.First(it =&gt; it.Equals(columnInfo.PropertyName, StringComparison.CurrentCultureIgnoreCase)));
             }
         }
     }
 }
</code></pre>
<p>通过这个方法可以看到，依据类型的判断，以及<code>columnInfo</code>的相关属性判断，来决定究竟是走<code>BindClass()</code>方法还是<code>BindField()</code>。经过调试，最终发现<code>StudentAddress</code>列进入了如下图所示的逻辑分支，并且调用了<code>BindClass()</code>方法。<br>
<img src="https://img2024.cnblogs.com/blog/1553709/202501/1553709-20250103161151185-1454791725.png" alt="image" loading="lazy"><br>
继续看看<code>BindClass()</code>方法的代码：</p>
<pre><code>private void BindClass(ILGenerator generator, LocalBuilder result, EntityColumnInfo columnInfo, string fieldName)
{

    if (columnInfo.SqlParameterDbType is Type)
    {
        BindCustomFunc(generator, result, columnInfo, fieldName);
        return;
    }

    if (columnInfo.IsJson)
    {
        MethodInfo jsonMethod = getJson.MakeGenericMethod(columnInfo.PropertyInfo.PropertyType);
        int i = DataRecord.GetOrdinal(fieldName);
        Label endIfLabel = generator.DefineLabel();
        generator.Emit(OpCodes.Ldarg_0);
        generator.Emit(OpCodes.Ldc_I4, i);
        generator.Emit(OpCodes.Callvirt, isDBNullMethod);
        generator.Emit(OpCodes.Brtrue, endIfLabel);
        generator.Emit(OpCodes.Ldloc, result);
        generator.Emit(OpCodes.Ldarg_0);
        generator.Emit(OpCodes.Ldc_I4, i);
        generator.Emit(OpCodes.Call, jsonMethod);
        generator.Emit(OpCodes.Callvirt, columnInfo.PropertyInfo.GetSetMethod(true));
        generator.MarkLabel(endIfLabel);
    }
    if (columnInfo.IsArray)
    {
        MethodInfo arrayMehtod = getArray.MakeGenericMethod(columnInfo.PropertyInfo.PropertyType);
        int i = DataRecord.GetOrdinal(fieldName);
        Label endIfLabel = generator.DefineLabel();
        generator.Emit(OpCodes.Ldarg_0);
        generator.Emit(OpCodes.Ldc_I4, i);
        generator.Emit(OpCodes.Callvirt, isDBNullMethod);
        generator.Emit(OpCodes.Brtrue, endIfLabel);
        generator.Emit(OpCodes.Ldloc, result);
        generator.Emit(OpCodes.Ldarg_0);
        generator.Emit(OpCodes.Ldc_I4, i);
        generator.Emit(OpCodes.Call, arrayMehtod);
        generator.Emit(OpCodes.Callvirt, columnInfo.PropertyInfo.GetSetMethod(true));
        generator.MarkLabel(endIfLabel);
    }
    else if (columnInfo.UnderType == typeof(XElement))
    {
        int i = DataRecord.GetOrdinal(fieldName);
        Label endIfLabel = generator.DefineLabel();
        generator.Emit(OpCodes.Ldarg_0);
        generator.Emit(OpCodes.Ldc_I4, i);
        generator.Emit(OpCodes.Callvirt, isDBNullMethod);
        generator.Emit(OpCodes.Brtrue, endIfLabel);
        generator.Emit(OpCodes.Ldloc, result);
        generator.Emit(OpCodes.Ldarg_0);
        generator.Emit(OpCodes.Ldc_I4, i);
        BindMethod(generator, columnInfo, i);
        generator.Emit(OpCodes.Callvirt, columnInfo.PropertyInfo.GetSetMethod(true));
        generator.MarkLabel(endIfLabel);
    }
}
</code></pre>
<p>这个方法就非常的直白明了了：<font color="red"> 就是根据<code>columnInfo</code>的几个属性进行判断，来决定使用不同的数据绑定方式。</font> ，而且也不难看出，如果<code>columnInfo.IsJson==true</code>，那么应该就能实现我要效果。</p>
<h2 id="2看见曙光直接釜底抽薪">2.看见曙光，直接釜底抽薪</h2>
<p>总结一下上面的结论：</p>
<ol>
<li>sqlguar将dto当作了跟数据表对应的实体类型，并且将其属性包装成了<code>EntityColumnInfo</code>类型。</li>
<li>根据<code>columnInfo</code>的几个属性进行判断，来决定使用不同的数据绑定方式。</li>
</ol>
<p>所以不难猜出，使用<code>[SugarColumn(IsJson = true)]</code>对dto的属性进行修饰，最终应该就是用在了<code>BindClass()</code>方法里的<code>if (columnInfo.IsJson)</code>判断上，根据这个决定数据绑定方式。</p>
<p>那么，做一个大胆的假设：<font color="red">如果不使用<code>[SugarColumn(IsJson = true)]</code>,但是想办法在让它的<code>IsJson</code>属性变成true，问题是不是就完美解决了？</font></p>
<p>说干就干， 要给其赋值，首先要明白将dto的属性包装成<code>EntityColumnInfo</code>究竟发生在哪，它的<code>IsJson</code>属性又是如何确定值得。<br>
于是又进入了漫长得源码调试阶段。省略其中的繁琐，我们直接看关键部分：</p>
<p><img src="https://img2024.cnblogs.com/blog/1553709/202501/1553709-20250103173614448-1068865560.png" alt="image" loading="lazy"></p>
<p>这个方法，核心就是将dto类，包裹成了<code>EntityInfo</code>类，并且在最下方的<code>SetColumns(result)</code>方法，对<code>column</code>进行了设置。继续去看这个方法的代码：</p>
<pre><code>private void SetColumns(EntityInfo result)
{
    foreach (var property in result.Type.GetProperties())
    {
        EntityColumnInfo column = new EntityColumnInfo();

        //省略部分代码

        var sugarColumn = property.GetCustomAttributes(typeof(SugarColumn), true)
        .Where(it =&gt; it is SugarColumn)
        .Select(it =&gt; (SugarColumn)it)
        .FirstOrDefault();
         //省略部分代码
        if (sugarColumn?.IsOwnsOne==true)
        {
            SetValueObjectColumns(result, property, column);
        }
        if (sugarColumn.IsNullOrEmpty())
        {
            column.DbColumnName = property.Name;
        }
        else
        {
            if (sugarColumn.IsIgnore == false)
            {
                //这里就是对各种属性进行赋值，省略部分代码

                column.IsJson = sugarColumn.IsJson;

               //省略
            }
            else
            {
               //。。。
            }
        }
        result.Columns.Add(column);
    }
}
</code></pre>
<p>从上述代码可以看出，这里就是尝试找到<code>result</code>的<code>SugarColumn</code>特性，并且给<code>IsJson</code>等属性赋值。</p>
<blockquote>
<p>上述代码在<code>EntityMaintenance</code>类里面，该文件在该文件在 <code>SqlSugar</code>项目的<code>Abstract\EntityMaintenance</code>文件夹内</p>
</blockquote>
<h2 id="3束手无策">3.束手无策</h2>
<p>事情到这里，就已经结束了，因为我找不到任何办法，可以绕过SugarColumn特性，而将column的IsJson值设置为true。<br>
而这里的代码，应该是属于整个框架里面的核心代码，其外层调用方法的<code>99+</code>的引用次数，更是让我不敢妄动。</p>
<p>我也考虑过修改数据绑定的那块逻辑，看看能否不通过判断<code>columnInfo.IsJson</code>也能实现。但是很可惜，也失败了，因为这里要考量的更多，不光是简单的查询，也要考虑多表join，甚至select时多个 对象属性查询，匿名对象(Select(x=&gt;new{}))，sqlFunc实现的子查询等N多种复杂情况。</p>
<h1 id="反思">反思</h1>
<p>将查询的对象类包装成<code>EntityInfo</code>似乎是sqlsugar的框架核心实现，这也导致了如果在Select时想要实现 复杂对象 属性的数据绑定，似乎只能依靠<code>SugarColumn</code>。</p>
<p>但是我真不敢苟同这样的设计，可是我水平有限，目前确实搞不定这个问题。</p>
<p>朋友们都说，dto上打一个特性标记就能解决了，没必要太上纲上线，框架层次引用的清洁性，真的有那么重要吗？</p>
<p>这个问题，我留给大家回答吧。</p>
<p>最后贴一段代码，调试源码的时候发现的，把我看乐了。</p>
<p><img src="https://img2024.cnblogs.com/blog/1553709/202501/1553709-20250103180208763-959538480.png" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="4.6910233318981485" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-03 18:12">2025-01-03 18:12</span>&nbsp;
<a href="https://www.cnblogs.com/diamondhusky">呆萌哈士奇</a>&nbsp;
阅读(<span id="post_view_count">143</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18650702" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18650702);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18650702', targetLink: 'https://www.cnblogs.com/diamondhusky/p/18650702', title: '继续聊一聊sqlsugar的一个机制问题' })">举报</a>
</div>
        