
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipsoft/p/19051313" title="发布于 2025-08-25 14:26">
    <span role="heading" aria-level="2">Vue  element admin 浏览器本地存储 localStorage、useStorage</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#localstorage-与-usestorage-的区别" rel="noopener nofollow">localStorage 与 useStorage 的区别</a><ul><li><a href="#localstorage原生-api" rel="noopener nofollow">localStorage（原生 API）</a></li><li><a href="#usestoragevueuse-工具函数" rel="noopener nofollow">useStorage（VueUse 工具函数）</a></li><li><a href="#对比示例" rel="noopener nofollow">对比示例</a></li><li><a href="#总结" rel="noopener nofollow">总结</a></li></ul></li><li><a href="#删除-userinfo-的-key-方法" rel="noopener nofollow">删除 userInfo 的 key 方法</a><ul><li><a href="#1-使用-usestorage-的推荐方式" rel="noopener nofollow">1. 使用 <code>useStorage</code> 的推荐方式</a></li><li><a href="#2-手动删除-localstorage-的-key" rel="noopener nofollow">2. 手动删除 localStorage 的 key</a></li><li><a href="#3-完整的清除方案" rel="noopener nofollow">3. 完整的清除方案</a></li><li><a href="#4-验证-key-是否被删除" rel="noopener nofollow">4. 验证 key 是否被删除</a></li><li><a href="#推荐方案" rel="noopener nofollow">推荐方案</a></li></ul></li></ul></div><br>
在你的代码中，<strong><code>userInfo</code> 的浏览器本地存储是在 <code>defineStore("user", () =&gt; { ... })</code> 函数内部的第一行实现的</strong>：<p></p>
<p>auth.ts</p>
<pre><code class="language-js">// 访问 token 缓存的 key
const ACCESS_TOKEN_KEY = "access_token";
// 刷新 token 缓存的 key
const REFRESH_TOKEN_KEY = "refresh_token";

function getAccessToken(): string {
  return localStorage.getItem(ACCESS_TOKEN_KEY) || "";
}

function setAccessToken(token: string) {
  localStorage.setItem(ACCESS_TOKEN_KEY, token);
}

function getRefreshToken(): string {
  return localStorage.getItem(REFRESH_TOKEN_KEY) || "";
}

function setRefreshToken(token: string) {
  localStorage.setItem(REFRESH_TOKEN_KEY, token);
}

function clearToken() {
  localStorage.removeItem(ACCESS_TOKEN_KEY);
  localStorage.removeItem(REFRESH_TOKEN_KEY);
}

export { getAccessToken, setAccessToken, clearToken, getRefreshToken, setRefreshToken };

</code></pre>
<pre><code class="language-js">
import { setAccessToken, setRefreshToken, getRefreshToken, clearToken } from "@/utils/auth";

export const useUserStore = defineStore("user", () =&gt; {
  const userInfo = useStorage&lt;UserInfo&gt;("userInfo", {} as UserInfo);
  const roleList = useStorage&lt;RoleInfo[]&gt;("roleList", []);
  
  
  /**
   * 登录
   *
   * @param {LoginFormData}
   * @returns
   */
  function login(LoginFormData: LoginFormData) {
    return new Promise&lt;void&gt;((resolve, reject) =&gt; {
      console.log("modules.user.login");
      AuthAPI.login(LoginFormData)
        .then((data) =&gt; {
          const { accessToken, user } = data;
          setAccessToken(accessToken);
          if (User.RoleList &amp;&amp; Array.isArray(user.RoleList)) {
            roleList.value = user.RoleList;
          } else {
            roleList.value = []; // 确保总是数组
            console.warn("RoleList is not an array or is undefined");
          }
          resolve();
        })
        .catch((error) =&gt; {
          reject(error);
        });
    });
  }
  
    /**
   * 获取用户信息
   *
   * @returns {UserInfo} 用户信息
   */
  function getUserInfo() {
    return new Promise&lt;UserInfo&gt;((resolve, reject) =&gt; {
      UserAPI.getInfo()
        .then((data) =&gt; {
          if (!data) {
            reject("Verification failed, please Login again.");
            return;
          }
          Object.assign(userInfo.value, { ...data });
          resolve(data);
        })
        .catch((error) =&gt; {
          reject(error);
        });
    });
  }
</code></pre>
<p>这行代码是关键，</p>
<pre><code class="language-typescript">const userInfo = useStorage&lt;UserInfo&gt;("userInfo", {} as UserInfo);
</code></pre>
<p>它使用了 <code>useStorage</code> 函数（通常来自 <code>@vueuse/core</code> 或类似的工具库）来创建一个响应式的引用，该引用会自动将数据持久化到浏览器的本地存储中。</p>
<p><strong>具体分析：</strong></p>
<ol>
<li>
<p><strong>存储时机</strong>：当调用 <code>getUserInfo()</code> 方法时，通过这行代码：</p>
<pre><code class="language-typescript">Object.assign(userInfo.value, { ...data });
</code></pre>
<p>将获取到的用户数据赋值给 <code>userInfo.value</code>，此时 <code>useStorage</code> 会自动将这些数据保存到 localStorage。</p>
</li>
<li>
<p><strong>存储位置</strong>：数据会被存储在浏览器的 localStorage 中，键名为 <code>"userInfo"</code>。</p>
</li>
<li>
<p><strong>自动持久化</strong>：<code>useStorage</code> 会自动处理：</p>
<ul>
<li>初始时从 localStorage 读取数据</li>
<li>数据变更时自动写入 localStorage</li>
<li>页面刷新后数据仍然保持</li>
</ul>
</li>
</ol>
<p><strong>验证方式</strong>：<br>
你可以在浏览器开发者工具中查看：</p>
<ol>
<li>打开「Application」标签页</li>
<li>选择「Local Storage」</li>
<li>查看你的网站域名下是否存在 <code>userInfo</code> 这个键，其值就是序列化的用户信息</li>
</ol>
<p><strong>注意</strong>：<code>clearUserData()</code> 函数中没有直接清除 <code>userInfo</code>，你可能需要在其中添加：</p>
<pre><code class="language-typescript">userInfo.value = {} as UserInfo;     // 保持响应式一致性
roleList.value = [] as RoleInfo[];   // 保持响应式一致性
</code></pre>
<p>来确保用户登出时本地存储的用户信息也被清除。</p>
<h1 id="localstorage-与-usestorage-的区别">localStorage 与 useStorage 的区别</h1>
<h2 id="localstorage原生-api">localStorage（原生 API）</h2>
<p><strong>直接操作本地存储的原生浏览器 API</strong>：</p>
<pre><code class="language-javascript">// 存储数据
localStorage.setItem('userInfo', JSON.stringify(userData));

// 读取数据
const data = JSON.parse(localStorage.getItem('userInfo') || '{}');

// 删除数据
localStorage.removeItem('userInfo');

// 清空所有
localStorage.clear();
</code></pre>
<p><strong>特点</strong>：</p>
<ul>
<li>✅ 浏览器原生支持，无需额外依赖</li>
<li>❌ 需要手动序列化/反序列化（JSON.stringify/JSON.parse）</li>
<li>❌ 不是响应式的，数据变更不会自动更新界面</li>
<li>❌ 需要手动处理存储和读取逻辑</li>
</ul>
<h2 id="usestoragevueuse-工具函数">useStorage（VueUse 工具函数）</h2>
<p><strong>基于 localStorage 封装的响应式工具函数</strong>：</p>
<pre><code class="language-typescript">import { useStorage } from '@vueuse/core';

// 自动处理序列化和响应式
const userInfo = useStorage('userInfo', {} as UserInfo);

// 直接赋值，自动保存到 localStorage
userInfo.value = newData;

// 读取数据，直接使用即可
console.log(userInfo.value);
</code></pre>
<p><strong>特点</strong>：</p>
<ul>
<li>✅ 自动序列化/反序列化</li>
<li>✅ 响应式，数据变更自动更新界面</li>
<li>✅ 与 Vue 响应式系统无缝集成</li>
<li>✅ 类型安全（TypeScript 支持）</li>
<li>❌ 需要安装 @vueuse/core 依赖</li>
</ul>
<h2 id="对比示例">对比示例</h2>
<p><strong>使用 localStorage</strong>：</p>
<pre><code class="language-javascript">// 需要手动处理
const user = ref(JSON.parse(localStorage.getItem('userInfo') || '{}'));

function updateUser(newData) {
  user.value = newData;
  localStorage.setItem('userInfo', JSON.stringify(newData)); // 手动保存
}
</code></pre>
<p><strong>使用 useStorage</strong>：</p>
<pre><code class="language-typescript">// 自动处理一切
const user = useStorage('userInfo', {});

function updateUser(newData) {
  user.value = newData; // 自动保存到 localStorage
}
</code></pre>
<h2 id="总结">总结</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>localStorage</th>
<th>useStorage</th>
</tr>
</thead>
<tbody>
<tr>
<td>响应式</td>
<td>❌ 否</td>
<td>✅ 是</td>
</tr>
<tr>
<td>自动序列化</td>
<td>❌ 需要手动</td>
<td>✅ 自动</td>
</tr>
<tr>
<td>Vue 集成</td>
<td>❌ 需要封装</td>
<td>✅ 无缝集成</td>
</tr>
<tr>
<td>类型安全</td>
<td>❌ 有限</td>
<td>✅ 完整TS支持</td>
</tr>
<tr>
<td>使用便捷性</td>
<td>❌ 较低</td>
<td>✅ 极高</td>
</tr>
</tbody>
</table>
<p><strong>推荐使用 useStorage</strong>，特别是在 Vue 项目中，它能极大简化本地存储的操作并提供更好的开发体验。</p>
<h1 id="删除-userinfo-的-key-方法">删除 userInfo 的 key 方法</h1>
<h2 id="1-使用-usestorage-的推荐方式">1. 使用 <code>useStorage</code> 的推荐方式</h2>
<p><strong>如果你使用的是 <code>@vueuse/core</code> 的 <code>useStorage</code></strong>：</p>
<pre><code class="language-typescript">import { useStorage } from '@vueuse/core';

// 清除数据并移除 key
function clearUserData() {
  return new Promise&lt;void&gt;((resolve) =&gt; {
    clearToken();
    usePermissionStoreHook().resetRouter();
    useDictStoreHook().clearDictionaryCache();
    //清除数据，key 还在
    userInfo.value = {} as UserInfo;
    // 推荐方式：直接设置为 null 或 undefined，useStorage 会自动移除 key
    userInfo.value = null as any;
    // 或者
    // userInfo.value = undefined as any;
    
    resolve();
  });
}
</code></pre>
<h2 id="2-手动删除-localstorage-的-key">2. 手动删除 localStorage 的 key</h2>
<pre><code class="language-typescript">function clearUserData() {
  return new Promise&lt;void&gt;((resolve) =&gt; {
    clearToken();
    usePermissionStoreHook().resetRouter();
    useDictStoreHook().clearDictionaryCache();
    
    // 方式1：直接操作 localStorage
    localStorage.removeItem('userInfo');
    
    // 方式2：如果还想保持响应式，需要重新赋值
    userInfo.value = {} as UserInfo;
    
    resolve();
  });
}
</code></pre>
<h2 id="3-完整的清除方案">3. 完整的清除方案</h2>
<pre><code class="language-typescript">/**
 * 清理用户数据（完全清除）
 */
function clearUserDataCompletely() {
  return new Promise&lt;void&gt;((resolve) =&gt; {
    clearToken();
    usePermissionStoreHook().resetRouter();
    useDictStoreHook().clearDictionaryCache();
    
    // 方案A：使用 localStorage.removeItem（推荐）
    localStorage.removeItem('userInfo');
    userInfo.value = {} as UserInfo; // 保持响应式一致性
    
    // 方案B：设置为 null/undefined（useStorage 会自动处理）
    // userInfo.value = null as any;
    
    resolve();
  });
}
</code></pre>
<h2 id="4-验证-key-是否被删除">4. 验证 key 是否被删除</h2>
<pre><code class="language-typescript">// 检查 key 是否存在的方法
function isUserInfoKeyExists(): boolean {
  return localStorage.getItem('userInfo') !== null;
}

// 使用示例
console.log('userInfo key exists:', isUserInfoKeyExists()); // false
</code></pre>
<h2 id="推荐方案">推荐方案</h2>
<p><strong>在你的 <code>clearUserData</code> 函数中这样实现</strong>：</p>
<pre><code class="language-typescript">function clearUserData() {
  return new Promise&lt;void&gt;((resolve) =&gt; {
    clearToken();
    usePermissionStoreHook().resetRouter();
    useDictStoreHook().clearDictionaryCache();
    
    // 同时操作 localStorage 和响应式变量
    localStorage.removeItem('userInfo'); // 删除 key
    userInfo.value = {} as UserInfo;     // 重置响应式变量
    
    resolve();
  });
}
</code></pre>
<p>这样就能确保：</p>
<ol>
<li>✅ localStorage 中的 <code>userInfo</code> key 被完全删除</li>
<li>✅ 响应式变量保持一致性</li>
<li>✅ 下次访问时不会读取到旧的缓存数据</li>
</ol>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/vipsoft/" target="_blank">VipSoft</a>  转载请注明原文链接：<a href="https://www.cnblogs.com/vipsoft/p/19051313" target="_blank">https://www.cnblogs.com/vipsoft/p/19051313</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-25 14:26">2025-08-25 14:26</span>&nbsp;
<a href="https://www.cnblogs.com/vipsoft">VipSoft</a>&nbsp;
阅读(<span id="post_view_count">77</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19051313);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19051313', targetLink: 'https://www.cnblogs.com/vipsoft/p/19051313', title: 'Vue  element admin 浏览器本地存储 localStorage、useStorage' })">举报</a>
</div>
        