
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18982777" title="发布于 2025-07-13 20:33">
    <span role="heading" aria-level="2">瞧瞧别人家的接口重试，那叫一个优雅！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>2025年某电商平台深夜故障，因<strong>重试策略不当</strong>导致银行退款接口被调用82次，引发<strong>重复退款126万元</strong>！</p>
<p>复盘发现：80%的开发者认为重试就是<code>for循环+Thread.sleep()</code>，却忽略了<strong>重试风暴</strong>、<strong>幂等性缺失</strong>、<strong>资源雪崩</strong>等致命问题。</p>
<p>这篇文章跟大家一起聊聊接口重试的8种常用方案，希望对你会有所帮助。</p>
<h2 id="一重试机制的原因">一、重试机制的原因</h2>
<h3 id="11-为什么需要重试">1.1 为什么需要重试？</h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250713203220400-1615670716.png" class="lazyload"></p>
<p>临时性故障占比超70%，合理重试可将成功率提升至99%以上。</p>
<h3 id="12-重试的三大陷阱">1.2 重试的三大陷阱</h3>
<ol>
<li><strong>重试风暴</strong>：固定间隔重试引发请求洪峰（如万次重试压垮服务）</li>
<li><strong>数据不一致</strong>：非幂等操作导致重复生效（如重复扣款）</li>
<li><strong>链路阻塞</strong>：长时重试耗尽线程资源（如数据库连接池枯竭）</li>
</ol>
<h2 id="二基础重试方案">二、基础重试方案</h2>
<h3 id="21-暴力轮回法青铜">2.1 暴力轮回法（青铜）</h3>
<p><strong>问题代码</strong>：</p>
<pre><code class="language-java">// 危险！切勿直接用于生产！
public void sendSms(String phone) {
    int retry = 0;
    while (retry &lt; 5) {
        try {
            smsClient.send(phone);
            break;
        } catch (Exception e) {
            retry++;
            Thread.sleep(1000); // 固定1秒间隔
        }
    }
}
</code></pre>
<p><strong>事故案例</strong>：某平台短信接口重试风暴，触发第三方熔断封禁。</p>
<p><strong>优化方向</strong>：增加随机抖动 + 异常过滤。</p>
<h3 id="22-spring-retry黄金">2.2 Spring Retry（黄金）</h3>
<p><strong>声明式注解控制重试</strong>：</p>
<pre><code class="language-java">@Retryable(
    value = {TimeoutException.class}, // 仅重试超时异常
    maxAttempts = 3,
    backoff = @Backoff(delay = 1000, multiplier = 2) // 指数退避：1s→2s→4s
)
public boolean queryOrder(String orderId) {
    return httpClient.get("/order/" + orderId);
}

@Recover // 兜底降级
public boolean fallback(TimeoutException e) {
    return false; 
}
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>注解驱动，业务零侵入</li>
<li>支持指数退避策略</li>
<li>无缝集成熔断器<code>@CircuitBreaker</code></li>
</ul>
<h2 id="三高阶重试方案">三、高阶重试方案</h2>
<h3 id="31-resilience4j白金">3.1 Resilience4j（白金）</h3>
<p><strong>应对高并发场景的重试+熔断组合拳</strong>：</p>
<pre><code class="language-java">// 重试配置：指数退避+随机抖动
RetryConfig retryConfig = RetryConfig.custom()
    .maxAttempts(3)
    .intervalFunction(IntervalFunction.ofExponentialRandomBackoff(
        1000L, 2.0, 0.3 // 初始1s，指数倍率2，抖动率30%
    ))
    .retryOnException(e -&gt; e instanceof TimeoutException)
    .build();

// 熔断配置：错误率超50%触发熔断
CircuitBreakerConfig cbConfig = CircuitBreakerConfig.custom()
    .slidingWindow(10, 10, COUNT_BASED) 
    .failureRateThreshold(50)
    .build();

// 组合装饰
Supplier&lt;Boolean&gt; supplier = () -&gt; paymentService.pay();
Supplier&lt;Boolean&gt; decorated = Decorators.ofSupplier(supplier)
    .withRetry(Retry.of("payment", retryConfig))
    .withCircuitBreaker(CircuitBreaker.of("payment", cbConfig))
    .decorate();
</code></pre>
<p><strong>效果</strong>：某支付系统接入后超时率下降60%，熔断触发率降低90%</p>
<h3 id="32-guava-retrying钻石">3.2 Guava-Retrying（钻石）</h3>
<p><strong>灵活定制复杂重试逻辑</strong>：</p>
<pre><code class="language-java">Retryer&lt;Boolean&gt; retryer = RetryerBuilder.&lt;Boolean&gt;newBuilder()
    .retryIfResult(Predicates.equalTo(false)) // 返回false重试
    .retryIfExceptionOfType(IOException.class)
    .withWaitStrategy(WaitStrategies.exponentialWait(1000, 30, TimeUnit.SECONDS))
    .withStopStrategy(StopStrategies.stopAfterAttempt(5))
    .build();

retryer.call(() -&gt; uploadService.upload(file)); // 执行
</code></pre>
<p><strong>核心能力</strong>：</p>
<ul>
<li>支持结果/异常双模式触发</li>
<li>提供7种等待策略（随机、指数、递增等）</li>
<li>可监听每次重试事件</li>
</ul>
<h2 id="四分布式重试方案">四、分布式重试方案</h2>
<h3 id="41-mq延时队列星耀ⅰ">4.1 MQ延时队列（星耀Ⅰ）</h3>
<p><strong>适用场景</strong>：异步解耦的高并发系统（如物流状态同步）<br>
<strong>架构原理</strong>：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250713203234749-465213653.png" class="lazyload"></p>
<p><strong>RocketMQ实现</strong>：</p>
<pre><code class="language-java">// 生产者发送延时消息
Message msg = new Message();
msg.setBody(orderData);
msg.setDelayTimeLevel(3); // RocketMQ预设10秒延迟
rocketMQTemplate.send(msg);

// 消费者
@RocketMQMessageListener(topic = "RETRY_TOPIC")
public class RetryConsumer {
    public void consume(Message msg) {
        try {
            process(msg);
        } catch (Exception e) {
            // 提升延迟级别重发
            msg.setDelayTimeLevel(5); 
            resend(msg);
        }
    }
}
</code></pre>
<p><strong>优势</strong>：</p>
<ul>
<li>重试与业务逻辑解耦</li>
<li>天然支持梯度延时</li>
<li>死信队列兜底人工处理</li>
</ul>
<h3 id="42-定时任务补偿星耀ⅱ">4.2 定时任务补偿（星耀Ⅱ）</h3>
<p><strong>适用场景</strong>：允许延迟的批处理任务（如文件导入）</p>
<pre><code class="language-java">@Scheduled(cron = "0 0/5 * * * ?") // 每5分钟执行
public void retryFailedTasks() {
    List&lt;FailedTask&gt; tasks = taskDao.findFailed(MAX_RETRY);
    tasks.forEach(task -&gt; {
        if (retry(task)) {
            task.markSuccess();
        } else {
            task.incrRetryCount();
        }
        taskDao.update(task);
    });
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>数据库记录失败任务</li>
<li>低峰期批量处理</li>
<li>独立线程池隔离资源</li>
</ul>
<h3 id="43-两阶段提交王者ⅰ">4.3 两阶段提交（王者Ⅰ）</h3>
<p><strong>金融级一致性保障（如转账）</strong>：</p>
<pre><code class="language-java">@Transactional
public void transfer(TransferRequest req) {
    // 阶段1：持久化操作流水
    TransferRecord record = recordDao.create(req, PENDING);
    
    // 阶段2：调用银行接口
    boolean success = bankClient.transfer(req);
    
    // 更新状态
    recordDao.updateStatus(record.getId(), success ? SUCCESS : FAILED);
    
    if (!success) {
        mqTemplate.send("TRANSFER_RETRY_QUEUE", req); // 触发异步重试
    }
}

// 补偿任务（扫描挂起流水）
@Scheduled(fixedRate = 30000)
public void compensate() {
    List&lt;TransferRecord&gt; pendings = recordDao.findPending(30);
    pendings.forEach(this::retryTransfer);
}
</code></pre>
<p><strong>核心思想</strong>：<strong>操作前先留痕</strong>，任何失败可追溯</p>
<h3 id="44-分布式锁重试王者ⅱ">4.4 分布式锁重试（王者Ⅱ）</h3>
<p><strong>防重复提交终极方案（如秒杀）</strong>：</p>
<pre><code class="language-java">public boolean retryWithLock(String key, int maxRetry) {
    String lockKey = "RETRY_LOCK:" + key;
    for (int i = 0; i &lt; maxRetry; i++) {
        if (redis.setIfAbsent(lockKey, "1", 30, SECONDS)) {
            try {
                return callApi(); // 持有锁时执行
            } finally {
                redis.delete(lockKey);
            }
        }
        Thread.sleep(1000 * (i + 1)); // 等待锁释放
    }
    return false;
}
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>多实例部署环境</li>
<li>高竞争资源访问</li>
<li>等幂性要求极高业务</li>
</ul>
<h2 id="五响应式重试spring-webflux方案">五、响应式重试：Spring WebFlux方案</h2>
<h3 id="51-响应式重试操作符">5.1 响应式重试操作符</h3>
<pre><code class="language-java">Mono&lt;String&gt; remoteCall = Mono.fromCallable(() -&gt; {
    if (Math.random() &gt; 0.5) throw new RuntimeException("模拟失败");
    return "Success";
});

remoteCall.retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
          .doBeforeRetry(signal -&gt; log.warn("第{}次重试", signal.totalRetries()))
          .subscribe();
</code></pre>
<p><strong>策略支持</strong>：</p>
<ul>
<li>指数退避：<code>Retry.backoff(maxAttempts, firstBackoff)</code></li>
<li>随机抖动：<code>.jitter(0.5)</code></li>
<li>条件过滤：<code>.filter(ex -&gt; ex instanceof TimeoutException)</code></li>
</ul>
<h2 id="六重试的避坑指南">六、重试的避坑指南</h2>
<h3 id="61-必须实现的三大防护">6.1 必须实现的三大防护</h3>
<table>
<thead>
<tr>
<th><strong>防护类型</strong></th>
<th><strong>目的</strong></th>
<th><strong>实现方案</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>幂等性防护</td>
<td>防止重复生效</td>
<td>唯一ID+状态机</td>
</tr>
<tr>
<td>重试风暴防护</td>
<td>避免洪峰冲击</td>
<td>指数退避+随机抖动</td>
</tr>
<tr>
<td>资源隔离</td>
<td>保护主链路资源</td>
<td>线程池隔离/熔断器</td>
</tr>
</tbody>
</table>
<h3 id="62-经典踩坑案例">6.2 经典踩坑案例</h3>
<ol>
<li>
<p><strong>坑1：无限制重试</strong><br>
→ 某系统因未设重试上限，线程池爆满导致集群雪崩<br>
<strong>解法</strong>：<code>maxAttempts=3</code> + 熔断降级</p>
</li>
<li>
<p><strong>坑2：忽略错误类型</strong><br>
→ 参数错误（4xx）被反复重试，放大无效流量<br>
<strong>解法</strong>：<code>retryOnException(e -&gt; e instanceof TimeoutException)</code></p>
</li>
<li>
<p><strong>坑3：上下文丢失</strong><br>
→ 异步重试后丢失用户会话信息<br>
<strong>解法</strong>：重试前快照关键上下文（如userId、requestId）</p>
</li>
</ol>
<h2 id="七方案选型参考图">七、方案选型参考图</h2>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2238006/202507/2238006-20250713203251863-1900094996.png" class="lazyload"></p>
<h2 id="总结">总结</h2>
<ol>
<li><strong>敬畏每一次重试</strong>：重试不是暴力补救，而是精密流量控制。</li>
<li><strong>面向失败设计</strong>：假设网络不可靠、服务会宕机、资源终将枯竭。</li>
<li><strong>分层防御体系</strong>：
<ul>
<li>代码层：幂等性 + 超时控制</li>
<li>框架层：退避策略 + 熔断降级</li>
<li>架构层：异步解耦 + 持久化补偿</li>
</ul>
</li>
<li><strong>没有银弹</strong>：秒杀场景用分布式锁，支付系统用两阶段提交，IoT设备用MQTT重试机制。</li>
</ol>
<blockquote>
<p>正如分布式系统大师Leslie Lamport所言：<strong>“重试是分布式系统的成人礼”</strong>。</p>
</blockquote>
<p>掌握这8种方案，你将拥有让系统“起死回生”的魔法！</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<p>本文收录于我的技术网站：<a href="http://www.susan.net.cn" target="_blank" rel="noopener nofollow">http://www.susan.net.cn</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-13 20:33">2025-07-13 20:33</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">632</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18982777);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18982777', targetLink: 'https://www.cnblogs.com/12lisu/p/18982777', title: '瞧瞧别人家的接口重试，那叫一个优雅！' })">举报</a>
</div>
        