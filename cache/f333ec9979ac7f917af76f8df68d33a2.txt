
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tianqing/p/18653870" title="发布于 2025-01-22 16:10">
    <span role="heading" aria-level="2">.NET 9 new features-C#13新的锁类型和语义</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>C# 13 中，引入了新的锁类型和语义，主要用于增强多线程编程中的同步机制。</p>
<p>传统上，C# 使用 <code>lock</code> 关键字与任意的 <code>object</code> 实例配合，实现线程间的互斥访问。然而，这种方式可能存在性能瓶颈和潜在的死锁风险。</p>
<p>为此，C# 13 在 .NET 9 中引入了新的锁类型 <code>System.Threading.Lock</code>，提供更高效和安全的线程同步机制。</p>
<p><code>System.Threading.Lock</code> 是一个专门设计用于线程同步的结构，提供了改进的 API，以实现更高效的线程同步操作。</p>
<p>例如，<code>Lock.EnterScope()</code> 方法可以进入一个独占作用域，从而替代传统的 <code>lock</code> 关键字。</p>
<h2>主要应用场景</h2>
<p>新的锁类型和语义主要适用于以下场景：</p>
<ol>
<li>
<p><strong>高性能要求的多线程应用</strong>：在需要频繁加锁和解锁的高并发环境中，<code>System.Threading.Lock</code> 提供了更高效的锁定机制，减少了上下文切换的开销。</p>
</li>
<li>
<p><strong>复杂的同步需求</strong>：对于需要精细控制锁定行为的应用，新的锁类型提供了更灵活的 API，可满足复杂的同步要求。</p>
</li>
<li>
<p><strong>避免死锁</strong>：通过新的锁语义，可以更容易地实现超时和取消等功能，降低死锁发生的可能性。</p>
</li>
</ol>
<h2>示例代码</h2>
<p>以下是使用 <code>System.Threading.Lock</code> 的示例代码，演示如何在多线程环境中安全地更新共享资源：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System;
</span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System.Threading;
</span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System.Threading.Tasks;

</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Account
{
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">decimal</span><span style="color: rgba(0, 0, 0, 1)"> _balance;
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> Lock _balanceLock = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Lock();

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> Account(<span style="color: rgba(0, 0, 255, 1)">decimal</span><span style="color: rgba(0, 0, 0, 1)"> initialBalance)
    {
        _balance </span>=<span style="color: rgba(0, 0, 0, 1)"> initialBalance;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> Debit(<span style="color: rgba(0, 0, 255, 1)">decimal</span><span style="color: rgba(0, 0, 0, 1)"> amount)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (amount &lt;= <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> ArgumentException(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Amount must be positive</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, nameof(amount));

        </span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> (_balanceLock.EnterScope())
        {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (_balance &lt;<span style="color: rgba(0, 0, 0, 1)"> amount)
                </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> InvalidOperationException(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Insufficient funds</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);

            _balance </span>-=<span style="color: rgba(0, 0, 0, 1)"> amount;
        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> Credit(<span style="color: rgba(0, 0, 255, 1)">decimal</span><span style="color: rgba(0, 0, 0, 1)"> amount)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (amount &lt;= <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> ArgumentException(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Amount must be positive</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, nameof(amount));

        </span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> (_balanceLock.EnterScope())
        {
            _balance </span>+=<span style="color: rgba(0, 0, 0, 1)"> amount;
        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">decimal</span><span style="color: rgba(0, 0, 0, 1)"> GetBalance()
    {
        </span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> (_balanceLock.EnterScope())
        {
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> _balance;
        }
    }
}

</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Program
{
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">async</span><span style="color: rgba(0, 0, 0, 1)"> Task Main()
    {
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> account = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Account(1000m);

        </span><span style="color: rgba(0, 0, 255, 1)">var</span> tasks = <span style="color: rgba(0, 0, 255, 1)">new</span> Task[<span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">];
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; tasks.Length; i++<span style="color: rgba(0, 0, 0, 1)">)
        {
            tasks[i] </span>= Task.Run(() =&gt;<span style="color: rgba(0, 0, 0, 1)">
            {
                </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> j = <span style="color: rgba(128, 0, 128, 1)">0</span>; j &lt; <span style="color: rgba(128, 0, 128, 1)">100</span>; j++<span style="color: rgba(0, 0, 0, 1)">)
                {
                    account.Credit(</span><span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">);
                    account.Debit(</span><span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">);
                }
            });
        }

        </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> Task.WhenAll(tasks);

        Console.WriteLine($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Final balance: {account.GetBalance()}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    }
}</span></pre>
</div>
<p>在上述代码中：</p>
<ul>
<li>
<p><strong><code>Account</code> 类</strong>：表示一个银行账户，包含借记、贷记和获取余额的方法。</p>
</li>
<li>
<p><strong><code>_balanceLock</code> 字段</strong>：使用新的 <code>Lock</code> 类型，确保对 <code>_balance</code> 字段的访问是线程安全的。</p>
</li>
<li>
<p><strong><code>EnterScope()</code> 方法</strong>：用于进入一个独占的锁定作用域，确保在该作用域内对共享资源的访问是互斥的。</p>
</li>
<li>
<p><strong><code>using</code> 语句</strong>：确保在作用域结束时自动释放锁，防止死锁的发生。</p>
</li>
</ul>
<p>通过使用新的 <code>System.Threading.Lock</code> 类型，代码实现了更高效的线程同步，避免了传统 <code>lock</code> 关键字可能带来的性能问题和潜在风险。</p>
<p><code>System.Threading.Lock</code> 的实现基于以下关键概念：</p>
<ol>
<li>
<p><strong>专用锁对象</strong>：<code>System.Threading.Lock</code> 是一个专门设计用于线程同步的类型，避免了使用通用对象作为锁的弊端。</p>
</li>
<li>
<p><strong>作用域管理</strong>：通过 <code>EnterScope()</code> 方法，进入一个锁定的作用域，确保在该作用域内对共享资源的访问是线程安全的。</p>
</li>
<li>
<p><strong>自动释放</strong>：利用 <code>using</code> 语句，确保在作用域结束时自动释放锁。</p>
</li>
</ol>
<p>&nbsp;</p>
<p>C# 13 中，引入了新的锁类型和语义，主要用于增强多线程编程中的同步机制。</p>
<p>&nbsp;</p>
<p>周国庆</p>
<p>2025/1/7</p>
<div>&nbsp;</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.006806690615740741" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-22 16:10">2025-01-22 16:10</span>&nbsp;
<a href="https://www.cnblogs.com/tianqing">Eric zhou</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18653870" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18653870);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18653870', targetLink: 'https://www.cnblogs.com/tianqing/p/18653870', title: '.NET 9 new features-C#13新的锁类型和语义' })">举报</a>
</div>
        