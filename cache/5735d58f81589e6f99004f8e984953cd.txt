
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wsg1100/p/18662571" title="发布于 2025-01-09 19:59">
    <span role="heading" aria-level="2">关于linux网桥(Linux Bridge)的一些个人记录</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1250138/202501/1250138-20250109214307063-1490570665.png" alt="关于linux网桥(Linux Bridge)的一些个人记录" class="desc_img">
        作为一个工业自动化行业常游走于各种 OT 网络和 IT 网络之间的码农，linux 网桥是常使用的工具之一，每每涉及Linux 网桥， 这些记忆性的操作都要现查，零散且麻烦，所以简单整理一下，主要方便自己查询，同时分享给大家参考，希望对你有所帮助。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-linux-bridge简述" rel="noopener nofollow">1. Linux Bridge简述</a></li><li><a href="#2-网桥创建" rel="noopener nofollow">2. 网桥创建</a><ul><li><a href="#创建" rel="noopener nofollow">创建</a></li><li><a href="#配置持久化" rel="noopener nofollow">配置持久化</a><ul><li><a href="#在debianubuntu系统上" rel="noopener nofollow">在Debian/Ubuntu系统上：</a></li><li><a href="#在centosrhel系统上" rel="noopener nofollow">在CentOS/RHEL系统上：</a></li></ul></li><li><a href="#启用和验证" rel="noopener nofollow">启用和验证</a></li></ul></li><li><a href="#3-关于linux网桥不转发ip帧的问题" rel="noopener nofollow">3. 关于linux网桥不转发ip帧的问题</a><ul><li><a href="#原因" rel="noopener nofollow">原因</a></li><li><a href="#解决" rel="noopener nofollow">解决</a></li><li><a href="#配置持久化-1" rel="noopener nofollow">配置持久化</a></li></ul></li><li><a href="#4-查看网桥学习交换表" rel="noopener nofollow">4. 查看网桥学习交换表</a><ul><li><a href="#手动添加或删除条目" rel="noopener nofollow">手动添加或删除条目</a><ul><li><a href="#添加条目" rel="noopener nofollow">添加条目</a></li><li><a href="#删除条目" rel="noopener nofollow">删除条目</a></li></ul></li><li><a href="#配置静态条目" rel="noopener nofollow">配置静态条目</a></li><li><a href="#设置条目的老化时间" rel="noopener nofollow">设置条目的老化时间</a></li><li><a href="#持久化配置" rel="noopener nofollow">持久化配置</a></li></ul></li><li><a href="#5-关于linux网桥stp" rel="noopener nofollow">5. 关于linux网桥STP</a></li><li><a href="#6-关于linux网桥不转发lldp帧" rel="noopener nofollow">6. 关于linux网桥不转发LLDP帧</a><ul><li><a href="#原因-1" rel="noopener nofollow">原因</a></li><li><a href="#解决-1" rel="noopener nofollow">解决</a></li><li><a href="#持久化配置-1" rel="noopener nofollow">持久化配置</a></li></ul></li><li><a href="#7-网桥vlan" rel="noopener nofollow">7. 网桥vlan</a><ul><li><a href="#配置持久化-2" rel="noopener nofollow">配置持久化</a></li></ul></li><li><a href="#8-其他" rel="noopener nofollow">8. 其他</a><ul><li><a href="#1-网卡混杂模式配置" rel="noopener nofollow">1. 网卡混杂模式配置</a></li><li><a href="#2-网卡接收多播包配置" rel="noopener nofollow">2. 网卡接收多播包配置</a></li><li><a href="#3-创建vlan接口" rel="noopener nofollow">3. 创建VLAN接口</a></li></ul></li><li><a href="#参考链接" rel="noopener nofollow">参考链接</a></li></ul></div><p></p>
<p>作为一个工业自动化行业，常游走于各种 OT 网络和 IT 网络之间的码农，linux 网桥是常使用的工具之一，每每涉及Linux 网桥， 这些记忆性的操作都要现查，零散且麻烦，所以简单整理一下，主要方便自己查询，同时分享给大家参考，希望对你有所帮助。</p>
<h2 id="1-linux-bridge简述">1. Linux Bridge简述</h2>
<p>有了虚拟网卡，我们很自然就会联想到让网卡接入到交换机里，来实现多个容器间的相互连接。而Linux Bridge就是 Linux 系统下的虚拟化交换机，虽然它是以“网桥”（Bridge）而不是“交换机”（Switch）为名，但在使用过程中，你会发现 Linux Bridge 看起来像交换机，功能使用起来像交换机、程序实现起来也像交换机，所以它实际就是一台虚拟交换机。</p>
<p>Linux Bridge 是在 Linux Kernel 2.2 版本开始提供的二层转发工具，由brctl命令创建和管理。Linux Bridge 创建以后，就能够接入任何位于二层的网络设备，无论是真实的物理设备（比如 eth0），还是虚拟的设备（比如 veth 或者 tap），都能与 Linux Bridge 配合工作。当有二层数据包（以太帧）从网卡进入 Linux Bridge，它就会根据数据包的类型和目标 MAC 地址，按照如下规则转发处理：</p>
<ul>
<li>
<p>如果数据包是广播帧，转发给所有接入网桥的设备。如果数据包是单播帧，且 MAC 地址在地址转发表中不存在，则洪泛（Flooding）给所有接入网桥的设备，并把响应设备的接口与 MAC 地址学习（MAC Learning）到自己的 MAC 地址转发表中。</p>
</li>
<li>
<p>如果数据包是单播帧，且 MAC 地址在地址转发表中已存在，则直接转发到地址表中指定的设备。</p>
</li>
<li>
<p>如果数据包是此前转发过的，又重新发回到此 Bridge，说明冗余链路产生了环路。由于以太帧不像 IP 报文那样有 TTL 来约束，所以一旦出现环路，如果没有额外措施来处理的话，就会永不停歇地转发下去。那么对于这种数据包，就需要交换机实现生成树协议（Spanning Tree Protocol，STP）来交换拓扑信息，生成唯一拓扑链路以切断环路。</p>
</li>
</ul>
<p>刚刚提到的这些名词，比如二层转发、泛洪、STP、MAC 学习、地址转发表，等等，都是物理交换机中已经非常成熟的概念了，它们在 Linux Bridge 中都有对应的实现，所以我才说，Linux Bridge 不仅用起来像交换机，实现起来也像交换机。</p>
<p>不过，它与普通的物理交换机也还是有一点差别的，<strong>普通交换机只会单纯地做二层转发，Linux Bridge 却还支持把发给它自身的数据包，接入到主机的三层协议栈中</strong>。</p>
<p>对于通过brctl命令显式接入网桥的设备，Linux Bridge 与物理交换机的转发行为是完全一致的，它也不允许给接入的设备设置 IP 地址，因为网桥是根据 MAC 地址做二层转发的，就算设置了三层的 IP 地址也没有意义。然而，Linux Bridge 与普通交换机的区别是，除了显式接入的设备外，它自己也无可分割地连接着一台有着完整网络协议栈的 Linux 主机，因为 Linux Bridge 本身肯定是在某台 Linux 主机上创建的，我们可以看作是 Linux Bridge 有一个与自己名字相同的隐藏端口，隐式地连接了创建它的那台 Linux 主机。</p>
<p>因此，Linux Bridge 允许给自己设置 IP 地址，这样就比普通交换机多出了一种特殊的转发情况：如果数据包的目的 MAC 地址为网桥本身，并且网桥设置了 IP 地址的话，那该数据包就会被认为是收到发往创建网桥那台主机的数据包，这个数据包将不会转发到任何设备，而是直接交给上层（三层）协议栈去处理。这时，网桥就取代了物理网卡 eth0 设备来对接协议栈，进行三层协议的处理。</p>
<p>涉及工具：</p>
<pre><code class="language-bash">sudo apt-get install bridge-utils iproute2   # 对于Debian/Ubuntu系统
</code></pre>
<p><img src="https://wsg-blogs-pic.oss-cn-beijing.aliyuncs.com/xenomai/isolated-bridge-v3.d0bfb82d28024d.svg" alt="" loading="lazy"></p>
<h2 id="2-网桥创建">2. 网桥创建</h2>
<h3 id="创建">创建</h3>
<p>创建网桥<code>br0</code> 并将<code>eth0</code>、<code>eth1 </code>添加到网桥:</p>
<pre><code class="language-shell"># 创建网桥 br0
sudo brctl addbr br0

# 添加物理接口 eth0 到网桥
sudo brctl addif br0 eth0
sudo brctl addif br0 eth1

# set up
sudo ifconfig br0 up
sudo ifconfig br0 eth0
sudo ifconfig br0 eth1
</code></pre>
<p>或者使用<code>ip</code>命令：</p>
<pre><code class="language-shell"># 使用 ip 命令
sudo ip link add name br0 type bridge
sudo ip link set dev br0 up
sudo ip link set dev eth0 master br0
sudo ip link set dev eth1 master br0
</code></pre>
<p>可以使用以下命令验证网桥和接口的配置：</p>
<pre><code class="language-bash"># 查看网桥信息
sudo bridge link show
sudo bridge fdb show br0

# 或者
sudo brctl show
</code></pre>
<h3 id="配置持久化">配置持久化</h3>
<p>为了在系统重启后保持网桥配置，你需要将相应的配置添加到网络配置文件中。</p>
<h4 id="在debianubuntu系统上">在Debian/Ubuntu系统上：</h4>
<p>编辑<code>/etc/network/interfaces</code>文件，添加如下内容：</p>
<pre><code class="language-bash">auto br0
iface br0 inet static
    address 192.168.1.100
    netmask 255.255.255.0
    bridge_ports eth0 eth1
    bridge_stp on
</code></pre>
<h4 id="在centosrhel系统上">在CentOS/RHEL系统上：</h4>
<p>创建或编辑<code>/etc/sysconfig/network-scripts/ifcfg-br0</code>文件，添加如下内容：</p>
<pre><code class="language-bash">DEVICE=br0
TYPE=Bridge
BOOTPROTO=static
IPADDR=192.168.1.100
NETMASK=255.255.255.0
ONBOOT=yes
STP=on

# 添加桥接的接口
BRIDGE_PORTS="eth0 eth1"
</code></pre>
<p>并确保<code>eth0</code>和<code>eth1</code>的配置文件中有以下内容：</p>
<pre><code class="language-bash"># /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
ONBOOT=yes
BRIDGE=br0

# /etc/sysconfig/network-scripts/ifcfg-eth1
DEVICE=eth1
ONBOOT=yes
BRIDGE=br0
</code></pre>
<h3 id="启用和验证">启用和验证</h3>
<p>重新启动网络服务以应用配置：</p>
<pre><code class="language-bash"># 对于Debian/Ubuntu
sudo systemctl restart networking

# 对于CentOS/RHEL
sudo systemctl restart network
</code></pre>
<p>通过检查网桥状态和接口状态来验证配置：</p>
<pre><code class="language-bash"># 查看网桥信息
sudo bridge link show
sudo bridge fdb show br0

# 或者
sudo brctl show
</code></pre>
<h2 id="3-关于linux网桥不转发ip帧的问题">3. 关于linux网桥不转发ip帧的问题</h2>
<h3 id="原因">原因</h3>
<p>Docker使用iptables时，默认将通过网桥的数据包发送到iptables进行处理，<code>sysctl</code>属性<code>net.bridge.bridge-nf-call-iptables=1</code>)。</p>
<p>这使得桥接帧(以太网，第2层)受制于iptables filter(IP,第3层)，导致网桥上的3层协议通信异常。</p>
<p>允许{ip、ip6、arp}表看到桥接通信可以使用位于<code>/proc/sys/net/bridge/</code>中的适当proc条目禁用或启用：</p>
<pre><code class="language-bash">bridge-nf-call-arptables
bridge-nf-call-iptables
bridge-nf-call-ip6tables
</code></pre>
<p>对应内核桥模块识别的3个“可调参数”的设置：</p>
<pre><code class="language-bash">net.bridge.bridge-nf-call-arptables
net.bridge.bridge-nf-call-ip6tables
net.bridge.bridge-nf-call-iptables
</code></pre>
<p>它们控制是否将通过网桥的数据包发送到iptables进行处理。在使用网桥将虚拟机连接到网络的情况下，通常这种处理是不希望的，因为它会导致guests流量被阻止，因为主机iptables规则只考虑主机本身，而不是guests。</p>
<p><strong>然而，内核中的桥模块将所有这三个值的默认值设置为“1”</strong>（“on”，即“<em>do</em> send the packets to iptables”），并且由于历史原因，内核维护人员拒绝更改此默认值（参见http://patchwork.ozlabs.org/patch/29319/）。</p>
<p>在内核拒绝了上述对编译默认值的更改之后，许多Linux发行版（包括Fedora，RHEL和CentOS）试图通过在/etc/sysctl.conf中添加行来修改编译到桥模块中的默认设置来解决这个问题：</p>
<pre><code class="language-bash">net.bridge.bridge-nf-call-arptables = 0
net.bridge.bridge-nf-call-ip6tables = 0
net.bridge.bridge-nf-call-iptables = 0
</code></pre>
<h3 id="解决">解决</h3>
<p>要禁用<code>br_netfilter's</code>代码对iptable的调用，如下所示：</p>
<pre><code class="language-bash">sudo sysctl -w net.bridge.bridge-nf-call-iptables=0
#或者
echo 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptables
</code></pre>
<p>内核(&gt;= 5.3)，在每个桥单独启用，而不是每个命名空间启用。</p>
<pre><code class="language-bash">sudo ip link set dev br0 type bridge nf_call_iptables 1
</code></pre>
<p>参考链接https://wiki.libvirt.org/Net.bridge.bridge-nf-call_and_sysctl.conf.html</p>
<h3 id="配置持久化-1">配置持久化</h3>
<p>除使用最原始的脚本配置外，可以使用udev+systemd，在桥的创建（加载模块）上重写udev规则来实现。</p>
<p>1)在文件<code>/etc/udev/rules.d/99-bridge.rules</code>中：</p>
<pre><code class="language-bash">ACTION=="add", SUBSYSTEM=="module", KERNEL=="br_netfilter", RUN+="/usr/lib/systemd/systemd-sysctl --prefix=net/bridge
</code></pre>
<p>2)在文件<code>/etc/sysctl.d/bridge.conf</code>中：</p>
<pre><code class="language-bash">net.bridge.bridge-nf-call-arptables = 0
net.bridge.bridge-nf-call-ip6tables = 0
net.bridge.bridge-nf-call-iptables = 0
</code></pre>
<p>3)重新引导或重新加载udev和sysctl。</p>
<h2 id="4-查看网桥学习交换表">4. 查看网桥学习交换表</h2>
<p>使用<code>bridge</code>命令查看网桥的学习交换表：</p>
<pre><code class="language-bash">bridge fdb show br br0
</code></pre>
<p>这个命令会展示网桥<code>br0</code>的当前学习交换表，包括各个MAC地址和它们对应的端口。</p>
<h3 id="手动添加或删除条目">手动添加或删除条目</h3>
<h4 id="添加条目">添加条目</h4>
<p>你可以手动添加一个MAC地址到网桥的学习交换表中。假设你要将MAC地址<code>00:11:22:33:44:55</code>绑定到接口<code>eth0</code>：</p>
<pre><code class="language-shell">sudo bridge fdb add 00:11:22:33:44:55 dev eth0 master br0
</code></pre>
<h4 id="删除条目">删除条目</h4>
<p>同样，你可以手动删除一个MAC地址条目：</p>
<pre><code class="language-shell">sudo bridge fdb del 00:11:22:33:44:55 dev eth0 master br0
</code></pre>
<h3 id="配置静态条目">配置静态条目</h3>
<p>你可以配置静态条目，这样这些MAC地址永远不会从网桥的学习交换表中删除：</p>
<pre><code class="language-shell">sudo bridge fdb add 00:11:22:33:44:55 dev eth0 
</code></pre>
<h3 id="设置条目的老化时间">设置条目的老化时间</h3>
<p>网桥会自动老化条目，并在一段时间不使用后删除它们。可以设置这个老化时间（以秒为单位）：</p>
<pre><code class="language-shell">sudo ip link set dev br0 type bridge ageing_time 300
</code></pre>
<p>这会将老化时间设置为300秒（5分钟）。</p>
<h3 id="持久化配置">持久化配置</h3>
<p>为了在系统重启后保持这些配置，可以将相应的命令添加到启动脚本中。例如，在Debian/Ubuntu系统中，可以将这些命令添加到<code>/etc/network/interfaces</code>文件中：</p>
<pre><code class="language-shell">auto br0
iface br0 inet static
    address 192.168.1.100
    netmask 255.255.255.0
    bridge_ports eth0 eth1
    post-up bridge fdb add 00:11:22:33:44:55 dev eth0 master br0 static
</code></pre>
<p>在CentOS/RHEL系统中，可以将命令添加到<code>/etc/sysconfig/network-scripts/ifcfg-br0</code>文件中：</p>
<pre><code class="language-shell">DEVICE=br0
TYPE=Bridge
BOOTPROTO=static
IPADDR=192.168.1.100
NETMASK=255.255.255.0
ONBOOT=yes

# Add these lines to the end of the file
BRIDGE_STP=no
BRIDGE_PORTS="eth0 eth1"
BRIDGE_AGEING_TIME=300

# Add static FDB entries
POST_UP="bridge fdb add 00:11:22:33:44:55 dev eth0 master br0 static"
</code></pre>
<h2 id="5-关于linux网桥stp">5. 关于linux网桥STP</h2>
<p>STP的目的是防止网络环路，这可能导致网络中的流量风暴。Linux桥接从2.4和2.6内核系列开始就支持STP。要在网桥上启用STP：</p>
<pre><code class="language-shell">sudo ip link set br0 type bridge stp_state 1
#或者
sudo brctl stp br0 on
</code></pre>
<blockquote>
<p>注意：Linux网桥不支持快速生成树协议（RSTP）</p>
</blockquote>
<p>网桥上显示STP阻塞状态：</p>
<pre><code class="language-bash">sudo ip -j -p -d link show br0 | grep root_port
sudo bridge link show
#或
sudo brctl showstp br0
</code></pre>
<p>要更改STP call时间：</p>
<pre><code class="language-bash">sudo ip link set br0 type bridge hello_time 300

sudo ip -j -p -d link show br0 | grep \"hello_time\"
                "hello_time": 300,
</code></pre>
<p>可以使用相同的基本方法来更改其他STP参数，如最大年龄、转发延迟、老化时间等</p>
<h2 id="6-关于linux网桥不转发lldp帧">6. 关于linux网桥不转发LLDP帧</h2>
<h3 id="原因-1">原因</h3>
<p>IEEE为标准协议留出的范围，使用这些地址的包将被网桥过滤，而不会被转发。</p>
<pre><code>IEEE 802.1D MAC Bridge Filtered MAC Group Addresses: 01-80-C2-00-00-00 to 01-80-C2-00-00-0F; MAC frames that have a destination MAC address within this range are not relayed by MAC bridges conforming to IEEE 802.1D.
</code></pre>
<p>IEEE协议中规定的预留的MAC地址表如下：</p>
<table>
<thead>
<tr>
<th>MAC address</th>
<th>Protocol</th>
</tr>
</thead>
<tbody>
<tr>
<td>01-80-C2-00-00-00</td>
<td>Spanning Tree (STP/RSPT/MSTP)<br>生成树（STP/RSPT/MSTP）</td>
</tr>
<tr>
<td>01-80-C2-00-00-01</td>
<td>Ethernet Flow Control (pause frames)<br>以太网流量控制（暂停帧）</td>
</tr>
<tr>
<td>01-80-C2-00-00-02</td>
<td>Link Aggregation Control Protocol (LACP)<br>链路聚合控制协议（LACP）</td>
</tr>
<tr>
<td>01-80-C2-00-00-03</td>
<td>802.1X Port-Based Network Access Control<br>802.1X基于端口的网络访问控制</td>
</tr>
<tr>
<td>01-80-C2-00-00-08</td>
<td>Provider Bridge protocols (STP)<br>供应商桥接协议（STP）</td>
</tr>
<tr>
<td>01-80-C2-00-00-0D</td>
<td>Provider Bridge protocols (MVRP)<br>提供商桥接协议（MVRP）</td>
</tr>
<tr>
<td>01-80-C2-00-00-0E</td>
<td>802.1AB Link Layer Discovery Protocol (LLDP)<br>802.1AB链路层发现协议（LLDP）</td>
</tr>
</tbody>
</table>
<h3 id="解决-1">解决</h3>
<p>综上网桥不转发LLDP（链路层发现协议）帧，但从Linux内核2.6开始，允许通过在<code>/sys/class/net/bridge-iface/bridge/group_fwd_mask</code>中设置特定的位掩码来控制网桥应该转发IEEE 802.1D中定义的范围内的哪些链路本地帧。默认值0表示Linux网桥不转发任何链路本地帧。</p>
<p>将此值设置为16384将允许网桥转发LLDP帧(<code>01-80-C2-00-00- 0E</code>)：</p>
<pre><code class="language-bash"># 关闭网桥的 LLDP 过滤
echo 16384 &gt; /sys/class/net/br0/bridge/group_fwd_mask
</code></pre>
<p>需要注意的是，在默认的发行版本中，对于该MAC地址范围中的前三个（-00,-01,-02）是不能通过以上方式控制的, 意味着在gns3的模拟环境中，我们仍然不能成功的测试STP,流控和LACP。要克服这个限制，必须要自己编译linux kernel才行，也可以下载EVE编译好的版本，<a href="http://eve-ng.net/index.php/documentation/installation/bare-install" target="_blank" rel="noopener nofollow">点击进入链接</a>。这样就可以随意调整group_fwd_mask的值，支持不过滤01-80-C2-00-00-0x的所有地址了。</p>
<p>前文中把group_fwd_mask设为16384，对应的MAC是01-80-C2-00-00-0E，对应的协议是LLDP, 那么group_fwd_mask是如何计算的呢？</p>
<p>位掩码是一个16位的数字，其中第一位（最低有效位）表示MAC地址01-80-C2-00 - 00-00，第16位（最高有效位）表示01-80-C2-00-00-<strong>0F</strong>。默认值（所有位均为0）不转发任何链路本地帧。要启用特定MAC地址的帧转发，我们需要将相应的位设置为1。例如，为了允许转发LLDP帧（01-80-C2-00-00- <strong>0E</strong>），我们需要将第15位设置为1，并将其余位保留为0：</p>
<table>
<thead>
<tr>
<th>MAC</th>
<th>0F</th>
<th>0E</th>
<th>0D</th>
<th>0C</th>
<th>0B</th>
<th>0A</th>
<th>09</th>
<th>08</th>
<th>07</th>
<th>06</th>
<th>05</th>
<th>04</th>
<th>03</th>
<th>02</th>
<th>01</th>
<th>00</th>
</tr>
</thead>
<tbody>
<tr>
<td>BIt</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>这意味着我们使用二进制数0100 0000 0000 0000作为位掩码，它转换为十进制数16384，就像我们在前面的例子中使用的那样。</p>
<p>如果我们想将LACP（01-80-C2-00-00-02）和802.1X（01-80-C2-00-00-03）添加到混合中，我们还将第3位和第4位设置为1。</p>
<table>
<thead>
<tr>
<th>MAC</th>
<th>0F</th>
<th>0E</th>
<th>0D</th>
<th>0C</th>
<th>0B</th>
<th>0A</th>
<th>09</th>
<th>08</th>
<th>07</th>
<th>06</th>
<th>05</th>
<th>04</th>
<th>03</th>
<th>02</th>
<th>01</th>
<th>00</th>
</tr>
</thead>
<tbody>
<tr>
<td>BIt</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>bitmasks是二进制数0100 0000 0000 1100, 转换成10进制则为16396。这样就可以允许LLDP,LACP,802.1x协议了。</p>
<p>按照这样的方法，要解除linux网桥对规定地址范围内所有地址的过滤，就把所有的bit都置为1 即可。</p>
<h3 id="持久化配置-1">持久化配置</h3>
<p>在<code>/etc/rc.local</code>中添加：</p>
<pre><code class="language-bash">#!/bin/bash

# 设置网桥 br0 的组转发掩码
echo 65 &gt; /sys/class/net/br0/bridge/group_fwd_mask
exit 0
</code></pre>
<p>确保脚本具有可执行权限：</p>
<pre><code class="language-bash">sudo chmod +x /etc/rc.local
</code></pre>
<p>或者使用systemd 创建或编辑一个系统服务单元文件，例如<code>/etc/systemd/system/set-group-fwd-mask.service</code>：</p>
<pre><code class="language-bash">[Unit]
Description=Set group forward mask for bridge br0
After=network.target

[Service]
Type=oneshot
ExecStart=/bin/sh -c 'echo 65 &gt; /sys/class/net/br0/bridge/group_fwd_mask'
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
</code></pre>
<p>启用并启动该服务：</p>
<pre><code class="language-bash">sudo systemctl enable set-group-fwd-mask.service
sudo systemctl start set-group-fwd-mask.service
</code></pre>
<p>参考链接</p>
<p><a href="https://interestingtraffic.nl/2017/11/21/an-oddly-specific-post-about-group_fwd_mask/" target="_blank" rel="noopener nofollow">https://interestingtraffic.nl/2017/11/21/an-oddly-specific-post-about-group_fwd_mask/</a></p>
<p><a href="http://standards.ieee.org/develop/regauth/tut/macgrp.pdf" target="_blank" rel="noopener nofollow">http://standards.ieee.org/develop/regauth/tut/macgrp.pdf</a></p>
<h2 id="7-网桥vlan">7. 网桥vlan</h2>
<p>查看网桥vlan信息</p>
<pre><code class="language-shell">bridge vlan show
</code></pre>
<p>要显式禁用网桥的VLAN 过滤功能，可以使用以下命令：</p>
<pre><code class="language-bash">sudo ip link set dev br0 type bridge vlan_filtering 0
</code></pre>
<p>这将确保网桥<code>br0</code>不会处理VLAN标签</p>
<p>要显示VLAN流量状态，启用VLAN统计（在内核4.7中添加）：</p>
<pre><code class="language-bash">sudo ip link set br0 type bridge vlan_stats_enabled 1
</code></pre>
<p>前面的命令只在网桥上启用全局VLAN统计信息，并且没有细粒度地显示每个VLAN的状态。要在网桥中没有端口号时启用每个VLAN的统计信息，还需要启用vlan_stats_per_port（在内核4.20中添加）</p>
<pre><code class="language-bash">sudo ip link set br0 type bridge vlan_stats_per_port 1
</code></pre>
<p>显示vlan统计信息</p>
<pre><code class="language-bash">sudo bridge -s vlan show
</code></pre>
<h3 id="配置持久化-2">配置持久化</h3>
<p>为了在系统重启后保持配置，你需要将相应的命令添加到网络配置文件中。</p>
<p>在Debian/Ubuntu系统上编辑<code>/etc/network/interfaces</code>文件，添加如下内容：</p>
<pre><code class="language-bash">auto br0
iface br0 inet static
    address 192.168.1.100
    netmask 255.255.255.0
    bridge_ports eth0 eth1
    post-up ip link set dev br0 type bridge vlan_filtering 0
</code></pre>
<h2 id="8-其他">8. 其他</h2>
<h3 id="1-网卡混杂模式配置">1. 网卡混杂模式配置</h3>
<pre><code class="language-bash">#打开混杂模式
sudo ip link set eth0 promisc on

#关闭混杂模式
sudo ip link set eth0 promisc off
</code></pre>
<p>或者使用<code>ifconfig</code></p>
<pre><code class="language-bash">#打开混杂模式
sudo ifconfig eth0 promisc

#关闭混杂模式
sudo ifconfig eth0 -promisc
</code></pre>
<h3 id="2-网卡接收多播包配置">2. 网卡接收多播包配置</h3>
<pre><code class="language-bash"># 确认你要配置的网络接口名称
ip link show

#加入多播组
sudo ip maddr add 239.255.255.250 dev eth0

#使能网卡接收多播帧
sudo ifconfig eth0 allmulti
#或
sudo ip link set dev eth0 allmulticast on

#验证配置
ip maddr show dev eth0

</code></pre>
<h3 id="3-创建vlan接口">3. 创建VLAN接口</h3>
<p>启用802.1Q VLAN标签支持</p>
<pre><code class="language-bash">sudo modprobe 8021q
</code></pre>
<p>为了使网卡能够接收所有VLAN包，你需要为每个VLAN创建虚拟接口。假设你需要接收VLAN ID为10和20的包。</p>
<pre><code class="language-bash">sudo ip link add link eth0 name eth0.10 type vlan id 10
sudo ip link add link eth0 name eth0.20 type vlan id 20
sudo ip link set dev eth0.10 up
sudo ip link set dev eth0.20 up
</code></pre>
<p>或者使用 <code>vconfig</code> 命令创建VLAN接口（旧版命令）</p>
<pre><code class="language-bash">sudo vconfig add eth0 10
sudo vconfig add eth0 20
sudo ifconfig eth0.10 up
sudo ifconfig eth0.20 up
</code></pre>
<p>你可以使用以下命令来验证VLAN接口是否已正确配置：</p>
<pre><code class="language-bash">ip -d link show eth0.10
ip -d link show eth0.20
</code></pre>
<p>为了在系统重启后保持这些配置，你需要将相应的命令添加到系统启动脚本中。</p>
<p>在ubuntu上，编辑<code>/etc/network/interfaces</code>文件，添加如下内容：</p>
<pre><code class="language-bash">auto eth0
iface eth0 inet static
    address 192.168.1.100
    netmask 255.255.255.0
    up ip link set eth0 promisc on

auto eth0.10
iface eth0.10 inet manual
    vlan-raw-device eth0

auto eth0.20
iface eth0.20 inet manual
    vlan-raw-device eth0
</code></pre>
<p>在CentOS/RHEL系统上：</p>
<p>创建或编辑<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>文件，确保包含以下内容：</p>
<pre><code class="language-bash">DEVICE=eth0
BOOTPROTO=none
ONBOOT=yes
PROMISC=yes
</code></pre>
<p>创建或编辑VLAN接口配置文件，例如<code>/etc/sysconfig/network-scripts/ifcfg-eth0.10</code>和<code>/etc/sysconfig/network-scripts/ifcfg-eth0.20</code>：</p>
<pre><code class="language-bash"># /etc/sysconfig/network-scripts/ifcfg-eth0.10
DEVICE=eth0.10
BOOTPROTO=none
ONBOOT=yes
VLAN=yes

# /etc/sysconfig/network-scripts/ifcfg-eth0.20
DEVICE=eth0.20
BOOTPROTO=none
ONBOOT=yes
VLAN=yes
</code></pre>
<p>重新启动网络服务以应用配置：</p>
<pre><code class="language-bash"># 对于Debian/Ubuntu
sudo systemctl restart networking

# 对于CentOS/RHEL
sudo systemctl restart network
</code></pre>
<h2 id="参考链接">参考链接</h2>
<p><a href="https://developers.redhat.com/articles/2022/04/06/introduction-linux-bridging-commands-and-features#vlan_filter" target="_blank" rel="noopener nofollow">https://developers.redhat.com/articles/2022/04/06/introduction-linux-bridging-commands-and-features#vlan_filter</a></p>
<p><a href="https://interestingtraffic.nl/2017/11/21/an-oddly-specific-post-about-group_fwd_mask/" target="_blank" rel="noopener nofollow">https://interestingtraffic.nl/2017/11/21/an-oddly-specific-post-about-group_fwd_mask/</a></p>
<p><a href="http://standards.ieee.org/develop/regauth/tut/macgrp.pdf" target="_blank" rel="noopener nofollow">http://standards.ieee.org/develop/regauth/tut/macgrp.pdf</a></p>
<p><a href="https://wiki.libvirt.org/Net.bridge.bridge-nf-call_and_sysctl.conf.html" target="_blank" rel="noopener nofollow">https://wiki.libvirt.org/Net.bridge.bridge-nf-call_and_sysctl.conf.html</a></p>

</div>
<div id="MySignature" role="contentinfo">
    <div>作者：<a href="http://www.cnblogs.com/wsg1100/" target="_blank">wsg1100</a></div>
<div>出处：<a href="http://www.cnblogs.com/wsg1100/" target="_blank">http://www.cnblogs.com/wsg1100/</a></div>
<div>本文版权归作者和博客园共有，欢迎转载，但必须给出原文链接，并保留此段声明，否则保留追究法律责任的权利。 </div>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6906787030543982" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-09 21:51">2025-01-09 19:59</span>&nbsp;
<a href="https://www.cnblogs.com/wsg1100">沐多</a>&nbsp;
阅读(<span id="post_view_count">215</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18662571" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18662571);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18662571', targetLink: 'https://www.cnblogs.com/wsg1100/p/18662571', title: '关于linux网桥(Linux Bridge)的一些个人记录' })">举报</a>
</div>
	