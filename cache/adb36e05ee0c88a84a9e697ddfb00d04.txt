
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wofeiliangren/p/18923487" title="发布于 2025-06-11 11:36">
    <span role="heading" aria-level="2">WinForm中实现Adobe PDF Reader实现旋转PDF功能</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p>
<h3 id="实现效果">实现效果：</h3>
<p><img src="https://img2023.cnblogs.com/blog/1687593/202506/1687593-20250611112556172-273404937.gif" alt="PDF旋转功能" loading="lazy"></p>
<h3 id="问题点adobe-pdf-reader中并没有可以直接旋转的方法">问题点：Adobe PDF Reader中并没有可以直接<font color="red">旋转</font>的方法</h3>
<table>
<thead>
<tr>
<th>LoadFile</th>
<th>加载文件,文件URL地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>GotoFirstPage</td>
<td>到第一页</td>
</tr>
<tr>
<td>GotoLastPage</td>
<td>到最后一页</td>
</tr>
<tr>
<td>GotoPreviousPage</td>
<td>上一页</td>
</tr>
<tr>
<td>GotoNextPape</td>
<td>下一页</td>
</tr>
<tr>
<td>SetCurrentpage</td>
<td>到指定页</td>
</tr>
<tr>
<td>Setshowscrollbars</td>
<td>设置是否显示 Acrobat Reader的滚动条。带一个参数,该参数设为0时不显示滚动条,设为1时显示滚动条</td>
</tr>
<tr>
<td>SetshowToolbar</td>
<td>设置是否显示 Acrobat Reader的工具栏。带一个参数,该参数设为时不显示,设为1时显示。</td>
</tr>
<tr>
<td>Setview</td>
<td>设置显示效果。Fit：适应窗口大小； FitH：适合宽度</td>
</tr>
<tr>
<td>setZoom</td>
<td>设置文件的显示比例；默认是100</td>
</tr>
</tbody>
</table>
<h3 id="解决办法引入pdfiumviewer旋转pdf并保存替换当前的文件">解决办法：引入PdfiumViewer旋转PDF并保存替换当前的文件。</h3>
<pre><code class="language-c#">		 /// &lt;summary&gt;
        /// 旋转保存PDF文件并释放文件锁定
        /// &lt;/summary&gt;
        /// &lt;param name="axControl"&gt;&lt;/param&gt;
        /// &lt;param name="filePath"&gt;&lt;/param&gt;
        /// &lt;param name="pdfRotation"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;    
public bool SafeSavePdfWithRelease(AxAcroPDFLib.AxAcroPDF axControl, string filePath, PdfRotation pdfRotation)
    {
        const int MAX_RETRY = 3;
        const int RETRY_DELAY = 500;

        for (int attempt = 0; attempt &lt; MAX_RETRY; attempt++)
        {
            try
            {
                // 步骤1：创建临时副本
                string tempPath = Path.GetTempFileName().Replace(".tmp", ".pdf");
                File.Copy(filePath, tempPath, true);

                // 步骤2：使用内存流操作
                using (var ms = new MemoryStream(File.ReadAllBytes(tempPath)))
                using (var document = PdfiumViewer.PdfDocument.Load(ms))
                {
                    for (int pageIndex = 0; pageIndex &lt; document.PageCount; pageIndex++)
                    {
                        document.RotatePage(pageIndex, pdfRotation);

                        // 可选：验证旋转结果
                        // var currentRotation = document.Pages[pageIndex].Rotation;
                        // Debug.Assert(currentRotation == (int)rotation);
                    }
                    // 执行修改操作（示例：旋转第一页）
                    //document.RotatePage(1, PdfRotation.Rotate90);

                    // 步骤3：保存到临时文件
                    byte[] pdfBytes;
                    using (var outputStream = new MemoryStream())
                    {
                        document.Save(outputStream);
                        pdfBytes = outputStream.ToArray();
                    }

                    // 步骤4：强制释放文件锁定
                    ForceReleasePdfFile(axControl, filePath);

                    // 步骤5：原子替换文件
                    File.WriteAllBytes(tempPath, pdfBytes);
                    // File.Replace(tempPath, filePath, null, true);

                    // 1. 复制替换文件到目标路径
                    File.Copy(tempPath, filePath, overwrite: true);

                    // 2. 删除临时文件（可选）
                    File.Delete(tempPath);

                    // 步骤6：验证加载
                    axControl.LoadFile(filePath);
                    return true;
                }
            }
            catch (IOException ex) when (ex.HResult == -2147024864)
            {
                if (attempt == MAX_RETRY - 1) throw;
                Thread.Sleep(RETRY_DELAY);
            }
        }
        return false;
    }
    public void ForceReleasePdfFile(AxAcroPDFLib.AxAcroPDF axControl, string filePath)
    {
        // 步骤1：深度释放COM对象
        ReleaseComObject(axControl);

        // 步骤2：内核级文件解锁
        UnlockFileHandle(filePath);

        // 步骤3：延迟重载验证
        Thread.Sleep(200);
        axControl.LoadFile(filePath);
    }

    private void ReleaseComObject(AxAcroPDFLib.AxAcroPDF axControl)
    {
        try
        {
            // 显式释放ActiveX资源
            if (axControl.IsDisposed) return;

            // 反射调用内部释放方法
            var type = axControl.GetType();
            var method = type.GetMethod("ReleaseOCX", BindingFlags.Instance | BindingFlags.NonPublic);
            method?.Invoke(axControl, null);

            // 强制垃圾回收
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }
        catch (Exception ex)
        {

        }
    }
    // 修改后的P/Invoke声明
    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    private static extern IntPtr CreateFile(
        string lpFileName,
        uint dwDesiredAccess,
        uint dwShareMode,
        IntPtr lpSecurityAttributes,
        FileMode dwCreationDisposition,  // 改用.NET枚举
        FileAttributes dwFlagsAndAttributes,  // 改用.NET枚举
        IntPtr hTemplateFile);

    // 修改后的UnlockFileHandle方法
    private void UnlockFileHandle(string filePath)
    {
        const uint FILE_SHARE_READ = 0x00000001;
        const uint FILE_SHARE_WRITE = 0x00000002;
        const uint GENERIC_READ = 0x80000000;

        IntPtr hFile = CreateFile(
            filePath,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            IntPtr.Zero,
            FileMode.Open,  // 对应原生OPEN_EXISTING
            FileAttributes.Normal,  // 对应原生FILE_ATTRIBUTE_NORMAL
            IntPtr.Zero);

        if (hFile != IntPtr.Zero &amp;&amp; hFile != new IntPtr(-1))
        {
            CloseHandle(hFile);
        }
    }

    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool CloseHandle(IntPtr hObject);`
</code></pre>
<p>调用代码：</p>
<pre><code class="language-C#">		  /// &lt;summary&gt;
        /// 当前旋转角度
        /// &lt;/summary&gt;
        public static int currentRotation = 0;

        /// &lt;summary&gt;
        /// 逆时针旋转
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void pictureEdit3_Click(object sender, EventArgs e)
        {
            if (axAcroPDF1.Visible)
            {
                currentRotation -= 90; 

                PdfRotation pdfRotation = GetCounterClockwiseRotation(currentRotation);
                 
                var path = axAcroPDF1.src;
                //调用旋转PDF保存方法
                SafeSavePdfWithRelease(axAcroPDF1, path,pdfRotation); 
                axAcroPDF1.LoadFile(path);
                axAcroPDF1.setView("Fit"); //适应窗口大小
            }
        }

        /// &lt;summary&gt;
        /// 顺时针旋转
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void pictureEdit2_Click(object sender, EventArgs e)
        {
            if (axAcroPDF1.Visible)
            {
                currentRotation += 90; 

                PdfRotation pdfRotation = GetCounterClockwiseRotation(currentRotation);

                var path = axAcroPDF1.src;
                //调用旋转PDF保存方法
                SafeSavePdfWithRelease(axAcroPDF1, path, pdfRotation);

                axAcroPDF1.LoadFile(path);
                axAcroPDF1.setView("Fit"); //适应窗口大小 
            }
        }


        /// &lt;summary&gt;
        /// 通过旋转度数计算旋转的角度
        /// &lt;/summary&gt;
        /// &lt;param name="counterClockwiseDegrees"&gt;当前旋转角度&lt;/param&gt;
        public static PdfRotation GetCounterClockwiseRotation(int counterClockwiseDegrees)
        {
            const int fullCircle = 360;
            int effectiveDegrees = counterClockwiseDegrees % fullCircle;

            if (effectiveDegrees &lt; 0) effectiveDegrees += fullCircle; // 处理负角度

            if (currentRotation &gt;= 360) 
            {
                currentRotation = 0;
            }
            if (currentRotation &lt;= -360) 
            {
                currentRotation = 0;
            }

            switch (effectiveDegrees)
            {
                case 90:
                    return PdfRotation.Rotate90; 
                case 180:
                    return PdfRotation.Rotate180;
                case 270:
                    return PdfRotation.Rotate270;
                case 0:
                default:
                    return PdfRotation.Rotate0;
            }
        }
        /// &lt;summary&gt;
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.09236111111111112" data-date-updated="2025-06-11 13:49">2025-06-11 11:36</span>&nbsp;
<a href="https://www.cnblogs.com/wofeiliangren">我本梁人</a>&nbsp;
阅读(<span id="post_view_count">164</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18923487);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18923487', targetLink: 'https://www.cnblogs.com/wofeiliangren/p/18923487', title: 'WinForm中实现Adobe PDF Reader实现旋转PDF功能' })">举报</a>
</div>
        