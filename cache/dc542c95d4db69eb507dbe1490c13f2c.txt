
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TheMagicalRainbowSea/p/18810981" title="发布于 2025-04-06 12:07">
    <span role="heading" aria-level="2">7. RabbitMQ 消息队列——延时队列(Spring Boot + 安装message_exchange"延迟插件" 的详细配置说明)的详细讲解</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="7-rabbitmq-消息队列延时队列spring-boot--安装message_exchange延迟插件-的详细配置说明的详细讲解">7. RabbitMQ 消息队列——延时队列(Spring Boot + 安装message_exchange"延迟插件" 的详细配置说明)的详细讲解</h1>
<p>@</p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#7-rabbitmq-消息队列延时队列spring-boot--安装message_exchange延迟插件-的详细配置说明的详细讲解" rel="noopener nofollow">7. RabbitMQ 消息队列——延时队列(Spring Boot + 安装message_exchange"延迟插件" 的详细配置说明)的详细讲解</a></li><li><a href="#1-rabbitmq-延时队列概述" rel="noopener nofollow">1. RabbitMQ 延时队列概述</a></li><li><a href="#2-rabbitmq-中的-ttl" rel="noopener nofollow">2. RabbitMQ 中的 TTL</a></li><li><a href="#3--rabbitmq-整合-spring-boot" rel="noopener nofollow">3.  RabbitMQ 整合 Spring Boot</a><ul><li><a href="#31--spring-boot-当中搭建配置-rabbitmq-的-队列-ttl延时队列" rel="noopener nofollow">3.1  Spring Boot 当中搭建配置 RabbitMQ 的 队列 TTL(延时队列)</a></li></ul></li><li><a href="#_" rel="noopener nofollow">null</a><ul><li><a href="#32-延时队列优化" rel="noopener nofollow">3.2 延时队列优化</a></li><li><a href="#33-rabbitmq-插件实现延迟队列" rel="noopener nofollow">3.3 Rabbitmq 插件实现延迟队列</a></li></ul></li><li><a href="#4-补充docker-容器当中安装-message_exchange延迟插件-的详细步骤" rel="noopener nofollow">4. 补充：Docker 容器当中安装 message_exchange"延迟插件" 的详细步骤</a></li><li><a href="#5-最后" rel="noopener nofollow">5. 最后：</a></li></ul></div><p></p>
<h1 id="1-rabbitmq-延时队列概述">1. RabbitMQ 延时队列概述</h1>
<p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p>
<p><strong>延时队列的应用场景：</strong></p>
<blockquote>
<p>场景：有一个订单，15 分钟内如果不支付，就把该订单设置为交易关闭，那么就不能再进行支付了，这类实现延迟任务的场景就可以采用延时队列的方式来实现，当然除了延时队列，还可以采用其它的方式——&gt; 定时任务的方式。</p>
</blockquote>
<ol>
<li>订单在十分钟之内未支付则自动取消。</li>
<li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li>
<li>用户注册后，如果三天内没有登陆则进行短信提醒。</li>
<li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li>
<li>预定会议后，需要在预定的时间点前 10 分钟，通知各个参会人员参加会议。</li>
</ol>
<p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎 使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果 数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支 付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十 分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万 级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单 的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428576-774380403.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="2-rabbitmq-中的-ttl">2. RabbitMQ 中的 TTL</h1>
<p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者队列中的所有消息的最大存活时间。</p>
<p>单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为 <strong>“死信 ”</strong> 。如果同时配置了队列的 TTL 和消息的 TTL ，那么较小的那个值将会被使用，有两种方式设置了 TTL 。</p>
<p><strong>消息设置 TTL：</strong></p>
<p>另一种方式便是针对每条消息设置 TTL</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428579-301523000.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>队列设置 TTL：</strong></p>
<p>第一种是在创建队列的时候设置队列的 <code>“x-message-ttl ”</code> 属性。</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428601-390382379.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>延时队列 和 死信队列：</strong></p>
<p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队 列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为<strong>消息是否过期是在即将投递到消费者 之前判定的</strong>，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；另外，还需 要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以 直接投递该消息到消费者，否则该消息将会被丢弃。</p>
<p>上一篇我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已 经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延 时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面， 成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为 里面的消息都是希望被立即处理的消息。</p>
<h1 id="3--rabbitmq-整合-spring-boot">3.  RabbitMQ 整合 Spring Boot</h1>
<p><strong>1. 创建项目</strong><br>
<img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428605-519347160.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428651-237240065.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>添加相关依赖，在 <code>pom.xml</code> 文件当中</strong></p>
<pre><code class="language-xml">
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!--RabbitMQ 依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.47&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--swagger--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--RabbitMQ 测试依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;
            &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

</code></pre>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.3&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.rainbowsea&lt;/groupId&gt;
    &lt;artifactId&gt;springboot-rabbitmq&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;springboot-rabbitmq&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!--RabbitMQ 依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.47&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--swagger--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--RabbitMQ 测试依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;
            &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;


&lt;/project&gt;

</code></pre>
<p><strong>在 <code>resources/创建一个 application.properties</code> 文件当中(当然也可以使用 <code>yaml</code> 配置文件)，配置相关的配置文件</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428644-1852372030.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-properties">spring.rabbitmq.host=192.168.76.156
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=123
</code></pre>
<p><strong>添加 Swagger 配置类</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428640-1022756704.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">package com.rainbowsea.rabbitmq.springbootrabbitmq.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration
@EnableSwagger2
public class SwaggerConfig {
    @Bean
    public Docket webApiConfig() {
        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("webApi")
                .apiInfo(webApiInfo())
                .select()
                .build();
    }

    private ApiInfo webApiInfo() {
        return new ApiInfoBuilder()
                .title("rabbitmq 接口文档")
                .description("本文档描述了 rabbitmq 微服务接口定义")
                .version("1.0")
                .contact(new Contact("enjoy6288", "http://rainbowsea.com", "3339966@qq.com"))
                .build();
    }
}
</code></pre>
<h2 id="31--spring-boot-当中搭建配置-rabbitmq-的-队列-ttl延时队列">3.1  Spring Boot 当中搭建配置 RabbitMQ 的 队列 TTL(延时队列)</h2>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428577-1684540341.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>代码架构图：</strong></p>
<p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428560-783473547.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>1. 创建文件类代码（该代码就是用于配置 RabbitMQ 当中的交换机和队列的信息配置的），作为一个配置类存在的</strong> 。</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428640-1008210609.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428671-1207320563.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428602-1347363408.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.DirectExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

@Configuration  // 标注是一个配置类，加载到 IOC 容器当中
public class TtlQueueConfig {

    // 普通交换机的名称
    public static final String X_EXCHANGE = "X";

    // 声明 XExchange 别名；会注入到 IOC 容器当中 普通交换机的
    @Bean(value = "xExchange")
    public DirectExchange xExchange() {
        return new DirectExchange(X_EXCHANGE);
    }

}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428603-1639140093.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">package com.rainbowsea.rabbitmq.springbootrabbitmq.config;


import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.DirectExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

@Configuration  // 标注是一个配置类，加载到 IOC 容器当中
public class TtlQueueConfig {

    // 普通交换机的名称
    public static final String X_EXCHANGE = "X";
    // 死信队列的名称
    public static final String DEAD_LETTER_QUEUE = "QD";

    // 死信交换机的名称
    public static final String Y_DEAD_LETTER_EXCHANGE = "Y";
    // 普通队列的名称
    public static final String QUEUE_A = "QA";
    public static final String QUEUE_B = "QB";

    // 声明普通队列 TTL 为 10s
    @Bean("queueA")
    public Queue queueA() {
        // 创建一个 Map 用于存放，设置队列信息
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(3);
        // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
        arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
        // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
        arguments.put("x-dead-letter-routing-key", "YD");
        // 设置 TTL ，单位是 ms 注意这里的参数 x-message-ttl 是固定的不可随便写
        arguments.put("x-message-ttl", 10000);

        return QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();
    }


    // 声明普通队列 TTL 为 40s
    @Bean("queueB")
    public Queue queueB() {
        // 创建一个 Map 用于存放，设置队列信息
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(3);
        // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
        arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
        // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
        arguments.put("x-dead-letter-routing-key", "YD");
        // 设置 TTL ，单位是 ms 注意这里的参数 x-message-ttl 是固定的不可随便写
        arguments.put("x-message-ttl", 40000);

        return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();
    }


}

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428559-914770760.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java"> // 声明死信队列
    @Bean("queueD")
    public Queue queueD() {
        //  不带参数，就不需要 .withArguments(arguments)
        //return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();
        return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();
    }

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428615-973761147.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428559-1586287764.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">// 绑定

    /**
     * 注意：这里的  public Binding queueABindingX(@Qualifier("queueA") Queue queueA,
     *                                   @Qualifier("xExchange") DirectExchange xExchange)
     *
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier 参数内的值是，我们上边：  @Bean(value = "xExchange")，@Bean("queueA") 注入到 IOC 容器当中的值
     * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
     *  @Bean(value = "xExchange")
     *     public DirectExchange xExchange() {
     * @Bean("queueA") public Queue queueA() {
     */
    @Bean
    public Binding queueABindingX(@Qualifier("queueA") Queue queueA,
                                  @Qualifier("xExchange") DirectExchange xExchange) {
        // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
        // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XA"
        // 表示将 队列 queueA 与 xExchange 交换机，通过 routingKey 为 "XA" 进行一个绑定
        return BindingBuilder.bind(queueA).to(xExchange).with("XA");
    }
</code></pre>
<p><strong>完整配置代码如下：</strong></p>
<pre><code class="language-java">package com.rainbowsea.rabbitmq.springbootrabbitmq.config;


import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.DirectExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

@Configuration  // 标注是一个配置类，加载到 IOC 容器当中
public class TtlQueueConfig {

    // 普通交换机的名称
    public static final String X_EXCHANGE = "X";
    // 死信队列的名称
    public static final String DEAD_LETTER_QUEUE = "QD";

    // 死信交换机的名称
    public static final String Y_DEAD_LETTER_EXCHANGE = "Y";
    // 普通队列的名称
    public static final String QUEUE_A = "QA";
    public static final String QUEUE_B = "QB";

    // 声明 XExchange 别名；会注入到 IOC 容器当中 普通交换机的
    @Bean(value = "xExchange")
    public DirectExchange xExchange() {
        return new DirectExchange(X_EXCHANGE);
    }


    // 声明 yExchange 别名；会注入到 IOC 容器当中 普通交换机的
    @Bean(value = "yExchange")
    public DirectExchange yExchange() {
        return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);
    }

    // 声明普通队列 TTL 为 10s
    @Bean("queueA")
    public Queue queueA() {
        // 创建一个 Map 用于存放，设置队列信息
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(3);
        // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
        arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
        // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
        arguments.put("x-dead-letter-routing-key", "YD");
        // 设置 TTL ，单位是 ms 注意这里的参数 x-message-ttl 是固定的不可随便写
        arguments.put("x-message-ttl", 10000);

        return QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();
    }


    // 声明普通队列 TTL 为 40s
    @Bean("queueB")
    public Queue queueB() {
        // 创建一个 Map 用于存放，设置队列信息
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(3);
        // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
        arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
        // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
        arguments.put("x-dead-letter-routing-key", "YD");
        // 设置 TTL ，单位是 ms 注意这里的参数 x-message-ttl 是固定的不可随便写
        arguments.put("x-message-ttl", 40000);

        return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();
    }


    // 声明死信队列
    @Bean("queueD")
    public Queue queueD() {
        //  不带参数，就不需要 .withArguments(arguments)
        //return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();
        return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();
    }


    // 绑定

    /**
     * 注意：这里的  public Binding queueABindingX(@Qualifier("queueA") Queue queueA,
     *                                   @Qualifier("xExchange") DirectExchange xExchange)
     *
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier 参数内的值是，我们上边：  @Bean(value = "xExchange")，@Bean("queueA") 注入到 IOC 容器当中的值
     * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
     *  @Bean(value = "xExchange")
     *     public DirectExchange xExchange() {
     * @Bean("queueA") public Queue queueA() {
     */
    @Bean  // 绑定也是要注入到 IOC 容器当中的
    public Binding queueABindingX(@Qualifier("queueA") Queue queueA,
                                  @Qualifier("xExchange") DirectExchange xExchange) {
        // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
        // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XA"
        // 表示将 队列 queueA 与 xExchange 交换机，通过 routingKey 为 "XA" 进行一个绑定
        return BindingBuilder.bind(queueA).to(xExchange).with("XA");
    }


    // 绑定

    /**
     * 注意：这里的  public Binding queueBBindingX(@Qualifier("queueB") Queue queueB,
     *                                   @Qualifier("xExchange") DirectExchange xExchange)
     *
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier 参数内的值是，我们上边：  @Bean(value = "xExchange")，@Bean("queueB") 注入到 IOC 容器当中的值
     * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
     *  @Bean(value = "xExchange")
     *     public DirectExchange xExchange() {
     * @Bean("queueB") public Queue queueB() {
     */
    @Bean  // 绑定也是要注入到 IOC 容器当中的
    public Binding queueBBindingX(@Qualifier("queueB") Queue queueB,
                                  @Qualifier("xExchange") DirectExchange xExchange) {
        // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
        // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XB"
        // 表示将 队列 queueB 与 xExchange 交换机，通过 routingKey 为 "XB" 进行一个绑定
        return BindingBuilder.bind(queueB).to(xExchange).with("XB");
    }


    // 绑定

    /**
     * 注意：这里的  public Binding queueDBindingX(@Qualifier("queueD") Queue queueD,
     *                                   @Qualifier("yExchange") DirectExchange yExchange)
     *
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier 参数内的值是，我们上边：  @Bean(value = "yExchange")，@Bean("queueD") 注入到 IOC 容器当中的值
     * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
     * @Bean(value = "yExchange")
     * public DirectExchange yExchange() {
     * @Bean("queueD")
     *     public Queue queueD() {
     */
    @Bean // 绑定也是要注入到 IOC 容器当中的
    public Binding queueDBindingX(@Qualifier("queueD") Queue queueD,
                                  @Qualifier("yExchange") DirectExchange yExchange) {
        // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
        // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"YD"
        // 表示将 队列 queueD 与 yExchange 交换机，通过 routingKey 为 "YD" 进行一个绑定
        return BindingBuilder.bind(queueD).to(yExchange).with("YD");
    }


}

</code></pre>
<p><strong>生产者——》发送消息的代码：</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428601-668428967.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">package com.rainbowsea.rabbitmq.springbootrabbitmq.controller;


import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
import java.util.Date;

/**
 * 生产者：发送延时消息
 * http://localhost:8080/ttl/sendMsg/嘻嘻嘻
 */


@RestController
@RequestMapping("/ttl")
@Slf4j
public class SendMsgController {

    @Resource  // 注入到 IOC 容器当中
    private RabbitTemplate rabbitTemplate;


    @GetMapping("/sendMsg/{message}")
    public void sendMsg(@PathVariable String message) {
        log.info("当前时间:{},发送一条消息给两个 TTL 队列:{}", new Date().toString(), message);
        rabbitTemplate.convertAndSend("X","XA","消息来自ttl为 10s的队列" + message);
        rabbitTemplate.convertAndSend("X","XB","消息来自ttl为 40s的队列" + message);

    }

}

</code></pre>
<p><strong>消费者——》消费/读取消息的代码：</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428580-852096707.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">package com.rainbowsea.rabbitmq.springbootrabbitmq.consumer;


import com.rabbitmq.client.Channel;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;

import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.Date;

/**
 * 消费者(消费/读取消息)
 */

@Slf4j
@Component  // 当 IOC 容器读取到
public class DeadLetterQueueConsumer {


    @RabbitListener(queues = "QD")
    public void receiveD(Message message, Channel channel) {
        String msg = new String(message.getBody());
        log.info("当前时间:{},收到死信队列的消息:{}", new Date().toString(), msg);
    }


}



</code></pre>
<p><strong>运行效果：</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428485-244160289.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>该延时队列存在的问题：</strong></p>
<p>第一条消息在 10 S 后变成了死信消息，然后被消费者消费/读取掉了，第二条消息在 40S 之后变成了死信消息，然后被消费掉，这样一个延时队列就被打造完成了。</p>
<p>不过，该延时队列存在一个问题：</p>
<blockquote>
<p>如果这样使用的话，岂不是<strong>每增加一个新的时间需求，就要新增一个队列。</strong> 这里只有 10S  和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加 <code>TTL</code> 为一个小时的队列，如果是预定会议室，然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求。</p>
</blockquote>
<h1 id="_"></h1>
<h2 id="32-延时队列优化">3.2 延时队列优化</h2>
<blockquote>
<p><strong>优化思路：</strong> <strong>就是把延时时间，交给发送消息的生产者上决定，而不是写死在队列当中，通过一个无延时队列来处理，生产者上设置的一个延时发送的时间。</strong></p>
</blockquote>
<p>在这里新增了一个队列 QC,绑定关系如下，该队列不设置 TTL 时间</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428652-1933494840.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p><strong>特别注意：</strong> <strong>这里需要将上面创建了的 交换机，队列删除了，因为 RabbitMQ 消息队列不能将一个已经存在的交换机/队列，的基础上，进行修改，而是只能重新生成</strong> 。</p>
</blockquote>
<p>在 <strong>TtlQueueConfig</strong> 配置类上添加上一个，RoutingKey 为 XC ，队列为 QC，对应 死信队列还是 QD 。</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428640-189613932.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.DirectExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

@Configuration  // 标注是一个配置类，加载到 IOC 容器当中
public class TtlQueueConfig {

    // 普通交换机的名称
    public static final String X_EXCHANGE = "X";
    // 死信队列的名称
    public static final String DEAD_LETTER_QUEUE = "QD";

    // 死信交换机的名称
    public static final String Y_DEAD_LETTER_EXCHANGE = "Y";
    // 普通队列的名称
    public static final String QUEUE_A = "QA";
    public static final String QUEUE_B = "QB";



    //普通队列的名称
    public static final String QUEUE_C = "QC";
    // 声明队列 QC 同时绑定上 (以 RoutingKey 为 XC  )QD 死信交换机
    @Bean("queueC")
    public Queue queueC(){
        // 创建一个 Map 用于存放，设置队列信息
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(3);
        // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
        arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
        // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
        arguments.put("x-dead-letter-routing-key", "YD");
        // 不设置 TTL 时间，也是通过生产者来设置
        return QueueBuilder.durable(QUEUE_C).withArguments(arguments).build();
    }

    // 将声明的队列 QC  绑定到 X 交换机当中
    @Bean  // 绑定也是要注入到 IOC 容器当中的
    public Binding queueBindingX(@Qualifier("queueC") Queue queueC,
                                  @Qualifier("xExchange") DirectExchange xExchange) {
        // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
        // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XC"
        // 表示将 队列 queueC 与 xExchange 交换机，通过 routingKey 为 "XC" 进行一个绑定
        return BindingBuilder.bind(queueC).to(xExchange).with("XC");
    }

}
</code></pre>
<p>完整代码内容：</p>
<pre><code class="language-java">package com.rainbowsea.rabbitmq.springbootrabbitmq.config;


import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.DirectExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

@Configuration  // 标注是一个配置类，加载到 IOC 容器当中
public class TtlQueueConfig {

    // 普通交换机的名称
    public static final String X_EXCHANGE = "X";
    // 死信队列的名称
    public static final String DEAD_LETTER_QUEUE = "QD";

    // 死信交换机的名称
    public static final String Y_DEAD_LETTER_EXCHANGE = "Y";
    // 普通队列的名称
    public static final String QUEUE_A = "QA";
    public static final String QUEUE_B = "QB";



    //普通队列的名称
    public static final String QUEUE_C = "QC";
    // 声明队列 QC 同时绑定上 (以 RoutingKey 为 XC  )QD 死信交换机
    @Bean("queueC")
    public Queue queueC(){
        // 创建一个 Map 用于存放，设置队列信息
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(3);
        // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
        arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
        // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
        arguments.put("x-dead-letter-routing-key", "YD");
        // 不设置 TTL 时间，也是通过生产者来设置
        return QueueBuilder.durable(QUEUE_C).withArguments(arguments).build();
    }

    // 将声明的队列 QC  绑定到 X 交换机当中
    @Bean  // 绑定也是要注入到 IOC 容器当中的
    public Binding queueBindingX(@Qualifier("queueC") Queue queueC,
                                  @Qualifier("xExchange") DirectExchange xExchange) {
        // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
        // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XC"
        // 表示将 队列 queueC 与 xExchange 交换机，通过 routingKey 为 "XC" 进行一个绑定
        return BindingBuilder.bind(queueC).to(xExchange).with("XC");
    }


    // 声明 XExchange 别名；会注入到 IOC 容器当中 普通交换机的
    @Bean(value = "xExchange")
    public DirectExchange xExchange() {
        return new DirectExchange(X_EXCHANGE);
    }


    // 声明 yExchange 别名；会注入到 IOC 容器当中 普通交换机的
    @Bean(value = "yExchange")
    public DirectExchange yExchange() {
        return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);
    }

    // 声明普通队列 TTL 为 10s
    @Bean("queueA")
    public Queue queueA() {
        // 创建一个 Map 用于存放，设置队列信息
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(3);
        // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
        arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
        // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
        arguments.put("x-dead-letter-routing-key", "YD");
        // 设置 TTL ，单位是 ms 注意这里的参数 x-message-ttl 是固定的不可随便写
        arguments.put("x-message-ttl", 10000);

        return QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();
    }


    // 声明普通队列 TTL 为 40s
    @Bean("queueB")
    public Queue queueB() {
        // 创建一个 Map 用于存放，设置队列信息
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(3);
        // 设置死信交换机 注意这里的参数 x-dead-letter-exchange 是固定的不可
        arguments.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);
        // 设置死信的 RoutingKey 为 YD ，注意这里的参数 x-dead-letter-routing-key 是固定的不可随便写
        arguments.put("x-dead-letter-routing-key", "YD");
        // 设置 TTL ，单位是 ms 注意这里的参数 x-message-ttl 是固定的不可随便写
        arguments.put("x-message-ttl", 40000);

        return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();
    }


    // 声明死信队列
    @Bean("queueD")
    public Queue queueD() {
        //  不带参数，就不需要 .withArguments(arguments)
        //return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();
        return QueueBuilder.durable(DEAD_LETTER_QUEUE).build();
    }


    // 绑定

    /**
     * 注意：这里的  public Binding queueABindingX(@Qualifier("queueA") Queue queueA,
     *                                   @Qualifier("xExchange") DirectExchange xExchange)
     *
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier 参数内的值是，我们上边：  @Bean(value = "xExchange")，@Bean("queueA") 注入到 IOC 容器当中的值
     * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
     *  @Bean(value = "xExchange")
     *     public DirectExchange xExchange() {
     * @Bean("queueA") public Queue queueA() {
     */
    @Bean  // 绑定也是要注入到 IOC 容器当中的
    public Binding queueABindingX(@Qualifier("queueA") Queue queueA,
                                  @Qualifier("xExchange") DirectExchange xExchange) {
        // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
        // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XA"
        // 表示将 队列 queueA 与 xExchange 交换机，通过 routingKey 为 "XA" 进行一个绑定
        return BindingBuilder.bind(queueA).to(xExchange).with("XA");
    }


    // 绑定

    /**
     * 注意：这里的  public Binding queueBBindingX(@Qualifier("queueB") Queue queueB,
     *                                   @Qualifier("xExchange") DirectExchange xExchange)
     *
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier 参数内的值是，我们上边：  @Bean(value = "xExchange")，@Bean("queueB") 注入到 IOC 容器当中的值
     * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
     *  @Bean(value = "xExchange")
     *     public DirectExchange xExchange() {
     * @Bean("queueB") public Queue queueB() {
     */
    @Bean  // 绑定也是要注入到 IOC 容器当中的
    public Binding queueBBindingX(@Qualifier("queueB") Queue queueB,
                                  @Qualifier("xExchange") DirectExchange xExchange) {
        // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
        // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"XB"
        // 表示将 队列 queueB 与 xExchange 交换机，通过 routingKey 为 "XB" 进行一个绑定
        return BindingBuilder.bind(queueB).to(xExchange).with("XB");
    }


    // 绑定

    /**
     * 注意：这里的  public Binding queueDBindingX(@Qualifier("queueD") Queue queueD,
     *                                   @Qualifier("yExchange") DirectExchange yExchange)
     *
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier("xExchange") DirectExchange xExchange)
     * @Qualifier 参数内的值是，我们上边：  @Bean(value = "yExchange")，@Bean("queueD") 注入到 IOC 容器当中的值
     * ，必须要是注入到了 IOC容器当中，不然是无法被使用上的，同时注意名称，不要写错了，要保持一致
     * @Bean(value = "yExchange")
     * public DirectExchange yExchange() {
     * @Bean("queueD")
     *     public Queue queueD() {
     */
    @Bean // 绑定也是要注入到 IOC 容器当中的
    public Binding queueDBindingX(@Qualifier("queueD") Queue queueD,
                                  @Qualifier("yExchange") DirectExchange yExchange) {
        // 第一个参数是 队列名(注入到了IOC容器当中了)，第二个参数是交换机(注入到了IOC容器当中了)
        // 第三个蚕食是: 队列名对于绑定交换机之间的交互的  routingKey 信息"YD"
        // 表示将 队列 queueD 与 yExchange 交换机，通过 routingKey 为 "YD" 进行一个绑定
        return BindingBuilder.bind(queueD).to(yExchange).with("YD");
    }


}

</code></pre>
<p><strong>生产者——&gt; 发送消息，代码</strong></p>
<blockquote>
<p>这里，生产者，指定一个延时时间(TTL)，交给 X 交换机——&gt;以 routingKey = XC 发送给 QC 队列——&gt; 发送给死信交换机——&gt; 以 routingKey = YD 分配给 QD 死信队列——&gt;最后给消费者读取/消费消息。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428544-1183079308.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">

import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
import java.util.Date;

/**
 * 生产者：发送延时消息
 * http://localhost:8080/ttl/sendMsg/嘻嘻嘻
 */


@RestController
@RequestMapping("ttl")
@Slf4j
public class SendMsgController {

    @Resource  // 注入到 IOC 容器当中
    private RabbitTemplate rabbitTemplate;


    @GetMapping("/sendExpirationMsg/{message}/{ttlTime}")
    public void sendMsg(@PathVariable String message,
                        @PathVariable String ttlTime) {
        log.info("当前时间:{},发送一条时长{}毫秒 TTL 消息给队列QC:{}", new Date().toString(), ttlTime, message);
        rabbitTemplate.convertAndSend("X", "XC", message, msg -&gt; {
            // 发送消息的时候，延时时长
            msg.getMessageProperties().setExpiration(ttlTime);
            return msg;
        });
        log.info("当前时间：{},发送一条时长{}毫秒 TTL 信息给队列 C:{}", new Date(), ttlTime, message);

    }
}
</code></pre>
<p><strong>测试效果：</strong></p>
<p>浏览器发送请求：</p>
<ul>
<li><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD1/20000" target="_blank" rel="noopener nofollow">http://localhost:8080/ttl/sendExpirationMsg/你好1/20000</a></li>
<li><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD2/2000" target="_blank" rel="noopener nofollow">http://localhost:8080/ttl/sendExpirationMsg/你好2/2000</a></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428483-138748402.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428559-146200515.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428642-1302957467.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p><strong>分析测试结果：</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428660-782814992.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<blockquote>
<p>看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用消息属性上设置 <strong>TTL</strong> 的方式，消息可能并不会按时 “死亡” ，因为<strong>RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列，如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行</strong> 。</p>
</blockquote>
<h2 id="33-rabbitmq-插件实现延迟队列">3.3 Rabbitmq 插件实现延迟队列</h2>
<p>上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间 及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。</p>
<p>我们可以通过安装一个：<code>rabbitmq-delayed-message-exchange 插件</code> 来解决这个问题。这个插件是如何解决的呢：<strong>既然延时队列，将消息放入到队列当中存在，一个消息过期时间优先级的问题，那么我们就不将延时的消息，放入到队列当中，而是通过交换机进行处理。</strong></p>
<p><code>rabbitmq-delayed-message-exchange 插件</code> 就是让我们延时的消息，可以不走队列，而是通过交换机本身进行一个处理，让消费者直接从交换机当中消费，读取消息。</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428484-1182540066.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>消息发送后不会直接投递到队列，</p>
<p>而是存储到 Mnesia（嵌入式数据库），检查 x-delay 时间（消息头部）；</p>
<p>延迟插件在 RabbitMQ 3.5.7 及以上的版本才支持，依赖 Erlang/OPT 18.0 及以上运行环境；</p>
<p>Mnesia 是一个小型数据库，不适合于大量延迟消息的实现</p>
<p>解决了消息过期时间不一致(优先级)出现的问题。</p>
<p><strong>安装：安装延时队列插件 详细步骤：</strong></p>
<ol>
<li>在官网上下载：<a href="https://www.rabbitmq.com/community-plugins" target="_blank" rel="noopener nofollow">https://www.rabbitmq.com/community-plugins</a></li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428643-1230798542.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>下载 <code>rabbitmq_delayed_message_exchange</code> 插件</p>
<ol start="2">
<li>然后解压放置到 RabbitMQ 的插件目录，进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效。</li>
</ol>
<pre><code class="language-sh">[root@RainbowSea plugins]# cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins # 进入到 RabbitMQ 插件目录
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428654-1753476306.png" alt="在这里插入图片描述" loading="lazy"></p>
<ol start="3">
<li>将下载好的 <code>rabbitmq_delayed_message_exchange</code> 插件，上传到 RabbitMQ 的安装目录下的 plgins 目录 当中。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428604-1263857573.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428603-204377583.png" alt="在这里插入图片描述" loading="lazy"></p>
<ol start="4">
<li>执行 <code>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</code> 命令，启用该插件</li>
</ol>
<pre><code class="language-sh">[root@RainbowSea plugins]# rabbitmq-plugins enable rabbitmq_delayed_message_exchange
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428642-1284427229.png" alt="在这里插入图片描述" loading="lazy"></p>
<ol start="5">
<li><code>rabbitmq-plugins list</code> 查看所有插件</li>
</ol>
<pre><code class="language-sh">[root@RainbowSea plugins]# rabbitmq-plugins list
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428643-221340504.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>添加成功的效果：</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428611-450078936.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428608-1951034612.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>具体代码实现：</strong></p>
<ol>
<li>在这里新增了一个队列 <code>delayed.queue</code>,一个自定义交换机 <code>delayed.exchange</code>，绑定关系如下:</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428653-111552693.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>编写配置类代码：</strong></p>
<p>在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制 消息传递后并 不会立即投递到目标队列中，而是存储在 mnesia (一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。<br>
<img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428630-1807443887.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">package com.rainbowsea.rabbitmq.springbootrabbitmq.config;


import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.CustomExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class DelayedQueueConfig {

    public static final String DELAYED_QUEUE_NAME = "delayed.queue";
    public static final String DELAYED_EXCHANGE_NAME = "delayed.exchange";
    public static final String DELAYED_ROUTING_KEY = "delayed.routingkey";


    @Bean("delayedQueue")  // 声明队列，基于 rabbitmq_delayed_message_exchange 插件的
    public Queue delayedQueue() {
        return new Queue(DELAYED_QUEUE_NAME);
    }

    // 声明交换机(可以算是一种自定义交换机)，基于 rabbitmq_delayed_message_exchange 插件的
    @Bean("delayedExchange")
    public CustomExchange delayedExchange() {
        // 创建一个 Map 用于存放，设置队列信息
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;(3);
        // 自定义交换机的类型, 这里定义为 direct 直接类型
        arguments.put("x-delayed-type", "direct");
        /**
         * CustomExchange 方法参数
         * 1.交换机的名称
         * 2.交换机的类型
         * 3.是否需要持久化
         * 4.是否需要自动删除
         * 5.其它的参数
         */

        return new CustomExchange(DELAYED_EXCHANGE_NAME, "x-delayed-message", true, false, arguments);
    }


    // 基于 rabbitmq_delayed_message_exchange 插件的 将队列绑定到交换机当中
    @Bean
    public Binding delayedQueueBindingdelayedExchange(
            @Qualifier("delayedQueue") Queue delayedQueue,
            @Qualifier("delayedExchange") CustomExchange delayedExchange) {
        return BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();
    }
}

</code></pre>
<p><strong>生产者-发送消息的：</strong> 这里我们使用的是，通过生产者，设置延时时间，而不是通过队列写死延时时间的方式。</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428650-647259746.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">
import com.rainbowsea.rabbitmq.springbootrabbitmq.config.DelayedQueueConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


import javax.annotation.Resource;
import java.util.Date;

/**
 * 生产者：发送延时消息
 * http://localhost:8080/ttl/sendMsg/嘻嘻嘻
 */


@RestController
@RequestMapping("ttl")
@Slf4j
public class SendMsgController {

    @Resource  // 注入到 IOC 容器当中
    private RabbitTemplate rabbitTemplate;


    @GetMapping("sendDelayMsg/{message}/{delayTime}")
    public void sendMsg(@PathVariable String message, @PathVariable Integer delayTime) {
        log.info(" 当前时间: {}, 发送一条延迟{} 毫秒的信息给队列 delayed.queue:{}", new Date(), delayTime, message);
        rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME, DelayedQueueConfig.DELAYED_ROUTING_KEY, message,
                correlationData -&gt; {
                    // 发送消息的时候，延迟时长，单位:ms
                    correlationData.getMessageProperties().setDelay(delayTime);
                    return correlationData;
                });
    }

}
</code></pre>
<p><strong>消费者/读取/消费——使用插件交换机当中延时的消息：</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428593-670395555.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">package com.rainbowsea.rabbitmq.springbootrabbitmq.consumer;


import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;
import com.rainbowsea.rabbitmq.springbootrabbitmq.config.DelayedQueueConfig;

import java.util.Date;


/**
 * 消费者，消费/读取消息，基于rabbitmq_delayed_message_exchange 插件
 */
@Slf4j
@Component
public class DelayQueueConsumer {

    // 监听消息
    @RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)
    public void receiveDelayQueue(Message message) {
        String msg = new String(message.getBody());
        log.info("当前时间:{} ,收到延时队列的消息:{}", new Date().toString(), msg);
    }
}

</code></pre>
<p><strong>运行结果：</strong>  浏览器当中发出请求：</p>
<ul>
<li><a href="http://localhost:8080/ttl/sendDelayMsg/come" target="_blank" rel="noopener nofollow">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby1/20000</li>
<li><a href="http://localhost:8080/ttl/sendDelayMsg/come" target="_blank" rel="noopener nofollow">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby2/2000</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428653-393492267.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428643-607159461.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>总结：</strong></p>
<p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：<strong>消息可靠发送，消息可靠投递，死信队列</strong> 来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单击故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。</p>
<p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点，看需要适用的场景。</p>
<h1 id="4-补充docker-容器当中安装-message_exchange延迟插件-的详细步骤">4. 补充：Docker 容器当中安装 message_exchange"延迟插件" 的详细步骤</h1>
<ol>
<li><strong>确定 Docker 容器对应映射的卷的目录位置：</strong></li>
</ol>
<pre><code class="language-sh">docker inspect rabbitmq
</code></pre>
<p>对应的运行结果：</p>
<pre><code class="language-sh">        "Mounts": [
            {
                "Type": "volume",
                "Name": "rabbitmq-plugin",
                "Source": "/var/lib/docker/volumes/rabbitmq-plugin/_data",
                "Destination": "/plugins",
                "Driver": "local",
                "Mode": "z",
                "RW": true,
                "Propagation": ""
            },
            {
                "Type": "volume",
                "Name": "cca7bc3012f5b76bd6c47a49ca6911184f9076f5f6263b41f4b9434a7f269b11",
                "Source": "/var/lib/docker/volumes/cca7bc3012f5b76bd6c47a49ca6911184f9076f5f6263b41f4b9434a7f269b11/_data",
                "Destination": "/var/lib/rabbitmq",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ]
</code></pre>
<p>和容器内 <code>/plugins</code> 目录对应的宿主机目录是：<code>/var/lib/docker/volumes/rabbitmq-plugin/_data</code></p>
<blockquote>
<p><strong>注意：这里必须必须必须，将下载到的 <code>插件</code> 拷贝到 RabbitMQ 服务器 <code>plugins</code> 目录下，不然时无法安装成功的。</strong></p>
</blockquote>
<ol start="2">
<li><strong>下载对应的 messaging 延时插件</strong></li>
</ol>
<p><strong>messaging 延时插件的官网文档地址：</strong> <a href="https://www.rabbitmq.com/community-plugins" target="_blank" rel="noopener nofollow">https://www.rabbitmq.com/community-plugins</a></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428631-1860627507.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428644-975179095.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>下载在 Docker 容器当中下载安装文件：</strong></p>
<pre><code class="language-sh">wget https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/v3.13.0/rabbitmq_delayed_message_exchange-3.13.0.ez
mv rabbitmq_delayed_message_exchange-3.13.0.ez /var/lib/docker/volumes/rabbitmq-plugin/_data
</code></pre>
<ol start="3">
<li><strong>启用该延时插件：</strong></li>
</ol>
<pre><code class="language-sh"># 登录进入容器内部
docker exec -it rabbitmq /bin/bash

# rabbitmq-plugins命令所在目录已经配置到$PATH环境变量中了，可以直接调用
rabbitmq-plugins enable rabbitmq_delayed_message_exchange

# 退出Docker容器
exit

# 重启Docker容器
docker restart rabbitmq
</code></pre>
<ol start="4">
<li><strong>插件安装成功的，确定，验证：</strong></li>
</ol>
<ul>
<li>确认点1：查看当前节点已启用插件的列表：</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428650-1702034190.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li>确认点2：如果创建新交换机时可以在type中看到x-delayed-message选项，那就说明插件安装好了</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428641-1256909882.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5-最后">5. 最后：</h1>
<blockquote>
<p>“在这个最后的篇章中，我要表达我对每一位读者的感激之情。你们的关注和回复是我创作的动力源泉，我从你们身上吸取了无尽的灵感与勇气。我会将你们的鼓励留在心底，继续在其他的领域奋斗。感谢你们，我们总会在某个时刻再次相遇。”</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202504/3084824-20250406120428685-1975720165.gif" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5090147855925926" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-06 12:08">2025-04-06 12:07</span>&nbsp;
<a href="https://www.cnblogs.com/TheMagicalRainbowSea">Rainbow-Sea</a>&nbsp;
阅读(<span id="post_view_count">50</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18810981" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18810981);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18810981', targetLink: 'https://www.cnblogs.com/TheMagicalRainbowSea/p/18810981', title: '7. RabbitMQ 消息队列——延时队列(Spring Boot + 安装message_exchange&amp;quot;延迟插件&amp;quot; 的详细配置说明)的详细讲解' })">举报</a>
</div>
	