
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/renzhesuanfa/p/18705271" title="发布于 2025-02-08 19:47">
    <span role="heading" aria-level="2">【忍者算法】从扫雷游戏到矩阵操作：探索矩阵置零问题｜LeetCode 73 矩阵置零</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="从扫雷游戏到矩阵操作探索矩阵置零问题">从扫雷游戏到矩阵操作：探索矩阵置零问题</h1>
<h2 id="生活中的算法">生活中的算法</h2>
<p>想象你在玩扫雷游戏，当你点到一个地雷时，不仅这个格子会被标记，与它同行同列的格子也都会受到影响。或者想象一个办公室的座位表，如果某个位置发现了感染者，为了安全起见，需要将该员工所在的整行（同排同事）和整列（对面同事）都标记为密切接触者需要检测。</p>
<p>这种"一点触发，全行全列响应"的场景在生活中很常见：</p>
<ul>
<li>学校课程表中，如果某个老师请假，那一整行的课程都需要调整</li>
<li>表格处理软件中，调整某个单元格的格式，可以统一设置整行整列</li>
<li>影院选座系统中，如果一个座位损坏，可能需要锁定那一排和那一列的预订功能</li>
</ul>
<h2 id="问题描述">问题描述</h2>
<p>LeetCode第73题"矩阵置零"是这样描述的：给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p>
<p>例如：</p>
<pre><code>输入：matrix = [
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出：[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
</code></pre>
<h2 id="最直观的解法额外空间标记">最直观的解法：额外空间标记</h2>
<p>就像在处理办公室防疫时，先用一张新表记录下所有需要检测的位置，然后统一处理。</p>
<p>让我们用一个简单的例子来理解：</p>
<pre><code>原矩阵：
[1,2,0]
[3,4,5]

1. 记录0所在的位置：
   - 第0行，第2列有个0

2. 标记需要置零的行和列：
   - 需要置零的行：[0]
   - 需要置零的列：[2]

3. 根据记录修改矩阵：
   [0,0,0]  // 第0行全置零
   [3,4,0]  // 第2列置零
</code></pre>
<h2 id="优化解法原地标记">优化解法：原地标记</h2>
<p>仔细思考会发现，我们可以用矩阵的第一行和第一列来记录标记信息，就像用办公室的墙上的记事板来标记需要处理的区域。这样就不需要额外的空间了。</p>
<h3 id="原地标记的原理">原地标记的原理</h3>
<ol>
<li>先记录第一行和第一列是否原本包含0</li>
<li>用第一行和第一列作为标记板</li>
<li>处理剩余的矩阵</li>
<li>最后根据第一步的记录处理第一行和第一列</li>
</ol>
<h3 id="示例演示">示例演示</h3>
<p>用下面的矩阵来说明：</p>
<pre><code>[1,2,3]
[4,0,6]
[7,8,9]

1. 记录第一行和第一列的状态：
   - 第一行没有0
   - 第一列没有0

2. 用第一行和第一列标记：
   - 因为matrix[1][1]=0，所以：
     - 标记第一行：matrix[0][1]=0
     - 标记第一列：matrix[1][0]=0

3. 根据标记处理矩阵主体：
   [1,0,3]
   [0,0,0]
   [7,0,9]

4. 最后根据第一步的记录处理第一行第一列
</code></pre>
<h3 id="java代码实现">Java代码实现</h3>
<pre><code class="language-java">public void setZeroes(int[][] matrix) {
    if (matrix == null || matrix.length == 0) return;
    
    int m = matrix.length;
    int n = matrix[0].length;
    
    // 记录第一行和第一列是否原本包含0
    boolean firstRowHasZero = false;
    boolean firstColHasZero = false;
    
    // 检查第一行
    for (int j = 0; j &lt; n; j++) {
        if (matrix[0][j] == 0) {
            firstRowHasZero = true;
            break;
        }
    }
    
    // 检查第一列
    for (int i = 0; i &lt; m; i++) {
        if (matrix[i][0] == 0) {
            firstColHasZero = true;
            break;
        }
    }
    
    // 使用第一行和第一列作为标记
    for (int i = 1; i &lt; m; i++) {
        for (int j = 1; j &lt; n; j++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;  // 标记该行
                matrix[0][j] = 0;  // 标记该列
            }
        }
    }
    
    // 根据标记处理非第一行第一列的部分
    for (int i = 1; i &lt; m; i++) {
        for (int j = 1; j &lt; n; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }
    
    // 处理第一行
    if (firstRowHasZero) {
        for (int j = 0; j &lt; n; j++) {
            matrix[0][j] = 0;
        }
    }
    
    // 处理第一列
    if (firstColHasZero) {
        for (int i = 0; i &lt; m; i++) {
            matrix[i][0] = 0;
        }
    }
}
</code></pre>
<h2 id="解法比较">解法比较</h2>
<p>让我们比较这两种方法：</p>
<p>额外空间标记：</p>
<ul>
<li>时间复杂度：O(m×n)</li>
<li>空间复杂度：O(m+n)</li>
<li>优点：思路清晰，实现简单</li>
<li>缺点：需要额外空间</li>
</ul>
<p>原地标记：</p>
<ul>
<li>时间复杂度：O(m×n)</li>
<li>空间复杂度：O(1)</li>
<li>优点：不需要额外空间</li>
<li>缺点：实现稍复杂，需要额外记录第一行列的状态</li>
</ul>
<h2 id="解题技巧总结">解题技巧总结</h2>
<p>这道题给我们的启发：</p>
<ol>
<li>矩阵问题中，往往可以利用矩阵本身来存储信息</li>
<li>处理特殊情况（如第一行列）时，可以单独考虑</li>
<li>分步骤处理复杂问题可以让思路更清晰</li>
<li>在修改数据时，注意保护原始信息</li>
</ol>
<p>类似的问题还有：</p>
<ul>
<li>生命游戏</li>
<li>旋转图像</li>
<li>岛屿数量</li>
</ul>
<h2 id="小结">小结</h2>
<p>通过矩阵置零这道题，我们学会了如何巧妙地利用矩阵本身来存储信息，避免使用额外空间。这种思维方式不仅适用于本题，在处理需要原地修改数据的矩阵问题时都很有启发。记住，当遇到需要在矩阵中标记信息的问题时，考虑能否利用矩阵本身的某些位置来存储标记！</p>
<hr>
<p>作者：忍者算法<br>
公众号：忍者算法</p>
<p>我准备了一份刷题清单，以及这些题目的详细题解，覆盖了绝大部分常见面试题。我可以很负责任地说，只要你把这些题真正掌握了，80%的算法面试都能遇到相似题目。公众号回复【刷题清单】获取～</p>
<p><a href="https://github.com/ninjaAlgorithm/LeetCode-Solutions-Hot-100/" target="_blank" rel="noopener nofollow">完整GitHub项目</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.02416255353587963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-08 19:48">2025-02-08 19:47</span>&nbsp;
<a href="https://www.cnblogs.com/renzhesuanfa">忍者算法</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18705271" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18705271);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18705271', targetLink: 'https://www.cnblogs.com/renzhesuanfa/p/18705271', title: '【忍者算法】从扫雷游戏到矩阵操作：探索矩阵置零问题｜LeetCode 73 矩阵置零' })">举报</a>
</div>
        