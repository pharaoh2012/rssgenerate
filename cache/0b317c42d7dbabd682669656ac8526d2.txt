
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/handsometaoa/p/18682740" title="发布于 2025-01-22 00:44">
    <span role="heading" aria-level="2">一种线程安全的缓存工具实现方式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>在多线程环境下，缓存是一个常见的性能优化手段。然而，实现一个线程安全的缓存并不容易，尤其是在高并发场景下，如何避免重复计算、保证数据一致性是一个挑战。<br>
最近在读《Java并发编程实战》时，书中提到了一种基于 ConcurrentHashMap 和 FutureTask 的线程安全缓存实现方式，今天就来分享记录一下。</p>
<h2 id="实现背景">实现背景</h2>
<p>在高并发场景中，缓存的核心作用是避免重复计算。比如，某个计算任务非常耗时，如果多个线程同时请求相同的数据，我们希望只计算一次，后续请求直接使用缓存结果。<br>
然而，实现这样的缓存工具需要考虑以下几个问题：</p>
<p>线程安全：多个线程可能同时访问缓存，如何避免竞态条件？<br>
避免重复计算：如何确保相同的计算任务只执行一次？<br>
异常处理：如果计算任务抛出异常，如何清理缓存并通知调用方？</p>
<h2 id="实现代码">实现代码</h2>
<pre><code class="language-java">public interface Computable&lt;A, V&gt; {
    V compute(A arg) throws InterruptedException;
}
</code></pre>
<pre><code class="language-java">import java.util.Map;
import java.util.concurrent.*;

public class CacheUtils&lt;A, V&gt; implements Computable&lt;A, V&gt; {
    private final Map&lt;A, Future&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;();
    private final Computable&lt;A, V&gt; computable;

    public CacheUtils(Computable&lt;A, V&gt; computable) {
        this.computable = computable;
    }

    @Override
    public V compute(A arg) throws InterruptedException {
        while (true) {
            Future&lt;V&gt; future = cache.get(arg);
            if (future == null) {
                Callable&lt;V&gt; eval = () -&gt; computable.compute(arg);
                FutureTask&lt;V&gt; futureTask = new FutureTask&lt;&gt;(eval);
                future = cache.putIfAbsent(arg, futureTask);
                if (future == null) {
                    future = futureTask;
                    futureTask.run();
                }
            }
            try {
                return future.get();
            } catch (CancellationException e) {
                // 如果任务被取消，移除缓存中的 Future
                cache.remove(arg, future);
            } catch (ExecutionException e) {
                // 如果计算任务抛出异常，移除缓存中的 Future 并抛出异常
                cache.remove(arg, future);
                throw new RuntimeException("Computation failed for argument: " + arg, e.getCause());
            }
        }
    }
}

</code></pre>
<h2 id="实现思路说明">实现思路说明</h2>
<p>使用 <code>ConcurrentHashMap</code> 中 <code>putIfAbsent</code> 方法来保证，同一时刻只能有一个线程可以将 <code>FutureTask</code> 放入缓存，从而避免相同任务的重复计算；当计算任务发生异常时，可以及时抛出错误/取消缓存结果。</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/handsometaoa/" target="_blank">帅气的涛啊</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/handsometaoa/p/18682740" target="_blank">https://www.cnblogs.com/handsometaoa/p/18682740</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.1454257836087963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-22 02:43">2025-01-22 00:44</span>&nbsp;
<a href="https://www.cnblogs.com/handsometaoa">帅气的涛啊</a>&nbsp;
阅读(<span id="post_view_count">13</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18682740" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18682740);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18682740', targetLink: 'https://www.cnblogs.com/handsometaoa/p/18682740', title: '一种线程安全的缓存工具实现方式' })">举报</a>
</div>
        