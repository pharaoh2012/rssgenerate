<!----> <meta itemprop="headline" content="因网速太慢我把20M+的字体压缩到了几KB"> <meta itemprop="keywords" content="React.js"> <meta itemprop="datePublished" content="2025-04-07T00:00:01.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="古茗前端团队"> <meta itemprop="url" content="https://juejin.cn/user/3233040624266695"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-5111268e="">
            因网速太慢我把20M+的字体压缩到了几KB
            <!----> <!----></h1> <div class="container team-follow" data-v-af376bf0="" data-v-5111268e=""><div class="left" data-v-af376bf0=""><a href="/team/7198439419173404711/posts" data-v-af376bf0=""><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dafcebf7c91d402abd52f072a32deba8~tplv-k3u1fbpfcp-watermark.image?" class="icon" data-v-af376bf0=""></a> <div class="content" data-v-af376bf0=""><div style="display: flex" data-v-af376bf0=""><a href="/team/7198439419173404711/posts" data-v-af376bf0=""><p class="title-line" data-v-af376bf0=""><span title="古茗前端团队" class="title" data-v-af376bf0="">古茗前端团队</span> <img src="//lf-web-assets.juejin.cn/obj/juejin-web/xitu_juejin_web/255e400027b783cbad76dc41527e7695.svg" alt="team icon" class="team-icon" data-v-af376bf0=""></p></a></div> <div class="meta-box team" data-v-af376bf0="" data-v-5111268e=""><time datetime="2025-04-07T00:00:01.000Z" title="Mon Apr 07 2025 00:00:01 GMT+0000 (Coordinated Universal Time)" class="time" data-v-af376bf0="" data-v-5111268e="">
                2025-04-07
              </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-af376bf0="" data-v-5111268e=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-af376bf0="" data-v-5111268e=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-af376bf0="" data-v-5111268e=""></circle></svg> <span class="views-count" style="display:none;" data-v-af376bf0="" data-v-5111268e="">
                51
              </span> <span class="read-time" data-v-af376bf0="" data-v-5111268e=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-af376bf0="" data-v-5111268e=""><rect width="16" height="16" fill="none" data-v-af376bf0="" data-v-5111268e=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-af376bf0="" data-v-5111268e=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-af376bf0="" data-v-5111268e=""></path></svg>
                阅读1分钟
              </span> <!----> <!----></div></div></div> <button class="jj-follow-button follow-btn" style="display:none;" data-v-090b3d46="" data-v-af376bf0=""><span data-v-090b3d46="" data-v-af376bf0=""><i class="byte-icon byte-icon--plus" data-v-af376bf0=""><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><path fill="none" d="M0 0h48v48H0z"></path><path d="M24.7 4c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8V22h16.7c.4 0 .6 0 .8.1.2.1.3.2.4.4.1.2.1.3.1.8v1.4c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1H26v16.7c0 .4 0 .6-.1.8-.1.2-.2.3-.4.4-.2.1-.3.1-.8.1h-1.4c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8V26H5.3c-.4 0-.6 0-.8-.1-.2-.1-.3-.2-.4-.4-.1-.2-.1-.3-.1-.8v-1.4c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1H22V5.3c0-.4 0-.6.1-.8.1-.2.2-.3.4-.4.2-.1.3-.1.8-.1h1.4z"></path></svg></i>
        关注
      </span></button></div> <div class="team-user block-hidden" data-v-5111268e=""><div class="avatar jj-avatar avatar" data-v-03256cc6="" data-v-5111268e=""><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="avatar" class="lazy avatar-img" data-v-5244ef91="" data-v-03256cc6=""> </div> <!----> <span class="position ellipsis" data-v-5111268e="">
              @古茗科技
            </span></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-5111268e=""><div class="article-viewer markdown-body cache result"><blockquote>
<p>于水增</p>
</blockquote>
<h2 data-id="heading-0">故事背景</h2>
<p>事情起源于之前做的海报编辑器，自己调试时无意中发现字体渲染好慢，第一反应就是网怎么变慢了，断网了？仔细一看才发现，淦！这几个字体资源咋这么大，难怪网速变慢了呢😁😁。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/997be8a2d3684c3085ee6331baa50662~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="" loading="lazy"></p>
<p>图片中的海报包含6种字体，其中最大的字体文件超过20M，而最长的网络加载时长已接近20s。所以海报实际效果图展示耗时太久，很影响用户体验。那就趁此机会跟大家聊聊 <strong>字体</strong> 这件小事。</p>
<h2 data-id="heading-1">字体文件为什么那么大？</h2>
<p>🙋 DeepSeek同学来回答下大家：</p>
<p>这里所说的大体积的字体资源多数是指中文主要原因下边两点</p>
<ul>
<li><strong>中文字符数量庞大</strong>，英文仅&nbsp;<strong>26</strong> 个字母 + 符号，中文（全字符集）包含&nbsp;<strong>70,000+</strong> 字符</li>
<li><strong>字形结构复杂</strong>，字体文件需为每个字符存储独立的矢量轮廓数据，而汉字笔画复杂，每个字符需存储数百个控制点坐标（例如「龍」字的轮廓点数量可能是「A」的 10 倍以上）</li>
</ul>
<p>总结下来就是咱们不光汉字多，书法也是五花八门，它是真小不了。如果你硬要压缩，我们只能从第一点入手，将字符数量进行缩减，比如保留 <strong>1000</strong> 个常用汉字。</p>
<p>web网站中常见字体格式</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a35681abebaa467f9d8cb71935d76835~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="" loading="lazy"></p>
<p>由于我司物料部门提供的为TTF格式，所以这里通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fadobe-fonts%2Fsource-han-sans%2Ftree%2Frelease%2F%3Ftab%3Dreadme-ov-file%23ttf-1" target="_blank" title="https://github.com/adobe-fonts/source-han-sans/tree/release/?tab=readme-ov-file#ttf-1" ref="nofollow noopener noreferrer">思源黑体</a> 给一个直观的对比：</p>
<ul>
<li>TTF 文件：16.9 MB</li>
<li>WOFF2 文件：7.4 MB（压缩率约 60%）</li>
</ul>
<p>两者为什么会差这么多，其实WOFF2 只是在 TTF/OTF 基础上添加了压缩和 Web 专用元数据，且WOFF2支持增量解码，也就是边下载边解析，文本可更快显示（即使字体未完全加载，不过有待考证）。</p>
<h2 data-id="heading-2">TTF有办法优化吗？</h2>
<h3 data-id="heading-3">回归问题本身</h3>
<p>首先来简单回顾下我们自定义的字体是如何在浏览器中完成渲染的</p>
<p>一般情况下我们对字体文件的引用方式为下边三种</p>
<ul>
<li>通过绝对路径来引用，这种就是将字体文件打包在工程内，所以带来的结果就是工程打包文件体积太大</li>
</ul>
<pre><code class="hljs language-less" lang="less"><span class="hljs-keyword">@font-face</span> {
  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'xxx'</span>;
  <span class="hljs-attribute">src</span>: url(<span class="hljs-string">'../../assets/fonts.woff2'</span>)
}
</code></pre>
<ul>
<li>第二种就是 CDN 中存放的字体文件，一般是通过这种方式来减少工程的编译后体积</li>
</ul>
<pre><code class="hljs language-less" lang="less"><span class="hljs-keyword">@font-face</span> {
  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">'xxx'</span>;
  <span class="hljs-attribute">src</span>: url(<span class="hljs-string">'https://xxx.woff2'</span>)
}
</code></pre>
<ul>
<li>通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFontFace" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/API/FontFace" ref="nofollow noopener noreferrer">FontFace</a> 构造一个字体对象</li>
</ul>
<p>前两种一般是在浏览器构建 CSSOM 时，当遇到<code>**&lt;font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(243, 243, 243);"&gt;url()&lt;/font&gt;**</code><strong> </strong>引用时会发起资源请求。第三种则是通过 js 来控制字体的加载流程，所以归根结底就是字体文件太大，导致网络资源下载速度慢，我们只能从优化字体大小的方向入手</p>
<h3 data-id="heading-4">确定解决方向</h3>
<p>下面汇总下查到的具体几个优化方案，诸如提高网络传输效率，增加缓存之类的就不讲了，能够立竿见影的主要下边这两个方案</p>




















<table><thead><tr><th>方案</th><th>方法/原理</th><th>适用场景</th></tr></thead><tbody><tr><td>字体子集化</td><td>通过工具将字体文件进行提取（<strong>支持动态</strong>），返回指定的字符集的字体文件，其根本就是<strong>减少单次资源请求的体积</strong>，需要服务端支持</td><td>这个方案是所有优化场景的基础</td></tr><tr><td>按需加载</td><td>通过设置 <code>unicode-range</code> 属性，浏览器在进行css样式计算时候，会根据页面中的字符与设置的字符范围进行比对，匹配上会加载对应的字体文件</td><td>前提是资源已经被子集化，比较适用多语言切换的场景</td></tr></tbody></table>
<p>简单来说，<strong>字体子集化</strong>可单独食用，<strong>按需加载</strong>则必须要将字体前置子集化。才能完美实现按需加载。就我的这个项目而言，动态子集化方案不要太完美，毕竟一张海报本身就没几个字儿！所以我们这次<strong>将抛弃 CDN，通过动态的将服务本地中的字体资源子集化</strong>来实现字体的压缩效果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88dcd2ebd4534344ad1a94309109eac8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="" loading="lazy"></p>
<p>这里我们使用<strong>python</strong>中的一个字体工具库 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffonttools%2Ffonttools" target="_blank" title="https://github.com/fonttools/fonttools" ref="nofollow noopener noreferrer">fontTools</a> 来实现一个动态子集化，类似于 Google Fonts 的实现。核心思路就是将字符传给服务端，通过工具将传入的字符在本地字体文件中提取并返回给客户端，通过<strong>fontTools</strong> 还可以将TTF格式转化为和Web更搭的<strong>WOFF2</strong>格式。实现细节如下述代码所示</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">'/font/&lt;font_name&gt;'</span>, methods=[<span class="hljs-string">'GET'</span>]</span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_font_subset</span>(<span class="hljs-params">font_name</span>):
    <span class="hljs-comment"># 获取本地字体文件路径</span>
    font_path = os.path.join(FONTS_DIR, <span class="hljs-string">f"<span class="hljs-subst">{font_name}</span>.ttf"</span>)
    <span class="hljs-comment"># 获取子集字符</span>
    chars = request.args.get(<span class="hljs-string">'text'</span>, <span class="hljs-string">''</span>)
    <span class="hljs-comment"># 字体文件格式</span>
    <span class="hljs-built_in">format</span> = request.args.get(<span class="hljs-string">'format'</span>, <span class="hljs-string">'woff2'</span>).lower()

    <span class="hljs-comment"># 处理字符，去重</span>
    unique_chars = <span class="hljs-string">''</span>.join(<span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">set</span>(chars)))
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># 配置子集化选项</span>
        options = Options()
        options.flavor = <span class="hljs-built_in">format</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">format</span> <span class="hljs-keyword">in</span> {<span class="hljs-string">'woff'</span>, <span class="hljs-string">'woff2'</span>} <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>
        options.desubroutinize = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 增强兼容性</span>
        subsetter = Subsetter(options=options)
        
        <span class="hljs-comment"># 加载字体并生成子集</span>
        font = TTFont(font_path)
        subsetter.populate(text=unique_chars)
        subsetter.subset(font)

        <span class="hljs-comment"># 保存为指定格式</span>
        buffer = io.BytesIO()
        font.save(buffer)
        buffer.seek(<span class="hljs-number">0</span>)

        <span class="hljs-comment"># 确定MIME类型</span>
        mime_type = {
            <span class="hljs-string">'woff2'</span>: <span class="hljs-string">'font/woff2'</span>,
            <span class="hljs-string">'woff'</span>: <span class="hljs-string">'font/woff'</span>,
        }[<span class="hljs-built_in">format</span>]

        <span class="hljs-comment"># 创建响应并设置</span>
        response = Response(buffer.read(), mimetype=mime_type)
        <span class="hljs-comment"># 其他设置...</span>
        <span class="hljs-keyword">return</span> response

    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-comment"># 子集化失败...</span>

</code></pre>
<p>前端代码中增加了一些字符提取的工作，我本身就是通过 <code>FontFace Api</code> 来请求字体资源的，所以我仅需将资源链接替换为<strong>子集化字体的接口</strong>就可以了，下面代码来描述字体的加载过程</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// ...其他逻辑</span>
<span class="hljs-title class_">Toast</span>.<span class="hljs-title function_">loading</span>(<span class="hljs-string">'字体加载中'</span>)
<span class="hljs-comment">// 遍历海报中的字体对象</span>
[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(fontFamilies)].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fontName</span>) =&gt;</span> {
  <span class="hljs-comment">// 在字体库中找到对应字体详细信息</span>
  <span class="hljs-keyword">const</span> obj = fontLibrary.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> el?.<span class="hljs-property">value</span> === fontName) ?? {};

  <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">value</span> &amp;&amp; obj.<span class="hljs-property">src</span>) {
    <span class="hljs-comment">// 处理海报中提取的文案集合</span>
    <span class="hljs-keyword">const</span> text = textMap[obj.<span class="hljs-property">value</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);
    <span class="hljs-comment">// 构建字体对象</span>
    <span class="hljs-keyword">const</span> font = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FontFace</span>(
      obj.<span class="hljs-property">value</span>,
      <span class="hljs-string">`url(http://127.0.0.1:5000/font/<span class="hljs-subst">${obj.value}</span>?text=<span class="hljs-subst">${text}</span>&amp;format=woff2)`</span>
    );
    <span class="hljs-comment">// 加载字体</span>
    font.<span class="hljs-title function_">load</span>();
    <span class="hljs-comment">// 添加到文档字体集中</span>
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">fonts</span>.<span class="hljs-title function_">add</span>(font);
  }
});
<span class="hljs-comment">// 文档所有字体加载完毕后返回成功的 Promise</span>
<span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-property">fonts</span>.<span class="hljs-property">ready</span>.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Toast</span>.<span class="hljs-title function_">destory</span>());
</code></pre>
<p>好了，刷新下浏览器，来看看最终的效果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf3a903e4b0f40108f561e70e1dde27c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="" loading="lazy"></p>
<p>这这 真立竿见影（主要是基数大😁😁），最终得到的结果就是，实际 <strong>22.4M</strong> 的字体文件，子集化后缩减到 <strong>3.6KB</strong>。实际效果图生成的时间由 <strong>20s+</strong> 缩减到毫秒级（<strong>300ms</strong> 以内）。这下就无惧网速了吧！</p>
<h2 data-id="heading-5">结语</h2>
<p>总的来说，优化字体加载的方案有很多，我们需要结合自己的实际业务场景来进行选型，字体子集化确实是一种高效且实用的优化手段，更多的实践思路可以参考下 <a title="" ref="nofollow noopener noreferrer" href="https://link.juejin.cn?target=">Google fonts</a>。</p></div></div>