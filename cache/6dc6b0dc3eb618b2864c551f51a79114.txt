
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hnzhengfy/p/18719503/Nginx_Practical4" title="发布于 2025-03-17 13:40">
    <span role="heading" aria-level="2">nginx 简单实践：负载均衡【nginx 实践系列之四】</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文为 nginx 简单实践系列文章之四，主要简单实践了：负载均衡，仅供参考。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2>〇、前言</h2>
<p>本文为 nginx 简单实践系列文章之四，主要简单实践了负载均衡，仅供参考。</p>
<p>关于 Nginx 基础，以及安装和配置详解，可以参考博主过往文章：</p>
<p><span style="font-size: 12px"><em><a title="https://www.cnblogs.com/hnzhengfy/p/Nginx.html" href="https://www.cnblogs.com/hnzhengfy/p/Nginx.html" target="_blank" rel="noopener">https://www.cnblogs.com/hnzhengfy/p/Nginx.html</a>&nbsp;</em></span></p>
<p><span style="font-size: 12px"><strong><em>注意：可以使用测试域名，但前提是要修改 hosts 文件。</em></strong></span></p>
<p><span style="font-size: 12px"><em>路径和重启：Linux（/etc/hosts）（重启命令：<span class="hljs-operator">/</span>etc<span class="hljs-operator">/</span>init.d<span class="hljs-operator">/</span>network restart）；Windows（C:\Windows\System32\drivers\etc\hosts）。</em></span></p>
<p><span style="font-size: 12px"><em>例如：192.168.1.1 www.testczzj.com</em></span></p>
<h2>一、关于负载均衡</h2>
<h3>1.1 简介</h3>
<p><strong>负载均衡（Load Balance，简称 LB）</strong>是高并发、高可用系统必不可少的关键组件，目标是<strong>尽力将网络流量平均分发</strong>到多个服务器上，以提高系统整体的响应速度和可用性。</p>
<p>主要的作用：</p>
<ul>
<li><strong>高并发：</strong>负载均衡通过算法调整负载，<strong>尽力均匀的分配</strong>应用集群中各节点的工作量，以此提高应用集群的并发处理能力（吞吐量）。</li>
<li><strong>伸缩性：</strong>添加或减少服务器数量，然后由负载均衡进行分发控制。这使得应用集群具备伸缩性。</li>
<li><strong>高可用：</strong>负载均衡器可以<strong>监控候选服务器</strong>，当服务器不可用时，自动跳过，将请求分发给可用的服务器。这使得应用集群具备高可用的特性。</li>
<li><strong>安全防护：</strong>有些负载均衡软件或硬件提供了安全性功能，如：黑白名单处理、防火墙，防 DDos 攻击等。</li>
</ul>
<h3>1.2 载体维度分类：硬件</h3>
<p>硬件负载均衡，一般是在定制处理器上运行的，<strong>独立负载均衡服务器</strong>，<strong>价格昂贵</strong>。</p>
<p>硬件负载均衡的主流产品有:F5 和 A10。F5 拥有更广泛的附加功能和服务，而 A10 则在某些特定领域如 IPv6 转换或 SSL 检查方面表现出色。</p>
<p>优点：</p>
<ul>
<li>功能强大：支持全局负载均衡并提供较全面的、复杂的负载均衡算法。</li>
<li>性能强悍：硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。</li>
<li>安全性高：往往具备防火墙，防 DDos 攻击等安全功能。</li>
</ul>
<p>缺点：</p>
<ul>
<li>成本昂贵：购买和维护硬件负载均衡的成本都很高。</li>
<li>扩展性差：当访问量突增时，超过限度不能动态扩容。</li>
</ul>
<h3>1.3&nbsp;载体维度分类：软件</h3>
<p>软件负载均衡是指，<strong>使用软件工具或解决方案来分配网络流量或计算任务到多个服务器</strong>，以实现资源的有效利用、提高系统性能和增强服务的可用性。</p>
<p>与硬件负载均衡器相比，软件负载均衡<strong>更加灵活、成本效益更高，并且可以轻松部署在标准的服务器硬件上</strong>。</p>
<p>软件负载均衡通常位于客户端和服务器之间，它接收来自客户端的请求，并根据预先设定的算法决定将这些请求转发到哪一个后端服务器。通过这种方式，它可以确保工作负载均匀分布，避免任何单一服务器过载。</p>
<p>优点：</p>
<ul>
<li>扩展性好：适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。</li>
<li>成本低廉：软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能略差：相比于硬件负载均衡，软件负载均衡的性能要略低一些。</li>
</ul>
<h3>1.4 网络通信分类：七层负载均衡</h3>
<h4>1.4.1 DNS 负载均衡</h4>
<p><strong>DNS（Domain Name System 域名解析系统）负载均衡一般用于互联网公司，复杂的业务系统不适合使用。大型网站一般使用 DNS 负载均衡作为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。</strong></p>
<p>什么是 DNS？它是 OSI 第七层网络协议。DNS 被设计为一个树形结构的分布式应用，自上而下依次为：权威服务器，顶级服务器，根域名服务器，递归服务器，本地DNS服务器。</p>
<p>下边简单列举下：</p>
<table style="border-collapse: collapse; width: 100%; height: 126px" border="1">
<tbody>
<tr style="height: 21px">
<td style="width: 23.6364%; height: 21px">DNS服务器的种类</td>
<td style="width: 31.1262%; height: 21px">&nbsp;</td>
<td style="width: 45.1839%; height: 21px">&nbsp;</td>
</tr>
<tr style="height: 21px">
<td style="width: 23.6364%; height: 21px">本地DNS服务器<br>（Local DNS Server）</td>
<td style="width: 31.1262%; height: 21px">通常是用户设备或网络中的默认 DNS 服务器，它接收用户的 DNS 查询请求。</td>
<td style="width: 45.1839%; height: 21px">首先检查自己的缓存中是否已有该域名的对应IP地址。如果有，直接返回结果；如果没有，则向上级 DNS 服务器发送查询请求。</td>
</tr>
<tr style="height: 21px">
<td style="width: 23.6364%; height: 21px">递归域名服务器<br>（Recursive DNS Server）</td>
<td style="width: 31.1262%; height: 21px">主要任务是代表客户端执行完整的解析过程，从而简化了客户端的工作流程。</td>
<td style="width: 45.1839%; height: 21px">通过递归方式完成查询。这意味着如果本地没有所需的信息，它会依次向根域名服务器、顶级域名服务器以及权威域名服务器发起查询，直到找到目标域名对应的 IP 地址。</td>
</tr>
<tr style="height: 21px">
<td style="width: 23.6364%; height: 21px">根域名服务器<br>（Root DNS Server）</td>
<td style="width: 31.1262%; height: 21px">是整个 DNS 系统的最顶层，提供顶级域名（TLD）服务器的信息。</td>
<td style="width: 45.1839%; height: 21px">当本地 DNS 服务器无法在缓存中找到答案时，它会向根域名服务器发出查询请求。根域名服务器不会直接提供最终的 IP 地址，而是返回负责特定顶级域名（如 .com、.org 等）的顶级域名服务器的地址。</td>
</tr>
<tr style="height: 21px">
<td style="width: 23.6364%; height: 21px">顶级域名服务器<br>（Top-Level Domain DNS Server, TLD Server）</td>
<td style="width: 31.1262%; height: 21px">管理特定顶级域名下的所有子域名信息。</td>
<td style="width: 45.1839%; height: 21px">根据来自本地 DNS 服务器的请求，顶级域名服务器会提供负责特定二级域名（例如 example.com 中的 example 部分）的权威域名服务器的地址。</td>
</tr>
<tr style="height: 21px">
<td style="width: 23.6364%; height: 21px">权威域名服务器<br>（Authoritative DNS Server）</td>
<td style="width: 31.1262%; height: 21px">存储并维护特定域名的实际 DNS 记录，包括 A 记录（指向IPv4地址）、AAAA 记录（指向 IPv6 地址）、MX 记录（邮件服务器信息）等。</td>
<td style="width: 45.1839%; height: 21px">这是最后一个层级的 DNS 服务器，它能提供所查询域名的确切 IP 地址或其他所需信息。一旦本地 DNS 服务器接收到权威域名服务器提供的答案，就会将该信息返回给客户端，并且通常会在本地缓存一段时间以供后续查询使用。</td>
</tr>
</tbody>
</table>
<p>DNS 负载均衡的工作原理就是：<strong>基于 DNS 查询缓存，按照负载情况返回不同服务器的 IP 地址。</strong></p>
<p>如下图，针对服务集群中的两个服务地址 127.0.0.1、127.0.0.2，在 DNS 服务器中都配置为指向域名 www.xxx.com，当用户通过域名访问时，请求到 DNS 服务器，然后随机返回一个实际请求的服务器 IP 地址。</p>
<p><strong><img src="https://img2024.cnblogs.com/blog/1868241/202503/1868241-20250310135638180-353314104.png"></strong></p>
<p>优点：</p>
<p><strong>简易部署与管理：</strong>无需改变应用程序的代码，仅通过配置DNS即可实现负载分发，简化了服务器集群的管理。<br><strong>地理分布优化：</strong>支持基于地理位置的流量分配，能够将用户请求定向到距离最近的数据中心或服务器，从而减少延迟，提高访问速度。<br><strong>扩展性强：</strong>可以轻松地向服务器池中添加新的服务器，以应对增加的流量需求，提高了系统的可伸缩性。<br><strong>成本效益高：</strong>通过更有效的资源利用减少了硬件投资和运营成本。</p>
<p>缺点：</p>
<p><strong>缓存问题：</strong>由于DNS解析结果会被客户端及中间DNS服务器缓存，当某个服务器出现故障时，已缓存该服务器IP地址的用户仍然可能被导向至故障服务器，直到缓存过期。这可能导致服务中断或性能下降。<br><strong>负载平衡精度有限：</strong>DNS负载均衡通常基于简单的算法（如轮询）进行分配，无法实时感知各服务器的实际负载情况，导致负载分配不够精准。<br><strong>安全性考虑：</strong>尽管DNSSEC等技术增强了DNS的安全性，但DNS本身仍可能存在被攻击的风险，例如DDoS攻击，可能会对整个系统造成影响。<br><strong>不支持会话持久化：</strong>如果应用需要保持用户的会话状态，单纯的DNS负载均衡无法保证用户在多次请求间总是被导向到同一台服务器，除非结合其他机制来实现。</p>
<p>虽然 DNS 负载均衡提供了一种简单且有效的方法来分散网络流量，但它也存在一定的局限性。因此，在实际应用中，<strong>常常需要结合使用其他技术和策略，如健康检查、自动故障转移以及会话保持机制等</strong>，以克服其固有的不足。</p>
<p>&nbsp;</p>
<h4>1.4.2 HTTP 负载均衡</h4>
<p>HTTP 负载均衡是基于 HTTP 重定向实现的。HTTP 负载均衡属于七层负载均衡。</p>
<p>HTTP 重定向原理是：根据用户的 HTTP 请求计算出一个真实的服务器地址，将该服务器地址写入 HTTP 重定向响应中，返回给浏览器，由浏览器重新进行访问。</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202503/1868241-20250310141452044-457542813.png"></p>
<p>优点：</p>
<p>高可用性和可靠性：即使某台服务器发生故障，负载均衡器也能自动将流量分配到其他健康的服务器上，从而保证服务的连续性。<br>扩展性：可以轻松添加更多的服务器到池中以应对增加的负载，提高了系统的可伸缩性。<br>性能提升：通过智能地选择最佳的服务器来处理每个请求，可以减少响应时间和提高用户体验。<br>安全性增强：负载均衡器可以充当额外的安全层，提供诸如 SSL 终止、DDoS 防护等功能，保护后端服务器免受攻击。<br>会话持久化支持：一些高级负载均衡器支持会话持久化功能，确保用户在整个会话过程中总是被导向到同一台服务器。</p>
<p>缺点：</p>
<p><strong>性能较差：</strong>每次访问需要两次请求服务器，增加了访问的延迟。<br><strong>降低搜索排名：使用重定向后，搜索引擎会视为 SEO 作弊。</strong><br>复杂性和成本：实现和维护 HTTP 负载均衡需要一定的技术知识和投入，包括硬件成本、软件许可证费用以及维护成本。<br>单点故障风险：如果负载均衡器本身出现故障，则可能导致整个系统不可用。虽然可以通过设置主备负载均衡器来缓解这一问题，但这增加了架构的复杂度。<br>潜在的瓶颈：在高并发情况下，如果负载均衡器本身的处理能力不足，可能会成为系统的瓶颈。</p>
<p>由于其缺点比较明显，所以这种负载均衡策略实际应用较少。</p>
<p>&nbsp;</p>
<h4>1.4.3 反向代理</h4>
<p>反向代理（Reverse Proxy）方式是指以&nbsp;代理服务器&nbsp;来接受网络请求，然后&nbsp;将请求转发给内网中的服务器，并将从内网中的服务器上得到的结果返回给网络请求的客户端。反向代理负载均衡属于七层负载均衡。</p>
<p>反向代理服务的主流产品：<strong>Nginx、Apache</strong>。</p>
<p>如下图，看下 Nginx 如何实现负载均衡：</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202503/1868241-20250310141854205-554807687.png"></p>
<p>首先，在代理服务器上设定好负载均衡规则。</p>
<p>然后，当收到客户端请求，反向代理服务器拦截指定的域名或 IP 请求，根据负载均衡算法，将请求分发到候选服务器上。</p>
<p>其次，如果某台候选服务器宕机，<strong>反向代理服务器会有容错处理</strong>，比如分发请求失败 3 次以上，将请求分发到其他候选服务器上。</p>
<p>优点：</p>
<p><strong>多种负载均衡算法：</strong>支持多种负载均衡算法，以应对不同的场景需求。<br><strong>可以监控服务器：</strong>基于 HTTP 协议，可以监控转发服务器的状态，如：系统负载、响应时间、是否可用、连接数、流量等，从而根据这些数据调整负载均衡的策略。</p>
<p>缺点：</p>
<p><strong>额外的转发开销：</strong>反向代理的转发操作本身是有性能开销的，可能会包括创建连接，等待连接响应，分析响应结果等操作。<br><strong>增加系统复杂度：</strong>反向代理常用于做分布式应用的水平扩展，但反向代理服务存在以下问题，为了解决以下问题会给系统整体增加额外的复杂度和运维成本。</p>
<p><strong>反向代理服务如果自身宕机，就无法访问站点，所以需要有高可用方案</strong>，常见的方案有：主备模式（一主一备）、双主模式（互为主备）。</p>
<p>反向代理服务自身也存在性能瓶颈，<strong>随着需要转发的请求量不断攀升，需要有可扩展方案</strong>。</p>
<h3>1.5 网络通信分类：四层负载均衡</h3>
<h4>1.5.1 IP 负载均衡</h4>
<p>IP 负载均衡是在网络层通过修改请求目的地址进行负载均衡。</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202503/1868241-20250310142811210-149277034.png"></p>
<p>如上图，大致流程为：</p>
<p>1. 客户端请求 192.168.137.10，由负载均衡服务器接收到报文。<br>2. 负载均衡服务器根据算法选出一个服务节点 192.168.0.1，然后将报文请求地址改为该节点的 IP。<br>3. 真实服务节点收到请求报文，处理后，返回响应数据到负载均衡服务器。<br>4. 负载均衡服务器将响应数据的源地址改负载均衡服务器地址，返回给客户端。</p>
<p>IP 负载均衡在内核进程完成数据分发，<strong>较反向代理负载均衡有更好的从处理性能</strong>。但是，由于所有请求响应都要经过负载均衡服务器，<strong>集群的吞吐量受制于负载均衡服务器的带宽</strong>。</p>
<h4>1.5.2 数据链路层通过修改 mac 地址来实现负载均衡</h4>
<p>数据链路层负载均衡是指，<strong>在通信协议的数据链路层修改 mac 地址</strong>进行负载均衡。</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202503/1868241-20250310150606426-1558045509.png"></p>
<p>在 Linux 平台上最好的链路层负载均衡开源产品是 LVS (Linux Virtual Server)。</p>
<p>LVS 是基于 Linux 内核中 netfilter 框架实现的负载均衡系统。netfilter 是内核态的 Linux 防火墙机制，可以在数据包流经过程中，根据规则设置若干个关卡（hook 函数）来执行相关的操作。</p>
<p>LVS 的工作流程大致如下：</p>
<p>1. 客户端请求：当客户端发起一个请求到目标服务时，首先会到达 LVS 配置的虚拟 IP 地址（VIP），这个 VIP 对外代表了一个或多个实际提供服务的服务器集群。<br>2. 流量分发的四种模式：<br>&nbsp;1）IPVS 模块：LVS 的核心是运行在 Linux 内核中的 IPVS（IP Virtual Server）模块，它负责根据预设的负载均衡算法（如轮询、最少连接数等）将收到的请求分发给后端的真实服务器（Real Server, RS）。<br>&nbsp;2）直接路由模式（DR：Direct Routing）：在此模式下，LVS 简单地重写数据包的目标 MAC 地址为选定真实服务器的 MAC 地址，并将数据包发送回交换机，由交换机转发给真实服务器。这种方式不需要修改数据包的 IP 头部信息，因此效率很高。<br>&nbsp;3）NAT 模式（Network Address Translation）：在这种模式下，LVS 不仅改变目标 MAC 地址，还会修改目标 IP 地址为目标服务器的实际 IP 地址，并且处理来自真实服务器的响应，将其源 IP 地址改为 VIP 后再返回给客户端。此方法适用于真实服务器位于私有网络的情况。<br>&nbsp;4）隧道模式（Tunnel：Tunneling）：通过将原始请求封装在 IP 隧道中发送给真实服务器，允许真实服务器位于不同的物理位置，只要它们能够与 LVS 通信即可。<br>3. 真实服务器处理请求：被选中的真实服务器接收到请求后进行处理，并直接将响应发送回客户端（在直接路由和隧道模式下），或者通过 LVS 返回给客户端（在 NAT 模式下）。<br>4. 健康检查：LVS通常结合外部工具（如keepalived）来进行真实服务器的健康检查。如果某个真实服务器不可用，LVS将停止向其分配新的请求，直到它恢复正常。</p>
<h3>1.6 负载均衡算法简介</h3>
<p>负载均衡器的实现可以分为两个部分：首先通过负载均衡算法在候选服务器列表选出一个服务器;然后，将请求数据发送到该服务器上。</p>
<p>负载均衡算法是负载均衡服务核心中的核心。</p>
<p>负载均衡产品多种多样，但是各种负载均衡算法原理是共性的。负载均衡算法有很多种，分别适用于不同的应用场景，常用的有：轮询、随机、最小活跃数、源地址哈希、一致性哈希等等，下文将逐个简单介绍。</p>
<ul>
<li><strong>随机算法（Random）</strong></li>
</ul>
<p>随机算法将请求随机分发到候选服务器。更适合服务器硬件相同的场景。当调用量较小的时候，可能负载并不均匀，调用量越大，负载越均衡。</p>
<ul>
<li><strong>加权随机算法（Weighted Random）</strong></li>
</ul>
<p>加权随机算法在随机算法的基础上，按照概率调整权重，进行负载分配。</p>
<ul>
<li><strong>轮询算法（Round Robin）</strong></li>
</ul>
<p>轮询算法的策略是：将请求依次分发到候选服务器。</p>
<p>该算法适合场景：各服务器处理能力相近，且每个事务工作量差异不大。如果存在较大差异，那么处理较慢的服务器就可能会积压请求，最终无法承担过大的负载。</p>
<ul>
<li><strong>加权轮询算法（Weighted Round Robbin）</strong></li>
</ul>
<p>加权轮询算法在轮询算法的基础上，增加了权重属性来调节转发服务器的请求数目。</p>
<p>性能高、处理速度快的节点应该设置更高的权重，使得分发时优先将请求分发到权重较高的节点上。</p>
<ul>
<li><strong>最少连接数（Least Connections）</strong></li>
</ul>
<p>最少连接数算法将请求分发到连接数/请求数最少的候选服务器（目前处理请求最少的服务器）。</p>
<p>它是根据候选服务器当前的请求连接数，动态分配。</p>
<p>适用于<strong>对系统负载较为敏感或请求连接时长相差较大的场景</strong>。</p>
<p>由于每个请求的连接时长不一样，如果采用简单的轮循或随机算法，都可能出现某些服务器当前连接数过大，而另一些服务器的连接过小的情况，这就造成了负载并非真正均衡。虽然，轮询或随机算法都可以通过加权重属性的方式进行负载调整，<strong>但加权方式难以应对动态变化</strong>。</p>
<ul>
<li><strong>加权最少连接数（Weighted Least Connections）</strong></li>
</ul>
<p>结合了加权轮询和最少连接数的优点，在选择服务器时既考虑了服务器的当前连接数也考虑了其权重，<strong>使得更强大的服务器可以处理更多的请求</strong>。</p>
<ul>
<li><strong>源 IP 地址哈希（Source IP Hash）</strong></li>
</ul>
<p>根据客户端 IP 地址计算哈希值，并根据哈希结果选择服务器。</p>
<p>这种方式可以<strong>确保来自同一客户端的请求总是被发送到相同的服务器上</strong>，有助于保持会话状态的一致性，用来实现会话粘滞（Sticky Session）。</p>
<ul>
<li><strong>一致性哈希（Consistent Hash）</strong></li>
</ul>
<p>一致性哈希算法的目标是：相同的请求尽可能落到同一个服务器上。</p>
<p>一致性哈希可以很好的解决稳定性问题，可以将所有的存储节点排列在首尾相接的 Hash 环上，每个 key 在计算 Hash 后会顺时针找到临接的存储节点存放。而当有节点加入或退出时，仅影响该节点在 Hash 环上顺时针相邻的后续节点。</p>
<p>‘相同的请求’是指：一般在使用一致性哈希时，需要指定一个 key 用于 hash 计算，可能是：用户 ID、请求方 IP、请求服务名称、参数列表构成的串等等。</p>
<p>‘尽可能’是指：服务器可能发生上下线，少数服务器的变化不应该影响大多数的请求。当某台候选服务器宕机时，原本发往该服务器的请求，会基于虚拟节点，平摊到其它候选服务器，不会引起剧烈变动。</p>
<p>优点：加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</p>
<p>缺点：加减节点会造成哈希环中部分数据无法命中。当使用少量节点时，节点变化将大范围影响哈希环中数据映射，不适合少量数据节点的分布式方案。普通的一致性哈希分区在增减节点时需要增加一倍或减去一半节点才能保证数据和负载的均衡。</p>
<p><span style="font-size: 12px"><em>参考：<a title="https://blog.csdn.net/wanghangzhen/article/details/118554304" href="https://blog.csdn.net/wanghangzhen/article/details/118554304" target="_blank" rel="noopener nofollow">https://blog.csdn.net/wanghangzhen/article/details/118554304</a></em></span></p>
<h2>二、Nginx 的负载均衡简单测试</h2>
<h3>2.1 轮询【默认方式】</h3>
<p>轮询算法是默认的一种方式。</p>
<p><strong>当 nginx 接收到请求后，逐一分配到所配置的服务列表进行访问并返回。</strong></p>
<p><strong>当某个服务异常时，自动跳过，并不会导致请求失败。</strong></p>
<p>实例配置如下：</p>
<pre class="language-nginx highlighter-hljs"><code># 反向代理配置
upstream server_czzj {
    server www.testczzj.com:5001;
    server www.testczzj.com:5021;
    server www.testczzj.com:5031;
}

server {
    listen 8888;
    server_name www.testczzj.com;

    access_log  /var/log/nginx/access.log;
    error_log  /var/log/nginx/error.log;

    location / {
            index index.html index.htm;
            proxy_pass http://server_czzj; # 指定反向代理服务器列表
    }
}</code></pre>
<p>如下图，刷新同一地址，请求的服务不同：</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202503/1868241-20250312114716990-275615116.png"></p>
<h3>2.2 weight【权重】</h3>
<p>权重用于调整不同服务器之间请求分配比例。</p>
<p>它允许管理员根据每台服务器的实际处理能力和性能，来手动控制流量分配，从而优化资源利用和提高系统的整体效率。</p>
<p>通过合理设置权重，可以根据实际需求动态调整服务器之间的负载分布，不仅提高了系统的灵活性和可靠性，还能更好地应对突发流量和资源限制等问题。</p>
<p>配置示例：</p>
<pre class="language-nginx highlighter-hljs"><code># 反向代理配置
upstream server_czzj {
    server www.testczzj.com:5001 weight=1; # 默认为 1，可不配置
    server www.testczzj.com:5021 weight=3;
    server www.testczzj.com:5031 weight=6;
}</code></pre>
<p>解释：例如示例中的权重总量为 10，那么如果 nginx 接到十个请求，那么三个服务就分别接到 1、3、6 个请求。但是首次请求进入那个服务是不固定的，权重为 6 的服务概率最大。</p>
<p>实际效果就类似于：（但是顺序是随机的）</p>
<pre class="language-nginx highlighter-hljs"><code># 反向代理配置
upstream server_czzj {
    server www.testczzj.com:5001;
    server www.testczzj.com:5021;
    server www.testczzj.com:5021;
    server www.testczzj.com:5021;
    server www.testczzj.com:5031;
    server www.testczzj.com:5031;
    server www.testczzj.com:5031;
    server www.testczzj.com:5031;
    server www.testczzj.com:5031;
    server www.testczzj.com:5031;
}</code></pre>
<p>此策略比较适合<strong>服务器的硬件配置差别比较大</strong>的情况。</p>
<h3>2.3 ip_hash【基于客户端 IP 来分配】</h3>
<p>指定负载均衡器按照基于客户端 IP 的分配方式，这个方法<strong>确保了相同的客户端的请求一直发送到相同的服务器</strong>，以保证 session 会话。<strong>这样每个访客都固定访问一个后端服务器，可以解决 session 不能跨服务器的问题。</strong></p>
<p>Nginx 使用的 Jenkins hash 函数对输入数据（如 IP 地址）进行哈希计算，生成一个 32 位无符号整数作为哈希值。对于 IP 地址 127.0.0.1，经过 Jenkins hash 计算后，得到的哈希值为 879045407。</p>
<p>如果有三个服务且权重均为1，则通过哈希值对3取余，得到的 0、1、2 分别对应三个服务。</p>
<p>如果有多个权重不同的服务，则通过对权重总和的值取余，得到序号，对应到不同的服务上。</p>
<p>实例配置：</p>
<pre class="language-nginx highlighter-hljs"><code># 反向代理配置
upstream server_czzj {
    ip_hash; # 保证每个客户端访问同一个后端服务
    server www.testczzj.com:5001;
    server www.testczzj.com:5021;
    server www.testczzj.com:5031;
}</code></pre>
<p><em>注意：在 nginx 版本 1.3.1 之前，不能在 ip_hash 中使用权重（weight）。</em></p>
<p><em>ip_hash <strong>不能与 backup（配置备用服务）同时使用</strong>。</em></p>
<p><em>此策略适合有状态服务，比如 session。</em></p>
<p><em>当有服务器需要剔除，必须<strong>手动进行停服操作</strong>。</em></p>
<h3>2.4 least_conn【最少连接】</h3>
<p><strong>把请求转发给连接数较少的后端服务。</strong></p>
<p>轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，<strong>有些请求占用的时间很长，会导致其所在的后端负载较高</strong>。这种情况下，least_conn 这种方式就可以达到更好的负载均衡效果。</p>
<pre class="language-nginx highlighter-hljs"><code># 反向代理配置
upstream server_czzj {
    least_conn; # 把新的请求，转发到当前连接数最少的服务
    server www.testczzj.com:5001;
    server www.testczzj.com:5021;
    server www.testczzj.com:5031;
}</code></pre>
<p><strong>此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况。</strong></p>
<h3>2.5 第三方策略：fair【按照最短响应时间分配请求】</h3>
<p>此方式需要单独额外的配置，不能直接在 upstream 模块添加关键字 fair。</p>
<p><strong>大概的思路就是，下载补充包，通过 ./configure 命令，将模块添加到已安装的 nginx，重启下服务就可以使用关键字 fair 了。</strong></p>
<h4>2.5.1 配置步骤和示例</h4>
<p>1）先下载第三方包：<a title="https://github.com/gnosek/nginx-upstream-fair" href="https://github.com/gnosek/nginx-upstream-fair" target="_blank" rel="noopener nofollow">https://github.com/gnosek/nginx-upstream-fair</a></p>
<p>文件很简单，如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202503/1868241-20250314183822886-1621270948.png"></p>
<p>需要将此文件夹放到 linux 系统中，本示例复制到路径：/usr/local/nginx-upstream-fair-master。</p>
<p>2）进入 nginx 源文件所在的文件夹（即 nginx 安装包解压后的文件夹），本示例的是：/usr/local/nginx-1.20.0。</p>
<pre class="language-nginx highlighter-hljs"><code># 下载 nginx 包并解压
wget http://nginx.org/download/nginx-1.20.0.tar.gz
tar -zxf nginx-1.20.1.tar.gz &amp;&amp; cd nginx-1.20.0/
# 其他一些可能用到的依赖包（按需安装）
yum -y install gcc gcc-c++ openssl openssl-devel zlib zlib-devel pcre pcre-devel make cmake gperftools perl-devel  gd-devel libxml2 libxml2-dev libxslt-devel  redhat-rpm-config.noarch</code></pre>
<p><span style="font-size: 12px"><em>注意：如果源文件找不到了，需要重新下载一个相同版本安装包使用。</em></span></p>
<p>3）执行命令添加模块：</p>
<pre class="language-nginx highlighter-hljs"><code># 手动添加模块
./configure --add-module=/usr/local/nginx-upstream-fair-master
# 重新进行编译
[root@www nginx-1.20.0]# make
# 添加成功，注意 configure arguments 配置：
[root@www sbin]#  nginx -V
nginx version: nginx/1.20.0
built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) 
configure arguments: --add-module=/usr/local/nginx-upstream-fair-master</code></pre>
<p>4）然后先停止 nginx 服务，再将 nginx 进行复制：</p>
<pre class="language-nginx highlighter-hljs"><code># 先停止 nginx 服务
[root@www sbin]# ./nginx -s stop
# 复制 nginx
[root@www nginx-1.20.0]# cp -rp objs/nginx /usr/local/nginx/sbin/nginx
cp: overwrite ‘/usr/local/nginx/sbin/nginx’? yes
[root@www nginx-1.20.0]#</code></pre>
<p>最后，修改 nginx.conf 配置文件，开启服务测试一下。</p>
<p><strong>配置示例：</strong></p>
<pre class="language-nginx highlighter-hljs"><code># 反向代理配置
upstream server_czzj {
    fair; # 按照最短响应时间分配请求
    server www.testczzj.com:5001;
    server www.testczzj.com:5021;
    server www.testczzj.com:5031;
}</code></pre>
<h4>2.5.2 make 执行时报错：‘ngx_http_upstream_srv_conf_t’ has no member named ‘default_port’</h4>
<p>ngx_http_upstream_srv_conf_t’没有名为‘default_port’的成员。</p>
<pre class="language-nginx highlighter-hljs"><code># 具体提示：
/usr/local/nginx-upstream-fair-master/ngx_http_upstream_fair_module.c: In function ‘ngx_http_upstream_init_fair_rr’:
/usr/local/nginx-upstream-fair-master/ngx_http_upstream_fair_module.c:543:28: error: ‘ngx_http_upstream_srv_conf_t’ has no member named ‘default_port’
     if (us-&gt;port == 0 &amp;&amp; us-&gt;default_port == 0) {
                            ^
/usr/local/nginx-upstream-fair-master/ngx_http_upstream_fair_module.c:553:51: error: ‘ngx_http_upstream_srv_conf_t’ has no member named ‘default_port’
     u.port = (in_port_t) (us-&gt;port ? us-&gt;port : us-&gt;default_port);</code></pre>
<pre class="language-nginx highlighter-hljs"><code># 解决，执行如下命令即可：
# Linux: 
sed -i 's/default_port/no_port/g' /usr/local/nginx-upstream-fair-master/ngx_http_upstream_fair_module.c
# macOs: 
sed -i '' 's/default_port/no_port/g' /file/ngx_http_upstream_fair_module.c</code></pre>
<p><span style="font-size: 12px"><em>参考：<a title="https://blog.csdn.net/weixin_46152207/article/details/121786162" href="https://blog.csdn.net/weixin_46152207/article/details/121786162" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_46152207/article/details/121786162</a></em></span></p>
<h3>2.6 第三方策略：url_hash【按访问url的hash结果来分配请求】</h3>
<p>此方式需要单独额外的配置，不能直接在 upstream 模块添加关键字 url_hash。</p>
<p><strong>大概的思路就是，下载补充包，通过 ./configure 命令，将模块添加到已安装的 nginx，重启下服务就可以使用关键字 fair 了。</strong></p>
<p>1）先下载第三方包：<a title="https://github.com/evanmiller/nginx_upstream_hash" href="https://github.com/evanmiller/nginx_upstream_hash" target="_blank" rel="noopener nofollow">https://github.com/evanmiller/nginx_upstream_hash</a></p>
<p>文件很简单，如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202503/1868241-20250317105132161-904634937.png"></p>
<p>需要将此文件夹放到 linux 系统中，本示例复制到路径：/usr/local/nginx_upstream_hash-master。</p>
<p>2）进入 nginx 源文件所在的文件夹（即 nginx 安装包解压后的文件夹），本示例的是：/usr/local/nginx-1.20.0。</p>
<p><span style="font-size: 12px"><em>注意：如果源文件找不到了，需要重新下载一个相同版本安装包使用。</em></span></p>
<pre class="language-nginx highlighter-hljs"><code># 下载 nginx 包并解压
wget http://nginx.org/download/nginx-1.20.0.tar.gz
tar -zxf nginx-1.20.1.tar.gz &amp;&amp; cd nginx-1.20.0/
# 其他一些可能用到的依赖包（按需安装）
yum -y install gcc gcc-c++ openssl openssl-devel zlib zlib-devel pcre pcre-devel make cmake gperftools perl-devel  gd-devel libxml2 libxml2-dev libxslt-devel  redhat-rpm-config.noarch</code></pre>
<p>3）执行命令添加模块：</p>
<pre class="language-nginx highlighter-hljs"><code># 手动添加模块
[root@www nginx-1.20.0]# ./configure --add-module=/usr/local/nginx_upstream_hash-master
# 重新进行编译
[root@www nginx-1.20.0]# make
# 添加成功，查看配置，注意 configure arguments 配置：
[root@www nginx-1.20.0]# nginx -V
nginx version: nginx/1.20.0
built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) 
configure arguments: --add-module=/usr/local/nginx_upstream_hash-master</code></pre>
<p>4）然后先停止 nginx 服务，再将 nginx 进行复制：</p>
<pre class="language-nginx highlighter-hljs"><code># 先停止 nginx 服务
[root@www sbin]# ./nginx -s stop
# 复制 nginx
[root@www nginx-1.20.0]# cp -rp objs/nginx /usr/local/nginx/sbin/nginx
cp: overwrite ‘/usr/local/nginx/sbin/nginx’? yes
[root@www nginx-1.20.0]#</code></pre>
<p>最后，修改 nginx.conf 配置文件，开启服务测试一下。</p>
<p><strong>配置示例：</strong></p>
<pre class="language-nginx highlighter-hljs"><code># 反向代理配置
upstream server_czzj {
    hash $request_uri; # 相同的 url 定向到同一后端服务器
    # hash $remote_addr; # 也可根据客户端 IP 映射
    # hash $args; # 也可根据客户端携带的参数进行映射
    server www.testczzj.com:5001;
    server www.testczzj.com:5021;
    server www.testczzj.com:5031;
}</code></pre>
<p>配置完成后就可以实现，相同的 url 请求到同一个服务。</p>
<p>另外，当某一个服务异常停止后，原来通过 hash 对应到此服务的请求，会自动对应到其他服务，并不会造成请求失败。</p>
<h3>2.7 第三方策略：consistent_hash【采用一致性哈希算法结果来分配请求】</h3>
<p>此方式需要单独额外的配置，不能直接在 upstream 模块添加关键字 consistent_hash。</p>
<p><strong>大概的思路就是，下载补充包，通过 ./configure 命令，将模块添加到已安装的 nginx，重启下服务就可以使用关键字 consistent_hash了。</strong></p>
<p>1）先下载第三方包：<a title="https://github.com/replay/ngx_http_consistent_hash" href="https://github.com/replay/ngx_http_consistent_hash" target="_blank" rel="noopener nofollow">https://github.com/replay/ngx_http_consistent_hash</a></p>
<p>文件很简单，如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/1868241/202503/1868241-20250317113652384-1402516390.png"></p>
<p>需要将此文件夹放到 linux 系统中，<strong>本示例复制到路径：/usr/local/ngx_http_consistent_hash-master。</strong></p>
<p>2）进入 nginx 源文件所在的文件夹（即 nginx 安装包解压后的文件夹），本示例的是：/usr/local/nginx-1.20.0。</p>
<p><span style="font-size: 12px"><em>注意：如果源文件找不到了，需要重新下载一个相同版本安装包使用。</em></span></p>
<pre class="language-nginx highlighter-hljs"><code># 下载 nginx 包并解压
wget http://nginx.org/download/nginx-1.20.0.tar.gz
tar -zxf nginx-1.20.1.tar.gz &amp;&amp; cd nginx-1.20.0/
# 其他一些可能用到的依赖包（按需安装）
yum -y install gcc gcc-c++ openssl openssl-devel zlib zlib-devel pcre pcre-devel make cmake gperftools perl-devel  gd-devel libxml2 libxml2-dev libxslt-devel  redhat-rpm-config.noarch</code></pre>
<p>3）执行命令添加模块：</p>
<pre class="language-nginx highlighter-hljs"><code># 手动添加模块
./configure --add-module=/usr/local/ngx_http_consistent_hash-master
# 重新进行编译
[root@www nginx-1.20.0]# make
# 添加成功，查看配置，注意 configure arguments 配置：
[root@www nginx-1.20.0]# nginx -V
nginx version: nginx/1.20.0
built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) 
configure arguments: --add-module=/usr/local/ngx_http_consistent_hash-master</code></pre>
<p>4）然后先停止 nginx 服务，再将 nginx 进行复制：</p>
<pre class="language-nginx highlighter-hljs"><code># 先停止 nginx 服务
[root@www sbin]# ./nginx -s stop
# 复制 nginx
[root@www nginx-1.20.0]# cp -rp objs/nginx /usr/local/nginx/sbin/nginx
cp: overwrite ‘/usr/local/nginx/sbin/nginx’? yes
[root@www nginx-1.20.0]#</code></pre>
<p>最后，修改 nginx.conf 配置文件，开启服务测试一下。</p>
<p><strong>配置示例：</strong></p>
<pre class="language-nginx highlighter-hljs"><code># 反向代理配置
upstream server_czzj {
    consistent_hash $request_uri; # 一致性哈希算法
    # consistent_hash $remote_addr; # 也可根据客户端 IP 映射
    # consistent_hash $args; # 也可根据客户端携带的参数进行映射
    server www.testczzj.com:5001;
    server www.testczzj.com:5021;
    server www.testczzj.com:5031;
}</code></pre>
<p><span style="font-size: 12px"><em>参考：<a title="https://www.cnblogs.com/1214804270hacker/p/9325150.html" href="https://www.cnblogs.com/1214804270hacker/p/9325150.html" target="_blank" rel="noopener">https://www.cnblogs.com/1214804270hacker/p/9325150.html</a></em></span></p>
<p><span style="font-size: 12px"><em><a title="https://blog.csdn.net/zpf1813763637/article/details/109455451" href="https://blog.csdn.net/zpf1813763637/article/details/109455451" target="_blank" rel="noopener nofollow">https://blog.csdn.net/zpf1813763637/article/details/109455451</a></em></span></p>
</div>
<div id="MySignature" role="contentinfo">
    <img src="https://images.cnblogs.com/cnblogs_com/blogs/683398/galleries/2417207/o_221441c4.png">
<p>本文来自博客园，作者：<a href="https://www.cnblogs.com/hnzhengfy/" target="_blank">橙子家</a>，欢迎微信扫码关注博主【橙子家czzj】，有任何疑问欢迎沟通，共同成长！</p>
<div><p style="float: left;">转载本文请注明原文链接：<a href="https://www.cnblogs.com/hnzhengfy/p/18719503/Nginx_Practical4" target="_blank">https://www.cnblogs.com/hnzhengfy/p/18719503/Nginx_Practical4</a></p></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4932111184895833" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-17 14:30">2025-03-17 13:40</span>&nbsp;
<a href="https://www.cnblogs.com/hnzhengfy">橙子家</a>&nbsp;
阅读(<span id="post_view_count">253</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18719503" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18719503);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18719503', targetLink: 'https://www.cnblogs.com/hnzhengfy/p/18719503/Nginx_Practical4', title: 'nginx 简单实践：负载均衡【nginx 实践系列之四】' })">举报</a>
</div>
        