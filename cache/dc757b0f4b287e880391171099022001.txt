
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/edisontalk/p/-/quick-start-agent-orchestration-agentgroupchat" title="发布于 2025-07-10 19:55">
    <span role="heading" aria-level="2">多Agent协作入门：群组聊天-AgentGroupChat</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/381412/202507/381412-20250710195417464-1243651660.png" alt="多Agent协作入门：群组聊天-AgentGroupChat" class="desc_img">
        本文介绍了如何通过Semantic Kernel提供的AgentGroupChat来实现多Agent的协作，其中最要的部分就是定义选择轮次策略 和 终止聊天策略，相信通过这个案例你能够有个感性的认识。当然，除了群组聊天模式之外，多Agent协作还有很多其他的方式（比如 并行、顺序、移交、磁性等等），也还有不同的框架实现（如AutoGen），这就留到后面一一介绍给你，因为我也还在学。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>大家好，我是Edison。</p>
<p>近日抽空学习了下Semantic Kernel提供的AgentGroupChat对象写了一个多Agent群组对话的Demo，总结一下分享与你。当然，多Agent协作还有其他的方式，就留到后续慢慢介绍给你。</p>
<h1><strong>AgentChat是什么鬼？</strong></h1>
<p>在Semantic Kernel中，AgentChat提供了一个框架，可以启用多个代理之间的交互，即使它们属于不同类型的代理。 这使得 ChatCompletionAgent和 OpenAIAssistantAgent 可以在同一对话中协同工作。 AgentChat还定义了用于启动代理之间协作的入口点，无论是通过多个响应还是单个代理响应。</p>
<p>在实现层面，AgentGroupChat&nbsp;提供了 AgentChat 的具体实现，它是使用基于策略的方法来管理聊天的动态。</p>
<p><img src="https://img2024.cnblogs.com/blog/381412/202507/381412-20250710193903823-1121177532.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<h1><strong><span data-pm-slice="0 0 []">快速入门案例</span></strong></h1>
<p>这里我们来快速实现一个案例：Reviewer &amp; Writer，让这两个不同功能的Agent能够相互配合协作，完成一个指定的功能：</p>
<p>（1）Reviewer 可以审核用户输入的文案并给出优化建议；</p>
<p>（2）Writer 则根据优化建议进行文案的优化创作；</p>
<p>为了简单地实现这个功能，我们创建一个.NET控制台项目，然后安装以下包：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">Microsoft.Extensions.Configuration
Microsoft.Extensions.Configuration.Json
Microsoft.SemanticKernel.Agents.Core
Microsoft.SemanticKernel.Agents.OpenAI (Preview版本）</span></pre>
</div>
<p>需要注意的是，由于Semantic Kernel的较多功能目前还处于实验预览阶段，所以建议在该项目的csproj文件中加入以下配置，统一取消警告：</p>
<div class="cnblogs_code">
<pre>&lt;PropertyGroup&gt;
  &lt;NoWarn&gt;$(NoWarn);CA2007;IDE1006;SKEXP0001;SKEXP0110;OPENAI001&lt;/NoWarn&gt;
&lt;/PropertyGroup&gt;</pre>
</div>
<p>创建一个appsettings.json配置文件，填入以下关于LLM API的配置，其中API_KEY请输入你自己的：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">{
  </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">LLM</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">: 
  {
    </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">BASE_URL</span><span style="color: rgba(128, 0, 0, 1)">"</span>: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">https://api.siliconflow.cn</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
    </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">API_KEY</span><span style="color: rgba(128, 0, 0, 1)">"</span>: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">******************************</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
    </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">MODEL_ID</span><span style="color: rgba(128, 0, 0, 1)">"</span>: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Qwen/Qwen2.5-32B-Instruct</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
  }
}</span></pre>
</div>
<p data-pm-slice="0 0 []"><span>这里我们使用SiliconCloud提供<span>的<span>&nbsp;<span class="code-snippet__string">Qwen2.5-32B-Instruct<span>&nbsp;<span>模型，你<span>可以通过：<a href="https://cloud.siliconflow.cn/i/DomqCefW" target="_blank" rel="noopener nofollow">https://cloud.siliconflow.cn/i/DomqCefW</a> 注册一个账号，<span>获取大量免费的Token来来进行这个DEMO实验。</span></span></span></span></span></span></span></span></p>
<p data-pm-slice="0 0 []"><span>有了LLM API，我们可以创建一个Kernel供后续使用，这也是老面孔了：</span></p>
<div class="cnblogs_code">
<pre>Console.WriteLine(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Now loading the configuration...</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 0, 255, 1)">var</span> config = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ConfigurationBuilder()
    .AddJsonFile($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">appsettings.json</span><span style="color: rgba(128, 0, 0, 1)">"</span>, optional: <span style="color: rgba(0, 0, 255, 1)">false</span>, reloadOnChange: <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">)
    .Build();
Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Now loading the chat client...</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 0, 255, 1)">var</span> chattingApiConfiguration = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> OpenAiConfiguration(
    config.GetSection(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">LLM:MODEL_ID</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">).Value,
    config.GetSection(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">LLM:BASE_URL</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">).Value,
    config.GetSection(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">LLM:API_KEY</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">).Value);
</span><span style="color: rgba(0, 0, 255, 1)">var</span> openAiChattingClient = <span style="color: rgba(0, 0, 255, 1)">new</span> HttpClient(<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> OpenAiHttpHandler(chattingApiConfiguration.EndPoint));
</span><span style="color: rgba(0, 0, 255, 1)">var</span> kernel =<span style="color: rgba(0, 0, 0, 1)"> Kernel.CreateBuilder()
    .AddOpenAIChatCompletion(chattingApiConfiguration.ModelId, chattingApiConfiguration.ApiKey, httpClient: openAiChattingClient)
    .Build();</span></pre>
</div>
<p><span><span>接下来，我们就一步一步地来看看核心的代码。</span></span></p>
<h1><span>定义两个Agent</span></h1>
<p><span><span>这里我们来定义两个Agent：Reviewer &amp; Writer:</span></span></p>
<p><span><span>（1）<strong>Reviewer</strong></span></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> ReviewerAgent
{
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">string</span> AgentName = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Reviewer</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span><span style="color: rgba(0, 0, 0, 1)"> ChatCompletionAgent Build(Kernel kernel)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> toolKernel =<span style="color: rgba(0, 0, 0, 1)"> kernel.Clone();
        toolKernel.Plugins.AddFromType</span>&lt;ClipboardAccessPlugin&gt;<span style="color: rgba(0, 0, 0, 1)">();
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> reviewerAgent = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ChatCompletionAgent()
        {
            Name </span>=<span style="color: rgba(0, 0, 0, 1)"> AgentName,
            Instructions </span>=
                <span style="color: rgba(128, 0, 0, 1)">"""
</span>                Your responsibility <span style="color: rgba(0, 0, 255, 1)">is</span><span style="color: rgba(0, 0, 0, 1)"> to review and identify how to improve user provided content.
                If the user has providing input or direction </span><span style="color: rgba(0, 0, 255, 1)">for</span> content already provided, specify how to address <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)"> input.
                Never directly perform the correction or provide example.
                Once the content has been updated </span><span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> a subsequent response, you will review the content again until satisfactory.
                Always copy satisfactory content to the clipboard </span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> available tools and inform user.
                RULES:
                </span>-<span style="color: rgba(0, 0, 0, 1)"> Only identify suggestions that are specific and actionable.
                </span>-<span style="color: rgba(0, 0, 0, 1)"> Verify previous suggestions have been addressed.
                </span>-<span style="color: rgba(0, 0, 0, 1)"> Never repeat previous suggestions.
                </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">,</span>
            Kernel =<span style="color: rgba(0, 0, 0, 1)"> toolKernel,
            Arguments </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> KernelArguments(
                </span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> OpenAIPromptExecutionSettings()
                {
                    FunctionChoiceBehavior </span>=<span style="color: rgba(0, 0, 0, 1)"> FunctionChoiceBehavior.Auto()
                })
        };
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> reviewerAgent;
    }
}</span></pre>
</div>
<p><span><span>（2）<strong>Writer</strong></span></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> WriterAgent
{
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">string</span> AgentName = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Writer</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span><span style="color: rgba(0, 0, 0, 1)"> ChatCompletionAgent Build(Kernel kernel)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> writerAgent = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ChatCompletionAgent()
        {
            Name </span>=<span style="color: rgba(0, 0, 0, 1)"> AgentName,
            Instructions </span>=
                <span style="color: rgba(128, 0, 0, 1)">"""
</span>                Your sole responsibility <span style="color: rgba(0, 0, 255, 1)">is</span><span style="color: rgba(0, 0, 0, 1)"> to rewrite content according to review suggestions.
                </span>-<span style="color: rgba(0, 0, 0, 1)"> Always apply all review direction.
                </span>- Always revise the content <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> its entirety without explanation.
                </span>-<span style="color: rgba(0, 0, 0, 1)"> Never address the user.
                </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">,</span>
            Kernel =<span style="color: rgba(0, 0, 0, 1)"> kernel
        };
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> writerAgent;
    }
}</span></pre>
</div>
<p>这里可以通过静态方法直接Build出来两个Agent实例：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Initialize Reviewer Agent</span>
Console.WriteLine(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Now loading the Reviewer Agent...</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 0, 255, 1)">var</span> reviewerAgent =<span style="color: rgba(0, 0, 0, 1)"> ReviewerAgent.Build(kernel);
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Initialize Writer Agent</span>
Console.WriteLine(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Now loading the Writer Agent...</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 0, 255, 1)">var</span> writerAgent = WriterAgent.Build(kernel);</pre>
</div>
<h1>定义选择策略 和 终止策略</h1>
<p><span><span>对于多Agent协作，在AgentGroupChat中需要定义选择Agent轮次的策略（即SelectionStrategy）和 终止聊天循环的策略（即TerminationStrategy）。我们可以通过使用 AgentGroupChat.CreatePromptFunctionForStrategy 来轻松地实现，它提供了一种方便的机制，避免了对消息参数进行HTML编码：</span></span></p>
<p><span><span>（1）<strong>SelectionStrategy</strong></span></span></p>
<p>所谓选择策略，就是如何定义下一个发言的是谁，或者谁来接龙。这里我们首先让Reviewer评估用户输入的内容，如果觉得需要优化，就给出建议，下一个就轮到Writer来进行优化内容协作。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Define Selection Policy</span>
<span style="color: rgba(0, 0, 255, 1)">var</span> selectionFunction =<span style="color: rgba(0, 0, 0, 1)">
    AgentGroupChat.CreatePromptFunctionForStrategy(
        $$$</span><span style="color: rgba(128, 0, 0, 1)">"""
</span><span style="color: rgba(0, 0, 0, 1)">        Examine the provided RESPONSE and choose the next participant.
        State only the name of the chosen participant without explanation.
        Never choose the participant named </span><span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> the RESPONSE.
        Choose only </span><span style="color: rgba(0, 0, 255, 1)">from</span><span style="color: rgba(0, 0, 0, 1)"> these participants:
        </span>-<span style="color: rgba(0, 0, 0, 1)"> {{{ReviewerAgent.AgentName}}}
        </span>-<span style="color: rgba(0, 0, 0, 1)"> {{{WriterAgent.AgentName}}}
        Always follow these rules when choosing the next participant:
        </span>- If RESPONSE <span style="color: rgba(0, 0, 255, 1)">is</span> user input, it <span style="color: rgba(0, 0, 255, 1)">is</span> {{{ReviewerAgent.AgentName}}}<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">s turn.</span>
        - If RESPONSE <span style="color: rgba(0, 0, 255, 1)">is</span> by {{{ReviewerAgent.AgentName}}}, it <span style="color: rgba(0, 0, 255, 1)">is</span> {{{WriterAgent.AgentName}}}<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">s turn.</span>
        - If RESPONSE <span style="color: rgba(0, 0, 255, 1)">is</span> by {{{WriterAgent.AgentName}}}, it <span style="color: rgba(0, 0, 255, 1)">is</span> {{{ReviewerAgent.AgentName}}}<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">s turn.</span>
<span style="color: rgba(0, 0, 0, 1)">        RESPONSE:
        {{${{{KernelFunctionTerminationStrategy.DefaultHistoryVariableName}}}}}
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">);</span></pre>
</div>
<p><span><span><span><span>（2）<strong>TerminationStrategy</strong></span></span></span></span></p>
<p><span><span><span><span>这个终止策略至关重要，它定义了如何评估什么时候退出聊天循环。对于这个案例来说，就是评估Writer优化的内容是否满足用户的需求了。</span></span></span></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Define Termination Policy</span>
<span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">string</span> TerminationToken = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">yes</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">var</span> terminationFunction =<span style="color: rgba(0, 0, 0, 1)">
    AgentGroupChat.CreatePromptFunctionForStrategy(
        $$$</span><span style="color: rgba(128, 0, 0, 1)">"""
</span><span style="color: rgba(0, 0, 0, 1)">        Examine the RESPONSE and determine whether the content has been deemed satisfactory.
        If content </span><span style="color: rgba(0, 0, 255, 1)">is</span><span style="color: rgba(0, 0, 0, 1)"> satisfactory, respond with a single word without explanation: {{{TerminationToken}}}.
        If specific suggestions are being provided, it </span><span style="color: rgba(0, 0, 255, 1)">is</span><span style="color: rgba(0, 0, 0, 1)"> not satisfactory.
        If no correction </span><span style="color: rgba(0, 0, 255, 1)">is</span> suggested, it <span style="color: rgba(0, 0, 255, 1)">is</span><span style="color: rgba(0, 0, 0, 1)"> satisfactory.
        RESPONSE:
        {{${{{KernelFunctionTerminationStrategy.DefaultHistoryVariableName}}}}}
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">);</span></pre>
</div>
<p><span data-pm-slice="0 0 []"><span><span>这<em><span><span>两种策略</span></span></em><span><span>都只需要了解最新的1条聊天<span><span>消息，因此可以使用下面的代码来定一个HistoryReducer，它可以只将最近的1条消息作为历史记录传递给下一个聊天参与者。<span>这将减少Token消耗 也能 一定程度提高性能。</span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">var</span> historyReducer = <span style="color: rgba(0, 0, 255, 1)">new</span> ChatHistoryTruncationReducer(<span style="color: rgba(128, 0, 128, 1)">1</span>);</pre>
</div>
<h1><span>初始化AgentGroupChat</span></h1>
<p><span><span>AgentGroupChat对象会将之前定义的所有内容聚集在一起，相当于我们创建了一个微信群聊，添加了群聊的对象（Reviewer + Writer），以及告诉群主或管理员如何选择Agent的策略 和 终止循环的策略。</span></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Initialize AgentGroupChat</span>
<span style="color: rgba(0, 0, 255, 1)">var</span> groupChat = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> AgentGroupChat(reviewerAgent, writerAgent)
{
    ExecutionSettings </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> AgentGroupChatSettings()
    {
        SelectionStrategy </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> KernelFunctionSelectionStrategy(selectionFunction, kernel)
        {
            InitialAgent </span>=<span style="color: rgba(0, 0, 0, 1)"> reviewerAgent,
            HistoryReducer </span>=<span style="color: rgba(0, 0, 0, 1)"> historyReducer,
            HistoryVariableName </span>=<span style="color: rgba(0, 0, 0, 1)"> KernelFunctionTerminationStrategy.DefaultHistoryVariableName,
            ResultParser </span>= (result) =&gt;<span style="color: rgba(0, 0, 0, 1)">
            {
                </span><span style="color: rgba(0, 0, 255, 1)">var</span> val = result.GetValue&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>&gt;() ??<span style="color: rgba(0, 0, 0, 1)"> ReviewerAgent.AgentName;
                </span><span style="color: rgba(0, 0, 255, 1)">return</span> val.ReplaceLineEndings(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">).Trim();
            }
        },
        TerminationStrategy </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> KernelFunctionTerminationStrategy(terminationFunction, kernel)
        {
            Agents </span>=<span style="color: rgba(0, 0, 0, 1)"> [reviewerAgent],
            HistoryReducer </span>=<span style="color: rgba(0, 0, 0, 1)"> historyReducer,
            HistoryVariableName </span>=<span style="color: rgba(0, 0, 0, 1)"> KernelFunctionTerminationStrategy.DefaultHistoryVariableName,
            MaximumIterations </span>= <span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">,
            ResultParser </span>= (result) =&gt;<span style="color: rgba(0, 0, 0, 1)">
            {
                </span><span style="color: rgba(0, 0, 255, 1)">var</span> val = result.GetValue&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>&gt;() ?? <span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)">.Empty;
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> val.Contains(TerminationToken, StringComparison.OrdinalIgnoreCase);
            }
        }
    }
};</span></pre>
</div>
<h1><span>开始聊天循环</span></h1>
<p><span><span>下面的代码也是老面孔了，就不过多介绍了：</span></span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Start Working!</span>
Console.WriteLine(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">----------Agents are Ready. Let's Start Working!----------</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 0, 255, 1)">while</span> (<span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">)
{
    Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">User&gt; </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> input =<span style="color: rgba(0, 0, 0, 1)"> Console.ReadLine();
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (<span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)">.IsNullOrWhiteSpace(input))
        </span><span style="color: rgba(0, 0, 255, 1)">continue</span><span style="color: rgba(0, 0, 0, 1)">;
    input </span>=<span style="color: rgba(0, 0, 0, 1)"> input.Trim();
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (input.Equals(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">EXIT</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, StringComparison.OrdinalIgnoreCase))
        </span><span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (input.Equals(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">RESET</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, StringComparison.OrdinalIgnoreCase))
    {
        </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> groupChat.ResetAsync();
        Console.ResetColor();
        Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">System&gt; Conversation has been reset!</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">continue</span><span style="color: rgba(0, 0, 0, 1)">;
    }
    groupChat.AddChatMessage(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ChatMessageContent(AuthorRole.User, input));
    groupChat.IsComplete </span>= <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)">
    {
        </span><span style="color: rgba(0, 0, 255, 1)">await</span> <span style="color: rgba(0, 0, 255, 1)">foreach</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> response <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> groupChat.InvokeAsync())
        {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (<span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)">.IsNullOrWhiteSpace(response.Content))
                </span><span style="color: rgba(0, 0, 255, 1)">continue</span><span style="color: rgba(0, 0, 0, 1)">;
            Console.ForegroundColor </span>=<span style="color: rgba(0, 0, 0, 1)"> ConsoleColor.Green;
            Console.WriteLine();
            Console.WriteLine($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">{response.AuthorName} ({response.Role})&gt; </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
            Console.WriteLine($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">{response.Content.ReplaceLineEndings(</span><span style="color: rgba(128, 0, 0, 1)">"</span>\n<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">).Trim()}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        }
        Console.ResetColor();
        Console.WriteLine();
    }
    </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (HttpOperationException ex)
    {
        Console.ResetColor();
        Console.WriteLine(ex.Message);
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (ex.InnerException != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">)
        {
            Console.WriteLine(ex.InnerException.Message);
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (ex.InnerException.Data.Count &gt; <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)
                Console.WriteLine(JsonSerializer.Serialize(ex.InnerException.Data, </span><span style="color: rgba(0, 0, 255, 1)">new</span> JsonSerializerOptions() { WriteIndented = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)"> }));
        }
    }
}
Console.ResetColor();
Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">----------See you next time!----------</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
Console.ReadKey();</span></pre>
</div>
<h1><strong><span>效果展示</span></strong></h1>
<p>第一轮：我给了它一段待优化的文本段落，文本内容如下。</p>
Semantic Kernel (SK) is an open-source SDK that enables developers to build and orchestrate complex AI workflows that involve natural language processing (NLP) and machine learning models. It provides a flexible platform for integrating AI capabilities such as semantic search, text summarization, and dialogue systems into applications. With SK, you can easily combine different AI services and models, define their relationships, and orchestrate interactions between them.
<p><img src="https://img2024.cnblogs.com/blog/381412/202507/381412-20250710194636581-490394290.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>第二轮：让Agent帮忙将其拆分为两个段落</p>
<p><img src="https://img2024.cnblogs.com/blog/381412/202507/381412-20250710194646744-743691474.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>第三轮：提出更高的要求，需要更加学术化以便大学教授能够欣赏</p>
<p><img src="https://img2024.cnblogs.com/blog/381412/202507/381412-20250710194655137-1789978985.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>可以看到，Reviewer 和 Writer 的配合还是不错，准确完成了我给它们的Task。</p>
<h1><strong><span>小结</span></strong></h1>
<p>本文介绍了如何通过Semantic Kernel提供的AgentGroupChat来实现多Agent的协作，其中最要的部分就是定义选择轮次策略 和 终止聊天策略，相信通过这个案例你能够有个感性的认识。</p>
<p>当然，除了群组聊天模式之外，多Agent协作还有很多其他的方式（比如 并行、顺序、移交、磁性等等），也还有不同的框架实现（如AutoGen），这就留到后面一一介绍给你，因为我也还在学。</p>
<h1><span><span><strong><span data-pm-slice="1 1 [&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;data-content&quot;:&quot;[{\&quot;type\&quot;:\&quot;block\&quot;,\&quot;id\&quot;:\&quot;dk8c-1652876793035\&quot;,\&quot;name\&quot;:\&quot;paragraph\&quot;,\&quot;data\&quot;:{\&quot;version\&quot;:1},\&quot;nodes\&quot;:[{\&quot;type\&quot;:\&quot;text\&quot;,\&quot;id\&quot;:\&quot;CmYV-1652876793036\&quot;,\&quot;leaves\&quot;:[{\&quot;text\&quot;:\&quot;Apache Kafka是一款\&quot;,\&quot;marks\&quot;:[]},{\&quot;text\&quot;:\&quot;开源的消息引擎系统\&quot;,\&quot;marks\&quot;:[{\&quot;type\&quot;:\&quot;bold\&quot;}]},{\&quot;text\&quot;:\&quot;。\&quot;,\&quot;marks\&quot;:[]}]}],\&quot;state\&quot;:{}},{\&quot;type\&quot;:\&quot;block\&quot;,\&quot;id\&quot;:\&quot;LkWc-1652879629260\&quot;,\&quot;name\&quot;:\&quot;image\&quot;,\&quot;data\&quot;:{\&quot;version\&quot;:1,\&quot;url\&quot;:\&quot;//note.youdao.com/yws/res/0/WEBRESOURCE57da98f333a501d9dc29bfb5680b9d80\&quot;,\&quot;width\&quot;:281,\&quot;height\&quot;:150,\&quot;style\&quot;:{\&quot;textAlign\&quot;:\&quot;center\&quot;}},\&quot;nodes\&quot;:[],\&quot;state\&quot;:{\&quot;renderSource\&quot;:\&quot;//note.youdao.com/yws/res/0/WEBRESOURCE57da98f333a501d9dc29bfb5680b9d80\&quot;,\&quot;initialSize\&quot;:{\&quot;width\&quot;:281,\&quot;height\&quot;:148},\&quot;loading\&quot;:false}},{\&quot;type\&quot;:\&quot;block\&quot;,\&quot;id\&quot;:\&quot;xh4n-1652876897909\&quot;,\&quot;name\&quot;:\&quot;paragraph\&quot;,\&quot;data\&quot;:{\&quot;version\&quot;:1},\&quot;nodes\&quot;:[{\&quot;type\&quot;:\&quot;text\&quot;,\&quot;id\&quot;:\&quot;3hx7-1652876897893\&quot;,\&quot;leaves\&quot;:[{\&quot;text\&quot;:\&quot;根据维基百科的定义，消息引擎系统是一组规范。企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。通俗来讲，就是系统 A 发送消息给消息引擎系统，系统 B 从消息引擎系统中读取 A 发送的消息。\&quot;,\&quot;marks\&quot;:[]}]}],\&quot;state\&quot;:{}}]&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; text-transform: none; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-align: left; margin-top: 16px; margin-bottom: 16px;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;node&quot;,{&quot;tagName&quot;:&quot;strong&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;caret-color: var(--weui-BRAND); letter-spacing: 0.034em;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;}]">示例源码</span></strong></span></span></h1>
<p><span><span><span><span>Github:&nbsp;<a href="https://github.com/EdisonTalk/MultiAgentSamples?wt.mc_id=MVP_397012" target="_blank" rel="noopener nofollow"><span><span>https://github.com/EdisonTalk/MultiAgentSamples</span></span></a></span></span></span></span></p>
<h1><span><span><strong><span data-pm-slice="1 1 [&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;data-content&quot;:&quot;[{\&quot;type\&quot;:\&quot;block\&quot;,\&quot;id\&quot;:\&quot;dk8c-1652876793035\&quot;,\&quot;name\&quot;:\&quot;paragraph\&quot;,\&quot;data\&quot;:{\&quot;version\&quot;:1},\&quot;nodes\&quot;:[{\&quot;type\&quot;:\&quot;text\&quot;,\&quot;id\&quot;:\&quot;CmYV-1652876793036\&quot;,\&quot;leaves\&quot;:[{\&quot;text\&quot;:\&quot;Apache Kafka是一款\&quot;,\&quot;marks\&quot;:[]},{\&quot;text\&quot;:\&quot;开源的消息引擎系统\&quot;,\&quot;marks\&quot;:[{\&quot;type\&quot;:\&quot;bold\&quot;}]},{\&quot;text\&quot;:\&quot;。\&quot;,\&quot;marks\&quot;:[]}]}],\&quot;state\&quot;:{}},{\&quot;type\&quot;:\&quot;block\&quot;,\&quot;id\&quot;:\&quot;LkWc-1652879629260\&quot;,\&quot;name\&quot;:\&quot;image\&quot;,\&quot;data\&quot;:{\&quot;version\&quot;:1,\&quot;url\&quot;:\&quot;//note.youdao.com/yws/res/0/WEBRESOURCE57da98f333a501d9dc29bfb5680b9d80\&quot;,\&quot;width\&quot;:281,\&quot;height\&quot;:150,\&quot;style\&quot;:{\&quot;textAlign\&quot;:\&quot;center\&quot;}},\&quot;nodes\&quot;:[],\&quot;state\&quot;:{\&quot;renderSource\&quot;:\&quot;//note.youdao.com/yws/res/0/WEBRESOURCE57da98f333a501d9dc29bfb5680b9d80\&quot;,\&quot;initialSize\&quot;:{\&quot;width\&quot;:281,\&quot;height\&quot;:148},\&quot;loading\&quot;:false}},{\&quot;type\&quot;:\&quot;block\&quot;,\&quot;id\&quot;:\&quot;xh4n-1652876897909\&quot;,\&quot;name\&quot;:\&quot;paragraph\&quot;,\&quot;data\&quot;:{\&quot;version\&quot;:1},\&quot;nodes\&quot;:[{\&quot;type\&quot;:\&quot;text\&quot;,\&quot;id\&quot;:\&quot;3hx7-1652876897893\&quot;,\&quot;leaves\&quot;:[{\&quot;text\&quot;:\&quot;根据维基百科的定义，消息引擎系统是一组规范。企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。通俗来讲，就是系统 A 发送消息给消息引擎系统，系统 B 从消息引擎系统中读取 A 发送的消息。\&quot;,\&quot;marks\&quot;:[]}]}],\&quot;state\&quot;:{}}]&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;para&quot;,{&quot;tagName&quot;:&quot;section&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; text-transform: none; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-align: left; margin-top: 16px; margin-bottom: 16px;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;},&quot;node&quot;,{&quot;tagName&quot;:&quot;strong&quot;,&quot;attributes&quot;:{&quot;style&quot;:&quot;caret-color: var(--weui-BRAND); letter-spacing: 0.034em;&quot;},&quot;namespaceURI&quot;:&quot;http://www.w3.org/1999/xhtml&quot;}]">参考资料</span></strong></span></span></h1>
<p><span><span><span><span>Microsoft Learn:&nbsp;<span><span><a href="https://learn.microsoft.com/en-us/semantic-kernel/support/archive/agent-chat-example?pivots=programming-language-csharp?wt.mc_id=MVP_397012" target="_blank" rel="noopener nofollow">https://learn.microsoft.com/en-us/semantic-kernel/support/archive/agent-chat-example?pivots=programming-language-csharp</a><span data-pm-slice="0 0 []"><span><span><br></span></span></span></span></span></span></span></span></span></p>
<h1>


推荐学习</h1>
<p><span><span><span><span><span><span><span><span>圣杰：<span>《<a href="https://www.cnblogs.com/sheng-jie/p/18840383" target="_blank">.NET+AI | Semantic Kernel入门到精通</a>》</span></span></span></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<p style="text-align: center"><img src="https://images.cnblogs.com/cnblogs_com/edisonchou/1647700/o_200902144330EdisonTalk-Footer.jpg" alt="" style="width: 65%; border: 1px solid rgba(221, 221, 221, 1); border-radius: 3px; box-shadow: 0 4px 8px rgba(3, 27, 78, 0.12)"></p>
<div id="Copyright">
<p>作者：<span style="text-decoration: underline">爱迪生</span></p>
<p>出处：<a title="from" href="https://edisontalk.cnblogs.com" target="_blank">https://edisontalk.cnblogs.com</a></p>
<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。</p>









</div>
</div>
<div id="MySignature" role="contentinfo">
    <div align="center"><a href="https://weibo.com/u/2068032061?s=6uyXnP" target="_blank"><img border="0" src="http://service.t.sina.com.cn/widget/qmd/2068032061/d643d182/10.png"></a></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.002777777777777778" data-date-updated="2025-07-10 19:59">2025-07-10 19:55</span>&nbsp;
<a href="https://www.cnblogs.com/edisontalk">EdisonZhou</a>&nbsp;
阅读(<span id="post_view_count">32</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18977640);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18977640', targetLink: 'https://www.cnblogs.com/edisontalk/p/-/quick-start-agent-orchestration-agentgroupchat', title: '多Agent协作入门：群组聊天-AgentGroupChat' })">举报</a>
</div>
        