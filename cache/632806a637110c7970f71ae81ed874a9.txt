
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18751783" title="发布于 2025-03-09 22:08">
    <span role="heading" aria-level="2">求下一排列问题和全排列问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="排列字典序与下一排列"><strong>排列，字典序与下一排列</strong></h2>
<p>假设你有一个数组或序列，<strong>下一个排列</strong>是指在字典序上比当前排列更大的排列。如果当前排列已经是最大的排列，那么下一个排列是最小的排列。</p>
<p>例如，给定一个数组 <code>[1, 2, 3]</code>，它的下一个排列是 <code>[1, 3, 2]</code>；再下一个是<code>[2, 1, 3]</code>；而对于 <code>[3, 2, 1]</code>，它已经是最大排列；一般规定下一个排列又循环到最小排列，即 <code>[1, 2, 3]</code>。</p>
<p>求下一排列的关键是从当前排列出发，利用字典序的性质来找到下一个更大的排列。这个算法的核心步骤如下：</p>
<ol>
<li>
<p><strong>从右向左扫描数组</strong>，找到第一个下降的位置。即找到一个元素 <code>nums[i]</code>，使得 <code>nums[i] &lt; nums[i + 1]</code>。这个位置的存在意味着当前排列还可以变大。如果没有找到这样的 <code>i</code>，说明当前排列已经是最大的排列。</p>
</li>
<li>
<p><strong>找到比 <code>nums[i]</code> 大的最小元素</strong>：找到 <code>i</code> 以右比他大的最小元素（由于 <code>i</code> 以后都是递减的，即最后一个）。</p>
</li>
<li>
<p><strong>交换元素</strong>：交换 <code>nums[i]</code> 和 <code>nums[j]</code>，这一步会确保新的排列更大。</p>
</li>
<li>
<p><strong>反转后部分</strong>：原来 <code>i</code> 处的元素已被替换为更大的元素；为了确保排列的字典序最小，反转 <code>nums[i+1]</code> 到 <code>nums[n-1]</code> 的部分，使得这一部分由降序变成升序，变成最小的排列。</p>
</li>
</ol>
<h4 id="为什么这样做是对的"><strong>为什么这样做是对的？</strong></h4>
<p>这是由字典序的性质决定的。每个排列在字典序中是由从左到右的逐步交换构成的。</p>
<ul>
<li>首先，从后向前找到不降序的第一个元素，确定了“还能增加”的部分。</li>
<li>他应和之后最小的元素交换，并把其他元素重新变成正序，确保增加的字典序最小。</li>
</ul>
<pre><code class="language-cpp">void nextPermutation(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    int i = n - 2;
    
    while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) i--;
    if (i &gt;= 0) swap(nums[i], nums[n - 1]);
    reverse(nums.begin() + i + 1, nums.end());
}
</code></pre>
<p>很多语言（也包括 C++）自带了此函数，复杂度显然是 <span class="math inline">\(O(n)\)</span>。</p>
<h2 id="全排列问题">全排列问题</h2>
<p>全排列问题给定一个长度为 <code>n</code> 的数组，要求返回该数组的所有排列。比如，给定数组 <code>[1, 2, 3]</code>，我们要找出 <code>[1, 2, 3]</code>、<code>[1, 3, 2]</code>、<code>[2, 1, 3]</code>、<code>[2, 3, 1]</code>、<code>[3, 1, 2]</code>、<code>[3, 2, 1]</code> 这六个排列。</p>
<p>全排列的一个特点是，它会生成所有可能的排列组合，并且每个排列都包含数组中所有元素的不同顺序。全排列一共有 <span class="math inline">\(n!\)</span> 个，你可以直接用上面的下一排列法枚举，运算量为 <span class="math inline">\(n! * n\)</span></p>
<p>另一个方案回溯法，通过递归的方式逐步填充排列中的每一个位置，并在每一步选择不同的元素，最后输出所有可能的排列。</p>
<ol>
<li><strong>初始化</strong>：从空的排列开始，递归地填充每个位置。</li>
<li><strong>递归填充排列</strong>：每次递归时，我们按顺序在剩余未使用的数字中选择一个，并将其放入当前排列中，递归生成剩余的部分。</li>
<li><strong>回溯</strong>：当递归到达底部（即生成了一个排列），我们回到上一层，尝试其他选择。</li>
<li><strong>终止条件</strong>：当排列的长度等于数组的长度时，表示一个排列已完全生成，加入结果。</li>
</ol>
<pre><code class="language-cpp">void permute(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;bool&gt;&amp; visited) {
    if (path.size() == nums.size()) {
        result.push_back(path);
        return;
    }

    for (int i = 0; i &lt; nums.size(); i++) {
        if (visited[i]) continue;

        visited[i] = true;
        path.push_back(nums[i]); 

        permute(nums, path, result, visited);

        path.pop_back();
        visited[i] = false;
    }
}
</code></pre>
<ul>
<li><strong>时间复杂度</strong>：全排列问题的时间复杂度为 <code>O(n!)</code>，因为生成所有排列需要 <code>n!</code> 个排列，而每生成一个排列需要 <code>O(n)</code> 时间来复制和保存。</li>
<li><strong>空间复杂度</strong>：空间复杂度为 <code>O(n)</code>，递归深度。</li>
</ul>
<h2 id="拓展知识">拓展知识</h2>
<p>排列顺序源于字典序，所以这种方法不仅适用于整数数组，也可以扩展到其他类型的数组（如字符串、字符等）。也并不要求数字是连续的 <code>1 ~ n</code>。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.1716960096527778" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-09 22:08">2025-03-09 22:08</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18751783" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18751783);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18751783', targetLink: 'https://www.cnblogs.com/ofnoname/p/18751783', title: '求下一排列问题和全排列问题' })">举报</a>
</div>
        