
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ITnoteforlsy/p/19027295" title="发布于 2025-08-24 10:35">
    <span role="heading" aria-level="2">详谈 QLayout::SizeConstraint 和 QSizePolicy 对 QWidget 尺寸的影响</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>QT 窗口布局常用的设置有 QSizePolicy 和 QLayout::SizeConstraint ，当窗口大小调整时，哪个配置会生效或者都会生效？先说一个简单的结论：QSizePolicy 与 QLayout::SizeConstraint 都用于 QLayout 的自动布局，父 widget 尺寸发生变化时，layout 会根据子 widget 的 QSizePolicy 与 QLayout 的方向调整子 widget 的位置及大小；子 widget 显示、隐藏、minimumSize、maximumSize 发生变化时，会触发父 widget 的 layout 重新计算（新尺寸的计算由 QLayout::SizeConstraint 来决定），从而改变父 widget 尺寸。QLayout::SizeConstraint 确定了主 widget （layout 所在 widget） 的尺寸变化策略。如果父 widget 没有使用 layout ，子 widget 的 QSizePolicy 不起任何作用。下面从帮助文档和源码分别分析一下。</p>
<h2 id="1-帮助文档">1. 帮助文档</h2>
<h3 id="11-qwidget">1.1 QWidget</h3>
<p>默认情况下组合窗口的大小根据子窗口的大小来调整。widget 的 size policy 用于父窗口 layout 的布局管理。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202508/1596700-20250807221109205-1628046811.png" alt="image" loading="lazy"></p>
<p>sizeHint 属性是 widget 的推荐大小。如果设置了 layout 该属性的值由 layout 计算，如果没设置 layout 该属性的值默认不可用。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202508/1596700-20250807223905725-1407107832.png" alt="image" loading="lazy"></p>
<p>minimumSizeHint 属性是 widget 推荐的最小尺寸。如果设置了 layout 该属性的值由 layout 计算，如果没设置 layout 该属性的值默认不可用。如果要设置比 minimumSizeHint 更小的尺寸，则必须设置 QSizePolicy::Ignore。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202508/1596700-20250807224301854-1505902257.png" alt="image" loading="lazy"></p>
<p>maximumSize 属性是 widget 推荐的最大尺寸， 宽高的默认值都是 16777215。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202508/1596700-20250807224801554-895504554.png" alt="image" loading="lazy"></p>
<p>adjustSize() 用于调整 widget 的大小到适合子控件大小。如果 sizeHint 属性可用，则使用sizeHint提供的大小，否则，使用所有子控件尺寸的并集（可以涵盖所有子控件的尺寸）来调整尺寸。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202508/1596700-20250807220040713-1460909489.png" alt="image" loading="lazy"></p>
<h3 id="12-qsizepolicy">1.2 QSizePolicy</h3>
<p>通过 QWidget 的 sizePolicy() 方法可以设置 widget 的 sizePolicy。但是该设置是 widget 未设置 layout 时的布局配置，如果设置了 layout 该 widget 使用 layout 的 size policy。layout 的 size policy 通过方法 setSizeConstraint() 和 setContentsMargins() 设置。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202508/1596700-20250807175532120-661070949.png" alt="image" loading="lazy"></p>
<h3 id="13-qlayout">1.3 QLayout</h3>
<p>QLayout 的大小调整由 SizeConstraint 配置，它有以下6种预置配置。从源码中可以确认文档中提到的<strong>minimumSize()、sizeHint()、maxmumSize() 指的是 QLayout 类中的方法，不是 Qwidget中的方法。</strong> 文档中的 main widget 指定的是 <code>QLayout::QLayout(QWidget *parent = nullptr)</code> 实例化时指定的 widget，或调用<code>QWidget::setLayout(QLayout *layout)</code> 方法的 widget。</p>
<p>从文档可以看出只有设置为 QLayout::SetNoConstraint 时，QLayout::SizeConstraint 不会影响 widget 的大小。当设置为 QLayout::SetDefaultConstraint 时，widget 自己的minimunSize() 才会生效。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202508/1596700-20250807175424812-1305505164.png" alt="image" loading="lazy"></p>
<p>QLayout::activate() 会重新计算父 widget 布局，一般情况下这个方法会自动执行。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202508/1596700-20250808091152275-1294968740.png" alt="image" loading="lazy"></p>
<h2 id="2-源码分析">2. 源码分析</h2>
<h3 id="21-消息的传递">2.1 消息的传递</h3>
<p>对于 widget 控件， QApplication 在分发消息时会优先发送给该 widget 的 layout 布局，然后再由 widget 处理。QLayout 中的 widgetEvent() 方法处理了 QEvent::Resize、QEvent::ChildRemoved、QEvent::LayoutRequest 消息。也就是说，当 widget 生子控件移除或大小变动时，layout 优先处理，优先调整大小。layout 调整大小时主要由 activate() 方法处理。</p>
<pre><code>// qapplication.cpp
bool QApplication::notify(QObject *receiver, QEvent *e)
{
    ...
    if (isWidgetType) {
        QWidget * w = static_cast&lt;QWidget *&gt;(receiver);
        switch (e-&gt;type()) {
        ...
        default:
            res = d-&gt;notify_helper(receiver, e);
            break;
        }
    } else {
        res = d-&gt;notify_helper(receiver, e);
    }

    return res;
}

bool QApplicationPrivate::notify_helper(QObject *receiver, QEvent * e)
{
    if (receiver-&gt;isWidgetType()) {
        QWidget *widget = static_cast&lt;QWidget *&gt;(receiver);
        ....
        // 如果使用了 layout 布局，消息先发送给 layout 处理
        if (QLayout *layout=widget-&gt;d_func()-&gt;layout) {
            layout-&gt;widgetEvent(e);
        }
    }
    // send to all receiver event filters
    if (sendThroughObjectEventFilters(receiver, e)) {
        filtered = true;
        return filtered;
    }

    // 消息再发送给 widget 处理
    // deliver the event
    consumed = receiver-&gt;event(e);

    QCoreApplicationPrivate::setEventSpontaneous(e, false);
    return consumed;
}
</code></pre>
<pre><code>// qlayout.cpp
void QLayout::widgetEvent(QEvent *e)
{
    Q_D(QLayout);
    const QEvent::Type type = e-&gt;type();
    if (!d-&gt;enabled &amp;&amp; type != QEvent::ChildRemoved)
        return;

    switch (type) {
    case QEvent::Resize:
        if (d-&gt;activated)
            d-&gt;doResize();
        else
            activate();
        break;
    case QEvent::ChildRemoved:
        {
            QChildEvent *c = (QChildEvent *)e;
            QObject *child = c-&gt;child();
            QObjectPrivate *op = QObjectPrivate::get(child);
            if (op-&gt;wasWidget) {
#if QT_CONFIG(menubar)
                if (child == d-&gt;menubar)
                    d-&gt;menubar = nullptr;
#endif
                removeWidgetRecursively(this, child);
            }
        }
        break;
    case QEvent::LayoutRequest:
        if (static_cast&lt;QWidget *&gt;(parent())-&gt;isVisible())
            activate();
        break;
    default:
        break;
    }
}
</code></pre>
<h3 id="22-qwidget-调整大小">2.2 QWidget 调整大小</h3>
<p>QWidget 在执行 show() 方法时会计算 widget 大小，show() 方法调用 setVisible() 计算widget 布局并显示 widget。调整 widget 尺寸由 adjustSize() 方法执行，调整尺寸时采用 sizeHint() 推荐的大小。sizeHint() 使用 layout 计算的推荐尺寸。<br>
由此可见，<mark><strong>当 widget 是组合 widget 时（即该 widget 包含其它 widget），它的尺寸由 layout 来计算，Size Policy 不起作用</strong>。</mark><strong>当 widget 是单一控件时（不包含其它 widget），必须重写 sizeHint() 方法，否则，该控件不会显示。</strong></p>
<pre><code>// qwidget.cpp
void QWidget::show()
{
    ...
    if (!isWindow()) {
        setVisible(true);
    } else {
        ...
        if (defaultState == Qt::WindowFullScreen)
            showFullScreen();
        else if (defaultState == Qt::WindowMaximized)
            showMaximized();
        else
            setVisible(true);
    }
}
void QWidget::setVisible(bool visible)
{
    ...
    d-&gt;setVisible(visible);
}
void QWidgetPrivate::setVisible(bool visible)
{
    ...
    if (visible) { // show
        ...
        // 向父窗口发送布局更改事件
        if (needUpdateGeometry)
            updateGeometry_helper(true);

        // 重新计算 layout 布局
        // activate our layout before we and our children become visible
        if (layout)
            layout-&gt;activate();
        
        if (!q-&gt;isWindow()) {
            QWidget *parent = q-&gt;parentWidget();
            // 依次调整上层 widget 尺寸
            while (parent &amp;&amp; parent-&gt;isVisible() &amp;&amp; parent-&gt;d_func()-&gt;layout  &amp;&amp; !parent-&gt;data-&gt;in_show) {
                parent-&gt;d_func()-&gt;layout-&gt;activate();
                if (parent-&gt;isWindow())
                    break;
                parent = parent-&gt;parentWidget();
            }
            if (parent)
                parent-&gt;d_func()-&gt;setDirtyOpaqueRegion();
        }
        // 如果是 window 或上级 widget 未设置 layout 调整大小
        // adjust size if necessary
        if (!wasResized
            &amp;&amp; (q-&gt;isWindow() || !q-&gt;parentWidget()-&gt;d_func()-&gt;layout))  {
            if (q-&gt;isWindow()) {
                // 调整 window 大小
                q-&gt;adjustSize();
                if (q-&gt;windowState() != initialWindowState)
                    q-&gt;setWindowState(initialWindowState);
            } else {
               // 调整 widget 大小
                q-&gt;adjustSize();
            }
            q-&gt;setAttribute(Qt::WA_Resized, false);
        }
        q-&gt;setAttribute(Qt::WA_KeyboardFocusChange, false);

        if (q-&gt;isWindow() || q-&gt;parentWidget()-&gt;isVisible()) {
            show_helper();// 显示 widget

            qApp-&gt;d_func()-&gt;sendSyntheticEnterLeave(q);
        }
        QEvent showToParentEvent(QEvent::ShowToParent);
        QCoreApplication::sendEvent(q, &amp;showToParentEvent);
    }else{ // hide
	    ...
        // 隐藏 widget 
        if (!q-&gt;testAttribute(Qt::WA_WState_Hidden)) {
            q-&gt;setAttribute(Qt::WA_WState_Hidden);
            hide_helper();
        }

        // 向父 widget 发送布局改变消息
        // invalidate layout similar to updateGeometry()
        if (!q-&gt;isWindow() &amp;&amp; q-&gt;parentWidget()) {
            if (q-&gt;parentWidget()-&gt;d_func()-&gt;layout)
                q-&gt;parentWidget()-&gt;d_func()-&gt;layout-&gt;invalidate();
            else if (q-&gt;parentWidget()-&gt;isVisible())
                QCoreApplication::postEvent(q-&gt;parentWidget(), new QEvent(QEvent::LayoutRequest));
        }
        QEvent hideToParentEvent(QEvent::HideToParent);
        QCoreApplication::sendEvent(q, &amp;hideToParentEvent);
    }
}

void QWidgetPrivate::updateGeometry_helper(bool forceUpdate)
{
    Q_Q(QWidget);
    if (widgetItem)
        widgetItem-&gt;invalidateSizeCache();
    QWidget *parent;
    if (forceUpdate || !extra || extra-&gt;minw != extra-&gt;maxw || extra-&gt;minh != extra-&gt;maxh) {
        const int isHidden = q-&gt;isHidden() &amp;&amp; !size_policy.retainSizeWhenHidden() &amp;&amp; !retainSizeWhenHiddenChanged;

        if (!q-&gt;isWindow() &amp;&amp; !isHidden &amp;&amp; (parent = q-&gt;parentWidget())) {
            if (parent-&gt;d_func()-&gt;layout)
                parent-&gt;d_func()-&gt;layout-&gt;invalidate();
            else if (parent-&gt;isVisible())
                QCoreApplication::postEvent(parent, new QEvent(QEvent::LayoutRequest));
        }
    }
}

void QWidget::adjustSize()
{
    Q_D(QWidget);
    ensurePolished();
    QSize s = d-&gt;adjustedSize();

    if (d-&gt;layout)
        d-&gt;layout-&gt;activate();

    if (s.isValid())
        resize(s);
}

QSize QWidgetPrivate::adjustedSize() const
{
    Q_Q(const QWidget);
    // 使用推荐大小
    QSize s = q-&gt;sizeHint();

    if (q-&gt;isWindow()) {
        Qt::Orientations exp;
        if (layout) {
            if (layout-&gt;hasHeightForWidth())
                s.setHeight(layout-&gt;totalHeightForWidth(s.width()));
            exp = layout-&gt;expandingDirections();
        } else
        {
            if (q-&gt;sizePolicy().hasHeightForWidth())
                s.setHeight(q-&gt;heightForWidth(s.width()));
            exp = q-&gt;sizePolicy().expandingDirections();
        }
        if (exp &amp; Qt::Horizontal)
            s.setWidth(qMax(s.width(), 200));
        if (exp &amp; Qt::Vertical)
            s.setHeight(qMax(s.height(), 100));

        QRect screen;
        if (const QScreen *screenAtPoint = QGuiApplication::screenAt(q-&gt;pos()))
            screen = screenAtPoint-&gt;geometry();
        else
            screen = QGuiApplication::primaryScreen()-&gt;geometry();

        s.setWidth(qMin(s.width(), screen.width()*2/3));
        s.setHeight(qMin(s.height(), screen.height()*2/3));

        if (QTLWExtra *extra = maybeTopData())
            extra-&gt;sizeAdjusted = true;
    }

    if (!s.isValid()) {
        QRect r = q-&gt;childrenRect(); // get children rectangle
        if (r.isNull())
            return s;
        s = r.size() + QSize(2 * r.x(), 2 * r.y());
    }

    return s;
}

QSize QWidget::sizeHint() const
{
    Q_D(const QWidget);
    // 使用 layout 计算的推荐尺寸
    if (d-&gt;layout)
        return d-&gt;layout-&gt;totalSizeHint();
    return QSize(-1, -1);
}

QSize QWidget::minimumSizeHint() const
{
    Q_D(const QWidget);
    // 使用 layout 计算的推荐尺寸
    if (d-&gt;layout)
        return d-&gt;layout-&gt;totalMinimumSize();
    return QSize(-1, -1);
}

void QWidget::resize(const QSize &amp;s)
{
    Q_D(QWidget);
    setAttribute(Qt::WA_Resized);
    if (testAttribute(Qt::WA_WState_Created)) {
        d-&gt;fixPosIncludesFrame();
        d-&gt;setGeometry_sys(geometry().x(), geometry().y(), s.width(), s.height(), false);
        d-&gt;setDirtyOpaqueRegion();
    } else {
        const auto oldRect = data-&gt;crect;
        // 根据 minimizeSize 与 maximumSize 进行约束后保存到 data-&gt;crect
        data-&gt;crect.setSize(s.boundedTo(maximumSize()).expandedTo(minimumSize()));
        if (oldRect != data-&gt;crect)
            setAttribute(Qt::WA_PendingResizeEvent);
    }
}

</code></pre>
<h3 id="23-qlayout-布局与-qsizepolicy">2.3 QLayout 布局与 QSizePolicy</h3>
<p>在 widget 调整尺寸时，调用了 QLayout::activate() 方法。该方法根据设置的 QLayout::SizeConstraint 调用主 widget 的方法设置对应的尺寸：</p>
<ul>
<li><strong>QLayout::SetFixedSize</strong> 调用 QWidget::setFixedSize() 方法，设置 QLayout::totalSizeHint() 计算的尺寸；</li>
<li><strong>QLayout::SetMinimumSize</strong> 调用 QWidget::setMinimumSize() 方法，设置 QLayout::totalMinimumSize() 计算的尺寸；</li>
<li><strong>QLayout::SetMaximumSize</strong> 调用 QWidget::SetMaximumSize() 方法，设置 QLayout::totalMaximumSize() 计算的尺寸；</li>
<li><strong>QLayout::SetMinAndMaxSize</strong> 调用 QWidget::setMinimumSize() 和 QWidget::SetMaximumSize() 方法，设置 QLayout::totalMinimumSize() 和 QLayout::totalMaximumSize() 计算的尺寸；</li>
<li><strong>QLayout::SetDefaultConstraint</strong> 当 QWidget::minimumSize 属性可用时，使用使用QWidget::minimumSize 指定的尺寸，否则调用 QWidget::setMinimumSize() 方法，设置 QLayout::totalMinimumSize() 计算的尺寸；</li>
<li><strong>QLayout::SetNoConstraint</strong> 不会修改主 widget 的尺寸</li>
</ul>
<p>QLayout::totalSizeHint()、QLayout::totalMinimumSize()、QLayout::totalMaximumSize() 会调用子类的 sizeHint()、minimumSize()、maximumSize()。以 QBoxLayout 为例，这些方法中会调用 QLayout::setupGeom() 方法。setupGeom() 方法遍历 layout 中所有 widget 计算 minSize、maxSize、sizeHint。遍历 widget 时，通过 QWidgetItem::expandingDirections() 获取该 widget 的扩展方向。expandingDirections() 方法根据 widget 设置的 size policy 来判断扩展方向。</p>
<pre><code>// qlayout.cpp
bool QLayout::activate()
{
    Q_D(QLayout);
    if (!d-&gt;enabled || !parent())
        return false;
    if (!d-&gt;topLevel)
        return static_cast&lt;QLayout*&gt;(parent())-&gt;activate();
    if (d-&gt;activated)
        return false;
    // layout 所属的主widget
    QWidget *mw = static_cast&lt;QWidget*&gt;(parent());
    if (Q_UNLIKELY(!mw)) {
        qWarning("QLayout::activate: %s \"%ls\" does not have a main widget",
                 metaObject()-&gt;className(), qUtf16Printable(objectName()));
        return false;
    }
    activateRecursiveHelper(this);

    QWidgetPrivate *md = mw-&gt;d_func();
    uint explMin = md-&gt;extra ? md-&gt;extra-&gt;explicitMinSize : 0;
    uint explMax = md-&gt;extra ? md-&gt;extra-&gt;explicitMaxSize : 0;
    // 根据 QLayout::SizeConstraint 设置主 widget 尺寸
    switch (d-&gt;constraint) {
    case SetFixedSize:
        // will trigger resize
        mw-&gt;setFixedSize(totalSizeHint());
        break;
    case SetMinimumSize:
        mw-&gt;setMinimumSize(totalMinimumSize());
        break;
    case SetMaximumSize:
        mw-&gt;setMaximumSize(totalMaximumSize());
        break;
    case SetMinAndMaxSize:
        mw-&gt;setMinimumSize(totalMinimumSize());
        mw-&gt;setMaximumSize(totalMaximumSize());
        break;
    case SetDefaultConstraint: {
        bool widthSet = explMin &amp; Qt::Horizontal;
        bool heightSet = explMin &amp; Qt::Vertical;
        if (mw-&gt;isWindow()) {
            QSize ms = totalMinimumSize();
            if (widthSet)
                ms.setWidth(mw-&gt;minimumSize().width());
            if (heightSet)
                ms.setHeight(mw-&gt;minimumSize().height());
            mw-&gt;setMinimumSize(ms);
        } else if (!widthSet || !heightSet) {
            QSize ms = mw-&gt;minimumSize();
            if (!widthSet)
                ms.setWidth(0);
            if (!heightSet)
                ms.setHeight(0);
            mw-&gt;setMinimumSize(ms);
        }
        break;
    }
    case SetNoConstraint:
        break;
    }
    // 根据主 widget 调整后的尺寸计算 layout 的 rect
    d-&gt;doResize();

    if (md-&gt;extra) {
        md-&gt;extra-&gt;explicitMinSize = explMin;
        md-&gt;extra-&gt;explicitMaxSize = explMax;
    }
    // ideally only if sizeHint() or sizePolicy() has changed
    mw-&gt;updateGeometry();
    return true;
}

void QLayoutPrivate::doResize()
{
    Q_Q(QLayout);
    QWidget *mw = q-&gt;parentWidget();
    QRect rect = mw-&gt;testAttribute(Qt::WA_LayoutOnEntireRect) ? mw-&gt;rect() : mw-&gt;contentsRect();
    const int mbh = menuBarHeightForWidth(menubar, rect.width());
    const int mbTop = rect.top();
    rect.setTop(mbTop + mbh);
    // 对于 QBoxLayout 此处会调整子 widget 大小
    q-&gt;setGeometry(rect);
#if QT_CONFIG(menubar)
    if (menubar)
        menubar-&gt;setGeometry(rect.left(), mbTop, rect.width(), mbh);
#endif
}
// 此方法在 QLayout 的子类中会重载，完成子 widget 坐标的计算与设置
void QLayout::setGeometry(const QRect &amp;r)
{
    Q_D(QLayout);
    d-&gt;rect = r;
}

QSize QLayout::totalSizeHint() const
{
    Q_D(const QLayout);
    int side=0, top=0;
    if (d-&gt;topLevel) {
        QWidget *pw = parentWidget();
        pw-&gt;ensurePolished();
        QWidgetPrivate *wd = pw-&gt;d_func();
        side += wd-&gt;leftmargin + wd-&gt;rightmargin;
        top += wd-&gt;topmargin + wd-&gt;bottommargin;
    }

    QSize s = sizeHint();
    if (hasHeightForWidth())
        s.setHeight(heightForWidth(s.width() + side));
#if QT_CONFIG(menubar)
    top += menuBarHeightForWidth(d-&gt;menubar, s.width());
#endif
    return s + QSize(side, top);
}

void QLayout::invalidate()
{
    Q_D(QLayout);
    d-&gt;rect = QRect();
    update();
}

void QLayout::update()
{
    QLayout *layout = this;
    while (layout &amp;&amp; layout-&gt;d_func()-&gt;activated) {
        layout-&gt;d_func()-&gt;activated = false;
        if (layout-&gt;d_func()-&gt;topLevel) {
            Q_ASSERT(layout-&gt;parent()-&gt;isWidgetType());
            QWidget *mw = static_cast&lt;QWidget*&gt;(layout-&gt;parent());
            QCoreApplication::postEvent(mw, new QEvent(QEvent::LayoutRequest));
            break;
        }
        layout = static_cast&lt;QLayout*&gt;(layout-&gt;parent());
    }
}
</code></pre>
<pre><code>// qboxlayout.cpp
QSize QBoxLayout::sizeHint() const
{
    Q_D(const QBoxLayout);
    if (d-&gt;dirty)
        const_cast&lt;QBoxLayout*&gt;(this)-&gt;d_func()-&gt;setupGeom();
    return d-&gt;sizeHint;
}

QSize QBoxLayout::minimumSize() const
{
    Q_D(const QBoxLayout);
    if (d-&gt;dirty)
        const_cast&lt;QBoxLayout*&gt;(this)-&gt;d_func()-&gt;setupGeom();
    return d-&gt;minSize;
}

QSize QBoxLayout::maximumSize() const
{
    Q_D(const QBoxLayout);
    if (d-&gt;dirty)
        const_cast&lt;QBoxLayout*&gt;(this)-&gt;d_func()-&gt;setupGeom();

    QSize s = d-&gt;maxSize.boundedTo(QSize(QLAYOUTSIZE_MAX, QLAYOUTSIZE_MAX));

    if (alignment() &amp; Qt::AlignHorizontal_Mask)
        s.setWidth(QLAYOUTSIZE_MAX);
    if (alignment() &amp; Qt::AlignVertical_Mask)
        s.setHeight(QLAYOUTSIZE_MAX);
    return s;
}

// 此方法遍历 layout 中所有 widget 计算 minSize、maxSize、sizeHint
void QBoxLayoutPrivate::setupGeom()
{
    if (!dirty)
        return;

    Q_Q(QBoxLayout);
    int maxw = horz(dir) ? 0 : QLAYOUTSIZE_MAX;
    int maxh = horz(dir) ? QLAYOUTSIZE_MAX : 0;
    int minw = 0;
    int minh = 0;
    int hintw = 0;
    int hinth = 0;

    bool horexp = false;
    bool verexp = false;

    hasHfw = false;

    int n = list.size();
    geomArray.clear();
    QList&lt;QLayoutStruct&gt; a(n);

    QSizePolicy::ControlTypes controlTypes1;
    QSizePolicy::ControlTypes controlTypes2;
    int fixedSpacing = q-&gt;spacing();
    int previousNonEmptyIndex = -1;

    QStyle *style = nullptr;
    if (fixedSpacing &lt; 0) {
        if (QWidget *parentWidget = q-&gt;parentWidget())
            style = parentWidget-&gt;style();
    }

    for (int i = 0; i &lt; n; i++) {
        QBoxLayoutItem *box = list.at(i);
        // 获取 layout 内的 widget 的尺寸
        QSize max = box-&gt;item-&gt;maximumSize();
        QSize min = box-&gt;item-&gt;minimumSize();
        QSize hint = box-&gt;item-&gt;sizeHint();
        // 计算扩展方向
        Qt::Orientations exp = box-&gt;item-&gt;expandingDirections();
        bool empty = box-&gt;item-&gt;isEmpty();
        int spacing = 0;

        if (!empty) {
            if (fixedSpacing &gt;= 0) {
                spacing = (previousNonEmptyIndex &gt;= 0) ? fixedSpacing : 0;
#ifdef Q_OS_MAC
                if (!horz(dir) &amp;&amp; previousNonEmptyIndex &gt;= 0) {
                    QBoxLayoutItem *sibling = (dir == QBoxLayout::TopToBottom  ? box : list.at(previousNonEmptyIndex));
                    if (sibling) {
                        QWidget *wid = sibling-&gt;item-&gt;widget();
                        if (wid)
                            spacing = qMax(spacing, sibling-&gt;item-&gt;geometry().top() - wid-&gt;geometry().top());
                    }
                }
#endif
            } else {
                controlTypes1 = controlTypes2;
                controlTypes2 = box-&gt;item-&gt;controlTypes();
                if (previousNonEmptyIndex &gt;= 0) {
                    QSizePolicy::ControlTypes actual1 = controlTypes1;
                    QSizePolicy::ControlTypes actual2 = controlTypes2;
                    if (dir == QBoxLayout::RightToLeft || dir == QBoxLayout::BottomToTop)
                        qSwap(actual1, actual2);

                    if (style) {
                        spacing = style-&gt;combinedLayoutSpacing(actual1, actual2,
                                             horz(dir) ? Qt::Horizontal : Qt::Vertical,
                                             nullptr, q-&gt;parentWidget());
                        if (spacing &lt; 0)
                            spacing = 0;
                    }
                }
            }

            if (previousNonEmptyIndex &gt;= 0)
                a[previousNonEmptyIndex].spacing = spacing;
            previousNonEmptyIndex = i;
        }

        bool ignore = empty &amp;&amp; box-&gt;item-&gt;widget(); // ignore hidden widgets
        bool dummy = true;
        if (horz(dir)) {
            bool expand = (exp &amp; Qt::Horizontal || box-&gt;stretch &gt; 0);
            horexp = horexp || expand;
            maxw += spacing + max.width();
            minw += spacing + min.width();
            hintw += spacing + hint.width();
            if (!ignore)
                qMaxExpCalc(maxh, verexp, dummy,
                            max.height(), exp &amp; Qt::Vertical, box-&gt;item-&gt;isEmpty());
            minh = qMax(minh, min.height());
            hinth = qMax(hinth, hint.height());

            a[i].sizeHint = hint.width();
            a[i].maximumSize = max.width();
            a[i].minimumSize = min.width();
            a[i].expansive = expand;
            a[i].stretch = box-&gt;stretch ? box-&gt;stretch : box-&gt;hStretch();
        } else {
            bool expand = (exp &amp; Qt::Vertical || box-&gt;stretch &gt; 0);
            verexp = verexp || expand;
            maxh += spacing + max.height();
            minh += spacing + min.height();
            hinth += spacing + hint.height();
            if (!ignore)
                qMaxExpCalc(maxw, horexp, dummy,
                            max.width(), exp &amp; Qt::Horizontal, box-&gt;item-&gt;isEmpty());
            minw = qMax(minw, min.width());
            hintw = qMax(hintw, hint.width());

            a[i].sizeHint = hint.height();
            a[i].maximumSize = max.height();
            a[i].minimumSize = min.height();
            a[i].expansive = expand;
            a[i].stretch = box-&gt;stretch ? box-&gt;stretch : box-&gt;vStretch();
        }

        a[i].empty = empty;
        a[i].spacing = 0;   // might be initialized with a non-zero value in a later iteration
        hasHfw = hasHfw || box-&gt;item-&gt;hasHeightForWidth();
    }

    geomArray = a;

    expanding = (Qt::Orientations)
                       ((horexp ? Qt::Horizontal : 0)
                         | (verexp ? Qt::Vertical : 0));

    minSize = QSize(minw, minh);
    maxSize = QSize(maxw, maxh).expandedTo(minSize);
    sizeHint = QSize(hintw, hinth).expandedTo(minSize).boundedTo(maxSize);

    q-&gt;getContentsMargins(&amp;leftMargin, &amp;topMargin, &amp;rightMargin, &amp;bottomMargin);
    int left, top, right, bottom;
    effectiveMargins(&amp;left, &amp;top, &amp;right, &amp;bottom);
    QSize extra(left + right, top + bottom);

    minSize += extra;
    maxSize += extra;
    sizeHint += extra;

    dirty = false;
}
struct QBoxLayoutItem
{
    ...
    QLayoutItem *item;
    ...
}；

void QBoxLayout::setGeometry(const QRect &amp;r)
{
    Q_D(QBoxLayout);
    if (d-&gt;dirty || r != geometry()) {
        QRect oldRect = geometry();
        QLayout::setGeometry(r);
        if (d-&gt;dirty)
            d-&gt;setupGeom();
        QRect cr = alignment() ? alignmentRect(r) : r;

        int left, top, right, bottom;
        d-&gt;effectiveMargins(&amp;left, &amp;top, &amp;right, &amp;bottom);
        QRect s(cr.x() + left, cr.y() + top,
                cr.width() - (left + right),
                cr.height() - (top + bottom));
        // d-&gt;geomArray 已经在 setupGeom() 完成计算
        QList&lt;QLayoutStruct&gt; a = d-&gt;geomArray;
        int pos = horz(d-&gt;dir) ? s.x() : s.y();
        int space = horz(d-&gt;dir) ? s.width() : s.height();
        int n = a.size();
        if (d-&gt;hasHfw &amp;&amp; !horz(d-&gt;dir)) {
            for (int i = 0; i &lt; n; i++) {
                QBoxLayoutItem *box = d-&gt;list.at(i);
                if (box-&gt;item-&gt;hasHeightForWidth()) {
                    int width = qBound(box-&gt;item-&gt;minimumSize().width(), s.width(), box-&gt;item-&gt;maximumSize().width());
                    a[i].sizeHint = a[i].minimumSize =
                                    box-&gt;item-&gt;heightForWidth(width);
                }
            }
        }

        Direction visualDir = d-&gt;dir;
        QWidget *parent = parentWidget();
        if (parent &amp;&amp; parent-&gt;isRightToLeft()) {
            if (d-&gt;dir == LeftToRight)
                visualDir = RightToLeft;
            else if (d-&gt;dir == RightToLeft)
                visualDir = LeftToRight;
        }
        // 根据 QRect &amp;r 大小，调整子 widget 尺寸
        qGeomCalc(a, 0, n, pos, space);

        bool reverse = (horz(visualDir)
                        ? ((r.right() &gt; oldRect.right()) != (visualDir == RightToLeft))
                        : r.bottom() &gt; oldRect.bottom());
        // 设置子 widget 坐标
        for (int j = 0; j &lt; n; j++) {
            int i = reverse ? n-j-1 : j;
            QBoxLayoutItem *box = d-&gt;list.at(i);

            switch (visualDir) {
            case LeftToRight:
                box-&gt;item-&gt;setGeometry(QRect(a.at(i).pos, s.y(), a.at(i).size, s.height()));
                break;
            case RightToLeft:
                box-&gt;item-&gt;setGeometry(QRect(s.left() + s.right() - a.at(i).pos - a.at(i).size + 1,
                                             s.y(), a.at(i).size, s.height()));
                break;
            case TopToBottom:
                box-&gt;item-&gt;setGeometry(QRect(s.x(), a.at(i).pos, s.width(), a.at(i).size));
                break;
            case BottomToTop:
                box-&gt;item-&gt;setGeometry(QRect(s.x(),
                                             s.top() + s.bottom() - a.at(i).pos - a.at(i).size + 1,
                                             s.width(), a.at(i).size));
            }
        }
    }
}

</code></pre>
<pre><code>// qlayoutengine_p.h
struct QLayoutStruct
{
    inline void init(int stretchFactor = 0, int minSize = 0) {
        stretch = stretchFactor;
        minimumSize = sizeHint = minSize;
        maximumSize = QLAYOUTSIZE_MAX;
        expansive = false;
        empty = true;
        spacing = 0;
    }

    int smartSizeHint() {
        return (stretch &gt; 0) ? minimumSize : sizeHint;
    }
    int effectiveSpacer(int uniformSpacer) const {
        Q_ASSERT(uniformSpacer &gt;= 0 || spacing &gt;= 0);
        return (uniformSpacer &gt;= 0) ? uniformSpacer : spacing;
    }

    // parameters
    int stretch;
    int sizeHint;
    int maximumSize;
    int minimumSize;
    int spacing;
    bool expansive;
    bool empty;

    // temporary storage
    bool done;

    // result
    int pos;
    int size;
};
Q_WIDGETS_EXPORT void qGeomCalc(QList&lt;QLayoutStruct&gt; &amp;chain, int start, int count, int pos,
                                int space, int spacer = -1);

...

static inline void qMaxExpCalc(int &amp; max, bool &amp;exp, bool &amp;empty,
                               int boxmax, bool boxexp, bool boxempty)
{
    if (exp) {
        if (boxexp)
            max = qMax(max, boxmax);
    } else {
        if (boxexp || (empty &amp;&amp; (!boxempty || max == 0)))
            max = boxmax;
        else if (empty == boxempty)
            max = qMin(max, boxmax);
    }
    exp = exp || boxexp;
    empty = empty &amp;&amp; boxempty;
}
</code></pre>
<pre><code>// qlayoutitem.cpp
Qt::Orientations QWidgetItem::expandingDirections() const
{
    if (isEmpty())
        return {};

    Qt::Orientations e = wid-&gt;sizePolicy().expandingDirections();
    /*
      If the layout is expanding, we make the widget expanding, even if
      its own size policy isn't expanding.
    */
    // 根据 widget 设置的 size ploicy 来判断扩展方向
    if (wid-&gt;layout()) {
        if (wid-&gt;sizePolicy().horizontalPolicy() &amp; QSizePolicy::GrowFlag
                &amp;&amp; (wid-&gt;layout()-&gt;expandingDirections() &amp; Qt::Horizontal))
            e |= Qt::Horizontal;
        if (wid-&gt;sizePolicy().verticalPolicy() &amp; QSizePolicy::GrowFlag
                &amp;&amp; (wid-&gt;layout()-&gt;expandingDirections() &amp; Qt::Vertical))
            e |= Qt::Vertical;
    }

    if (align &amp; Qt::AlignHorizontal_Mask)
        e &amp;= ~Qt::Horizontal;
    if (align &amp; Qt::AlignVertical_Mask)
        e &amp;= ~Qt::Vertical;
    return e;
}
</code></pre>
<h2 id="3-分析总结">3. 分析总结</h2>
<p>通过上述分析，widget 调整尺寸主要由 layout 管理控件进行计算调整；如果没有设置 layout 由 sizeHint() 提供 widget 的大小。当子 widget 尺寸发生变化时，会通知其所在的 layout 进行尺寸计算，从而影响父 widget 的尺寸，此时 layout 的 SizeConstraint 对 widget 的尺寸调整起到决定性作用。当包含 widget 的 widget 的尺寸发生变化时，resize 方法会触发 layout 执行 doResize 方法，setGeometry() 方法中重新计算子 widget 应该占用的空间，此时会根据 QSizePolicy 确定扩展方向。下面简单描述以下 widget 尺寸变化的 3 种情况：</p>
<h3 id="31-widget-显示或隐藏对父-widget-的影响">3.1 widget 显示或隐藏对父 widget 的影响</h3>
<p>此种情况会触发父 widget 直至顶层 widget 的尺寸调整（需要每层 widget 都使用 layout 布局）。父 widget 未使用 layout 布局时，可以通过处理 QEvent::LayoutRequest 事件来手工调整尺寸。</p>
<p>当 widget 隐藏时，QWidget::setVisible() 方法被调用。该方法在完成 widget 隐藏操作后，会调用父 widget 的 layout-&gt;invalidate() 方法（当父 widget 使用 layout 管理布局时），或者向父 widget 发送 QEvent::LayoutRequest 事件（当父 widget 未使用 layout 布局并且可见时）。 <mark><strong>widget 未使用 layout 布局时，默认不处理 QEvent::LayoutRequest 事件，也就是说此时父 widget 不会因为子 widget 的隐藏而改变尺寸。</strong></mark> 此时，父 widget 可以通过处理 QEvent::LayoutRequest 事件来手工调整尺寸。使用 layout 布局时，layout-&gt;invalidate() 方法会调用 layout-&gt;update() 方法，采用循环的方式将所有上层 widget 的 layout 的 activated 置为 false，并给顶层 widget 发送 QEvent::LayoutRequest 事件。顶层 widget 的 layout 收到 QEvent::LayoutRequest 事件后将调用 activate() 方法重新计算所有下层 widget 及本身的尺寸。 <mark><strong>widget 使用 layout 布局时，只需要设置 QLayout::SizeConstraint ，当子 widget 隐藏时会自动重新计算窗口尺寸。</strong></mark></p>
<p>当 widget 显示时，QWidget::setVisible() 方法被调用。该方法首先通过updateGeometry_helper(）将父 widget 的 layout 置为 invalidate()（当父 widget 使用 layout 布局时）或向父 widget 发送 QEvent::LayoutRequest 事件。然后调用本级的 layout-&gt;activate() 计算本身级下级 widget 的尺寸。最后，再依次调用上层 widget 的 layout-&gt;activate() 重新计算尺寸。该过程中，<strong>只要有一层 widget 没有设置 layout ，就会中断，上层 widget 都将无法自动调整。</strong></p>
<h3 id="32-widget-调整大小对子-widget-的影响">3.2 widget 调整大小对子 widget 的影响</h3>
<p>当调用 resize() 方法或 setGeometry() 方法调整 widget时，或者 widget 是 scrollArea 中的控件（设置了自动调整大小）时，如果使用了 layout 布局，其子 widget 的大小会由 layout 根据子 widget 的 SizePolicy 计算尺寸和位置信息并依次调整。如果未使用 layout 布局，子 widget 不会自动调整，可以通过处理 QResizeEvent 事件手工调整子 widget 大小及位置。</p>
<p>resize() 方法或 setGeometry() 方法都会调用 QWidgetPrivate::setGeometry_sys()方法，在该方法中会判断是否移动或改变大小，并发送 QMoveEvent 和 QResizeEvent 事件。下个事件循环中 QLayout 截获 QEvent::Resize 事件，并调用 d-&gt;doResize() 方法，该方法会调用 QLayout 子类的 setGeometry() 方法。QBoxLayout::setGeometry() 方法会根据子 widget 的 SizePolicy 计算其尺寸和位置信息并依次调用子 widget 的 setGeometry() 方法修改其位置及尺寸。如果 widget 未设置 layout 布局，widget 尺寸的调整不会影响子 widget 的位置及尺寸。</p>
<h3 id="33-widget-主动调整大小对父-widget-的影响">3.3 widget 主动调整大小对父 widget 的影响</h3>
<p>当调用 resize() 方法或 setGeometry() 方法调整 widget 时，widget 会修改大小或位置，但是父 widget 不会有任何变化。如果父 widget 使用了 layout，当父 widget 变化时，该 widget 的大小由 layout 重新设定。</p>
<p>当调用 setMinimumSize() 方法或 setMaximumSize() 方法调整 widget 时，如果 widget 大小改变， 会触发父 widget 的 layout 重新计算父 widget 尺寸。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.002777777777777778" data-date-updated="2025-08-24 10:39">2025-08-24 10:35</span>&nbsp;
<a href="https://www.cnblogs.com/ITnoteforlsy">永不停转</a>&nbsp;
阅读(<span id="post_view_count">31</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19027295);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19027295', targetLink: 'https://www.cnblogs.com/ITnoteforlsy/p/19027295', title: '详谈 QLayout::SizeConstraint 和 QSizePolicy 对 QWidget 尺寸的影响' })">举报</a>
</div>
        