
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zj99/p/18799748" title="发布于 2025-03-29 18:32">
    <span role="heading" aria-level="2">Static Timing Analysis Basics</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="preface">Preface</h2>
<p>This note only introduce the essential concepts about Static Timing Analysis, which not contains:</p>
<ul>
<li>Async, i.e. remove, recover</li>
<li>Timing conceptions, i.e. false path, multi cycle path etc.</li>
<li>Advance timing domain knowledge
<ul>
<li>POCV, MCMM etc.</li>
</ul>
</li>
</ul>
<h3 id="什么是-sta">什么是 STA</h3>
<p>由于时钟频率越快，芯片中的逻辑单元在单位时间内能够完成的操作就越多，所以频率与芯片性能成正相关。而芯片设计需要在 PPA 之间 tradeoff，那么如何才能知道一枚芯片正常工作的频率极限到底是多少呢？这就引入了 STA 静态时序分析的概念。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250308154438.png" alt="image.png" loading="lazy"><br>
STA 用于验证设计是否能够<strong>安全运行在给定的时钟频率下且没有时序违例</strong>。STA存在以下特点：</p>
<ul>
<li>Pros
<ul>
<li>无需输入激励仿真</li>
<li>完备的时序检查</li>
</ul>
</li>
<li>Cons
<ul>
<li>无法处理异步时序</li>
</ul>
</li>
</ul>
<h3 id="sta-应用场景">STA 应用场景</h3>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250308155224.png" alt="image.png" loading="lazy"></p>
<p>STA 可以应用于 PD 多个阶段，并且分别具有不同特点，如：</p>
<ol>
<li>synthesis: 在逻辑设计阶段，由于没有与布局有关的物理信息，因此可以假设互连线是理想状态的，此阶段会更关注查看导致最差路径的逻辑。在这个阶段使用的另一种技术是采用<strong>线负载模型</strong>(wireload model)来<strong>估算互连线的长度</strong>, 线负载模型会<strong>基于逻辑单元的扇出提供一个估计的RC值</strong>。</li>
<li>Pre-CTS: 在物理设计的一开始，<strong>时钟树被认为是理想的</strong>，即它们具有零延迟。而在 CTS 后，时钟则具有实际的 propagate delay</li>
<li>Pre-Route: 在实际布线前，STA 用于计算延迟的<strong>金属线寄生 RC 为估计值</strong>。</li>
</ol>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250308160208.png" alt="image.png" loading="lazy"></p>
<h2 id="cell">Cell</h2>
<p>单元可以是标准单元、IO缓冲器或者是如USB内核这样的复杂 IP。除时序信息外，库单元描述中还包含一些其它属性，例如单元面积和功能，这些属性与时序无关，但在RTL综合（synthesis）过程中会用到。</p>
<h3 id="引脚电容">引脚电容</h3>
<p>单元的每个输入和输出都可以在引脚（pin）上指定电容。在大多数情况下，<strong>仅为单元输入引脚指定电容，而不为输出引脚指定电容</strong>，即大多数单元库中的输出引脚电容为0</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250310092637.png" alt="image.png" loading="lazy"></p>
<p>上面的示例展示了输入INP1引脚电容值的一般规格（specification）。在最基本的格式中，引脚电容被指定为单个值（在上面的示例中为0.5个单位）。电容单位通常为皮法拉（pF），一般在库文件的开头指定。单元描述中还可以为<strong>rise_capacitance</strong>（0.5个单位）和<strong>fall_capacitance</strong>（0.45个单位）分别指定值，这些值是指引脚INP1上发生电平上升和下降跳变时的值。也可以将<strong>rise_capacitance</strong>和<strong>fall_capacitance</strong>的值指定为范围，并在描述中指定下限值和上限值。</p>
<h3 id="驱动强度">驱动强度</h3>
<p>输入引脚电容定义在 liberty 中，而<strong>输出引脚电容则由该单元驱动的所有下级单元所决定</strong>。当CMOS单元切换电平状态时，<strong>切换的速度取决于输出引脚上的电容被充放电的速度</strong>。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250310091220.png" alt="image.png" loading="lazy"></p>
<p>通常来说，单元驱动强度决定了可以<strong>驱动的最大电容负载</strong>，最大电容负载又决定了<strong>扇出的最大数量</strong>，即可<strong>以驱动多少个其他单元</strong>。较高的输出驱动对应较低的输出上拉/下拉电阻，这使单元可以在输出引脚上<strong>对较大的负载进行充电和放电</strong>。</p>
<ul>
<li>驱动强度越大则单元面积越大，且 <code>max_cap</code> 也越大。</li>
<li>驱动强度越大，对应的输出电阻越小，延迟也就越小。</li>
</ul>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250310093543.png" alt="image.png|500" loading="lazy"><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250310093550.png" alt="image.png|500" loading="lazy"></p>
<ul>
<li>如果标准单元库中只有小驱动强度的标准逻辑单元，则对时序有何影响?
<ul>
<li>当整个库只有小驱动单元时，首先想到的是<strong>每个单元的驱动能力弱</strong>，输出电阻更大。</li>
<li>如果一个反相器的驱动强度小，那么它能够驱动的最大负载电容也较小。如果设计中某些节点必须驱动较大的电容，<strong>比如长线或高扇出网络，这时候小驱动单元可能无法满足需求</strong>，从而导致建立时间或保持时间违规。</li>
</ul>
</li>
</ul>
<h3 id="propagation-delay">Propagation Delay</h3>
<p>单元的传播延时(propagation delay)是由电平切换波形上的某些测量点定义的。这些阈值的单位是Vdd或电源的百分比，对于大多数标准单元库，通常将<strong>50%阈值</strong>用于计算延时。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250310094435.png" alt="image.png" loading="lazy"></p>
<p>这里的传播延时按照输出信号的 rise/fall 分为两种（不相等）：</p>
<ul>
<li>output rise delay: 从输入信号到达下降沿阈值点开始，到输出信号到达上升沿阈值点结束的这段时间延迟</li>
<li>output fall delay：与 output rise delay 相反</li>
</ul>
<h3 id="slew">Slew</h3>
<p>压摆率(slew rate)的定义是<strong>电压转换速率</strong>。在 STA 中，通常会根据电平转换的快慢来衡量上升波形或下降波形。压摆(slew)通常是根据转换时间(transition time)来定义的，转换时间是指信号<strong>在两个特定电平之间转换所需要的时间</strong>。请注意，转换时间实际上就是压摆率的倒数，因此转换时间越大，压摆率就越低，反之亦然。</p>
<p>一般使用指定的阈值电压来规定过渡时间计算的起点和终点</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250310094627.png" alt="image.png" loading="lazy"></p>
<p>Slew rate 和 Slew 非同一件事。Slew 为 transition 而 Slew rate 为其倒数。</p>
<h3 id="timing-arc">Timing Arc</h3>
<p>时序弧描述了信号在单元引脚之间传输的延迟以及信号的跳变情况。</p>
<ul>
<li>像与门、或门、与非门、加法器这些组合逻辑单元,<strong>每个输入引脚到每个输出引脚都存在一条时序弧</strong></li>
<li>而像触发器之类的时序逻辑单元除了有从时钟引脚到输出引脚的时序弧，还有<strong>相对于时钟引脚的数据引脚时序约束(timing constraint)</strong></li>
</ul>
<p>每个时序弧都具有特定的<strong>时序敏感(timing sense)</strong>, 即输出如何针对输入的不同跳变类型而变化。在<strong>非单边(non-unate)时序弧</strong>中，仅仅从一个输入引脚的跳变方向是无法确定输出引脚电平将如何跳变的，还要<strong>取决于其他输入引脚的状态</strong>。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250311090026.png" alt="image.png" loading="lazy"></p>
<h3 id="timing-model">Timing Model</h3>
<p>逻辑单元的时序模型(timing model)旨在为设计中的各种单元实例(instance)提供准确的时序信息。</p>
<ul>
<li>每个时序弧都有时序模型</li>
<li>时序模型由详细电路仿真所得</li>
</ul>
<p>对于一个 inverter 而言其存在两种延迟：分别为输出上升沿延时 $T_{r}$ 和输出下降沿延时 $T_{f}$</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250312084054.png" alt="image.png" loading="lazy"></p>
<p>通过 inverter 的 delay and output transition 主要取决于：</p>
<ul>
<li>输出负载，即反相器输出引脚上的电容负载</li>
<li>输入信号的过渡(transition)时间</li>
<li>晶体管版图设计：可忽略</li>
</ul>
<p>一个逻辑单元的信号输入，如同在水槽上来了水流，水流首先推动蓝色水车运转（类似于输入变换时间），然后把水池（输出电容）灌满后，才能推动红色水车的运作（下一个逻辑单元）。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250327213736.png" alt="image.png|625" loading="lazy"></p>
<p>延迟值与负载电容有直接关系：<strong>负载电容越大，延迟越大。在大多数情况下，延迟也会随着输入信号过渡时间的增加而增加</strong>。PS: 非绝对</p>
<h4 id="nldm">NLDM</h4>
<p>逻辑单元的时序模型可以简单理解为以 input slew 和 output load 为参数的函数，但简单的线性时序模型在应用于亚微米技术时并不准确。因此，目前大多数单元库都使用更复杂的非线性延迟模型(non-linear delay model)</p>
<p>大多数单元库都包括表格模型(table model)，用于为单元的各种时序弧指定延迟并进行时序检查。这些表格模型被称为 NLDM (Non-Linear Delay Model)，可用于<strong>延迟、输出压摆计算或其他时序检查</strong>。表格模型中提供了：在单元输入引脚处输入过渡时间和输出引脚处输出负载电容的各种组合下通过单元的延迟。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250312085040.png" alt="image.png" loading="lazy"></p>
<p>根据延迟表，输入下降过渡时间为0.3ns且输出负载为0.16pf时，反相器的上升延迟为0.1018ns。由于输入的下降沿跳变导致反相器输出的上升沿跳变，因此当输入引脚发生下降沿跳变时，应该去查询cell_rise延迟表。注意，<strong>表格模型也可以是3维的</strong>，例如一个具有互补输出Q和QN的触发器。</p>
<p>NLDM模型不仅可以用于计算延迟，而且还可用于<strong>计算逻辑单元输出引脚的过渡时间</strong>，该时间同样由输入过渡时间和输出负载电容来表征。</p>
<p>所以通过 NLDM 模型可计算：</p>
<ol>
<li>Rise Delay</li>
<li>Fall Delay</li>
<li>Rise Slew</li>
<li>Fall Slew</li>
</ol>
<p>另外，如果没有表中对应索引，可通过插值计算结果。</p>
<h4 id="derate">Derate</h4>
<blockquote>
<p>skip it</p>
</blockquote>
<p>压摆值(slew)基于的是在库中指定的测量阈值点，大多数上一代的库(0.25um或更旧的库)都使用10%和90%（对应波形的线性部分）作为压摆 (或称过渡时间)的测量阈值点。</p>
<p>随着技术的发展，实际波形最线性的部分通常在30%至70%之间。因此，大多数新一代时序库都将压摆测量阈值点指定为Vdd的30%和70%。但是，由于之前测得的过渡时间在10%至90%之间，因此在填充库时，通常将测得的30%至70%的过渡时间加倍，这由压摆降额系数(<code>slew derate factor</code>)指定，通常指定为0.5。压摆测量阈值点为30%和70%且压摆降额系数为0.5，等效于测量阈值点为10%和90%。</p>
<h3 id="组合逻辑单元">组合逻辑单元</h3>
<p>对于两输入与门：共有四种 delay 以及四种 output transition</p>
<ul>
<li>上升下降 * 两个输入引脚 = 4</li>
<li>而在 FPGA 中，每个逻辑单元的所有延时信息基本是固定的，所以每一种逻辑单元都分别拟合一个固定的延迟（例如LUT是0.1ns，DSP是1.3ns等）</li>
</ul>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250312094207.png" alt="image.png" loading="lazy"></p>
<h3 id="通用组合逻辑块">通用组合逻辑块</h3>
<p>考虑以下这个具有三输入和两输出的通用组合逻辑块(General Combinational Block):</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250312094332.png" alt="image.png" loading="lazy"><br>
像这样的组合逻辑块可以具有多个时序弧。通常，<strong>从块的每个输入到每个输出都有一条时序弧</strong>。</p>
<h3 id="时序逻辑单元">时序逻辑单元</h3>
<p>时序逻辑单元的时序弧如下：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250313075747.png" alt="image.png|500" loading="lazy"></p>
<p>对于引脚 D, SI 和 SE 的同步输入信号，存在以下时序弧（both rise and fall）：</p>
<ul>
<li>建立时间检查时序弧</li>
<li>保持时间检查时序弧</li>
</ul>
<p>对于引脚 Q 的同步输出信号，存在以下时序弧：</p>
<ul>
<li>CK to Q or QN Propagation delay arc</li>
</ul>
<p>对于引脚 CDN 的异步输入信号，存在以下时序弧：</p>
<ul>
<li>移除时间检查时序弧</li>
<li>恢复时间检查时序弧</li>
</ul>
<p>此外，对于时钟引脚和异步引脚还存在</p>
<ul>
<li>脉冲宽度时序检查</li>
</ul>
<h3 id="setup-and-hold">Setup and Hold</h3>
<p>建立时间和保持时间的同步时序检查用于<strong>确保数据能够正确通过时序单元传播</strong>。这些时序检查可<strong>验证输入的数据在时钟有效沿上是否为确定的逻辑状态</strong>，并且在有效沿上将正确的数据锁存下来。</p>
<p>二维表格模型是根据约束引脚constrained_pin(D)和相关引脚related_pin(CK)处的<strong>过渡时间</strong>确定的。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250313081216.png" alt="image.png" loading="lazy"></p>
<p>setup and hold 详细内容在后文介绍。</p>
<h3 id="异步时序检查">异步时序检查</h3>
<blockquote>
<p>SKIP</p>
</blockquote>
<h3 id="状态相关的时序模型">状态相关的时序模型</h3>
<blockquote>
<p>SKIP</p>
</blockquote>
<p>输入和输出之间的时序弧取决于模块中其他引脚的逻辑状态</p>
<h3 id="黑盒的接口时序模型">黑盒的接口时序模型</h3>
<blockquote>
<p>SKIP</p>
</blockquote>
<h3 id="高级时序模型">高级时序模型</h3>
<blockquote>
<p>SKIP</p>
</blockquote>
<p>非线性延迟模型(NLDM)这类的时序模型是<strong>基于输出负载电容和输入过渡时间</strong>来表示通过时序弧的延迟的。实际上，单元输出的负载不仅包括电容还应当<strong>包括互连电阻(interconnect resistance)</strong>。</p>
<p>由于NLDM方法假设输出负载为纯电容，因此互连电阻成为了一个问题。即使互连电阻不为零，但当互连电阻的影响较小时，仍使用了这些NLDM模型。在互连电阻存在的情况下，延迟的计算方法通过在单元的输出端获得<strong>等效的有效电容(effective capacitance)来改进NLDM模型</strong>。延迟计算工具中使用的“有效”电容法获得的<strong>等效电容可保证单元输出延迟与具有RC互连的单元输出延迟相同</strong>。</p>
<p>由于 NLDM 无法很好地处理互连电阻带来的误差，所以提出了如 CCS (Composite Current Source) 等更高级的时序模型。</p>
<h2 id="clock">Clock</h2>
<h3 id="skew">Skew</h3>
<p>偏斜(skew)是指两个或<strong>多个信号(数据或者时钟)之间的时序之差</strong>。例如，如果一个时钟树(clock tree)有500个终点, 并且有50ps的偏斜，则意味着<strong>最长时钟路径和最短时钟路径之间的延迟差为50ps</strong>。</p>
<p>时钟树的起点通常是定义时钟的节点，时钟树的终点通常是同步元件(例如触发器)的时钟引脚。时钟延迟(clock latency: Source + Insertion)是指从时钟源到终点所花费的总时间，时钟偏斜(clock skew)是指到达不同时钟树终点的时间差。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250310094831.png" alt="image.png" loading="lazy"></p>
<p><strong>理想时钟树</strong>是假定时钟源具有无限驱动力，时钟可以<strong>无延迟地驱动无限个终点</strong>。另外，假定时钟树中存在的任何逻辑单元都具有<strong>零延迟(zero delay)</strong>。在逻辑设计的早期阶段，STA通常使用理想的时钟树来执行，因此分析的重点是数据路径 (data path)。通过 <code>set_clock_latency</code> 可显示指定时钟树延迟。</p>
<h3 id="uncertainty">Uncertainty</h3>
<p><code>set_clock_uncertainty</code> 命令为时钟沿的出现指定了一个窗口。时钟边沿时序的不确定性将考虑多个因素，例如时钟周期抖动 (jitter) 和用于时序验证的额外裕量 (slack)。实际上是不存在理想时钟的，<strong>所有时钟都具有一定的抖动量</strong>，并且在指定时钟不确定度时应包括时钟周期抖动。</p>
<p>在时钟树被实现(implement)之前，时钟不确定度还必须<strong>包括预期的时钟偏斜</strong>。而保持时间检查不需要将时钟抖动包括在内，因此通常<strong>为保持时间检查指定较小的时钟不确定度</strong>。</p>
<h4 id="实际中的时钟信号">实际中的时钟信号</h4>
<p>实际的时钟信号包括上升沿和下降沿：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250311084120.png" alt="image.png" loading="lazy"><br>
将两种时钟信号结合得到理想情况下的眼图，此时为只有 transition 的理想时钟：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250311084226.png" alt="image.png" loading="lazy"></p>
<p>但实际上时钟信号存在不同的到达时间（jitter），此时的眼图为：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250311084456.png" alt="image.png" loading="lazy"></p>
<p>此外，时钟还会因为 Power Supply variations cause voltage drop and ground bounce.</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250311084617.png" alt="image.png" loading="lazy"></p>
<p>最终得到实际情况下的时钟信号：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250311084642.png" alt="image.png" loading="lazy"></p>
<p>针对电平波动，定义 <strong>noise margin</strong>, 允许一定失真:</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250311084753.png" alt="image.png" loading="lazy"><br>
时钟信号无抖动区域称为 window where data is reliable:</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250311085135.png" alt="image.png" loading="lazy"></p>
<p>而时钟信号存在抖动的区域称为 <strong>jitter</strong>: Jitter has to be accounted for in the timing reports. We model this using one more parameter called <strong>Uncertainty</strong>.</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250311085237.png" alt="image.png" loading="lazy"><br>
Example : Uncertainty = 90ps = 0.09ns</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250311085350.png" alt="image.png" loading="lazy"></p>
<h3 id="clock-domain">Clock Domain</h3>
<p>一个时钟通常驱动许多触发器，<strong>由同一时钟驱动的一组触发器称为其时钟域(clock domain)</strong>。下图即存在两个时钟域：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250311090715.png" alt="image.png" loading="lazy"></p>
<p>需要关注一个问题：<strong>两个时钟域是相关的还是彼此独立的</strong>？答案取决于是否存在一条从一个时钟域开始并在另一时钟域结束的数据路径，如果没有这样的路径，我们可以肯定地说这两个时钟域彼此独立，这意味着没有时序路径从一个时钟域开始而在另一时钟域结束。</p>
<p>若存在跨时钟域的数据路径(如下图所示)，<strong>则必须确定这些路径是否为真实(real)路径</strong>：例如一个两倍频时钟驱动的触发器发起数据，再由一倍频时钟驱动的触发器捕获数据，这条路径就是一条真实路径。</p>
<p>而伪路径(false path)的一个例子是设计人员将时钟同步器(clock synchronizer)逻辑明确放置在两个时钟域之间。在这种情况下，即使好像存在从一个时钟域到下一时钟域的时序路径，但这也不是真实的时序路径，因为<strong>数据没有被约束要在一个时钟周期之内通过同步器逻辑传播</strong>。这样的路径称为伪路径(不是真实的)，因为是由时钟同步器来确保数据正确地从一个时钟域传递到另一个时钟域。</p>
<ul>
<li>false path belongs to timing exceptions, so skip it.</li>
<li>在设计中，有些路径是不可能存在的，或者不可能发生的，这种路径称为伪路径。伪路径通常发生在异步电路以及跨时钟域；或者电路内部逻辑复杂，推导后发现其实是常量，不会发生变化</li>
</ul>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250311090949.png" alt="image.png" loading="lazy"></p>
<p>实际出现<strong>跨时钟域的情况往往是双向的</strong>，即从USBCLK时钟域到MEMCLK时钟域，以及从 MEMCLK时钟域到USBCLK时钟域，这两种情况都需要在STA中正确理解和处理。</p>
<h2 id="sdc">SDC</h2>
<p>正确的约束对于分析STA结果很重要，只有准确指定设计环境，STA分析才能够识别出设计中的所有时序问题。STA的准备工作包括<strong>设置时钟、指定IO时序特性以及指定伪路径和多周期路径</strong>。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318081109.png" alt="image.png" loading="lazy"></p>
<p>为了对这种设计执行STA，需要<strong>指定触发器的时钟、以及进入设计和退出设计的所有路径的时序约束</strong>。</p>
<h3 id="指定时钟">指定时钟</h3>
<p>要定义时钟，我们需要提供以下信息:</p>
<ol>
<li>时钟源(Clock source)：它可以是设计的端口，也可以是设计内部单元的引脚(通常是时钟生成逻辑的一部分)。</li>
<li>周期(Period):时钟的周期。</li>
<li>占空比(Duty cycle):高电平持续时间(正相位)和低电平持续时间(负相位)。</li>
<li>边沿时间(Edge times):上升沿和下降沿的时刻。</li>
</ol>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318081405.png" alt="image.png" loading="lazy"></p>
<p>创建时钟的例子：<code>create_clock -name SYSCLK -period 20 -waveform {0 5} [get_ports SCLK]</code>；该时钟名为SYSCLK，并在端口SCLK上定义。SYSCLK的周期指定为20个单位，如果未指定,默认时间单位为纳秒(通常，时间单位会在技术库中进行指定)。waveform中的第一个自变量指定出现上升沿的时刻，第二个自变量指定出现下降沿的时刻。</p>
<h3 id="时钟不确定度">时钟不确定度</h3>
<p>可以使用 <code>set_clock_uncertainty</code> 约束来指定时钟周期的时序不确定度(uncertainty)，该不确定度可用于<strong>对可能会减少有效时钟周期的各种因素进行建模</strong>。这些因素可能是jitter以及可能需要在时序分析中考虑的任何其它悲观度。</p>
<p><code>set_clock_uncertainty -setup 0.2 [get_clocks CLK_CONFIG]</code>；注意，建立时间检查的时钟不确定度将<strong>减少可用的有效时钟周期</strong>。对于保持时间检查，时钟不确定度<strong>将用作需要满足的额外时序裕量</strong>。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318081944.png" alt="image.png" loading="lazy"></p>
<h3 id="时钟延迟">时钟延迟</h3>
<p>可用以下命令设置时钟延迟，如 <code>set_clock_latency 1.8 -rise [get_clocks MAIN_CLK]</code></p>
<p>时钟延迟有两种类型：网络延迟(network latency)和源延迟(source latency)：触发器时钟引脚上的总时钟延迟是<strong>源延迟和网络延迟之和</strong>。在时钟树综合完成后，从时钟源到触发器时钟引脚的总时钟延迟是<strong>源延迟加上时钟树从时钟定义点到触发器的实际延迟</strong>。</p>
<ul>
<li>网络延迟是指从时钟定义点 (create_clock) 到触发器时钟引脚的延迟。
<ul>
<li>CTS 后忽略</li>
</ul>
</li>
<li>源延迟也称为插入延迟(insertion delay)：是指从时钟源到时钟定义点的延迟, 源延迟可能代表片上或片外延迟
<ul>
<li>CTS 后保留</li>
</ul>
</li>
</ul>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318082206.png" alt="image.png" loading="lazy"></p>
<p>源延迟和网络延迟之间的一个重要区别是：<strong>一旦为设计建立了时钟树,就可以忽略网络延迟</strong> (假设指定了 <code>set_propagated_clock</code> 命令)。</p>
<h3 id="约束输入路径">约束输入路径</h3>
<p>触发器UFF0在设计的外部，并向设计内部的触发器UFF1提供数据。数据通过输入端口INP1连接两个触发器。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318083240.png" alt="image.png" loading="lazy"></p>
<p>CLKA的时钟定义指定了时钟周期，这是两个触发器UFF0和UFF1之间可用的总时间。外部逻辑所需的时间为Tclk2q(数据发起触发器UFF0的CK至Q延迟)加上Tc1(通过外部组合逻辑的延迟) ，因此<strong>输入引脚INP1上的延迟定义指定了Tclk2q加上Tc1的外部延迟</strong>。</p>
<p>以下是输入延迟的约束 (可分别定义 minmax):</p>
<ul>
<li><code>set Tclk2q 0.9</code></li>
<li><code>set Tc1 0.6</code></li>
<li><code>set_input_delay -clock CLKA -max [ expr Tclk2q + Tc1] [ get_ports INP1]</code></li>
</ul>
<h3 id="约束输出路径">约束输出路径</h3>
<p>约束输出路径与约束输入路径类似，可通过命令 <code>set_output_delay</code> 来指定外部延迟：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318195900.png" alt="image.png" loading="lazy"></p>
<h3 id="时序路径组">时序路径组</h3>
<p>设计中的时序路径可以视为路径的集合，每个路径都有一个起点和一个终点。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318200023.png" alt="image.png" loading="lazy"></p>
<p>时序路径可以<strong>根据与路径终点相关的时钟分类</strong>为不同时序路径组(path groups)。因此，每个时钟都有一组与之相关的时序路径。还有一个<strong>默认时序路径组，其中包括了所有非时钟(异步)路径</strong>。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318200227.png" alt="image.png" loading="lazy"></p>
<h3 id="外部属性建模">外部属性建模</h3>
<p>尽管 <code>create_clock</code> 、<code>set_input_delay</code> 和 <code>set_output_delay</code> 足以约束设计中用于执行时序分析的所有路径，但这些并不足以获取该<strong>模块IO引脚上的准确时序</strong>。</p>
<p>对于输入，需要在输入端口处指定压摆：</p>
<ul>
<li><code>set_drive</code></li>
<li><code>set_driving_cell</code></li>
<li><code>set_input_transition</code></li>
</ul>
<p>对于输出，需要指定输出引脚的负载电容：</p>
<ul>
<li><code>set_load</code></li>
</ul>
<h4 id="驱动强度建模">驱动强度建模</h4>
<blockquote>
<p>总之，设计人员需要<strong>指定输入端的压摆值来确定输入路径中第一个单元的延迟</strong>。在没有该约束的情况下，将假设为理想过渡值 0，这显然是不现实的。</p>
</blockquote>
<p><code>set_drive</code> 和 <code>set_driving_cell</code> 约束用于<strong>对驱动模块输入端口的外部单元的驱动强度进行建模</strong>。在没有这些约束的默认情况下，假定<strong>所有输入都具有无限的驱动强度</strong>，即<strong>输入引脚的过渡时间为0</strong></p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318201706.png" alt="image.png" loading="lazy"></p>
<p><code>set_drive</code> 明确指定了DUA输入引脚上的驱动电阻值，<strong>该电阻值越小，驱动强度越高，电阻值为0表示无限的驱动强度</strong>。输入端口的驱动强度用于<strong>计算第一个单元的过渡时间</strong>。指定的驱动强度还可用于计算在任何RC互连情况下从<strong>输入端口到第一个单元的延迟值</strong></p>
<ul>
<li>延迟值 = (驱动强度 * 网络负载) + 互连线延迟</li>
</ul>
<p><code>set_driving_cell</code> 约束提供了一种更方便，更准确的方法来描述端口的驱动能力。 <code>set_driving_cell</code> 可用于<strong>指定驱动输入端口的单元类型</strong>。但由于输入端口上的电容性负载而导致驱动单元的增量延迟被视作为输入上的附加延迟被包括在内</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318201910.png" alt="image.png" loading="lazy"></p>
<p>作为上述方法的替代方法, <code>set_input_transition</code> 约束提供了一种在输入端口表示过渡时间的便捷方法，并且可以指定参考时钟</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318202047.png" alt="image.png" loading="lazy"></p>
<h4 id="负载电容建模">负载电容建模</h4>
<blockquote>
<p>指定输出上的负载很重要，因为该值会影响驱动输出的单元的延迟。在没有该约束的情况下，将假定负载为0，这显然是不现实的。</p>
</blockquote>
<p><code>set_load</code> 约束在输出端口上设置了电容性负载，以<strong>模拟由输出端口驱动的外部负载</strong>。默认情况下，端口上的电容性负载为0。可以将负载显式地<strong>指定为电容值或某个单元的输入引脚电容</strong>。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318202309.png" alt="image.png" loading="lazy"></p>
<h3 id="drv">DRV</h3>
<p>STA中两个常用的设计规则是最大过渡时间<code>-max_transition</code>和最大电容<code>-max_capacitance</code>。这些规则将会检查设计中的<strong>所有端口和引脚是否满足过渡时间和电容的规定约束</strong>。</p>
<p>此外，还可以为设计指定其他设计规则检查，比如: <code>set_max_fanout</code> (指定设计中所有引脚的扇出约束) 以及 <code>set_max_area</code> (用于设计)。但是，<strong>这些检查适用于综合(synthesis)而非STA</strong>。</p>
<h2 id="delay-calculation">Delay Calculation</h2>
<h3 id="延迟计算基本概念">延迟计算基本概念</h3>
<p>由上文可知，<strong>每个单元的输入引脚都存在引脚电容</strong>，所以<strong>每条 net 都将具有容性负载</strong>，其值为所有 fanout 的引脚负载电容及互连线的寄生电容之和。</p>
<p>考虑如下设计：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315142157.png" alt="image.png" loading="lazy"></p>
<p>对于 <code>NET0</code>, 在不考虑互联寄生的情况下，其电容等于 <code>UAND1</code> 和 <code>UNOR2</code> 的输入引脚电容之和。由此，可将上图等价为:</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315142658.png" alt="image.png" loading="lazy"></p>
<p>输出 <code>O1</code> 的负载电容等价于输出端口负载（未指定，可通过 <code>set_load</code> 指定）加上 <code>UNOR2</code> 输入引脚负载电容（已在库中指定），所以此时只要为输入 <code>I1</code> 指定压摆（或 <code>set_drive</code>），即可获得单元 <code>UAND1</code> 相对于该 input transition 的 propagation delay and output transition（知道了上一级的 output transition, 则又可以得到下一级单元的 input transition）.</p>
<p>由于多输入单元存在不同输入到输出的多条 timing arc, 所以 output transition 的值由 slew merge 结果来决定。</p>
<h3 id="有效电容计算单元延迟">有效电容计算单元延迟</h3>
<p>当单元输出端的负载<strong>包含互连电阻</strong>时，NLDM模型不可直接使用。因此，<strong>采用“有效”电容法来处理电阻的影响</strong>。</p>
<p>有效电容法试图找到一个可以用作等效负载的电容，以使原始设计与具有等效电容负载的设计在单元输出的时序方面表现一致。这个等效电容被称为有效电容(effective capacitance)</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315144404.png" alt="image.png" loading="lazy"></p>
<p>即在实际情况下，互连寄生不能忽略电阻的影响，此时可将 RC 互连建模为更精简的 PI model。由于 NLDM 只接受电容，所以将 RC 计算为一个等效的 $C_{eff}$ ，进而可以继续使用 NLDM 查表得到单元延迟。那如何计算得到这个 $C_{eff}$ 则存在不同算法：如二阶 AWE, Arnoldi 算法等。</p>
<p>注意：虽然能够得到近似的单元延迟，但 <strong>output slew 与单元实际输出波形并不一致</strong>。</p>
<h3 id="net-delay">Net Delay</h3>
<p>对于有大学简单电路背景的同学应该很熟悉，走线延迟的本质是由于导通的电路是可以等效为电阻电容（R与C），其上信号传递的延迟可以简化为RC Delay。总体而言，走线的延迟取决于<strong>线宽、线长（Wire length）、工艺、扇出分支（Fanout）</strong>。而在不同EDA阶段，我们可以通过不同模型去预估两个引脚之间的走线延迟。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250327214609.png" alt="image.png" loading="lazy"></p>
<ol>
<li>逻辑综合：如Synopsys的Design Compiler，是基于走线负载模型（Wire Load Model，WLM）预估两个信号引脚之间的走线延迟。在这个设计环节，芯片设计还没走到布局布线，因此没有相对位置来具体的走线路径。因此WLM是根据扇出数量来估计网络的长度，从而获得延迟的（误差可想而知，<strong>毕竟扇出少的逻辑路径也可能在布局时被扯得很远</strong>）。WLM通常是由对应的ASIC/FPGA厂商会提供，然后设计者基于自己的设计进行微调即可，在一个设计中，不同层次位置、不同的走线可以配置不同的WLM，从而逼近实际延迟。</li>
<li>布局：布局期间知道了每个逻辑单元的具体位置，因此我们可以充分利用位置信息来推测路径：我们首先估计两个相连的逻辑单元之间线长是多少，随后<strong>通过线长，预估延迟</strong>。需要留意的是，<strong>虽然理论上走线越长，延迟越长，但是并不完全是线性关系</strong>，毕竟从广州北京，走高速开始开县道还是不一样的。通常而言，以Cadence Innovus的布线前、布局后（Post-placement pre-route）的时序估计是基于所谓的TrialRoute（尝试布线）[7]或Early Global Route （前期全局布线）[8]去估计布线情况，然后<strong>基于这个粗糙的布线情况，进行RC寄生参数的提取</strong>，然后将这些寄生参数与驱动单元的输入引脚电容相加，从而获得走线延迟。其中最重要的是如何获得一个准确的布线估计，<strong>一个准确的估计可以实现很小的布线前后的时序跳跃(Timing Jump)</strong>。</li>
<li>布线：在这期间不仅知道位置，还知道了具体的金属走线。因此此时可以直接的提取RC参数，然后跑时序分析引擎即可。</li>
</ol>
<h3 id="elmore-模型计算互连延迟">Elmore 模型计算互连延迟</h3>
<p>Elmore 是用于在特定条件的 RC 互连结构下<strong>计算 net delay</strong> 的延迟模型。</p>
<h3 id="压摆合并-tbd">压摆合并 (TBD)</h3>
<h3 id="路径延迟计算">路径延迟计算</h3>
<blockquote>
<p>回顾几个概念：timing path, timing arc</p>
</blockquote>
<p>理论上的 timing path 存在一个 start point 和一个 end point:</p>
<ul>
<li>start point: input port and clk pin</li>
<li>end point: d pin and output port</li>
</ul>
<p>所以，一共存在四种 timing path: <code>r2r</code>, <code>i2o</code>, <code>i2r</code> and <code>r2o</code></p>
<p>而 timing arc 用于描述:</p>
<ul>
<li>pin to pin 之间的信号传输关系（传输延迟以及如何变化）</li>
<li>timing constraints: setup/hold etc..</li>
</ul>
<p>所以，一但使用 timing arc annotate whole design, 则计算路径延时即<strong>将所有 net arc and cell arc 相加</strong>。</p>
<h4 id="i2o"><code>I2O</code></h4>
<p>第一种时序路径，即 input port to output port.</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315150750.png" alt="image.png" loading="lazy"></p>
<p>而从输入端口到第一个 load cell 需要特殊处理，即可以<strong>指定第一个反相器输入端的过渡时间(或压摆)</strong>，若没有此类指定的话，就假定过渡时间为0(相当于理想情况)。</p>
<ul>
<li>在 OpenSTA 中如果不指定的话第一个cell的load slew为0。在seedRootSlew时可以计算出root到第一个cell的load delay &amp; load slew</li>
</ul>
<p>此外，可根据第一个 cell 输出处的 RC 负载情况计算得到一个等效电容，进而查表得到第一个 cell delay 和 output slew.</p>
<p>当计算得到第一个 cell 的 output slew 后，又可以得到下一级单元的 input slew, 以此循环。</p>
<p>注意，和第一级输入类似，最后一级输出需要手动 <code>set_load</code>, 否则仅使用网络N3的线负载。</p>
<h4 id="i2r"><code>I2R</code></h4>
<p>类似计算。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315153711.png" alt="image.png" loading="lazy"></p>
<h4 id="r2r"><code>R2R</code></h4>
<p>类似计算。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315153823.png" alt="image.png" loading="lazy"></p>
<h2 id="timing-graph">Timing Graph</h2>
<p>STA breaks a design down into timing paths, calculates the signal propagation delay along each path, and checks for violations of timing constraints inside the design and at the input/output interface.</p>
<h3 id="timing-path">Timing Path</h3>
<p>timing path 存在 start and end point, 定义分别如下：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250313083312.png" alt="image.png" loading="lazy"></p>
<p>根据 start point 和 endpoint 可将 timing path 分为四类：</p>
<ul>
<li>input port to d pin, <code>I2R</code></li>
<li>clk pin to output port, <code>R2O</code></li>
<li>clk pin to d pin, <code>R2R</code></li>
<li>input port to output port, <code>I2O</code></li>
</ul>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250327100653.png" alt="image.png" loading="lazy"></p>
<p>时序路径为一段段时序弧的集合，除了可以根据起点和终点分类外，还可以 By signal type or timing check:&nbsp;<em>Data path</em>,&nbsp;<em>clock path</em>,&nbsp;<em>clock-gating path</em>,&nbsp;<em>asynchornous path</em>.</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250327100634.png" alt="image.png" loading="lazy"></p>
<h3 id="timing-graph-1">Timing Graph</h3>
<p>考虑如下网表：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250313083803.png" alt="image.png" loading="lazy"></p>
<p>Convert the above circuit to a 'Direct Acyclic Graph (DAG)' shown below:</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250313083753.png" alt="image.png" loading="lazy"></p>
<h4 id="opensta-timing-graph">OpenSTA Timing Graph</h4>
<p>Timing graph is a flat DAG, though OpenSTA has full hierarchical netlist.</p>
<p>以下网表为例：<br>
<img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315102637.png" alt="image.png|425" loading="lazy"></p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315102724.png" alt="image.png" loading="lazy"></p>
<p>将其转换为时序图：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315102825.png" alt="image.png" loading="lazy"></p>
<p>vertex 定义为：Each Vertex corresponds to one network pin.</p>
<ul>
<li>包括了 internal pin (图中未画出)，</li>
</ul>
<p>edge 定义为：There is one Edge between each pair of pins that has a timing path between them.</p>
<p>每条 edge 有自己的 timing role: 代表这条 edge 可能是 cell delay or wire delay, 亦或是各种类型的 timing analysis</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315112342.png" alt="image.png|275" loading="lazy"></p>
<p>此外，一条 edge 上存储了一组 timing arc: A timing arc set is a group of related timing arcs between from/to a pair of cell ports. &nbsp;Wire timing arcs are a special set owned by the TimingArcSet class.</p>
<h3 id="时序分析方式">时序分析方式</h3>
<p>以分析的方式区分，可分为 <code>Path-Based</code> 及 <code>Block-Based</code> 两种，他们的主要区别在于<strong>对特定逻辑单元的Transition Time（电平转换时间）的处理不同</strong>。</p>
<p>实际上，在电路工作过程中，一个逻辑单元收到的<strong>输入电平变换时间是由前级逻辑单元所影响的</strong>。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250327221319.png" alt="image.png|500" loading="lazy"></p>
<p>C pin 的 input transition 取决于上一级逻辑单元的 output transition, 而经不同输入引脚变换而引起的 output transition 不同，从而影响 C 的 input transition. 如何确定这个C处的电平转换时间是时序分析算法的差异。</p>
<h4 id="graph-base">Graph Base</h4>
<p>基于图的静态时序分析（GBA）是大多数工具默认的分析模式，它在从标准逻辑单元库（Standard Cell Library）中读取单元延迟时<strong>基于最差情况的电平转换时间进行计算</strong>。例如在上面的例子中，不管A\B如何跳变，都会取对C处电平延迟最大的电平转换时间，例如12ps。因此即使某个时序路径下，A的信号一直不变的，变化都只发生在B引脚，后面的蓝色或非门理应用B引脚引起的9ps电平转换时间，在GBA的分析算法中，仍将使用12ps。因此，<strong>GBA模式往往比较悲观，可能导致某些路径上的时序违例</strong>，因为实际跳变很可能不会导致每个逻辑单元都恰好引脚跳变引起最差电平转换时间。为了解决这种悲观性并提高准确性，引入了基于路径的静态时序分析（Path-based Analysis, PBA）</p>
<h4 id="path-based">Path Based</h4>
<p>PT 采用 path based 时序分析方法，将分析所有 timing path.</p>
<p>与GBA相比，PBA则会<strong>遍历所有可能的时序路径</strong>，（理论上）枚举所有可能的输入跳变组合来进行时序评估，因此可以获得最准确的时序分析结果。在上图的示例中，如果针对在B引脚的跳变，则PBA会实实在在地用B引脚的9ps跳变来计算下一级蓝色或非门的延迟。但因为相比于GBA，遍历了更多的情况，导致算法的运行时间极其慢，在复杂用例中，可能PBA会比GBA慢上一个数量级。</p>
<h4 id="gba-vs-pba">GBA Vs PBA</h4>
<p>对于同一个 combinational design, GBA vs PBA as shown below:</p>
<ul>
<li><code>min_delay_in_GBA</code> &lt;= <code>min_delay_in_PBA</code></li>
<li><code>max_delay_in_GBA</code> &gt;= <code>max_delay_in_PBA</code></li>
</ul>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318210150.png" alt="image.png" loading="lazy"></p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318210304.png" alt="image.png" loading="lazy"></p>
<p>In&nbsp;GBA (Graph Base Analysis), in place of choosing 2 combinations of AND gate (1) delay, i.e. (Combination_1:&nbsp;0.5ns, 1.5ns ;&nbsp;Combination_2:&nbsp;0.2ns, 1.2ns) we choose extreme boundaries, i.e.&nbsp;<strong>min delay = 0.2ns and max delay = 1.5ns.</strong></p>
<p>In case of&nbsp;<strong>PBA (Path base Analysis)</strong>, we are using actual delay between input pin and output combination (means choosing both combination of delay).</p>
<ul>
<li>Combination_1: 0.5ns, 1.5ns</li>
<li>Combination_2: 0.2ns, 1.2ns</li>
</ul>
<p>You might be thinking that this is not <strong>accurate</strong> (means why in GBA we missed 2 value), we are adding unnecessary delay in our calculation. And I am glad to say that you are right. 😃 The reason we are doing this because from tool point of view - doing analysis or say calculation as per <strong>GBA is very fast compare to PBA</strong>.&nbsp;<strong>Runtime of tool is very low.</strong>&nbsp;And only difference is that we are <strong>adding pessimism</strong> in our calculation.</p>
<ul>
<li>GBA is <strong>more faster</strong> than PBA</li>
<li>GBA is <strong>more pessimism</strong> than PBA</li>
</ul>
<hr>
<p>基于上述特性，GBA和PBA在静态时序分析中具有不同的用途。GBA可以实现快速但粗糙的分析，如果未检测到任何违规，那么因为GBA这么悲观都没有违例，PBA分析的结果则理应没有违规。<strong>如果GBA存在违规，我们则可以使用PBA</strong>，但无需再分析所有的时序路径，只需要分析GBA模式下产生违规的路径即可（当然也可以全局进行PBA）。</p>
<h5 id="gba-delay-calculation">GBA Delay Calculation</h5>
<p>每个 cell arc <strong>不管 rise fall or min max</strong>, 都取极端值，这使得计算更加简单快速，但因更加悲观而不够准确。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318210808.png" alt="image.png" loading="lazy"></p>
<h5 id="pba-delay-calculation">PBA Delay Calculation</h5>
<p>PBA 会穷尽一条 timing path 上的所有 arc combination</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318210917.png" alt="image.png" loading="lazy"></p>
<h3 id="基于图的静态时序分析原理">基于图的静态时序分析原理</h3>
<p>假设所有锁存器都是统一时间收到时钟上升沿（即忽略因布局引起的Clock Skew）。在这一系列的简化下，STA问题可以退化为：求有向图中，所有时序终点离最远的时序起点有多远（理论上讲是指Arrival Time，信号从源头到某个节点的延迟），即<strong>最长路径问题</strong>（参考：<a href="https://www.zhihu.com/question/278602624" target="_blank" rel="noopener nofollow">有向无环图中单源最长路径如何求？</a>，这里解决<strong>多源多汇最长路径</strong>），如下图所示。算法的简单描述就是<strong>从所有起点开始，遍历所有节点，更新节点距离起点的最远距离</strong>:</p>
<p>$$<br>
ArrivalTime[i] = max{ArrivalTime[Predessor[i, j]]+CellDelay[j]+NetDelay[i,j]}<br>
$$</p>
<p>其中i为当前节点编号，$Predecessor[i, j]$是指i节点的第j个前序节点的编号，$ArrivalTime[Predecessor[i, j]]$为源头信号抵达该前序节点的时间，$CellDelay[j]$为前序节点的逻辑时延，$NetDelay[i,j]$为经过该前序节点到节点i的走线延迟，可以根据该两个节点的坐标位置获取的。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250327223743.png" alt="image.png|550" loading="lazy"></p>
<h4 id="网表分级">网表分级</h4>
<p>由于布局一动就需要重新评估时序情况，所以在布局算法运行期间，针对多源多汇的最长路径算法会被频繁调用。由上面的递推公式可以知道，计算节点i的 $ArrivalTime[i]$ 之前，我们需要先已经获得它的前序节点的ArrivalTime，否则这些ArrivalTime的计算不能确保是最长的。而<strong>电路划分是为了进行并行化运算</strong>，即我们需要把电路中节点染色分块，<strong>每一块子图中的节点互不依赖</strong>（即互相之间没有连边，图不一定是联通的），<strong>对于每一块子图中的节点，我们可以并行计算</strong>。</p>
<p>为了实现满足这种特性的电路划分，基本的算法原理：在队列中存储所有的时序起点，并且将它标记为level=0。随后开始BFS，更新有向图中，每个节点离时序起点的最远距离，随后有向图会被标记：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250327224309.png" alt="image.png|675" loading="lazy"></p>
<h4 id="基于分层同步-bfs-的时序传递">基于分层同步 BFS 的时序传递</h4>
<h5 id="正向-bfs-计算到达时间">正向 BFS 计算到达时间</h5>
<p>可以留意到分层后level=i中的所有节点：（1）除了level=0的特例（level=0的起点单元会被强制标记为ArrivalTime=0，不进行计算），它们之间没有相互连边，即它们的时序计算之间没有依赖；（2）如果我们按照从level=0<sub>i的顺序计算ArrivalTime，当遍历直至level=i时，level=0</sub>i-1的节点都已经完成ArrivalTime的计算。<strong>即level=i的所有节点能同时进行它们的Arrival time计算</strong>，这时候我们就可以<strong>调用openmp等并行化框架进行加速</strong>。我们初始化所有的节点的Arrival time为0，然后跑上面提及的最长路径算法，即可推出下图中的时延信息：（右图中第三级最左边的节点 arrival time 应该为 10）</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250328090904.png" alt="image.png" loading="lazy"></p>
<h5 id="反向-bfs-计算-rat">反向 BFS 计算 RAT</h5>
<p>如上一节中的前向时延分析之后，我们就知道每一个终点离起点有多远了。但是可能设计者对于每个终点有不同的约束，它们可能希望其中某些信号早些抵达特定的时序终点，因此这时候会有时序裕量（Timing Slack）的概念：</p>
<p>$$Timing Slack = Required Arrival Time （用户指定的） - Arrival Time（实际抵达时间）$$</p>
<p>如果Timing Slack小于0，则说明信号来迟了，存在时序违例。其中 Arrival Time 是在前向时序传递完成了计算。通常对于时序终点，Required Arrival Time（RAT）为时钟周期减去建立时间（Clock Period - Setup Time）。<strong>但是对于中间每一个时序节点，设计者通常是不会设置RAT的</strong>。因此在STA中，我们需要<strong>做反向的时序传递，从而让除了终点外的每一个节点，都知道自己实际上被要求多早获得信号</strong>，就很像我们上班时候的项目管理，每个任务节点都需要自己要在什么时间前完成才不给后续大伙挖坑。</p>
<p>而反向时序传递的基本方法与正向传递基本一致，只是之前正向公式为：</p>
<p>$$ArrivalTime[i] = max{ArrivalTime[Predecessor[i, j]]+CellDelay[j]+NetDelay[i,j]}$$</p>
<p>而反向为：</p>
<p>$$RequiredArrivalTime[i] = min{RequiredArrivalTime[Successor[i, j]] - NetDelay[i,j]} - CellDelay[i]$$</p>
<p>其中$RequiredArrivalTime[i]$为节点i的RAT，而$RequiredArrivalTime[Successor[i, j]]$是指节点i的第j个后序节点的RAT，$NetDelay[i,j]$为两个节点之间的走线延迟，而$CellDelay[i]$是指节点i的逻辑时延。</p>
<p>根据上面公式的变换，我们也需要<strong>反向重新进行网表分层</strong>，如下图：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250328090939.png" alt="image.png" loading="lazy"></p>
<p>我们<strong>初始化所有的节点的RAT为无穷大</strong>，而终点节点的RAT则为设计者指定，然后跑我们上面提及的最长路算法，即可推出下图中的RAT信息，其中我们<strong>假设所有终点RAT为20</strong>：</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250328090955.png" alt="image.png" loading="lazy"></p>
<h4 id="增量式时序分析">增量式时序分析</h4>
<p>如果在布局时进行局部调整，则没必要进行全局 STA, 因为全局分析缓慢低效，而很多节点的时序可能是没变的。这时候我们的正向、反向的分层都不需要动，我只需<strong>根据出现变化的节点，将他们的所有前序节点和后续节点重新放到上面的BFS流程中</strong>，就可以实现快速增量式时序分析。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250328091036.png" alt="image.png" loading="lazy"></p>
<p>当红色节点被移动时，只有蓝色和橙色覆盖的节点需要重新进行STA</p>
<h2 id="timing-analysis">Timing Analysis</h2>
<p>时序分析主要关注 setup and hold violation, 分别对应最差和最优情况。此外，还需掌握以下命令的使用：</p>
<ul>
<li><code>set_input_delay</code></li>
<li><code>set_output_delay</code></li>
<li><code>set_drive</code>, <code>set_driving_cell</code> and <code>set_input_transition</code></li>
<li><code>set_load</code></li>
</ul>
<h3 id="setup">Setup</h3>
<p><strong>输入的数据</strong>必须在<strong>有效时钟沿之前保持稳定的最短时间</strong>称为建立时间(setup time)。注意：这是<strong>根据最晚</strong>的(the latest)数据信号超过其阈值(通常为Vdd的50%)到有效时钟沿超过其阈值(通常为Vdd的50%)的时间间隔测量的。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315162726.png" alt="image.png" loading="lazy"></p>
<p>在时钟的有效沿到达触发器之前，数据应在一定时间内保持稳定，即触发器的建立时间，该要求将<strong>确保数据可靠地被捕获到触发器中</strong>。</p>
<ul>
<li>注意，建立时间检查允许 launch 和 capture 归属不同时钟域。</li>
</ul>
<h4 id="setup-case-1">Setup case 1</h4>
<p>以下图为例，时钟 CLKM 周期为 $T_{cycle}$</p>
<ul>
<li>对于 launch path: 时钟 CLKM 到达触发器 <code>UFF0</code> 时钟引脚的时间 $T_{launch}$ + 触发器 <code>UFF0</code> 自身的 propagation delay ($T_{ck2q}$) + Data path delay ($T_{dp}$)</li>
<li>对于 capture path: 时钟 CLKM 到达触发器 <code>UFF1</code> 时钟引脚的时间 $T_{capture}$ + 时钟周期 $T_{cycle}$</li>
</ul>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315163057.png" alt="image.png|500" loading="lazy"></p>
<p>由于在 capture 建立时间约束要求数据信号相对于时钟信号需要至少提前一个建立时间保持稳定，所以需要满足公式：</p>
<p>$$<br>
T_{launch} + T_{ck2q} + T_{dp} &lt; T_{cycle} + T_{capture} - T_{setup}<br>
$$</p>
<h4 id="arrival-and-required-in-setup">Arrival and Required in Setup</h4>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250327101615.png" alt="image.png" loading="lazy"></p>
<p>已知 setup check 需满足：（上图为具体的 case，下式为 generic 公式）</p>
<p>$$<br>
T_{launch} + T_{ck2q} + T_{dp} &lt; T_{cycle} + T_{capture} - T_{setup}<br>
$$</p>
<p>则 require 和 arrival time 定义如下：</p>
<ul>
<li>require time: capture path delay</li>
<li>arrival time: launch path delay</li>
</ul>
<p>由于 slack 需要 &gt;= 0, 则有如下公式：</p>
<p>$$<br>
T_{cycle} + T_{capture} - T_{launch} - (T_{ck2q} + T_{dp}) - T_{setup} &gt;= 0<br>
$$</p>
<h4 id="r2r-setup-check"><code>R2R</code> Setup Check</h4>
<p>解析下述时序报告：</p>
<ul>
<li>start point &amp; end point 都是触发器，且由时钟 CLKM 上升沿触发</li>
<li>path group: 由 capture ff 决定</li>
<li>path type: max, i.e. setup time check</li>
<li>clock network delay is zero as it's ideal clock network
<ul>
<li>i.e. $T_{launch}$ and $T_{capture}$ is zero</li>
</ul>
</li>
<li>clock uncertainty
<ul>
<li>jitter</li>
<li>setup time</li>
</ul>
</li>
</ul>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315165904.png" alt="image.png" loading="lazy"></p>
<h5 id="clock-network-delay">Clock Network Delay</h5>
<p>时序报告中的时钟网络延迟(clock network delay)是什么？为什么将其标记为理想(ideal)？时序报告中的这一行表明时钟树被认为是理想的，时钟路径中的任何缓冲器(buffer)都假定为零延迟。一旦构建了时钟树，就可以将时钟网络标记为“已传播”(propagated)，从而使得时钟路径显示实际延迟值。</p>
<ul>
<li>时钟网络延迟用于在建立时钟树之前(即在时钟树综合之前)对通过时钟路径的延迟进行建模。一旦建立了时钟树并标记为了 “已传播”(propagated)，便会忽略此时钟网络延迟约束。<code>set_clock_latency</code> 命令也可用于对从主时钟到其衍生时钟的延迟进行建模</li>
</ul>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315171425.png" alt="image.png" loading="lazy"></p>
<p>此外，如果是显示的时钟树，即插入了 clock buffer:</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315172043.png" alt="image.png|475" loading="lazy"></p>
<p>第一个 cell 的 delay 需要知道自己的 input transition，所以需要通过 <code>set_drive, set_driving_cell or set_input_transition</code> 来显式指定，否则认为其 input transition 为 0</p>
<p>此外，clock source latency, i.e. insertion delay 的定义为：时钟源端到 DUA 时钟定义点的延迟。通过命令 <code>set_clock_latency -source</code></p>
<ul>
<li>this command will set clock network delay if w/o source option</li>
</ul>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315172621.png" alt="image.png" loading="lazy"></p>
<h4 id="i2r-setup-check"><code>I2R</code> Setup Check</h4>
<ul>
<li>设置相对于虚拟时钟或实际时钟的外部输入延迟：<code>set_input_delay</code></li>
</ul>
<hr>
<p>从输入端口到寄存器的时序路径可由虚拟时钟或实际时钟触发，如下：</p>
<p>该时钟可以被认为是驱动设计输入端口INA的虚拟触发器，<strong>该虚拟触发器的时钟为 VIRTUAL_CLKM</strong>。此外，从该虚拟触发器的时钟引脚到输入端口INA的最大延迟指定为2.55ns，在报告中显示为input external delay</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318075826.png" alt="image.png" loading="lazy"></p>
<p>输入延迟也可以<strong>相对于实际时钟来指定</strong>,并不一定必须相对于虚拟时钟来指定。实际时钟可以是设计中的内部引脚或者输入端口上的时钟</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318075945.png" alt="image.png" loading="lazy"></p>
<h4 id="r2o-setup-check"><code>R2O</code> Setup Check</h4>
<ul>
<li><code>set_output_delay</code></li>
<li><code>set_load</code></li>
</ul>
<hr>
<p>与上述输入端口约束类似，可以<strong>相对于虚拟时钟或设计中的内部时钟来约束输出端口</strong>，或者可以相对于实际的输入时钟端口或输出时钟端口来约束输出端口。</p>
<p>为了确定<strong>最后一个单元连接到输出端口的延迟</strong>，需要指定该端口上的负载，上面使用了 <code>set_load</code> 命令来指定输出负载。请注意，端口ROUT可能在DUA内部具有负载，而set_load约束<strong>指定的是额外的负载</strong>，即来自DUA外部的负载。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318080340.png" alt="image.png" loading="lazy"></p>
<p>注意在 <code>R2O</code> 路径中，其 endpoint 的 setup check 计算为 $T_{period} - T_{output}$</p>
<h4 id="i2o-setup-check"><code>I2O</code> Setup Check</h4>
<p>设计也可以具有从输入端口到输出端口的纯组合逻辑路径。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250318080645.png" alt="image.png" loading="lazy"></p>
<h3 id="hold">Hold</h3>
<p>保持时间(hold time)是在<strong>时钟有效沿之后输入的数据必须保持稳定的最短时间</strong>，这也是根据有效时钟沿超过其阈值到<strong>最早的</strong>(the earliest)数据信号超过其阈值的时间间隔来度量的。</p>
<p>保持时间检查可确保<strong>正在变化的触发器输出值不会传递到捕获触发器</strong>、并在捕获触发器有机会捕获其原始值之前重写 (overwrite)其输出。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315173947.png" alt="image.png" loading="lazy"></p>
<p>保持时间违例针对最快的 launch path 进行分析，需要限制最快到达 D pin 的信号也能够相对于时钟信号至少保持稳定一个 hold time 的稳定状态. 所以公式为：</p>
<p>$$<br>
T_{launch} + T_{ck2q} + T_{dp} &gt; T_{capture} + T_{hold}<br>
$$</p>
<h4 id="required-and-arrival-in-hold-check">Required and Arrival in Hold Check</h4>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250327104014.png" alt="image.png" loading="lazy"></p>
<p>由于 launch delay 为 arrival, 而 capture 为 require time, 并且在 hold check 中要求 arrival time 需要晚于 require time, 所以</p>
<p>$$<br>
T_{arrival} = T_{launch} + T_{ck2q} + T_{dp}<br>
$$</p>
<p>$$<br>
T_{require} = T_{capture} + T_{hold}<br>
$$</p>
<p>$$<br>
T_{arrival} &gt; T_{require}<br>
$$</p>
<h4 id="hold-time-check">Hold time Check</h4>
<p>一般在 CTS 后才分析 hold time violation</p>
<h3 id="其余分析类型">其余分析类型</h3>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315101459.png" alt="image.png" loading="lazy"></p>
<h4 id="slew-analysis">Slew Analysis</h4>
<p>Two Types Slew/Transition Analysis.</p>
<ol>
<li>Data(max/min)</li>
<li>clock(max/min)</li>
</ol>
<h4 id="load-analysis">Load Analysis</h4>
<p>Two Types Of Load Analysis</p>
<ol>
<li>Fanout(max/main)</li>
<li>Capacitance(max/min)</li>
</ol>
<h4 id="clock-analysis">Clock Analysis</h4>
<p>Two Types of Clock Analysis</p>
<ol>
<li>Skew : Difference between the latencies (L1,L2,L3,L4 etc.,) are referred to as skew.</li>
<li>Pulse Width : This type of analysis is performed due to the clock tree network that has parasitic elements in the clock network path we need to see upto which point the pulse width gets degraded to.</li>
</ol>
<h2 id="interconnect-parasitics">Interconnect Parasitics</h2>
<p>net 通常为 single driver and multi load。并且在物理实现后, net可以在芯片的多个金属层上移动，同时各种金属层可以具有不同的电阻和电容值。</p>
<p>对于等效的电气表示，通常<strong>将网络划分为多个段(segment)</strong>，每个段均由等效的寄生参数表示。我们也将段称为<strong>互连走线(interconnect trace)</strong>, 即特定金属层上网络的一部分。</p>
<h3 id="互连-rlc">互连 RLC</h3>
<p>互连 RC 由图中穿过不同金属层的 net 造成，包括:</p>
<ul>
<li>互连电阻(R)来自设计实现中各种金属层和过孔(vias)中的互连走线。我们可以将互连电阻视为单元的输出引脚与扇出单元的输入<strong>引脚之间的电阻</strong>。</li>
<li>互连电容(C)也来自金属走线,包括接地电容以及相邻信号路径之间的电容。</li>
<li>不考虑互连电感 L</li>
</ul>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315135513.png" alt="image.png" loading="lazy"></p>
<p>理想情况下，互连走线一部分的<strong>电阻和电容(RC)用分布式(distributed)RC树</strong>表示。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315135922.png" alt="image.png" loading="lazy"></p>
<p>此外，还可以采用简化方式来 model RC tree</p>
<h4 id="t-model">T Model</h4>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315140108.png" alt="image.png" loading="lazy"></p>
<h4 id="π-model">Π Model</h4>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315140119.png" alt="image.png" loading="lazy"></p>
<h3 id="wlm">WLM</h3>
<p>在物理实现之前，可以使用线负载模型(wireload models)来<strong>估计由互连线带来的电容、电阻以及面积开销</strong>。线负载模型可用于<strong>根据扇出数量来估计网络的长度</strong>，<strong>线负载模型取决于块(block)的面积</strong>，具有不同面积的设计可以选择不同的线负载模型。线负载模型还可以<strong>将网络的估计长度映射(map)为电阻、电容以及由于布线而产生的相应面积开销</strong>。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315140752.png" alt="image.png" loading="lazy"></p>
<ul>
<li>线负载模型用于根据 fanout 估算线长，并得到对应的 RC 及面积开销。</li>
<li>线负载模型由单元面积所决定。随着块的面积增大，走线也会增长。</li>
</ul>
<p>对于不同的面积(芯片或块)，通常将使用不同的线负载模型来确定寄生效应。</p>
<p><img src="https://joy-1314155565.cos.ap-shanghai.myqcloud.com/pic/20250315140812.png" alt="image.png" loading="lazy"></p>
<h3 id="指定线负载模型-tbd">指定线负载模型 (TBD)</h3>
<blockquote>
<p>todo</p>
</blockquote>
<p>通过指令 <code>set_wire_load_model</code> 指定线负载模型，并可通过 <code>set_wire_load_mode</code> 指定线负载模式</p>
<h3 id="互连树-tbd">互连树 (TBD)</h3>
<blockquote>
<p>todo</p>
<ul>
<li>what is the difference between t/pi model and rc tree?</li>
</ul>
</blockquote>
<p>由于从驱动引脚(driver pin)到负载引脚(load pin)的互连延迟不仅需要 RC 值，也取决于互连的结构。</p>
<h2 id="refs">Refs</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/345536827" target="_blank" rel="noopener nofollow">静态时序分析圣经翻译计划——汇总篇</a></li>
<li><a href="https://www.zhihu.com/question/54079224/answer/27941211538" target="_blank" rel="noopener nofollow">如何学习数字电路中的静态时序分析？</a></li>
<li><a href="https://blog.csdn.net/weixin_43698385/article/details/127132540" target="_blank" rel="noopener nofollow">[静态时序分析简明教程(一)] 绪论_静态时序分析时综合的一步吗-CSDN博客</a></li>
<li><a href="https://github.com/Gogireddyravikiran/Static-Timing-Analysis" target="_blank" rel="noopener nofollow">GitHub - Gogireddyravikiran/Static-Timing-Analysis</a></li>
<li><a href="https://book.douban.com/subject/30180948/" target="_blank" rel="noopener nofollow">集成电路静态时序分析与建模 (豆瓣)</a></li>
<li><a href="https://www.bilibili.com/video/BV1if4y1p7Dq/?spm_id_from=333.1387.0.0" target="_blank" rel="noopener nofollow">数字集成电路静态时序分析基础_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.vlsi-expert.com/2017/11/pba-vs-gba-1.html" target="_blank" rel="noopener nofollow">Path Base Analysis (PBA) Vs Graph Base Analysis (GBA) - part1 |VLSI Concepts</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/683865906" target="_blank" rel="noopener nofollow">设计VLSI EDA(5): 时序(Timing)分析你的电路反射弧有多长</a></li>
<li><a href="https://github.com/brabect1/sta_basics_course/blob/master/doc/sta_basics_course.rst" target="_blank" rel="noopener nofollow">sta_basics_course/doc/sta_basics_course.rst at master · brabect1/sta_basics_course · GitHub</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.689967195380787" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-29 18:35">2025-03-29 18:32</span>&nbsp;
<a href="https://www.cnblogs.com/zj99">joytown</a>&nbsp;
阅读(<span id="post_view_count">32</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18799748" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18799748);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18799748', targetLink: 'https://www.cnblogs.com/zj99/p/18799748', title: 'Static Timing Analysis Basics' })">举报</a>
</div>
        