
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/many-bucket/p/18956769" title="发布于 2025-06-29 21:14">
    <span role="heading" aria-level="2">以接口肢解bean factory，源码没那么神秘</span>
    

</a>

	</div>
	<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>本来昨天在看 spring frame的八股， 看到了IOC部分，但是实在看不懂是什么东西，讲是讲源码部分，但又不完全讲，我想着那我要不自己看一下源码</p>
</blockquote>
<p>这是我画的Bean Factory的大致关系图</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3642195/202506/3642195-20250629211318369-1488247909.png" class="lazyload"></p>
<p>删去了bean别名管理接口（AliasRegistry）和bean定义接口（BeanDefinitionRegistry）避免复杂理解</p>
<p><code>BeanFactory</code>有三个子类<code>ListableBeanFactory</code> ，<code>HierarchicalBeanFactory</code>，<code>ConfigurableBeanFactory</code> ，<code>AutowireCapableBeanFactory</code> 。</p>
<p>我们先来看看<code>BeanFactory</code> 只实现了IOC 容器的基本行为规范，好比是让需求方提出对目标的需求。</p>
<pre><code class="language-java">public interface BeanFactory {
//与FactoryBean创建的bean区分开来, 若命名的bean是FactoryBean，
//则获取将返回Factory，而不是Factory返回的实例。
    String FACTORY_BEAN_PREFIX = "&amp;";

    Object getBean(String var1) throws BeansException;

    &lt;T&gt; T getBean(String var1, Class&lt;T&gt; var2) throws BeansException;

    Object getBean(String var1, Object... var2) throws BeansException;

    &lt;T&gt; T getBean(Class&lt;T&gt; var1) throws BeansException;

    &lt;T&gt; T getBean(Class&lt;T&gt; var1, Object... var2) throws BeansException;

    &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; var1);

    &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType var1);

    boolean containsBean(String var1);

    boolean isSingleton(String var1) throws NoSuchBeanDefinitionException;

    boolean isPrototype(String var1) throws NoSuchBeanDefinitionException;

    boolean isTypeMatch(String var1, ResolvableType var2) throws NoSuchBeanDefinitionException;

    boolean isTypeMatch(String var1, Class&lt;?&gt; var2) throws NoSuchBeanDefinitionException;

    @Nullable
    Class&lt;?&gt; getType(String var1) throws NoSuchBeanDefinitionException;

    @Nullable
    Class&lt;?&gt; getType(String var1, boolean var2) throws NoSuchBeanDefinitionException;

    String[] getAliases(String var1);
}

</code></pre>
<p><code>ListableBeanFactory</code> 定义了Factory Bean的可枚举性，适用于批量操作 bean 的场景</p>
<pre><code class="language-java">public interface ListableBeanFactory extends BeanFactory {
    boolean containsBeanDefinition(String var1);

    int getBeanDefinitionCount();

    String[] getBeanDefinitionNames();

    &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; var1, boolean var2);

    &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType var1, boolean var2);

    String[] getBeanNamesForType(ResolvableType var1);

    String[] getBeanNamesForType(ResolvableType var1, boolean var2, boolean var3);

    String[] getBeanNamesForType(@Nullable Class&lt;?&gt; var1);

    String[] getBeanNamesForType(@Nullable Class&lt;?&gt; var1, boolean var2, boolean var3);

    &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(@Nullable Class&lt;T&gt; var1) throws BeansException;

    &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(@Nullable Class&lt;T&gt; var1, boolean var2, boolean var3) throws BeansException;

    String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; var1);

    Map&lt;String, Object&gt; getBeansWithAnnotation(Class&lt;? extends Annotation&gt; var1) throws BeansException;

    @Nullable
    &lt;A extends Annotation&gt; A findAnnotationOnBean(String var1, Class&lt;A&gt; var2) throws NoSuchBeanDefinitionException;

    @Nullable
    &lt;A extends Annotation&gt; A findAnnotationOnBean(String var1, Class&lt;A&gt; var2, boolean var3) throws NoSuchBeanDefinitionException;
}
</code></pre>
<p><code>HierarchicalBeanFactory</code> 定义了Bean Factory的分层能力</p>
<p>之前还不知道Bean Factory可以有父子容器区分</p>
<p>Spring MVC 有以下分层</p>
<ul>
<li>根上下文（ContextLoaderListener 或 Spring Boot 创建）作为父容器。</li>
</ul>
<p>如服务层、数据访问层和基础设施 bean（DataSource）。</p>
<ul>
<li>DispatcherServlet 的上下文作为子容器。</li>
</ul>
<p>定义 Web 层特定 bean，如控制器、HandlerMapping 等。</p>
<pre><code class="language-java">public interface HierarchicalBeanFactory extends BeanFactory {
    @Nullable
    BeanFactory getParentBeanFactory();

    boolean containsLocalBean(String var1);
}
</code></pre>
<p><code>ConfigurableBeanFactory</code> 定义了自定义Bean工厂的能力 ， 自定义类加载器、beany定义、作用域、依赖关系。</p>
<pre><code class="language-java">
public interface ConfigurableBeanFactory extends HierarchicalBeanFactory, SingletonBeanRegistry {
    // 自定义类加载器
    void setBeanClassLoader(@Nullable ClassLoader var1);
    @Nullable
    ClassLoader getBeanClassLoader();
    void setTempClassLoader(@Nullable ClassLoader var1);
    @Nullable
    ClassLoader getTempClassLoader();

    // bean 定义
    void setCacheBeanMetadata(boolean var1);
    boolean isCacheBeanMetadata();
    BeanDefinition getMergedBeanDefinition(String var1) throws NoSuchBeanDefinitionException;
    boolean isFactoryBean(String var1) throws NoSuchBeanDefinitionException;

    // 作用域
    void registerScope(String var1, Scope var2);
    String[] getRegisteredScopeNames();
    @Nullable
    Scope getRegisteredScope(String var1);

    // 依赖关系
    void registerDependentBean(String var1, String var2);
    String[] getDependentBeans(String var1);
    String[] getDependenciesForBean(String var1);
    
    ......
    ......
}
</code></pre>
<p><code>AutowireCapableBeanFactory</code> 实现了Bean自动装配能力</p>
<pre><code class="language-java">public interface AutowireCapableBeanFactory extends BeanFactory {
    int AUTOWIRE_NO = 0;
    int AUTOWIRE_BY_NAME = 1;
    int AUTOWIRE_BY_TYPE = 2;
    int AUTOWIRE_CONSTRUCTOR = 3;
    /** @deprecated */
    @Deprecated
    int AUTOWIRE_AUTODETECT = 4;
    String ORIGINAL_INSTANCE_SUFFIX = ".ORIGINAL";

    &lt;T&gt; T createBean(Class&lt;T&gt; var1) throws BeansException;

    void autowireBean(Object var1) throws BeansException;

    Object configureBean(Object var1, String var2) throws BeansException;

    Object createBean(Class&lt;?&gt; var1, int var2, boolean var3) throws BeansException;

    Object autowire(Class&lt;?&gt; var1, int var2, boolean var3) throws BeansException;

    void autowireBeanProperties(Object var1, int var2, boolean var3) throws BeansException;

    void applyBeanPropertyValues(Object var1, String var2) throws BeansException;

    Object initializeBean(Object var1, String var2) throws BeansException;

    Object applyBeanPostProcessorsBeforeInitialization(Object var1, String var2) throws BeansException;

    Object applyBeanPostProcessorsAfterInitialization(Object var1, String var2) throws BeansException;

    void destroyBean(Object var1);

    &lt;T&gt; NamedBeanHolder&lt;T&gt; resolveNamedBean(Class&lt;T&gt; var1) throws BeansException;

    Object resolveBeanByName(String var1, DependencyDescriptor var2) throws BeansException;

    @Nullable
    Object resolveDependency(DependencyDescriptor var1, @Nullable String var2) throws BeansException;

    @Nullable
    Object resolveDependency(DependencyDescriptor var1, @Nullable String var2, @Nullable Set&lt;String&gt; var3, @Nullable TypeConverter var4) throws BeansException;
}

</code></pre>
<p>看完了这些接口类和接口方法，对IOC容器有了更扩展一些的理解</p>
<p>其实源码还是挺容易看的，先通过一个类向上找到基类，再往下看详细的接口类，实现类。 对其有一个全局的理解</p>

</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-06-29 21:15">2025-06-29 21:14</span>&nbsp;
<a href="https://www.cnblogs.com/many-bucket">crhl-yy</a>&nbsp;
阅读(<span id="post_view_count">2</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18956769);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18956769', targetLink: 'https://www.cnblogs.com/many-bucket/p/18956769', title: '以接口肢解bean factory，源码没那么神秘' })">举报</a>
</div>
