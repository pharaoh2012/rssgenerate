
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19046147" title="发布于 2025-08-19 10:47">
    <span role="heading" aria-level="2">【渲染流水线】[光栅阶段]-[片元着色]以UnityURP为例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250819105340356-36829822.png" alt="【渲染流水线】[光栅阶段]-[片元着色]以UnityURP为例" class="desc_img">
        本文深入解析Unity URP渲染管线中片元着色器的核心功能与实现细节。重点介绍了：1）片元着色器在纹理采样、光照计算和特效处理中的关键作用；2）输入输出语义体系（如SV_POSITION、TEXCOORD0-7等）及其典型应用场景；3）URP常用纹理变量（_MainTex、_NormalMap等）的规范用法；4）基于导数函数（ddx/ddy）的边缘检测等高级技术实现。文章还对比了URP与前向/延迟渲染的差异，并提供了移动端优化建议，如数据打包和纹理数组应用。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<ul>
<li>在Unity URP渲染管线中，光栅化阶段的片元着色器(Fragment Shader)是决定像素最终颜色的核心环节。</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<h1 id="核心功能"><strong>核心功能</strong>‌：</h1>
<ul>
<li>纹理采样：通过UV坐标从贴图获取颜色数据</li>
<li>光照计算：结合材质属性和光源信息计算逐像素光照</li>
<li>特效处理：实现透明度混合、边缘检测等后处理效果</li>
</ul>
<h1 id="可配置">‌<strong>可配置</strong>‌：</h1>
<ul>
<li>重写片元函数（<code>#pragma fragment frag</code>）。语义、纹理用途、</li>
</ul>
<h1 id="语义体系"><strong>语义体系</strong></h1>
<h2 id="输入结构体v2f语义"><strong>输入结构体(v2f)语义</strong></h2>
<ul>
<li><code>SV_POSITION</code>：裁剪空间顶点位置（必需），由顶点着色器输出</li>
<li><code>TEXCOORD0-7</code>：通用插值寄存器，存储UV坐标/自定义数据（如法线、视向量）</li>
<li><code>COLOR0-1</code>：顶点颜色通道，常用于渐变效果或数据传递</li>
<li><code>NORMAL</code>：世界空间法线向量（需手动计算后传递）</li>
</ul>
<h2 id="输出语义"><strong>输出语义</strong></h2>
<ul>
<li><code>SV_Target</code>：写入渲染目标（默认颜色缓冲）</li>
<li><code>SV_Depth</code>：自定义深度值输出（需显式启用）</li>
</ul>
<h1 id="texcoord0-7和color0-1语义的常用数据存储内容"><code>TEXCOORD0-7</code>和<code>COLOR0-1</code>语义的常用数据存储内容</h1>
<table>
<thead>
<tr>
<th>‌<strong>语义</strong>‌</th>
<th>‌<strong>常用存储数据</strong>‌</th>
<th>‌<strong>典型应用场景</strong>‌</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TEXCOORD0</code></td>
<td>主纹理UV坐标</td>
<td>采样漫反射贴图（_MainTex）</td>
</tr>
<tr>
<td><code>TEXCOORD1</code></td>
<td>次要纹理UV坐标</td>
<td>光照贴图、细节纹理叠加</td>
</tr>
<tr>
<td><code>TEXCOORD2</code></td>
<td>世界空间法线向量</td>
<td>法线贴图计算、光照模型处理</td>
</tr>
<tr>
<td><code>TEXCOORD3</code></td>
<td>世界空间切线向量</td>
<td>切线空间转换、法线映射</td>
</tr>
<tr>
<td><code>TEXCOORD4</code></td>
<td>世界空间视线方向</td>
<td>高光反射计算、视差效果</td>
</tr>
<tr>
<td><code>TEXCOORD5</code></td>
<td>世界空间顶点位置</td>
<td>动态雾效、距离衰减计算</td>
</tr>
<tr>
<td><code>TEXCOORD6-7</code></td>
<td>自定义数据或额外UV集</td>
<td>顶点动画参数、流动贴图、多纹理混合</td>
</tr>
<tr>
<td><code>COLOR0</code></td>
<td>顶点颜色主通道</td>
<td>顶点着色效果、渐变色处理（如植被/地形）</td>
</tr>
<tr>
<td><code>COLOR1</code></td>
<td>顶点颜色辅助通道</td>
<td>特殊效果遮罩、动态参数传递（如溶解阈值）</td>
</tr>
</tbody>
</table>
<h2 id="关键说明"><strong>关键说明：</strong></h2>
<ul>
<li>
<p>‌<strong>数据复用性</strong>‌</p>
<p><code>TEXCOORD</code>语义本质上是通用插值寄存器，实际用途根据Shader需求动态分配4。例如简单着色器可能仅用<code>TEXCOORD0</code>，而复杂PBR材质会占用更多通道。</p>
</li>
<li>
<p>‌<strong>优化建议</strong>‌</p>
<p>URP推荐将关联数据打包到同一寄存器（如法线/切线共用<code>TEXCOORD2-3</code>），减少插值计算开销。</p>
</li>
<li>
<p>‌<strong>通道限制</strong>‌</p>
<p>移动端平台最多支持8个<code>TEXCOORD</code>和2个<code>COLOR</code>通道，超限需通过数据压缩或纹理烘焙解决</p>
</li>
</ul>
<h1 id="内容映射表"><strong>内容映射表</strong></h1>
<h2 id="核心纹理变量">核心纹理变量</h2>
<table>
<thead>
<tr>
<th>纹理变量名</th>
<th>来源类/脚本</th>
<th>用途说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_MainTex</code></td>
<td><code>Material</code>属性面板</td>
<td>基础颜色/Albedo贴图（通过<code>[MainTexture]</code>特性标记）</td>
</tr>
<tr>
<td><code>_BaseMap</code></td>
<td>URP Shader内置变量</td>
<td>替代<code>_MainTex</code>的标准化命名（URP 7.0+版本推荐使用）</td>
</tr>
<tr>
<td><code>_NormalMap</code></td>
<td><code>Standard Shader</code>/自定义Shader</td>
<td>切线空间法线贴图（需配合<code>BUMP</code>关键字启用）</td>
</tr>
<tr>
<td><code>_MetallicGlossMap</code></td>
<td>PBR材质系统</td>
<td>金属度(R)和光滑度(A)通道存储</td>
</tr>
<tr>
<td><code>_EmissionMap</code></td>
<td><code>Material</code>发光属性</td>
<td>自发光纹理（需启用<code>_EMISSION</code>关键字）</td>
</tr>
</tbody>
</table>
<h2 id="特殊功能纹理"><strong>‌特殊功能纹理‌</strong></h2>
<table>
<thead>
<tr>
<th><strong>纹理变量名</strong></th>
<th><strong>来源类/脚本</strong></th>
<th><strong>用途说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_OcclusionMap</code></td>
<td>光照探针系统</td>
<td>环境光遮蔽贴图（通常存储在G通道）</td>
</tr>
<tr>
<td><code>_DetailAlbedoMap</code></td>
<td>细节层材质</td>
<td>表面微结构纹理（通过<code>_DETAIL</code>宏控制）</td>
</tr>
<tr>
<td><code>_ParallaxMap</code></td>
<td>高度图效果</td>
<td>视差偏移贴图（需启用<code>_PARALLAXMAP</code>）</td>
</tr>
<tr>
<td><code>_SpecGlossMap</code></td>
<td>旧版高光工作流</td>
<td>高光颜色(RGB)和光滑度(A)替代金属度贴图</td>
</tr>
</tbody>
</table>
<h2 id="渲染管线专用纹理"><strong>‌渲染管线专用纹理‌</strong></h2>
<table>
<thead>
<tr>
<th><strong>纹理变量名</strong></th>
<th><strong>来源类/脚本</strong></th>
<th><strong>用途说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_CameraColorTexture</code></td>
<td>URP&nbsp;<code>RendererFeature</code></td>
<td>相机颜色缓冲（后处理输入）</td>
</tr>
<tr>
<td><code>_CameraDepthTexture</code></td>
<td>URP&nbsp;<code>DepthTexture</code>模式</td>
<td>场景深度图（需在URP Asset中启用）</td>
</tr>
<tr>
<td><code>_ScreenSpaceOcclusion</code></td>
<td>SSAO效果</td>
<td>屏幕空间环境遮蔽图（通过<code>SSAO</code>&nbsp;Renderer Feature生成）</td>
</tr>
</tbody>
</table>
<h2 id="脚本动态引用示例"><strong>‌脚本动态引用示例‌</strong></h2>
<pre><code class="language-glsl">hlsl
// C#脚本中通过Material类设置纹理
material.SetTexture("_MainTex", Resources.Load&lt;Texture2D&gt;("Albedo"));
</code></pre>
<ul>
<li>该代码通过<code>Material.SetTexture</code>方法动态绑定纹理</li>
<li>纹理变量命名遵循URP核心库规范（<code>Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl</code>），其中<code>WS</code>后缀表示世界空间坐标，<code>RWS</code>为相机相对坐标。移动端需注意通过<code>SAMPLER</code>宏声明采样器以兼容GLES2.0平台</li>
</ul>
<h2 id="纹理数组高级应用"><strong>纹理数组高级应用</strong></h2>
<pre><code class="language-glsl">Texture2DArray _TextureArray;  // 声明纹理数组 
float _LayerIndex;             // 动态切换纹理层  
fixed4 frag(v2f i) : SV_Target {
     return tex2DArray(_TextureArray, float3(i.uv, _LayerIndex));
}
</code></pre>
<p>该技术适用于地形系统（不同区块材质切换）或角色换装系统</p>
<h1 id="片元着色器中的导数信息"><strong>片元着色器中的导数信息</strong></h1>
<p>每次片元着色器处理片元时都<strong>独立处理单个片元</strong>，因此片元在处理时无法得到临近片元信息。</p>
<p>实际GPU在运行时并不是只运行一个片元着色器，而是将其2x2的一组片元块，同时运行4个片元着色器。 通过ddx和ddy（URP中可通过<code>ddx</code>/<code>ddy</code>函数获取屏幕空间导数）两个偏导函数求得临近片元的差值。（偏导函数时纹理mipmaps实现的基础）</p>
<p><img alt="Image" loading="lazy" data-src="https://img.notionusercontent.com/s3/prod-files-secure%2F66e0fe7b-1a4b-48ff-b1ca-bd80212154ec%2Fa6dbf2ab-7bf5-498a-9dac-6d521660b3f9%2FIMG_20250723_184946(2).jpg/size/w=2000?exp=1755055058&amp;sig=fHXVYh-EvtNeMntSASBCkCS63OV5y1SfLqXMlL8RSbc&amp;id=23924489-bbde-8081-8858-e139f81dcc5a&amp;table=block&amp;userId=f97b3955-c81a-4615-8bdb-f8deb4f3401c" class="lazyload"></p>
<h2 id="作用">‌<strong>作用</strong>‌：</h2>
<ul>
<li>边缘检测：通过颜色/深度突变识别物体轮廓</li>
<li>Mipmap层级选择：动态调整纹理采样精度</li>
<li>屏幕空间特效：如SSAO、运动模糊等</li>
</ul>
<h2 id="urp中基于导数的边缘检测示例">URP中基于导数的边缘检测示例</h2>
<ul>
<li>
<p>使用HLSL标准导数函数ddx/ddy</p>
</li>
<li>
<p>通过颜色梯度检测边缘</p>
</li>
<li>
<p>可调节阈值控制边缘灵敏度</p>
</li>
<li>
<p>兼容URP渲染管线</p>
</li>
<li>
<p><strong>EdgeDetection.shader</strong></p>
<pre><code class="language-glsl">Shader "Custom/EdgeDetection" {
    Properties {
        _MainTex ("Base (RGB)", 2D) = "white" {}
        _EdgeColor ("Edge Color", Color) = (1,0,0,1)
        _Threshold ("Threshold", Range(0,1)) = 0.1
    }
    SubShader {
        Pass {
            HLSLPROGRAM
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            
            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            float4 _EdgeColor;
            float _Threshold;

            struct v2f {
                float4 pos : SV_POSITION;
                float2 uv : TEXCOORD0;
            };

            v2f vert(Attributes v) {
                v2f o;
                o.pos = TransformObjectToHClip(v.positionOS);
                o.uv = v.uv;
                return o;
            }

            half4 frag(v2f i) : SV_Target {
                half3 col = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv).rgb;
                
                // 计算屏幕空间导数
                half3 dx = ddx(col);
                half3 dy = ddy(col);
                float edge = sqrt(dot(dx,dx) + dot(dy,dy));
                
                // 边缘检测
                edge = step(_Threshold, edge);
                return lerp(float4(col,1), _EdgeColor, edge);
            }
            ENDHLSL
        }
    }
}
</code></pre>
</li>
</ul>
<p>在<strong>延迟渲染</strong>中，片元着色器会利用G缓冲中的深度/法线信息进行更精确的光照计算，而<strong>前向渲染</strong>则直接在每个Pass中处理光照（内置管线每个pass处理灯光，URP中将所有灯光汇聚在一个Pass中处理）。URP通过优化后的着色器变体减少重复计算，提升多光源场景性能。</p>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.004861111111111111" data-date-updated="2025-08-19 10:54">2025-08-19 10:47</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
阅读(<span id="post_view_count">80</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19046147);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19046147', targetLink: 'https://www.cnblogs.com/SmalBox/p/19046147', title: '【渲染流水线】[光栅阶段]-[片元着色]以UnityURP为例' })">举报</a>
</div>
        