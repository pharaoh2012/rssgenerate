
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ishoulgodo/p/18695658" title="发布于 2025-01-31 10:45">
    <span role="heading" aria-level="2">java中的ArrayBlockingQueue</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h4 id="arrayblockingqueue">ArrayBlockingQueue</h4>
<p>ArrayBlockingQueue 是 Java 并发包 (java.util.concurrent) 中的一个线程安全的阻塞队列实现。<br>
它基于数组实现，容量固定，支持先进先出的顺序。<br>
Array Blocking Queue 数组阻塞队列 读音: [əˈreɪ]  [ˈblɒkɪŋ] [kjuː]<br>
concurrent   同时发生的  /kənˈkʌrənt/<br>
peek  偷看;窥视  /piːk/</p>
<h4 id="arrayblockingqueue的常见方法">ArrayBlockingQueue的常见方法</h4>
<p>添加元素<br>
1,boolean add(E e)将元素添加到队列尾部。如果队列已满，抛出异常。返回值是布尔类型<br>
2,boolean offer(E e)将元素添加到队列尾部。如果队列已满，返回 false。返回值是布尔类型[常用]<br>
3, void put(E e)将元素添加到队列尾部。如果队列已满，会造成阻塞，最好抛出异常<br>
移除元素<br>
1,E remove()移除并返回队列头部的元素。如果队列为空，抛出 NoSuchElementException，最好抛出异常。<br>
2,E poll()移除并返回队列头部的元素。如果队列为空，返回 null[常用]<br>
3,E take()移除并返回队列头部的元素。如果队列为空，就会造成阻塞。最好抛出异常,take必须放置在try-catch中，否则会在编译的时不会通过。<br>
查看元素<br>
1,E element()返回队列头部的元素(不移除)。如果队列为空，抛出 NoSuchElementException。<br>
2,E peek()返回队列头部的元素(不移除)。如果队列为空，返回 null[常用]<br>
其他方法<br>
1,int size()返回队列中的元素数量。<br>
2,int remainingCapacity()返回队列剩余的容量。<br>
3,boolean contains(Object o)检查队列是否包含指定元素。<br>
4,void clear()清空队列中的所有元素。<br>
5,Object[] toArray()将队列转换为数组。<br>
ps: E 表示泛型<br>
<img src="https://img2024.cnblogs.com/blog/1972489/202501/1972489-20250131104503558-2074481967.jpg" alt="" loading="lazy"></p>
<h4 id="arrayblockingqueueadd-添加元素">ArrayBlockingQueue.add 添加元素</h4>
<p>ArrayBlockingQueue.add 添加数据的时候。<br>
如果添加的长度已经大于了设置的长度。<br>
在程序运行的时候会报错 Queue full 队列已满</p>
<pre><code class="language-java">package part;
// 在util-&gt;concurrent包下
import java.util.concurrent.ArrayBlockingQueue;

public class Java01 {
    public static void main(String[] args) {
        ArrayBlockingQueue queue = new ArrayBlockingQueue(3);
        queue.add("张三");
        queue.add("李四");
        queue.add("wangwu");
        queue.add("赵六");
        // 会出现报错，Queue full 队列已满
        System.out.println(queue);
    }
}
</code></pre>
<h4 id="arrayblockingqueueput-添加元素超出设置的长度会造成阻塞">ArrayBlockingQueue.put 添加元素,超出设置的长度会造成阻塞</h4>
<p>我们设置ArrayBlockingQueue的长度是3<br>
当我们添加数据的长度大于3的时候<br>
程序是会出现错误：编译不会通过，使用异常捕获后，还是会造成阻塞<br>
挂号:赵六 输不出来</p>
<pre><code class="language-java">
package part;
// 在util-&gt;concurrent包下
import java.util.concurrent.ArrayBlockingQueue;
public class Java01 {
    public static void main(String[] args) {
        ArrayBlockingQueue queue = new ArrayBlockingQueue(3);
        try{
            queue.put("张三");
            System.out.println("挂号:张三");
            queue.put("李四");
            System.out.println("挂号:李四");
            queue.put("wangwu");
            System.out.println("挂号:wangwu");
            queue.put("赵六");
            System.out.println("挂号:赵六");
            System.out.println(queue);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202501/1972489-20250131104044641-1114146131.png" alt="" loading="lazy"></p>
<h5 id="arrayblockingqueueoffer-添加元素">ArrayBlockingQueue.offer 添加元素</h5>
<p>ArrayBlockingQueue.offer 也是新增数据的。<br>
它的返回值是布尔值。<br>
如果放入进去了。返回true,没有放进去，返回false。</p>
<pre><code class="language-java">package part;
// 在util-&gt;concurrent包下
import java.util.concurrent.ArrayBlockingQueue;
public class Java01 {
    public static void main(String[] args) {
        ArrayBlockingQueue queue = new ArrayBlockingQueue(2);
        Boolean BoolA= queue.offer("A");
        Boolean BoolB= queue.offer("B");
        Boolean BoolC= queue.offer("C");
        System.out.println(BoolA); // true
        System.out.println(BoolB); // true
        System.out.println(BoolC); // false
    }
}
</code></pre>
<h4 id="arrayblockingqueuepoll">ArrayBlockingQueue.poll()</h4>
<p>ArrayBlockingQueue.poll()	移除并返回队列头部的元素。如果队列为空，返回 null。</p>
<pre><code class="language-java">
public class Java01 {
    public static void main(String[] args) {
        ArrayBlockingQueue queue = new ArrayBlockingQueue(3);
        Boolean BoolA= queue.offer("A");
        Boolean BoolB= queue.offer("B");
        Boolean BoolC= queue.offer("C");
        // [A, B, C]
       System.out.println(queue);
       // poll: 移除并返回队列头部的元素。如果队列为空，返回 null。
        // 队列头部的元素是A,因此A会被移除，并返回A
        System.out.println( queue.poll()); // 输出的是 A
        // [B, C]
        System.out.println(queue);
    }
}
</code></pre>
<h4 id="arrayblockingqueueremove移除并返回队列头部的元素">ArrayBlockingQueue.remove()移除并返回队列头部的元素</h4>
<p>E ArrayBlockingQueue.remove()移除并返回队列头部的元素。<br>
如果队列为空，抛出 NoSuchElementException，最好抛出异常。</p>
<pre><code class="language-java">package part;
// 在util-&gt;concurrent包下
import java.util.concurrent.ArrayBlockingQueue;
public class Java01 {
    public static void main(String[] args) {
        ArrayBlockingQueue queue = new ArrayBlockingQueue(3);
        Boolean BoolA= queue.offer("A");
        Boolean BoolB= queue.offer("B");
        Boolean BoolC= queue.offer("C");
        // [A, B, C]
       System.out.println(queue);

        System.out.println( queue.remove());
        System.out.println( queue.remove());
        System.out.println( queue.remove());
        // 报错 Exception in thread "main" java.util.NoSuchElementException
        // 因为：此时队列已经是空(空数组)在移除就会报错了
        System.out.println(queue.remove());
    }
}
</code></pre>
<h4 id="take移除并返回队列头部的元素如果队列为空就会造成阻塞">take()移除并返回队列头部的元素。如果队列为空，就会造成阻塞。</h4>
<p>E ArrayBlockingQueue.take()移除并返回队列头部的元素。<br>
如果队列为空，就会造成阻塞。<br>
最好抛出异常,take必须放置在try-catch中，否则会在编译的时不会通过。</p>
<pre><code class="language-java">package part;
// 在util-&gt;concurrent包下
import java.util.concurrent.ArrayBlockingQueue;
public class Java01 {
    public static void main(String[] args) {
        ArrayBlockingQueue queue = new ArrayBlockingQueue(3);
        Boolean BoolA= queue.offer("A");
        Boolean BoolB= queue.offer("B");
        Boolean BoolC= queue.offer("C");
        // [A, B, C]
        System.out.println(queue);
        try{
            System.out.println( queue.take());
            System.out.println( queue.take());
            System.out.println( queue.take());
            // take必须放置在try-catch中，否则会在编译的时不会通过。
            // 如果队列为空，就会造成阻塞。
            System.out.println(queue.take());
        }catch (Exception e){
            System.out.println(e);
        }
    }
}
</code></pre>
<h4 id="element返回队列头部的元素不移除如果队列为空抛出异常">element返回队列头部的元素(不移除)如果队列为空，抛出异常。</h4>
<p>E element()返回队列头部的元素(不移除)。如果队列为空，抛出 NoSuchElementException。</p>
<pre><code class="language-java">
package part;
// 在util-&gt;concurrent包下
import java.util.concurrent.ArrayBlockingQueue;
public class Java01 {
    public static void main(String[] args) throws InterruptedException {
        ArrayBlockingQueue queue = new ArrayBlockingQueue(3);
        Boolean BoolA= queue.offer("A");
        Boolean BoolB= queue.offer("B");
        Boolean BoolC= queue.offer("C");
        // [A, B, C]
        System.out.println(queue);
        System.out.println(queue.element()); // 输出A
        System.out.println(queue.element()); // 输出A
    }
}
</code></pre>
<pre><code class="language-java">package part;
// 在util-&gt;concurrent包下
import java.util.concurrent.ArrayBlockingQueue;
public class Java01 {
    public static void main(String[] args) throws InterruptedException {
        ArrayBlockingQueue queue = new ArrayBlockingQueue(3);
        Boolean BoolA= queue.offer("A");
        Boolean BoolB= queue.offer("B");
        Boolean BoolC= queue.offer("C");
        // 清空
        queue.clear();
        // 输出 []
        System.out.println(queue);
        // 报错，因为：如果队列为空，抛出 NoSuchElementException。
        System.out.println(queue.element());
    }
}
</code></pre>
<h4 id="使用queueelement安全的写法">使用queue.element()安全的写法</h4>
<pre><code class="language-java">
package part;
// 在util-&gt;concurrent包下
import java.util.concurrent.ArrayBlockingQueue;

public class Java01 {
    public static void main(String[] args) throws InterruptedException {
        ArrayBlockingQueue queue = new ArrayBlockingQueue(3);
        Boolean BoolA= queue.offer("A");
        Boolean BoolB= queue.offer("B");
        Boolean BoolC= queue.offer("C");
        // 清空
        queue.clear();
        // 输出 []
        System.out.println(queue);
        // 安全的写法，如果是空数组，就不会取出来。或者使用peek
        if(queue.size() &gt;0){
            System.out.println(queue.element());
        }
    }
}
</code></pre>
<h4 id="使用-peek-返回队列头部的元素不移除如果队列为空返回-null">使用 peek() 返回队列头部的元素(不移除)。如果队列为空，返回 null。</h4>
<pre><code class="language-java">package part;
// 在util-&gt;concurrent包下
import java.util.concurrent.ArrayBlockingQueue;

public class Java01 {
    public static void main(String[] args) throws InterruptedException {
        ArrayBlockingQueue queue = new ArrayBlockingQueue(3);
        Boolean BoolA= queue.offer("A");
        Boolean BoolB= queue.offer("B");
        Boolean BoolC= queue.offer("C");
        System.out.println(queue.peek()); // A
        queue.clear();
        System.out.println(queue.peek()); // null
    }
}
</code></pre>
<h4 id="remainingcapacity方法返回的值返回队列剩余的容量">remainingCapacity方法返回的值返回队列剩余的容量</h4>
<p>remainingCapacity() 方法返回的值返回队列剩余的容量。具体来说:<br>
如果队列是空的，返回值是初始容量减去当前队列中元素的数量<br>
如果队列已经满了，返回的剩余容量将为0。<br>
在其他情况下，返回的剩余容量将是初始容量减去当前队列中元素的数量。</p>
<pre><code class="language-java">package part;
// 在util-&gt;concurrent包下
import java.util.concurrent.ArrayBlockingQueue;
public class Java01 {
    public static void main(String[] args) throws InterruptedException {
        ArrayBlockingQueue queue = new ArrayBlockingQueue(3);
        Boolean BoolA= queue.offer("A");
        Boolean BoolB= queue.offer("B");
        Boolean BoolC= queue.offer("C");
        // 3-3 =0 输出的是0
        System.out.println(queue.remainingCapacity());
        // 获取对队列中的元素数量
        int len = queue.size();
        System.out.println(len);// 3
        //检查队列是否包含指定元素B,包含的话，返回trie
        Boolean hasExist =queue.contains("B");
        System.out.println(hasExist); // true
        //  移除并返回队列头部的元素。如果队列为空，返回 null。
        queue.poll();
        System.out.println(queue);  // [B, C]
        // 3-2 = 1
        System.out.println(queue.remainingCapacity());
    }
}
</code></pre>
<h4 id="尾声">尾声</h4>
<p>准备开始学习java了。<br>
今天学习的第四天，每天都会发文章，我要卷起来。<br>
请小伙伴们监督我，奥利给</p>

</div>
<div id="MySignature" role="contentinfo">
    <div style="width:818px;background:#f5f5f5; padding: 10px 10px 10px 10px; border: 1px dashed rgb(224, 224, 224); font-family: 微软雅黑; font-size: 13px;">
		    <div style="padding:10px">
		        作者：<a href="https://www.cnblogs.com/ishoulgodo/" target="_blank">流年少年</a> <br>
		        出处：<a href="https://www.cnblogs.com/ishoulgodo/">https://www.cnblogs.com/ishoulgodo/</a> <br>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
		        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>
		        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
				<div style="display: flex;">
					<div style="margin-right: 100px;text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179">
						<div>
							支付宝
						</div>
					</div>
					<div style="text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg">
						<div>微信</div>
					</div>
				</div>
		        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br>
		        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br>
		    </div>
		</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.016778088597222223" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-31 10:45">2025-01-31 10:45</span>&nbsp;
<a href="https://www.cnblogs.com/ishoulgodo">何人陪我共长生</a>&nbsp;
阅读(<span id="post_view_count">2</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18695658" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18695658);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18695658', targetLink: 'https://www.cnblogs.com/ishoulgodo/p/18695658', title: 'java中的ArrayBlockingQueue' })">举报</a>
</div>
        