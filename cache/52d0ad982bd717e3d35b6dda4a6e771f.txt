
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/KubeExplorer/p/18674820" title="发布于 2025-01-16 13:37">
    <span role="heading" aria-level="2">大模型微调基本概念指北</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><img src="https://img.lixueduan.com/ai/cover/finetune-concept.png" alt="finetune-concept.png" loading="lazy"></p>
<p>本文主要分享一下大模型微调相关的基本概念，包括大模型(GPT)训练流程、微调(SFT)方法&amp;分类&amp;框架&amp;最佳实践、强化学习(RLHF)，最后则是分享了如何训练垂直领域大模型。</p>

<hr>
<p>本文是参考网上博客、文章后进行总结而成，旨在让刚接触大模型的同学阅读后能对大模型训练的各个阶段有一个大致的概念。大佬可以直接跳过，或者也可以帮忙看下写错没有哈哈~</p>
<blockquote>
<p>如果你在阅读过程中发现文中存在错误，请一定留言指正，感谢~</p>
</blockquote>
<h2 id="1-大模型训练流程">1. 大模型训练流程</h2>
<h3 id="chatgpt-是如何炼成的">ChatGPT 是如何炼成的</h3>
<p><em><strong>ChatGPT是如何炼成的，或者说如何训练出一个大模型？</strong></em></p>
<p>GPT 训练流程图如下：</p>
<p><img src="https://img.lixueduan.com/ai/finetune/gpt-train-pipeline.png" alt="gpt-train-pipeline.png" loading="lazy"></p>
<blockquote>
<p>图源：<a href="https://medium.com/@chassweeting/the-state-of-gpt-by-andrew-kaparthy-fad2f007c1b9" target="_blank" rel="noopener nofollow">medium.com</a></p>
</blockquote>
<p>图中的 Reward Modeling 和 Reinforcement Learning 可以看做一步，即 RLHF，因此训练一个大模型一般可以分为三步：</p>
<ul>
<li>1）<strong>预训练（Pre Training，PT）</strong>：这一阶段是模型训练的基础，利用海量数据、大量算力通过无监督训练得到<strong>基座模型</strong>。
<ul>
<li><strong>海量数据</strong>：一般按 T 计算，最少也是几百 G，数据通常包括从互联网上收集的大规模文本语料库，模型通过学习如何预测下一个词或 token</li>
<li><strong>大量算力</strong>：一般是上万块 GPU、时间则是按月计算</li>
<li>Llama 2 是在 2万亿个 token 上训练的，Llama 2 70B 需要 1720320 GPU 小时</li>
<li>Llama 3 在 24K GPU 集群上训练，使用了 15T 的数据</li>
<li>预训练后的模型具备强大的语言生成能力，但由于它主要是无监督训练的结果，可能不会直接适应具体的任务（如问答、对话），需要进一步的微调。</li>
</ul>
</li>
<li>2）<strong>监督微调（Supervised Fine-Tuning, SFT）</strong>：这一阶段则是对基座模型进行微调，让模型能够适用特定任务，最终得到一个 <strong>SFT 模型</strong>。
<ul>
<li>微调的目的是让模型更好地理解特定任务的需求。例如，通过使用对话数据集对模型进行微调，可以让模型在遇到问题时生成更相关的答案，而不是简单地生成与问题相似的文本。</li>
<li>这些问答对话由人类准备的，通常是有标签的，包含了问题和答案对，或者其他特定任务的数据。</li>
</ul>
</li>
<li>3）<strong>强化学习（Reinforcement Learning from Human Feedback, RLHF）</strong>：这一阶段通过引入人类反馈（或者基于人类反馈训练的奖励模型）进一步优化模型的生成质量，使其生成的回答更符合用户的期望和人类的价值观。
<ul>
<li>一般根据 3H 原则进行打分：
<ul>
<li>Helpful：判断模型遵循用户指令以及推断指令的能力。</li>
<li>Honest：判断模型产生幻觉( 编造事实)的倾向。</li>
<li>Harmless：判断模型的输出是否适当、是否诋毁或包含贬义内容。</li>
</ul>
</li>
<li>由于直接从人类获取反馈的成本较高，通常会先训练一个奖励模型（Reward Model，RM）来代替人类打分，这样可以在RL的框架下进行大规模的自动优化。</li>
</ul>
</li>
</ul>
<p>预训练由于对算力和数据需求都比较大，因此一般玩家不会涉及到预训练，更多的是基于开源的基础模型（LLama、Baichuan、Qwen、ChatGLM...）做微调、强化学习以满足自身需求。</p>
<h3 id="模型名称各部分的含义">模型名称各部分的含义</h3>
<p>以 <code>Qwen1.5-14B-Chat-GQPT-Int4</code> 为例，可以分为 5 个部分，具体含义如下图：</p>
<p><img src="https://img.lixueduan.com/ai/finetune/model-name-means.png" alt="model-name-means.png" loading="lazy"></p>
<p>5 个参数含义如下：</p>
<ul>
<li><strong>模型系列</strong>：一般一个公司、组织的模型都会归属于同一个系列
<ul>
<li>比如阿里的 Qwen 系列、Meta 的 Llama 系列，智普的 Chatglm 系列</li>
</ul>
</li>
<li><strong>模型版本</strong>：一个系列的模型也会有多个版本，一般是有大更新时才会更新
<ul>
<li>比如 Qwen 系列就存在 Qwen、Qwen1.5、Qwen2 三个系列</li>
</ul>
</li>
<li><strong>参数量</strong>：一般为 xx B，B 为单位，表示 10 亿参数
<ul>
<li>比如 7B 则是有 70 亿参数，72B 则是 720 亿参数</li>
<li>这个只是一个大致范围，比如 68 亿、72 亿参数的模型一般也叫做 7B</li>
</ul>
</li>
<li><strong>微调</strong>：开源模型为了能够直接使用，一般会提供经过问答任务微调的版本，即 Chat 模型</li>
<li><strong>量化</strong>：为了降低内存占用有的也会提供量化版本，比如大模型一般使用 FP32/FP16 精度，即一个参数占 4 或者 2 字节，而量化则是将权重参数使用更低精度的格式来存放，比如量化为 FP8 则是只需要 1 字节，Int4 则只需要 4 位。</li>
</ul>
<p>我们需要注意的就是是否经过微调、量化：</p>
<ul>
<li>基座模型：不带任意后缀,或者 -Base 后缀，就是预训练后未经过微调的原始模型
<ul>
<li>比如 Qwen1.5、Llama3</li>
</ul>
</li>
<li>SFT 模型：带特定领域任务后缀，比如 xxx-chat，就是对基座模型做了问答任务微调。
<ul>
<li>比如 Qwen1.5-Chat、Baichuan2-Chat</li>
</ul>
</li>
<li>量化模型：它通过将模型中的高精度浮点数参数转换为低精度的整数参数来减少模型的存储和计算需求。这样做可以显著降低模型的内存占用，加快推理速度，并减少能耗。量化可以带来显著的效率提升，但也可能引入一些精度损失
<ul>
<li>GGUF：GGUF(以前称为GGML)是一种量化方法，允许用户使用 CPU 来运行 LLM，但也可以将其某些层加载到GPU以提高速度。</li>
<li>GQPT：GPTQ是一种 4 位量化的训练后量化(PTQ)方法，主要关注GPU推理和性能。</li>
<li>AWQ：是一种新格式(激活感知权重量化)，它是一种类似于 GPTQ的 量化方法。AWQ 和 GPTQ 作为方法有几个不同之处，但最重要的是 AWQ 假设并非所有权重对 LLM 的性能都同等重要。也就是说在量化过程中会跳过一小部分权重，这有助于减轻量化损失。所以他们的论文提到了与 GPTQ 相比的可以由显著加速，同时保持了相似的，有时甚至更好的性能。</li>
<li>...</li>
</ul>
</li>
</ul>
<p><em>如何选择合适的模型？</em></p>
<ul>
<li>如果是直接部署推理，建议选择 Chat 模型，如果资源不够则选择量化版本。</li>
<li>如果要做增量预训练、微调等操作则建议使用基座模型。</li>
</ul>
<h2 id="2-微调sft">2. 微调(SFT)</h2>
<h3 id="什么是大模型微调">什么是大模型微调</h3>
<p>大模型微调，通常指有<strong>监督微调（Supervised Fine-Tuning, SFT）</strong>，是在预训练模型（一般称为“基座模型”）的基础上进行的训练过程。</p>
<p>预训练模型通常已经掌握了广泛的语言知识和语义表示，但为了让模型在特定任务或领域上表现得更好，我们会在特定任务的数据集上对其进行微调。</p>
<h3 id="为什么需要微调">为什么需要微调</h3>
<p>微调是优化大模型在特定任务或领域表现的关键步骤。通过微调，模型不仅能在通用任务上表现出色，还能在特定应用场景中更好地满足用户的需求。它在任务性能、领域适应性、数据利用效率和计算成本等方面具有显著的优势。</p>
<p>具体为：</p>
<ul>
<li><strong>任务特定性能提升</strong>：预训练模型虽然有广泛的语言理解能力，但在特定任务上（如情感分析、问答系统、机器翻译等）的表现可能不尽如人意。微调通过在任务特定的数据上进一步训练，使模型能够更好地理解和执行该任务。</li>
<li><strong>领域适应性</strong>：预训练模型可能在一些通用领域表现良好，但在特定领域（如医学、法律、金融等）中可能难以准确理解专业术语和内容结构。通过微调，可以让模型更好地适应这些领域的语言特点，提高在这些领域中的应用效果。</li>
<li><strong>数据稀缺性</strong>：对于一些数据稀缺的任务或领域，获取大量标签数据可能比较困难。微调允许在有限的数据集上进行有效训练，从而在数据稀缺的情况下也能取得较好的性能。</li>
<li><strong>防止过拟合</strong>：预训练过程中模型可能会过度拟合于无监督学习的任务（如下一个词预测），而在特定任务中表现不佳。通过微调，可以让模型专注于特定任务的数据，这有助于减少过拟合的风险，提高模型在该任务上的泛化能力。</li>
<li><strong>成本效益</strong>：与使用 prompt 来引导模型行为相比，微调通常可以更高效地优化模型的表现。微调后的模型通常可以更直接地执行任务，减少了对复杂提示的依赖。同时，微调可以在更小的模型上实现类似于大型模型的性能，从而降低推理的计算成本和延迟，比如与使用通用的GPT-3.5模型相比，经过微调的小型模型（如LLaMA 7B）在成本效益上可能更具优势，尤其是在特定任务的执行上。</li>
</ul>
<h3 id="微调方法分类">微调方法分类</h3>
<p>微调根据更新参数量不同可以分为以下两种：</p>
<ul>
<li><strong>全量参数更新 Full Fine-tuning（FFT）</strong>：即对预训练模型的所有参数进行更新，训练速度较慢，消耗机器资源较多。</li>
<li><strong>参数高效微调 Parameter-Efficient Fine-Tuning（PEFT）</strong>：只对部分参数做调整，训练速度快，消耗机器资源少。</li>
</ul>
<blockquote>
<p>理论上，预训练和微调都可以做全量参数更新和部分参数更新，但是<strong>一般实际训练时都是 预训练 + 全量，微调 + 部分参数更新 这样组合的</strong>。</p>
</blockquote>
<p>FFT 的原理，就是用特定的数据，对大模型进行训练，将 W变成<em>W</em>′，<em>W</em>′相比W，最大的优点就是上述特定数据领域的表现会好很多。</p>
<p>但 FFT 也会带来一些问题，影响比较大的问题，主要有以下两个：</p>
<ul>
<li>一个是<strong>训练的成本会比较高</strong>，因为全量微调的参数量跟预训练的是一样多的；</li>
<li>一个是叫<strong>灾难性遗忘(Catastrophic Forgetting)</strong>，用特定训练数据去微调可能会把这个领域的表现变好，但也可能会把原来表现好的别的领域的能力变差。
<ul>
<li>可以理解为：修复一个 bug 的同时又在别的地方引入了一个新的 bug。</li>
</ul>
</li>
</ul>
<p>另外，<strong>随着模型规模变得越来越大，这使得在消费级硬件上进行全量微调变得不可行</strong>，这也给参数高效微调技术研究提供了空间。</p>
<p>PEFT 主要想解决的问题，就是 FFT 存在的上述两个问题，PEFT 也是目前比较主流的微调方案。</p>
<p><a href="https://arxiv.org/pdf/2303.15647" target="_blank" rel="noopener nofollow">Scaling Down to Scale Up: A Guide to Parameter-Efficient Fine-Tuning</a> 论文里系统地概述和比较了参数高效微调方法，涵盖了 2019 年 2 月至 2023 年 2 月之间发表的 40 多篇论文，作者在文中将 PEFT 分为三类：</p>
<ul>
<li><strong>添加额外参数的 Addition-based（A)</strong>
<ul>
<li>类似适配器的方法（Adapter-like methods）</li>
<li>软提示（Soft prompts）</li>
</ul>
</li>
<li><strong>选取部分参数更新 Selection-based（S）</strong></li>
<li><strong>引入重参数化 Reparametrization-based（R）</strong></li>
</ul>
<p><img src="https://img.lixueduan.com/ai/finetune/peft.png" alt="peft.png" loading="lazy"></p>
<p><strong>常见的 PEFT 方法：BitFit、Prompt Tuning、Prefix Tuning、P-Tuning、P-Tuning V2、Adapter Tuning、LoRA、QLoRA、MAM Adapter、UniPELT、 Freeze tuning  等等。</strong></p>
<p><img src="https://img.lixueduan.com/ai/finetune/sft-method.png" alt="sft-method.png" loading="lazy"></p>
<p>大致介绍：</p>
<ul>
<li>1）<strong>《BitFit: BitFit: Simple Parameter-efficient Fine-tuning or Transformer-based Masked Language-models》</strong>训练时只更新bias的参数或者部分bias参数</li>
<li>2）<strong>《Prefix Tuning: Prefix-Tuning: Optimizing Continuous Prompts for Generation》</strong>在输入token之前构造一段任务相关的virtual tokens作为Prefix，然后训练的时候只更新Prefix部分的参数，而PLM中的其他部分参数固定。</li>
<li>3）<strong>《Prompt Tuning: The Power of Scale for Parameter-Efficient Prompt Tuning》</strong> 该方法可以看作是Prefix Tuning的简化版本，它给每个任务定义了自己的Prompt，然后拼接到数据上作为输入，但只在输入层加入prompt tokens，并且不需要加入 MLP 进行调整来解决难训练的问题。</li>
<li>4）<strong>《P-Tuning:</strong> <strong>GPT</strong> <strong>Understands, Too 》</strong>该方法将Prompt转换为可以学习的Embedding层，并用MLP+LSTM的方式来对Prompt Embedding进行一层处理。相比Prefix Tuning，P-Tuning加入的可微的virtual token，但仅限于输入层，没有在每一层都加；另外，virtual token的位置也不一定是前缀，插入的位置是可选的。这里的出发点实际是把传统人工设计模版中的真实token替换成可微的virtual token</li>
<li>5）<strong>《P-Tuning v2: P-Tuning v2: Prompt Tuning Can Be Comparable to Fine-tuning Universally Across Scales and Tasks》</strong>该方法在每一层都加入了Prompts tokens作为输入，而不是仅仅加在输入层</li>
<li>6）<strong>《Adapter Tuning :Parameter-Efficient Transfer Learning fo NLP》</strong>,该方法设计了Adapter结构，并将其嵌入Transformer的结构里面，针对每一个Transformer层，增加了两个Adapter结构(分别是多头注意力的投影之后和第二个feed-forward层之后)，在训练时，固定住原来预训练模型的参数不变，只对新增的 Adapter 结构和 Layer Norm 层进行微调，从而保证了训练的高效性。</li>
<li>7）<strong>《LoRA: LOW-RANK ADAPTATION OF LARGE LANGUAGE MODELS》</strong>，该方法的核心思想就是通过低秩分解来模拟参数的改变量，从而以极小的参数量来实现大模型的间接训练.</li>
<li>....</li>
</ul>
<p>各自的特点：</p>
<ul>
<li><strong>BitFit</strong>: 只更新模型中的bias参数或部分bias参数。</li>
<li><strong>Prefix</strong> <strong>Tuning</strong>: 在模型输入前添加可训练的前缀向量。</li>
<li><strong>Prompt</strong> <strong>Tuning</strong>: 在输入层加入提示词（prompt tokens）进行微调。</li>
<li><strong>P-Tuning</strong>: 在模型的每层都加入可学习的提示词。</li>
<li><strong>Adapter</strong> <strong>Tuning</strong>: 在Transformer的每一层插入小型的适配器网络。</li>
<li><strong>LoRA</strong> <strong>(Low-Rank Adaptation)</strong>: 通过在模型的权重矩阵中引入低秩结构来进行微调。</li>
<li><strong>QLoRA(Quantized</strong> <strong>LoRA****)</strong>：提出了 NormalFloat 数据类型,通过量化降低基座模型的显存占用，使得 65B 模型在单GPU上可以完成训练。</li>
</ul>
<p>这部分微调技术也可以按照 PEFT 进行分类：</p>
<ul>
<li>1）增加额外参数的 A，如：Prefix Tuning、Prompt Tuning、Adapter Tuning及其变体。</li>
<li>2）选取一部分参数更新的 S，如：BitFit。</li>
<li>3）引入重参数化的 R，如：LoRA、AdaLoRA、QLoRA。</li>
<li>4）混合高效微调（混合多种微调方法），如：MAM Adapter、UniPELT</li>
</ul>
<p><strong>现在比较主流的几种 PEFT：Prompt Tuning、Prefix Tuning、LoRA、QLoRA。</strong></p>
<h3 id="训练框架选择">训练框架选择</h3>
<p>比较主流的几个微调工具：</p>
<ul>
<li><a href="https://github.com/huggingface/transformers" target="_blank" rel="noopener nofollow">huggingface/transformers</a>：最基础的一个库,提供了丰富的预训练模型和微调工具，支持大多数主流的NLP任务（如文本分类、序列标注、生成任务等）。适合进行快速实验和生产部署，有着广泛的社区支持。</li>
<li><a href="https://github.com/huggingface/peft" target="_blank" rel="noopener nofollow">huggingface/peft</a>：Parameter-Efficient Fine-Tuning，huggingface 开源的微调基础工具</li>
<li><a href="https://github.com/modelscope/ms-swift" target="_blank" rel="noopener nofollow">modelscope/ms-swift</a>：modelscope 开源的轻量级微调框架
<ul>
<li>以中文大模型为主，支持各类微调方法</li>
<li>可以通过执行脚本进行微调，也可以在代码环境中一键微调</li>
<li>自带微调数据集和验证数据集，可以一键微调 + 模型验证</li>
</ul>
</li>
<li><a href="https://github.com/hiyouga/LLaMA-Factory" target="_blank" rel="noopener nofollow">hiyouga/LLaMA-Factory</a>：全栈微调工具
<ul>
<li>支持海量模型 + 各种主流微调方法
<ul>
<li>运行脚本微调</li>
<li>基于 Web 端微调</li>
</ul>
</li>
<li>自带基础训练数据集</li>
<li>除微调外，支持增量预训练和全量微调</li>
</ul>
</li>
<li><a href="https://github.com/NVIDIA/Megatron-LM" target="_blank" rel="noopener nofollow">NVIDIA/Megatron-LM</a>：NVIDIA开发的大模型训练框架，支持大规模的预训练和微调。适用于需要极高性能和规模的大模型训练和微调。</li>
</ul>
<p>快速实验选择 Transformers 即可，超大规模的选择 NVIDIA/Megatron-LM，普通规模就选择使用较为简单的 hiyouga/LLaMA-Factory。</p>
<h2 id="3-sft-最佳实践">3. SFT 最佳实践</h2>
<ul>
<li>数据集的质量对模型微调至关重要，<strong>毫不夸张的说，微调后的模型效果80%取决于SFT 训练数据</strong>，少量高质的数据要比大量低质或者普通的数据要好很多。</li>
<li>超参数调整
<ul>
<li>Epochs：需要根据数据集多少动态调整</li>
<li>Learning Rate：根据不同微调方法 LR 也需要调整</li>
<li>Global BatchSize：调整 bs 可以加快训练速度，但是也会增加显存占用，需要根据 GPU 资源调整。</li>
</ul>
</li>
</ul>
<h3 id="数据集准备">数据集准备</h3>
<p>数据集的质量对模型微调至关重要，<strong>毫不夸张的说，微调后的模型效果80%取决于 SFT训练数据</strong>，少量高质的数据要比大量低质或者普通的数据要好很多。</p>
<ul>
<li>数据集格式：SFT数据一般以问答形式呈现,参考开源数据集：<a href="https://huggingface.co/datasets/BAAI/COIG" target="_blank" rel="noopener nofollow">BAAI/COIG</a></li>
<li>Prompt 优化，适当构建few-shot及COT（思维链，Chain-of-Thought）数据加入训练，可以有助于模型的指令理解以及多轮对话能力。</li>
<li>数据规模、多样性：通常1万条左右的精标数据即可发挥良好的效果，在扩充数据规模时需要注意数据多样性，多样性的数据可以提高模型性能</li>
<li>数据质量：挑选质量较高的数据，可以有效提高模型的性能。</li>
</ul>
<p><strong>1）数据集格式</strong></p>
<p>问答格式可以处理成多种文件格式, 例如JSONL, Excel File, CSV; 核心是要保持两个独立的字段, 即<strong>问题和答案</strong>。</p>
<p>例如：</p>
<pre><code class="language-JSON">[
  {
    "question": "特种珊瑚是一种海洋动物吗？",
    "answer": "特种珊瑚虽然生活在海洋中，但它属于珊瑚软体类的石珊瑚目，是一种动物。而海洋动物是海洋中所有异养型生物的总称，包括鱼类、鲸类、浮游动物和游泳动物等，特种珊瑚只是其中的一种。"
  }
]
</code></pre>
<p>2）Prompt 优化</p>
<ul>
<li>prompt优化主要在训练阶段，用于增强指令的多样性，让模型更好的理解指令
<ul>
<li>预测阶段的prompt优化主要用于无法进行finetune的场景，例如chatgpt/yiyan.baidu.com等。</li>
<li>对于特定下游任务，预测阶段建议与训练阶段保持一致或者接近的prompt，可以暂时忽略预测阶段的prompt优化。</li>
</ul>
</li>
<li>适当构建few shot 及COT(Chain of Thought) 数据加入训练，可以有助于模型的指令理解以及多轮对话能力。</li>
</ul>
<p>3）数据规模、数据多样性</p>
<p>在SFT上数据规模的重要性低于数据质量, <strong>通常 1 万条左右的精标数据即可发挥良好的效果</strong>。</p>
<p>在扩充数据规模时需要注意数据多样性，<strong>多样性的数据可以提高模型性能</strong>。</p>
<blockquote>
<p>在不扩大提示多样性的情况下扩大数据量时，收益会大大减少，而在优化数据质量时，收益会显著增加。</p>
</blockquote>
<p>4）数据质量</p>
<p><strong>挑选质量较高的数据，可以有效提高模型的性能。</strong></p>
<p>数据质量用户需尽量自己把控，避免出现一些错误，或者无意义的内容。虽然平台也可以提供数据质量筛选的能力，但不可避免出现错筛的情况。</p>
<p>数据质量可以通过 ppl、reward model，文本质量分类模型等方式进行初步评估。经过人工进行后续筛选。</p>
<h3 id="sft-超参数调整">SFT 超参数调整</h3>
<p>比如10万个样本2-3个epoch内为佳，2～5万个样本 一般是4-5个 epoch 并且领域增强的SFT数据不需要太多，质量一定要把握好，一般的领域总结回复的任务几百条数据即可（ 个人经验 ），视情况而定;小数据量可以适当增大epoch，让模型充分收敛。</p>
<ul>
<li>例如：EPOCH：100条数据时, Epoch为15，1000条数据时, Epoch为10，10000条数据时, Epoch为2。</li>
</ul>
<p>一般只需要关注以下 三个超参数的调整</p>
<ul>
<li>Epochs：需要根据数据集多少动态调整，比如 100 条数据时, Epoch 设置为 15，1000 条数据时, Epoch 为10，10000 条数据时, Epoch 为 2。</li>
<li>Learning Rate：根据不同微调方法 LR 也需要调整，对于 LoRA 的 peft 训练方式，同时可以适当增大 LR</li>
<li>Global batch_size：调整 bs 可以加快训练速度，但是也会增加显存占用，需要根据 GPU 资源调整。如增加accumulate step 32 64，当分布式节点增多时可以进一步增加batch_size，提高吞吐。</li>
</ul>
<h2 id="4-什么是强化学习rlhf">4. 什么是强化学习(RLHF)</h2>
<p>RLHF 是一种训练方式，并不是类似 Lora 这种的训练方法，RLHF 可以分为三阶段：</p>
<ul>
<li><strong>1）Language Model，LM：一个预训练语言模型 LM</strong>，对基础模型微调得到一个微调后的模型
<ul>
<li>使用人工标注的数据对预训练模型进行监督微调，以获得初始版本的生成模型。</li>
</ul>
</li>
<li>2）<strong>Reward Model，RM</strong>：训练一个奖励模型RM：训练一个奖励模型（Reward Model），用于评估生成模型的输出质量。
<ul>
<li>收集生成模型输出及其对应的人类反馈。这些反馈可以是评分、选择最佳输出、直接修改等形式。</li>
<li>使用这些反馈数据训练奖励模型，使其能够对生成的输出进行评分。</li>
<li>奖励模型通常是一个监督学习模型，通过最小化预测评分与人类反馈评分之间的差距进行训练。</li>
</ul>
</li>
<li>3）<strong>Reinforcement Learning，RL</strong>：用强化学习 RL 方式微调 LM ：使用强化学习算法（如 <strong>PPO（Proximal Policy Optimization）</strong>）进一步优化第一步中生成的模型，使其输出更符合人类反馈的期望。
<ul>
<li>使用初始生成模型产生输出，并通过奖励模型评估这些输出的质量</li>
<li>使用 PPO 算法，根据奖励模型的评分更新生成模型的参数。
<ul>
<li>PPO 是一种强化学习算法，旨在平衡探索和利用，通过限制每次更新的幅度，确保稳定性和效率。</li>
<li>算法优化生成模型的策略，使其输出在奖励模型的评分下不断提升。</li>
</ul>
</li>
<li>反复进行生成、评估、优化的循环，逐步提高生成模型的性能。</li>
</ul>
</li>
</ul>
<blockquote>
<p>相比于 RLHF 现在好像 DPO 比较火</p>
</blockquote>
<h2 id="5-如何训练垂直领域大模型">5. 如何训练垂直领域大模型？</h2>
<p><em><strong>1）选择</strong></em> <em><strong>Base</strong></em> <em><strong>模型还是 Chat 模型？</strong></em></p>
<p>对模型进行微调，都有可能触发灾难性遗忘。</p>
<blockquote>
<p>在进行领域任务的 SFT 时，模型会重新调整对话任务相关的参数，而这些调整可能会干扰或破坏模型原先在通用对话任务上所学到的知识。这种现象就是灾难性遗忘。</p>
<p>即：灾难性遗忘 会导致模型通用能力降低。</p>
</blockquote>
<p>因为 Chat 模型就是在 Base 模型基础上做了微调以适应对话任务，掌握了生成对话内容的能力的 SFT 模型，因此再对 Chat 模型做 SFT 触发 灾难性遗忘 风险就比较高，相比之下 Base 因为没经过微调，因为触发 灾难性遗忘 的风险会比较低。</p>
<p>因此选择哪种模型取决于我们的场景：</p>
<ul>
<li>选 Base 模型：当您希望领域任务效果提升，同时不希望牺牲通用能力时，选择Base模型作为基座模型更为合适。</li>
<li>选 Chat 模型：如果您的领域任务与通用任务相关性不大，并且只追求领域任务的效果，可以选择Chat模型。</li>
</ul>
<p><em><strong>2）是否需要继续预训练（Continue PreTraining）？</strong></em></p>
<ul>
<li><strong>必要性</strong>：如果领域任务的数据集与预训练时的数据集差异较大，例如您的数据源自公司内部，而预训练数据无法覆盖这些领域，建议进行继续预训练。这样可以让模型更好地适应领域特定任务。</li>
<li><strong>数据量考虑</strong>：当领域任务的数据量较大（例如1B以上的token），增量预训练是必要的。</li>
</ul>
<p>因此，<strong>一般有两种选择</strong>：</p>
<ul>
<li>1）青春版：Chat 模型 +  SFT
<ul>
<li>资源消耗少、模型通用能力有所降低</li>
</ul>
</li>
<li>2）完整版：Base 模型 + 增量预训练(Continue PreTraining) + SFT
<ul>
<li>资源消耗大、模型通用能力完整保留</li>
</ul>
</li>
</ul>
<p>在此基础上，还可以通过强化学习进一步提升模型效果。</p>
<p>那么，<strong>最终一个完整的训练垂直领域大模型可以分为以下三步</strong>：</p>
<ul>
<li>1）<strong>Continue PreTraining(增量预训练):</strong> 一般垂直大模型是基于通用基座大模型进行二次的训练，为了给模型注入领域知识，就需要用领域内的语料进行继续预训练。</li>
<li>2）<strong>SFT( Supervised Finetuning,有监督微调)</strong>: 通过 SFT 可以激发大模型理解领域内的各种问题并进行回答的能力(在有召回知识的基础上)</li>
<li>3）<strong>强化学习</strong>：一般是二选一
<ul>
<li><strong>RLHF(奖励建模、强化学习训练)</strong>: 通过 RLHF 可以让大模型的回答对齐人们的偏好，比如行文的风格。</li>
<li><strong>DPO(直接偏好优化)</strong></li>
</ul>
</li>
</ul>
<h2 id="6-小结">6. 小结</h2>
<p><strong>1）大模型训练流程</strong></p>
<ul>
<li>1）预训练（Pre Training，<strong>PT</strong>）</li>
<li>2）监督微调（Supervised Fine-Tuning, <strong>SFT</strong>）</li>
<li>3）强化学习（Reinforcement Learning from Human Feedback, <strong>RLHF</strong>）</li>
</ul>
<p><strong>2）微调</strong></p>
<ul>
<li>微调根据参数分类：
<ul>
<li><strong>全量参数更新 Full Fine-tuning（FFT）</strong>：，即对预训练模型的所有参数进行更新，训练速度较慢，消耗机器资源较多。</li>
<li><strong>参数高效微调 Parameter-Efficient Fine-Tuning（PEFT）</strong> ：只对部分参数做调整，一般指的就是 PEFT。</li>
</ul>
</li>
<li>主流的微调方法：<strong>Prompt Tuning、Prefix Tuning、LoRA、QLoRA。</strong></li>
<li>微调框架：peft、ms-swift、LLaMAFactory</li>
</ul>
<p><strong>3）SFT 最佳实践</strong></p>
<ul>
<li>数据集准备：10000 条左右高质量数据集</li>
<li>超参调整
<ul>
<li>Epochs</li>
<li>Learning Rate</li>
<li>Global batch_size</li>
</ul>
</li>
</ul>
<p><strong>4）强化学习 RLHF</strong></p>
<ul>
<li><strong>Reward Model，RM：训练一个奖励模型RM</strong>：训练一个奖励模型（Reward Model），用于评估生成模型的输出质量。</li>
<li><strong>Reinforcement Learning，RL</strong>：用强化学习 RL 方式微调 LM ：使用强化学习算法（如 <strong>PPO（Proximal Policy Optimization）</strong>）进一步优化第一步中生成的模型，使其输出更符合人类反馈的期望。</li>
</ul>
<p><strong>5）如何训练垂直领域大模型</strong></p>
<ul>
<li>1）<strong>Continue PreTraining(增量预训练):</strong> 一般垂直大模型是基于通用基座大模型进行二次的训练，为了给模型注入领域知识，就需要用领域内的语料进行继续预训练。</li>
<li>2）<strong>SFT( Supervised Finetuning,有监督微调)</strong>: 通过 SFT 可以激发大模型理解领域内的各种问题并进行回答的能力(在有召回知识的基础上)</li>
<li>3）<strong>强化学习</strong>：一般是二选一
<ul>
<li><strong>RLHF(奖励建模、强化学习训练)</strong>: 通过 RLHF 可以让大模型的回答对齐人们的偏好，比如行文的风格。</li>
<li><strong>DPO(直接偏好优化)</strong></li>
</ul>
</li>
</ul>
<h2 id="7-参考">7. 参考</h2>
<p><a href="https://ai.meta.com/blog/adapting-large-language-models-llms/" target="_blank" rel="noopener nofollow">Methods for adapting large language models</a></p>
<p><a href="https://ai.meta.com/blog/how-to-fine-tune-llms-peft-dataset-curation/" target="_blank" rel="noopener nofollow">How to fine-tune: Focus on effective datasets</a></p>
<p><a href="https://arxiv.org/pdf/2303.15647" target="_blank" rel="noopener nofollow">Scaling Down to Scale Up: A Guide to Parameter-Efficient Fine-Tuning</a></p>
<p><a href="https://medium.com/@chassweeting/the-state-of-gpt-by-andrew-kaparthy-fad2f007c1b9" target="_blank" rel="noopener nofollow">the-state-of-gpt-by-andrew-kaparthy</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/635152813" target="_blank" rel="noopener nofollow">大模型参数高效微调技术原理综述</a></p>
<p><a href="https://huggingface.co/blog/zh/rlhf" target="_blank" rel="noopener nofollow">ChatGPT 背后的“功臣”——RLHF 技术详解</a></p>
<p><a href="https://cloud.baidu.com/doc/WENXINWORKSHOP/s/9liblgyh7" target="_blank" rel="noopener nofollow">SFT调优快速手册</a></p>
<p><a href="https://blog.csdn.net/youbingchen/article/details/135941677" target="_blank" rel="noopener nofollow">微调入门篇:大模型微调的理论学习</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.35860546750694444" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-16 13:38">2025-01-16 13:37</span>&nbsp;
<a href="https://www.cnblogs.com/KubeExplorer">探索云原生</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18674820" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18674820);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18674820', targetLink: 'https://www.cnblogs.com/KubeExplorer/p/18674820', title: '大模型微调基本概念指北' })">举报</a>
</div>
        