
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wubayue/p/18892131" title="发布于 2025-05-22 22:50">
    <span role="heading" aria-level="2">UML类图-UML Class Diagram</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/11504/202505/11504-20250522224853109-1178772480.png" alt="UML类图-UML Class Diagram" class="desc_img">
        类图以可视化的方式呈现了软件中的基本单元以及它们之间的关系。在软件架构设计过程中，它可以帮助架构师快速构思项目框架而无需关注代码细节；在软件开发过程中，它又可以精确描述类中的所有元素细节。因此对于开发人员，了解了面向对象就必须掌握UML类图。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">



<p class="wj_title_1">导航</p>
<p class="wj_nav wj_nav_1"><span>1</span><a href="#chapter1" rel="noopener nofollow">前言</a></p>
<p class="wj_nav wj_nav_1"><span>2</span><a href="#chapter2" rel="noopener nofollow">UML类图中的元素</a></p>
<p class="wj_nav wj_nav_2"><span>2.1</span><a href="#chapter2.1" rel="noopener nofollow">类</a></p>
<p class="wj_nav wj_nav_2"><span>2.2</span><a href="#chapter2.2" rel="noopener nofollow">接口</a></p>
<p class="wj_nav wj_nav_1"><span>3</span><a href="#chapter3" rel="noopener nofollow">UML类图中的关系</a></p>
<p class="wj_nav wj_nav_2"><span>3.1</span><a href="#chapter3.1" rel="noopener nofollow">关联关系</a></p>
<p class="wj_nav wj_nav_2"><span>3.2</span><a href="#chapter3.2" rel="noopener nofollow">泛化关系</a></p>
<p class="wj_nav wj_nav_2"><span>3.3</span><a href="#chapter3.3" rel="noopener nofollow">实现关系</a></p>
<p class="wj_nav wj_nav_2"><span>3.4</span><a href="#chapter3.4" rel="noopener nofollow">聚合关系</a></p>
<p class="wj_nav wj_nav_2"><span>3.5</span><a href="#chapter3.5" rel="noopener nofollow">组合关系</a></p>
<p class="wj_nav wj_nav_2"><span>3.6</span><a href="#chapter3.6" rel="noopener nofollow">依赖关系</a></p>
<p class="wj_nav wj_nav_2"><span>3.7</span><a href="#chapter3.7" rel="noopener nofollow">关系中的数量表示</a></p>

<p id="chapter1" class="wj_title_1 mt0625r">1 前言</p>
<p class="wj_cont">在面向对象软件开发中，类是软件设计的基本单元，由类构造出对象，由对象支持整个软件系统的运行，因此UML中的类图是开发人员使用最高频的图。一个复杂的软件系统，通常由非常多的类构成，如何让这些相互交织的类与对象高效的协同工作，一直以来都是软件设计领域中的巨大挑战，在这个过程中，诞生了诸如领域驱动设计（DDD），微服务等一系列革命性的思想。</p>
<p class="wj_cont">类图以可视化的方式呈现了软件中的基本单元以及它们之间的关系。在软件架构设计过程中，它可以帮助架构师快速构思项目框架而无需关注代码细节；在软件开发过程中，它又可以精确描述类中的所有元素细节。因此对于开发人员，了解了面向对象就必须掌握UML类图。<a class="wj_watermark" href="https://www.wubayue.com" target="_blank" rel="noopener nofollow">来源：https://www.wubayue.com</a></p>
<p id="chapter2" class="wj_title_1">2 UML类图中的元素</p>
<p id="chapter2.1" class="wj_title_2">2.1 类</p>
<p class="wj_title_3">类的基本构成</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250522143812_71_1200.jpg" alt="UML类图-类的基本构成" width="435" height="225" class="img-fluid" title="UML类图-类的基本构成"></p>
<p class="wj_cont">在UML类图中，类主要由三部分构成：类的名称、类的属性与类的方法。</p>
<p class="wj_cont">类的基本构成代码示例如下：</p>
<pre class="wj_code"><code class="language-csharp">// 类名称
public class MyClass
{
&nbsp; &nbsp; // 属性
&nbsp; &nbsp; public int MyProperty { get; set; }

&nbsp; &nbsp; // 方法
&nbsp; &nbsp; public int MyMethod(int p1, int p2)
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; return p1 + p2;
&nbsp; &nbsp; }
} </code></pre>
<p class="wj_title_3">类成员的可访问性</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250522143812_73_1200.jpg" alt="UML类图-类成员的可访问性" width="419" height="260" class="img-fluid" title="UML类图-类成员的可访问性"></p>
<p class="wj_cont">类成员的可访问性通过类成员的前缀符号表示：</p>
<p class="wj_cont"><strong>+</strong> 表示公有，该成员可以被任何对象访问。</p>
<p class="wj_cont"><strong>~</strong> 表示包内公有，该成员可以被同一包内的对象访问。</p>
<p class="wj_cont"><strong>#</strong> 表示受保护，该成员只能被当前类对象及子类的对象访问。</p>
<p class="wj_cont"><strong>-</strong> 表示私有，该成员只能被当前类对象访问，其它外部对象无法访问。</p>
<p class="wj_cont">类成员的可访问性代码示例如下：</p>
<pre class="wj_code"><code class="language-csharp">// 类成员的可访问性
public class MyClass
{
&nbsp; &nbsp; // 公有
&nbsp; &nbsp; public void PublicMethod()
&nbsp; &nbsp; {
&nbsp; &nbsp; }

&nbsp; &nbsp; // 包内公有
&nbsp; &nbsp; internal void InternalMethod()
&nbsp; &nbsp; {
&nbsp; &nbsp; }

&nbsp; &nbsp; // 受保护
&nbsp; &nbsp; protected void ProtectedMethod()
&nbsp; &nbsp; {
&nbsp; &nbsp; }

&nbsp; &nbsp; // 私有
&nbsp; &nbsp; private void PrivateMethod()
&nbsp; &nbsp; {
&nbsp; &nbsp; }
} </code></pre>
<p class="wj_title_3">抽象类与抽象成员</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250522143812_74_1200.jpg" alt="UML类图-抽象类与抽象成员" width="400" height="225" class="img-fluid" title="UML类图-抽象类与抽象成员"></p>
<p class="wj_cont">抽象类与抽象成员均使用斜体表示。</p>
<p class="wj_cont">抽象类与抽象成员代码示例如下：</p>
<pre class="wj_code"><code class="language-csharp">// 抽象类
public abstract class AbstractClass
{
&nbsp; &nbsp; // 抽象方法
&nbsp; &nbsp; public abstract void AbstractMethod();
} </code></pre>
<p class="wj_title_3">静态类成员</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250522143812_75_1200.jpg" alt="UML类图-静态类成员" width="400" height="225" class="img-fluid" title="UML类图-静态类成员"></p>
<p class="wj_cont">静态类成员使用下划线表示。</p>
<p class="wj_cont">静态类成员代码示例如下：</p>
<pre class="wj_code"><code class="language-csharp">// 静态类成员
public class MyClass
{
&nbsp; &nbsp; // 静态属性
&nbsp; &nbsp; public static int StaticProperty { get; set; }

&nbsp; &nbsp; // 静态方法
&nbsp; &nbsp; public static void StaticMethod()
&nbsp; &nbsp; {
&nbsp; &nbsp; }
} </code></pre>
<p id="chapter2.2" class="wj_title_2">2.2 接口</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250522143812_76_1200.jpg" alt="UML类图-接口" width="365" height="225" class="img-fluid" title="UML类图-接口"></p>
<p class="wj_cont">接口在UML图例中与类的主要差别是接口名称后多了一个圆圈。</p>
<p class="wj_cont">接口代码示例如下：<a class="wj_watermark" href="https://www.wubayue.com" target="_blank" rel="noopener nofollow">来源：https://www.wubayue.com</a></p>
<pre class="wj_code"><code class="language-csharp">// 接口
public interface MyInterface
{
&nbsp; &nbsp; // 属性
&nbsp; &nbsp; int MyProperty { get; set; }

&nbsp; &nbsp; // 方法
&nbsp; &nbsp; void MyMethod();
} </code></pre>
<p id="chapter3" class="wj_title_1">3 UML类图中的关系</p>
<p id="chapter3.1" class="wj_title_2">3.1 关联关系</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250522143811_77_1200.jpg" alt="UML类图中的关系-关联" width="470" height="330" class="img-fluid" title="UML类图中的关系-关联"></p>
<p class="wj_cont">关联关系是对象之间最常见的一种关系，主要表示为拥有。比如老师拥有课程，老师与课程之间即为单向的关联关系；老师拥有学生，学生也拥有老师，老师与学生之间即为双向的关联关系。</p>
<p class="wj_cont">关联关系示例代码如下：</p>
<pre class="wj_code"><code class="language-csharp">// 课程
public class Course
{
&nbsp; &nbsp; public string name { get; set; }
}

// 老师
public class Teacher
{
&nbsp; &nbsp; // 老师的课程
&nbsp; &nbsp; public Course[] Courses { get; set; }
&nbsp; &nbsp; // 老师的学生
&nbsp; &nbsp; public Student[] Students { get; set; }
}

// 学生
public class Student
{
&nbsp; &nbsp; // 学生的课程
&nbsp; &nbsp; public Course[] Courses { get; set; }
&nbsp; &nbsp; // 学生的老师
&nbsp; &nbsp; public Student[] Students { get; set; }
} </code></pre>
<p id="chapter3.2" class="wj_title_2">3.2 泛化关系</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250522143812_78_1200.jpg" alt="UML类图中的关系-泛化" width="470" height="365" class="img-fluid" title="UML类图中的关系-泛化"></p>
<p class="wj_cont">泛化通常表示子类对父类的继承关系。</p>
<p class="wj_cont">泛化关系示例代码如下：</p>
<pre class="wj_code"><code class="language-csharp">// 动物
public class Animal
{
&nbsp; &nbsp; // 重量
&nbsp; &nbsp; public decimal Weight { get; set; }
&nbsp; &nbsp; // 移动
&nbsp; &nbsp; public virtual void Move()
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine("动物都会动");
&nbsp; &nbsp; }
}

// 狗
public class Dog : Animal
{
&nbsp; &nbsp; public override void Move()
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine("狗在地上跑");
&nbsp; &nbsp; }
}

// 鱼
public class Fish : Animal
{
&nbsp; &nbsp; public override void Move()
&nbsp; &nbsp; {
&nbsp; &nbsp; Console.WriteLine("鱼在水中游");
&nbsp; &nbsp; }
} </code></pre>
<p id="chapter3.3" class="wj_title_2">3.3 实现关系</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250522143812_99_1200.jpg" alt="UML类图中的关系-实现" width="470" height="365" class="img-fluid" title="UML类图中的关系-实现"></p>
<p class="wj_cont">通常为具体类实现抽象的接口。</p>
<p class="wj_cont">实现关系示例代码如下：</p>
<pre class="wj_code"><code class="language-csharp">// 画画
public interface Drawing
{
&nbsp; &nbsp; // 笔
&nbsp; &nbsp; string Pen { get; }

&nbsp; &nbsp; // 作画
&nbsp; &nbsp; void Paint();
}

// 素描画
public class Sketch : Drawing
{
&nbsp; &nbsp; public string Pen&nbsp;
&nbsp; &nbsp; {&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; get { return "铅笔"; }&nbsp;
&nbsp; &nbsp; }

&nbsp; &nbsp; public void Paint()
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine("画素描画");
&nbsp; &nbsp; }
}

// 水彩画
public class Watercolor : Drawing
{
&nbsp; &nbsp; public string Pen
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; get { return "毛笔"; }
&nbsp; &nbsp; }

&nbsp; &nbsp; public void Paint()
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine("画水彩画");
&nbsp; &nbsp; }
} </code></pre>
<p id="chapter3.4" class="wj_title_2">3.4 聚合关系</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250522143812_100_1200.jpg" alt="UML类图中的关系-聚合" width="470" height="330" class="img-fluid" title="UML类图中的关系-聚合"></p>
<p class="wj_cont">表示整体与部分的关系，聚合属于强关联关系。</p>
<p id="chapter3.5" class="wj_title_2">3.5 组合关系</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250522143812_101_1200.jpg" alt="UML类图中的关系-组合" width="365" height="365" class="img-fluid" title="UML类图中的关系-组合"></p>
<p class="wj_cont">表示整体与部分的关系，组合属于最强关联关系。</p>
<p class="wj_cont">组合与聚合的区别在于组合中的部分不能脱离于整体单独存在，比如部门不能脱离于公司而存在。</p>
<p id="chapter3.6" class="wj_title_2">3.6 依赖关系</p>
<p class="wj_img"><img src="https://images.cnblogs.com/cnblogs_com/blogs/15060/galleries/2448674/o_250522143829_102_1200.jpg" alt="UML类图中的关系-依赖" width="470" height="365" class="img-fluid" title="UML类图中的关系-依赖"></p>
<p class="wj_cont">依赖关系并非类图中的特有关系，而是UML中的一种通用关系，比如在用例图中也能使用。依赖即使用关系，通常为单方向。</p>
<p id="chapter3.7" class="wj_title_2">3.7 关系中的数量表示</p>
<p class="wj_cont">两个类之间的关系，有时还需要使用数量进行更精确的描述，比如一辆汽车有一台引擎多个轮胎，一家公司有多个部门等。类图关系中的数量表示位于关系连线的两端，具体含义如下：<a class="wj_watermark" href="https://www.wubayue.com" target="_blank" rel="noopener nofollow">来源：https://www.wubayue.com</a></p>
<table class="wj_table">
<tbody>
<tr><th>标识</th><th>含义</th></tr>
<tr>
<td>0..1</td>
<td>0个或1个，最多1个</td>
</tr>
<tr>
<td>0..*</td>
<td>0个或多个，数量不限</td>
</tr>
<tr>
<td>1..1</td>
<td>只有1个</td>
</tr>
<tr>
<td>1..*</td>
<td>1个或多个，至少1个</td>
</tr>
<tr>
<td>1</td>
<td>只有1个（简化表示）</td>
</tr>
<tr>
<td>*</td>
<td>0个或多个，数量不限（简化表示）</td>
</tr>
</tbody>
</table>
<p class="wj_cont">本文同步发布于个人博客：<a class="wj_link" href="https://www.wubayue.com" target="_blank" rel="noopener nofollow">wubayue.com</a></p>
<p class="wj_cont">&lt;全文完&gt;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7273490688854166" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-22 22:54">2025-05-22 22:50</span>&nbsp;
<a href="https://www.cnblogs.com/wubayue">吴八月</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18892131);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18892131', targetLink: 'https://www.cnblogs.com/wubayue/p/18892131', title: 'UML类图-UML Class Diagram' })">举报</a>
</div>
        