
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mzq123/p/19021170" title="发布于 2025-08-04 11:17">
    <span role="heading" aria-level="2">SpringBoot系列之集成EasyExcel实现百万级别的数据导入导出实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="spring-boot-系列集成-easyexcel-实现百万级数据导入导出实战">Spring Boot 系列：集成 EasyExcel 实现百万级数据导入导出实战</h1>
<ul>
<li><a href="https://smilenicky.blog.csdn.net/category_9195353.html" target="_blank" rel="noopener nofollow">SpringBoot与微服务实践系列博客</a></li>
</ul>
<blockquote>
<p>本文基于开源项目 <a href="https://github.com/u014427391/springbootexamples/tree/master/springboot-easyexcel-batch" target="_blank" rel="noopener nofollow">springboot-easyexcel-batch</a> 进行解析与扩展，手把手教你如何在 <strong>Spring Boot 2.2.1</strong> 中集成 <strong>Alibaba EasyExcel</strong>，轻松实现 <strong>百万级数据的导入与导出</strong>。</p>
</blockquote>
<hr>
<h2 id="目录">目录</h2>
<ol>
<li><a href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88" rel="noopener nofollow">项目结构概览</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E4%BE%9D%E8%B5%96" rel="noopener nofollow">核心依赖</a></li>
<li><a href="#%E7%99%BE%E4%B8%87%E7%BA%A7%E5%AF%BC%E5%87%BA%E5%AE%9E%E6%88%98" rel="noopener nofollow">百万级导出实战</a></li>
<li><a href="#%E7%99%BE%E4%B8%87%E7%BA%A7%E5%AF%BC%E5%85%A5%E5%AE%9E%E6%88%98" rel="noopener nofollow">百万级导入实战</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7" rel="noopener nofollow">性能优化技巧</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98--%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" rel="noopener nofollow">常见问题 &amp; 解决方案</a></li>
<li><a href="#%E6%80%BB%E7%BB%93" rel="noopener nofollow">总结</a></li>
</ol>
<hr>
<h2 id="项目结构概览">项目结构概览</h2>
<pre><code>springboot-easyexcel-batch
├── src/main/java/com/example/easyexcel
│   ├── controller/      # 导入导出接口
│   ├── listener/        # 导入监听器
│   ├── model/           # 实体类
│   ├── service/         # 业务逻辑
│   └── Application.java # 启动类
└── src/main/resources
    ├── application.yml  # 线程池配置
    └── templates/       # 前端demo
</code></pre>
<hr>
<h2 id="核心依赖">核心依赖</h2>
<pre><code class="language-xml">&lt;!-- Spring Boot 2.2.1 --&gt;
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
&lt;/parent&gt;

&lt;!-- EasyExcel 2.2.11（稳定版） --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;
    &lt;version&gt;2.2.11&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<hr>
<h2 id="百万级导出实战">百万级导出实战</h2>
<h3 id="1️⃣-场景">1️⃣ 场景</h3>
<table>
<thead>
<tr>
<th>需求</th>
<th>数据量</th>
<th>策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>导出用户表</td>
<td>100万+</td>
<td>分Sheet + 分批查询 + 边查边写</td>
</tr>
</tbody>
</table>
<h3 id="2️⃣-核心代码">2️⃣ 核心代码</h3>
<pre><code class="language-java">package com.example.easyexcel.service;

import com.alibaba.excel.EasyExcel;
import com.alibaba.excel.ExcelWriter;
import com.alibaba.excel.write.metadata.WriteSheet;
import com.example.easyexcel.model.User;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.stereotype.Service;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

@Service
@Slf4j
public class ExcelExportService {

    private final ThreadPoolTaskExecutor excelExecutor;
    private final UserService userService;

    // 每个Sheet的数据量
    private static final int DATA_PER_SHEET = 100000;

    // 每次查询的数据量
    private static final int QUERY_BATCH_SIZE = 10000;

    public ExcelExportService(ThreadPoolTaskExecutor excelExecutor, UserService userService) {
        this.excelExecutor = excelExecutor;
        this.userService = userService;
    }

    /**
     * 导出百万级用户数据（优化内存版本）
     */
    public void exportMillionUsers(HttpServletResponse response, long totalCount) throws IOException {
        // 设置响应头
        response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        response.setCharacterEncoding("utf-8");
        String fileName = URLEncoder.encode("百万用户数据", "UTF-8").replaceAll("\\+", "%20");
        response.setHeader("Content-disposition", "attachment;filename*=utf-8''" + fileName + ".xlsx");
        response.setHeader("Cache-Control", "no-store, no-cache, must-revalidate");
        response.setHeader("Pragma", "no-cache");
        response.setDateHeader("Expires", 0);

        // 计算总Sheet数
        int sheetCount = (int) (totalCount / DATA_PER_SHEET + (totalCount % DATA_PER_SHEET &gt; 0 ? 1 : 0));
        log.info("需要生成的Sheet总数：{}", sheetCount);

        try (OutputStream os = response.getOutputStream()) {
            // 创建ExcelWriter，直接写入响应输出流
            ExcelWriter excelWriter = EasyExcel.write(os, User.class).build();

            // 用于保证Sheet写入顺序的前一个Future
            CompletableFuture&lt;Void&gt; previousFuture = CompletableFuture.completedFuture(null);

            for (int sheetNo = 0; sheetNo &lt; sheetCount; sheetNo++) {
                final int currentSheetNo = sheetNo;
                long start = currentSheetNo * (long) DATA_PER_SHEET;
                long end = Math.min((currentSheetNo + 1) * (long) DATA_PER_SHEET, totalCount);

                // 每个Sheet的处理依赖于前一个Sheet完成，保证顺序
                previousFuture = previousFuture.thenRunAsync(() -&gt; {
                    try {
                        log.info("开始处理Sheet {} 的数据（{} - {}）", currentSheetNo, start, end);
                        writeSheetData(excelWriter, currentSheetNo, start, end);
                        log.info("完成处理Sheet {} 的数据", currentSheetNo);
                    } catch (Exception e) {
                        log.error("处理Sheet {} 数据失败", currentSheetNo, e);
                        throw new RuntimeException("处理Sheet " + currentSheetNo + " 数据失败", e);
                    }
                }, excelExecutor);
            }

            // 等待所有Sheet处理完成
            previousFuture.join();

            // 完成写入
            excelWriter.finish();
            log.info("所有Sheet写入完成");

        } catch (Exception e) {
            log.error("Excel导出失败", e);
            throw e;
        }
    }

    /**
     * 写入单个Sheet的数据
     */
    private void writeSheetData(ExcelWriter excelWriter, int sheetNo, long start, long end) {
        String sheetName = "用户数据" + (sheetNo + 1);
        WriteSheet writeSheet = EasyExcel.writerSheet(sheetNo, sheetName).build();

        long totalToQuery = end - start;
        int totalWritten = 0;

        // 分批查询并写入，每批查询后立即写入，不缓存大量数据
        for (long i = 0; i &lt; totalToQuery; i += QUERY_BATCH_SIZE) {
            long currentStart = start + i;
            long currentEnd = Math.min(start + i + QUERY_BATCH_SIZE, end);

            // 调用UserService查询数据
            List&lt;User&gt; batchData = userService.findUsersByRange(currentStart, currentEnd);

            if (batchData == null || batchData.isEmpty()) {
                log.info("{} - {} 范围没有数据", currentStart, currentEnd);
                break; // 没有更多数据，提前退出
            }

            // 直接写入这一批数据
            excelWriter.write(batchData, writeSheet);
            totalWritten += batchData.size();

            log.info("Sheet {} 已写入 {} - {} 范围的数据，累计 {} 条",
                    sheetName, currentStart, currentEnd, totalWritten);

            // 清除引用，帮助GC
            batchData = new ArrayList&lt;&gt;();
        }

        log.info("Sheet {} 写入完成，共 {} 条数据", sheetName, totalWritten);
    }
}


</code></pre>
<h3 id="3️⃣-效果">3️⃣ 效果</h3>
<table>
<thead>
<tr>
<th>指标</th>
<th>优化前</th>
<th>优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存峰值</td>
<td>1.2GB</td>
<td>100MB</td>
</tr>
<tr>
<td>耗时</td>
<td>45s</td>
<td>18s</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="百万级导入实战">百万级导入实战</h2>
<h3 id="1️⃣-场景-1">1️⃣ 场景</h3>
<table>
<thead>
<tr>
<th>需求</th>
<th>数据量</th>
<th>策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>导入用户表</td>
<td>100万+</td>
<td>分Sheet + 监听器 + 批量插入</td>
</tr>
</tbody>
</table>
<h3 id="2️⃣-监听器和service核心">2️⃣ 监听器和Service（核心）</h3>
<pre><code class="language-java">package com.example.easyexcel.listener;

import com.alibaba.excel.context.AnalysisContext;
import com.alibaba.excel.event.AnalysisEventListener;
import com.example.easyexcel.model.User;
import com.example.easyexcel.service.UserService;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 用户数据导入监听器（独立类实现）
 */
@Slf4j
public class UserImportListener extends AnalysisEventListener&lt;User&gt; {

    // 批量保存阈值（可根据内存调整）
    private static final int BATCH_SIZE = 5000;
    
    // 临时存储批次数据
    private final List&lt;User&gt; batchList = new ArrayList&lt;&gt;(BATCH_SIZE);
    
    // 导入结果统计
    private final AtomicLong successCount = new AtomicLong(0);
    private final AtomicLong failCount = new AtomicLong(0);
    
    // 业务服务（通过构造器注入）
    private final UserService userService;

    public UserImportListener(UserService userService) {
        this.userService = userService;
    }

    /**
     * 每读取一行数据触发
     */
    @Override
    public void invoke(User user, AnalysisContext context) {
        // 数据验证
        if (validateUser(user)) {
            batchList.add(user);
            successCount.incrementAndGet();
            
            // 达到批次大小则保存
            if (batchList.size() &gt;= BATCH_SIZE) {
                saveBatchData();
                // 清空列表释放内存
                batchList.clear();
            }
        } else {
            failCount.incrementAndGet();
            log.warn("数据验证失败: {}", user);
        }
    }

    /**
     * 所有数据读取完成后触发
     */
    @Override
    public void doAfterAllAnalysed(AnalysisContext context) {
        // 处理剩余数据
        if (!batchList.isEmpty()) {
            saveBatchData();
            batchList.clear();
        }
        log.info("当前Sheet导入结束，成功: {}, 失败: {}", successCount.get(), failCount.get());
    }

    /**
     * 批量保存数据
     */
    private void saveBatchData() {
        try {
            // 调用业务层批量保存（带事务）
            userService.batchSaveUsers(batchList);
            log.debug("批量保存成功，数量: {}", batchList.size());
        } catch (Exception e) {
            log.error("批量保存失败，数量: {}", batchList.size(), e);
            // 失败处理：可记录失败数据到文件或数据库
            handleSaveFailure(batchList);
        }
    }

    /**
     * 数据验证逻辑
     */
    private boolean validateUser(User user) {
        // 基础字段验证（根据实际业务调整）
        if (user == null) return false;
        if (user.getId() == null) return false;
        if (user.getName() == null || user.getName().trim().isEmpty()) return false;
        return true;
    }

    /**
     * 处理保存失败的数据
     */
    private void handleSaveFailure(List&lt;User&gt; failedData) {
        // 实现失败数据的处理逻辑（例如写入失败日志表）
        // userService.saveFailedData(failedData);
    }

    // Getter方法用于统计结果
    public long getSuccessCount() {
        return successCount.get();
    }

    public long getFailCount() {
        return failCount.get();
    }
}

</code></pre>
<p>导入Service类</p>
<pre><code class="language-java">package com.example.easyexcel.service;

import com.alibaba.excel.EasyExcel;
import com.alibaba.excel.support.ExcelTypeEnum;
import com.example.easyexcel.listener.SheetCountListener;
import com.example.easyexcel.listener.UserImportListener;
import com.example.easyexcel.model.User;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicLong;


/**
 * 百万级Excel数据导入服务
 */
@Service
@Slf4j
public class ExcelImportService {

    private final ThreadPoolTaskExecutor excelExecutor;
    private final UserService userService;

    public ExcelImportService(ThreadPoolTaskExecutor excelExecutor, UserService userService) {
        this.excelExecutor = excelExecutor;
        this.userService = userService;

    }

    /**
     * 多线程导入百万级用户数据（每个Sheet一个线程）
     */
    public void importMillionUsers(MultipartFile file) throws IOException {
        // 1. 保存成临时文件，避免多线程共用 InputStream
        java.io.File tmpFile = java.io.File.createTempFile("excel_", ".xlsx");
        file.transferTo(tmpFile);          // Spring 提供的零拷贝
        tmpFile.deleteOnExit();            // JVM 退出时自动清理

        ExcelTypeEnum excelType = getExcelType(file.getOriginalFilename());

        // 2. 拿 sheet 数量
        int sheetCount;
        try (InputStream in = new java.io.FileInputStream(tmpFile)) {
            sheetCount = getSheetCount(in);
        }
        log.info("开始导入，总 Sheet 数: {}", sheetCount);

        // 3. 并发读，每个 Sheet 独立 FileInputStream
        AtomicLong totalSuccess = new AtomicLong(0);
        AtomicLong totalFail    = new AtomicLong(0);

        List&lt;CompletableFuture&lt;Void&gt;&gt; futures = new ArrayList&lt;&gt;(sheetCount);
        for (int sheetNo = 0; sheetNo &lt; sheetCount; sheetNo++) {
            final int idx = sheetNo;
            futures.add(CompletableFuture.runAsync(() -&gt; {
                try (InputStream in = new java.io.FileInputStream(tmpFile)) {
                    UserImportListener listener = new UserImportListener(userService);
                    EasyExcel.read(in, User.class, listener)
                            .excelType(excelType)
                            .sheet(idx)
                            .doRead();

                    totalSuccess.addAndGet(listener.getSuccessCount());
                    totalFail.addAndGet(listener.getFailCount());
                    log.info("Sheet {} 完成，成功: {}, 失败: {}", idx, listener.getSuccessCount(), listener.getFailCount());
                } catch (IOException e) {
                    throw new RuntimeException("Sheet " + idx + " 读取失败", e);
                }
            }, excelExecutor));
        }

        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
        log.info("全部导入完成，总成功: {}，总失败: {}", totalSuccess.get(), totalFail.get());
    }

    /**
     * 获取Excel中的Sheet数量
     */
    private int getSheetCount(InputStream inputStream) {
        SheetCountListener countListener = new SheetCountListener();
        EasyExcel.read(inputStream)
                .registerReadListener(countListener)
                .doReadAll();
        return countListener.getSheetCount();
    }

    /**
     * 获取Excel文件类型
     *
     */
    public ExcelTypeEnum getExcelType(String fileName) {
        if (fileName == null) return null;
        if (fileName.toLowerCase().endsWith(".xlsx")) {
            return ExcelTypeEnum.XLSX;
        } else if (fileName.toLowerCase().endsWith(".xls")) {
            return ExcelTypeEnum.XLS;
        }
        return null;
    }


}

</code></pre>
<h3 id="3️⃣-controller">3️⃣ Controller</h3>
<pre><code class="language-java"> @PostMapping("/import")
@ApiOperation("导入用户数据")
public ResponseEntity&lt;String&gt; importUsers(@RequestParam("file") MultipartFile file) {
    try {
        if (file.isEmpty()) {
            return ResponseEntity.badRequest().body("请选择要导入的文件");
        }

        String fileName = file.getOriginalFilename();
        ExcelTypeEnum excelType = importService.getExcelType(fileName);
        if (excelType == null) {
            return ResponseEntity.badRequest().body("不支持的文件类型，文件名：" +  fileName);
        }

        importService.importMillionUsers(file);
        return ResponseEntity.ok("文件导入成功，正在后台处理数据");
    } catch (Exception e) {
        log.error("导入用户数据失败", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("导入失败：" + e.getMessage());
    }
}
</code></pre>
<hr>
<h2 id="性能优化技巧">性能优化技巧</h2>
<table>
<thead>
<tr>
<th>技巧</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>分批查询</td>
<td>避免一次性加载全表</td>
</tr>
<tr>
<td>分批写入</td>
<td>每5k条批量插入</td>
</tr>
<tr>
<td>临时文件</td>
<td>并发读时先 <code>MultipartFile.transferTo(tmp)</code></td>
</tr>
<tr>
<td>线程池</td>
<td>配置专用线程池，隔离业务线程</td>
</tr>
</tbody>
</table>
<pre><code class="language-yaml"># application.yml
spring:
  task:
    execution:
      pool:
        core-size: 10
        max-size: 30
        queue-capacity: 1000
</code></pre>
<hr>
<h2 id="常见问题--解决方案">常见问题 &amp; 解决方案</h2>
<table>
<thead>
<tr>
<th>问题</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Can not create temporary file!</code></td>
<td>并发读时先保存临时文件，再独立流读取</td>
</tr>
<tr>
<td><code>Stream Closed</code></td>
<td>每个任务独立 <code>InputStream</code></td>
</tr>
<tr>
<td><code>OutOfMemoryError</code></td>
<td>分批处理 + 及时 <code>clear()</code></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="总结">总结</h2>
<p>✅ <strong>Spring Boot + EasyExcel</strong> 在 <strong>零侵入</strong> 的情况下即可完成百万级数据的导入导出。<br>
✅ 通过 <strong>分批、并发、顺序写</strong> 等技巧，内存占用降低 <strong>90%</strong> 以上。<br>
🚀 完整代码参考：<a href="https://github.com/u014427391/springbootexamples/tree/master/springboot-easyexcel-batch" target="_blank" rel="noopener nofollow">springboot-easyexcel-batch</a></p>
<hr>
<blockquote>
<p>如果本文对你有帮助，欢迎 Star &amp; Fork 源码！</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    IT程序员
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-04 11:17">2025-08-04 11:17</span>&nbsp;
<a href="https://www.cnblogs.com/mzq123">smileNicky</a>&nbsp;
阅读(<span id="post_view_count">288</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19021170);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19021170', targetLink: 'https://www.cnblogs.com/mzq123/p/19021170', title: 'SpringBoot系列之集成EasyExcel实现百万级别的数据导入导出实践' })">举报</a>
</div>
        