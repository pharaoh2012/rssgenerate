
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zjdxr-up/p/18869766" title="发布于 2025-05-10 16:58">
    <span role="heading" aria-level="2">Redis 连接池耗尽的一次异常定位</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>转载请注明出处：</p>
<p>　　最近在项目中遇到一个奇怪的现象，项目运行环境中的redis在业务运行中，一直没有更新redis的值，在服务的日志中也没有看到相关的异常，导致服务看起来正常，但和redis相关的功能却没有更新。记录下这个异常定位解决的过程。</p>
<p>　　登录到redis里面，发现redis也是运行正常的，且能正常获取。所以进入到了服务端里面，获取jvm线程进行具体分析，看到有很多个线程栈如下：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="https://img2024.cnblogs.com/blog/1110857/202505/1110857-20250510163940990-790315007.png" alt="" width="1034" height="465" loading="lazy"></p>
<h2>定位分析过程</h2>
<ul>
<ul>
<li>
<p class="ds-markdown-paragraph"><strong><code>pool-4-thread-1</code></strong>：<br>线程名称，表明该线程属于线程池&nbsp;<code>pool-4</code>&nbsp;的第一个工作线程（线程池通常由&nbsp;<code>ThreadPoolExecutor</code>&nbsp;管理）。</p>


</li>
<li>
<p class="ds-markdown-paragraph"><strong><code>Id=211</code></strong>：<br>JVM 内部分配的线程唯一标识符（非操作系统线程ID）。</p>

</li>
<li>
<div>
<h3><strong>CPU 时间统计</strong></h3>
<div class="cnblogs_code">
<pre>cpu=<span style="color: rgba(128, 0, 128, 1)">692644037380</span> ns usr=<span style="color: rgba(128, 0, 128, 1)">644020000000</span> ns </pre>
</div>
<div class="dad65929">
<div class="_4f9bf79 d7dc56a8 _43c05b5">
<div class="ds-markdown ds-markdown--block">
<ul>
<li>
<p class="ds-markdown-paragraph"><strong><code>cpu=692644037380 ns</code></strong>：<br>线程从启动至今消耗的&nbsp;<strong>总 CPU 时间</strong>（包括内核态和用户态），单位为纳秒（≈ 692.64 秒）。</p>


</li>
<li>
<p class="ds-markdown-paragraph"><strong><code>usr=644020000000 ns</code></strong>：<br>线程在&nbsp;<strong>用户态（User Mode）</strong>&nbsp;消耗的 CPU 时间（≈ 644.02 秒）。<br><strong>差值意义</strong>：<code>cpu - usr ≈ 48.62秒</code>&nbsp;为线程在内核态（Kernel Mode）的耗时，通常由系统调用（如 I/O、锁竞争）引起。</p>


</li>


</ul>
<hr>
<h3><strong>线程阻塞与等待统计</strong></h3>
<div class="md-code-block md-code-block-light">
<div class="md-code-block-banner-wrap">
<div class="md-code-block-banner md-code-block-banner-lite">
<div class="_121d384">
<div class="d2a24f03">
<div class="cnblogs_code">
<pre>blocked <span style="color: rgba(128, 0, 128, 1)">2294</span> <span style="color: rgba(0, 0, 255, 1)">for</span> -<span style="color: rgba(128, 0, 128, 1)">1</span> ms waited <span style="color: rgba(128, 0, 128, 1)">28442</span> <span style="color: rgba(0, 0, 255, 1)">for</span> -<span style="color: rgba(128, 0, 128, 1)">1</span> ms</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<ul>
<li>
<p class="ds-markdown-paragraph"><strong><code>blocked 2294</code></strong>：<br>线程因&nbsp;<strong>竞争锁（synchronized）</strong>&nbsp;而被阻塞的次数（总计 2294 次）。</p>


</li>
<li>
<p class="ds-markdown-paragraph"><strong><code>for -1 ms</code></strong>：<br>阻塞时间的统计方式，<code>-1 ms</code>&nbsp;表示未记录具体阻塞时长（需启用 JVM 参数&nbsp;<code>-XX:+PrintBlocked</code>&nbsp;获取）。</p>


</li>
<li>
<p class="ds-markdown-paragraph"><strong><code>waited 28442</code></strong>：<br>线程在&nbsp;<strong>等待条件触发</strong>（如&nbsp;<code>Object.wait()</code>&nbsp;或&nbsp;<code>Condition.await()</code>）的次数（总计 28442 次）。</p>


</li>
<li>
<p class="ds-markdown-paragraph"><strong><code>for -1 ms</code></strong>：<br>等待时间的统计方式，<code>-1 ms</code>&nbsp;表示未记录具体等待时长（需启用&nbsp;<code>-XX:+PrintWait</code>&nbsp;获取）。</p>


</li>


</ul>
<hr>
<h3><strong>线程状态与堆栈跟踪</strong></h3>
<div class="md-code-block md-code-block-light">
<div class="md-code-block-banner-wrap">
<div class="md-code-block-banner md-code-block-banner-lite">
<div class="_121d384">
<div class="d2a24f03">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">java.lang.Thread.State: WAITING
  at sun.misc.Unsafe.park(Native Method)
  </span>- waiting on (a java.util.concurrent.ThreadPoolExecutor$Worker@5cf37a65)</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<ul>
<li>
<p class="ds-markdown-paragraph"><strong><code>Thread.State: WAITING</code></strong>：<br>线程处于&nbsp;<strong>无限期等待</strong>&nbsp;状态，通常由以下操作触发：</p>
<ul>
<li>
<p class="ds-markdown-paragraph"><code>Object.wait()</code>（无超时参数）。</p>


</li>
<li>
<p class="ds-markdown-paragraph"><code>LockSupport.park()</code>。</p>


</li>
<li>
<p class="ds-markdown-paragraph"><code>Condition.await()</code>（无超时参数）。</p>


</li>


</ul>


</li>
<li>
<p class="ds-markdown-paragraph"><strong><code>sun.misc.Unsafe.park(Native Method)</code></strong>：<br>线程通过&nbsp;<code>LockSupport.park()</code>&nbsp;进入阻塞状态，底层调用&nbsp;<code>Unsafe.park()</code>。</p>


</li>
<li>
<p class="ds-markdown-paragraph"><strong><code>waiting on (a java.util.concurrent.ThreadPoolExecutor$Worker@5cf37a65)</code></strong>：<br>线程正在等待&nbsp;<code>ThreadPoolExecutor.Worker</code>&nbsp;对象（线程池工作线程的封装）关联的条件变量（如任务队列非空）。</p>


</li>


</ul>
<hr>
<h3><strong>关键堆栈分析</strong></h3>
<div class="md-code-block md-code-block-light">
<div class="cnblogs_code">
<pre>at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span style="color: rgba(128, 0, 128, 1)">175</span><span style="color: rgba(0, 0, 0, 1)">)
at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.</span><span style="color: rgba(0, 0, 255, 1)">await</span>(AbstractQueuedSynchronizer.java:<span style="color: rgba(128, 0, 128, 1)">2039</span><span style="color: rgba(0, 0, 0, 1)">)
at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:</span><span style="color: rgba(128, 0, 128, 1)">442</span><span style="color: rgba(0, 0, 0, 1)">)
at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:</span><span style="color: rgba(128, 0, 128, 1)">1074</span><span style="color: rgba(0, 0, 0, 1)">)
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:</span><span style="color: rgba(128, 0, 128, 1)">1134</span><span style="color: rgba(0, 0, 0, 1)">)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:</span><span style="color: rgba(128, 0, 128, 1)">624</span><span style="color: rgba(0, 0, 0, 1)">)
at java.lang.Thread.run(Thread.java:</span><span style="color: rgba(128, 0, 128, 1)">750</span>)</pre>
</div>
</div>
<ul>
<li>
<p class="ds-markdown-paragraph"><strong>核心路径</strong>：</p>
<ol start="1">
<li>
<p class="ds-markdown-paragraph">线程从&nbsp;<code>LinkedBlockingQueue.take()</code>&nbsp;尝试获取任务。</p>
</li>
<li>
<p class="ds-markdown-paragraph">若队列为空，调用&nbsp;<code>ConditionObject.await()</code>&nbsp;进入等待。</p>
</li>
<li>
<p class="ds-markdown-paragraph">最终通过&nbsp;<code>LockSupport.park()</code>&nbsp;挂起线程，直到新任务到达。</p>
</li>
</ol></li>
</ul>
<hr>
<h3><strong>性能问题诊断</strong></h3>
<h4><strong>1. 高&nbsp;<code>waited</code>&nbsp;次数（28442 次）</strong></h4>
<ul>
<li>
<p class="ds-markdown-paragraph"><strong>可能原因</strong>：</p>
<ul>
<li>
<p class="ds-markdown-paragraph">线程池任务队列长期为空，工作线程频繁等待新任务。</p>
</li>
<li>
<p class="ds-markdown-paragraph">任务生产速度不足（如上游系统吞吐量低）。</p>
</li>
<li>
<p class="ds-markdown-paragraph">线程池配置不合理（核心线程数过多，超出实际需求）。</p>
</li>
</ul>
</li>
</ul>
<h4><strong>2. 高&nbsp;<code>blocked</code>&nbsp;次数（2294 次）</strong></h4>
<ul>
<li>
<p class="ds-markdown-paragraph"><strong>可能原因</strong>：</p>
<ul>
<li>
<p class="ds-markdown-paragraph">线程池内部锁竞争（如&nbsp;<code>Worker</code>&nbsp;线程争用任务队列）。</p>
</li>
<li>
<p class="ds-markdown-paragraph">共享资源（如数据库连接池）的同步访问冲突。</p>
</li>
</ul>
</li>
</ul>
<h4><strong>3. CPU 时间分配</strong></h4>
<ul>
<li>
<p class="ds-markdown-paragraph"><strong>用户态耗时占比</strong>：<br><code>usr / cpu ≈ 644.02 / 692.64 ≈ 93%</code>，表明线程主要执行用户代码，而非系统调用。若应用为计算密集型，此比例为正常现象。</p>


</li>


</ul>
<hr>
<h3><strong>优化建议</strong></h3>
<h4><strong>1. 线程池配置优化</strong></h4>
<ul>
<li>
<p class="ds-markdown-paragraph"><strong>调整核心线程数</strong>：<br>若队列长期为空，减少&nbsp;<code>corePoolSize</code>，避免线程闲置。</p>
<div class="md-code-block md-code-block-light">
<div class="md-code-block-banner-wrap">
<div class="md-code-block-banner md-code-block-banner-lite">
<div class="_121d384">
<div class="d2a24f03">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ThreadPoolExecutor(
    corePoolSize,   </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 根据负载动态调整（如使用动态线程池框架）</span>
<span style="color: rgba(0, 0, 0, 1)">    maxPoolSize,
    keepAliveTime,
    TimeUnit.SECONDS,
    </span><span style="color: rgba(0, 0, 255, 1)">new</span> LinkedBlockingQueue&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">(capacity)
);</span></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</li>
</ul>
<h4><strong>2. 任务队列监控</strong></h4>
<ul>
<li>
<p class="ds-markdown-paragraph"><strong>检查队列容量</strong>：<br>若使用无界队列（如&nbsp;<code>LinkedBlockingQueue</code>&nbsp;未指定容量），可能导致内存溢出，建议改为有界队列。</p>


</li>
<li>
<p class="ds-markdown-paragraph"><strong>监控队列堆积</strong>：<br>通过 JMX 或&nbsp;<code>ThreadPoolExecutor</code>&nbsp;的&nbsp;<code>getQueue().size()</code>&nbsp;实时观察任务积压情况。</p>


</li>


</ul>
<h4><strong>3. 减少锁竞争</strong></h4>
<ul>
<li>
<p class="ds-markdown-paragraph"><strong>使用无锁数据结构</strong>：<br>替换&nbsp;<code>LinkedBlockingQueue</code>&nbsp;为&nbsp;<code>ConcurrentLinkedQueue</code>（需配合非阻塞任务调度逻辑）。</p>


</li>
<li>
<p class="ds-markdown-paragraph"><strong>分离读写操作</strong>：<br>若共享资源访问频繁，使用读写锁（<code>ReentrantReadWriteLock</code>）替代独占锁。</p>

</li>

</ul>

</div>

</div>

</div>

</div>


</li>


</ul>

</ul>
<h2>问题解决：</h2>
<p>　　根据截图中的线程栈调用过程，可以定位到项目代码执行调用的地方，发现调用的地方是频繁批量更新redis缓存值得，且每次都是单独一条设置更新得。因此很快推测出来，是这个调用得地方在频繁更新redis缓存值时，导致服务中redis得连接数不够了，因此将代码中更新redis值得方式，使用管道得方式进行更新设置，问题得以解决。</p>
<p>&nbsp;　　</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> ValueOperations&lt;String, T&gt;<span style="color: rgba(0, 0, 0, 1)"> setCacheObject(String key, T value) {
        ValueOperations</span>&lt;String, T&gt; operation =<span style="color: rgba(0, 0, 0, 1)"> redisTemplate.opsForValue();
        operation.</span><span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">(key, value);
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> operation;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> pipelineSetCacheObjects(Map&lt;String, BigDecimal&gt;<span style="color: rgba(0, 0, 0, 1)"> keyValueMap, Integer timeout, TimeUnit timeUnit) {
        redisTemplate.executePipelined((RedisCallback</span>&lt;Object&gt;) connection -&gt;<span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 获取键值序列化器（直接从RedisTemplate中获取）</span>
            RedisSerializer&lt;String&gt; keySerializer = (RedisSerializer&lt;String&gt;<span style="color: rgba(0, 0, 0, 1)">) redisTemplate.getKeySerializer();
            RedisSerializer</span>&lt;BigDecimal&gt; valueSerializer = (RedisSerializer&lt;BigDecimal&gt;<span style="color: rgba(0, 0, 0, 1)">) redisTemplate.getValueSerializer();

            keyValueMap.forEach((key, value) </span>-&gt;<span style="color: rgba(0, 0, 0, 1)"> {
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 序列化键值</span>
                <span style="color: rgba(0, 0, 255, 1)">byte</span>[] keyBytes =<span style="color: rgba(0, 0, 0, 1)"> keySerializer.serialize(key);
                </span><span style="color: rgba(0, 0, 255, 1)">byte</span>[] valueBytes =<span style="color: rgba(0, 0, 0, 1)"> valueSerializer.serialize(value);

                </span><span style="color: rgba(0, 0, 255, 1)">if</span> (keyBytes != <span style="color: rgba(0, 0, 255, 1)">null</span> &amp;&amp; valueBytes != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (timeout != <span style="color: rgba(0, 0, 255, 1)">null</span> &amp;&amp; timeUnit != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                        connection.setEx(keyBytes, timeUnit.toSeconds(timeout), valueBytes);
                    } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
                        connection.</span><span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">(keyBytes, valueBytes);
                    }
                }
            });
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
        });
    }</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div><span style="color: rgba(64, 64, 64, 1); font-family: DeepSeek-CJK-patch, Inter, system-ui, -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Noto Sans&quot;, Ubuntu, Cantarell, &quot;Helvetica Neue&quot;, Oxygen, &quot;Open Sans&quot;, sans-serif; font-size: 16.002px">&nbsp;</span></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.21974726434143518" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-10 21:03">2025-05-10 16:58</span>&nbsp;
<a href="https://www.cnblogs.com/zjdxr-up">香吧香</a>&nbsp;
阅读(<span id="post_view_count">65</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18869766);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18869766', targetLink: 'https://www.cnblogs.com/zjdxr-up/p/18869766', title: 'Redis 连接池耗尽的一次异常定位' })">举报</a>
</div>
        