
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiezhr/p/18784433" title="发布于 2025-03-21 08:14">
    <span role="heading" aria-level="2">Java24你发任你发，我用Java8</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>大家好，我是晓凡。</p>
<p>各位 Java 开发者们！是不是还在为 Java 23 的新特性忙得焦头烂额？</p>
<p>别急，Java 24 已经悄咪咪地发布了！</p>
<p><img src="https://img2024.cnblogs.com/blog/2381533/202503/2381533-20250321081234097-447618218.png" alt="java24发布了" loading="lazy"></p>
<p>这可是自 Java 21 以来的第三个非长期支持版本，而且这次的新特性数量直接拉满，一共有 24 个，是 Java 22 和 Java 23 的总和！</p>
<p><img src="http://blog.xiezhrspace.cn/blog-img/%E6%96%B0%E7%89%B9%E6%80%A7.png" alt="新特性" loading="lazy"></p>
<p>这么多新特性，学得废么？别怕，这就带大家来一探究竟，看看 Java 24 到底给我们带来了哪些“惊喜”。</p>
<h3 id="一java-版本的江湖现状">一、Java 版本的江湖现状</h3>
<p>在深入 Java 24 的新特性之前，我们先来瞅瞅 Java 各个版本的使用占比情况。</p>
<p>距离Java8版本已经过去了很久，但是不少小伙伴还坚守在Java8战场。凭借其稳定性和丰富的类库，在实际开发中依然占据着重要地位。</p>
<p>网友：“你发任你发，我用Java8！”。</p>
<p><img src="https://img2024.cnblogs.com/blog/2381533/202503/2381533-20250321081124244-1520767678.png" alt="java24" loading="lazy"></p>
<p>根据最新的统计数据（不一定准确~），目前 Java 17 作为长期支持版本（LTS），占据了市场的半壁江山，约有 50% 的开发者在使用。</p>
<p>Java 11 也还有一批忠实的粉丝，占比约 30%。</p>
<p>而像 Java 22、Java 23 这些非长期支持版本，虽然更新频繁，但由于生命周期较短，使用占比相对较低，加起来也就 20% 左右。</p>
<p>不过，随着 Java 25 预计在今年 9 月份发布，作为下一个长期支持版本，相信又会掀起一波升级热潮。</p>
<h3 id="二java-24-的新特性大揭秘">二、Java 24 的新特性大揭秘</h3>
<h4 id="21-jep-478密钥派生函数-api预览">2.1 JEP 478：密钥派生函数 API（预览）</h4>
<p>先来说说这个密钥派生函数 API。在以前，我们开发加密相关的功能时，密钥管理一直是个让人头疼的问题。要是密钥重复使用，那可就容易被黑客钻空子了。Java 24 给我们带来了解决方案，通过这个 API，我们可以使用最新的密钥派生算法，比如 HKDF 和未来可能会加入的 Argon2，来生成各种加密目的所需的密钥。这样一来，安全性就大大提升了，也为应对未来的量子计算威胁做好了准备。</p>
<p>代码示例：</p>
<pre><code class="language-java">// 创建一个 KDF 对象，使用 HKDF-SHA256 算法
KDF hkdf = KDF.getInstance("HKDF-SHA256");
// 创建 Extract 和 Expand 参数规范
AlgorithmParameterSpec params =
    HKDFParameterSpec.ofExtract()
                     .addIKM(initialKeyMaterial) // 设置初始密钥材料
                     .addSalt(salt)              // 设置盐值
                     .thenExpand(info, 32);      // 设置扩展信息和目标长度
// 派生一个 32 字节的 AES 密钥
SecretKey key = hkdf.deriveKey("AES", params);
// 可以使用相同的 KDF 对象进行其他密钥派生操作
</code></pre>
<h4 id="22-jep-483提前类加载和链接">2.2 JEP 483：提前类加载和链接</h4>
<p>这个特性简直就是启动时间敏感应用的救星！</p>
<p>在传统的 JVM 中，每次启动应用都要动态加载和链接类，这对于微服务或者无服务器函数来说，简直就是噩梦，启动时间长得让人抓狂。</p>
<p>Java 24 通过缓存已加载和链接的类，直接减少了重复工作的开销，让大型应用的启动时间减少了 40% 以上。</p>
<p>而且，这个优化完全不需要我们修改应用程序、库或框架的代码，只需要添加一个 JVM 参数 <code>-XX:+ClassDataSharing</code> 就搞定了。</p>
<h4 id="23-jep-484类文件-api">2.3 JEP 484：类文件 API</h4>
<p>这个特性对于那些喜欢折腾 Java 类文件的开发者来说，简直就是福音。</p>
<p>以前我们处理类文件，还得依赖第三方库，比如 ASM。</p>
<p>现在 Java 24 给我们提供了一套标准化的 API，可以轻松地解析、生成和转换 Java 类文件。</p>
<p>这样一来，我们就可以更加方便地进行字节码操作，提升开发效率。</p>
<p>代码示例：</p>
<pre><code class="language-java">// 创建一个 ClassFile 对象，这是操作类文件的入口
ClassFile cf = ClassFile.of();
// 解析字节数组为 ClassModel
ClassModel classModel = cf.parse(bytes);
// 构建新的类文件，移除以 "debug" 开头的所有方法
byte[] newBytes = cf.build(classModel.thisClass().asSymbol(),
    classBuilder -&gt; {
        // 遍历所有类元素
        for (ClassElement ce : classModel) {
            // 判断是否为方法且方法名以 "debug" 开头
            if (!(ce instanceof MethodModel mm
                    &amp;&amp; mm.methodName().stringValue().startsWith("debug"))) {
                // 添加到新的类文件中
                classBuilder.with(ce);
            }
        }
    });
</code></pre>
<h4 id="24-jep-485流收集器">2.4 JEP 485：流收集器</h4>
<p>流收集器 <code>Stream::gather(Gatherer)</code> 是 Java 24 中一个非常强大的新特性。它允许我们定义自定义的中间操作，从而实现更复杂、更灵活的数据转换。</p>
<p>与现有的 <code>filter</code>、<code>map</code> 或 <code>distinct</code> 等内置操作不同，<code>Stream::gather</code> 可以帮助我们完成那些难以用标准 Stream 操作完成的任务，比如滑动窗口、自定义规则的去重等。</p>
<p>这简直就是数据处理的瑞士军刀，大大扩展了 Stream API 的应用范围。</p>
<p>代码示例：</p>
<pre><code class="language-java">var result = Stream.of("foo", "bar", "baz", "quux")
                   .gather(Gatherer.ofSequential(
                       HashSet::new, // 初始化状态为 HashSet，用于保存已经遇到过的字符串长度
                       (set, str, downstream) -&gt; {
                           if (set.add(str.length())) {
                               return downstream.push(str);
                           }
                           return true; // 继续处理流
                       }
                   ))
                   .toList();
// 输出结果 ==&gt; [foo, quux]
</code></pre>
<h4 id="25-jep-486永久禁用安全管理器">2.5 JEP 486：永久禁用安全管理器</h4>
<p>这个特性可能会让一些老派的 Java 开发者感到不习惯。</p>
<p>Java 24 不再允许启用 <code>Security Manager</code>，即使通过 <code>java -Djava.security.manager</code> 命令也无法启用。</p>
<p>虽然 <code>Security Manager</code> 曾经是 Java 中限制代码权限的重要工具，但由于它复杂性高、使用率低且维护成本大，Java 社区决定最终移除它。</p>
<p>这也意味着我们在开发过程中需要寻找新的安全策略来替代它。</p>
<h4 id="26-jep-487作用域值第四次预览">2.6 JEP 487：作用域值（第四次预览）</h4>
<p>作用域值这个特性听起来有点高大上，其实它的作用非常实用。</p>
<p>它可以在线程内和线程间共享不可变的数据，比线程局部变量好多了，尤其是在使用大量虚拟线程时。</p>
<p>这样一来，我们就可以在大型程序中的组件之间安全有效地共享数据，而不用再通过方法参数传递，代码更加简洁清晰。</p>
<p>代码示例：</p>
<pre><code class="language-java">final static ScopedValue&lt;...&gt; V = new ScopedValue&lt;&gt;();
// 在某个方法中
ScopedValue.where(V, &lt;value&gt;)
           .run(() -&gt; { ... V.get() ... call methods ... });
// 在被 lambda 表达式直接或间接调用的方法中
... V.get() ...
</code></pre>
<h4 id="27-jep-491虚拟线程的同步而不固定平台线程">2.7 JEP 491：虚拟线程的同步而不固定平台线程</h4>
<p>这个特性对于提升应用程序的并发能力非常有帮助。</p>
<p>在 Java 24 中，虚拟线程在 <code>synchronized</code> 方法和代码块中阻塞时，通常能够释放其占用的操作系统线程，避免了对平台线程的长时间占用。</p>
<p>这样一来，即使在 <code>synchronized</code> 块中发生阻塞，也不会固定平台线程，从而允许平台线程继续服务于其他虚拟线程，提高整体的并发性能。</p>
<p>这对于 I/O 密集型的应用程序来说，简直就是如虎添翼。</p>
<h4 id="28-jep-493在没有-jmod-文件的情况下链接运行时镜像">2.8 JEP 493：在没有 JMOD 文件的情况下链接运行时镜像</h4>
<p>这个特性主要是为了减少 JDK 的安装体积。默认情况下，JDK 同时包含运行时镜像和 JMOD 文件。</p>
<p>现在，通过这个特性，<code>jlink</code> 工具无需使用 JDK 的 JMOD 文件就可以创建自定义运行时镜像，直接减少了约 25% 的 JDK 安装体积。</p>
<p>这对于那些需要在资源受限的环境中部署 Java 应用的开发者来说，简直就是福音。</p>
<h4 id="29--jep-495简化的源文件和实例主方法第四次预览">2.9  JEP 495：简化的源文件和实例主方法（第四次预览）</h4>
<p>这个特性主要针对 Java 初学者。</p>
<p>传统的 <code>main</code> 方法声明对于初学者来说，引入了太多的 Java 语法概念，不利于快速上手。</p>
<p>Java 24 对 <code>main</code> 方法的声明进行了简化，让初学者能够更快地入门。</p>
<p>代码示例：</p>
<p>没有使用该特性之前：</p>
<pre><code class="language-java">public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
</code></pre>
<p>使用该新特性之后：</p>
<pre><code class="language-java">class HelloWorld {
    void main() {
        System.out.println("Hello, World!");
    }
}
</code></pre>
<p>进一步简化（未命名的类允许我们省略类名）：</p>
<pre><code class="language-java">void main() {
    System.out.println("Hello, World!");
}
</code></pre>
<h4 id="210-jep-497量子抗性数字签名算法-ml-dsa">2.10 JEP 497：量子抗性数字签名算法 (ML-DSA)</h4>
<p>Java 24 还引入了支持实施抗量子的基于模块晶格的数字签名算法（ML-DSA）。</p>
<p>这是为了应对未来量子计算机可能带来的威胁，提前做好准备。</p>
<p>ML-DSA 是美国国家标准与技术研究院（NIST）在 FIPS 204 中标准化的量子抗性算法，用于数字签名和身份验证。</p>
<p>这个特性让我们在安全性方面又多了一层保障。</p>
<h4 id="211-jep-498使用-sunmiscunsafe-内存访问方法时发出警告">2.11 JEP 498：使用 <code>sun.misc.Unsafe</code> 内存访问方法时发出警告</h4>
<p>这个特性主要是为了提醒开发者，<code>sun.misc.Unsafe</code> 中的内存访问方法已经在 JDK 23 中被提议弃用，并且在未来的版本中会被移除。</p>
<p>在 Java 24 中，当首次调用 <code>sun.misc.Unsafe</code> 的任何内存访问方法时，运行时会发出警告。</p>
<p>同时，Java 也提供了安全高效的替代方案，比如 <code>java.lang.invoke.VarHandle</code> 和 <code>java.lang.foreign.MemorySegment</code>，</p>
<p>让我们可以更加安全地进行内存操作。</p>
<h4 id="212-jep-499结构化并发第四次预览">2.12 JEP 499：结构化并发（第四次预览）</h4>
<p>结构化并发是 Java 19 引入的一个多线程编程方法，目的是通过结构化并发 API 来简化多线程编程。</p>
<p>在 Java 24 中，这个特性继续得到完善。</p>
<p>它将不同线程中运行的多个任务视为单个工作单元，从而简化错误处理、提高可靠性并增强可观察性。</p>
<p>这对于虚拟线程来说，简直就是绝配。虚拟线程是 JDK 实现的轻量级线程，许多虚拟线程共享同一个操作系统线程，从而允许非常多的虚拟线程。</p>
<p>代码示例：</p>
<pre><code class="language-java">try (var scope = new StructuredTaskScope&lt;Object&gt;()) {
    // 使用 fork 方法派生线程来执行子任务
    Future&lt;Integer&gt; future1 = scope.fork(task1);
    Future&lt;String&gt; future2 = scope.fork(task2);
    // 等待线程完成
    scope.join();
    // 结果的处理可能包括处理或重新抛出异常
    ... process results/exceptions ...
} // close
</code></pre>
<h3 id="小结">小结</h3>
<p>Java 24 的发布，无疑给 Java 开发者们带来了新的挑战。</p>
<p>这么多的新特性，在开发过中也有了更多的选择和更强大的工具。</p>
<p>小伙伴：“学习进度跟不上版本更新的脚步，学不动了，要学废了~”</p>
<p><img src="https://img2024.cnblogs.com/blog/2381533/202503/2381533-20250321081138081-1658364999.jpg" alt="已经学废了表情包-千图网" loading="lazy"></p>
<p>但从长远来看，这将有助于我们提升开发效率、优化代码质量和提升应用性能。</p>
<p>各位小伙伴们，你对此有什么看法呢？ 欢迎评论区留言~</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/xiezhr/" target="_blank">程序员晓凡</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/xiezhr/p/18784433" target="_blank">https://www.cnblogs.com/xiezhr/p/18784433</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03609677222569444" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-21 08:15">2025-03-21 08:14</span>&nbsp;
<a href="https://www.cnblogs.com/xiezhr">程序员晓凡</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18784433" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18784433);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18784433', targetLink: 'https://www.cnblogs.com/xiezhr/p/18784433', title: 'Java24你发任你发，我用Java8' })">举报</a>
</div>
        