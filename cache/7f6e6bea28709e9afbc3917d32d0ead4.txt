
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19031670" title="发布于 2025-08-11 11:08">
    <span role="heading" aria-level="2">【渲染流水线】[应用阶段]-[渲染命令队列]以UnityURP为例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250811111444989-385893265.png" alt="【渲染流水线】[应用阶段]-[渲染命令队列]以UnityURP为例" class="desc_img">
        本文以Unity URP渲染管线为例，详细解析了从数据到图像的渲染流程。内容涵盖模型数据获取（顶点坐标、法线等）、变换矩阵计算（MVP矩阵）、渲染状态设置（剔除、深度测试等）和渲染指令提交（DrawCall）等关键环节。文章深入分析了URP中渲染命令队列的实现机制，包括ScriptableRenderContext和CommandBuffer的使用，以及ShaderLab配置状态的解析与处理流程。同时提供了动态修改渲染状态的代码示例，帮助开发者理解URP渲染管线的底层实现原理和优化方法。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>应用阶段最后是CPU向GPU提交需要渲染的数据。通常数据会被复制到显存中，然后设置渲染参数，最后调用渲染接口。PC中是这样的，但是移动设备一般没有单独的显存。使用内存为GPU服务。他们使用同一内存地址。除非要读/写这段内存内容才会复制出一份调整CPU和GPU之间协作。</p>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<h1 id="渲染状态"><strong>渲染状态</strong>：</h1>
<ul>
<li>一连串开关或方法，以及方法的地址指向（阶段中的各种可配置的阶段等都是在这里）。SetPassCall。例如是否开启混合、用哪个纹理、哪个顶点着色器、是否背面剔除等，在Unity中则是ShaderLab语法规则中规定的各种标签。</li>
</ul>
<h1 id="渲染指令"><strong>渲染指令</strong>：</h1>
<ul>
<li>调用具体渲染的对象。drawcall是一个渲染指令，这个指令仅指向一连串图元（点线面 网格拆分后的状态），并不会包含任何其他材质信息。每个状态前都伴随着一连串渲染状态设置，所以渲染命令队列中，渲染状态和渲染指令是交替出现。</li>
</ul>
<h1 id="渲染命令队列"><strong>渲染命令队列</strong>：</h1>
<ul>
<li>其中包含渲染状态、渲染指令的缓冲区。CPU向缓冲区放入指令，GPU执行指令。CPU发送渲染状态后，CPU需要控制总线将数据从内存搬运到显存，搬运过程耗费大量时间。drawcall多了后会导致大量内存搬运，运行速度下降。</li>
</ul>
<h1 id="打包数据">打包数据</h1>
<h2 id="模型信息"><strong>模型信息</strong></h2>
<p>模型数据主要从网格资源（Mesh）中获取，包含以下核心属性：</p>
<ol>
<li>‌<strong>顶点坐标</strong>‌描述模型局部空间的顶点位置坐标（x, y, z）。</li>
<li>‌<strong>法线信息</strong>‌定义顶点朝向，用于光照计算和表面平滑度。</li>
<li>‌<strong>UV信息</strong>‌二维纹理映射坐标（u, v），范围[0,1]，控制贴图在模型表面的分布。</li>
<li>‌<strong>切线向量</strong>‌与法线配合构建切线空间，用于法线贴图等高级渲染效果。</li>
<li>‌<strong>顶点颜色</strong>‌存储逐顶点颜色值，可用于特殊着色效果。</li>
<li>‌<strong>索引列表</strong>‌定义顶点连接顺序，优化绘制效率（减少重复顶点）</li>
</ol>
<ul>
<li>‌<strong>数据来源</strong>‌：
<ul>
<li>
<p>由建模工具（如Blender/Maya）导出时生成，随模型文件（.fbx/.obj）导入Unity。</p>
</li>
<li>
<p>程序化网格通过<code>Mesh</code>类API动态设置（如<code>mesh.vertices</code>,&nbsp;<code>mesh.uv</code>）</p>
</li>
<li>
<p><strong>变换矩阵</strong></p>
<p>矩阵数据由CPU计算并传递给GPU：</p>
<ul>
<li>‌<strong>模型矩阵 Model Matrix（M）</strong> ‌模型局部坐标→世界坐标，由物体的<code>Transform</code>组件（位置/旋转/缩放）计算得出。
<ul>
<li>计算顺序：缩放 → 旋转 → 平移（SRT）</li>
</ul>
</li>
<li>‌<strong>视图矩阵 View Matrix（V）</strong> ‌世界坐标→摄像机坐标，基于<code>Camera</code>组件的位姿（位置/朝向/上方向）生成。
<ul>
<li>计算原理：先逆平移（摄像机到原点），再逆旋转（对齐坐标轴）</li>
</ul>
</li>
<li>‌<strong>投影矩阵 Projection Matrix（P）</strong> ‌摄像机坐标→齐次裁剪坐标，通过相机参数计算：
<ul>
<li>参数来源：FOV、近/远裁剪面、宽高比</li>
<li>透视投影（近大远小）或正交投影（等比例缩放）</li>
<li><code>Field of View (FOV)</code>：视角范围</li>
<li><code>Near/Far Clipping Planes</code>：近远裁剪平面</li>
<li><code>Aspect Ratio</code>：屏幕宽高比。</li>
</ul>
</li>
<li>‌<strong>MVP矩阵</strong>‌最终变换矩阵：<code>MVP = P × V × M</code></li>
<li><strong>计算主体与存储位置</strong>
<table>
<thead>
<tr>
<th>矩阵类型</th>
<th>计算者</th>
<th>存储位置（GPU端）</th>
<th>访问方式（Shader）</th>
</tr>
</thead>
<tbody>
<tr>
<td>‌<strong>模型矩阵 (M)</strong> ‌</td>
<td>Transform组件 (CPU计算)</td>
<td><code>unity_ObjectToWorld</code></td>
<td><code>UNITY_MATRIX_M</code></td>
</tr>
<tr>
<td>‌<strong>视图矩阵 (V)</strong> ‌</td>
<td>摄像机组件 (CPU计算)</td>
<td><code>unity_MatrixV</code></td>
<td><code>UNITY_MATRIX_V</code></td>
</tr>
<tr>
<td>‌<strong>投影矩阵 (P)</strong> ‌</td>
<td>摄像机投影参数 (CPU计算)</td>
<td><code>unity_MatrixP</code></td>
<td><code>UNITY_MATRIX_P</code></td>
</tr>
<tr>
<td>‌<strong>MVP矩阵</strong> ‌</td>
<td>Shader运行时组合</td>
<td>无独立存储</td>
<td><code>mul(UNITY_MATRIX_VP, mul(UNITY_MATRIX_M, pos))</code></td>
</tr>
</tbody>
</table>
</li>
<li><strong>计算时机</strong>
<ul>
<li>CPU端：每帧渲染前更新（物体Transform或摄像机移动时）。</li>
<li>GPU端：通过<code>UNITY_MATRIX_VP</code>（视图投影矩阵）与<code>UNITY_MATRIX_M</code>（模型矩阵）在顶点着色器动态组合</li>
</ul>
</li>
<li><strong>优化机制</strong>
<ul>
<li>
<p>URP预计算<code>VP矩阵</code>（视图投影联合矩阵），减少GPU计算量。</p>
</li>
<li>
<p>使用<code>UnityObjectToClipPos</code>内置函数直接完成MVP变换：</p>
<pre><code class="language-hlsl">hlsl
float4 clipPos = UnityObjectToClipPos(v.vertex); // 内部实现：mul(UNITY_MATRIX_VP, mul(UNITY_MATRIX_M, v.vertex))
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="灯光材质参数"><strong>灯光、材质参数</strong></h2>
<ul>
<li><strong>灯光参数</strong>‌
<ul>
<li>‌<strong>光源属性</strong>‌：位置、颜色、强度、衰减等，源自场景中的<code>Light</code>组件。</li>
<li>‌<strong>阴影参数</strong>‌：阴影强度、分辨率，通过URP光源设置（如<code>UniversalAdditionalLightData</code>）配置。</li>
</ul>
</li>
<li>‌<strong>材质数据</strong>‌
<ul>
<li>‌<strong>Shader与材质属性</strong>‌：漫反射颜色、高光强度等，由<code>Material</code>实例定义。</li>
<li>‌<strong>纹理贴图</strong>‌：通过材质绑定（如<code>_MainTex</code>），从纹理资源加载。</li>
</ul>
</li>
</ul>
<h2 id="数据传递流程">‌<strong>数据传递流程</strong>‌：</h2>
<p>应用阶段通过<code>SetPassCall</code>设置渲染状态（Shader/材质），并通过<code>DrawCall</code>提交图元列表</p>
<h1 id="batch"><strong>Batch</strong>：</h1>
<ul>
<li>把数据加载到显存，设置渲染状态，CPU调用GPU渲染的过程称之为一个Batch。</li>
</ul>
<h1 id="unity-urp渲染管线中的渲染状态和渲染命令的实现"><strong>Unity URP渲染管线中的渲染状态和渲染命令的实现</strong></h1>
<h2 id="一渲染状态设置setpasscall"><strong>一、‌渲染状态设置（SetPassCall）‌</strong></h2>
<ul>
<li>
<p>‌<strong>ScriptableRenderer类</strong></p>
<ul>
<li>位于<code>UniversalRenderer.cs</code>中，负责管理URP的默认渲染流程。</li>
<li>调用<code>EnqueuePass</code>方法将渲染Pass（如<code>DrawObjectsPass</code>）加入队列。</li>
</ul>
</li>
<li>
<p>‌<strong>CommandBuffer类</strong>‌</p>
<ul>
<li>通过<code>CommandBufferPool.Get</code>获取实例，录制渲染指令。</li>
<li>关键方法：<pre><code class="language-csharp">csharp
cmd.SetRenderTarget()// 绑定渲染目标
cmd.SetGlobalTexture()// 设置全局纹理
cmd.SetViewProjectionMatrices()// 设置VP矩阵
</code></pre>
</li>
</ul>
</li>
<li>
<p>‌<strong>Material与Shader</strong>‌</p>
<ul>
<li>材质状态通过<code>Material.SetPass</code>方法设置，触发底层<code>SetPassCall</code>。</li>
<li>URP通过<code>ShaderData</code>类管理着色器变体（Variant）的切换。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="二图元提交drawcall"><strong>二、‌图元提交（DrawCall）‌</strong></h2>
<ul>
<li>
<p>‌<strong>ScriptableRenderContext类</strong>‌</p>
<ul>
<li>
<p>核心方法<code>Submit</code>提交所有录制的<code>CommandBuffer</code>到GPU。</p>
</li>
<li>
<p>调用链：</p>
<pre><code class="language-csharp">csharp
context.ExecuteCommandBuffer(cmd);// 执行指令
context.DrawRenderers()// 触发DrawCall
</code></pre>
</li>
</ul>
</li>
<li>
<p>‌<strong>DrawingSettings与FilteringSettings</strong>‌</p>
<ul>
<li>
<p>在<code>DrawObjectsPass.Execute</code>中配置：</p>
<pre><code class="language-csharp">csharp
var drawSettings = new DrawingSettings(...);// 指定Shader Pass和排序var filterSettings = new FilteringSettings(...);// 设置渲染队列和层级
context.DrawRenderers(...);// 最终提交
</code></pre>
</li>
</ul>
</li>
<li>
<p>‌<strong>Graphics.DrawMesh</strong>‌</p>
<ul>
<li>直接提交网格数据的备选API，绕过URP流程但效率较低。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="三关键脚本位置"><strong>三、关键脚本位置</strong></h2>
<table>
<thead>
<tr>
<th>功能</th>
<th>脚本文件</th>
<th>核心方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>‌<strong>渲染流程控制</strong>‌</td>
<td><code>UniversalRenderer.cs</code></td>
<td><code>AddRenderPasses</code>,&nbsp;<code>Execute</code></td>
</tr>
<tr>
<td>‌<strong>指令录制</strong>‌</td>
<td><code>CommandBuffer.cs</code></td>
<td><code>Clear</code>,&nbsp;<code>DrawMesh</code>,&nbsp;<code>Blit</code></td>
</tr>
<tr>
<td>‌<strong>材质状态管理</strong>‌</td>
<td><code>Material.cs</code></td>
<td><code>SetPass</code>,&nbsp;<code>SetShaderPassEnabled</code></td>
</tr>
<tr>
<td>‌<strong>数据提交</strong>‌</td>
<td><code>ScriptableRenderContext.cs</code></td>
<td><code>Submit</code>,&nbsp;<code>DrawRenderers</code></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="四执行流程示例"><strong>四、执行流程示例</strong></h2>
<pre><code class="language-csharp">csharp
// 在ScriptableRenderPass中实现
public override void Execute(ScriptableRenderContext context, ref RenderingData data) {
    CommandBuffer cmd = CommandBufferPool.Get("CustomPass");
    cmd.SetRenderTarget(...);// SetPassCall
    cmd.DrawMesh(...);// DrawCall
    context.ExecuteCommandBuffer(cmd);
    CommandBufferPool.Release(cmd);
}
</code></pre>
<h1 id="unity-urp渲染管线中的应用阶段渲染命令队列及渲染队列实现"><strong>Unity URP渲染管线中的应用阶段渲染命令队列及渲染队列实现</strong></h1>
<p>在Unity URP渲染管线的应用阶段，渲染命令队列包含一系列图形命令，主要用于调度和执⾏渲染操作，例如清除缓冲区、绘制几何体、设置材质和着色器参数、处理光源阴影，以及执行后处理效果。</p>
<p>这些命令通过<code>ScriptableRenderContext</code>接口进行管理，该接口作为C#代码与Unity底层图形引擎的桥梁，确保命令按序列化顺序提交GPU处理。队列内容包括：</p>
<ul>
<li>缓冲区清除命令（如颜色缓冲和深度缓冲）。</li>
<li>几何体绘制命令（调用<code>DrawMesh</code>或<code>DrawProcedural</code>）。</li>
<li>状态设置命令（如设置视口、混合模式）。</li>
<li>阴影贴图生成命令（针对动态光源）。</li>
<li>后处理Pass（如抗锯齿或景深应用）。这些命令在每帧的渲染循环中被动态生成和执行，以支持前向渲染策略和性能优化。</li>
</ul>
<p>URP中的渲染队列实现主要由<code>ScriptableRenderPass</code>类完成，它定义了Pass的执行顺序和具体渲染逻辑。具体脚本流程如下：</p>
<h2 id="渲染队列管理">‌<strong>渲染队列管理</strong>‌：</h2>
<ul>
<li>
<p><strong>渲染队列</strong>（如<code>RenderQueueRange.opaque</code>或<code>RenderQueueRange.transparent</code>）在<code>ScriptableRenderPass</code>的构造函数中指定，通过字段如<code>renderPassEvent</code>控制Pass的执行时机（例如在相机渲染前或后）。</p>
</li>
<li>
<p><strong>例如</strong>，一个基本的Pass脚本会继承自<code>ScriptableRenderPass</code>，并在其Configure方法中设置队列优先级：这里，<code>Execute</code>方法包含具体命令队列的实现，使用<code>CommandBuffer</code>来录制命令（如<code>cmd.ClearRenderTarget</code>），并通过<code>ScriptableRenderContext</code>提交。</p>
<pre><code class="language-csharp">csharp
public class CustomRenderPass : ScriptableRenderPass
{
    public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
    {
// 设置队列范围为不透明对象
        renderPassEvent = RenderPassEvent.BeforeRenderingOpaques;
    }
    public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
    {
// 执行命令，如绘制或清除
        CommandBuffer cmd = CommandBufferPool.Get();
        context.ExecuteCommandBuffer(cmd);
        CommandBufferPool.Release(cmd);
    }
}
</code></pre>
</li>
</ul>
<h2 id="脚本集成">‌<strong>脚本集成</strong>‌：</h2>
<ul>
<li>在<code>ScriptableRenderer</code>（如<code>UniversalRenderer</code>）中，渲染队列通过<code>m_ActiveRenderPassQueue</code>列表管理。</li>
<li>Setup阶段调用<code>AddRenderPasses</code>方法收集所有关联的<code>ScriptableRenderPass</code>实例（来自<code>RendererFeature</code>），并按事件顺序排序；<code>Execute</code>阶段遍历列表执行每个Pass的<code>Execute</code>方法。</li>
<li>例如，<code>UniversalRenderPipeline.Render</code>方法驱动整个流程：此脚本位于URP核心程序集（如<code>UniversalRenderPipeline.cs</code>），依赖于<code>UniversalRenderPipelineAsset</code>提供配置</li>
</ul>
<pre><code class="language-csharp">csharp
protected override void Render(ScriptableRenderContext context, List&lt;Camera&gt; cameras)
{
// 排序相机并逐个处理foreach (var camera in cameras)
    {
        var renderer = cameraData.renderer;
        renderer.Execute(context, ref renderingData);// 执行Pass队列
    }
}
</code></pre>
<h1 id="在unity-urp中shaderlab配置的渲染状态如剔除深度测试混合模式等的处理流程"><strong>在Unity URP中，ShaderLab配置的渲染状态（如剔除、深度测试、混合模式等）的处理流程</strong></h1>
<h2 id="一状态读取与存储机制"><strong>一、状态读取与存储机制</strong></h2>
<h3 id="shaderlab解析阶段">‌<strong>ShaderLab解析阶段</strong>‌</h3>
<ul>
<li>URP通过<code>ShaderCompiler</code>解析ShaderLab代码，将<code>Cull</code>、<code>ZTest</code>、<code>Blend</code>等指令转换为底层渲染状态标识符。</li>
<li>解析结果存储在<code>ShaderData</code>结构中，包含渲染状态变体（Variant）和材质属性。</li>
</ul>
<h3 id="gpu状态设置阶段">‌<strong>GPU状态设置阶段</strong>‌</h3>
<ul>
<li>运行时由<code>CommandBuffer</code>录制指令（如<code>cmd.SetRenderTarget</code>、<code>cmd.SetGlobalDepthBias</code>），通过<code>ScriptableRenderContext.Submit</code>提交到GPU。</li>
<li>关键存储位置：
<ul>
<li>‌<strong>剔除模式</strong>‌：存于<code>RenderStateBlock.cullMode</code>，通过<code>DrawingSettings</code>传递给<code>DrawRenderers</code>调用。</li>
<li>‌<strong>深度测试/写入</strong>‌：通过<code>DepthState</code>结构（含<code>ZWrite</code>、<code>ZTest</code>）配置，最终写入GPU深度缓冲区。</li>
<li>‌<strong>混合模式</strong>‌：由<code>BlendState</code>管理（含<code>BlendOp</code>、<code>SrcFactor</code>等参数），绑定到渲染管线状态。</li>
</ul>
</li>
</ul>
<h3 id="urp运行时管理">‌<strong>URP运行时管理</strong>‌</h3>
<ul>
<li><code>UniversalRenderer</code>在<code>AddRenderPasses</code>阶段收集所有Pass的渲染状态，合并到<code>RenderStateBlock</code>。</li>
<li>通过<code>MaterialPropertyBlock</code>动态覆盖材质属性（如运行时修改<code>_ZWrite</code>）。</li>
</ul>
<hr>
<h2 id="二关键脚本与调用链"><strong>二、关键脚本与调用链</strong></h2>
<table>
<thead>
<tr>
<th>‌<strong>功能</strong>‌</th>
<th>‌<strong>脚本/类</strong>‌</th>
<th>‌<strong>核心方法</strong>‌</th>
<th>‌<strong>数据流向</strong>‌</th>
</tr>
</thead>
<tbody>
<tr>
<td>‌<strong>Shader解析</strong>‌</td>
<td><code>ShaderCompiler</code></td>
<td><code>CompileShader</code></td>
<td>ShaderLab →&nbsp;<code>ShaderData</code></td>
</tr>
<tr>
<td>‌<strong>状态录制</strong>‌</td>
<td><code>CommandBuffer</code></td>
<td><code>SetRenderState</code></td>
<td>CPU → GPU指令队列</td>
</tr>
<tr>
<td>‌<strong>Pass执行</strong>‌</td>
<td><code>DrawObjectsPass</code></td>
<td><code>Execute</code></td>
<td>通过<code>DrawingSettings</code>传递状态</td>
</tr>
<tr>
<td>‌<strong>动态修改</strong>‌</td>
<td><code>MaterialPropertyBlock</code></td>
<td><code>SetFloat</code>/<code>SetInt</code></td>
<td>运行时覆盖Shader参数</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="三使用示例urp中动态修改深度测试"><strong>三、使用示例（URP中动态修改深度测试）</strong></h2>
<pre><code class="language-hlsl">hlsl
// ShaderLab中声明深度测试
SubShader {
    Pass {
        ZWrite On
        ZTest LEqual
    }
}
</code></pre>
<ul>
<li>
<p>‌<strong>运行时读取</strong>‌：通过<code>Material.GetInt("_ZWrite")</code>获取状态。</p>
</li>
<li>
<p>‌<strong>动态修改</strong>‌：</p>
<pre><code class="language-csharp">csharp
var block = new MaterialPropertyBlock();
block.SetInt("_ZWrite", 0);// 禁用深度写入
renderer.SetPropertyBlock(block);
</code></pre>
</li>
</ul>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>（欢迎点赞留言探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.005555555555555556" data-date-updated="2025-08-11 11:16">2025-08-11 11:08</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
阅读(<span id="post_view_count">60</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19031670);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19031670', targetLink: 'https://www.cnblogs.com/SmalBox/p/19031670', title: '【渲染流水线】[应用阶段]-[渲染命令队列]以UnityURP为例' })">举报</a>
</div>
        