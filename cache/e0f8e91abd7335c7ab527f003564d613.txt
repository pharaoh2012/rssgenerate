
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/gtyan/p/18984282" title="发布于 2025-07-14 16:46">
    <span role="heading" aria-level="2">AI网络搜索</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        使用人工智能平台提供的搜索能力完成信息检索与整合。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>作为AI应用程序开发人员在了解函数调用（Function Calling）特性调用本地函数时可能注意到列表型参数tools中每一个元素都携带有一个type值。而在大多数函数调用示例程序中，这个type值一直被设定为“function”，这意味着它还可能存在其他合法且有效的取值。本文的示例程序将尝试把这个值设定为“web_search”，顾名思义，此时这个工具应当是网页搜索器。<br>
模型在训练过程中汲取海量语料数据，从而构建其深厚的知识储备。但是，这些用于训练的语料往往具有时效性，它们所反映的信息和知识是特定时间点的产物。随着时间的推移，新的信息、知识和观念层出不穷。因此，模型所掌握的内容逐渐变得陈旧，对于新出现的概念、事件和趋势，其了解程度可能会变得有限，甚至一无所知。<br>
在需要获取较新资讯的场景中，为确保模型输出内容的时效性和准确性，应用程序有必要为其补充新鲜的信息。使用网页搜索器正是解决这个问题的一种高效且实用的手段。网页搜索器本质上就是利用网页搜索引擎快速抓取互联网上的最新信息，包括新闻报道、学术论文、社交媒体动态等，使用它能够为模型提供较新的资讯或模型所不知道的信息，使得模型的回复更具时效性和有效性。这样，基于生成式人工智能模型开发的应用程序就能够更好地理解和适应不断变化的信息世界。<br>
网页搜索器从互联网上检索到相关信息后，模型会对这些信息进行整合，并将最终整合完成的内容反馈给应用程序。<br>
网页搜索器的设定较为简单，在参数tools中添加一个type为“web_search”的工具，并将该工具的enable值设定为True以启用网络搜索功能即可。如果期望网页搜索器不仅提供整合完成的内容，还同时提供相关信息来源网页的详细信息（标题、URL、媒体名称等），则需要通过将web_search工具的search_result值设定为True。<br>
基于以上说明，代码中参数tools的值设定如下：</p>
<pre><code>def get_completion(messages, model="glm-4-plus"):
&nbsp; &nbsp; response = client.chat.completions.create(
&nbsp; &nbsp; &nbsp; &nbsp; model=model,
&nbsp; &nbsp; &nbsp; &nbsp; messages=messages,
&nbsp; &nbsp; &nbsp; &nbsp; temperature=0.01, &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; tool_choice="auto", 
&nbsp; &nbsp; &nbsp; &nbsp; tools=[{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "type": "web_search",
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "web_search": {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "enable": True,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "search_result": True,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }],
&nbsp; &nbsp; )
&nbsp; &nbsp; print(f"\nget_completion:{response}")
&nbsp; &nbsp; return response
</code></pre>
<p>通过使用web_search工具检索到相关网页后，网页内容会被自动整合处理，这个过程应用程序无需进行任何额外操作，可以像与模型进行普通对话的程序一样，自然地继续进行后续的代码编写工作即可。当前示例程序被设计为在输出模型回复文本的末尾同时列出web_search工具所检索到的具体网页信息，以便必要时用户可以直接点击来源网页链接跳转到相应网页查看原文，因此应用程序要做更多的工作。<br>
如前所述，使用web_search工具时，如果需要获得信息来源，需要将search_result设定为True，此时模型返回信息中将包含一个名为web_search的对象，它包含本次运行检索到的所有网页信息。示例程序通过对它进行遍历，并使用其中的标题、媒体名称及URL组合成超链接供用户点击查阅。<br>
以下代码实现上述输出整合内容后再列出资讯来源的设想。</p>
<pre><code>&nbsp; &nbsp; response = get_completion(messages)

&nbsp; &nbsp; content = response.choices[0].message.content
&nbsp; &nbsp; print(f"\n综合结果：{content}\n")
&nbsp; &nbsp; if (hasattr(response, "web_search") and 
&nbsp; &nbsp; &nbsp; &nbsp; response.web_search is not None):
&nbsp; &nbsp; &nbsp; &nbsp; content = f"{content}\n\n*以下是消息来源：*\n"

&nbsp; &nbsp; &nbsp; &nbsp; # 取得检索到的网页信息
&nbsp; &nbsp; &nbsp; &nbsp; for searchResult in response.web_search:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(f"\nsearchResult=\n{searchResult}\n")
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; webContent = searchResult["content"]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; webIcon = None
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if "icon"in searchResult:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; webIcon = searchResult["icon"]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link = searchResult["link"]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; media = None
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if "media" in searchResult:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; media = searchResult["media"]
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; title = searchResult["title"]

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(f"\nwebConten={webContent}\nwebIcon={webIcon}\nlink={link}\nmedia={media}\ntitle={title}")
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if media is None:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; searchContent = f"[{title}]({link})"
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; searchContent = f"[{title} - {media}]({link})"
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; content = f"{content}\n{searchContent}\n"

&nbsp; &nbsp; # 保存并显示已经完成的回复
&nbsp; &nbsp; append_and_show("assistant", content) 
&nbsp; &nbsp; print(f"\n===END===\n")
</code></pre>
<p>此外，基于本示例程序的主要功能与目的，也需要设定消息列表中system消息的预设信息，以便模型知道应用程序意图。</p>
<pre><code>&nbsp; &nbsp; messages = [
&nbsp; &nbsp; &nbsp; &nbsp; {"role": "system", 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "content": """你是一个具备网络访问能力的信息小助手，
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 你应当先分析用户消息中的关键主题，然后优先使用网检索相关信息，
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然后根据搜索的结果给出回答。"""},
&nbsp; &nbsp; &nbsp; &nbsp; {"role": "user", "content": prompt}
&nbsp; &nbsp; ]
</code></pre>
<p>至此，网络搜索助手主体代码部分完成，运行完成的网络搜索助手，输入相应提示词，可以看到模型输出综合整理后的信息及其相关资讯来源。如下图所示。<br>
<img alt="图 工具调用效果" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3579674/202507/3579674-20250714164138221-104044645.png" class="lazyload"><br>
需要特别说明的是，上述示例程序基于智谱AI成功运行，但并非所有生成式人工智能模型都提供web_search工具供用户使用。在使用不支持web_search工具的模型时，可以采用函数调用方法自行实现这一功能。具体做法是将网络搜索功能封装在本地函数中，当模型识别出需要进行网络检索的需求时，通过调用这个封装函数在应用程序端执行检索操作，再将检索结果提交给模型，用于进一步分析和整理概括，并最终生成所需的搜索结果整合信息。事实上，各大搜索引擎都提供使用API进行搜索的能力，也有多个第三方检索平台或软件包对网络搜索提供API支持。采用通过第三方检索平台的方式获得网络搜索能力的示例将单独发文介绍，本文不再赘述。<br>
使用上述本地函数调用方式获得的网络搜索能力不仅能实现本节示例程序网络搜索助手的功能，还可以根据具体应用场景对搜索过程进行优化和定制。而且由于搜索逻辑封装在本地函数，可以灵活地调整搜索引擎、设定查询参数，甚至必要时可对搜索结果数据进行预处理，进而提高搜索的有效性和准确性。<br>
在具体实践中，需要网络搜索功能时，设计师与开发人员应当考虑当前所选用的模型服务平台是否提供web_search工具以及应用程序未来更换模型平台的可能性两个因素。同时从程序实现角度而言，如果平台兼容性优先，则应当尽量避免使用特定平台的特定功能；如果快速实现和功能效果优先，则应当尽量采用平台已提供的功能。最终需要综合多个因素完成设计决策。</p>
<p>本文摘录自《生成式AI应用开发实战：基于智谱AI和DeepSeek》第三章第四节（3.4 网络搜索助手——网页搜索），略有修改。<br>
<img alt="本书封面" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3579674/202507/3579674-20250714164231811-713675404.jpg" class="lazyload"></p>
<p>本文示例完整源码参见源文件:<br>
<a href="https://gitcode.com/gtyan/ISBN9787111782179/blob/main/Ch3/FunctionCallingWebSearch.py" target="_blank" rel="noopener nofollow">https://gitcode.com/gtyan/ISBN9787111782179/blob/main/Ch3/FunctionCallingWebSearch.py</a></p>

</div>
<div id="MySignature" role="contentinfo">
    <p>更多文章访问<a href="https://gtyan.com" target="_blank">https://gtyan.com</a></p><p>
</p><p>本文来自博客园，作者：<a href="https://www.cnblogs.com/gtyan/" target="_blank">光头颜</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/gtyan/p/18984282" target="_blank">https://www.cnblogs.com/gtyan/p/18984282</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.005555555555555556" data-date-updated="2025-07-14 16:54">2025-07-14 16:46</span>&nbsp;
<a href="https://www.cnblogs.com/gtyan">光头颜</a>&nbsp;
阅读(<span id="post_view_count">13</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18984282);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18984282', targetLink: 'https://www.cnblogs.com/gtyan/p/18984282', title: 'AI网络搜索' })">举报</a>
</div>
        