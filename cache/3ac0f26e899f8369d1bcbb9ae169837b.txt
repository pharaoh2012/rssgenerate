<!----> <meta itemprop="headline" content="面试官: 工作5年了 不知道Reflect嘛？"> <meta itemprop="keywords" content="JavaScript,面试,前端"> <meta itemprop="datePublished" content="2024-09-30T02:33:42.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="某某某人"> <meta itemprop="url" content="https://juejin.cn/user/3649990025815853"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7cdd11fb="">
            面试官: 工作5年了 不知道Reflect嘛？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7cdd11fb=""><div class="author-info-box" data-v-7cdd11fb=""><div class="author-name" data-v-7cdd11fb=""><a href="/user/3649990025815853/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-7cdd11fb=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    某某某人
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-7cdd11fb=""><time datetime="2024-09-30T02:33:42.000Z" title="Mon Sep 30 2024 02:33:42 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7cdd11fb="">
                    2024-09-30
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7cdd11fb=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7cdd11fb=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7cdd11fb=""></circle></svg> <span class="views-count" data-v-7cdd11fb="">
                    12,946
                  </span> <span class="read-time" data-v-7cdd11fb=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7cdd11fb=""><rect width="16" height="16" fill="none" data-v-7cdd11fb=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7cdd11fb=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7cdd11fb=""></path></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7cdd11fb=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7cdd11fb=""><div class="article-viewer markdown-body result"><h2 data-id="heading-0">先有问题再有答案</h2>
<ol>
<li><code>Reflect是什么</code></li>
<li><code>Reflect都有哪些方法</code></li>
<li><code>这些方法存在的意义是什么</code></li>
<li><code>Reflect的方法为什么不放在Object上</code></li>
<li><code>Reflect的设计目的是什么</code></li>
<li><code>为什么proxy里一定要使用reflect</code></li>
</ol>
<h2 data-id="heading-1">Reflect是什么</h2>
<p>在 JavaScript 中，Reflect&nbsp;是一个内置的全局对象，对一些函数式的操作提供了面向对象的 API。
Reflect&nbsp;不是一个函数对象，因此它是不可构造的。它所有的方法都是静态的，类似于&nbsp;Math&nbsp;对象。</p>
<h2 data-id="heading-2">Reflect方法</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1870389a3f8346429bfe9f2011cf2fac~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p-Q5p-Q5p-Q5Lq6:q75.awebp?rk3s=f64ab15b&amp;x-expires=1736097937&amp;x-signature=ZYQBrgpcmMZ02xiKxkuVdic6Oe0%3D" alt="截屏2024-09-29 19.31.21.png" loading="lazy">
目前共13个静态方法 可以分为<code>函数相关</code>,<code>原型相关</code>,<code>对象相关</code>三大类。</p>
<h3 data-id="heading-3">函数相关</h3>
<ul>
<li><code>Reflect.apply</code>方法用于绑定<code>this</code>对象后执行给定函数。
一般来说，如果要绑定一个函数的<code>this</code>对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的<code>apply</code>方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用<code>Reflect</code>对象可以简化这种操作。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">${name}</span> and I am <span class="hljs-subst">${age}</span> years old.`</span>);
}
<span class="hljs-keyword">const</span> args = [<span class="hljs-string">'John'</span>, <span class="hljs-number">30</span>];
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(greet, <span class="hljs-literal">null</span>, args); <span class="hljs-comment">// 相当于 greet(...args)</span>
</code></pre>
<ul>
<li><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}
<span class="hljs-keyword">const</span> args = [<span class="hljs-string">'John'</span>, <span class="hljs-number">30</span>];
<span class="hljs-keyword">const</span> instance = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(<span class="hljs-title class_">Person</span>, args); <span class="hljs-comment">// 相当于 new Person(...args)</span>
</code></pre>
<h3 data-id="heading-4">原型相关</h3>
<ul>
<li><code>Reflect.getPrototypeOf</code> 等同于&nbsp;Object.getPrototypeOf()，用于获取对象的原型（即内部[[Prototype]]属性的值）。</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">obj</span> = { x: <span class="hljs-number">1</span> }<span class="hljs-comment">;</span>
const <span class="hljs-attr">proto</span> = Reflect.getPrototypeOf(obj)<span class="hljs-comment">; // 相当于 Object.getPrototypeOf(obj)</span>
console.log(<span class="hljs-attr">proto</span> === Object.prototype)<span class="hljs-comment">; // true</span>
</code></pre>
<ul>
<li><code>Reflect.setPrototypeOf</code> 基本等同于&nbsp;Object.setPrototypeOf()，用于设置对象的原型（即内部[[Prototype]]属性的值）。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> };
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 设置 obj 的原型为 Array.prototype</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span>
</code></pre>
<h3 data-id="heading-5">对象相关</h3>
<ul>
<li>
<p><code>Reflect.defineProperty()</code> 方法基本等同于 Object.defineProperty，但返回值略有不同。如果定义属性成功，它会返回true，否则返回false。</p>
</li>
<li>
<p><code>Reflect.deleteProperty()</code> 方法基本等同于 delete operator，用于删除一个对象的属性。</p>
</li>
<li>
<p><code>Reflect.get(target, propertyKey, receiver)</code> 方法用于读取属性值，等同于&nbsp;target[propertyKey]，但receiver参数可以改变getter的this对象。</p>
</li>
<li>
<p><code> Reflect.set(target, propertyKey, value, receiver)</code> 方法用于设置属性值，等同于target[propertyKey] = value，但receiver参数可以改变setter的this对象。</p>
</li>
<li>
<p><code>Reflect.has(target, propertyKey)</code> 方法基本等同于&nbsp;<code>propertyKey in target</code>，用于检查一个属性是否在某个对象中。</p>
</li>
<li>
<p><code>Reflect.getOwnPropertyDescriptor(target, propertyKey)</code>&nbsp;方法用于获取对象自身的某个属性的属性描述符，等同于Object.getOwnPropertyDescriptor()。</p>
</li>
<li>
<p><code>Reflect.ownKeys(target)</code> 方法返回一个由目标对象自身的属性键组成的数组，等同于&nbsp;Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</p>
</li>
<li>
<p><code>Reflect.isExtensible(target)&nbsp;</code> 方法用于判断一个对象是否可扩展，等同于&nbsp;Object.isExtensible()。</p>
</li>
<li>
<p><code>Reflect.preventExtensions(target)</code>&nbsp;方法基本等同于&nbsp;Object.preventExtensions()，用于使一个对象变为不可扩展。如果操作成功则返回true，否则返回false。</p>
</li>
</ul>
<h2 data-id="heading-6">Reflect vs Object</h2>
<p>Reflect &amp;&amp; Object的某些方法是相似甚至相同的，可能有的同学会问，为什么不直接把Reflect的方法放在Object上呢？何必新加一个对象？两者到底有什么区别？</p>
<ol>
<li>
<p>Reflect上不光有对象的相关操作方法还有函数相关的方法 这和Object本身代表的含义不符 因此不能放在Object上。同时Reflect为未来语言的扩展提供了一套可能的API，如果将来JavaScript想要添加新的底层操作对象的方法，它们可以被加入到Reflect上，而不是继续增加Object的静态方法，这样有助于保持Object构造函数的简洁性。</p>
</li>
<li>
<p>在Reflect出现之前，JavaScript操作对象的一些方法散布在Object构造函数上，比如Object.defineProperty。但是，这些方法的返回值和错误处理机制并不一致（例如，如果操作失败，一些方法会抛出错误，而其他一些方法则返回false）。Reflect提供了一套具有一致返回值的API，使得这些操作更加统一和可预测。</p>
</li>
</ol>
<p>所以 <strong><code>当Reflect和Object方法能实现同样效果时 我们建议优先使用Reflect</code></strong></p>
<h2 data-id="heading-7">设计目的</h2>
<p>在有了上面的一些基本了解后 我们再来谈下Reflect的设计目的：</p>
<h3 data-id="heading-8">编程规范性</h3>
<ol>
<li>
<p><strong>统一操作对象的方法</strong>：Reflect提供了一套具有一致返回值的API，使得这些操作更加统一和可预测。</p>
</li>
<li>
<p><strong>提供未来的新操作 API</strong>：Reflect为未来语言的扩展提供了一套可能的API。</p>
</li>
<li>
<p><strong>使某些操作更加函数式</strong>：JavaScript是一门支持函数式编程的语言，在某些场景中，我们可能更倾向于使用函数而不是命令式的操作。Reflect的方法都是函数更符合js函数式的思想。<br>
<code>delete obj.xx</code>, <code>key in obj</code> 这种代码都可以使用reflect替代。<br> <strong><code>当Reflect和操作符(例如delete, in)能实现同样效果时 我们建议优先使用Reflect</code></strong>。</p>
</li>
<li>
<p><strong>简化错误处理</strong>：像之前提到的，传统的对象操作方法在错误处理上不一致。Reflect提供的方法倾向于返回更简明的结果，如布尔值，这简化了错误处理和条件检测。</p>
</li>
</ol>
<h3 data-id="heading-9">获取语言内部的基本操作</h3>
<p>基本操作包括<code>属性访问和赋值</code>、<code>属性删除</code>、<code>枚举</code>、<code>函数调用</code>、<code>对象构造</code>等等 <br>
例如：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">originalFunction</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>);
}

<span class="hljs-keyword">const</span> context = {
  <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello, Reflect!'</span>,
};

<span class="hljs-comment">// 假设originalFunction有一个自定义的apply方法</span>
originalFunction.<span class="hljs-property">apply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Custom apply method called'</span>);
};

<span class="hljs-comment">// 如果调用originalFunction的apply方法，会调用自定义的apply，而不是原生的Function.prototype.apply</span>
originalFunction.<span class="hljs-title function_">apply</span>(context); <span class="hljs-comment">// 输出: Custom apply method called</span>


<span class="hljs-comment">// 使用Reflect.apply可以更简单地达到同样的效果，并且不管原Function对象有没有自定义的apply方法</span>
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(originalFunction, context,[]); <span class="hljs-comment">// 输出: Hello, Reflect!</span>
</code></pre>
<p>即使在特定环境下目标函数的某些行为被覆盖或修改了  Reflect对象依然是调用语言的内部基本操作，而不受外部环境的影响。 <br>
当然我们通过其他方式也是可以做到的 只是麻烦了一点...</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用Function.prototype.apply.call确保调用的是原生的apply方法</span>
<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">apply</span>.<span class="hljs-title function_">call</span>(originalFunction, context,[]); <span class="hljs-comment">// 输出: Hello, Reflect!</span>
</code></pre>
<h3 data-id="heading-10">配合proxy实现代理等元编程操作</h3>
<p>元编程是指编写可以操作或改变其他程序的程序。元编程可以改变 JavaScript 的一些基本操作的行为。<br>
主要与这三个对象有关。<br>
<strong>Symbol</strong>：通过内置Symbol值复写 js语言中的<code>基本操作</code>。<br>
<strong>Reflect</strong>：可以获取语言内部的<code>基本操作</code>。<br>
<strong>Proxy</strong>：通过钩子函数 拦截&amp;改变 js语言的<code>基本操作</code>。<br></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> obj = {};
<span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj,{
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>){
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`get <span class="hljs-subst">${property}</span>`</span>, target[property])
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property, receiver)
    },
    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>){
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`set <span class="hljs-subst">${property}</span>`</span>, value)
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, property, value, receiver);
    },
    <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, property</span>){ <span class="hljs-comment">// 拦截属性删除</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`delete <span class="hljs-subst">${property}</span>`</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, property);
    }
})

proxyObj.<span class="hljs-property">name</span> = <span class="hljs-string">'test'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxyObj.<span class="hljs-property">name</span>)
<span class="hljs-keyword">delete</span> proxyObj.<span class="hljs-property">name</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxyObj.<span class="hljs-property">name</span>)

<span class="hljs-comment">// 结果</span>
set name test
get name test
test
<span class="hljs-keyword">delete</span> name
get name <span class="hljs-literal">undefined</span>
<span class="hljs-literal">undefined</span>
</code></pre>
<p>这段代码展示了如何使用Proxy对象来拦截对底层对象的操作。</p>
<p>通过这种方法，可以在执行实际操作之前或之后插入自定义行为。这里拦截了三种操作：属性的获取 (get)、设置 (set) 和删除 (deleteProperty)。</p>
<h2 data-id="heading-11">元编程系列文章</h2>
<ul>
<li><a href="https://juejin.cn/post/7331955221114224675" target="_blank" title="https://juejin.cn/post/7331955221114224675">js元编程: Symbol&amp;Reflect&amp;Proxy</a></li>
<li><a href="https://juejin.cn/post/7354660202426597388" target="_blank" title="https://juejin.cn/post/7354660202426597388">js元编程：妙用proxy实现add[1][2][3] + 4</a></li>
<li><a href="https://juejin.cn/post/7329807974967722018" target="_blank" title="https://juejin.cn/post/7329807974967722018">js基石之Symbol值</a></li>
</ul>
<h2 data-id="heading-12">补充</h2>
<h3 data-id="heading-13">为什么proxy里一定要使用reflect？</h3>
<p>先看下不使用reflect的例子</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> obj = {
    <span class="hljs-attr">_name</span>: <span class="hljs-string">'test'</span>,
    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>(){
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;
    }
};
<span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj,{
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>){
        <span class="hljs-keyword">return</span> target[property];
    },
});

<span class="hljs-keyword">const</span> child = {
    <span class="hljs-attr">_name</span>: <span class="hljs-string">'child'</span>
};
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>(child, proxyObj);

child.<span class="hljs-property">name</span> <span class="hljs-comment">// test</span>
proxyObj.<span class="hljs-property">name</span> <span class="hljs-comment">// test</span>
</code></pre>
<p>因为代理对象的get拦截中固定返回的<code>target[property];</code>  target永远指向obj 所以拿到的永远是obj的_name属性值。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> obj = {
    <span class="hljs-attr">_name</span>: <span class="hljs-string">'test'</span>,
    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>(){
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_name</span>;
    }
};
<span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj,{
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property, receiver)
    },
});

<span class="hljs-keyword">const</span> child = {
    <span class="hljs-attr">_name</span>: <span class="hljs-string">'child'</span>
};
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>(child, proxyObj);

child.<span class="hljs-property">name</span> <span class="hljs-comment">// child </span>
proxyObj.<span class="hljs-property">name</span> <span class="hljs-comment">// test</span>
</code></pre>
<p>当我们使用Reflect时可以正确转发运行时上下文; 其实主要就是<code>receiver</code>这个参数，receiver 代表的是代理对象本身或者继承自代理对象的对象，它表示触发陷阱时<code>正确的上下文</code>。</p></div></div>