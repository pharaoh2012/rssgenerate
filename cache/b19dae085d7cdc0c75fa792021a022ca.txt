
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19044976" title="发布于 2025-08-18 16:49">
    <span role="heading" aria-level="2">【渲染流水线】[光栅阶段]-[光栅插值]以UnityURP为例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250818165210465-1069539902.png" alt="【渲染流水线】[光栅阶段]-[光栅插值]以UnityURP为例" class="desc_img">
        本文探讨了Unity URP渲染管线中的光栅化过程。重点解析了三角形设置阶段（计算边界框、预计算重心坐标分母）和遍历阶段（通过重心坐标判断像素覆盖，生成包含插值属性的片元）。文章详细介绍了透视校正插值公式，并举例说明颜色和纹理坐标的插值计算。同时指出URP中光栅化由UniversalRenderer类组织，底层由GPU固定功能单元加速实现，通过并行处理优化性能。文末邀请读者参与讨论，共同完善渲染知识体系。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<ul>
<li><strong>作用</strong>‌：将几何图元（三角形）转换为片元（Fragment），并插值顶点属性（如纹理坐标）</li>
<li>‌<strong>可配置</strong>‌：通过&nbsp;<code>Cull</code>&nbsp;指令控制面片剔除模式（<code>Back</code>/<code>Front</code>/<code>Off</code>）。</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<h1 id="三角形设置-triangle-setup">三角形设置 <strong>Triangle Setup</strong></h1>
<h2 id="预先计算全局系数">预先计算<strong>全局系数</strong>‌</h2>
<ul>
<li>优化遍历效率；实时计算则结合像素位置完成‌<strong>动态插值</strong>‌，确保透视正确性‌。</li>
</ul>
<h2 id="输入">输入：</h2>
<ul>
<li>屏幕坐标系下的三角形顶点坐标（包含深度值&nbsp;<code>z</code>）</li>
<li>关联属性：法线、纹理坐标、顶点颜色等‌</li>
</ul>
<h2 id="生成">生成：</h2>
<ul>
<li><strong>计算边界框</strong>‌：确定三角形在屏幕上的最小/最大像素范围（<code>x_min</code>,&nbsp;<code>y_min</code>&nbsp;至&nbsp;<code>x_max</code>,&nbsp;<code>y_max</code>），限定后续遍历区域‌。</li>
<li>生成边方程（效率低，用点积求重心方式判断替代的话这里不用求解这个）:构建三角形三条边的线性方程（如&nbsp;<code>Ax+By+C=0</code>），用于后续像素覆盖判断‌</li>
<li><strong>重心坐标分母项</strong>‌：预计算重心坐标插值所需的公共分母（如&nbsp;<code>1/(w0·α + w1·β + w2·γ)</code>），避免遍历阶段重复计算‌（由于使用点积重心坐标求解重心和像素判断，其中解方程组时有一个共同的行列式分母需要点积计算，这里可以把分母预计算，下面阶段就可以直接用。 点积重心求解坐标下面的三角形遍历阶段有解释。）</li>
<li>与像素位置无关的数学系数，供遍历阶段复用。</li>
</ul>
<h1 id="三角形遍历-triangle-traversal-扫描变换-scanconversion">三角形遍历 <strong>Triangle Traversal （扫描变换 ScanConversion）</strong></h1>
<h2 id="输入数据"><strong>输入数据</strong></h2>
<ul>
<li>三角形设置阶段输出的网格表示数据‌</li>
</ul>
<h2 id="输出数据">输出数据</h2>
<h3 id="像素覆盖检测"><strong>像素覆盖检测</strong>‌</h3>
<ul>
<li>遍历边界框内所有像素，通过<s>边方程</s>或<strong>重心坐标判断（点积重心坐标</strong>求解代替<strong>叉乘面积</strong>求解加速优化运算）中心点是否在三角形内部‌</li>
</ul>
<h3 id="片元生成"><strong>片元生成</strong></h3>
<p>对覆盖的像素创建片元（Fragment），包含以下状态：</p>
<ul>
<li>屏幕坐标&nbsp;<code>(x, y)</code></li>
<li>插值后的深度值&nbsp;<code>z</code></li>
<li>插值后的属性：法线、纹理坐标、颜色等‌</li>
</ul>
<h3 id="深度初筛"><strong>深度初筛</strong>‌</h3>
<ul>
<li>初步计算片元深度，供后续深度测试使用‌</li>
</ul>
<p>输出 片元序列（每个片元包含像素位置、深度及插值属性），传递至片元着色器‌</p>
<p>利用重心坐标权重混合顶点属性，确保纹理、颜色等平滑过渡‌：</p>
<p>$属性pixel=α⋅属性A+β⋅属性B+γ⋅属性C$</p>
<h3 id="点积法重心坐标公式解析"><strong>点积法重心坐标公式解析</strong></h3>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/other/3685400/202508/3685400-20250818164900018-992908384.png" class="lazyload"></p>
<h1 id="urp中光栅化的具体过程举例">URP中光栅化的具体过程举例</h1>
<p>Unity URP的光栅化阶段，几何图元通过重心坐标公式转化为片元的过程：</p>
<h2 id="三角形设置阶段">‌<strong>三角形设置阶段</strong>‌</h2>
<ul>
<li>首先计算三角形在屏幕空间的包围盒，确定潜在覆盖的像素范围。</li>
<li>例如一个三角形顶点坐标为(100,200)、(300,400)、(200,500)，其包围盒范围为x∈[100,300]，y∈[200,500]。</li>
</ul>
<h2 id="三角形遍历与片元生成">‌<strong>三角形遍历与片元生成</strong>‌</h2>
<ul>
<li>遍历包围盒内所有像素，通过重心坐标判断是否在三角形内。重心坐标公式为：</li>
<li>$α + β + γ = 1 (α,β,γ ≥ 0)$</li>
<li>若像素(150,300)的重心坐标计算结果为α=0.4, β=0.3, γ=0.3，则该像素属于三角形。</li>
</ul>
<h2 id="透视校正插值">‌<strong>透视校正插值</strong>‌</h2>
<ul>
<li>使用公式对顶点属性进行插值：</li>
<li>$f = (αf₀/w₀ + βf₁/w₁ + γf₂/w₂) / (α/w₀ + β/w₁ + γ/w₂)$</li>
<li>例如插值纹理坐标时，若三个顶点的w值为1.0、1.2、1.1，UV为(0,0)、(1,0)、(0,1)，则像素(150,300)的UV插值结果为(0.28, 0.23)45。</li>
</ul>
<h2 id="具体案例">具体案例：</h2>
<ul>
<li>一个红色渐变三角形，顶点颜色分别为红(1,0,0)、绿(0,1,0)、蓝(0,0,1)。</li>
<li>片元(200,350)的重心坐标为(0.5,0.3,0.2)，插值后颜色为(0.5,0.3,0.2)。</li>
</ul>
<h1 id="光栅化在urp中的具体实现">光栅化在URP中的具体实现</h1>
<h2 id="核心类与方法"><strong>核心类与方法</strong>‌</h2>
<p>在URP管线中，相关逻辑由以下部分实现：</p>
<ul>
<li>‌<strong>UniversalRenderer类</strong>‌：负责组织渲染流程，通过<code>RenderOpaqueGeometry</code>等方法触发光栅化</li>
<li>‌<strong>ShaderLibrary/Core.hlsl</strong>‌：包含插值计算的底层实现，如<code>InterpolateBarycentricCoords</code>等工具函数</li>
<li>‌<strong>GPU固定功能单元</strong>‌：实际计算由硬件光栅化器完成，Unity通过<code>CommandBuffer.DrawProcedural</code>等接口触发</li>
</ul>
<h2 id="gpu加速机制">‌<strong>GPU加速机制</strong>‌</h2>
<p><strong>重心坐标计算通过以下方式实现硬件加速：</strong></p>
<ul>
<li>由GPU的‌<strong>光栅化引擎</strong>(Rasterizer Engine)自动执行，属于固定管线功能</li>
<li>Unity通过<code>ShaderPass</code>中的<code>HLSLPROGRAM</code>声明插值变量（如<code>Varyings</code>结构体），驱动GPU完成插值</li>
<li>计算过程优化为并行处理，每个流处理器(SM)同时处理多个像素的重心坐标</li>
</ul>
<p><strong>典型数据流路径为：</strong><br>
<code>UniversalRenderer</code>&nbsp;→&nbsp;<code>Shader.Draw</code>&nbsp;→ GPU光栅化器 → 片元着色器（接收插值后数据</p>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0020833333333333333" data-date-updated="2025-08-18 16:52">2025-08-18 16:49</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
阅读(<span id="post_view_count">3</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19044976);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19044976', targetLink: 'https://www.cnblogs.com/SmalBox/p/19044976', title: '【渲染流水线】[光栅阶段]-[光栅插值]以UnityURP为例' })">举报</a>
</div>
        