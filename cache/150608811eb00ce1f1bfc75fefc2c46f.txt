
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ivictor/p/18733235" title="发布于 2025-02-24 07:29">
    <span role="heading" aria-level="2">Redis 大 Key 分析利器：支持 TOP N、批量分析与从节点优先</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        
        推荐一个比 redis-cli 更强大的 Redis 大 Key 分析工具
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">背景</span></h1>
<p data-tool="mdnice编辑器">Redis 大 key 分析工具主要分为两类：</p>
<p data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)"><strong>1. 离线分析</strong></span></p>
<p data-tool="mdnice编辑器">基于 RDB 文件进行解析，常用工具是 redis-rdb-tools（https://github.com/sripathikrishnan/redis-rdb-tools）。</p>
<p data-tool="mdnice编辑器">不过这个工具已近 5 年未更新，不支持 Redis 7，而且由于使用 Python 开发，解析速度较慢。</p>
<p data-tool="mdnice编辑器">目前较为活跃的替代工具是 https://github.com/HDT3213/rdb ，该工具支持 Redis 7，并使用 Go 开发。</p>
<p data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)"><strong>2. 在线分析</strong></span></p>
<p data-tool="mdnice编辑器">常用工具是 redis-cli，提供两种分析方式：</p>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>--bigkeys：Redis 3.0.0 引入，统计的是 key 中元素的数量。</li>
<li>--memkeys：Redis 6.0.0 引入，通过<code>MEMORY USAGE</code>命令统计 key 的内存占用。</li>
</ol>
<p data-tool="mdnice编辑器">这两种方式的优缺点如下：</p>
<ul class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>离线分析：基于 RDB 文件进行解析，不会对线上实例产生影响，不足的是操作相对复杂，尤其是对于很多 Redis 云服务，由于禁用了 SYNC 命令，无法直接通过&nbsp;<code>redis-cli --rdb &lt;filename&gt;</code>&nbsp;下载 RDB 文件，只能手动从控制台下载。</li>
<li>在线分析：操作简单，只要有实例的访问权限，即可直接进行分析，不足的是分析过程中可能会对线上实例的性能产生一定影响。</li>
</ul>
<p data-tool="mdnice编辑器">本文要介绍的工具（<code>redis-find-big-key</code>）也是一个在线分析工具，其实现思路与<code>redis-cli --memkeys</code>类似，但功能更为强大实用。主要体现在：</p>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>
<p>支持 TOP N 功能</p>
<p>该工具能够输出内存占用最多的前 N 个 key，而 redis-cli 只能输出每种类型中占用最多的单个 key。</p>
</li>
<li>
<p>支持批量分析</p>
<p>该工具能够同时分析多个 Redis 节点，特别是对于 Redis Cluster，启用集群模式（<code>-cluster-mode</code>）后，会自动分析每个分片。而 redis-cli 只能针对单个节点进行分析。</p>
</li>
<li>
<p>自动选择从节点进行分析</p>
<p>为了减少对实例性能的影响，工具会自动选择从节点进行分析。只有在没有从节点时，才会选择主节点进行分析。而 redis-cli 只能分析主节点。</p>
</li>
</ol>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">测试时间对比</span></h1>
<p data-tool="mdnice编辑器">测试环境：Redis 6.2.17，单实例，used_memory_human 为 9.75G，key 数量 100w，RDB 文件大小 3GB。</p>
<p data-tool="mdnice编辑器">以下是上面提到的四个工具在获取内存占用最多的 100 个 key 时的耗时情况：</p>
<table>
<thead>
<tr><th>工具</th><th>耗时</th></tr>
</thead>
<tbody>
<tr>
<td>redis-rdb-tools</td>
<td>25m38.68s</td>
</tr>
<tr>
<td>https://github.com/HDT3213/rdb</td>
<td>50.68s</td>
</tr>
<tr>
<td>redis-cli --memkeys</td>
<td>40.22s</td>
</tr>
<tr>
<td>redis-find-big-key</td>
<td>29.12s</td>
</tr>
</tbody>
</table>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">工具效果</span></h1>
<pre data-tool="mdnice编辑器"><code>#&nbsp;./redis-find-big-key&nbsp;-addr&nbsp;10.0.1.76:6379&nbsp;-cluster-mode<br>Log&nbsp;file&nbsp;not&nbsp;specified,&nbsp;using&nbsp;default:&nbsp;/tmp/10.0.1.76:6379_20250222_043832.txt<br>Scanning&nbsp;keys&nbsp;from&nbsp;node:&nbsp;10.0.1.76:6380&nbsp;(slave)<br><br>Node:&nbsp;10.0.1.76:6380<br>--------&nbsp;Summary&nbsp;--------<br>Sampled&nbsp;8&nbsp;keys&nbsp;in&nbsp;the&nbsp;keyspace!<br>Total&nbsp;key&nbsp;length&nbsp;in&nbsp;bytes&nbsp;is&nbsp;2.96&nbsp;MB&nbsp;(avg&nbsp;len&nbsp;379.43&nbsp;KB)<br><br>Top&nbsp;biggest&nbsp;keys:<br>+------------------------------+--------+-----------+---------------------+<br>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;Type&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Number&nbsp;of&nbsp;elements&nbsp;&nbsp;|<br>+------------------------------+--------+-----------+---------------------+<br>|&nbsp;mysortedset_20250222043729:1&nbsp;|&nbsp;&nbsp;zset&nbsp;&nbsp;|&nbsp;739.6&nbsp;KB&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;8027&nbsp;members&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;&nbsp;&nbsp;myhash_20250222043741:2&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;hash&nbsp;&nbsp;|&nbsp;648.12&nbsp;KB&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9490&nbsp;fields&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;mysortedset_20250222043741:1&nbsp;|&nbsp;&nbsp;zset&nbsp;&nbsp;|&nbsp;536.44&nbsp;KB&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;5608&nbsp;members&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;&nbsp;&nbsp;&nbsp;myset_20250222043729:1&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;set&nbsp;&nbsp;&nbsp;|&nbsp;399.66&nbsp;KB&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;8027&nbsp;members&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;&nbsp;&nbsp;&nbsp;myset_20250222043741:1&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;set&nbsp;&nbsp;&nbsp;|&nbsp;328.36&nbsp;KB&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;5608&nbsp;members&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;&nbsp;&nbsp;myhash_20250222043729:2&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;hash&nbsp;&nbsp;|&nbsp;222.65&nbsp;KB&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3917&nbsp;fields&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;&nbsp;&nbsp;mylist_20250222043729:1&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;list&nbsp;&nbsp;|&nbsp;160.54&nbsp;KB&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8027&nbsp;items&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;&nbsp;&nbsp;&nbsp;mykey_20250222043729:2&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;string&nbsp;|&nbsp;73&nbsp;bytes&nbsp;&nbsp;|&nbsp;7&nbsp;bytes&nbsp;(value&nbsp;len)&nbsp;|<br>+------------------------------+--------+-----------+---------------------+<br>Scanning&nbsp;keys&nbsp;from&nbsp;node:&nbsp;10.0.1.202:6380&nbsp;(slave)<br><br>Node:&nbsp;10.0.1.202:6380<br>--------&nbsp;Summary&nbsp;--------<br>Sampled&nbsp;8&nbsp;keys&nbsp;in&nbsp;the&nbsp;keyspace!<br>Total&nbsp;key&nbsp;length&nbsp;in&nbsp;bytes&nbsp;is&nbsp;3.11&nbsp;MB&nbsp;(avg&nbsp;len&nbsp;398.23&nbsp;KB)<br><br>Top&nbsp;biggest&nbsp;keys:<br>+------------------------------+--------+------------+---------------------+<br>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;Type&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Number&nbsp;of&nbsp;elements&nbsp;&nbsp;|<br>+------------------------------+--------+------------+---------------------+<br>|&nbsp;mysortedset_20250222043741:2&nbsp;|&nbsp;&nbsp;zset&nbsp;&nbsp;|&nbsp;1020.13&nbsp;KB&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;9490&nbsp;members&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;&nbsp;&nbsp;&nbsp;myset_20250222043741:2&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;set&nbsp;&nbsp;&nbsp;|&nbsp;588.81&nbsp;KB&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;9490&nbsp;members&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;&nbsp;&nbsp;myhash_20250222043729:1&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;hash&nbsp;&nbsp;|&nbsp;&nbsp;456.1&nbsp;KB&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8027&nbsp;fields&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;mysortedset_20250222043729:2&nbsp;|&nbsp;&nbsp;zset&nbsp;&nbsp;|&nbsp;&nbsp;404.5&nbsp;KB&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;3917&nbsp;members&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;&nbsp;&nbsp;myhash_20250222043741:1&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;hash&nbsp;&nbsp;|&nbsp;335.79&nbsp;KB&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5608&nbsp;fields&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;&nbsp;&nbsp;&nbsp;myset_20250222043729:2&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;set&nbsp;&nbsp;&nbsp;|&nbsp;195.87&nbsp;KB&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;3917&nbsp;members&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;&nbsp;&nbsp;mylist_20250222043741:2&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;list&nbsp;&nbsp;|&nbsp;184.55&nbsp;KB&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9490&nbsp;items&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;&nbsp;&nbsp;&nbsp;mykey_20250222043741:1&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;string&nbsp;|&nbsp;&nbsp;73&nbsp;bytes&nbsp;&nbsp;|&nbsp;7&nbsp;bytes&nbsp;(value&nbsp;len)&nbsp;|<br>+------------------------------+--------+------------+---------------------+<br>Scanning&nbsp;keys&nbsp;from&nbsp;node:&nbsp;10.0.1.147:6380&nbsp;(slave)<br><br>Node:&nbsp;10.0.1.147:6380<br>--------&nbsp;Summary&nbsp;--------<br>Sampled&nbsp;4&nbsp;keys&nbsp;in&nbsp;the&nbsp;keyspace!<br>Total&nbsp;key&nbsp;length&nbsp;in&nbsp;bytes&nbsp;is&nbsp;192.9&nbsp;KB&nbsp;(avg&nbsp;len&nbsp;48.22&nbsp;KB)<br><br>Top&nbsp;biggest&nbsp;keys:<br>+-------------------------+--------+-----------+---------------------+<br>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;Type&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Number&nbsp;of&nbsp;elements&nbsp;&nbsp;|<br>+-------------------------+--------+-----------+---------------------+<br>|&nbsp;mylist_20250222043741:1&nbsp;|&nbsp;&nbsp;list&nbsp;&nbsp;|&nbsp;112.45&nbsp;KB&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5608&nbsp;items&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;mylist_20250222043729:2&nbsp;|&nbsp;&nbsp;list&nbsp;&nbsp;|&nbsp;80.31&nbsp;KB&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3917&nbsp;items&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>|&nbsp;mykey_20250222043729:1&nbsp;&nbsp;|&nbsp;string&nbsp;|&nbsp;73&nbsp;bytes&nbsp;&nbsp;|&nbsp;7&nbsp;bytes&nbsp;(value&nbsp;len)&nbsp;|<br>|&nbsp;mykey_20250222043741:2&nbsp;&nbsp;|&nbsp;string&nbsp;|&nbsp;73&nbsp;bytes&nbsp;&nbsp;|&nbsp;7&nbsp;bytes&nbsp;(value&nbsp;len)&nbsp;|<br>+-------------------------+--------+-----------+---------------------+<br></code></pre>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">工具地址</span></h1>
<p data-tool="mdnice编辑器">项目地址：https://github.com/slowtech/redis-find-big-key</p>
<p data-tool="mdnice编辑器">可直接下载二进制包，也可进行源码编译。</p>
<h3 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">直接下载二进制包</span></h3>
<pre data-tool="mdnice编辑器"><code>#&nbsp;wget&nbsp;https://github.com/slowtech/redis-find-big-key/releases/download/v1.0.0/redis-find-big-key-linux-amd64.tar.gz<br>#&nbsp;tar&nbsp;xvf&nbsp;redis-find-big-key-linux-amd64.tar.gz&nbsp;<br></code></pre>
<p data-tool="mdnice编辑器">解压后，会在当前目录生成一个名为<code>redis-find-big-key</code>的可执行文件。</p>
<h3 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">源码编译</span></h3>
<pre data-tool="mdnice编辑器"><code>#&nbsp;wget&nbsp;https://github.com/slowtech/redis-find-big-key/archive/refs/tags/v1.0.0.tar.gz<br>#&nbsp;tar&nbsp;xvf&nbsp;v1.0.0.tar.gz&nbsp;<br>#&nbsp;cd&nbsp;redis-find-big-key-1.0.0<br>#&nbsp;go&nbsp;build<br></code></pre>
<p data-tool="mdnice编辑器">编译完成后，会在当前目录生成一个名为<code>redis-find-big-key</code>的可执行文件。</p>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">参数解析</span></h1>
<pre data-tool="mdnice编辑器"><code>#&nbsp;./redis-find-big-key&nbsp;--help<br>Usage&nbsp;of&nbsp;./redis-find-big-key:<br>&nbsp;&nbsp;-addr&nbsp;string<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redis&nbsp;server&nbsp;address&nbsp;in&nbsp;the&nbsp;format&nbsp;&lt;hostname&gt;:&lt;port&gt;<br>&nbsp;&nbsp;-cluster-mode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable&nbsp;cluster&nbsp;mode&nbsp;to&nbsp;get&nbsp;keys&nbsp;from&nbsp;all&nbsp;shards&nbsp;in&nbsp;the&nbsp;Redis&nbsp;cluster<br>&nbsp;&nbsp;-concurrency&nbsp;int<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum&nbsp;number&nbsp;of&nbsp;nodes&nbsp;to&nbsp;process&nbsp;concurrently&nbsp;(default&nbsp;1)<br>&nbsp;&nbsp;-direct<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform&nbsp;operation&nbsp;on&nbsp;the&nbsp;specified&nbsp;node.&nbsp;If&nbsp;not&nbsp;specified,&nbsp;the&nbsp;operation&nbsp;will&nbsp;default&nbsp;to&nbsp;executing&nbsp;on&nbsp;the&nbsp;slave&nbsp;node<br>&nbsp;&nbsp;-log-file&nbsp;string<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log&nbsp;file&nbsp;for&nbsp;saving&nbsp;progress&nbsp;and&nbsp;intermediate&nbsp;result<br>&nbsp;&nbsp;-master-yes<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Execute&nbsp;even&nbsp;if&nbsp;the&nbsp;Redis&nbsp;role&nbsp;is&nbsp;master<br>&nbsp;&nbsp;-password&nbsp;string<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redis&nbsp;password<br>&nbsp;&nbsp;-samples&nbsp;uint<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Samples&nbsp;for&nbsp;memory&nbsp;usage&nbsp;(default&nbsp;5)<br>&nbsp;&nbsp;-skip-lazyfree-check<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Skip&nbsp;check&nbsp;lazyfree-lazy-expire<br>&nbsp;&nbsp;-sleep&nbsp;float<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sleep&nbsp;duration&nbsp;(in&nbsp;seconds)&nbsp;after&nbsp;processing&nbsp;each&nbsp;batch<br>&nbsp;&nbsp;-tls<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable&nbsp;TLS&nbsp;for&nbsp;Redis&nbsp;connection<br>&nbsp;&nbsp;-top&nbsp;int<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum&nbsp;number&nbsp;of&nbsp;biggest&nbsp;keys&nbsp;to&nbsp;display&nbsp;(default&nbsp;100)<br></code></pre>
<p data-tool="mdnice编辑器">各个参数的具体含义如下：</p>
<ul class="list-paddingleft-2" data-tool="mdnice编辑器">
<li>
<p>-addr：指定 Redis 实例的地址，格式为<code>&lt;hostname&gt;:&lt;port&gt;</code>，例如 10.0.0.108:6379。注意，</p>
</li>
<ul class="list-paddingleft-1">
<li>如果不启用集群模式（-cluster-mode），可以指定多个地址，地址之间用逗号分隔，例如 10.0.0.108:6379,10.0.0.108:6380。</li>
<li>如果启用集群模式，只能指定一个地址，工具会自动发现集群中的其它节点。</li>
</ul>
<li>
<p>-cluster-mode：开启集群模式。工具会自动分析 Redis Cluster 中的每个分片，并优先选择从节点，只有在对应分片没有从节点时，才会选择主节点进行分析。</p>
</li>
<li>
<p>-concurrency：设置并发度，默认值为 1，即逐个节点进行分析。如果要分析的节点比较多，可以增加并发度来提升分析速度。</p>
</li>
<li>
<p>-direct：在 -addr 指定的节点上直接进行分析，这样会跳过自动选择从节点这个默认逻辑。</p>
</li>
<li>
<p>-log-file：指定日志文件路径，用于记录分析过程中的进度信息和中间过程信息。不指定则默认是<code>/tmp/&lt;firstNode&gt;_&lt;timestamp&gt;.txt</code>，例如 /tmp/10.0.0.108:6379_20250218_125955.txt。</p>
</li>
<li>
<p>-master-yes：如果待分析的节点中存在主节点（常见原因：从节点不存在；通过 -direct 参数指定要在主节点上分析），工具会提示以下错误：</p>
<blockquote>
<p>Error: nodes 10.0.1.76:6379 are master. To execute, you must specify --master-yes</p>
</blockquote>
<p>如果确定可以在主节点上进行分析，可指定 -master-yes 跳过检测。</p>
</li>
<li>
<p>-password：指定 Redis 实例的密码。</p>
</li>
<li>
<p>-samples：设置<code>MEMORY USAGE key [SAMPLES count]</code>命令中的采样数量。对于包含多个元素的数据结构（如 LIST、SET、ZSET、HASH、STREAM 等），采样数量过低可能导致内存占用估算不准确，而过高则会增加计算时间和资源消耗。SAMPLES 不指定的话，默认为 5。</p>
</li>
<li>
<p>-skip-lazyfree-check：如果是在主节点上进行分析，需要特别注意过期大 key。因为扫描操作会触发过期 key 的删除，如果未开启惰性删除（<code>lazyfree-lazy-expire</code>），删除操作将在主线程中执行，此时，删除大 key 可能会导致阻塞，影响正常的业务请求。</p>
<p>因此，当工具在主节点上进行分析时，会自动检查该节点是否启用了惰性删除。如果未启用，工具将提示以下错误并终止操作，以避免对线上业务造成影响：</p>
<blockquote>
<p>Error: nodes 10.0.1.76:6379 are master and lazyfree-lazy-expire is set to 'no'. Scanning might trigger large key expiration, which could block the main thread. Please set lazyfree-lazy-expire to 'yes' for better performance. To skip this check, you must specify --skip-lazyfree-check</p>
</blockquote>
<p>在这种情况下，建议通过<code>CONFIG SET lazyfree-lazy-expire yes</code>命令开启惰性删除。</p>
<p>如果确认没有过期大 key，可指定 -skip-lazyfree-check 跳过检测。</p>
</li>
<li>
<p>-sleep：设置每扫描完一批数据后的休眠时间。</p>
</li>
<li>
<p>-tls：启用 TLS 连接。</p>
</li>
<li>
<p>-top: &nbsp;显示占用内存最多的 前 N 个 key。默认是 100。</p>
</li>
</ul>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">常见用法</span></h1>
<h3 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">分析单个节点</span></h3>
<pre data-tool="mdnice编辑器"><code>./redis-find-big-key&nbsp;-addr&nbsp;10.0.1.76:6379<br>Scanning&nbsp;keys&nbsp;from&nbsp;node:&nbsp;10.0.1.202:6380&nbsp;(slave)<br></code></pre>
<p data-tool="mdnice编辑器">注意，在上面的示例中，指定的节点和实际扫描的节点并不相同。这是因为 10.0.1.76:6379 是主节点，而该工具默认会选择从库进行分析。只有当指定的主节点没有从库时，工具才会直接扫描该主节点。</p>
<h3 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">分析单个 Redis 集群</span></h3>
<pre data-tool="mdnice编辑器"><code>./redis-find-big-key&nbsp;-addr&nbsp;10.0.1.76:6379&nbsp;-cluster-mode<br></code></pre>
<p data-tool="mdnice编辑器">只需提供集群中任意一个节点的地址，工具会自动获取集群中其它节点的地址。同时，工具会优先选择从节点进行分析，只有在某个分片没有从节点时，才会选择该分片的主节点进行分析。</p>
<h3 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">分析多个节点</span></h3>
<pre data-tool="mdnice编辑器"><code>./redis-find-big-key&nbsp;-addr&nbsp;10.0.1.76:6379,10.0.1.202:6379,10.0.1.147:6379<br></code></pre>
<p data-tool="mdnice编辑器">节点之间是相互独立的，可以来自同一个集群，也可以来自不同的集群。注意，如果 -addr 参数指定了多个节点地址，则不能再使用 -cluster-mode 参数。</p>
<h3 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">对主节点进行分析</span></h3>
<p data-tool="mdnice编辑器">如果需要对主节点进行分析，可指定主节点并使用<code>-direct</code>参数。</p>
<pre data-tool="mdnice编辑器"><code>./redis-find-big-key&nbsp;-addr&nbsp;10.0.1.76:6379&nbsp;-direct&nbsp;-master-yes<br></code></pre>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">注意事项</span></h1>
<p data-tool="mdnice编辑器">1. 该工具仅适用于 Redis 4.0 及以上版本，因为<code>MEMORY USAGE</code>和<code>lazyfree-lazy-expire</code>是从 Redis 4.0 开始支持的。</p>
<p data-tool="mdnice编辑器">2. 同一个 key 在 redis-find-big-key 和 redis-cli 中显示的大小可能不一致，这是正常现象。原因在于，redis-find-big-key 默认选择从库进行分析，因此通常显示的是从库中的 key 大小，而 &nbsp;redis-cli 只能对主库进行分析，显示的是主库中的 key 大小。看下面这个示例。</p>
<pre data-tool="mdnice编辑器"><code>#&nbsp;./redis-find-big-key&nbsp;-addr&nbsp;10.0.1.76:6379&nbsp;-top&nbsp;1<br>Scanning&nbsp;keys&nbsp;from&nbsp;node:&nbsp;10.0.1.202:6380&nbsp;(slave)<br>...<br>Top&nbsp;biggest&nbsp;keys:<br>+------------------------------+------+------------+--------------------+<br>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Type&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Number&nbsp;of&nbsp;elements&nbsp;|<br>+------------------------------+------+------------+--------------------+<br>|&nbsp;mysortedset_20250222043741:2&nbsp;|&nbsp;zset&nbsp;|&nbsp;1020.13&nbsp;KB&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;9490&nbsp;members&nbsp;&nbsp;&nbsp;&nbsp;|<br>+------------------------------+------+------------+--------------------+<br><br>#&nbsp;redis-cli&nbsp;-h&nbsp;10.0.1.76&nbsp;-p&nbsp;6379&nbsp;-c&nbsp;MEMORY&nbsp;USAGE&nbsp;mysortedset_20250222043741:2<br>(integer)&nbsp;1014242<br><br>#&nbsp;echo&nbsp;"scale=2;&nbsp;1014242&nbsp;/&nbsp;1024"&nbsp;|&nbsp;bc<br>990.47<br></code></pre>
<p data-tool="mdnice编辑器">一个是 1020.13 KB，一个是 990.47 KB。</p>
<p data-tool="mdnice编辑器">如果直接通过 redis-find-big-key 查看主库中该 key 的大小，结果与 redis-cli 完全一致：</p>
<pre data-tool="mdnice编辑器"><code>#&nbsp;./redis-find-big-key&nbsp;-addr&nbsp;10.0.1.76:6379&nbsp;-direct&nbsp;--master-yes&nbsp;-top&nbsp;1&nbsp;--skip-lazyfree-check<br>Scanning&nbsp;keys&nbsp;from&nbsp;node:&nbsp;10.0.1.76:6379&nbsp;(master)<br>...<br>Top&nbsp;biggest&nbsp;keys:<br>+------------------------------+------+-----------+--------------------+<br>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Type&nbsp;|&nbsp;&nbsp;&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Number&nbsp;of&nbsp;elements&nbsp;|<br>+------------------------------+------+-----------+--------------------+<br>|&nbsp;mysortedset_20250222043741:2&nbsp;|&nbsp;zset&nbsp;|&nbsp;990.47&nbsp;KB&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;9490&nbsp;members&nbsp;&nbsp;&nbsp;&nbsp;|<br>+------------------------------+------+-----------+--------------------+<br></code></pre>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">实现原理</span></h1>
<p data-tool="mdnice编辑器">该工具是参考<code>redis-cli --memkeys</code>实现的。</p>
<p data-tool="mdnice编辑器">实际上，无论是<code>redis-cli --bigkeys</code>还是<code>redis-cli --memkeys</code>，调用的都是<code>findBigKeys</code>函数，只不过传入的参数不一样。</p>
<pre data-tool="mdnice编辑器"><code>/*&nbsp;Find&nbsp;big&nbsp;keys&nbsp;*/<br>if&nbsp;(config.bigkeys)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cliConnect(0)&nbsp;==&nbsp;REDIS_ERR)&nbsp;exit(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;findBigKeys(0,&nbsp;0);<br>}<br><br>/*&nbsp;Find&nbsp;large&nbsp;keys&nbsp;*/<br>if&nbsp;(config.memkeys)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cliConnect(0)&nbsp;==&nbsp;REDIS_ERR)&nbsp;exit(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;findBigKeys(1,&nbsp;config.memkeys_samples);<br>}<br></code></pre>
<p data-tool="mdnice编辑器">接下来，我们看一下这个函数的具体实现逻辑。</p>
<pre data-tool="mdnice编辑器"><code>static&nbsp;void&nbsp;findBigKeys(int&nbsp;memkeys,&nbsp;unsigned&nbsp;memkeys_samples)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;通过&nbsp;DBSIZE&nbsp;命令获取&nbsp;key&nbsp;的总数量<br>&nbsp;&nbsp;&nbsp;&nbsp;total_keys&nbsp;=&nbsp;getDbSize();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Status&nbsp;message&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("\n#&nbsp;Scanning&nbsp;the&nbsp;entire&nbsp;keyspace&nbsp;to&nbsp;find&nbsp;biggest&nbsp;keys&nbsp;as&nbsp;well&nbsp;as\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("#&nbsp;average&nbsp;sizes&nbsp;per&nbsp;key&nbsp;type.&nbsp;&nbsp;You&nbsp;can&nbsp;use&nbsp;-i&nbsp;0.1&nbsp;to&nbsp;sleep&nbsp;0.1&nbsp;sec\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("#&nbsp;per&nbsp;100&nbsp;SCAN&nbsp;commands&nbsp;(not&nbsp;usually&nbsp;needed).\n\n");<br><br>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;SCAN&nbsp;loop&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;do&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Calculate&nbsp;approximate&nbsp;percentage&nbsp;completion&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pct&nbsp;=&nbsp;100&nbsp;*&nbsp;(double)sampled/total_keys;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;通过&nbsp;SCAN&nbsp;命令扫描&nbsp;key<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reply&nbsp;=&nbsp;sendScan(&amp;it);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scan_loops++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取当前批次的 key 名称。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keys&nbsp;&nbsp;=&nbsp;reply-&gt;element[1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;使用&nbsp;pipeline&nbsp;技术批量发送&nbsp;TYPE&nbsp;命令，获取每个&nbsp;key&nbsp;的类型<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getKeyTypes(types_dict,&nbsp;keys,&nbsp;types);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;使用&nbsp;pipeline&nbsp;技术批量发送相应命令获取每个&nbsp;key&nbsp;的大小<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getKeySizes(keys,&nbsp;types,&nbsp;sizes,&nbsp;memkeys,&nbsp;memkeys_samples);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;逐个处理&nbsp;key，更新统计信息<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;keys-&gt;elements;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeinfo&nbsp;*type&nbsp;=&nbsp;types[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Skip&nbsp;keys&nbsp;that&nbsp;disappeared&nbsp;between&nbsp;SCAN&nbsp;and&nbsp;TYPE&nbsp;*/<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!type)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type-&gt;totalsize&nbsp;+=&nbsp;sizes[i];&nbsp;//&nbsp;累计每个类型&nbsp;key&nbsp;的总大小<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type-&gt;count++;&nbsp;//&nbsp;累计每个类型&nbsp;key&nbsp;的数量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totlen&nbsp;+=&nbsp;keys-&gt;element[i]-&gt;len;&nbsp;//&nbsp;累计&nbsp;key&nbsp;的长度<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sampled++;&nbsp;//&nbsp;累计扫描的&nbsp;key&nbsp;的数量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果当前 key 的大小超过该类型的最大值，则会更新该类型的最大键大小，并打印统计信息。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(type-&gt;biggest&lt;sizes[i])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(type-&gt;biggest_key)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sdsfree(type-&gt;biggest_key);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type-&gt;biggest_key&nbsp;=&nbsp;sdscatrepr(sdsempty(),&nbsp;keys-&gt;element[i]-&gt;str,&nbsp;keys-&gt;element[i]-&gt;len);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"[%05.2f%%]&nbsp;Biggest&nbsp;%-6s&nbsp;found&nbsp;so&nbsp;far&nbsp;'%s'&nbsp;with&nbsp;%llu&nbsp;%s\n",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pct,&nbsp;type-&gt;name,&nbsp;type-&gt;biggest_key,&nbsp;sizes[i],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!memkeys?&nbsp;type-&gt;sizeunit:&nbsp;"bytes");<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type-&gt;biggest&nbsp;=&nbsp;sizes[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;每扫描 100&nbsp;万个 key，还会输出当前进度和扫描的 key 数量。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(sampled&nbsp;%&nbsp;1000000&nbsp;==&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("[%05.2f%%]&nbsp;Sampled&nbsp;%llu&nbsp;keys&nbsp;so&nbsp;far\n",&nbsp;pct,&nbsp;sampled);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果设置了 interval，则每执行 100&nbsp;次 SCAN 命令，都会 sleep 一段时间。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(config.interval&nbsp;&amp;&amp;&nbsp;(scan_loops&nbsp;%&nbsp;100)&nbsp;==&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usleep(config.interval);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freeReplyObject(reply);<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;while(force_cancel_loop&nbsp;==&nbsp;0&nbsp;&amp;&amp;&nbsp;it&nbsp;!=&nbsp;0);<br>&nbsp;&nbsp;&nbsp;&nbsp;..&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出总的统计信息<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("\n--------&nbsp;summary&nbsp;-------\n\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(force_cancel_loop)&nbsp;printf("[%05.2f%%]&nbsp;",&nbsp;pct);&nbsp;//&nbsp;如果循环被取消，则显示进度百分比<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("Sampled&nbsp;%llu&nbsp;keys&nbsp;in&nbsp;the&nbsp;keyspace!\n",&nbsp;sampled);&nbsp;//&nbsp;打印已经扫描的&nbsp;key&nbsp;的数量<br>&nbsp;&nbsp;&nbsp;&nbsp;printf("Total&nbsp;key&nbsp;length&nbsp;in&nbsp;bytes&nbsp;is&nbsp;%llu&nbsp;(avg&nbsp;len&nbsp;%.2f)\n\n",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totlen,&nbsp;totlen&nbsp;?&nbsp;(double)totlen/sampled&nbsp;:&nbsp;0);&nbsp;//&nbsp;打印&nbsp;key&nbsp;名的总长度及平均长度<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出每种类型最大键的信息<br>&nbsp;&nbsp;&nbsp;&nbsp;di&nbsp;=&nbsp;dictGetIterator(types_dict);<br>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;((de&nbsp;=&nbsp;dictNext(di)))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeinfo&nbsp;*type&nbsp;=&nbsp;dictGetVal(de);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(type-&gt;biggest_key)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Biggest&nbsp;%6s&nbsp;found&nbsp;'%s'&nbsp;has&nbsp;%llu&nbsp;%s\n",&nbsp;type-&gt;name,&nbsp;type-&gt;biggest_key,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type-&gt;biggest,&nbsp;!memkeys?&nbsp;type-&gt;sizeunit:&nbsp;"bytes");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;//&nbsp;type-&gt;name&nbsp;是&nbsp;key&nbsp;的类型名称，type-&gt;biggest_key&nbsp;是最大键的名称<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;// type-&gt;biggest 是最大键的大小，!memkeys? type-&gt;sizeunit:&nbsp;"bytes"&nbsp;是大小单位。<br>&nbsp;&nbsp;&nbsp;&nbsp;..<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出每种类型的统计信息<br>&nbsp;&nbsp;&nbsp;&nbsp;di&nbsp;=&nbsp;dictGetIterator(types_dict);<br>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;((de&nbsp;=&nbsp;dictNext(di)))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeinfo&nbsp;*type&nbsp;=&nbsp;dictGetVal(de);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%llu&nbsp;%ss&nbsp;with&nbsp;%llu&nbsp;%s&nbsp;(%05.2f%%&nbsp;of&nbsp;keys,&nbsp;avg&nbsp;size&nbsp;%.2f)\n",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type-&gt;count,&nbsp;type-&gt;name,&nbsp;type-&gt;totalsize,&nbsp;!memkeys?&nbsp;type-&gt;sizeunit:&nbsp;"bytes",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sampled&nbsp;?&nbsp;100&nbsp;*&nbsp;(double)type-&gt;count/sampled&nbsp;:&nbsp;0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type-&gt;count&nbsp;?&nbsp;(double)type-&gt;totalsize/type-&gt;count&nbsp;:&nbsp;0);<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;// sampled ? 100&nbsp;*&nbsp;(double)type-&gt;count/sampled :&nbsp;0&nbsp;是当前类型的 key 的数量在总扫描的 key 数量中的百分比。<br>&nbsp;&nbsp;&nbsp;&nbsp;..<br>&nbsp;&nbsp;&nbsp;&nbsp;exit(0);<br>}<br></code></pre>
<p data-tool="mdnice编辑器">该函数的实现逻辑如下：</p>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>
<p>使用 DBSIZE 命令获取 Redis 数据库中的 key 总数。</p>
</li>
<li>
<p>使用 SCAN 命令批量扫描 key，并获取当前批次的 key 名称。</p>
</li>
<li>
<p>使用 pipeline 批量发送 TYPE 命令，获取每个 key 的类型。</p>
</li>
<li>
<p>使用 pipeline 批量发送相应命令获取每个 key 的大小：</p>
</li>
<ul class="list-paddingleft-1">
<li>若指定了 --bigkeys，根据 key 的类型使用对应命令获取大小：STRLEN（string 类型）、LLEN（list 类型）、SCARD（set 类型）、HLEN（hash 类型）、ZCARD（zset 类型）、XLEN（stream 类型）。</li>
<li>若指定了 --memkeys，使用 MEMORY USAGE 命令获取 key 的内存占用。</li>
</ul>
<li>
<p>逐个处理 key，更新统计信息：若某个 key 的大小超过该类型的最大值，则更新最大值并打印相关统计信息。</p>
</li>
<li>
<p>输出总结信息，展示每种 key 类型的最大 key 及其相关统计数据。</p>
</li>
</ol>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7023936389050925" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-24 07:29">2025-02-24 07:29</span>&nbsp;
<a href="https://www.cnblogs.com/ivictor">iVictor</a>&nbsp;
阅读(<span id="post_view_count">171</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18733235" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18733235);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18733235', targetLink: 'https://www.cnblogs.com/ivictor/p/18733235', title: 'Redis 大 Key 分析利器：支持 TOP N、批量分析与从节点优先' })">举报</a>
</div>
	