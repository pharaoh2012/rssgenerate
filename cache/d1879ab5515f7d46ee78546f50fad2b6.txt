
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/koushenhai/p/18869746" title="发布于 2025-05-10 16:40">
    <span role="heading" aria-level="2">物联网之对接MQTT最佳实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>小伙伴们，你们好呀，我是老寇，跟我一起学习对接MQTT</p>
<h3 id="安装emqx">安装EMQX</h3>
<p>采用docker-compose一键式启动！！！</p>
<p>还没有安装docker朋友，参考文章下面两篇文章</p>
<p><a href="https://koushenhai.github.io/pages/fade19/" target="_blank" rel="noopener nofollow"># Ubuntu20.04安装Docker</a></p>
<p><a href="https://koushenhai.github.io/pages/65acff/" target="_blank" rel="noopener nofollow"># Centos7安装Docker 23.0.6</a></p>
<h6 id="使用-emqx-541按照老夫的教程来请不要改版本号">使用 emqx 5.4.1，按照老夫的教程来，请不要改版本号！！！</h6>
<h6 id="使用-emqx-541按照老夫的教程来请不要改版本号-1">使用 emqx 5.4.1，按照老夫的教程来，请不要改版本号！！！</h6>
<h6 id="使用-emqx-541按照老夫的教程来请不要改版本号-2">使用 emqx 5.4.1，按照老夫的教程来，请不要改版本号！！！</h6>
<pre><code class="language-yml">services:
    emqx:
      image: emqx/emqx:5.4.1
      container_name: emqx
      # 保持容器在没有守护程序的情况下运行
      tty: true
      restart: always
      privileged: true
      ports:
        - "1883:1883"
        - "8083:8083"
        - "8883:8883"
        - "18083:18083"
      environment:
        - TZ=Asia/Shanghai
      volumes:
        # 挂载数据存储
        - ./emqx/data:/opt/emqx/data
        # 挂载日志文件
        - ./emqx/log:/opt/emqx/log
      networks:
        - laokou_network
networks:
  laokou_network:
    driver: bridge
</code></pre>
<p>访问 <a href="http://127.0.0.1:18083" target="_blank" rel="noopener nofollow">http://127.0.0.1:18083</a> 设置密码</p>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/d15ae88627c14bac98a46a4607b123d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgS-elng==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMTYwOTQ1ODA4ODczNTM0In0%3D&amp;rk3s=f64ab15b&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1747471147&amp;x-orig-sign=et%2FkJ6fQ8aj44Tm1Ht%2F7Lup%2Bo%2FY%3D" alt="image.png" loading="lazy"></p>
<h3 id="emqx-mqtt摘抄自官方文档">EMQX MQTT【摘抄自官方文档】</h3>
<p><a href="https://docs.emqx.com/zh/emqx/latest/configuration/mqtt.html" target="_blank" rel="noopener nofollow">EMQX官方文档</a></p>
<p><a href="https://mqtt.org/" target="_blank" rel="noopener nofollow">MQTT</a>&nbsp;是物联网 (IoT) 的 OASIS 标准消息传递协议。它被设计为一种极轻量的发布/订阅消息传输协议，非常适合以较小的代码占用空间和极低的网络带宽连接远程设备。MQTT 目前广泛应用于汽车、制造、电信、石油和天然气等众多行业。</p>
<p>EMQX 完全兼容 MQTT 5.0 和 3.x，本节将介绍 MQTT 相关功能的基本配置项，包括基本 MQTT 设置、订阅设置、会话设置、强制关闭设置和强制垃圾回收设置等</p>
<h3 id="客户端对接">客户端对接</h3>
<p>本文章采用三种客户端对接</p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>Paho</strong></th>
<th><strong>Hivemq-MQTT-Client</strong></th>
<th><strong>Vert.x MQTT Client</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>协议支持</strong></td>
<td>MQTT 3.1.1（5.0 实验性）</td>
<td><strong>MQTT 5.0 完整支持</strong></td>
<td>MQTT 5.0（较新版本）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>中（同步模式）</td>
<td><strong>高（异步非阻塞）</strong></td>
<td><strong>极高（响应式架构）</strong></td>
</tr>
<tr>
<td><strong>依赖复杂度</strong></td>
<td>低</td>
<td>中（仅 Netty）</td>
<td>高（需 Vert.x 生态）</td>
</tr>
<tr>
<td><strong>社区资源</strong></td>
<td><strong>丰富</strong></td>
<td>较少</td>
<td>中等</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>传统 IoT、跨语言项目</td>
<td>企业级 MQTT 5.0、高吞吐</td>
<td>响应式系统、高并发微服务</td>
</tr>
</tbody>
</table>
<h3 id="paho不推荐连接不稳定">Paho【不推荐，连接不稳定】</h3>
<p><a href="https://github.com/KouShenhai/mqtt-client-sample/tree/main/src/main/java/org/laokou/sample/mqtt/paho" target="_blank" rel="noopener nofollow">Paho代码地址</a></p>
<h6 id="引入依赖">引入依赖</h6>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.eclipse.paho&lt;/groupId&gt;
        &lt;artifactId&gt;org.eclipse.paho.mqttv5.client&lt;/artifactId&gt;
        &lt;version&gt;1.2.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.eclipse.paho&lt;/groupId&gt;
        &lt;artifactId&gt;org.eclipse.paho.client.mqttv3&lt;/artifactId&gt;
        &lt;version&gt;1.2.5&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h6 id="项目集成">项目集成</h6>
<p>PahoProperties</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@Data
public class PahoProperties {

    private boolean auth = true;

    private String username = "emqx";

    private String password = "laokou123";

    private String host = "127.0.0.1";

    private int port = 1883;

    private String clientId;

    private int subscribeQos = 1;

    private int publishQos = 0;

    private int willQos = 1;

    private int connectionTimeout = 60;

    private boolean manualAcks = false;

    // @formatter:off
    /**
     * 控制是否创建新会话（true=新建，false=复用历史会话）. clearStart=true =&gt; Broker 会在连接断开后立即清除所有会话信息.
     * clearStart=false =&gt; Broker 会在连接断开后保存会话信息，并在重新连接后复用会话信息.
     * &lt;a href="https://github.com/hivemq/hivemq-mqtt-client/issues/627"&gt;...&lt;/a&gt;
     */
    // @formatter:on
    private boolean clearStart = false;

    private int receiveMaximum = 10000;

    private int maximumPacketSize = 10000;

    // @formatter:off
    /**
     * 默认会话保留一天.
     * 最大值，4294967295L，会话过期时间【永不过期，单位秒】.
     * 定义客户端断开后会话保留的时间（仅在 Clean Session = false 时生效）.
     */
    private long sessionExpiryInterval = 86400L;
    // @formatter:on

    /**
     * 心跳包每隔60秒发一次.
     */
    private int keepAliveInterval = 60;

    private boolean automaticReconnect = true;

    private Set&lt;String&gt; topics = new HashSet&lt;&gt;(0);

}
</code></pre>
<p>PahoMqttClientMessageCallbackV5</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@Slf4j
@RequiredArgsConstructor
public class PahoMqttClientMessageCallbackV5 implements MqttCallback {

    private final List&lt;MessageHandler&gt; messageHandlers;

    @Override
    public void disconnected(MqttDisconnectResponse disconnectResponse) {
       log.error("【Paho-V5】 =&gt; MQTT关闭连接");
    }

    @Override
    public void mqttErrorOccurred(MqttException ex) {
       log.error("【Paho-V5】 =&gt; MQTT报错，错误信息：{}", ex.getMessage());
    }

    @Override
    public void messageArrived(String topic, MqttMessage message) {
       for (MessageHandler messageHandler : messageHandlers) {
          if (messageHandler.isSubscribe(topic)) {
             log.info("【Paho-V5】 =&gt; MQTT接收到消息，Topic：{}", topic);
             messageHandler.handle(new org.laokou.sample.mqtt.handler.MqttMessage(message.getPayload(), topic));
          }
       }
    }

    @Override
    public void deliveryComplete(IMqttToken token) {
       log.info("【Paho-V5】 =&gt; MQTT消息发送成功，消息ID：{}", token.getMessageId());
    }

    @Override
    public void connectComplete(boolean reconnect, String uri) {
       if (reconnect) {
          log.info("【Paho-V5】 =&gt; MQTT重连成功，URI：{}", uri);
       }
       else {
          log.info("【Paho-V5】 =&gt; MQTT建立连接，URI：{}", uri);
       }
    }

    @Override
    public void authPacketArrived(int reasonCode, MqttProperties properties) {
       log.info("【Paho-V5】 =&gt; 接收到身份验证数据包：{}", reasonCode);
    }

}
</code></pre>
<p>PahoV5MqttClientTest</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@SpringBootTest
@RequiredArgsConstructor
@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)
class PahoV5MqttClientTest {

    private final List&lt;MessageHandler&gt; messageHandlers;

    @Test
    void testMqttClient() throws InterruptedException {
        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(16);

        PahoProperties pahoProperties = new PahoProperties();
        pahoProperties.setClientId("test-client-3");
        pahoProperties.setTopics(Set.of("/test-topic-3/#"));
        PahoMqttClientV5 pahoMqttClientV5 = new PahoMqttClientV5(pahoProperties, messageHandlers, scheduledExecutorService);
        pahoMqttClientV5.open();
        Thread.sleep(1000);
        pahoMqttClientV5.publish("/test-topic-3/789", "Hello World789".getBytes());
    }

}
</code></pre>
<p>PahoMqttClientMessageCallbackV3</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@Slf4j
@RequiredArgsConstructor
public class PahoMqttClientMessageCallbackV3 implements MqttCallback {

    private final List&lt;MessageHandler&gt; messageHandlers;

    @Override
    public void deliveryComplete(IMqttDeliveryToken iMqttDeliveryToken) {
       log.info("【Paho-V3】 =&gt; MQTT消息发送成功，消息ID：{}", iMqttDeliveryToken.getMessageId());
    }

    @Override
    public void connectionLost(Throwable throwable) {
       log.error("【Paho-V3】 =&gt; MQTT关闭连接");
    }

    @Override
    public void messageArrived(String topic, MqttMessage message) throws Exception {
       for (MessageHandler messageHandler : messageHandlers) {
          if (messageHandler.isSubscribe(topic)) {
             log.info("【Paho-V3】 =&gt; MQTT接收到消息，Topic：{}", topic);
             messageHandler.handle(new org.laokou.sample.mqtt.handler.MqttMessage(message.getPayload(), topic));
          }
       }
    }
}
</code></pre>
<p>PahoV3MqttClientTest</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@SpringBootTest
@RequiredArgsConstructor
@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)
class PahoV3MqttClientTest {

    private final List&lt;MessageHandler&gt; messageHandlers;

    @Test
    void testMqttClient() throws InterruptedException {
        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(16);

        PahoProperties pahoProperties2 = new PahoProperties();
        pahoProperties2.setClientId("test-client-4");
        pahoProperties2.setTopics(Set.of("/test-topic-4/#"));
        PahoMqttClientV3 pahoMqttClientV3 = new PahoMqttClientV3(pahoProperties2, messageHandlers, scheduledExecutorService);
        pahoMqttClientV3.open();
        Thread.sleep(1000);
        pahoMqttClientV3.publish("/test-topic-4/000", "Hello World000".getBytes());
    }

}
</code></pre>
<h3 id="hivemq-mqtt-client不推荐">Hivemq-MQTT-Client【不推荐】</h3>
<p>注意：订阅一段时间收不到数据，标准mqtt5.0协议，不兼容emqx broker mqtt5.0</p>
<p><a href="https://github.com/KouShenhai/mqtt-client-sample/tree/main/src/main/java/org/laokou/sample/mqtt/hivemq" target="_blank" rel="noopener nofollow">Hivemq代码地址</a></p>
<h6 id="引入依赖-1">引入依赖</h6>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.hivemq&lt;/groupId&gt;
        &lt;artifactId&gt;hivemq-mqtt-client-reactor&lt;/artifactId&gt;
        &lt;version&gt;1.3.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.hivemq&lt;/groupId&gt;
        &lt;artifactId&gt;hivemq-mqtt-client-epoll&lt;/artifactId&gt;
        &lt;version&gt;1.3.5&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
&lt;dependencies&gt;
</code></pre>
<h6 id="项目集成-1">项目集成</h6>
<p>HivemqProperties</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@Data
public class HivemqProperties {

    private boolean auth = true;

    private String username = "emqx";

    private String password = "laokou123";

    private String host = "127.0.0.1";

    private int port = 1883;

    private String clientId;

    private int subscribeQos = 1;

    private int publishQos = 0;

    private int willQos = 1;

    // @formatter:off
    /**
     * 控制是否创建新会话（true=新建，false=复用历史会话）. clearStart=true =&gt; Broker 会在连接断开后立即清除所有会话信息.
     * clearStart=false =&gt; Broker 会在连接断开后保存会话信息，并在重新连接后复用会话信息.
     * &lt;a href="https://github.com/hivemq/hivemq-mqtt-client/issues/627"&gt;...&lt;/a&gt;
     */
    // @formatter:on
    private boolean clearStart = false;

    private int receiveMaximum = 10000;

    private int sendMaximum = 10000;

    private int maximumPacketSize = 10000;

    private int sendMaximumPacketSize = 10000;

    private int topicAliasMaximum = 1024;

    private int sendTopicAliasMaximum = 2048;

    private long messageExpiryInterval = 86400L;

    private boolean requestProblemInformation = true;

    private boolean requestResponseInformation = true;

    // @formatter:off
    /**
     * 默认会话保留一天.
     * 最大值，4294967295L，会话过期时间【永不过期，单位秒】.
     * 定义客户端断开后会话保留的时间（仅在 Clean Session = false 时生效）.
     */
    private long sessionExpiryInterval = 86400L;
    // @formatter:on

    /**
     * 心跳包每隔60秒发一次.
     */
    private int keepAliveInterval = 60;

    private boolean automaticReconnect = true;

    private long automaticReconnectMaxDelay = 5;

    private long automaticReconnectInitialDelay = 1;

    private Set&lt;String&gt; topics = new HashSet&lt;&gt;(0);

    private int nettyThreads = 32;

    private boolean retain = false;

    private boolean noLocal = false;

}
</code></pre>
<p>HivemqClientV5</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@Slf4j
public class HivemqClientV5 {

    /**
     * 响应主题.
     */
    private final String RESPONSE_TOPIC = "response/topic";

    /**
     * 服务下线数据.
     */
    private final byte[] WILL_PAYLOAD = "offline".getBytes(UTF_8);

    /**
     * 相关数据.
     */
    private final byte[] CORRELATION_DATA = "correlationData".getBytes(UTF_8);

    private final HivemqProperties hivemqProperties;

    private final List&lt;MessageHandler&gt; messageHandlers;

    private volatile Mqtt5RxClient client;

    private final Object lock = new Object();

    private volatile Disposable connectDisposable;

    private volatile Disposable subscribeDisposable;

    private volatile Disposable unSubscribeDisposable;

    private volatile Disposable publishDisposable;

    private volatile Disposable disconnectDisposable;

    private volatile Disposable consumeDisposable;

    public HivemqClientV5(HivemqProperties hivemqProperties, List&lt;MessageHandler&gt; messageHandlers) {
        this.hivemqProperties = hivemqProperties;
        this.messageHandlers = messageHandlers;
    }

    public void open() {
        if (Objects.isNull(client)) {
            synchronized (lock) {
                if (Objects.isNull(client)) {
                    client = getMqtt5ClientBuilder().buildRx();
                }
            }
        }
        connect();
        consume();
    }

    public void close() {
        if (!Objects.isNull(client)) {
            disconnectDisposable = client.disconnectWith()
                    .sessionExpiryInterval(hivemqProperties.getSessionExpiryInterval())
                    .applyDisconnect()
                    .subscribeOn(Schedulers.io())
                    .retryWhen(errors -&gt; errors.scan(1, (retryCount, error) -&gt; retryCount &gt; 5 ? -1 : retryCount + 1)
                            .takeWhile(retryCount -&gt; retryCount != -1)
                            .flatMap(retryCount -&gt; Flowable.timer((long) Math.pow(2, retryCount) * 100, TimeUnit.MILLISECONDS)))
                    .subscribe(() -&gt; log.info("【Hivemq-V5】 =&gt; MQTT断开连接成功，客户端ID：{}", hivemqProperties.getClientId()),
                            e -&gt; log.error("【Hivemq-V5】 =&gt; MQTT断开连接失败，错误信息：{}", e.getMessage(), e));
        }
    }

    public void subscribe() {
        String[] topics = getTopics();
        subscribe(topics, getQosArray(topics));
    }

    public String[] getTopics() {
        return hivemqProperties.getTopics().toArray(String[]::new);
    }

    public int[] getQosArray(String[] topics) {
        return Stream.of(topics).mapToInt(item -&gt; hivemqProperties.getSubscribeQos()).toArray();
    }

    public void subscribe(String[] topics, int[] qosArray) {
        checkTopicAndQos(topics, qosArray);
        if (!Objects.isNull(client)) {
            List&lt;Mqtt5Subscription&gt; subscriptions = new ArrayList&lt;&gt;(topics.length);
            for (int i = 0; i &lt; topics.length; i++) {
                subscriptions.add(Mqtt5Subscription.builder()
                        .topicFilter(topics[i])
                        .qos(getMqttQos(qosArray[i]))
                        .retainAsPublished(hivemqProperties.isRetain())
                        .noLocal(hivemqProperties.isNoLocal())
                        .build());
            }
            subscribeDisposable = client.subscribeWith()
                    .addSubscriptions(subscriptions)
                    .applySubscribe()
                    .subscribeOn(Schedulers.io())
                    .retryWhen(errors -&gt; errors.scan(1, (retryCount, error) -&gt; retryCount &gt; 5 ? -1 : retryCount + 1)
                            .takeWhile(retryCount -&gt; retryCount != -1)
                            .flatMap(retryCount -&gt; Flowable.timer((long) Math.pow(2, retryCount) * 100, TimeUnit.MILLISECONDS)))
                    .subscribe(ack -&gt; log.info("【Hivemq-V5】 =&gt; MQTT订阅成功，主题: {}", String.join("、", topics)), e -&gt; log
                            .error("【Hivemq-V5】 =&gt; MQTT订阅失败，主题：{}，错误信息：{}", String.join("、", topics), e.getMessage(), e));
        }
    }

    public void unSubscribe() {
        String[] topics = hivemqProperties.getTopics().toArray(String[]::new);
        unSubscribe(topics);
    }

    public void unSubscribe(String[] topics) {
        checkTopic(topics);
        if (!Objects.isNull(client)) {
            List&lt;MqttTopicFilter&gt; matchedTopics = new ArrayList&lt;&gt;(topics.length);
            for (String topic : topics) {
                matchedTopics.add(MqttTopicFilter.of(topic));
            }
            unSubscribeDisposable = client.unsubscribeWith()
                    .addTopicFilters(matchedTopics)
                    .applyUnsubscribe()
                    .subscribeOn(Schedulers.io())
                    .retryWhen(errors -&gt; errors.scan(1, (retryCount, error) -&gt; retryCount &gt; 5 ? -1 : retryCount + 1)
                            .takeWhile(retryCount -&gt; retryCount != -1)
                            .flatMap(retryCount -&gt; Flowable.timer((long) Math.pow(2, retryCount) * 100, TimeUnit.MILLISECONDS)))
                    .subscribe(ack -&gt; log.info("【Hivemq-V5】 =&gt; MQTT取消订阅成功，主题：{}", String.join("、", topics)), e -&gt; log
                            .error("【Hivemq-V5】 =&gt; MQTT取消订阅失败，主题：{}，错误信息：{}", String.join("、", topics), e.getMessage(), e));
        }
    }

    public void publish(String topic, byte[] payload, int qos) {
        if (!Objects.isNull(client)) {
            publishDisposable = client
                    .publish(Flowable.just(Mqtt5Publish.builder()
                            .topic(topic)
                            .qos(getMqttQos(qos))
                            .payload(payload)
                            .noMessageExpiry()
                            .retain(hivemqProperties.isRetain())
                            .messageExpiryInterval(hivemqProperties.getMessageExpiryInterval())
                            .correlationData(CORRELATION_DATA)
                            .payloadFormatIndicator(Mqtt5PayloadFormatIndicator.UTF_8)
                            .contentType("text/plain")
                            .responseTopic(RESPONSE_TOPIC)
                            .build()))
                    .subscribeOn(Schedulers.io())
                    .retryWhen(errors -&gt; errors.scan(1, (retryCount, error) -&gt; retryCount &gt; 5 ? -1 : retryCount + 1)
                            .takeWhile(retryCount -&gt; retryCount != -1)
                            .flatMap(retryCount -&gt; Flowable.timer((long) Math.pow(2, retryCount) * 100, TimeUnit.MILLISECONDS)))
                    .subscribe(ack -&gt; log.info("【Hivemq-V5】 =&gt; MQTT消息发布成功，topic：{}", topic),
                            e -&gt; log.error("【Hivemq-V5】 =&gt; MQTT消息发布失败，topic：{}，错误信息：{}", topic, e.getMessage(), e));
        }
    }

    public void publish(String topic, byte[] payload) {
        publish(topic, payload, hivemqProperties.getPublishQos());
    }

    public void dispose(Disposable disposable) {
        if (!Objects.isNull(disposable) &amp;&amp; !disposable.isDisposed()) {
            // 显式取消订阅
            disposable.dispose();
        }
    }

    public void dispose() {
        dispose(connectDisposable);
        dispose(subscribeDisposable);
        dispose(unSubscribeDisposable);
        dispose(publishDisposable);
        dispose(consumeDisposable);
        dispose(disconnectDisposable);
    }

    public void reSubscribe() {
        log.info("【Hivemq-V5】 =&gt; MQTT重新订阅开始");
        dispose(subscribeDisposable);
        subscribe();
        log.info("【Hivemq-V5】 =&gt; MQTT重新订阅结束");
    }

    private MqttQos getMqttQos(int qos) {
        return MqttQos.fromCode(qos);
    }

    private void connect() {
        connectDisposable = client.connectWith()
                .keepAlive(hivemqProperties.getKeepAliveInterval())
                .cleanStart(hivemqProperties.isClearStart())
                .sessionExpiryInterval(hivemqProperties.getSessionExpiryInterval())
                .willPublish()
                .topic("will/topic")
                .payload(WILL_PAYLOAD)
                .qos(getMqttQos(hivemqProperties.getWillQos()))
                .retain(true)
                .messageExpiryInterval(100)
                .delayInterval(10)
                .payloadFormatIndicator(Mqtt5PayloadFormatIndicator.UTF_8)
                .contentType("text/plain")
                .responseTopic(RESPONSE_TOPIC)
                .correlationData(CORRELATION_DATA)
                .applyWillPublish()
                .restrictions()
                .receiveMaximum(hivemqProperties.getReceiveMaximum())
                .sendMaximum(hivemqProperties.getSendMaximum())
                .maximumPacketSize(hivemqProperties.getMaximumPacketSize())
                .sendMaximumPacketSize(hivemqProperties.getSendMaximumPacketSize())
                .topicAliasMaximum(hivemqProperties.getTopicAliasMaximum())
                .sendTopicAliasMaximum(hivemqProperties.getSendTopicAliasMaximum())
                .requestProblemInformation(hivemqProperties.isRequestProblemInformation())
                .requestResponseInformation(hivemqProperties.isRequestResponseInformation())
                .applyRestrictions()
                .applyConnect()
                .toFlowable()
                .firstElement()
                .subscribeOn(Schedulers.io())
                .retryWhen(errors -&gt; errors.scan(1, (retryCount, error) -&gt; retryCount &gt; 5 ? -1 : retryCount + 1)
                        .takeWhile(retryCount -&gt; retryCount != -1)
                        .flatMap(retryCount -&gt; Flowable.timer((long) Math.pow(2, retryCount) * 100, TimeUnit.MILLISECONDS)))
                .subscribe(
                        ack -&gt; log.info("【Hivemq-V5】 =&gt; MQTT连接成功，主机：{}，端口：{}，客户端ID：{}", hivemqProperties.getHost(),
                                hivemqProperties.getPort(), hivemqProperties.getClientId()),
                        e -&gt; log.error("【Hivemq-V5】 =&gt; MQTT连接失败，错误信息：{}", e.getMessage(), e));
    }

    private void consume() {
        if (!Objects.isNull(client)) {
            consumeDisposable = client.publishes(MqttGlobalPublishFilter.ALL)
                    .onBackpressureBuffer(8192)
                    .observeOn(Schedulers.computation(), false, 8192)
                    .doOnSubscribe(subscribe -&gt; {
                        log.info("【Hivemq-V5】 =&gt; MQTT开始订阅消息，请稍候。。。。。。");
                        reSubscribe();
                    })
                    .subscribeOn(Schedulers.io())
                    .retryWhen(errors -&gt; errors.scan(1, (retryCount, error) -&gt; retryCount &gt; 5 ? -1 : retryCount + 1)
                            .takeWhile(retryCount -&gt; retryCount != -1)
                            .flatMap(retryCount -&gt; Flowable.timer((long) Math.pow(2, retryCount) * 100, TimeUnit.MILLISECONDS)))
                    .subscribe(publish -&gt; {
                                for (MessageHandler messageHandler : messageHandlers) {
                                    if (messageHandler.isSubscribe(publish.getTopic().toString())) {
                                        log.info("【Hivemq-V5】 =&gt; MQTT接收到消息，Topic：{}", publish.getTopic());
                                        messageHandler
                                                .handle(new MqttMessage(publish.getPayloadAsBytes(), publish.getTopic().toString()));
                                    }
                                }
                            }, e -&gt; log.error("【Hivemq-V5】 =&gt; MQTT消息处理失败，错误信息：{}", e.getMessage(), e),
                            () -&gt; log.info("【Hivemq-V5】 =&gt; MQTT订阅消息结束，请稍候。。。。。。"));
        }
    }

    private Mqtt5ClientBuilder getMqtt5ClientBuilder() {
        Mqtt5ClientBuilder builder = Mqtt5Client.builder().addConnectedListener(listener -&gt; {
                    Optional&lt;? extends MqttClientConnectionConfig&gt; config = Optional
                            .of(listener.getClientConfig().getConnectionConfig())
                            .get();
                    config.ifPresent(mqttClientConnectionConfig -&gt; log.info("【Hivemq-V5】 =&gt; MQTT连接保持时间：{}ms",
                            mqttClientConnectionConfig.getKeepAlive()));
                    log.info("【Hivemq-V5】 =&gt; MQTT已连接，客户端ID：{}", hivemqProperties.getClientId());
                })
                .addDisconnectedListener(
                        listener -&gt; log.error("【Hivemq-V5】 =&gt; MQTT已断开连接，客户端ID：{}", hivemqProperties.getClientId()))
                .identifier(hivemqProperties.getClientId())
                .serverHost(hivemqProperties.getHost())
                .serverPort(hivemqProperties.getPort())
                .executorConfig(MqttClientExecutorConfig.builder()
                        .nettyExecutor(ThreadUtils.newVirtualTaskExecutor())
                        .nettyThreads(hivemqProperties.getNettyThreads())
                        .applicationScheduler(Schedulers.from(ThreadUtils.newVirtualTaskExecutor()))
                        .build());
        // 开启重连
        if (hivemqProperties.isAutomaticReconnect()) {
            builder.automaticReconnect()
                    .initialDelay(hivemqProperties.getAutomaticReconnectInitialDelay(), TimeUnit.SECONDS)
                    .maxDelay(hivemqProperties.getAutomaticReconnectMaxDelay(), TimeUnit.SECONDS)
                    .applyAutomaticReconnect();
        }
        if (hivemqProperties.isAuth()) {
            builder.simpleAuth()
                    .username(hivemqProperties.getUsername())
                    .password(hivemqProperties.getPassword().getBytes())
                    .applySimpleAuth();
        }
        return builder;
    }

    private void checkTopicAndQos(String[] topics, int[] qosArray) {
        if (topics == null || qosArray == null) {
            throw new IllegalArgumentException("【" + "Hivemq-V5" + "】 =&gt; Topics and QoS arrays cannot be null");
        }
        if (topics.length != qosArray.length) {
            throw new IllegalArgumentException("【" + "Hivemq-V5" + "】 =&gt; Topics and QoS arrays must have the same length");
        }
        if (topics.length == 0) {
            throw new IllegalArgumentException("【" + "Hivemq-V5" + "】 =&gt; Topics array cannot be empty");
        }
    }

    private void checkTopic(String[] topics) {
        if (topics.length == 0) {
            throw new IllegalArgumentException("【" + "Hivemq-V5" + "】 =&gt; Topics array cannot be empty");
        }
    }

}
</code></pre>
<p>HivemqV5MqttClientTest</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@SpringBootTest
@RequiredArgsConstructor
@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)
class HivemqV5MqttClientTest {

    private final List&lt;MessageHandler&gt; messageHandlers;

    @Test
    void testMqttClient() throws InterruptedException {
        HivemqProperties hivemqProperties = new HivemqProperties();
        hivemqProperties.setClientId("test-client-1");
        hivemqProperties.setTopics(Set.of("/test-topic-1/#"));
        HivemqClientV5 hivemqClientV5 = new HivemqClientV5(hivemqProperties, messageHandlers);
        hivemqClientV5.open();
        hivemqClientV5.publish("/test-topic-1/123", "Hello World123".getBytes());
    }

}
</code></pre>
<p>HivemqClientV3</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@Slf4j
public class HivemqClientV3 {

    /**
     * 服务下线数据.
     */
    private final byte[] WILL_PAYLOAD = "offline".getBytes(UTF_8);

    private final HivemqProperties hivemqProperties;

    private final List&lt;MessageHandler&gt; messageHandlers;

    private volatile Mqtt3RxClient client;

    private final Object lock = new Object();

    private volatile Disposable connectDisposable;

    private volatile Disposable subscribeDisposable;

    private volatile Disposable unSubscribeDisposable;

    private volatile Disposable publishDisposable;

    private volatile Disposable disconnectDisposable;

    private volatile Disposable consumeDisposable;

    public HivemqClientV3(HivemqProperties hivemqProperties, List&lt;MessageHandler&gt; messageHandlers) {
        this.hivemqProperties = hivemqProperties;
        this.messageHandlers = messageHandlers;
    }

    public void open() {
        if (Objects.isNull(client)) {
            synchronized (lock) {
                if (Objects.isNull(client)) {
                    client = getMqtt3ClientBuilder().buildRx();
                }
            }
        }
        connect();
        consume();
    }

    public void close() {
        if (!Objects.isNull(client)) {
            disconnectDisposable = client.disconnect()
                    .subscribeOn(Schedulers.io())
                    .retryWhen(errors -&gt; errors.scan(1, (retryCount, error) -&gt; retryCount &gt; 5 ? -1 : retryCount + 1)
                            .takeWhile(retryCount -&gt; retryCount != -1)
                            .flatMap(retryCount -&gt; Flowable.timer((long) Math.pow(2, retryCount) * 100, TimeUnit.MILLISECONDS)))
                    .subscribe(() -&gt; log.info("【Hivemq-V3】 =&gt; MQTT断开连接成功，客户端ID：{}", hivemqProperties.getClientId()),
                            e -&gt; log.error("【Hivemq-V3】 =&gt; MQTT断开连接失败，错误信息：{}", e.getMessage(), e));
        }
    }

    public void subscribe() {
        String[] topics = getTopics();
        subscribe(topics, getQosArray(topics));
    }

    public String[] getTopics() {
        return hivemqProperties.getTopics().toArray(String[]::new);
    }

    public int[] getQosArray(String[] topics) {
        return Stream.of(topics).mapToInt(item -&gt; hivemqProperties.getSubscribeQos()).toArray();
    }

    public void subscribe(String[] topics, int[] qosArray) {
        checkTopicAndQos(topics, qosArray);
        if (!Objects.isNull(client)) {
            List&lt;Mqtt3Subscription&gt; subscriptions = new ArrayList&lt;&gt;(topics.length);
            for (int i = 0; i &lt; topics.length; i++) {
                subscriptions.add(Mqtt3Subscription.builder()
                        .topicFilter(topics[i])
                        .qos(getMqttQos(qosArray[i]))
                        .build());
            }
            subscribeDisposable = client.subscribeWith()
                    .addSubscriptions(subscriptions)
                    .applySubscribe()
                    .subscribeOn(Schedulers.io())
                    .retryWhen(errors -&gt; errors.scan(1, (retryCount, error) -&gt; retryCount &gt; 5 ? -1 : retryCount + 1)
                            .takeWhile(retryCount -&gt; retryCount != -1)
                            .flatMap(retryCount -&gt; Flowable.timer((long) Math.pow(2, retryCount) * 100, TimeUnit.MILLISECONDS)))
                    .subscribe(ack -&gt; log.info("【Hivemq-V3】 =&gt; MQTT订阅成功，主题: {}", String.join("、", topics)), e -&gt; log
                            .error("【Hivemq-V3】 =&gt; MQTT订阅失败，主题：{}，错误信息：{}", String.join("、", topics), e.getMessage(), e));
        }
    }

    public void unSubscribe() {
        String[] topics = hivemqProperties.getTopics().toArray(String[]::new);
        unSubscribe(topics);
    }

    public void unSubscribe(String[] topics) {
        checkTopic(topics);
        if (!Objects.isNull(client)) {
            List&lt;MqttTopicFilter&gt; matchedTopics = new ArrayList&lt;&gt;(topics.length);
            for (String topic : topics) {
                matchedTopics.add(MqttTopicFilter.of(topic));
            }
            unSubscribeDisposable = client.unsubscribeWith()
                    .addTopicFilters(matchedTopics)
                    .applyUnsubscribe()
                    .subscribeOn(Schedulers.io())
                    .retryWhen(errors -&gt; errors.scan(1, (retryCount, error) -&gt; retryCount &gt; 5 ? -1 : retryCount + 1)
                            .takeWhile(retryCount -&gt; retryCount != -1)
                            .flatMap(retryCount -&gt; Flowable.timer((long) Math.pow(2, retryCount) * 100, TimeUnit.MILLISECONDS)))
                    .subscribe(() -&gt; log.info("【Hivemq-V3】 =&gt; MQTT取消订阅成功，主题：{}", String.join("、", topics)), e -&gt; log
                            .error("【Hivemq-V3】 =&gt; MQTT取消订阅失败，主题：{}，错误信息：{}", String.join("、", topics), e.getMessage(), e));
        }
    }

    public void publish(String topic, byte[] payload, int qos) {
        if (!Objects.isNull(client)) {
            publishDisposable = client
                    .publish(Flowable.just(Mqtt3Publish.builder()
                            .topic(topic)
                            .qos(getMqttQos(qos))
                            .payload(payload)
                            .retain(hivemqProperties.isRetain())
                            .build()))
                    .subscribeOn(Schedulers.io())
                    .retryWhen(errors -&gt; errors.scan(1, (retryCount, error) -&gt; retryCount &gt; 5 ? -1 : retryCount + 1)
                            .takeWhile(retryCount -&gt; retryCount != -1)
                            .flatMap(retryCount -&gt; Flowable.timer((long) Math.pow(2, retryCount) * 100, TimeUnit.MILLISECONDS)))
                    .subscribe(ack -&gt; log.info("【Hivemq-V3】 =&gt; MQTT消息发布成功，topic：{}", topic),
                            e -&gt; log.error("【Hivemq-V3】 =&gt; MQTT消息发布失败，topic：{}，错误信息：{}", topic, e.getMessage(), e));
        }
    }

    public void publish(String topic, byte[] payload) {
        publish(topic, payload, hivemqProperties.getPublishQos());
    }

    public void dispose(Disposable disposable) {
        if (!Objects.isNull(disposable) &amp;&amp; !disposable.isDisposed()) {
            // 显式取消订阅
            disposable.dispose();
        }
    }

    public void dispose() {
        dispose(connectDisposable);
        dispose(subscribeDisposable);
        dispose(unSubscribeDisposable);
        dispose(publishDisposable);
        dispose(consumeDisposable);
        dispose(disconnectDisposable);
    }

    public void reSubscribe() {
        log.info("【Hivemq-V3】 =&gt; MQTT重新订阅开始");
        dispose(subscribeDisposable);
        subscribe();
        log.info("【Hivemq-V3】 =&gt; MQTT重新订阅结束");
    }

    private MqttQos getMqttQos(int qos) {
        return MqttQos.fromCode(qos);
    }

    private void connect() {
        connectDisposable = client.connectWith()
                .keepAlive(hivemqProperties.getKeepAliveInterval())
                .willPublish()
                .topic("will/topic")
                .payload(WILL_PAYLOAD)
                .qos(getMqttQos(hivemqProperties.getWillQos()))
                .retain(true)
                .applyWillPublish()
                .restrictions()
                .sendMaximum(hivemqProperties.getSendMaximum())
                .sendMaximumPacketSize(hivemqProperties.getSendMaximumPacketSize())
                .applyRestrictions()
                .applyConnect()
                .toFlowable()
                .firstElement()
                .subscribeOn(Schedulers.io())
                .retryWhen(errors -&gt; errors.scan(1, (retryCount, error) -&gt; retryCount &gt; 5 ? -1 : retryCount + 1)
                        .takeWhile(retryCount -&gt; retryCount != -1)
                        .flatMap(retryCount -&gt; Flowable.timer((long) Math.pow(2, retryCount) * 100, TimeUnit.MILLISECONDS)))
                .subscribe(
                        ack -&gt; log.info("【Hivemq-V3】 =&gt; MQTT连接成功，主机：{}，端口：{}，客户端ID：{}", hivemqProperties.getHost(),
                                hivemqProperties.getPort(), hivemqProperties.getClientId()),
                        e -&gt; log.error("【Hivemq-V3】 =&gt; MQTT连接失败，错误信息：{}", e.getMessage(), e));
    }

    private void consume() {
        if (!Objects.isNull(client)) {
            consumeDisposable = client.publishes(MqttGlobalPublishFilter.ALL)
                    .onBackpressureBuffer(8192)
                    .observeOn(Schedulers.computation(), false, 8192)
                    .doOnSubscribe(subscribe -&gt; {
                        log.info("【Hivemq-V3】 =&gt; MQTT开始订阅消息，请稍候。。。。。。");
                        reSubscribe();
                    })
                    .subscribeOn(Schedulers.io())
                    .retryWhen(errors -&gt; errors.scan(1, (retryCount, error) -&gt; retryCount &gt; 5 ? -1 : retryCount + 1)
                            .takeWhile(retryCount -&gt; retryCount != -1)
                            .flatMap(retryCount -&gt; Flowable.timer((long) Math.pow(2, retryCount) * 100, TimeUnit.MILLISECONDS)))
                    .subscribe(publish -&gt; {
                                for (MessageHandler messageHandler : messageHandlers) {
                                    if (messageHandler.isSubscribe(publish.getTopic().toString())) {
                                        log.info("【Hivemq-V3】 =&gt; MQTT接收到消息，Topic：{}", publish.getTopic());
                                        messageHandler
                                                .handle(new MqttMessage(publish.getPayloadAsBytes(), publish.getTopic().toString()));
                                    }
                                }
                            }, e -&gt; log.error("【Hivemq-V3】 =&gt; MQTT消息处理失败，错误信息：{}", e.getMessage(), e),
                            () -&gt; log.info("【Hivemq-V3】 =&gt; MQTT订阅消息结束，请稍候。。。。。。"));
        }
    }

    private Mqtt3ClientBuilder getMqtt3ClientBuilder() {
        Mqtt3ClientBuilder builder = Mqtt3Client.builder().addConnectedListener(listener -&gt; {
                    Optional&lt;? extends MqttClientConnectionConfig&gt; config = Optional
                            .of(listener.getClientConfig().getConnectionConfig())
                            .get();
                    config.ifPresent(mqttClientConnectionConfig -&gt; log.info("【Hivemq-V5】 =&gt; MQTT连接保持时间：{}ms",
                            mqttClientConnectionConfig.getKeepAlive()));
                    log.info("【Hivemq-V3】 =&gt; MQTT已连接，客户端ID：{}", hivemqProperties.getClientId());
                })
                .addDisconnectedListener(
                        listener -&gt; log.error("【Hivemq-V3】 =&gt; MQTT已断开连接，客户端ID：{}", hivemqProperties.getClientId()))
                .identifier(hivemqProperties.getClientId())
                .serverHost(hivemqProperties.getHost())
                .serverPort(hivemqProperties.getPort())
                .executorConfig(MqttClientExecutorConfig.builder()
                        .nettyExecutor(ThreadUtils.newVirtualTaskExecutor())
                        .nettyThreads(hivemqProperties.getNettyThreads())
                        .applicationScheduler(Schedulers.from(ThreadUtils.newVirtualTaskExecutor()))
                        .build());
        // 开启重连
        if (hivemqProperties.isAutomaticReconnect()) {
            builder.automaticReconnect()
                    .initialDelay(hivemqProperties.getAutomaticReconnectInitialDelay(), TimeUnit.SECONDS)
                    .maxDelay(hivemqProperties.getAutomaticReconnectMaxDelay(), TimeUnit.SECONDS)
                    .applyAutomaticReconnect();
        }
        if (hivemqProperties.isAuth()) {
            builder.simpleAuth()
                    .username(hivemqProperties.getUsername())
                    .password(hivemqProperties.getPassword().getBytes())
                    .applySimpleAuth();
        }
        return builder;
    }

    private void checkTopicAndQos(String[] topics, int[] qosArray) {
        if (topics == null || qosArray == null) {
            throw new IllegalArgumentException("【" + "Hivemq-V3" + "】 =&gt; Topics and QoS arrays cannot be null");
        }
        if (topics.length != qosArray.length) {
            throw new IllegalArgumentException("【" + "Hivemq-V3" + "】 =&gt; Topics and QoS arrays must have the same length");
        }
        if (topics.length == 0) {
            throw new IllegalArgumentException("【" + "Hivemq-V3" + "】 =&gt; Topics array cannot be empty");
        }
    }

    private void checkTopic(String[] topics) {
        if (topics.length == 0) {
            throw new IllegalArgumentException("【" + "Hivemq-V3" + "】 =&gt; Topics array cannot be empty");
        }
    }

}
</code></pre>
<p>HivemqV3MqttClientTest</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@SpringBootTest
@RequiredArgsConstructor
@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)
class HivemqV3MqttClientTest {

    private final List&lt;MessageHandler&gt; messageHandlers;

    @Test
    void testMqttClient() throws InterruptedException {
        HivemqProperties hivemqProperties2 = new HivemqProperties();
        hivemqProperties2.setClientId("test-client-2");
        hivemqProperties2.setTopics(Set.of("/test-topic-2/#"));
        HivemqClientV3 hivemqClientV3 = new HivemqClientV3(hivemqProperties2, messageHandlers);
        hivemqClientV3.open();
        hivemqClientV3.publish("/test-topic-2/456", "Hello World456".getBytes());
    }

}
</code></pre>
<h3 id="vertx-mqtt-client推荐只兼容mqtt311">Vert.x MQTT Client【推荐，只兼容mqtt3.1.1】</h3>
<p><a href="https://vertx-china.github.io/docs/vertx-mqtt/java/#_vert_x_mqtt_client" target="_blank" rel="noopener nofollow"># Vert.x MQTT文档</a></p>
<h6 id="引入依赖-2">引入依赖</h6>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.vertx&lt;/groupId&gt;
      &lt;artifactId&gt;vertx-mqtt&lt;/artifactId&gt;
      &lt;version&gt;4.5.14&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
      &lt;artifactId&gt;reactor-core&lt;/artifactId&gt;
      &lt;version&gt;3.7.5&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h6 id="项目集成-2">项目集成</h6>
<p>MqttClientProperties</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@Data
public class MqttClientProperties {

    private boolean auth = true;

    private String username = "emqx";

    private String password = "laokou123";

    private String host = "127.0.0.1";

    private int port = 1883;

    private String clientId = UUIDGenerator.generateUUID();

    // @formatter:off
    /**
     * 控制是否创建新会话（true=新建，false=复用历史会话）. clearStart=true =&gt; Broker 会在连接断开后立即清除所有会话信息.
     * clearStart=false =&gt; Broker 会在连接断开后保存会话信息，并在重新连接后复用会话信息.
     */
    // @formatter:on
    private boolean clearSession = false;

    private int receiveBufferSize = Integer.MAX_VALUE;

    private int maxMessageSize = -1;

    /**
     * 心跳包每隔60秒发一次.
     */
    private int keepAliveInterval = 60;

    private boolean autoKeepAlive = true;

    private long reconnectInterval = 1000;

    private int reconnectAttempts = Integer.MAX_VALUE;

    private Map&lt;String, Integer&gt; topics = new HashMap&lt;&gt;(0);

    private int willQos = 1;

    private boolean willRetain = false;

    private int ackTimeout = -1;

    private boolean autoAck = true;

    /**
     * 服务下线主题.
     */
    private String willTopic = "/will";

    /**
     * 服务下线数据.
     */
    private String willPayload = "offline";

}
</code></pre>
<p>VertxConfig</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@Configuration
public class VertxConfig {

    @Bean
    public Vertx vertx() {
       VertxOptions vertxOptions = new VertxOptions();
       vertxOptions.setMaxEventLoopExecuteTime(60);
       vertxOptions.setMaxWorkerExecuteTime(60);
       vertxOptions.setMaxEventLoopExecuteTimeUnit(TimeUnit.SECONDS);
       vertxOptions.setMaxWorkerExecuteTimeUnit(TimeUnit.SECONDS);
       vertxOptions.setPreferNativeTransport(true);
       return Vertx.vertx(vertxOptions);
    }

}
</code></pre>
<p>VertxMqttClient</p>
<p>注意：vertx-mqtt不支持客户端自动断线重连，网络不通畅或连接关闭，需要自己手动调用连接！！！实现这个重连的功能</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@Slf4j
public class VertxMqttClient {

    private final Sinks.Many&lt;MqttPublishMessage&gt; messageSink = Sinks.many()
       .multicast()
       .onBackpressureBuffer(Integer.MAX_VALUE, false);

    private final MqttClient mqttClient;

    private final Vertx vertx;

    private final MqttClientProperties mqttClientProperties;

    private final List&lt;MessageHandler&gt; messageHandlers;

    private final List&lt;Disposable&gt; disposables;

    private final AtomicBoolean isConnected = new AtomicBoolean(false);

    private final AtomicBoolean isLoaded = new AtomicBoolean(false);

    private final AtomicBoolean isReconnected = new AtomicBoolean(true);

    public VertxMqttClient(final Vertx vertx, final MqttClientProperties mqttClientProperties,
          final List&lt;MessageHandler&gt; messageHandlers) {
       this.vertx = vertx;
       this.mqttClientProperties = mqttClientProperties;
       this.mqttClient = MqttClient.create(vertx, getOptions());
       this.messageHandlers = messageHandlers;
       this.disposables = Collections.synchronizedList(new ArrayList&lt;&gt;());
    }

    public void open() {
       mqttClient.closeHandler(v -&gt; {
          isConnected.set(false);
          log.error("【Vertx-MQTT】 =&gt; MQTT连接断开，客户端ID：{}", mqttClientProperties.getClientId());
          reconnect();
       })
          .publishHandler(messageSink::tryEmitNext)
          // 仅接收QoS1和QoS2的消息
          .publishCompletionHandler(id -&gt; {
             // log.info("【Vertx-MQTT】 =&gt; 接收MQTT的PUBACK或PUBCOMP数据包，数据包ID：{}", id);
          })
          .subscribeCompletionHandler(ack -&gt; {
             // log.info("【Vertx-MQTT】 =&gt; 接收MQTT的SUBACK数据包，数据包ID：{}", ack.messageId());
          })
          .unsubscribeCompletionHandler(id -&gt; {
             // log.info("【Vertx-MQTT】 =&gt; 接收MQTT的UNSUBACK数据包，数据包ID：{}", id);
          })
          .pingResponseHandler(s -&gt; {
             // log.info("【Vertx-MQTT】 =&gt; 接收MQTT的PINGRESP数据包");
          })
          .connect(mqttClientProperties.getPort(), mqttClientProperties.getHost(), connectResult -&gt; {
             if (connectResult.succeeded()) {
                isConnected.set(true);
                log.info("【Vertx-MQTT】 =&gt; MQTT连接成功，主机：{}，端口：{}，客户端ID：{}", mqttClientProperties.getHost(),
                      mqttClientProperties.getPort(), mqttClientProperties.getClientId());
                resubscribe();
             }
             else {
                isConnected.set(false);
                Throwable ex = connectResult.cause();
                log.error("【Vertx-MQTT】 =&gt; MQTT连接失败，原因：{}，客户端ID：{}", ex.getMessage(),
                      mqttClientProperties.getClientId(), ex);
                reconnect();
             }
          });
    }

    public void close() {
       disconnect();
    }

    /**
     * Sends the PUBLISH message to the remote MQTT server.
     * @param topic topic on which the message is published
     * @param payload message payload
     * @param qos QoS level
     * @param isDup if the message is a duplicate
     * @param isRetain if the message needs to be retained
     */
    public void publish(String topic, int qos, String payload, boolean isDup, boolean isRetain) {
       mqttClient.publish(topic, Buffer.buffer(payload), convertQos(qos), isDup, isRetain);
    }

    private void reconnect() {
       if (isReconnected.get()) {
          log.info("【Vertx-MQTT】 =&gt; MQTT尝试重连");
          vertx.setTimer(mqttClientProperties.getReconnectInterval(),
                handler -&gt; ThreadUtils.newVirtualTaskExecutor().execute(this::open));
       }
    }

    private void subscribe() {
       Map&lt;String, Integer&gt; topics = mqttClientProperties.getTopics();
       checkTopicAndQos(topics);
       mqttClient.subscribe(topics, subscribeResult -&gt; {
          if (subscribeResult.succeeded()) {
             log.info("【Vertx-MQTT】 =&gt; MQTT订阅成功，主题: {}", String.join("、", topics.keySet()));
          }
          else {
             Throwable ex = subscribeResult.cause();
             log.error("【Vertx-MQTT】 =&gt; MQTT订阅失败，主题：{}，错误信息：{}", String.join("、", topics.keySet()), ex.getMessage(),
                   ex);
          }
       });
    }

    private void resubscribe() {
       if (isConnected.get() || mqttClient.isConnected()) {
          ThreadUtils.newVirtualTaskExecutor().execute(this::subscribe);
       }
       if (isLoaded.compareAndSet(false, true)) {
          ThreadUtils.newVirtualTaskExecutor().execute(this::consume);
       }
    }

    private void consume() {
       Disposable disposable = messageSink.asFlux().doOnNext(mqttPublishMessage -&gt; {
          String topic = mqttPublishMessage.topicName();
          log.info("【Vertx-MQTT】 =&gt; MQTT接收到消息，Topic：{}", topic);
          for (MessageHandler messageHandler : messageHandlers) {
             if (messageHandler.isSubscribe(topic)) {
                messageHandler.handle(new MqttMessage(mqttPublishMessage.payload(), topic));
             }
          }
       }).subscribeOn(Schedulers.boundedElastic()).subscribe();
       disposables.add(disposable);
    }

    private void disposable() {
       for (Disposable disposable : disposables) {
          if (ObjectUtils.isNotNull(disposable) &amp;&amp; !disposable.isDisposed()) {
             disposable.dispose();
          }
       }
    }

    private void disconnect() {
       isReconnected.set(false);
       mqttClient.disconnect(disconnectResult -&gt; {
          if (disconnectResult.succeeded()) {
             disposable();
             log.info("【Vertx-MQTT】 =&gt; MQTT断开连接成功");
             disposables.clear();
          }
          else {
             Throwable ex = disconnectResult.cause();
             log.error("【Vertx-MQTT】 =&gt; MQTT断开连接失败，错误信息：{}", ex.getMessage(), ex);
          }
       });
    }

    private void unsubscribe(List&lt;String&gt; topics) {
       checkTopic(topics);
       mqttClient.unsubscribe(topics, unsubscribeResult -&gt; {
          if (unsubscribeResult.succeeded()) {
             log.info("【Vertx-MQTT】 =&gt; MQTT取消订阅成功，主题：{}", String.join("、", topics));
          }
          else {
             Throwable ex = unsubscribeResult.cause();
             log.error("【Vertx-MQTT】 =&gt; MQTT取消订阅失败，主题：{}，错误信息：{}", String.join("、", topics), ex.getMessage(), ex);
          }
       });
    }

    private MqttClientOptions getOptions() {
       MqttClientOptions options = new MqttClientOptions();
       options.setClientId(mqttClientProperties.getClientId());
       options.setCleanSession(mqttClientProperties.isClearSession());
       options.setAutoKeepAlive(mqttClientProperties.isAutoKeepAlive());
       options.setKeepAliveInterval(mqttClientProperties.getKeepAliveInterval());
       options.setReconnectAttempts(mqttClientProperties.getReconnectAttempts());
       options.setReconnectInterval(mqttClientProperties.getReconnectInterval());
       options.setWillQoS(mqttClientProperties.getWillQos());
       options.setWillTopic(mqttClientProperties.getWillTopic());
       options.setAutoAck(mqttClientProperties.isAutoAck());
       options.setAckTimeout(mqttClientProperties.getAckTimeout());
       options.setWillRetain(mqttClientProperties.isWillRetain());
       options.setWillMessageBytes(Buffer.buffer(mqttClientProperties.getWillPayload()));
       options.setReceiveBufferSize(mqttClientProperties.getReceiveBufferSize());
       options.setMaxMessageSize(mqttClientProperties.getMaxMessageSize());
       if (mqttClientProperties.isAuth()) {
          options.setPassword(mqttClientProperties.getPassword());
          options.setUsername(mqttClientProperties.getUsername());
       }
       return options;
    }

    private void checkTopicAndQos(Map&lt;String, Integer&gt; topics) {
       topics.forEach((topic, qos) -&gt; {
          if (StringUtils.isEmpty(topic) || ObjectUtils.isNull(qos)) {
             throw new IllegalArgumentException("【Vertx-MQTT】 =&gt; Topic and QoS cannot be null");
          }
       });
    }

    private void checkTopic(List&lt;String&gt; topics) {
       if (CollectionUtils.isEmpty(topics)) {
          throw new IllegalArgumentException("【Vertx-MQTT】 =&gt; Topics list cannot be empty");
       }
    }

    private MqttQoS convertQos(int qos) {
       return MqttQoS.valueOf(qos);
    }

}
</code></pre>
<p>VertxMqttClientTest</p>
<pre><code class="language-java">/**
 * @author laokou
 */
@SpringBootTest
@RequiredArgsConstructor
@ContextConfiguration(classes = { DefaultMessageHandler.class, VertxConfig.class })
@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)
class VertxMqttClientTest {

    private final List&lt;MessageHandler&gt; messageHandlers;

    private final Vertx vertx;

    @Test
    void testMqttClient() throws InterruptedException {
       MqttClientProperties properties = new MqttClientProperties();
       properties.setHost("127.0.0.1");
       properties.setPort(1883);
       properties.setUsername("emqx");
       properties.setPassword("laokou123");
       properties.setClientId("test-client-1");
       properties.setTopics(Map.of("/test-topic-1/#", 1));
       VertxMqttClient vertxMqttClient = new VertxMqttClient(vertx, properties, messageHandlers);
       Assertions.assertDoesNotThrow(vertxMqttClient::open);
       Thread.sleep(500);
       Assertions.assertDoesNotThrow(() -&gt; vertxMqttClient.publish("/test-topic-1/test", 1, "test", false, false));
       Thread.sleep(500);
       Assertions.assertDoesNotThrow(vertxMqttClient::close);
       Thread.sleep(500);
    }

}
</code></pre>
<p><a href="https://github.com/KouShenhai/KCloud-Platform-IoT/tree/master/laokou-common/laokou-common-network/laokou-common-network-mqtt-client" target="_blank" rel="noopener nofollow">详细代码请点击</a></p>
<p>非常推荐使用vertx-mqtt，项目平稳运行好用！！！</p>
<p>但是，需要时注意的是，项目部署到Linux系统，需要最少分配 -Xmx2100m  -Xms2100m 内存，不然连接会关闭！</p>
<p>我是老寇，我们下次再见啦~</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4017347632627315" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-10 16:41">2025-05-10 16:40</span>&nbsp;
<a href="https://www.cnblogs.com/koushenhai">k↑</a>&nbsp;
阅读(<span id="post_view_count">20</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18869746);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18869746', targetLink: 'https://www.cnblogs.com/koushenhai/p/18869746', title: '物联网之对接MQTT最佳实践' })">举报</a>
</div>
        