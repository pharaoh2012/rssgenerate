
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/MelonTe/p/18779892" title="发布于 2025-03-18 21:53">
    <span role="heading" aria-level="2">golang单机锁实现</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1锁的概念引入">1、锁的概念引入</h1>
<p>首先，为什么需要锁？</p>
<p>在并发编程中，多个线程或进程可能<strong>同时访问和修改同一个共享资源</strong>（例如变量、数据结构、文件）等，若不引入合适的同步机制，会引发以下问题：</p>
<ul>
<li><strong>数据竞争</strong>：多个线程同时修改一个资源，最终的结果跟线程的执行顺序有关，结果是不可预测的。</li>
<li><strong>数据不一致</strong>：一个线程在修改资源，而另一个线程读取了未修改完的数据，从而导致读取了错误的数据。</li>
<li><strong>资源竞争</strong>：多线程竞争同一个资源，浪费系统的性能。</li>
</ul>
<p>因此，我们需要一把锁，来保证同一时间只有一个人能写数据，确保共享资源在并发访问下的正确性和一致性。</p>
<p>在这里，引入两种常见的并发控制处理机制，即<strong>乐观锁</strong>与<strong>悲观锁</strong>：</p>
<ul>
<li>乐观锁：假定在并发操作中，资源的抢占并不是很激烈，数据被修改的可能性不是很大，那这时候就不需要对共享资源区进行加锁再操作，而是<strong>先修改了数据，最终来判断数据有没有被修改</strong>，没有被修改则提交修改指，否则重试。</li>
<li>悲观锁：与乐观锁相反，它假设场景的资源竞争激烈，对共享资源区的访问必须要求持有锁。</li>
</ul>
<p>针对不同的场景需要采取因地制宜的策略，比较乐观锁与悲观所，它们的优缺点显而易见：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>乐观锁</td>
<td>不需要实际上锁，性能高</td>
<td>若冲突时，需要重新进行操作，多次重试可能会导致性能下降明显</td>
</tr>
<tr>
<td>悲观锁</td>
<td>访问数据一定需要持有锁，保证并发场景下的数据正确性</td>
<td>加锁期间，其他等待锁的线程需要被阻塞，性能低</td>
</tr>
</tbody>
</table>
<h1 id="2syncmutex">2、Sync.Mutex</h1>
<p>Go对单机锁的实现，考虑了实际环境中协程对资源竞争程度的变化，制定了一套<strong>锁升级</strong>的过程。具体方案如下：</p>
<ul>
<li>首先采取乐观的态度，Goroutine会保持<strong>自旋态</strong>，通过<strong>CAS</strong>操作尝试获取锁。</li>
<li>当多次获取失败，将会由乐观态度转入悲观态度，判定当前并发资源竞争程度剧烈，进入阻塞态等待被唤醒。</li>
</ul>
<p>从<strong>乐观转向悲观</strong>的判定规则如下，满足其中之一即发生转变：</p>
<ul>
<li>Goroutine自旋尝试<strong>次数超过4次</strong></li>
<li>当前P的执行队列中存在等待被执行的G（避免自旋影响GMP调度性能）</li>
<li>CPU是单核的（其他Goroutine执行不了，自旋无意义）</li>
</ul>
<p>除此之外，为了防止被阻塞的协程等待过长时间也没有获取到锁，导致用户的整体体验下降，引入了<strong>饥饿</strong>的概念：</p>
<ul>
<li><strong>饥饿态</strong>：若Goroutine被阻塞等待的时间&gt;1ms，则这个协程被视为处于饥饿状态</li>
<li><strong>饥饿模式</strong>：表示当前锁是否处于特定的模式，在该模式下，锁的交接是<strong>公平</strong>的，按顺序交给等待最久的协程。</li>
</ul>
<p>饥饿模式与正常模式的<strong>转变规则</strong>如下：</p>
<ul>
<li>
<p>普通模式-&gt;饥饿模式：存在阻塞的协程，<strong>阻塞时间超过1ms</strong></p>
</li>
<li>
<p>饥饿模式-&gt;普通模式：阻塞队列清空，亦或者获得锁的协程的等待时间小于1ms，则恢复</p>
</li>
</ul>
<p>接下来步入源码，观看具体的实现。</p>
<h2 id="21数据结构">2.1、数据结构</h2>
<p>位于包<code>sync/mutex.go</code>中，对锁的定义如下：</p>
<pre><code class="language-go">type Mutex struct {
	state int32
	sema  uint32
}
</code></pre>
<ul>
<li><code>state</code>：标识目前锁的状态信息，包括了是否处于饥饿模式、是否存在唤醒的阻塞协程、是否上锁、以及处于等待锁的协程个数有多少。</li>
<li><code>seme</code>：用于阻塞和唤醒协程的信号量。</li>
</ul>
<p>将<code>state</code>看作一个二进制字符串，它存储信息的规则如下：</p>
<ul>
<li>第一位标识是否处于上锁，0表示否，1表示上锁（mutexLocked）</li>
<li>第二位标识是否存在唤醒的阻塞协程（mutexWoken）</li>
<li>第三位标识是否处于饥饿模式（mutexStarving）</li>
<li>从第四位开始，记录了处于阻塞态的协程个数</li>
</ul>
<pre><code class="language-go">const (
	mutexLocked = 1 &lt;&lt; iota // mutex is locked
	mutexWoken
	mutexStarving
	mutexWaiterShift = iota
	starvationThresholdNs = 1e6 //饥饿阈值
)
</code></pre>
<h2 id="22获取锁lock">2.2、获取锁Lock()</h2>
<pre><code class="language-go">func (m *Mutex) Lock() {
	if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
		return
	}
	m.lockSlow()
}
</code></pre>
<p>尝试直接通过<strong>CAS</strong>操作直接获取锁，若成功则返回，否则说明锁被获取，步入<code>LockSlow</code>。</p>
<h2 id="23lockslow">2.3、LockSlow()</h2>
<p>源码较长，进行拆分讲解：</p>
<pre><code class="language-go">var waitStartTime int64
	starving := false
	awoke := false
	iter := 0
	old := m.state
</code></pre>
<p>（1）定义了基本的常量，含义如下：</p>
<ul>
<li><code>waitStartTime</code>：记录当前协程等待的时间，只有被阻塞才会使用</li>
<li><code>awoke</code>：标识当前协程是否被Unlock唤醒</li>
<li><code>iter</code>：记录当前协程自旋尝试次数</li>
<li><code>old</code>：记录旧的锁的状态信息</li>
</ul>
<hr>
<pre><code class="language-go">for {
    	//处于上锁状态，并且不处于饥饿状态中，并且当前的协程允许继续自旋下去
		if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {
 
			if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
				awoke = true
			}
			runtime_doSpin()
			iter++
			old = m.state
			continue
		}
		//...
	}
</code></pre>
<p>（2）进入尝试获取锁的循环中，两个if表示：</p>
<ul>
<li>若锁<strong>处于上锁状态</strong>，并且不<strong>处于饥饿状态中</strong>，并且当前的协程<strong>允许继续自旋下去</strong>（非单核CPU、自旋次数&lt;=4、调度器P的本地队列不存在等待执行的G），则步入：
<ul>
<li>若当前协程<strong>并非从等待队列唤醒</strong>、并且<strong>不存在被唤醒的等待协程</strong>、并且<strong>存在位于阻塞的协程</strong>、则尝试<strong>设置mutexWoken标识为1</strong>，若成功：
<ul>
<li>标识当前的协程为被唤醒的协程。（虽然并非实际从阻塞中唤醒）</li>
</ul>
</li>
<li>告诉P，当前的协程处于自旋态</li>
<li>更新<code>iter</code>计数器，与<code>old</code>记录的当前锁的状态信息，进行下一次重试循环</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里存在的唯一疑惑为，为什么要将awoke标识为true？</p>
<p>首先，因为当前锁并<strong>非处于饥饿模式</strong>，因此当前的抢占锁的模式是<strong>不公平的</strong>，若当前锁的阻塞队列还没有被唤醒的协程，那就要求<strong>不要唤醒了</strong>，尝试让当前正在尝试的协程获取到锁，避免唤醒协程进行资源竞争。</p>
</blockquote>
<hr>
<pre><code class="language-go">for {
    	//...
    	new := old
		if old&amp;mutexStarving == 0 {
			new |= mutexLocked
		}
		if old&amp;(mutexLocked|mutexStarving) != 0 {
			new += 1 &lt;&lt; mutexWaiterShift
		}
		if starving &amp;&amp; old&amp;mutexLocked != 0 {
			new |= mutexStarving
		}
		if awoke {
			new &amp;^= mutexWoken
		}
		//...
}		
</code></pre>
<p>（3）进行状态更新：</p>
<p>当协程从步骤2走出来时，只能说明它位于以下两个状态之一：</p>
<ul>
<li>旋不动了，或者锁进入饥饿模式了，锁要让给别人了，总之是<strong>获取不到锁了</strong>（悲观）。</li>
<li>锁被释放了。</li>
</ul>
<p>不论如何，都需要进行一些状态的更新，为接下来的打算做准备。</p>
<p>用new存储一个锁即将要进入的新状态信息，更新规则：</p>
<ul>
<li>若锁不处于饥饿模式：说明锁可能被释放了，也可能是自旋次数过多，不管接下来是否能拿到锁，<strong>锁都会被某一个协程获取</strong>，因此置<code>mutexLocked</code>为1。</li>
<li>若锁可能处于饥饿状态，或者锁没有被释放：那说明自己是抢不到锁了，<strong>即将进入阻塞态</strong>，阻塞协程计数器+1。</li>
<li>若当前的协程是被唤醒的，并且已经处在饥饿态中而且锁仍然锁着：<strong>锁进入绝对公平的饥饿模式</strong>。</li>
<li>若当前协程是被唤醒的：清除<code>mutexWoken</code>标识位，因为接下来<strong>可能需要有协程被唤醒</strong>（饥饿模式）。</li>
</ul>
<p>虽然更新的有点多，但是可以<strong>归纳为</strong>：</p>
<ul>
<li>若锁释放了，那就标识一下接下来锁要被获取即可。</li>
<li>若锁没有释放，并给当前协程等待了很久，那锁就进入饥饿状态，接下来需要有阻塞协程被唤醒。</li>
</ul>
<hr>
<p>（4）尝试更新信息：</p>
<pre><code class="language-go">if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
			//...
		} else {
			old = m.state
		}
</code></pre>
<p>接下来尝试将new更新进state，若更新失败，说明当前有另一个协程介入了，为了防止数据的一致性丢失，要全部重来一次。</p>
<p>（5）状态更新成功，<strong>具体判断是要沉睡还是获取锁成功</strong>：</p>
<p>步入步骤4的if主支中，此时有两个状态：</p>
<pre><code class="language-go">if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
			if old&amp;(mutexLocked|mutexStarving) == 0 {
				break // locked the mutex with CAS
			}
    //...
		} else {
			//...
		}
</code></pre>
<p>因为当前状态，可能是锁释放了，检查锁更新前是否已经被释放了并且不是饥饿模式，若是那<strong>说明获取锁成功了</strong>，函数结束了。</p>
<pre><code class="language-go">if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
			if old&amp;(mutexLocked|mutexStarving) == 0 {
				break // locked the mutex with CAS
			}
			// If we were already waiting before, queue at the front of the queue.
			queueLifo := waitStartTime != 0
			if waitStartTime == 0 {
				waitStartTime = runtime_nanotime()
			}
			runtime_SemacquireMutex(&amp;m.sema, queueLifo, 2)
    //....
		} else {
			//...
		}
</code></pre>
<p>否则，说明当前协程要进入阻塞态了，记录一下开始阻塞的时间，用于醒来是判断是否饥饿。然后进入阻塞沉睡中。</p>
<p>（6）若步骤5进入阻塞，则被唤醒后：</p>
<pre><code class="language-go">if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
			if old&amp;(mutexLocked|mutexStarving) == 0 {
				break // locked the mutex with CAS
			}
			// If we were already waiting before, queue at the front of the queue.
			queueLifo := waitStartTime != 0
			if waitStartTime == 0 {
				waitStartTime = runtime_nanotime()
			}
			runtime_SemacquireMutex(&amp;m.sema, queueLifo, 2)
    			//唤醒
    		  starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
			old = m.state
    //若锁处于饥饿模式
			if old&amp;mutexStarving != 0 {
                //锁的异常处理
				if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {
					throw("sync: inconsistent mutex state")
				}
                //将要更新的信号量
				delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)
				if !starving || old&gt;&gt;mutexWaiterShift == 1 {
					delta -= mutexStarving
				}
				atomic.AddInt32(&amp;m.state, delta)
				break
			}
			awoke = true
			iter = 0
    
    //....
		} else {
			//...
		}
</code></pre>
<p>从阻塞中唤醒，首先计算一些协程的阻塞时间，以及当前的最新锁状态。</p>
<p>若<strong>锁处于饥饿模式</strong>：那么当前协程将直接获取锁，当前协程是因为饥饿模式被唤醒的，不存在其他协程抢占锁。于是更新信号量，将记录阻塞协程数-1，将锁的上锁态置1。若当前从饥饿模式唤醒的协程，<strong>等待时间已经不到1ms了或者是最后一个等待的协程</strong>，那么将将锁从饥饿模式转化为正常模式。至此，获取成功，退出函数。</p>
<p>否则，只是普通的随机唤醒，于是开始尝试进行抢占，回到步骤1。</p>
<h2 id="24释放锁unlock">2.4、释放锁Unlock()</h2>
<pre><code class="language-go">func (m *Mutex) Unlock() {
    //直接释放锁
	new := atomic.AddInt32(&amp;m.state, -mutexLocked)
	if new != 0 {
		m.unlockSlow(new)
	}
}
</code></pre>
<p>通过原子操作，直接将锁的<code>mutexLocked</code>标识置为0。若置0后，锁的状态不为0，那就说明存在需要获取锁的协程，步入<code>unlockSlow</code>。</p>
<h2 id="25unlockslow">2.5、unlockSlow()</h2>
<pre><code class="language-go">func (m *Mutex) unlockSlow(new int32) {
	if (new+mutexLocked)&amp;mutexLocked == 0 {
		fatal("sync: unlock of unlocked mutex")
	}
	if new&amp;mutexStarving == 0 {
		old := new
		for {
			if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
				return
			}
			new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
			if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
				runtime_Semrelease(&amp;m.sema, false, 2)
				return
			}
			old = m.state
		}
	} else {
		runtime_Semrelease(&amp;m.sema, true, 2)
	}
}
</code></pre>
<p>（1）首先进行了异常状态处理，若释放了一个已经释放了到锁，那么直接fatal，程序终止。</p>
<pre><code class="language-go">if (new+mutexLocked)&amp;mutexLocked == 0 {
		fatal("sync: unlock of unlocked mutex")
	}
</code></pre>
<p>（2）若锁不处于饥饿状态：</p>
<ul>
<li>若此时的等待协程数量为0，或者锁被上锁了、含有被唤醒的协程、锁处于饥饿模式：都说明有新的协程介入了流程，已经完成了交接，可以直接退出</li>
<li>唤醒一个处于阻塞态的协程。</li>
</ul>
<p>否则，处于饥饿状态，唤醒等待最久的协程。</p>
<h1 id="3syncrwmutex">3、Sync.RWMutex</h1>
<p>对于共享资源区的操作，可以划分为读与写两大类。假设在一个场景中，对共享资源区继续<strong>读的操作远大于写的操作</strong>，如果每个协程的读操作都需要获取互斥锁，这带来的性能损耗是非常大的。</p>
<p><code>RWMutex</code>是一个可以运用在读操作&gt;写操作中的提高性能的锁，可以将它视为由一个读锁与一个写锁构成。其运作规则具体如下：</p>
<ul>
<li>读锁允许多个读协程同时读取共享资源区，若有协程需要修改资源区的数据，那么它需要被阻塞。</li>
<li>写锁具有严格的排他性，当共享资源区被上了写锁时，<strong>任何其他goroutine都不得访问</strong>。</li>
</ul>
<p>可见在最坏的情况下，所有的协程都是需要写操作时，读写锁会退化成普通的Mutex。</p>
<h2 id="31数据结构">3.1、数据结构</h2>
<pre><code class="language-go">type RWMutex struct {
	w           Mutex        // held if there are pending writers
	writerSem   uint32       // semaphore for writers to wait for completing readers
	readerSem   uint32       // semaphore for readers to wait for completing writers
	readerCount atomic.Int32 // number of pending readers
	readerWait  atomic.Int32 // number of departing readers
}
const rwmutexMaxReaders = 1 &lt;&lt; 30 //最大的读协程数量
</code></pre>
<ul>
<li><code>w</code>：一个互斥的写锁</li>
<li><code>writerSem</code>：关联被阻塞的写协程的信号量</li>
<li><code>readerSem</code>：关联被阻塞的读协程的信号量</li>
<li><code>readerCount</code>：正常情况下，记录正在读取的协程数量；<strong>但若当前是写协程正在持有锁，那么实际记录读协程的数量为</strong><code>readerCount - rwmutexMaxReader</code></li>
<li><code>readerWait</code>：记录释放下一个写协程，还需要等待读协程完成的数量</li>
</ul>
<h2 id="32读锁流程rlock">3.2、读锁流程RLock()</h2>
<pre><code class="language-go">func (rw *RWMutex) RLock() {
	if rw.readerCount.Add(1) &lt; 0 {
		// A writer is pending, wait for it.
		runtime_SemacquireRWMutexR(&amp;rw.readerSem, false, 0)
	}
}
</code></pre>
<p>对<code>readerCount</code>+1，表示新加入一个读协程。若结果&lt;0，说明当前锁正在被写协程占据，令当前的读协程阻塞。</p>
<h2 id="33读释放锁流程runlock">3.3、读释放锁流程RUnlock()</h2>
<pre><code class="language-go">func (rw *RWMutex) RUnlock() {
	if r := rw.readerCount.Add(-1); r &lt; 0 {
		// Outlined slow-path to allow the fast-path to be inlined
		rw.rUnlockSlow(r)
	}
}
</code></pre>
<p>对<code>readerCount</code>-1，表示减少一个读协程。若结果&lt;0，说明当前锁正在被写协程占据，步入runlockslow。</p>
<h2 id="34runlockslow">3.4、rUnlockSlow()</h2>
<pre><code class="language-go">func (rw *RWMutex) rUnlockSlow(r int32) {
	if r+1 == 0 || r+1 == -rwmutexMaxReaders {
		race.Enable()
		fatal("sync: RUnlock of unlocked RWMutex")
	}
	if rw.readerWait.Add(-1) == 0 {
		// The last reader unblocks the writer.
		runtime_Semrelease(&amp;rw.writerSem, false, 1)
	}
}
</code></pre>
<p>首先进行错误处理，若发现当前协程为占用过读锁，或者读流程的协程数量上限，系统出现异常，fatal。</p>
<p>否则，对<code>readerWait</code>-1，若结果为0，说明当前协程是最后一个介入读锁流程的协程，此时需要释放一个写锁。</p>
<h2 id="35写锁流程lock">3.5、写锁流程Lock()</h2>
<pre><code class="language-go">func (rw *RWMutex) Lock() {
	// First, resolve competition with other writers.
	rw.w.Lock()
	// Announce to readers there is a pending writer.
	r := rw.readerCount.Add(-rwmutexMaxReaders) + rwmutexMaxReaders
	// Wait for active readers.
	if r != 0 &amp;&amp; rw.readerWait.Add(r) != 0 {
		runtime_SemacquireRWMutex(&amp;rw.writerSem, false, 0)
	}
}
</code></pre>
<p>首先尝试获取写锁，若获取成功，需要将<code>readerCount</code>-最大读协程数，表示现在锁被读协程占据。</p>
<p>r表示处于读流程的协程数量，若r不为0，那么就将<code>readerWait</code>加上r，等这些读协程都读取完毕，再去写。将这个写协程阻塞。（<strong>读写锁并非读、写公平，读协程优先。</strong>）</p>
<h2 id="36写释放锁流程unlock">3.6、写释放锁流程Unlock()</h2>
<pre><code class="language-go">func (rw *RWMutex) Unlock() {
	// Announce to readers there is no active writer.
	r := rw.readerCount.Add(rwmutexMaxReaders)
	if r &gt;= rwmutexMaxReaders {
		race.Enable()
		fatal("sync: Unlock of unlocked RWMutex")
	}
	// Unblock blocked readers, if any.
	for i := 0; i &lt; int(r); i++ {
		runtime_Semrelease(&amp;rw.readerSem, false, 0)
	}
	// Allow other writers to proceed.
	rw.w.Unlock()
}
</code></pre>
<p>重新将<code>readerCount</code>置为正常指，表示释放了写锁。若读协程超过最大上限，则异常。</p>
<p>然后唤醒所有阻塞的读协程。（<strong>读协程优先</strong>）</p>
<p>解锁。</p>
<h1 id="4参考学习文章">4、参考学习文章：</h1>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzkxMjQzMjA0OQ==&amp;mid=2247483797&amp;idx=1&amp;sn=34274d44bced0835ea302376a137219b" target="_blank" rel="noopener nofollow">mp.weixin.qq.com/s?__biz=MzkxMjQzMjA0OQ==&amp;mid=2247483797&amp;idx=1&amp;sn=34274d44bced0835ea302376a137219b</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5558016696458333" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-18 21:53">2025-03-18 21:53</span>&nbsp;
<a href="https://www.cnblogs.com/MelonTe">MelonTe</a>&nbsp;
阅读(<span id="post_view_count">28</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18779892" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18779892);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18779892', targetLink: 'https://www.cnblogs.com/MelonTe/p/18779892', title: 'golang单机锁实现' })">举报</a>
</div>
        