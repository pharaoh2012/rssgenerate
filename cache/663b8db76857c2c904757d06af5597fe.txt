
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18680990" title="发布于 2025-01-20 11:13">
    <span role="heading" aria-level="2">千万级的大表，如何做性能调优？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>大表优化是一个老生常谈的话题，但随着业务规模的增长，总有人会“中招”。</p>
<p>很多小伙伴的数据库在刚开始的时候表现良好，查询也很流畅，但一旦表中的数据量上了千万级，性能问题就开始浮现，查询慢、写入卡、分页拖沓、甚至偶尔直接宕机。这</p>
<p>时大家可能会想，是不是数据库不行？是不是需要升级到更强的硬件？</p>
<p>其实很多情况下，根本问题在于<strong>没做好优化</strong>。</p>
<p>今天，我们就从<strong>问题本质</strong>讲起，逐步分析大表常见的性能瓶颈，以及如何一步步优化。</p>
<p>我最近开源了一个基于 SpringBoot+Vue+uniapp 的商城项目，里面的技术亮点挺多的，欢迎访问和star。[<a href="https://gitee.com/dvsusan/susan_mall" target="_blank" rel="noopener nofollow">https://gitee.com/dvsusan/susan_mall</a>]</p>
<h2 id="一为什么大表会慢">一、为什么大表会慢？</h2>
<p>在搞优化之前，先搞清楚大表性能问题的根本原因。数据量大了，为什么数据库就慢了？</p>
<h3 id="1-磁盘io瓶颈">1. <strong>磁盘IO瓶颈</strong></h3>
<p>大表的数据是存储在磁盘上的，数据库的查询通常会涉及到数据块的读取。</p>
<p>当数据量很大时，单次查询可能需要从多个磁盘块中读取大量数据，磁盘的读写速度会直接限制查询性能。</p>
<h4 id="举例">举例：</h4>
<p>假设有一张订单表<code>orders</code>，里面存了5000万条数据，你想要查询某个用户的最近10条订单：</p>
<pre><code class="language-sql">SELECT * FROM orders WHERE user_id = 123 ORDER BY order_time DESC LIMIT 10;
</code></pre>
<p>如果没有索引，数据库会扫描整个表的所有数据，再进行排序，性能肯定会拉胯。</p>
<h3 id="2-索引失效或没有索引">2. <strong>索引失效或没有索引</strong></h3>
<p>如果表的查询没有命中索引，数据库会进行<strong>全表扫描</strong>（Full Table Scan），也就是把表里的所有数据逐行读一遍。</p>
<p>这种操作在千万级别的数据下非常消耗资源，性能会急剧下降。</p>
<h4 id="举例-1">举例：</h4>
<p>比如你在查询时写了这样的条件：</p>
<pre><code class="language-sql">SELECT * FROM orders WHERE DATE(order_time) = '2023-01-01';
</code></pre>
<p>这里用了<code>DATE()</code>函数，数据库需要对所有记录的<code>order_time</code>字段进行计算，导致索引失效。</p>
<h3 id="3-分页性能下降">3. <strong>分页性能下降</strong></h3>
<p>分页查询是大表中很常见的场景，但深度分页（比如第100页之后）会导致性能问题。</p>
<p>即使你只需要10条数据，但数据库仍然需要先扫描出前面所有的记录。</p>
<h4 id="举例-2">举例：</h4>
<p>查询第1000页的10条数据：</p>
<pre><code class="language-sql">SELECT * FROM orders ORDER BY order_time DESC LIMIT 9990, 10;
</code></pre>
<p>这条SQL实际上是让数据库先取出前9990条数据，然后丢掉，再返回后面的10条。</p>
<p>随着页码的增加，查询的性能会越来越差。</p>
<h3 id="4-锁争用">4. <strong>锁争用</strong></h3>
<p>在高并发场景下，多个线程同时对同一张表进行增删改查操作，会导致行锁或表锁的争用，进而影响性能。</p>
<h2 id="二性能优化的总体思路">二、性能优化的总体思路</h2>
<p>性能优化的本质是<strong>减少不必要的IO、计算和锁竞争</strong>，目标是让数据库尽量少做“无用功”。</p>
<p>优化的总体思路可以总结为以下几点：</p>
<ol>
<li><strong>表结构设计要合理</strong>：尽量避免不必要的字段，数据能拆分则拆分。</li>
<li><strong>索引要高效</strong>：设计合理的索引结构，避免索引失效。</li>
<li><strong>SQL要优化</strong>：查询条件精准，尽量减少全表扫描。</li>
<li><strong>分库分表</strong>：通过水平拆分、垂直拆分减少单表数据量。</li>
<li><strong>缓存和异步化</strong>：减少对数据库的直接压力。</li>
</ol>
<p>接下来，我们逐一展开。</p>
<h2 id="三表结构设计优化">三、表结构设计优化</h2>
<p>表结构是数据库性能优化的基础，设计不合理的表结构会导致后续的查询和存储性能问题。</p>
<h3 id="1-精简字段类型">1. 精简字段类型</h3>
<p><strong>字段的类型决定了存储的大小和查询的性能。</strong></p>
<ul>
<li>能用<code>INT</code>的不要用<code>BIGINT</code>。</li>
<li>能用<code>VARCHAR(100)</code>的不要用<code>TEXT</code>。</li>
<li>时间字段建议用<code>TIMESTAMP</code>或<code>DATETIME</code>，不要用<code>CHAR</code>或<code>VARCHAR</code>来存时间。</li>
</ul>
<h4 id="举例-3">举例：</h4>
<pre><code class="language-sql">-- 不推荐
CREATE TABLE orders (
    id BIGINT,
    user_id BIGINT,
    order_status VARCHAR(255),
    remarks TEXT
);

-- 优化后
CREATE TABLE orders (
    id BIGINT,
    user_id INT UNSIGNED,
    order_status TINYINT, -- 状态用枚举表示
    remarks VARCHAR(500) -- 限制最大长度
);
</code></pre>
<p>这样可以节省存储空间，查询时也更高效。</p>
<h3 id="2-表拆分垂直拆分与水平拆分">2. 表拆分：垂直拆分与水平拆分</h3>
<h4 id="垂直拆分"><strong>垂直拆分</strong></h4>
<p>当表中字段过多，某些字段并不是经常查询的，可以将表按照业务逻辑拆分为多个小表。</p>
<p><strong>示例</strong>：<br>
将订单表分为两个表：<code>orders_basic</code> 和 <code>orders_details</code>。</p>
<pre><code class="language-sql">-- 基本信息表
CREATE TABLE orders_basic (
    id BIGINT PRIMARY KEY,
    user_id INT UNSIGNED,
    order_time TIMESTAMP
);

-- 详情表
CREATE TABLE orders_details (
    id BIGINT PRIMARY KEY,
    remarks VARCHAR(500),
    shipping_address VARCHAR(255)
);
</code></pre>
<h4 id="水平拆分"><strong>水平拆分</strong></h4>
<p>当单表的数据量过大时，可以按一定规则拆分到多张表中。</p>
<p><strong>示例</strong>：<br>
假设我们按用户ID对订单表进行水平拆分：</p>
<pre><code class="language-sql">orders_0 -- 存user_id % 2 = 0的订单
orders_1 -- 存user_id % 2 = 1的订单
</code></pre>
<p>拆分后每张表的数据量大幅减少，查询性能会显著提升。</p>
<h2 id="四索引优化">四、索引优化</h2>
<p>索引是数据库性能优化的“第一杀器”，但很多人对索引的使用并不熟悉，导致性能不升反降。</p>
<h3 id="1-创建合适的索引">1. 创建合适的索引</h3>
<p>为高频查询的字段创建索引，比如主键、外键、查询条件字段。</p>
<h4 id="示例">示例：</h4>
<pre><code class="language-sql">CREATE INDEX idx_user_id_order_time ON orders (user_id, order_time DESC);
</code></pre>
<p>上面的复合索引可以同时加速<code>user_id</code>和<code>order_time</code>的查询。</p>
<h3 id="2-避免索引失效">2. 避免索引失效</h3>
<ul>
<li>
<p><strong>别对索引字段使用函数或运算</strong>。<br>
错误：</p>
<pre><code class="language-sql">SELECT * FROM orders WHERE DATE(order_time) = '2023-01-01';
</code></pre>
<p>优化：</p>
<pre><code class="language-sql">SELECT * FROM orders WHERE order_time &gt;= '2023-01-01 00:00:00'
  AND order_time &lt; '2023-01-02 00:00:00';
</code></pre>
</li>
<li>
<p><strong>注意隐式类型转换</strong>。<br>
错误：</p>
<pre><code class="language-sql">SELECT * FROM orders WHERE user_id = '123';
</code></pre>
<p>优化：</p>
<pre><code class="language-sql">SELECT * FROM orders WHERE user_id = 123;
</code></pre>
</li>
</ul>
<h2 id="五sql优化">五、SQL优化</h2>
<h3 id="1-减少查询字段">1. 减少查询字段</h3>
<p>只查询需要的字段，避免<code>SELECT *</code>。</p>
<pre><code class="language-sql">-- 错误
SELECT * FROM orders WHERE user_id = 123;

-- 优化
SELECT id, order_time FROM orders WHERE user_id = 123;
</code></pre>
<h3 id="2-分页优化">2. 分页优化</h3>
<p>深度分页时，使用“延迟游标”的方式避免扫描过多数据。</p>
<pre><code class="language-sql">-- 深分页（性能较差）
SELECT * FROM orders ORDER BY order_time DESC LIMIT 9990, 10;

-- 优化：使用游标
SELECT * FROM orders WHERE order_time &lt; '2023-01-01 12:00:00'
  ORDER BY order_time DESC LIMIT 10;
</code></pre>
<h2 id="六分库分表">六、分库分表</h2>
<h3 id="1-水平分库分表">1. 水平分库分表</h3>
<p>当单表拆分后仍无法满足性能需求，可以通过分库分表将数据分散到多个数据库中。</p>
<h4 id="常见的分库分表规则">常见的分库分表规则：</h4>
<ul>
<li>按用户ID取模。</li>
<li>按时间分区。</li>
</ul>
<h2 id="七缓存与异步化">七、缓存与异步化</h2>
<h3 id="1-使用redis缓存热点数据">1. 使用Redis缓存热点数据</h3>
<p>对高频查询的数据可以存储到Redis中，减少对数据库的直接访问。</p>
<h4 id="示例-1">示例：</h4>
<pre><code class="language-java">// 从缓存读取数据
String result = redis.get("orders:user:123");
if (result == null) {
    result = database.query("SELECT * FROM orders WHERE user_id = 123");
    redis.set("orders:user:123", result, 3600); // 设置缓存1小时
}
</code></pre>
<h3 id="2-使用消息队列异步处理写操作">2. 使用消息队列异步处理写操作</h3>
<p>高并发写入时，可以将写操作放入消息队列（如Kafka），然后异步批量写入数据库，减轻数据库压力。</p>
<h2 id="八实战案例">八、实战案例</h2>
<h4 id="问题">问题：</h4>
<p>某电商系统的订单表存储了5000万条记录，用户查询订单详情时，页面加载时间超过10秒。</p>
<h4 id="解决方案">解决方案：</h4>
<ol>
<li><strong>垂直拆分订单表</strong>：将订单详情字段拆分到另一个表中。</li>
<li><strong>创建复合索引</strong>：为<code>user_id</code>和<code>order_time</code>创建索引。</li>
<li><strong>使用Redis缓存</strong>：将最近30天的订单缓存到Redis中。</li>
<li><strong>分页优化</strong>：使用<code>search_after</code>代替<code>LIMIT</code>深分页。</li>
</ol>
<h2 id="九总结">九、总结</h2>
<p>大表性能优化是一个系统性工程，需要从表结构、索引、SQL到架构设计全方位考虑。</p>
<p>千万级别的数据量看似庞大，但通过合理的拆分、索引设计和缓存策略，可以让数据库轻松应对。</p>
<p>最重要的是，<strong>根据业务特点选择合适的优化策略，切勿盲目追求“高大上”的方案</strong>。</p>
<p>希望这些经验能帮到你！</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.90733927240625" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-20 11:14">2025-01-20 11:13</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">940</span>)&nbsp;
评论(<span id="post_comment_count">4</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18680990" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18680990);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18680990', targetLink: 'https://www.cnblogs.com/12lisu/p/18680990', title: '千万级的大表，如何做性能调优？' })">举报</a>
</div>
        