
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/smileZAZ/p/18686431" title="发布于 2025-01-22 16:58">
    <span role="heading" aria-level="2">记录---当window.open被ios安全机制拦截，我掏出3种方案，终于跳转成功！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1 data-id="heading-0">🧑‍💻 写在开头</h1>
<p>点赞 + 收藏 === 学会🤣🤣🤣</p>
<div>
<div>
<h2 data-id="heading-0">一、前言</h2>
<p>今天在开发H5的时候，遇到了一个bug，就是在ios环境，在某些情况下执行<code>window.open</code>不生效，所以正好趁此机会研究了一下<code>window.open</code>。</p>
<h2 data-id="heading-1">二、window.open介绍</h2>
<p>从<code>open</code>方法的调用方式可以看出，<code>open</code>方法是定义在<code>Window</code>接口上，正因为如此它有三个参数：</p>
</div>
<div class="cnblogs_Highlighter">
<pre class="brush:bash;gutter:true;">window.open(url, target, windowFeatures)</pre>
</div>
<ol>
<li>url：「可选参数」，表示你要加载的资源URL或路径，如果不传，则打开一个<code>url</code>地址为<code>about:blank</code>的空白页。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/2149129/202501/2149129-20250122165553655-859772090.png" alt="" loading="lazy"></p>
<div>
<div>
<p>顺便介绍一下，<code>about:blank</code>是<code>chrome浏览器</code>的一个命令，该指令会打开浏览器的一个内建空白页面，而不是从网络上下载，类似的命令还有<code>about:downloads</code>、<code>about:extensions</code>、<code>about:history</code>等等，具体<code>chrom浏览器</code>提供了哪些命令，你可以通过在浏览器地址栏输入<code>about:about</code>查看。</p>
<ol start="2">
<li><strong>target</strong>：「可选参数」,它可以给以下两种值。
<ul>
<li>第一种是<strong>target关键字</strong>
<ul>
<li><code>_self</code>：当前标签页加载；</li>
<li><code>_blank（默认值）</code>：新标签页打开；</li>
<li><code>_parent</code>：作为当前浏览环境的父级浏览上下文打开，没有父级浏览上下文，效果与<code>_self</code>相同；</li>
<li><code>_top</code>：作为最顶级的浏览上下文打开，没有顶级浏览上下文，效果与<code>_self</code>相同。</li>
</ul>
</li>
<li>第二种是一个<strong>字符串</strong>：表示加载资源的浏览上下文的<strong>名称</strong>，也就是<strong>标签页的名称</strong>，如果这个名称在现有的标签页中不存在，则会开启一个新的标签页，如果存在，会跳转到这个标签页。</li>
</ul>
</li>
</ol>
<p>这里顺便提一下，我在平时开发中曾经写出这样的代码：</p>
</div>
<div class="cnblogs_Highlighter">
<pre class="brush:bash;gutter:true;">const handleClick = () =&gt; {
    window.open(url, 'blank');
}</pre>
</div>
<div>
<div>
<p>这个方法是绑定在一个点击按钮上面的，结果我的同事在点击多次这个按钮时，第一次会打开一个新窗口，而后续的点击都跳转到第一次点击打开的那个窗口，于是我去排查了一下，发现自己把<code>_blank</code>写成了<code>blank</code>，于是浏览器把它解析成了<strong>标签页的名字</strong>，而不是<strong>target关键词</strong>，我那时候感觉挺有意思，第一次详细去了解了这个<code>target</code>。</p>
<ol start="3">
<li><strong>windowFeatures</strong>:「可选参数」，它是一个字符串，用来描述窗口的特性，其格式是<code>"key1=value1, key2=value2"</code>，即将<code>key</code>和<code>value</code>以<code>=</code>号连接拼接成字符串，多个<code>key value</code>以<strong>逗号</strong>隔开，比如我们要打开一个宽为500，高为600的窗口可以这么写：</li>
</ol></div>
<div class="cnblogs_Highlighter">
<pre class="brush:bash;gutter:true;">window.open(url, 'new-window', 'width=500,height=600');</pre>
</div>
<div>
<div>
<p>它可以描述如下窗口特性：</p>
<ol>
<li><code>width</code>：内容区域宽度，最小值为100，</li>
<li><code>height</code>：内容区域高度，最小值100，</li>
<li><code>left</code>：距离<strong>用户操作系统</strong>工作区左侧的距离，</li>
<li><code>top</code>：距离<strong>用户操作系统</strong>工作区顶部的距离。</li>
<li>...</li>
</ol>
<p>这四个应该是最常用的，其它的不太常用我这里就不列举了。</p>
<p>至于这个<code>windowFeatures</code>的作用呢，平常开发中用的不太多，我能想到的场景就是比如你要通过url打开一个预览页面，让用户看里面的一些内容，就可以用这个试试。</p>
<h2 data-id="heading-2">三、bug复现</h2>
<p>先写一个能复现问题的demo：</p>
</div>
<div class="cnblogs_Highlighter">
<pre class="brush:bash;gutter:true;">async function jump() {
  await fetch('/xxx');
  window.open('https://www.xxx.cn');
}</pre>
</div>
<p>正常情况下执行<code>window.open</code>是能正常新标签页打开传入的url的，但是一旦前面用<code>await</code>做了异步操作后，再执行<code>window.open</code>，就不生效了。</p>
<p>然后我又尝试了<code>a标签</code>，发现效果也是一样的，无法打开新标签页。</p>
<div class="cnblogs_Highlighter">
<pre class="brush:bash;gutter:true;">async function jump() {
  await fetch('/xxx');
  let a = document.createElement('a');
  a.setAttribute('target', 'blank');
  a.href = 'https://www.xxx.cn';
  a.click()
  a = null;
}</pre>
</div>
<div>
<div>
<h2 data-id="heading-3">四、原因分析</h2>
<ol>
<li><strong>安全机制拦截</strong>：IOS的Safari浏览器为了防止恶意网站通过<code>window.open/a标签</code>打开其他网站，于是对它们的调用有所限制，如果不是由用户直接交互触发的，而是由程序自动触发的，Safari会拦截这个操作。</li>
<li><strong>异步操作</strong>：在AJAX回调中执行<code>window.open/a标签跳转</code>，被浏览器认为是非用户交互行为，所以被拦截。</li>
</ol>
<h2 data-id="heading-4">五、解决方案</h2>
<h3 data-id="heading-5">方案1：改用location.href</h3>
<p>既然<code>window.open</code>和<code>a标签跳转</code>不行，那就换成<code>location.href</code>就好了，因为safari不会拦截<code>location.href</code>。</p>
</div>
<div class="cnblogs_Highlighter">
<pre class="brush:bash;gutter:true;">async function jump() {
  await fetch('/xxx');
  location.href = 'https://www.xxx.cn';
}</pre>
</div>
<div>
<div>
<p>当然并不是所有场景下都适合用<code>location.href</code>，因为<code>location.href</code>会刷新页面，所以需要根据具体场景来选择。</p>
<h3 data-id="heading-6">方案2：先打开一个空标签页</h3>
<p>通过<code>window.open("", "_blank")</code>先打开一个空标签页，然后等待请求完成后，修改这个新标签页的url。</p>
</div>
</div>
<div class="cnblogs_Highlighter">
<pre class="brush:bash;gutter:true;">async function jump() {
  const newWin = window.open("", "_blank"); // 提前打开一个窗口
  const { jumpUrl } = await fetch('/xxx');
  if (jumpUrl) {
    newWin.location = jumpUrl;
  } else {
    newWin.close();
    // ... 
  }
}</pre>
</div>
<div>
<div>
<p>但这里有个体验问题，我这里根据有没有<code>jumpUrl</code>进行跳转，如果没有<code>jumpUrl</code>，我需要调用<code>close</code>方法关闭刚才提前打开的那个窗口，而这样用户就会体验到的流程就是，先出来一个新窗口，随后被秒关闭，这样用户体验很差。</p>
<h3 data-id="heading-7">方案3：setTimeout/requestAnimationFrame</h3>
<p>在我的业务场景中，是必须要用window.open的，所以只能另寻他法，最终找到了一个解决方案，就是在<code>window.open</code>之前加一个<code>setTimeout</code>，在回调中执行<code>window.open</code>，这样就能避免被safari拦截。</p>
</div>
</div>
<div class="cnblogs_Highlighter">
<pre class="brush:bash;gutter:true;">async function jump() {
  await fetch('/xxx');
  setTimeout(() =&gt; {
    window.open('https://www.xxx.cn');
  }, 0)
}</pre>
</div>
<p>后面测试了一下，发现<code>requestAnimationFrame</code>也可以。</p>
<div class="cnblogs_Highlighter">
<pre class="brush:bash;gutter:true;">async function jump() {
  await fetch('/xxx');
  requestAnimationFrame(() =&gt; {
    window.open('https://www.xxx.cn');
  })
}</pre>
</div>
<div>
<div>
<h2 data-id="heading-8">六、最终我采取的方案</h2>
<p>我最终是通过<strong>方案3</strong>的<code>setTimeout</code>解决了问题，如果<code>setTimeout</code>不生效，可以尝试加点延时看看，比如100毫秒，我这边实测的ios机型都能生效，所以就没加延时。</p>
<h2 data-id="heading-9">七、小结</h2>
<p>本文主要介绍了<code>window.open</code>的用法，以及我自己在平时开发中踩的坑，希望对大家平常开发有帮助！</p>
</div>
<div>
<h2>本文转载于：https://juejin.cn/post/7461206556300607525</h2>
</div>
<h3 id="tid-D8HBxE">如果对您有所帮助，欢迎您点个关注，我会定时更新技术文档，大家一起讨论学习，一起进步。</h3>
<p><img src="https://img2024.cnblogs.com/blog/2149129/202501/2149129-20250122165814748-630765389.png" alt="" loading="lazy"></p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="3.8045664645162036" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-22 16:59">2025-01-22 16:58</span>&nbsp;
<a href="https://www.cnblogs.com/smileZAZ">林恒</a>&nbsp;
阅读(<span id="post_view_count">37</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18686431" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18686431);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18686431', targetLink: 'https://www.cnblogs.com/smileZAZ/p/18686431', title: '记录---当window.open被ios安全机制拦截，我掏出3种方案，终于跳转成功！' })">举报</a>
</div>
        