
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/noear/p/18640811" title="发布于 2024-12-30 13:16">
    <span role="heading" aria-level="2">使用 httputils + sbe (Simple Binary Encoding) 实现金融级 java rpc</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        高性能Java库 Agrona  的主要目标是减少性能瓶颈，通过提供线程安全的直接和原子缓冲区、无装箱操作的原始类型列表、开散列映射和集合以及锁-free队列等，为开发者在处理并发和低延迟场景时提供强大工具。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="1认识-simple-binary-encoding-sbe">1、认识 Simple Binary Encoding (sbe)</h3>
<p>高性能Java库 Agrona  的主要目标是减少性能瓶颈，通过提供线程安全的直接和原子缓冲区、无装箱操作的原始类型列表、开散列映射和集合以及锁-free队列等，为开发者在处理并发和低延迟场景时提供强大工具。</p>
<p>Simple Binary Encoding (sbe) 是 Agrona 的一部分，也是高性能通讯框架 Aeron 的一部分。</p>
<h3 id="2什么是-rpc-">2、什么是 rpc ？</h3>
<p>一讲 rpc ，很多人会想到 dubbo （国产）和 grpc。估计还会联想到注册与发现服务；可能还会联想到微服务。可能就会觉得这个事儿“老重啦”，害怕！</p>
<p>其实很简单的，你请求一次 http 就是个 rpc 请求了（远程过程调用嘛）。最典型的就是 http + json 请求了。</p>
<h3 id="3现在讲-httputils--sbe">3、现在讲 httputils + sbe</h3>
<p>这里我们会用到两个重要的 <a href="https://solon.noear.org/article/875" target="_blank" rel="noopener nofollow">solon 框架</a>的插件：一个是 httputils 工具插件，一个是 abc + agrona 序列化插件（abc 适配了多个编解码方案）。</p>
<pre><code class="language-xml">&lt;!-- 这是 sbe 的编解码包装器 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.noear&lt;/groupId&gt;
    &lt;artifactId&gt;solon-serialization-abc&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.agrona&lt;/groupId&gt;
    &lt;artifactId&gt;agrona&lt;/artifactId&gt;
    &lt;version&gt;${agrona-sbe.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.noear&lt;/groupId&gt;
    &lt;artifactId&gt;solon-net-httputils&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>这里要感谢 solon 框架，它强调<a href="https://solon.noear.org/article/idea" target="_blank" rel="noopener nofollow">三元合一（mvc 与 rpc 是自然一体的）</a>。下面，开始干活啦...</p>
<ul>
<li>公用包（也可以在客户端，服务端分别定义实体类。只要实现 SbeSerializable 接口即可 ）</li>
</ul>
<p>这里定义一个 sbe 实体类。注意要实现 SbeSerializable 接口。</p>
<pre><code class="language-java">@Getter
@Setter
public class MessageDo implements SbeSerializable {
    private long id;
    private String title;

    @Override
    public void serializeRead(SbeInput in) {
        id = in.readLong();
        title = in.readString();
    }

    @Override
    public void serializeWrite(SbeOutput out) {
        out.writeLong(id);
        out.writeString(title);
    }
}
</code></pre>
<ul>
<li>服务端（只支持 @Body 数据接收，只支持实体类）</li>
</ul>
<p>在 solon web 项目里，添加一个控制器（注解可以用 <code>@Remoting</code> 或 <code>@Controller</code>）。使用 <code>@Remoting</code> 时，方法上不需要加 <code>@Mapping</code> 注解。</p>
<pre><code class="language-yaml">#添加插件
org.noear:solon-web
org.noear:solon-serialization-abc
org.agrona:agrona:${agrona-sbe.version} # 提供 sbe 序列化支持
</code></pre>
<pre><code class="language-java">@Mapping("/rpc/demo")
@Remoting
public class HelloServiceImpl {
    @Override
    public MessageDo hello(@Body MessageDo message) { //还可接收路径变量，与请求上下文
        return message;
    }
}
</code></pre>
<ul>
<li>客户端应用 for HttpUtils（只支持 body 数据提交，只支持实体类）</li>
</ul>
<pre><code class="language-yaml">#添加插件
org.noear:solon-net-httputils
org.noear:solon-serialization-abc
org.agrona:agrona:${agrona-sbe.version} # 提供 sbe 序列化支持
</code></pre>
<pre><code class="language-java">//应用代码
@Component
public class DemoCom {
    public MessageDo hello() {
        MessageDo message = new MessageDo();
        message.setId(3);
        
        //指明请求数据为 ABC，接收数据要 ABC
        return HttpUtils.http("http://localhost:8080/rpc/demo/hello")
                .serializer(AbcBytesSerializer.getInstance())
                .header(ContentTypes.HEADER_CONTENT_TYPE, ContentTypes.ABC_VALUE)
                .header(ContentTypes.HEADER_ACCEPT, ContentTypes.ABC_VALUE)
                .bodyOfBean(message)
                .postAs(MessageDo.class);
    }
}
</code></pre>
<h3 id="4总结">4、总结</h3>
<p>总体上，跟 json 没什么大的区别。主要是指定了：序列化器、内容类型、接收类型，让各端能识别类据类型。</p>
<h3 id="5还可以使用注解式-http-客户端框架">5、还可以使用“注解式 http 客户端”框架</h3>
<p>肯定也会有人觉得，一个接口还好，如果有很多接口就要写很多重复的http请求代码了。所以，“注解式 http 客户端” 很重要，这也是很多 rpc 框架流行的原因，就像调用本地接口一样，使用远程接口。</p>
<p>nami 是 solon 框架的 rpc 客户端（或者，注解式 http 客户端），支持各种序列化。（只要是“支持序列化定制”的注解式 http 客户端，都可用！）</p>
<ul>
<li>添加两个依赖包</li>
</ul>
<pre><code class="language-yaml">#添加插件
org.noear:nami-coder-abc # abc 编解码支持
org.noear:nami-channel-http     # http 请求通道支持，也可以是 socketd（支持 tcp, udp, ws）
org.agrona:agrona:${agrona-sbe.version} # 提供 sbe 序列化支持
</code></pre>
<ul>
<li>代码应用（只支持 body 数据提交，只支持实体类）</li>
</ul>
<pre><code class="language-java">@NamiClient(url = "http://localhost:8080/rpc/demo", headers = {ContentTypes.ABC, ContentTypes.ABC_ACCEPT})
public interface HelloService {
    MessageDo hello(@NamiBody MessageDo message);
    //方法2
    //方法3
    //方法4
    //方法5
    //方法6
}

@Component
public class DemoCom {
    @NamiClient //注入
    HelloService helloService;
  
    public MessageDo hello() {
         MessageDo message = new MessageDo();
         message.setId(3);
        
         rerturn helloService.hello(message);
    }
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7059693384918981" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-30 13:17">2024-12-30 13:16</span>&nbsp;
<a href="https://www.cnblogs.com/noear">带刺的坐椅</a>&nbsp;
阅读(<span id="post_view_count">192</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18640811" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18640811);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18640811', targetLink: 'https://www.cnblogs.com/noear/p/18640811', title: '使用 httputils + sbe (Simple Binary Encoding) 实现金融级 java rpc' })">举报</a>
</div>
        