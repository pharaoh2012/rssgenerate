
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hugogoos/p/18702067" title="发布于 2025-02-07 09:38">
    <span role="heading" aria-level="2">并发编程 - 线程同步（四）之原子操作Interlocked详解一</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文介绍Interlocked类的使用，包括Read、Increment、Decrement和Add方法，适用于多线程环境安全操作变量，解决了非原子操作导致的线程安全问题，并提供示例代码。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>上一章我们了解了原子操作Interlocked类的设计原理及简单介绍，今天我们将对Interlocked的使用进行详细讲解。</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250207092939280-420007594.jpg" alt="" loading="lazy"></p>
<p>在此之前我们先学习一个概念——原子操作。</p>
<h1 id="01read方法"><em><strong>01</strong></em>、Read方法</h1>
<p>该方法用于原子的读取64位值，有分别针对long类型和ulong类型的两个重载方法；</p>
<p>对于64位系统，64位数据类型的读取本身就是原子操作；而对于32位系统，64位数据类型的读取需要至少两个原子指令，因此在32位系统可以通过Read方法对64位数据类型进行原子读取。</p>
<p>用法也很简单，示例如下：</p>
<pre><code class="language-csharp">private static long _readValue = 0;
public static void ReadRun()
{
    var thread = new Thread(ModifyReadValue);
    thread.Start();
    Thread.Sleep(100);
    var value = Interlocked.Read(ref _readValue);
    Console.WriteLine("原子读取long类型变量: " + value);
}
static void ModifyReadValue()
{
    _readValue = 88;
    Console.WriteLine("修改long类型变量: " + _readValue);
}
</code></pre>
<p>运行结果如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250207092932229-874151228.png" alt="" loading="lazy"></p>
<p>因为系统环境原因无法模拟出32位系统效果，因此这里只是给了个简单使用示例。</p>
<h1 id="02increment方法"><em><strong>02</strong></em>、Increment方法</h1>
<p>该方法用于原子的递增指定的变量，并返回递增后的新值。该方法有4个重载方法，分别为long、ulong、int和uint四种数据类型；该方法适用于多线程环境中需要安全递增变量的场景，如计数器、资源管理等。</p>
<p>对于加法操作，无论是i+1,还是i++或++i，都不是线程安全的，最终可能会生成3条CPU指令，整个操作过程大致如下：</p>
<p>1.将 i 的值加载到寄存器，即从内存中读取i；</p>
<p>2.将寄存器中值加1，即i值加1；</p>
<p>3.最后将寄存器中值回写到i，即完成i值的变更；</p>
<p>而在这编码层面为1行代码，而CPU层面为3行指令的操作中，随时都有可能被线程调度器打断，而导致其他线程同时对i进行操作，最终导致竞争条件，最后数据错乱。</p>
<p>下面我们来举个例子，启动100个线程，分别对一个共享变量进行1000次递增1，最后打印出共享变量，运行这个示例9次观察每次运行结果，代码如下：</p>
<pre><code class="language-csharp">private static long _incrementValue = 0;
public static void IncrementRun()
{
    //运行9次测试，观察每次结果
    for (var i = 1; i &lt; 10; i++)
    {
        //启动100个线程，对变量进行递增
        var threads = new Thread[100];
        for (var j = 0; j &lt; threads.Length; j++)
        {
            threads[j] = new Thread(ModifyIncrementValue);
            threads[j].Start();
        }
        //等待所有线程执行完成
        foreach (var thread in threads)
        {
            thread.Join();
        }
        //最后打印结果
        Console.WriteLine($"第 {i} 运行结果: {_incrementValue}");
        _incrementValue = 0;
    }
}
static void ModifyIncrementValue()
{
    for (var i = 0; i &lt; 1000; i++)
    {
        ++_incrementValue;
    }
}
</code></pre>
<p>先看下执行结果：</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250207092921203-1884641789.png" alt="" loading="lazy"></p>
<p>可以发现每次的运行结果都不相同，并且结果也不对。这就是因为++i操作并不是原子操作，是线程不安全的。</p>
<p>只需要把上面代码：</p>
<pre><code class="language-csharp">++_incrementValue;
</code></pre>
<p>改为：</p>
<pre><code class="language-csharp">Interlocked.Increment(ref _incrementValue);
</code></pre>
<p>即可解决上面的问题，修改过后，我们再来看看执行结果：</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250207092912443-834303041.png" alt="" loading="lazy"></p>
<h1 id="03decrement方法"><em><strong>03</strong></em>、Decrement方法</h1>
<p>该方法用于原子的递减指定的变量，并返回递减后的新值。该方法同样有4个重载方法，分别为long、ulong、int和uint四种数据类型；</p>
<p>该方法和Increment方法基本一样，区别就是一个是递增一个是递减，因此用法可以直接参考Increment方法，这里就不做详细讲解了。</p>
<h1 id="04add方法"><em><strong>04</strong></em>、Add方法</h1>
<p>该方法用于原子的对两个变量求和，将第一个变量替换为两者和，并返回操作后第一个变量的新值。该方法同样有4个重载方法，分别为long、ulong、int和uint四种数据类型；</p>
<p>虽然这个方法叫求和是加法，但是只需要把第2个参数变为负数，既可以实现减法。简单来说该方法可以实现原子的对两个变量求和与求差。</p>
<p>上面Increment方法和Decrement方法，只能对变量每次进行递增递减1，而能随意加减，可以通过Add方法实现两个变量进行加减。</p>
<p>下面我们用代码实现累加和累减示例用来说明Add使用方法，就不展示线程安全差异了，可以参考Increment方法中的示例，自己写一个线程不安全的示例。</p>
<pre><code class="language-csharp">private static long _addValue = 0;
public static void AddRun()
{
    for (var j = 0; j &lt; 1000; j++)
    {
        //_addValue =_ addValue + j;
        Interlocked.Add(ref _addValue, j);
    }
    Console.WriteLine($"累加结果: {_addValue}");
    _addValue = 0;
    for (var j = 0; j &lt; 1000; j++)
    {
        //_addValue =_ addValue - j;
        Interlocked.Add(ref _addValue, -j);
    }
    Console.WriteLine($"累减结果: {_addValue}");
}
</code></pre>
<p>执行结果如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/386841/202502/386841-20250207092902587-1160289413.png" alt="" loading="lazy"></p>
<p><em><strong>注</strong></em>：测试方法代码以及示例源码都已经上传至代码库，有兴趣的可以看看。<a href="https://gitee.com/hugogoos/Planner" target="_blank" rel="noopener nofollow">https://gitee.com/hugogoos/Planner</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="3.981686751443287" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-07 09:38">2025-02-07 09:38</span>&nbsp;
<a href="https://www.cnblogs.com/hugogoos">IT规划师</a>&nbsp;
阅读(<span id="post_view_count">281</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18702067" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18702067);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18702067', targetLink: 'https://www.cnblogs.com/hugogoos/p/18702067', title: '并发编程 - 线程同步（四）之原子操作Interlocked详解一' })">举报</a>
</div>
        