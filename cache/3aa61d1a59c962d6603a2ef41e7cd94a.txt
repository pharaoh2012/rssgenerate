
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wkynf/p/18789638" title="发布于 2025-03-24 16:16">
    <span role="heading" aria-level="2">响应式编程之Project Reactor</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><strong>Project Reactor</strong>作为响应式编程范式的核心实现框架，<strong>严格遵循Reactive Streams规范体系</strong>，其架构设计完整包含了规范定义的四个核心组件：Publisher（数据源）、Subscriber（订阅者）、Subscription（订阅关系）和Processor（处理节点）。在该框架中，<strong>Flux</strong>和<strong>Mono</strong>不仅实现了Publisher接口的标准语义，更构建了完整的响应式数据流处理范式：通过订阅关系建立生产-消费通道，基于事件驱动机制实现非阻塞式数据推送，同时通过背压（backpressure）协议保障系统的弹性通信。</p>
<h2 id="基本流程">基本流程</h2>
<p>从整体上理解 Project Reactor 的工作原理，能够帮助我们更清晰地掌握其中的各种概念和操作，避免迷失方向。实际上，从大局来看，整个 Reactor 就是基于订阅-发布模式的。Flux 和 Mono 作为系统中默认的 Publisher，简化了我们自定义 Publisher 的工作。Flux 和 Mono 集成了大量的操作符，这些操作符的存在减少了我们自定义 Subscriber 和 Processor 的需求。通过这些操作符的组合，我们可以直接对数据源和元素进行操作，而无需自己编写额外的 Processor 和 Subscriber。除非在特殊情况下，否则不建议主动去自定义 Subscriber 和 Processor。</p>
<pre><code class="language-txt">创建数据源(Flux,Mono)-&gt;转换和处理数据(map,filter...)-&gt;subscribe订阅数据源
</code></pre>
<h2 id="一响应式数据源">一、响应式数据源：</h2>
<h3 id="11-flux与mono">1.1 Flux与Mono</h3>
<p>作为Project Reactor的核心发布者，Flux和Mono的主要区别如下：</p>
<ul>
<li>
<p>Flux代表0-N个元素的异步序列</p>
</li>
<li>
<p>Mono表示0-1个结果的异步操作</p>
</li>
</ul>
<pre><code class="language-java">// 创建Flux
Flux.just("1", "2", "3").subscribe(System.out::println);

// 创建Mono
Mono.just("a").subscribe(System.out::println);
</code></pre>
<h3 id="12-数据源类型">1.2 数据源类型</h3>
<p>了解了Flux和Mono之后，我们知道了如何简单的创建数据源，其中Flux和Mono也给我们提供了非常多的创建数据源的方式，大概分为以下几类。</p>
<ol>
<li>‌空数据源： 用于表示无数据的完成信号（如删除操作的结果）。</li>
<li>‌动态生成：<code>Mono.create</code> 和 <code>Flux.generate</code>/<code>Flux.create</code> 允许手动控制元素发射（同步或异步）。</li>
<li>‌异步数据源： 从 <code>Future</code>、<code>Callable</code> 或 <code>Supplier</code> 中获取数据，支持非阻塞操作。</li>
<li>‌时间驱动： <code>Mono.delay</code> 延迟发射，<code>Flux.interval</code> 周期性发射递增数值。</li>
<li>‌合并/组合： <code>zip</code> 严格对齐元素，<code>merge</code> 无序合并，<code>concat</code> 顺序连接。</li>
<li>‌背压适配： 通过 <code>FluxSink</code> 或 <code>MonoSink</code> 手动控制背压和元素发射。</li>
</ol>
<p><strong>Mono 和 Flux 数据源创建方式分类总结</strong>‌</p>
<table>
<thead>
<tr>
<th>‌<strong>类别</strong>‌</th>
<th>‌<strong>描述</strong>‌</th>
<th>‌<strong>Mono 方法示例</strong>‌</th>
<th>‌<strong>Flux 方法示例</strong>‌</th>
</tr>
</thead>
<tbody>
<tr>
<td>‌<strong>空数据源</strong>‌</td>
<td>创建不发射任何元素的数据流。</td>
<td><code>Mono.empty()</code></td>
<td><code>Flux.empty()</code></td>
</tr>
<tr>
<td>‌<strong>单个元素</strong>‌</td>
<td>发射单个静态值或对象。</td>
<td><code>Mono.just(T)</code></td>
<td><code>Flux.just(T...)</code></td>
</tr>
<tr>
<td>‌<strong>多个元素</strong>‌</td>
<td>发射多个静态值或对象（仅 <code>Flux</code> 支持）。</td>
<td><code>N/A</code></td>
<td><code>Flux.just(T1, T2...)</code></td>
</tr>
<tr>
<td>‌<strong>集合/数组</strong>‌</td>
<td>从集合或数组生成元素。</td>
<td><code>N/A</code></td>
<td><code>Flux.fromIterable(List&lt;T&gt;)</code> <code>Flux.fromArray(T[])</code></td>
</tr>
<tr>
<td>‌<strong>流（Stream）</strong>‌</td>
<td>从 Java <code>Stream</code> 生成元素。</td>
<td><code>N/A</code></td>
<td><code>Flux.fromStream(Stream&lt;T&gt;)</code></td>
</tr>
<tr>
<td>‌<strong>动态生成</strong>‌</td>
<td>通过生成器函数动态生成元素。</td>
<td><code>Mono.create(sink -&gt; {...})</code></td>
<td><code>Flux.generate(sink -&gt; {...})</code> <code>Flux.create(sink -&gt; {...})</code></td>
</tr>
<tr>
<td>‌<strong>异步数据源</strong>‌</td>
<td>从异步操作（如 <code>Future</code>、<code>Callable</code>）获取数据。</td>
<td><code>Mono.fromFuture(Future)</code> <code>Mono.fromCallable(Callable)</code></td>
<td><code>Flux.from(Publisher)</code> <code>Flux.fromStream(Supplier&lt;Stream&gt;)</code></td>
</tr>
<tr>
<td>‌<strong>错误信号</strong>‌</td>
<td>直接发射错误信号。</td>
<td><code>Mono.error(Throwable)</code></td>
<td><code>Flux.error(Throwable)</code></td>
</tr>
<tr>
<td>‌<strong>延迟初始化</strong>‌</td>
<td>惰性生成数据（订阅时才执行逻辑）。</td>
<td><code>Mono.defer(() -&gt; ...)</code> <code>Mono.fromSupplier(Supplier)</code></td>
<td><code>Flux.defer(() -&gt; ...)</code> <code>Flux.fromStream(Supplier&lt;Stream&gt;)</code></td>
</tr>
<tr>
<td>‌<strong>时间驱动</strong>‌</td>
<td>基于时间生成数据（如定时、延迟）。</td>
<td><code>Mono.delay(Duration)</code></td>
<td><code>Flux.interval(Duration)</code></td>
</tr>
<tr>
<td>‌<strong>合并/组合</strong>‌</td>
<td>合并多个数据源。</td>
<td><code>Mono.zip(Mono1, Mono2...)</code></td>
<td><code>Flux.merge(Flux1, Flux2...)</code> <code>Flux.concat(Flux1, Flux2...)</code> <code>Flux.zip(Flux1, Flux2...)</code></td>
</tr>
<tr>
<td>‌<strong>背压适配</strong>‌</td>
<td>适配外部背压机制（如 <code>Sink</code> 手动控制）。</td>
<td><code>Mono.create(MonoSink)</code></td>
<td><code>Flux.create(FluxSink)</code></td>
</tr>
<tr>
<td>‌<strong>条件触发</strong>‌</td>
<td>根据条件生成数据（如 <code>first</code>、<code>takeUntil</code>）。</td>
<td><code>Mono.firstWithValue(Mono1, Mono2)</code></td>
<td><code>Flux.firstWithValue(Publisher...)</code> <code>Flux.takeUntil(Predicate)</code></td>
</tr>
</tbody>
</table>
<h3 id="13-数据源发布模型">1.3 数据源发布模型</h3>
<p>Project Reactor 的发布模型是其响应式编程的核心机制，主要分为 ‌<strong>冷发布者（Cold Publisher）</strong>‌ 和 ‌<strong>热发布者（Hot Publisher）</strong>‌。它们的区别在于数据流的生成、共享方式以及订阅者的消费行为。以下是详细解释：</p>
<h4 id="131冷发布者cold-publisher">1.3.1、冷发布者（Cold Publisher）</h4>
<p>‌<strong>定义</strong>‌：冷发布者为每个订阅者生成‌<strong>独立的数据流</strong>‌。每个订阅者都会触发数据源的完整生成过程，即使其他订阅者已订阅过。</p>
<p>‌<strong>特点</strong>‌：</p>
<ol>
<li>‌<strong>数据流独立</strong>‌：每个订阅者从头开始消费数据。</li>
<li>‌<strong>延迟生成</strong>‌：数据在订阅时才开始生成（惰性计算）。</li>
<li>‌<strong>资源隔离</strong>‌：不同订阅者的数据生成逻辑互不影响。</li>
</ol>
<p>‌<strong>适用场景</strong>‌：</p>
<ul>
<li>
<p>需要每个订阅者获取完整数据（如 HTTP 请求、数据库查询）。</p>
</li>
<li>
<p>数据源的生成成本较高，但需确保订阅者的独立性。</p>
<p><strong>代码示例</strong></p>
<pre><code class="language-java">// 创建冷发布者
Flux&lt;Integer&gt; coldFlux = Flux.range(1, 3).doOnNext(i -&gt; System.out.println("冷发布者发出: " + i));
// 第一个订阅者
coldFlux.subscribe(i -&gt; System.out.println("订阅者1: " + i));
// 第二个订阅者
coldFlux.subscribe(i -&gt; System.out.println("订阅者2: " + i));
</code></pre>
<p><strong>输出</strong></p>
<pre><code>冷发布者发出: 1
订阅者1: 1
冷发布者发出: 2
订阅者1: 2
冷发布者发出: 1
订阅者2: 1
冷发布者发出: 2
订阅者2: 2
</code></pre>
</li>
</ul>
<h4 id="132热发布者hot-publisher">1.3.2、热发布者（Hot Publisher）</h4>
<ul>
<li>
<p>‌<strong>定义</strong>‌：热发布者共享一个‌<strong>统一的数据流</strong>‌，所有订阅者消费同一份数据。数据源的生成与订阅者的订阅时间无关，后订阅的订阅者可能错过早期数据。</p>
<p>‌<strong>特点</strong>‌：</p>
<ol>
<li>‌<strong>数据流共享</strong>‌：所有订阅者接收同一数据源。</li>
<li>‌<strong>实时性</strong>‌：数据源的生成独立于订阅行为。</li>
<li>‌<strong>资源复用</strong>‌：多个订阅者共享同一数据生成逻辑。</li>
</ol>
<p>‌<strong>适用场景</strong>‌：</p>
<ul>
<li>实时事件推送（如传感器数据、股票报价）。</li>
<li>需要广播数据，避免重复生成高成本操作（如 WebSocket 消息）。</li>
</ul>
</li>
</ul>
<p><strong>热发布者的实现方式有如下几种：</strong></p>
<ol>
<li>
<h5 id="connectableflux手动控制">‌<strong><code>ConnectableFlux（手动控制）</code></strong>‌</h5>
</li>
</ol>
<p>通过 <code>publish()</code> 方法将 <code>Flux</code> 转换为 <code>ConnectableFlux</code>，需手动调用 <code>connect()</code> 启动数据流。</p>
<p><strong>代码示例</strong></p>
<pre><code class="language-java">        // 创建 ConnectableFlux 并转换为热发布者
        ConnectableFlux&lt;Integer&gt; hotFlux = Flux.range(1, 3)
                .doOnNext(i -&gt; System.out.println("热发布者发出: " + i))
                .publish(); // 转换为 ConnectableFlux
        // 订阅者A
        hotFlux.subscribe(i -&gt; System.out.println("订阅者A: " + i));
        // 订阅者B
        hotFlux.subscribe(i -&gt; System.out.println("订阅者B: " + i));
        // 手动触发数据流开始
        hotFlux.connect();
</code></pre>
<p><strong>输出</strong></p>
<pre><code class="language-txt">热发布者发出: 1
订阅者A: 1
订阅者B: 1
热发布者发出: 2
订阅者A: 2
订阅者B: 2
热发布者发出: 3
订阅者A: 3
订阅者B: 3
</code></pre>
<ol start="2">
<li>
<h5 id="autoconnect自动连接">‌<strong><code>autoConnect()</code></strong>‌（自动连接）</h5>
</li>
</ol>
<p>当达到指定订阅者数量时，自动启动数据流。</p>
<pre><code class="language-java">        Flux&lt;Integer&gt; autoFlux = Flux.range(1, 3)
                .doOnNext(i -&gt; System.out.println("热发布者发出: " + i))
                .publish()
                .autoConnect(2);// 当有 2 个订阅者时自动启动
        autoFlux.subscribe(i -&gt; System.out.println("订阅者A: " + i));
        autoFlux.subscribe(i -&gt; System.out.println("订阅者B: " + i));
</code></pre>
<p><strong>输出</strong></p>
<pre><code>热发布者发出: 1
订阅者A: 1
订阅者B: 1
热发布者发出: 2
订阅者A: 2
订阅者B: 2
热发布者发出: 3
订阅者A: 3
订阅者B: 3
</code></pre>
<ol start="3">
<li>
<h5 id="share简化热发布者">‌<strong><code>share()</code></strong>‌（简化热发布者）</h5>
</li>
</ol>
<p>等价于 <code>publish().refCount(1)</code>：当第一个订阅者到来时启动，最后一个取消订阅时终止。</p>
<pre><code class="language-java">        Flux&lt;Long&gt; sharedFlux = Flux.interval(Duration.ofSeconds(1))
                .doOnNext(i -&gt; System.out.println("热发布者发出: " + i))
                .take(5)
                .share();
        sharedFlux.subscribe(i -&gt; System.out.println("订阅者A: " + i));
        Thread.sleep(2500);
        sharedFlux.subscribe(i -&gt; System.out.println("订阅者B: " + i)); // 订阅者B错过前2个数据
</code></pre>
<p><strong>输出</strong></p>
<pre><code class="language-txt">热发布者发出: 0
订阅者A: 0
热发布者发出: 1
订阅者A: 1
热发布者发出: 2
订阅者A: 2
订阅者B: 2
热发布者发出: 3
订阅者A: 3
订阅者B: 3
热发布者发出: 4
订阅者A: 4
订阅者B: 4
</code></pre>
<hr>
<ol start="4">
<li>
<h5 id="replay历史数据缓存">‌<strong><code>replay()</code></strong>‌（历史数据缓存）</h5>
</li>
</ol>
<p>允许新订阅者消费订阅前的历史数据（缓存策略可配置）。</p>
<pre><code class="language-java">        ConnectableFlux&lt;Integer&gt; replayFlux = Flux.range(1, 3)
                .doOnNext(i -&gt; System.out.println("热发布者发出: " + i))
                .replay(2);// 缓存最近2个数据

        replayFlux.subscribe(i -&gt; System.out.println("订阅者A: " + i));
        replayFlux.connect();
        Thread.sleep(1000);
        replayFlux.subscribe(i -&gt; System.out.println("订阅者B: " + i)); // 订阅者B收到最后2个数据
</code></pre>
<p>‌<strong>输出</strong>‌：</p>
<pre><code>热发布者发出: 1
订阅者A: 1
热发布者发出: 2
订阅者A: 2
热发布者发出: 3
订阅者A: 3
订阅者B: 2
订阅者B: 3
</code></pre>
<p><strong>冷发布者和热发布者对比表格</strong></p>
<table>
<thead>
<tr>
<th>‌<strong>特性</strong>‌</th>
<th>‌<strong>冷发布者</strong>‌</th>
<th>‌<strong>热发布者</strong>‌</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据生成时机</td>
<td>订阅时生成</td>
<td>提前生成（或由 <code>connect()</code> 触发）</td>
</tr>
<tr>
<td>订阅者独立性</td>
<td>每个订阅者独立消费完整数据</td>
<td>共享同一数据流</td>
</tr>
<tr>
<td>资源消耗</td>
<td>高（每个订阅者独立生成）</td>
<td>低（共享生成逻辑）</td>
</tr>
<tr>
<td>典型场景</td>
<td>数据库查询、静态数据</td>
<td>实时事件、广播</td>
</tr>
</tbody>
</table>
<h2 id="二强大的操作符生态系统">二、强大的操作符生态系统</h2>
<h3 id="21-核心操作符分类">2.1 核心操作符分类</h3>
<table>
<thead>
<tr>
<th>‌<strong>类别</strong>‌</th>
<th>‌<strong>操作符示例</strong>‌</th>
<th>‌<strong>功能描述</strong>‌</th>
</tr>
</thead>
<tbody>
<tr>
<td>‌<strong>转换操作符</strong>‌</td>
<td><code>buffer</code>, <code>map</code>, <code>flatMap</code>, <code>window</code></td>
<td>修改流中元素结构或内容（如分组、映射、扁平化）</td>
</tr>
<tr>
<td>‌<strong>过滤操作符</strong>‌</td>
<td><code>filter</code>, <code>take</code>, <code>skip</code></td>
<td>按条件筛选元素（如保留满足条件的元素、跳过前N项）</td>
</tr>
<tr>
<td>‌<strong>组合操作符</strong>‌</td>
<td><code>merge</code>, <code>concat</code>, <code>zip</code></td>
<td>合并多个流（如按顺序连接、并行合并、元素一一配对）</td>
</tr>
<tr>
<td>‌<strong>条件操作符</strong>‌</td>
<td><code>any</code>, <code>all</code>, <code>hasElement</code></td>
<td>判断流中元素是否满足条件（如是否存在满足条件的元素）</td>
</tr>
<tr>
<td>‌<strong>数学操作符</strong>‌</td>
<td><code>count</code>, <code>sum</code>, <code>reduce</code></td>
<td>对元素进行聚合计算（如统计总数、求和、累加）</td>
</tr>
<tr>
<td>‌<strong>错误处理操作符</strong>‌</td>
<td><code>onErrorReturn</code>, <code>onErrorResume</code></td>
<td>异常时提供备选值或切换至备用流（如返回静态值、动态恢复逻辑）</td>
</tr>
<tr>
<td>‌<strong>工具操作符</strong>‌</td>
<td><code>delay</code>, <code>timeout</code>, <code>log</code>, <code>subscribe</code></td>
<td>控制流生命周期（如延迟发送、超时中断、记录日志、触发订阅）</td>
</tr>
<tr>
<td><strong>整个数据源操作</strong></td>
<td><code>doOnNext</code>,<code>,</code>,<code>doOnRequest</code>,<code>doOnSubscribe</code>,<code>doOnComplete</code>等</td>
<td>其中以doOn开头的可以对整个数据链的不同状态进行操作</td>
</tr>
</tbody>
</table>
<h3 id="22-常见操作类似java的stream">2.2 常见操作（类似Java的Stream）</h3>
<pre><code class="language-java">//转换操作符、过滤操、条件及数学操作符类似Java的Stream这里不做过多赘述
//map
Flux.just(1, 2, 3).map(i -&gt; i + 1).subscribe(System.out::println);
//filter
Flux.just("a", "b", "c").filter(s -&gt; s.equals("a")).subscribe(System.out::println);
//flatMap
Flux.just("a", "b", "c").flatMap(s -&gt; Flux.just(s.toUpperCase())).subscribe(System.out::println);
//reduce
Flux.just(1, 2, 3).reduce(0, (a, b) -&gt; a + b).subscribe(System.out::println);
//window  窗口使用
Flux.just(1, 2, 3, 4, 5, 6).window(3, 1).flatMap(e -&gt; e.reduce(0, Integer::sum)).subscribe(System.out::println);
//buffer  背压或者批处理使用，会缓存数据
Flux.just(1, 2, 3, 4, 5, 6).buffer(3, 1).subscribe(System.out::println);
</code></pre>
<h3 id="23-组合操作符">2.3 组合操作符</h3>
<ul>
<li><strong>zip</strong></li>
</ul>
<p>zip操作符可以将多个（最多8个）流合并成一个流，合并的方式是将两个流中的元素按照顺序一一对应，然后将两个元素组合成一个元素。 如果两个流的长度不一致，那么最终合并成的流的长度就是两个流中长度较短的那个流的长度。</p>
<pre><code class="language-java">Flux&lt;String&gt; flux1 = Flux.just("a", "b", "c");
Flux&lt;String&gt; flux2 = Flux.just("d", "e", "f");
Flux&lt;String&gt; flux3 = Flux.just("1", "2", "3");
Flux.zip(flux1, flux2, flux3).subscribe(System.out::println);

//输出
[a,d,1]
[b,e,2]
[c,f,3]
</code></pre>
<ul>
<li><strong>merge</strong></li>
</ul>
<p>merge 操作符可以将两个流合并成一个流，合并的方式是将两个流中的元素交替地放入到合并后的流中。同时运行，根据时间先后运行。</p>
<pre><code class="language-java">Flux&lt;Integer&gt; flux3 = Flux.just(1, 2, 3).delayElements(Duration.ofMillis(80));
Flux&lt;Integer&gt; flux4 = Flux.just(4, 5, 6).delayElements(Duration.ofMillis(50));
flux3.mergeWith(flux4).subscribe(System.out::println);

//输出  由于是根据时间先后处理，所以结果大概率是这样，也有可能会稍有不同
4
1
5
2
6
3
</code></pre>
<ul>
<li><strong>concat</strong></li>
</ul>
<p>concat 操作符可以将两个流合并成一个流，合并的方式是将两个流中的元素按照顺序放入到合并后的流中。按照顺序分别运行，flux1运行完成以后再运行flux2</p>
<pre><code class="language-java">Flux&lt;Integer&gt; flux1 = Flux.just(1, 2, 3).delayElements(Duration.ofMillis(80));
Flux&lt;Integer&gt; flux2 = Flux.just(4, 5, 6).delayElements(Duration.ofMillis(50));
flux1.concatWith(flux2).subscribe(System.out::println);
//输出
1
2
3
4
5
6
</code></pre>
<h3 id="24-整个数据源操作"><strong>2.4 整个数据源操作</strong></h3>
<p>Project Reactor 提供了大量的以doOn开头的方法，这些方法用于在数据流的生命周期中插入副作用逻辑（如日志、监控或资源管理），‌<strong>不修改数据流本身，仅用于观察或触发行为</strong>‌。</p>
<p>每个方法的使用方法大致相同，下面以doOnRequest和doOnNext做一下简单的示例。</p>
<pre><code class="language-java">Flux.just(1, 2, 3, 4, 5, 6).doOnNext(s -&gt; System.out.println("doOnNext: " + s)).subscribe();
System.out.println("----------------");
Flux.just(1, 2, 3).doOnRequest(s -&gt; System.out.println("doOnRequest: " + s)).subscribe(System.out::println);
//输出
doOnNext: 1
doOnNext: 2
doOnNext: 3
doOnNext: 4
doOnNext: 5
doOnNext: 6
----------------
doOnRequest: 9223372036854775807
1
2
3
</code></pre>
<p>下面是每个方法的使用场景和触发时机。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>触发时机</th>
<th>参数类型</th>
<th>典型场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>doOnSubscribe</code></td>
<td>订阅时</td>
<td><code>Consumer&lt;Subscription&gt;</code></td>
<td>资源初始化</td>
</tr>
<tr>
<td><code>doOnNext</code></td>
<td>元素推送时</td>
<td><code>Consumer&lt;T&gt;</code></td>
<td>日志记录、状态更新</td>
</tr>
<tr>
<td><code>doOnError</code></td>
<td>发生错误时</td>
<td><code>Consumer&lt;Throwable&gt;</code></td>
<td>错误监控、报警</td>
</tr>
<tr>
<td><code>doOnComplete</code></td>
<td>流正常结束时</td>
<td><code>Runnable</code></td>
<td>完成通知</td>
</tr>
<tr>
<td><code>doOnRequest</code></td>
<td>下游请求数据时</td>
<td><code>Consumer&lt;Long&gt;</code></td>
<td>背压调试、请求量监控</td>
</tr>
<tr>
<td><code>doOnCancel</code></td>
<td>取消订阅时</td>
<td><code>Runnable</code></td>
<td>资源释放</td>
</tr>
<tr>
<td><code>doOnEach</code></td>
<td>所有事件发生时</td>
<td><code>Consumer&lt;Signal&lt;T&gt;&gt;</code></td>
<td>统一事件处理</td>
</tr>
<tr>
<td><code>doOnTerminate</code></td>
<td>流终止前（完成/错误前）</td>
<td><code>Runnable</code></td>
<td>终止前清理逻辑</td>
</tr>
<tr>
<td><code>doAfterTerminate</code></td>
<td>流终止后（完成/错误后）</td>
<td><code>Runnable</code></td>
<td>终止后统计</td>
</tr>
<tr>
<td><code>doOnDiscard</code></td>
<td>元素被丢弃时</td>
<td><code>Consumer&lt;T&gt;</code></td>
<td>资源回收、数据一致性检查</td>
</tr>
</tbody>
</table>
<h2 id="三执行控制订阅与调度">三、执行控制：订阅与调度</h2>
<h3 id="31-订阅机制">3.1 订阅机制</h3>
<p>subscribe 操作符用来订阅流中的元素。 当流中的元素没有被订阅的时候，所有的操作都不会触发，只有当流中的元素被订阅的时候，所有的操作才会触发。 通过上面内容的阅读，相信你已经对Project Reactor的发布订阅模型已经了解了个大概，上面的订阅的例子也有很多，这里不做过多的赘述。</p>
<h3 id="32-调度器策略">3.2 调度器策略</h3>
<p><strong><code>Schedulers</code></strong>‌ 是管理线程和并发任务的核心工具，用于控制响应式流的执行上下文。通过合理选择调度器，可以优化资源利用、避免阻塞，并提升应用性能</p>
<table>
<thead>
<tr>
<th>调度器</th>
<th>线程模型</th>
<th>适用场景</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>immediate</code></td>
<td>当前线程</td>
<td>轻量级同步操作</td>
<td>避免阻塞</td>
</tr>
<tr>
<td><code>single</code></td>
<td>单线程</td>
<td>严格顺序执行</td>
<td>避免长时间阻塞</td>
</tr>
<tr>
<td><code>boundedElastic</code></td>
<td>动态线程池</td>
<td>阻塞 I/O 操作</td>
<td>控制最大线程数和队列容量</td>
</tr>
<tr>
<td><code>parallel</code></td>
<td>固定大小线程池</td>
<td>计算密集型并行任务</td>
<td>线程数默认等于 CPU 核心数</td>
</tr>
<tr>
<td><code>fromExecutorService</code></td>
<td>自定义线程池</td>
<td>集成现有线程池</td>
<td>需自行管理生命周期</td>
</tr>
</tbody>
</table>
<h3 id="33-默认调度器">3.3 默认调度器</h3>
<p>在 Project Reactor 中，可以很方便的通过publishOn和subscribeOn来切换使用的线程调度器。</p>
<pre><code class="language-java">Flux.range(1, 10)
        .publishOn(Schedulers.boundedElastic()) //切换调度器
        .log("publish thread:")
        .flatMap(n -&gt; Mono.fromCallable(() -&gt; n).subscribeOn(Schedulers.parallel()))  //切换调度器
        .log("subscribe thread:")
        .subscribe();
</code></pre>
<h3 id="34-自定义虚拟线程调度器">3.4 自定义虚拟线程调度器</h3>
<p>当然在JDK17及更改的版本中也可以结合虚拟线程进一步提高并发量。</p>
<pre><code class="language-java">Scheduler customSchedule = Schedulers.fromExecutor(Executors.newVirtualThreadPerTaskExecutor());
Flux.range(1, 10)
        .publishOn(customSchedule)
        .log("publish thread:")
        .flatMap(n -&gt; Mono.fromCallable(() -&gt; n).subscribeOn(Schedulers.parallel()))
        .log("subscribe thread:")
        .subscribe();
</code></pre>
<h2 id="四高级控制组件">四、高级控制组件</h2>
<h3 id="41-processor与sink的关系">4.1 Processor与Sink的关系</h3>
<p>在 Project Reactor 中，‌<strong><code>Processor</code></strong>‌ 曾是一个关键组件，但随着 Reactor 3.4+ 版本的演进，官方逐渐将其标记为‌<strong>弃用（Deprecated）</strong>‌，并推荐使用更现代的 ‌<strong><code>Sink</code> API</strong>‌ 替代。以下是弃用原因、两者核心区别。</p>
<h4 id="1-线程安全">1. ‌<strong>线程安全</strong></h4>
<ul>
<li><strong>processor：</strong>大多数 <code>Processor</code> 实现（如 <code>DirectProcessor</code>、<code>UnicastProcessor</code>）‌<strong>非线程安全</strong>‌，直接调用 <code>onNext</code>、<code>onComplete</code> 等方法需手动同步。</li>
<li><strong>Sink：</strong> <strong>原子性操作</strong>‌：<code>Sink</code> 提供 <code>tryEmitNext</code>、<code>tryEmitError</code> 等方法，确保多线程推送数据时的安全性。</li>
</ul>
<h4 id="2-角色定位">2. ‌<strong>角色定位</strong>‌</h4>
<ul>
<li>‌<strong>Processor：</strong>  同时作为 <code>Publisher</code> 和 <code>Subscriber</code>，这种设计虽然灵活，但导致职责不清晰，容易误用。</li>
<li><strong>Sink：</strong>仅作为纯生产者（仅生成数据流）</li>
</ul>
<h4 id="3-背压处理">3. ‌<strong>背压处理</strong></h4>
<ul>
<li>
<p>‌<strong>processor</strong></p>
<p>对背压的支持差异大：</p>
<ul>
<li><code>DirectProcessor</code> 完全忽略背压（无界队列）。</li>
<li><code>UnicastProcessor</code> 支持单订阅者的背压，但需手动配置缓冲区。</li>
</ul>
</li>
<li>
<p><strong>Sink</strong>‌：内置配置,通过 <code>onBackpressureBuffer</code>、<code>onBackpressureError</code> 等链式方法直接定义背压行为。</p>
</li>
</ul>
<h4 id="4-生命周期管理复杂">4. ‌<strong>生命周期管理复杂</strong>‌</h4>
<ul>
<li>‌<strong>processor</strong>‌：需显式调用 <code>onComplete</code> 或 <code>onError</code> 结束流，若遗漏可能导致资源泄漏或订阅者挂起。</li>
<li><strong>Sink：</strong>通过 <code>tryEmitComplete</code> 和 <code>tryEmitError</code> 明确结束流，避免资源泄漏。</li>
</ul>
<h4 id="5-api-设计">5. ‌<strong>API 设计</strong></h4>
<ul>
<li>‌<strong>processor</strong>‌：<code>Processor</code> 的 API 未针对现代响应式编程模式优化（如缺少对重试、重播的内置支持）。</li>
<li><strong>Sink：</strong>灵活简单，通过 <code>Sinks.Many</code> 的 <code>multicast()</code>、<code>unicast()</code> 或 <code>replay()</code> 快速配置多订阅者行为。</li>
</ul>
<h3 id="42-api使用示例">4.2 API使用示例</h3>
<p>​    由于processor已经被弃用，不推荐使用，这里不做过多介绍。</p>
<ul>
<li>
<p>1：发送单个数据</p>
<pre><code class="language-java">Sinks.One&lt;String&gt; sink = Sinks.one();
Mono&lt;String&gt; mono = sink.asMono();
mono.subscribe(
        value -&gt; System.out.println("Received: " + value),
        error -&gt; System.err.println("Error: " + error),
        () -&gt; System.out.println("Completed")
);
sink.tryEmitValue("Hello");  // 等效于 tryEmitNext + tryEmitComplete
</code></pre>
</li>
<li>
<p>2：发送多个数据</p>
<pre><code class="language-Java">// 创建多播 Sink, 并设计缓冲被压策略
Sinks.Many&lt;String&gt; sink = Sinks.many().multicast().onBackpressureBuffer();
//转换为flux
Flux&lt;String&gt; hotFlux = sink.asFlux().map(String::toUpperCase);

// 订阅者A
hotFlux.subscribe(i -&gt; System.out.println("订阅者A: " + i));

// 订阅者B
hotFlux.subscribe(i -&gt; System.out.println("订阅者B: " + i));

// 发送数据
sink.tryEmitNext("hello");
sink.tryEmitNext("world");
sink.tryEmitComplete();
</code></pre>
</li>
<li>
<p>3：支持历史数据</p>
</li>
</ul>
<pre><code class="language-java">// 创建重播 Sink，保留最近 2 个元素
Sinks.Many&lt;String&gt; sink = Sinks.many().replay().limit(2);

sink.tryEmitNext("A");
sink.tryEmitNext("B");

// 订阅者1 （接收历史数据 A, B）
sink.asFlux().subscribe(s -&gt; System.out.println("Sub1: " + s));

// 推送新数据
sink.tryEmitNext("C");

// 订阅者2（接收历史数据 B, C）
sink.asFlux().subscribe(s -&gt; System.out.println("Sub2: " + s));

//输出
Sub1: A
Sub1: B
Sub1: C
Sub2: B
Sub2: C
</code></pre>
<h3 id="42--背压">4.2  背压</h3>
<h4 id="421-背压策略">4.2.1 背压策略</h4>
<h4 id="1onbackpressurebuffer缓冲策略"><strong>1.<code>onBackpressureBuffer</code>（缓冲策略）</strong></h4>
<ul>
<li>‌<strong>行为</strong>‌：将未消费的数据存储在缓冲区中，等待下游请求时发送。</li>
<li>‌<strong>配置选项</strong>‌
<ul>
<li>‌<strong>缓冲区大小</strong>‌：可指定有界或无界（默认无界，需谨慎使用）。</li>
<li>‌<strong>溢出策略</strong>‌
<ul>
<li><code>ERROR</code>：缓冲区满时抛出 <code>IllegalStateException</code>。</li>
<li><code>DROP_LATEST</code>：丢弃新数据，保留旧数据。</li>
<li><code>DROP_OLDEST</code>：丢弃最旧数据，保留新数据。</li>
</ul>
</li>
</ul>
</li>
<li>‌<strong>适用场景</strong>‌：允许短暂的速度不匹配，但需控制内存占用。</li>
</ul>
<h4 id="2-onbackpressureerror错误策略">‌<strong>2. <code>onBackpressureError</code>（错误策略）</strong></h4>
<ul>
<li>‌<strong>行为</strong>‌：当缓冲区满或下游未请求时，‌<strong>立即抛出错误</strong>‌（<code>IllegalStateException</code>）。</li>
<li>‌<strong>适用场景</strong>‌：严格要求实时性，容忍数据丢失但需快速失败。</li>
</ul>
<h4 id="3-directbesteffort尽力而为策略"><strong>3. <code>directBestEffort</code>（尽力而为策略）</strong></h4>
<ul>
<li>‌<strong>行为</strong>‌：无缓冲区，直接推送数据到下游。如果下游未请求，‌<strong>静默丢弃新数据</strong>‌。</li>
<li>‌<strong>特点</strong>‌：避免内存占用，但可能导致数据丢失。</li>
<li>‌<strong>适用场景</strong>‌：实时事件处理（如日志、指标采集），允许偶尔丢失。</li>
</ul>
<h4 id="4-replay重播策略">‌<strong>4. <code>replay</code>（重播策略）</strong></h4>
<ul>
<li>
<p>‌<strong>行为</strong></p>
<p>‌<strong>新订阅者重播历史数据</strong>‌</p>
<ul>
<li>
<p>同时支持实时数据推送。</p>
</li>
<li>
<p>可配置重播的缓冲区大小（如保留最近的 <code>N</code> 个元素）。</p>
</li>
</ul>
</li>
<li>
<p>‌<strong>背压处理</strong>‌</p>
<ul>
<li>对新订阅者：重播历史数据时遵循背压请求。</li>
<li>对实时数据：使用 <code>onBackpressureBuffer</code> 或 <code>directBestEffort</code> 策略。</li>
</ul>
</li>
<li>
<p>‌<strong>适用场景</strong>‌：需要新订阅者获取历史数据的场景。</p>
</li>
</ul>
<h4 id="422-默认策略">‌<strong>4.2.2. 默认策略</strong>‌</h4>
<ul>
<li>‌<strong><code>multicast()</code></strong>‌：默认使用 <code>directBestEffort</code>（无缓冲区）。</li>
<li>‌<strong><code>unicast()</code></strong>‌：默认使用 <code>onBackpressureBuffer</code>（无界缓冲区）。</li>
<li>‌<strong><code>replay()</code></strong>‌：默认保留所有历史数据（无界缓冲区）。</li>
</ul>
<h2 id="五-hooks与context">五、 Hooks与Context</h2>
<h3 id="51-hooks">5.1 Hooks</h3>
<p>在 Project Reactor 中，‌<strong>Hooks</strong>‌ 是一组全局回调机制，允许对 Reactor 库的默认行为进行‌<strong>定制化扩展</strong>‌，用于调试、监控或修改响应式流的执行逻辑。</p>
<h4 id="1hooks-的核心用途">‌<strong>1、Hooks 的核心用途</strong>‌</h4>
<ol>
<li>‌<strong>全局错误处理</strong>‌：捕获未被下游处理的异常。</li>
<li>‌<strong>操作符生命周期监控</strong>‌：在操作符执行前后插入自定义逻辑。</li>
<li>‌<strong>调试与追踪</strong>‌：增强堆栈跟踪信息，定位异步流问题。</li>
<li>‌<strong>行为修改</strong>‌：动态替换或包装操作符的实现。</li>
</ol>
<hr>
<h4 id="2常用-hooks-及功能">‌<strong>2、常用 Hooks 及功能</strong>‌</h4>
<p><strong>1. <code>onOperatorError</code></strong>‌</p>
<ul>
<li>
<p>‌<strong>作用</strong>‌：捕获操作符执行过程中抛出的‌<strong>未处理异常</strong>‌。</p>
</li>
<li>
<p>‌<strong>典型场景</strong>‌：统一日志记录、转换错误类型。</p>
<pre><code class="language-java">Hooks.onOperatorError((error, context) -&gt; {
    System.err.println("全局捕获异常: " + error);
    return error; 
});
</code></pre>
</li>
</ul>
<p>‌<strong>2. <code>onNextDropped</code></strong>‌</p>
<ul>
<li>
<p>‌<strong>作用</strong>‌：处理因下游取消订阅、背压溢出等原因被‌<strong>丢弃的 <code>onNext</code> 元素</strong>‌。</p>
</li>
<li>
<p>‌<strong>典型场景</strong>‌：记录丢失的数据，用于审计或补偿。</p>
<pre><code class="language-java">Hooks.onNextDropped(item -&gt; 
    System.out.println("元素被丢弃: " + item)
);
</code></pre>
</li>
</ul>
<p>‌<strong>3. <code>onErrorDropped</code></strong>‌</p>
<ul>
<li>
<p>‌<strong>作用</strong>‌：处理因下游已终止（如已调用 <code>onComplete</code>）而被‌<strong>丢弃的 <code>onError</code> 信号</strong>‌。</p>
</li>
<li>
<p>‌<strong>典型场景</strong>‌：避免静默忽略错误。</p>
<pre><code class="language-java">Hooks.onErrorDropped(error -&gt; 
    System.err.println("错误被丢弃: " + error)
);
</code></pre>
</li>
</ul>
<p><strong>4. <code>onOperatorDebug</code></strong>‌</p>
<ul>
<li>
<p>‌<strong>作用</strong>‌：启用‌<strong>调试模式</strong>‌，为异步操作符生成增强的堆栈跟踪信息（含订阅点位置）。</p>
</li>
<li>
<p>‌<strong>代价</strong>‌：增加性能开销，‌<strong>仅限开发环境使用</strong>‌。</p>
<pre><code class="language-java">Hooks.onOperatorDebug(); // 启用调试模式
</code></pre>
</li>
</ul>
<p>‌<strong>5. <code>onEachOperator</code> / <code>onLastOperator</code></strong>‌</p>
<ul>
<li>
<p>‌<strong>作用</strong>‌：在‌<strong>每个操作符执行前后</strong>‌插入自定义逻辑（如日志、指标采集）。</p>
</li>
<li>
<p>‌<strong>典型场景</strong>‌：性能监控、动态修改数据流。</p>
<pre><code class="language-java">Hooks.onEachOperator(operator -&gt; {
    long start = System.currentTimeMillis();
    return original -&gt; original.doFinally(signal -&gt; 
        System.out.println("操作符耗时: " + (System.currentTimeMillis() - start) + "ms")
    );
});
</code></pre>
</li>
</ul>
<p><strong>6. 重置 Hooks</strong>‌</p>
<ul>
<li>
<p>恢复默认行为</p>
<pre><code>javaCopy CodeHooks.resetOnOperatorError();
Hooks.resetOnNextDropped();
Hooks.resetOnOperatorDebug();
</code></pre>
</li>
</ul>
<h3 id="44-context">4.4 Context</h3>
<p>在 Project Reactor 中，‌<strong><code>Context</code></strong>‌ 是用于在响应式流的各个阶段之间传递‌<strong>上下文数据</strong>‌的核心机制。它解决了传统 <code>ThreadLocal</code> 在异步、多线程环境中的局限性，允许数据在操作符链中安全传递。以下是 <code>Context</code> 的详细解析，涵盖其设计思想、API 使用及典型场景。</p>
<h5 id="1-为什么需要-context">‌<strong>1. 为什么需要 Context？</strong>‌</h5>
<ul>
<li>‌<strong>问题</strong>‌：在异步响应式流中，数据可能由不同线程处理，<code>ThreadLocal</code> 无法跨线程传递。</li>
<li>‌<strong>解决方案</strong>‌：<code>Context</code> 提供一种与订阅链绑定的、不可变的键值存储，确保上下文数据在流的生命周期内可被安全访问。</li>
</ul>
<h5 id="2-context-的特点">‌<strong>2. Context 的特点</strong>‌</h5>
<ul>
<li>‌<strong>不可变性</strong>‌：每次修改会生成新实例，确保线程安全。</li>
<li>‌<strong>订阅链绑定</strong>‌：数据跟随订阅链传递，而非依赖线程(<strong>需要注意的是Context的传递是从底部往上传递的</strong>)。</li>
<li>‌<strong>键值存储</strong>‌：类似 <code>Map</code> 结构，支持类型安全的键（<code>ContextKey</code>）。</li>
<li><strong>自底向上（Downstream → Upstream）</strong>‌
<ul>
<li>‌<strong>写入顺序</strong>‌：后调用的 <code>contextWrite</code> 会覆盖先调用的。</li>
<li>‌<strong>读取顺序</strong>‌：下游（靠近订阅点）的 <code>Context</code> 优先被访问。</li>
</ul>
</li>
</ul>
<p>通过 <code>contextWrite</code> 操作符将 <code>Context</code> 写入响应式流，通过<code>deferContextual</code>在流中读取 Context</p>
<pre><code class="language-java">//注意由于ontext的传递是从底部往上传递的，所以必须在下面（A点）先写入才能在（B点读取到）
Flux.just("A", "B", "C", "D")
        //记为B点  拼接 Context 中的值
        .flatMap(s -&gt; {
                    System.out.println("ssss:" + s);
                    return Mono.deferContextual(ctx -&gt; Mono.just(s + ctx.get("suffix")));
                }
        )
        //记为A点  写入 Context（关键：必须在读取操作之前调用）
        .contextWrite(Context.of("suffix", "-ctx"))
        // 订阅输出结果
        .subscribe(System.out::println);
</code></pre>
<p><strong>Context自底向上（Downstream → Upstream）传播示例</strong></p>
<p>由于Context自底向上的传播特性，所以Context中<strong>B点</strong>的值会覆盖<strong>A点</strong>的值</p>
<pre><code class="language-java">Flux.just("A", "B", "C", "D")
        // 拼接 Context 中的值
        .flatMap(s -&gt; {
                    //由于ctx222会覆盖ctx111，所以此处拼接的是ctx222
                    System.out.println("ssss:" + s);
                    return Mono.deferContextual(ctx -&gt; Mono.just(s + ctx.get("suffix")));
                }
        )
        //记为B点，    写入 Context ctx222会覆盖ctx111
        .contextWrite(Context.of("suffix", "-ctx222"))
        //记为A点，    写入 Context
        .contextWrite(Context.of("suffix", "-ctx111"))
        // 订阅输出结果
        .subscribe(System.out::println);



//输出
ssss:A
A-ctx222
ssss:B
B-ctx222
ssss:C
C-ctx222
ssss:D
D-ctx222
</code></pre>
<h2 id="结语">结语</h2>
<p>通过深入理解Project Reactor这些核心概念，可以更好地驾驭响应式编程范式，构建出更高效、更弹性的分布式系统。与现代虚拟线程的结合，为构建新一代高并发应用提供了更优解。通过合理选择调度策略、优化线程模型，可以在保持代码简洁的同时，充分发挥硬件性能。</p>
<p><strong>路漫漫其修远兮，吾将上下而求索</strong></p>
<hr>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7019857308576389" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-24 16:16">2025-03-24 16:16</span>&nbsp;
<a href="https://www.cnblogs.com/wkynf">Philosophy</a>&nbsp;
阅读(<span id="post_view_count">91</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18789638" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18789638);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18789638', targetLink: 'https://www.cnblogs.com/wkynf/p/18789638', title: '响应式编程之Project Reactor' })">举报</a>
</div>
        