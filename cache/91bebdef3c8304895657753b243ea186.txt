
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangxincheng/p/18863987" title="发布于 2025-05-07 12:12">
    <span role="heading" aria-level="2">Linux系列：如何用perf跟踪.NET程序的mmap泄露</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景">一：背景</h2>
<h3 id="1-讲故事">1. 讲故事</h3>
<p>如何跟踪.NET程序的mmap泄露，这个问题困扰了我差不多一年的时间，即使在官方的github库中也找不到切实可行的方案，更多海外大佬只是推荐valgrind这款工具，但这款工具底层原理是利用模拟器，它的地址都是虚拟出来的，你无法对valgrind 监控的程序抓dump，并且valgrind显示的调用栈无法映射出.NET函数以及地址，这几天我仔仔细细的研究这个问题，结合大模型的一些帮助，算是找到了一个相对可行的方案。</p>
<h2 id="二mmap-导致的内存泄露">二：mmap 导致的内存泄露</h2>
<h3 id="1-一个测试案例">1. 一个测试案例</h3>
<p>为了方便讲述，我们通过 C 调用 mmap 方法分配256个 4M 的内存块，即总计 1G 的内存泄露，参考代码如下：</p>
<pre><code class="language-C">
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;unistd.h&gt;

#define BLOCK_SIZE (4096 * 1024)            // 每个块 4096KB (4MB)
#define TOTAL_SIZE (1 * 1024 * 1024 * 1024) // 总计 1GB
#define BLOCKS (TOTAL_SIZE / BLOCK_SIZE)    // 计算需要的块数

void mmap_allocation() {
    uint8_t* blocks[BLOCKS]; // 存储每个块的指针

    // 使用 mmap 分配 1GB 内存，分成多个 4MB 块
    for (size_t i = 0; i &lt; BLOCKS; i++) {
        blocks[i] = (uint8_t*)mmap(NULL, BLOCK_SIZE,
            PROT_READ | PROT_WRITE,
            MAP_PRIVATE | MAP_ANONYMOUS,
            -1, 0);

        if (blocks[i] == MAP_FAILED) {
            perror("mmap 失败");
            return;
        }

        // 确保每个块都被实际占用
        memset(blocks[i], 20, BLOCK_SIZE);
    }

    printf("已经使用 mmap 分配 1GB 内存（分成 %d 个 %dKB 块）！\n", 
           BLOCKS, BLOCK_SIZE/1024);
    printf("程序将暂停 10 秒，可以使用 top/htop 查看内存使用情况...\n");
    sleep(10);
}

int main() {
    mmap_allocation();
    return 0;
}

</code></pre>
<p>为了能够让 C# 调用，我们将这个 c 编译成 so 库，即 windows 中的 dll 文件，参考命令如下：</p>
<pre><code class="language-shell">
root@ubuntu2404:/data2/c# gcc -shared -o Example_18_1_5.so -fPIC -g -O0 Example_18_1_5.c
root@ubuntu2404:/data2/c# ls -lh
total 24K
-rw-r--r-- 1 root root 1.2K May  7 10:47 Example_18_1_5.c
-rwxr-xr-x 1 root root  18K May  7 10:47 Example_18_1_5.so

</code></pre>
<p>接下来创建一个名为 MyConsoleApp 的 Console控制台项目。</p>
<pre><code class="language-C#">
root@ubuntu2404:/data2# dotnet new console -n MyConsoleApp --framework net8.0 --use-program-main
The template "Console App" was created successfully.

Processing post-creation actions...
Restoring /data2/MyConsoleApp/MyConsoleApp.csproj:
  Determining projects to restore...
  Restored /data2/MyConsoleApp/MyConsoleApp.csproj (in 1.73 sec).
Restore succeeded.

root@ubuntu2404:/data2# cd MyConsoleApp
root@ubuntu2404:/data2/MyConsoleApp# dotnet run
Hello, World!

</code></pre>
<p>项目创建好之后，接下来就可以调用 Example_18_1_5.so 中的<code>mmap_allocation</code>方法了，在真正调用之前故意用<code>Console.ReadLine();</code>拦截，主要是方便用 perf 去介入监控，最后不要忘了将生成好的 <code>Example_18_1_5.so</code>文件丢到 bin 目录下，参考代码如下：</p>
<pre><code class="language-C#">
using System.Runtime.InteropServices;

namespace MyConsoleApp;

class Program
{
    [DllImport("Example_18_1_5.so", CallingConvention = CallingConvention.Cdecl)]
    public static extern void mmap_allocation();

    static void Main(string[] args)
    {
        MyTest();

        for (int i = 0; i &lt; int.MaxValue; i++)
        {
            Console.WriteLine($"{DateTime.Now} ：i={i} 执行完毕，自我轮询中...");

            Thread.Sleep(1000);
        }

        Console.ReadLine();
    }

    static void MyTest()
    {
        Console.WriteLine("MyTest 已执行，准备执行 mmap_allocation 方法");
        Console.ReadLine();
        mmap_allocation();
        Console.WriteLine("MyTest 已执行，准备执行 mmap_allocation 方法");
    }
}

</code></pre>
<h3 id="2-使用-perf-监控mmap事件">2. 使用 perf 监控mmap事件</h3>
<p>Linux 上的 perf 你可以简单的理解成 Windows 上的 perfview，前者是基于 perf_events 子系统，后者是基于 etw事件，这里就不做具体介绍了，这里我们用它监控 mmap 的调用，因为拿到调用线程栈之后，就可以知道到底是谁导致的泄露。</p>
<p>为了能够让 perf 识别到 .NET 的托管栈，微软做了一些特别支持，即开启 <code>export DOTNET_PerfMapEnabled=1</code> 环境变量，截图如下：<br>
<img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250507121225654-276403991.png" alt="" loading="lazy"></p>
<p>更多资料参考：<a href="https://learn.microsoft.com/zh-cn/dotnet/core/runtime-config/debugging-profiling" target="_blank" rel="noopener nofollow">https://learn.microsoft.com/zh-cn/dotnet/core/runtime-config/debugging-profiling</a></p>
<ol>
<li>在 <code>终端1</code> 上启动 C# 程序。</li>
</ol>
<pre><code class="language-C#">
root@ubuntu2404:/data2/MyConsoleApp/bin/Debug/net8.0# export DOTNET_PerfMapEnabled=1
root@ubuntu2404:/data2/MyConsoleApp/bin/Debug/net8.0# dotnet MyConsoleApp.dll
MyTest 已执行，准备执行 mmap_allocation 方法

</code></pre>
<ol start="2">
<li><code>终端2</code> 上开启 perf 对dontet程序的mmap进行跟踪。</li>
</ol>
<pre><code class="language-C#">
root@ubuntu2404:/data2/MyConsoleApp# ps -ef | grep Console
root        3074    2197  0 11:14 pts/1    00:00:00 dotnet MyConsoleApp.dll
root        3241    3106  0 11:56 pts/3    00:00:00 grep --color=auto Console
root@ubuntu2404:/data2/MyConsoleApp# perf record -p 3074 -g -e syscalls:sys_enter_mmap

</code></pre>
<p>启动跟踪之后记得在 <code>终端1</code> 上按下Enter回车让程序继续执行，当跟踪差不多（大量的内存泄露）的时候，我们在 <code>终端2</code> 上按下 <code>Ctrl+C</code> 停止跟踪，截图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250507121225664-1103622690.png" alt="" loading="lazy"></p>
<pre><code class="language-shell">
root@ubuntu2404:/data2/MyConsoleApp# perf record -p 3074 -g -e syscalls:sys_enter_mmap
^C[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.139 MB perf.data (333 samples) ]

</code></pre>
<p>从输出看当前的 perf.data 有 333 个样本，0.13M 的大小，由于在 linux 上分析不方便，而且又是二进制的，所以我们将 perf.data 转成 perf.txt 然后传输到 windows 上分析，参考命令如下：</p>
<pre><code class="language-shell">
root@ubuntu2404:/data2/MyConsoleApp# ls
MyConsoleApp.csproj  Program.cs  bin  obj  perf.data
root@ubuntu2404:/data2/MyConsoleApp# perf script &gt; perf.txt
root@ubuntu2404:/data2/MyConsoleApp# sz perf.txt

</code></pre>
<p>经过仔细的分析 perf.txt 的 mmap 调用栈，很快就会发现有人调了 256 次 4M 的 mmap 分配吃掉了绝大部分内存，那个上层的 <code>memfd:doublemapper</code> 就是 JIT 代码所存放的内存临时文件，由于有 <code>DOTNET_PerfMapEnabled=1</code> 的加持，可以看到 <code>[unknown]</code> 前面的方法返回地址，截图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250507121225664-933060136.png" alt="" loading="lazy"></p>
<h3 id="3-这些地址对应的-c-方法是什么">3. 这些地址对应的 C# 方法是什么</h3>
<p>本来我以为 JIT很给力，在 perf 生成的 <code>/tmp/perf-3074.map</code> 文件中弄好了符号信息，结果搜了下没有对应的方法名，比较尴尬。</p>
<pre><code class="language-shell">
root@ubuntu2404:/data2/MyConsoleApp# grep "7f42f3f11967" /tmp/perf-3074.map
root@ubuntu2404:/data2/MyConsoleApp# grep "7f42f3f11a90" /tmp/perf-3074.map
root@ubuntu2404:/data2/MyConsoleApp# 

</code></pre>
<p>那怎么办呢？只能抓dump啦，这也是我非常擅长的，可以用 <code>dotnet-dump</code>抓一个，然后使用 <code>!ip2md</code> 观察便知。</p>
<pre><code class="language-C#">
root@ubuntu2404:/data2/MyConsoleApp# dotnet-dump collect -p 3074

Writing full to /data2/MyConsoleApp/core_20250507_113516
Complete
root@ubuntu2404:/data2/MyConsoleApp# ls -lh 
total 1.2G
-rw-r--r-- 1 root root  242 May  7 10:50 MyConsoleApp.csproj
-rw-r--r-- 1 root root  769 May  7 11:05 Program.cs
drwxr-xr-x 3 root root 4.0K May  7 10:51 bin
-rw------- 1 root root 1.2G May  7 11:35 core_20250507_113516
drwxr-xr-x 3 root root 4.0K May  7 10:51 obj
-rw------- 1 root root 164K May  7 11:16 perf.data
-rw-r--r-- 1 root root 874K May  7 11:21 perf.txt
root@ubuntu2404:/data2/MyConsoleApp# dotnet-dump analyze core_20250507_113516
Loading core dump: core_20250507_113516 ...
Ready to process analysis commands. Type 'help' to list available commands or 'help [command]' to get detailed help on a command.
Type 'quit' or 'exit' to exit the session.
&gt; ip2md 7f42f3f11967                                                                                                                            
MethodDesc:   00007f42f3f9f320
Method Name:          MyConsoleApp.Program.Main(System.String[])
Class:                00007f42f3fbb648
MethodTable:          00007f42f3f9f368
mdToken:              0000000006000002
Module:               00007f42f3f9cec8
IsJitted:             yes
Current CodeAddr:     00007f42f3f11920
Version History:
  ILCodeVersion:      0000000000000000
  ReJIT ID:           0
  IL Addr:            00007f437307e250
     CodeAddr:           00007f42f3f11920  (MinOptJitted)
     NativeCodeVersion:  0000000000000000
Source file:  /data2/MyConsoleApp/Program.cs @ 12
&gt; ip2md 7f42f3f11a90                                                                                                                            
MethodDesc:   00007f42f3f9f338
Method Name:          MyConsoleApp.Program.MyTest()
Class:                00007f42f3fbb648
MethodTable:          00007f42f3f9f368
mdToken:              0000000006000003
Module:               00007f42f3f9cec8
IsJitted:             yes
Current CodeAddr:     00007f42f3f11a50
Version History:
  ILCodeVersion:      0000000000000000
  ReJIT ID:           0
  IL Addr:            00007f437307e2d2
     CodeAddr:           00007f42f3f11a50  (MinOptJitted)
     NativeCodeVersion:  0000000000000000
Source file:  /data2/MyConsoleApp/Program.cs @ 28
&gt; ip2md 7f42f3f13557                                                                                                                            
MethodDesc:   00007f42f42f42b8
Method Name:          ILStubClass.IL_STUB_PInvoke()
Class:                00007f42f42f41e0
MethodTable:          00007f42f42f4248
mdToken:              0000000006000000
Module:               00007f42f3f9cec8
IsJitted:             yes
Current CodeAddr:     00007f42f3f134d0
Version History:
  ILCodeVersion:      0000000000000000
  ReJIT ID:           0
  IL Addr:            0000000000000000
     CodeAddr:           00007f42f3f134d0  (MinOptJitted)
     NativeCodeVersion:  0000000000000000
&gt;                              

</code></pre>
<p>从 dotnet-dump 给的输出看，可以清楚的看到调用关系为： <code>Main -&gt; MyTest -&gt; ILStubClass.IL_STUB_PInvoke -&gt; mmap_allocation -&gt; mmap</code> 。</p>
<p>至此真相大白于天下。</p>
<h2 id="三总结">三：总结</h2>
<p>这类问题的泄露真的费了我不少心思，曾经让我纠结过，迷茫过，我也捣鼓过 strace，最终都无法找出栈上的托管函数，真的，目前 .NET 在 Linux 调试生态上还是很弱，好无奈，这篇文章我相信弥补了国内，甚至国外在这一块领域的空白，也算是这一年来对自己的一个交代。<br>
<img src="https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_210929020104最新消息优惠促销公众号关注二维码.jpg" width="700" height="300" alt="图片名称" align="center"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="3.1707008611168983" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-07 12:13">2025-05-07 12:12</span>&nbsp;
<a href="https://www.cnblogs.com/huangxincheng">一线码农</a>&nbsp;
阅读(<span id="post_view_count">719</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18863987);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18863987', targetLink: 'https://www.cnblogs.com/huangxincheng/p/18863987', title: 'Linux系列：如何用perf跟踪.NET程序的mmap泄露' })">举报</a>
</div>
        