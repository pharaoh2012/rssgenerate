
        <div class="postTitle">
            <h1><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chenyishi/p/18620273" title="发布于 2024-12-21 09:15">
    <span role="heading" aria-level="2">C#中 Task 结合 CancellationTokenSource的妙用</span>
    

</a>
</h1>
        </div>
        <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>在.NET中，<strong>CancellationTokenSource</strong>、<strong>CancellationToken</strong>和<strong>Task</strong>是处理异步操作和取消任务的重要工具。本文将通过一些简单的例子，帮助你理解它们的用法和协作方式。</p>
<hr>
<h4>CancellationTokenSource</h4>
<p><strong>CancellationTokenSource</strong> 是一个取消操作的触发器。它用于生成和管理<strong>CancellationToken</strong>，并控制取消信号的发出。</p>
<h5>常用属性和方法</h5>
<ul>
<li><strong>Token</strong>: 返回一个与此源关联的<code>CancellationToken</code>。</li>
<li><strong>Cancel()</strong>: 触发取消操作。</li>
<li><strong>CancelAfter(milliseconds)</strong>: 指定时间后触发取消操作。</li>
<li><strong>Dispose()</strong>: 释放资源。</li>
</ul>
<h5>示例</h5>
<pre><code class="language-csharp">var cts = new CancellationTokenSource();
CancellationToken token = cts.Token;

Task.Run(() =&gt; {
    for (int i = 0; i &lt; 10; i++)
    {
        if (token.IsCancellationRequested)
        {
            Console.WriteLine("Task canceled");
            break;
        }
        Console.WriteLine($"Task running: {i}");
        Thread.Sleep(500);
    }
});

Thread.Sleep(2000);
cts.Cancel();
</code></pre>
<h4>CancellationToken</h4>
<p><strong>CancellationToken</strong> 是用于传播取消请求的轻量级结构。它由<code>CancellationTokenSource</code>生成。</p>
<h5>常用属性和方法</h5>
<ul>
<li><strong>IsCancellationRequested</strong>: 是否收到取消请求。</li>
<li><strong>ThrowIfCancellationRequested()</strong>: 如果已请求取消，抛出<code>OperationCanceledException</code>。</li>
<li><strong>Register(Action)</strong>: 注册一个取消时触发的回调。</li>
</ul>
<h5>示例</h5>
<pre><code class="language-csharp">var cts = new CancellationTokenSource();
CancellationToken token = cts.Token;

Task.Run(() =&gt; {
    token.Register(() =&gt; Console.WriteLine("Cancellation registered"));

    try
    {
        for (int i = 0; i &lt; 10; i++)
        {
            token.ThrowIfCancellationRequested();
            Console.WriteLine($"Task running: {i}");
            Thread.Sleep(500);
        }
    }
    catch (OperationCanceledException)
    {
        Console.WriteLine("Task was canceled");
    }
});

Thread.Sleep(2000);
cts.Cancel();
</code></pre>
<h4>Task与CancellationToken</h4>
<p><strong>Task</strong> 是.NET中的异步操作单元。结合<code>CancellationToken</code>可以在任务运行时取消它。</p>
<h5>示例：取消任务</h5>
<pre><code class="language-csharp">var cts = new CancellationTokenSource();
CancellationToken token = cts.Token;

Task task = Task.Run(() =&gt; {
    for (int i = 0; i &lt; 10; i++)
    {
        if (token.IsCancellationRequested)
        {
            Console.WriteLine("Task canceled");
            break;
        }
        Console.WriteLine($"Task running: {i}");
        Thread.Sleep(500);
    }
}, token);

Thread.Sleep(2000);
cts.Cancel();

try
{
    task.Wait();
}
catch (AggregateException ex)
{
    foreach (var inner in ex.InnerExceptions)
    {
        if (inner is TaskCanceledException)
        {
            Console.WriteLine("Task cancellation exception caught");
        }
    }
}
</code></pre>
<h5>示例：带超时的任务</h5>
<pre><code class="language-csharp">var cts = new CancellationTokenSource(3000); // 3秒后自动取消
CancellationToken token = cts.Token;

Task.Run(() =&gt; {
    try
    {
        for (int i = 0; i &lt; 10; i++)
        {
            token.ThrowIfCancellationRequested();
            Console.WriteLine($"Task running: {i}");
            Thread.Sleep(1000);
        }
    }
    catch (OperationCanceledException)
    {
        Console.WriteLine("Task canceled due to timeout");
    }
});
</code></pre>
<h4>小结</h4>
<ol>
<li>使用<code>CancellationTokenSource</code>来控制取消。</li>
<li>通过<code>CancellationToken</code>将取消信号传递给任务或方法。</li>
<li>任务中可以通过<code>ThrowIfCancellationRequested</code>或检查<code>IsCancellationRequested</code>响应取消请求。</li>
<li>合理使用<code>Register</code>可以处理取消时的回调逻辑。</li>
</ol>
<p>通过灵活运用这些工具，你可以编写更高效、可控的异步程序。</p>
</div>
<div class="clear"></div>

        <div class="postDesc">posted on 
<span id="post-date" data-last-update-days="2.2353672265891205" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-21 09:20">2024-12-21 09:15</span>&nbsp;
<a href="https://www.cnblogs.com/chenyishi">chester·chen</a>&nbsp;
阅读(<span id="post_view_count">442</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18620273" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18620273);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18620273', targetLink: 'https://www.cnblogs.com/chenyishi/p/18620273', title: 'C#中 Task 结合 CancellationTokenSource的妙用' })">举报</a>
</div>
    