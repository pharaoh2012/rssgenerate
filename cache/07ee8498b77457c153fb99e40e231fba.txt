
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/IwishIcould/p/18935216" title="发布于 2025-06-19 09:04">
    <span role="heading" aria-level="2">Flex布局,绝对定位,层叠布局Stack的详细讲解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h4 id="flex布局">Flex布局</h4>
<p>Flex布局也叫做：伸缩布局，当子盒子的总和溢出父盒子时默认进行压缩显示<br>
线性布局的原理是基于Flex来设计的。<br>
Flex布局默认主轴是：水平向右的，交叉轴垂：直向下<br>
单行或者单列的情况下，优先使用线性布局<br>
线性布局的性能由于Flex布局</p>
<h4 id="flex布局我们可以根据-direction-来调整主轴的方向">FLex布局我们可以根据 direction 来调整主轴的方向</h4>
<p>direction:FlexDirection.Row 主轴水平向右的<br>
direction:FlexDirection.Column 主轴垂直向下的<br>
direction:FlexDirection.RowReverse 主轴水平向左，与Row<br>
direction:FlexDirection.ColumnReverse 垂直从下到上，与Column 相反</p>
<h4 id="flex布局主轴垂直向下">Flex布局主轴垂直向下</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Flex({
      direction:FlexDirection.Column // 主轴垂直向下的
    }){
      Text('111').width(80).height(80).backgroundColor("#bab")
      Text('222').width(80).height(80).backgroundColor("#d9d")
      Text('333').width(80).height(80).backgroundColor("#c2c")
    }.width('100%').height("100%")
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505101025192-1942855658.png" alt="" loading="lazy"></p>
<h4 id="flex布局主轴垂直从下到上">Flex布局主轴:垂直从下到上</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Flex({
      direction:FlexDirection.ColumnReverse // 垂直从下到上，与Column 相反
    }){
      Text('111').width(80).height(80).backgroundColor("#bab")
      Text('222').width(80).height(80).backgroundColor("#d9d")
      Text('333').width(80).height(80).backgroundColor("#c2c")
    }.width('100%').height("100%")
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505101002746-627815204.png" alt="" loading="lazy"></p>
<h4 id="主轴的对齐方式与之前学习的线性布局方式是一样的哈">主轴的对齐方式,与之前学习的线性布局方式是一样的哈</h4>
<p>justifyContent:FlexAlign.Start在最起始位置；<br>
justifyContent:FlexAlign.Center在中间;<br>
justifyContent:FlexAlign.End 在最末端;<br>
justifyContent:FlexAlign.SpaceBetween 两端紧挨着，中间均匀分布。与css3的一样。<br>
justifyContent:FlexAlign.SpaceAround 两端有一点间距(0.5)，中间间距(1)均匀分布。与css3的一样。<br>
justifyContent:FlexAlign.SpaceEvenly 间隙是均匀的。</p>
<h4 id="主轴水平向右排列方式间隙均匀">主轴水平向右,排列方式间隙均匀</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Flex({
      direction:FlexDirection.Row, // 主轴是：水平向右的
      justifyContent:FlexAlign.SpaceEvenly // 排列方式：间隙均匀
    }){
      Text('111').width(80).height(80).backgroundColor("#bab")
      Text('222').width(80).height(80).backgroundColor("#d9d")
      Text('333').width(80).height(80).backgroundColor("#c2c")
    }.width('100%').height("100%")
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505100914404-883843160.png" alt="" loading="lazy"></p>
<h4 id="主轴水平向右排列方式两端紧挨着中间均匀分布">主轴水平向右,排列方式:两端紧挨着，中间均匀分布</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Flex({
      direction:FlexDirection.Row, // 主轴是：水平向右的
      justifyContent:FlexAlign.SpaceBetween, // 排列方式：两端紧挨着，中间均匀分布
    }){
      Text('111').width(80).height(80).backgroundColor("#bab")
      Text('222').width(80).height(80).backgroundColor("#d9d")
      Text('333').width(80).height(80).backgroundColor("#c2c")
    }.width('100%').height("100%")
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1425695/202506/1425695-20250618192800964-835607024.png" alt="" loading="lazy"></p>
<h4 id="交叉轴的对齐方式">交叉轴的对齐方式</h4>
<p>alignItems: ItemAlign.Start 顶部<br>
alignItems: ItemAlign.Center 居中<br>
alignItems: ItemAlign.End 底部<br>
alignItems: ItemAlign.Stretch 拉伸，占满整个空间</p>
<h4 id="交叉轴的对齐方式--垂直方向拉伸占满整个空间">交叉轴的对齐方式:  垂直方向拉伸，占满整个空间</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Flex({
      direction:FlexDirection.Row, // 主轴是：水平向右的
      justifyContent:FlexAlign.SpaceBetween, // 排列方式：两端紧挨着，中间均匀分布,
      alignItems: ItemAlign.Stretch // 交叉轴的对齐方式:  垂直方向拉伸，占满整个空间
    }){
      Text('111').width(80).height(80).backgroundColor("#bab")
      Text('222').width(80).height(80).backgroundColor("#d9d")
      Text('333').width(80).height(80).backgroundColor("#c2c")
    }.width('100%').height("100%")
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505102631969-1482160589.png" alt="" loading="lazy"></p>
<h4 id="交叉轴对齐方式在末端">交叉轴对齐方式:在末端</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Flex({
      direction:FlexDirection.Row, // 主轴是：水平向右的
      justifyContent:FlexAlign.SpaceBetween, // 排列方式：两端紧挨着，中间均匀分布,
      alignItems: ItemAlign.End // 交叉轴方向上:在末端
    }){
      Text('111').width(80).height(80).backgroundColor("#bab")
      Text('222').width(80).height(80).backgroundColor("#d9d")
      Text('333').width(80).height(80).backgroundColor("#c2c")
    }.width('100%').height("100%")
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505102810699-25215314.png" alt="" loading="lazy"></p>
<h4 id="是否换行">是否换行</h4>
<p>wrap: FlexWrap.Wrap 换行<br>
wrap: FlexWrap.NoWrap 不换行。在使用Flex布局时，如果不进行换行，子元素的宽度大于父元素。会进行挤压<br>
wrap: FlexWrap.WrapReverse 换行翻转</p>
<h4 id="不换行">不换行</h4>
<p>在使用Flex布局时，如果不进行换行，子元素的宽度大于父元素。会进行挤压</p>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Flex({
      wrap:FlexWrap.NoWrap
    }){
      Text('111').width(180).height(80).backgroundColor("#bab")
      Text('222').width(180).height(80).backgroundColor("#d9d")
      Text('333').width(180).height(80).backgroundColor("#c2c")
      Text('444').width(180).height(80).backgroundColor("#ccc")
    }.width('100%').height("100%")
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505105733089-1397716788.png" alt="" loading="lazy"></p>
<h4 id="换行显示">换行显示</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Flex({
      wrap:FlexWrap.Wrap
    }){
      Text('111').width(180).height(80).backgroundColor("#bab")
      Text('222').width(180).height(80).backgroundColor("#d9d")
      Text('333').width(180).height(80).backgroundColor("#c2c")
    }.width('100%').height("100%")
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505105408550-1922857176.png" alt="" loading="lazy"></p>
<h4 id="换行翻转">换行翻转</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Flex({
      wrap:FlexWrap.WrapReverse
    }){
      Text('111').width(180).height(80).backgroundColor("#bab")
      Text('222').width(180).height(80).backgroundColor("#d9d")
      Text('333').width(180).height(80).backgroundColor("#c2c")
    }.width('100%').height("100%")
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505105520269-1796234667.png" alt="" loading="lazy"></p>
<h4 id="实现xx直聘搜索历史记录">实现XX直聘搜索历史记录</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Column(){
      Row(){
        Text('历史搜索').fontSize(22).fontWeight(700).margin({left:10, bottom:10})
      }.width('100%')
      Flex({
        wrap: FlexWrap.Wrap
      }){
        Text('galang').height(30).backgroundColor("#ccc").borderRadius(4).padding({left:8, right:8}).margin({left:10,right:10, bottom:10})
        Text('go开发工程师').height(30).backgroundColor("#ccc").padding({left:8, right:8}).borderRadius(4).margin({left:10,right:10, bottom:10})
        Text('web开发工程师').height(30).backgroundColor("#ccc").padding({left:8, right:8}).borderRadius(4).margin({left:10,right:10, bottom:10})
        Text('嵌入式开发').height(30).backgroundColor("#ccc").padding({left:8, right:8}).borderRadius(4).margin({left:10,right:10, bottom:10})
        Text('Ai开发').height(30).backgroundColor("#ccc").padding({left:8, right:8}).borderRadius(4).margin({left:10,right:10, bottom:10})
      }
    }
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505105052522-1144833626.png" alt="" loading="lazy"></p>
<h4 id="绝对定位">绝对定位</h4>
<p>绝对定位后的组件不再占用自身原有位置，可以实现层叠效果，原本的位置就不进行占用了。<br>
默认情况下，绝对定位的堆叠层级与组件的加载顺序有关，在最后的组件往往在最上面。<br>
如果使用了ZIndex，就与ZIndex的值大小有关，谁值越大，谁就在最上面。</p>
<p>语法：组件.position({x:数值,y:数值}) 或者 组件.position({right:数值,top:数值})<br>
你也可以这样写：Text('使用定位').position({ right:10,top:0}).backgroundColor(Color.Pink)</p>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Flex({
      wrap:FlexWrap.NoWrap
    }){
      Text('我使用了绝对定位').position({ right:10,top:0}).backgroundColor(Color.Pink)
    }.width('100%').height("100%")
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505110919180-1179390885.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505110948483-567596990.png" alt="" loading="lazy"></p>
<h4 id="zindex的使用">ZIndex的使用</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Flex({
      wrap:FlexWrap.NoWrap
    }){
      Text('最上面').position({ right:20,top:50}).backgroundColor('#ccc').width(60).height(40).zIndex(10)
      Text('哈哈').position({ right:10,top:0}).backgroundColor(Color.Pink).width(200).height(200)
      Text('五一结束啦').position({ right:20,top:50}).backgroundColor(Color.Orange).width(100).height(100)
    }.width('100%').height("100%")
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505231223963-326947239.png" alt="" loading="lazy"></p>
<h4 id="层叠布局">层叠布局</h4>
<p>层叠布局：堆叠容器，子组件按照顺序依次入栈，后一个子组件覆盖前一个子组件。<br>
层叠布局具有较强的组件层叠能力。<br>
场景:卡片层叠效果等，如购物车等<br>
特点:层叠操作更简洁，编码效率高。(绝对定位的优势是更灵活）<br>
我们可以通过alignContent来控制显示的位置<br>
语法：Stack({alignContent:Alignment.Start}){ })</p>
<h4 id="aligncontent的属性值通过有下面这9个属性值">alignContent的属性值通过有下面这9个属性值</h4>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alignment.TopStart</td>
<td>子组件对齐到容器的左上角（Top-Left）</td>
</tr>
<tr>
<td>Alignment.Top</td>
<td>子组件水平居中，并紧贴容器的顶部</td>
</tr>
<tr>
<td>Alignment.TopEnd</td>
<td>子组件对齐到容器的右上角（Top-Right）</td>
</tr>
<tr>
<td>Alignment.Start</td>
<td>子组件垂直居中，并紧贴容器的左侧（Left）</td>
</tr>
<tr>
<td>Alignment.Center</td>
<td>子组件在容器的中心位置（水平和垂直居中）</td>
</tr>
<tr>
<td>Alignment.End</td>
<td>子组件垂直居中，并紧贴容器的右侧（Right）</td>
</tr>
<tr>
<td>Alignment.BottomStart</td>
<td>子组件对齐到容器的左下角（Bottom-Left）</td>
</tr>
<tr>
<td>Alignment.Bottom</td>
<td>子组件水平居中，并紧贴容器的底部</td>
</tr>
<tr>
<td>Alignment.BottomEnd</td>
<td>子组件对齐到容器的右下角（Bottom-Right）</td>
</tr>
</tbody>
</table>
<h4 id="层叠布局-aligncontentalignmentstart-子组件垂直居中并紧贴容器的左侧">层叠布局: alignContent:Alignment.Start 子组件垂直居中，并紧贴容器的左侧</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Stack({alignContent:Alignment.Start}){
      Text("最大").width(200).height(200).backgroundColor(Color.Pink)
      Text("中等").width(120).height(120).backgroundColor('#50D')
      Text("最小").width(40).height(40).backgroundColor('#FF3')
    }.width('100%').height('100%').backgroundColor('#ccc')
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505225836233-1045001416.png" alt="" loading="lazy"></p>
<h4 id="层叠布局-aligncontentalignmenttopend-右上角">层叠布局: alignContent:Alignment.TopEnd 右上角</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Stack({alignContent:Alignment.TopEnd}){
      Text("最大").width(200).height(200).backgroundColor(Color.Pink)
      Text("中等").width(120).height(120).backgroundColor('#50D')
      Text("最小").width(40).height(40).backgroundColor('#FF3')
    }.width('100%').height('100%').backgroundColor('#ccc')
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505225453972-1140028016.png" alt="" loading="lazy"></p>
<h4 id="层叠布局-aligncontentalignmentbottomstart-左边底部">层叠布局: alignContent:Alignment.BottomStart 左边底部</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Stack({alignContent:Alignment.BottomStart}){
      Text("最大").width(200).height(200).backgroundColor(Color.Pink)
      Text("中等").width(120).height(120).backgroundColor('#50D')
      Text("最小").width(40).height(40).backgroundColor('#FF3')
    }.width('100%').height('100%').backgroundColor('#ccc')
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505225741624-1868072691.png" alt="" loading="lazy"></p>
<h4 id="通过zindex来控制层级关系">通过ZIndex来控制层级关系</h4>
<pre><code>@Entry
@Component
struct Index {
  build() {
    Stack({alignContent:Alignment.Center}){
      Text("最大").width(200).height(200).backgroundColor(Color.Pink).zIndex(40)
      Text("中等").width(120).height(120).backgroundColor('#50D').zIndex(20)
      Text("最小").width(40).height(40).backgroundColor('#FF3').zIndex(50)
    }.width('100%').height('100%').backgroundColor('#ccc')
  }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202505/1972489-20250505230804851-189875827.png" alt="" loading="lazy"></p>
<h4 id="层叠布局和绝对定位的区别">层叠布局和绝对定位的区别</h4>
<p>层叠布局（Stack）：通过对齐属性快速实现组件堆叠，适合简单叠加场景。<br>
绝对定位：通过精确坐标自由控制位置，适合复杂或动态布局需求。</p>
<p>也就是说：绝对定位更加控制位置更加的自由。<br>
能够使用层叠布局实现的，一定可以使用绝对定位来实现。<br>
在我们实现需求时，优先使用：层叠布局，如果不好实现的话，在考虑绝对定位</p>

</div>
<div id="MySignature" role="contentinfo">
    <div style="width:818px;background:#f5f5f5; padding: 10px 10px 10px 10px; border: 1px dashed rgb(224, 224, 224); font-family: 微软雅黑; font-size: 13px;">
            <h1 style="font-size: 24px;"> 遇见问题，这是你成长的机会，如果你能够解决，这就是收获。 </h1>
		    <div style="padding:10px">
		        作者：<a href="https://www.cnblogs.com/IwishIcould/" target="_blank">晚来南风晚相识</a> <br>
		        出处：<a href="https://www.cnblogs.com/IwishIcould/">https://www.cnblogs.com/IwishIcould/</a> <br>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
		        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>
		        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
				<div style="display: flex;">
					<div style="margin-right: 100px;text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179">
						<div>
							支付宝
						</div>
					</div>
					<div style="text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg">
						<div>微信</div>
					</div>
				</div>
		        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br>
		        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br>
               
		    </div>
           
            
		</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-19 09:04">2025-06-19 09:04</span>&nbsp;
<a href="https://www.cnblogs.com/IwishIcould">南风晚来晚相识</a>&nbsp;
阅读(<span id="post_view_count">67</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18935216);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18935216', targetLink: 'https://www.cnblogs.com/IwishIcould/p/18935216', title: 'Flex布局,绝对定位,层叠布局Stack的详细讲解' })">举报</a>
</div>
        