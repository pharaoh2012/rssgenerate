<!----> <meta itemprop="headline" content="TypeScript 官方宣布弃用 Enum？Enum 何罪之有？"> <meta itemprop="keywords" content="前端,TypeScript,JavaScript"> <meta itemprop="datePublished" content="2025-03-08T12:02:47.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="MurphyChen"> <meta itemprop="url" content="https://juejin.cn/user/3913917127723367"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-799d3073="">
            TypeScript 官方宣布弃用 Enum？Enum 何罪之有？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-799d3073=""><div class="author-info-box" data-v-799d3073=""><div class="author-name" data-v-799d3073=""><a href="/user/3913917127723367/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-6a576a98="" data-v-799d3073=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-6a576a98="">
    MurphyChen
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-799d3073=""><time datetime="2025-03-08T12:02:47.000Z" title="Sat Mar 08 2025 12:02:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-799d3073="">
                    2025-03-08
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-799d3073=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-799d3073=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-799d3073=""></circle></svg> <span class="views-count" data-v-799d3073="">
                    21,444
                  </span> <span class="read-time" data-v-799d3073=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-799d3073=""><rect width="16" height="16" fill="none" data-v-799d3073=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-799d3073=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-799d3073=""></path></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-799d3073=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-799d3073=""><div class="article-viewer markdown-body cache result"><h2 data-id="heading-0">1. 官方真的不推荐 Enum 了吗？</h2>
<h3 data-id="heading-1">1.1 事情的起因</h3>
<p>起因是看到 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2025%2F03%2Fweekly-issue-340.html%23%3A~%3Atext%3D2%25E3%2580%2581%25E4%25B8%258D%25E8%25A6%2581%25E7%2594%25A8%2520TypeScript%2520%25E6%259E%259A%25E4%25B8%25BE%25EF%25BC%2588%25E8%258B%25B1%25E6%2596%2587%25EF%25BC%2589" target="_blank" title="https://www.ruanyifeng.com/blog/2025/03/weekly-issue-340.html#:~:text=2%E3%80%81%E4%B8%8D%E8%A6%81%E7%94%A8%20TypeScript%20%E6%9E%9A%E4%B8%BE%EF%BC%88%E8%8B%B1%E6%96%87%EF%BC%89" ref="nofollow noopener noreferrer">科技爱好者周刊（第 340 期）</a> 里面推荐了一篇文章，说是官方不再推荐使用 enum 语法，原文链接在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.disintegrator.dev%2Fposts%2Fode-to-typescript-enums%2F" target="_blank" title="https://blog.disintegrator.dev/posts/ode-to-typescript-enums/" ref="nofollow noopener noreferrer">An ode to TypeScript enums</a>，大致是说 TS 新出了一个 <code>--erasableSyntaxOnly</code> 配置，只允许使用可擦除语法，但是 enum 不可擦除，因此推断官方已不再推荐使用 enum 了。官方并没有直接表达不推荐使用，那官方为什么要出这个配置项呢？</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/366aa9adc32b45118bc5ab3ae97455ae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXVycGh5Q2hlbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1748307699&amp;x-signature=OgU%2B%2BiEOJzr77Bfztg86uPgwQKg%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-2">1.2 什么是可擦除语法</h3>
<p>就在上周，TypeScript 发布了 5.8 版本，其中有一个改动是<strong>添加了 <code>--erasableSyntaxOnly</code> 配置选项，开启后仅允许使用可擦除语法，否则会报错</strong>。<code>enum</code> 就是一个不可擦除语法，开启 <code>erasableSyntaxOnly</code> 配置后，使用 <code>enum</code> 会报错。</p>
<p>例如，如果在 tsconfig 文件中配置 <code>"erasableSyntaxOnly": true</code>（只允许可擦除语法），此时使用不可擦除语法，将会得到报错：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e015d52b86cd49479c4acfd403e39e88~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXVycGh5Q2hlbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1748307699&amp;x-signature=alZtqoJrN%2FKDwl1pVVnKqMVvjq0%3D" alt="image.png" loading="lazy"></p>
<p><strong>可擦除语法就是可以直接去掉的、仅在编译时存在、不会生成额外运行时代码的语法，例如 <code>type</code>，<code>interface</code>。不可擦除语法就是不能直接去掉的、需要编译为JS且会生成额外运行时代码的语法，例如 <code>enum</code>，<code>namesapce(with runtime code</code>)。</strong> 具体举例如下：</p>
<p>可擦除语法，不生成额外运行时代码，比如 <code>type</code>、<code>let n: number</code>、<code>interface</code>、<code>as number</code> 等：
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab1838139057410488382f20ef9e7918~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXVycGh5Q2hlbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1748307699&amp;x-signature=XQN0i7VW5c%2BIoZuMTmiYtkAZ0Qg%3D" alt="image.png" loading="lazy"></p>
<p>不可擦除语法，生成额外运行时代码，比如 <code>enum</code>、<code>namespace</code>（具有运行时行为的）、类属性参数构造语法糖（Class Parameter properties）等：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 枚举类型</span>
<span class="hljs-keyword">enum</span> <span class="hljs-variable constant_">METHOD</span> {
  <span class="hljs-variable constant_">ADD</span> = <span class="hljs-string">'add'</span>
}

<span class="hljs-comment">// 类属性参数构造</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> x: <span class="hljs-built_in">number</span></span>) {}
}
<span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d1ba0b3069e492e8d9b2550ff9ed920~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXVycGh5Q2hlbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1748307699&amp;x-signature=EQBallUKf%2BdtgMJEdzC8nWzBWQ4%3D" alt="image.png" loading="lazy"></p>
<p>需要注意，具有运行时行为的 <code>namespace</code> 才属于不可擦除语法。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 不可擦除，具有运行时逻辑</span>
<span class="hljs-keyword">namespace</span> <span class="hljs-title class_">MathUtils</span> {
&nbsp; <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {
&nbsp; &nbsp; <span class="hljs-keyword">return</span> a + b;
&nbsp; }
}

<span class="hljs-comment">// 可擦除，仅用于类型声明，不包含任何运行时逻辑</span>
<span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Shapes</span> {
&nbsp; <span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Rectangle</span> {
&nbsp; &nbsp; <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>;
&nbsp; &nbsp; <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>;
&nbsp; }
}
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5bfa1f42b1604d99b429fdcae85443e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXVycGh5Q2hlbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1748307699&amp;x-signature=06vdqRXPr%2FMDDy0O9wU9P11ZnV8%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-3">1.3 TS 官方为什么要出 erasableSyntaxOnly？</h3>
<p>官方既然没有直接表达不推荐 enum，那为什么要出 <code>erasableSyntaxOnly</code> 配置来排除 <code>enum</code> 呢？</p>
<p>我找到了 TS 官方文档（<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Frelease-notes%2Ftypescript-5-8.html%23the---erasablesyntaxonly-option" target="_blank" title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html#the---erasablesyntaxonly-option" ref="nofollow noopener noreferrer">The --erasableSyntaxOnly Option</a>）说明：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/07e110d0a6b2402ab1e80a97464d70c9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXVycGh5Q2hlbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1748307699&amp;x-signature=lcYJIy7GDJNL0G0639E6muD4XwQ%3D" alt="image.png" loading="lazy"></p>
<p>大致意思是说之前 Node 新版本中支持了执行 TS 代码的能力，可以直接运行包含可擦除语法的 TypeScript 文件。Node 将用空格替换 TypeScript 语法，并且不执行类型检查。总结下来就是：</p>
<p>在 Node 22 版本：</p>
<ul>
<li>需要配置 <code>--experimental-transform-types</code> 执行支持 TS 文件</li>
<li>要禁用 Node 这种特性，使用参数 <code>--no-experimental-strip-types</code></li>
</ul>
<p>在 Node 23.6.0 版本：</p>
<ul>
<li>默认支持直接运行<strong>可擦除语法</strong>的 TS 文件，删除参数 <code>--no-experimental-strip-types</code></li>
<li>对于<strong>不可擦除语法</strong>，使用参数 <code>--experimental-transform-types</code></li>
</ul>
<p>综上所述，TS 官方为了配合 Node.js 这次改动（即默认允许直接执行不可擦除语法的 TS 代码），才添加了一个配置项 <code>erasableSyntaxOnly</code>，只允许可擦除语法。</p>
<h2 data-id="heading-4">2. Enum 的三大罪行</h2>
<p>自 Enum 从诞生以来，它一直是前端界最具争议的特性之一，许多前端开发者乃至不少大佬都对其颇有微词，纷纷发起了 <strong>DO NOT USE TypeScript Enum</strong> 的吐槽。那么<code>enum</code> 真的有那么难用吗？我认为是的，这玩意坑还挺多的，甲级战犯 Enum，出列！</p>
<h3 data-id="heading-5">2.1 枚举默认值</h3>
<p><code>enum</code> 默认的枚举值从 <code>0</code> 开始，这还不是最关键的，你传入了默认枚举值时，居然是合法的，这无形之中带来了类型安全问题。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">enum</span> <span class="hljs-variable constant_">METHOD</span> {
    <span class="hljs-variable constant_">ADD</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">doAction</span>(<span class="hljs-params">method: METHOD</span>) {
  <span class="hljs-comment">// some code</span>
}

<span class="hljs-title function_">doAction</span>(<span class="hljs-variable constant_">METHOD</span>.<span class="hljs-property">ADD</span>) <span class="hljs-comment">// ✅ 可以</span>
<span class="hljs-title function_">doAction</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// ✅ 可以</span>
</code></pre>
<h3 data-id="heading-6">2.2 不支持枚举值字面量</h3>
<p>还有一种场景，我要求既可以传入枚举类型，又要求传入枚举值字面量，如下所示，但是他又不合法了？（有人说你定义传枚举类型就要传相应的枚举，这没问题，但是上面提到的问题又是怎么回事呢？这何尝不是 Enum 的双标？）</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">enum</span> <span class="hljs-variable constant_">METHOD</span> {
    <span class="hljs-variable constant_">ADD</span> = <span class="hljs-string">'add'</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">doAction</span>(<span class="hljs-params">method: METHOD</span>) {
  <span class="hljs-comment">// some code</span>
}

<span class="hljs-title function_">doAction</span>(<span class="hljs-variable constant_">METHOD</span>.<span class="hljs-property">ADD</span>) <span class="hljs-comment">// ✅ 可以</span>
<span class="hljs-title function_">doAction</span>(<span class="hljs-string">'add'</span>) <span class="hljs-comment">// ❌ 不行	</span>
</code></pre>
<h3 data-id="heading-7">2.3 增加运行时开销</h3>
<p>TypeScript 的&nbsp;<code>enum</code>&nbsp;在编译后会生成额外的 JavaScript 双向映射数据，这会增加运行时的开销。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/efcee965f7fa4044a06ddedf53a46504~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXVycGh5Q2hlbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1748307699&amp;x-signature=UfBJ9baDHRiJ35sKxBXACgXe9v0%3D" alt="image.png" loading="lazy"></p>
<h2 data-id="heading-8">3. Enum 的替代方案</h2>
<p>众所周知，TS 一大特性是类型变换，我们可以通过类型操作组合不同类型来达到目标类型，又称为类型体操。下面的四种解决方案，可以根据实际需求来选择。</p>
<h3 data-id="heading-9">3.1 <code>const enum</code></h3>
<p><code>const enum</code> 是解决产生额外生成的代码和额外的间接成本有效且快捷的方法，但不推荐使用。</p>
<blockquote>
<p><code>const enum</code> 由于编译时内联带来了性能优化，但在 <code>.d.ts</code> 文件、<code>isolatedModules</code> 兼容性、版本不匹配及运行时缺少 <code>.js</code> 文件等场景下存在隐藏陷阱，可能导致难以发现的 bug。详见官方说明：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Fenums.html%23const-enum-pitfalls" target="_blank" title="https://www.typescriptlang.org/docs/handbook/enums.html#const-enum-pitfalls" ref="nofollow noopener noreferrer">const-enum-pitfalls</a></p>
</blockquote>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> <span class="hljs-keyword">enum</span> <span class="hljs-variable constant_">METHOD</span> {
  <span class="hljs-variable constant_">ADD</span> = <span class="hljs-string">'add'</span>,
  <span class="hljs-variable constant_">DELETE</span> = <span class="hljs-string">'delete'</span>,
  <span class="hljs-variable constant_">UPDATE</span> = <span class="hljs-string">'update'</span>,
  <span class="hljs-variable constant_">QUERY</span> = <span class="hljs-string">'query'</span>,
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">doAction</span>(<span class="hljs-params">method: METHOD</span>) {
    <span class="hljs-comment">// some code</span>
}

<span class="hljs-title function_">doAction</span>(<span class="hljs-variable constant_">METHOD</span>.<span class="hljs-property">ADD</span>) <span class="hljs-comment">// ✅ 可行</span>
<span class="hljs-title function_">doAction</span>(<span class="hljs-string">'delete'</span>) <span class="hljs-comment">// ❌ 不行</span>
</code></pre>
<p><code>const enum</code> 解析后的代码中引用 enum 的地方将直接被替换为对应的枚举值：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2c6871d5dae742b3902f1abfcdd03730~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXVycGh5Q2hlbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1748307699&amp;x-signature=eYpDbWqgKwe9zaQK9kPfcjTdwp4%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-10">3.2 模板字面量类型</h3>
<p>将枚举类型包装为模板字面量类型（Template Literal Types），从而即支持枚举类型，又支持枚举值字面量，但是没有解决运行时开销问题。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">enum</span> <span class="hljs-variable constant_">METHOD</span> {
  <span class="hljs-variable constant_">ADD</span> = <span class="hljs-string">'add'</span>,
  <span class="hljs-variable constant_">DELETE</span> = <span class="hljs-string">'delete'</span>,
  <span class="hljs-variable constant_">UPDATE</span> = <span class="hljs-string">'update'</span>,
  <span class="hljs-variable constant_">QUERY</span> = <span class="hljs-string">'query'</span>,
}

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">METHOD_STRING</span> = <span class="hljs-string">`<span class="hljs-subst">${METHOD}</span>`</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">doAction</span>(<span class="hljs-params">method: METHOD_STRING</span>) {
    <span class="hljs-comment">// some code</span>
}

<span class="hljs-title function_">doAction</span>(<span class="hljs-variable constant_">METHOD</span>.<span class="hljs-property">ADD</span>) <span class="hljs-comment">// ✅ 可行</span>
<span class="hljs-title function_">doAction</span>(<span class="hljs-string">'delete'</span>) <span class="hljs-comment">// ✅ 可行</span>
<span class="hljs-title function_">doAction</span>(<span class="hljs-string">'remove'</span>) <span class="hljs-comment">// ❌ 不行</span>

</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/72c520dcf7904fbcb5d3f3f7653be51d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXVycGh5Q2hlbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1748307699&amp;x-signature=hqGjQys79mToMW56Ut6lx3g4Oxs%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-11">3.3 联合类型（Union Types）</h3>
<p>使用联合类型，引用时可匹配的值限定为指定的枚举值了，但同时也没有一个地方可以统一维护枚举值，如果一旦枚举值有调整，其他地方都需要改。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">METHOD</span> =
  | <span class="hljs-string">'add'</span>
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@deprecated</span> 不再支持删除
   */</span>
  | <span class="hljs-string">'delete'</span>
  | <span class="hljs-string">'update'</span>
  | <span class="hljs-string">'query'</span>


<span class="hljs-keyword">function</span> <span class="hljs-title function_">doAction</span>(<span class="hljs-params">method: METHOD</span>) {
    <span class="hljs-comment">// some code</span>
}

<span class="hljs-title function_">doAction</span>(<span class="hljs-string">'delete'</span>) <span class="hljs-comment">// ✅ 可行，没有 TSDoc 提示</span>
<span class="hljs-title function_">doAction</span>(<span class="hljs-string">'remove'</span>) <span class="hljs-comment">// ❌ 不行</span>

</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e5e2ea32caa94b45819075e0ef8a4d3f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXVycGh5Q2hlbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1748307699&amp;x-signature=Neuny%2BfwJPXHMI2FBLWpFNZw4Lk%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-12">3.4 类型字面量 + as const（推荐）</h3>
<p>类型字面量就是一个对象，将一个对象断言（Type Assertion）为一个 <code>const</code>，此时这个对象的类型就是对象字面量类型，然后通过类型变换，达到即可以传入枚举值，又可以传入枚举类型的目的。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">METHOD</span> = {
  <span class="hljs-attr">ADD</span>:<span class="hljs-string">'add'</span>,
  <span class="hljs-comment">/**
  * <span class="hljs-doctag">@deprecated</span> 不再支持删除
  */</span>
  <span class="hljs-attr">DELETE</span>:<span class="hljs-string">'delete'</span>,
  <span class="hljs-attr">UPDATE</span>: <span class="hljs-string">'update'</span>,
  <span class="hljs-attr">QUERY</span>: <span class="hljs-string">'query'</span>
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">METHOD_TYPE</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-variable constant_">METHOD</span>[keyof <span class="hljs-keyword">typeof</span> <span class="hljs-variable constant_">METHOD</span>]

<span class="hljs-keyword">function</span> <span class="hljs-title function_">doAction</span>(<span class="hljs-params">method: METHOD_TYPE</span>) {
  <span class="hljs-comment">// some code</span>
}

<span class="hljs-title function_">doAction</span>(<span class="hljs-variable constant_">METHOD</span>.<span class="hljs-property">DELETE</span>) <span class="hljs-comment">// ✅ 可行，有 TSDoc 提示</span>
<span class="hljs-title function_">doAction</span>(<span class="hljs-string">'delete'</span>) <span class="hljs-comment">// ✅ 可行</span>
<span class="hljs-title function_">doAction</span>(<span class="hljs-string">'remove'</span>) <span class="hljs-comment">// ❌ 不行</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb5437de68b9408fae26ee1b50013ea9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXVycGh5Q2hlbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1748307699&amp;x-signature=Czc4dNvxVIInnflmP2qVQSrgkdQ%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-13">3.5 Class 类静态属性自定义实现</h3>
<p>还有一种方法，参考了 <a href="https://juejin.cn/user/475426363282808" target="_blank" title="https://juejin.cn/user/475426363282808">@Hamm</a> 提供的方法，即利用 TS 面向对象的特性，自定义实现一个枚举类，实际上这很类似于后端定义枚举的一般方式。这种方式具有很好的扩展性，自定义程度更高。</p>
<ol>
<li>
<p>定义枚举基类</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * 枚举基类
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumBase</span> {
  <span class="hljs-comment">/**
   * 枚举值
   */</span>
  <span class="hljs-keyword">private</span> value!: <span class="hljs-built_in">string</span>

  <span class="hljs-comment">/**
   * 枚举描述
   */</span>
  <span class="hljs-keyword">private</span> label!: <span class="hljs-built_in">string</span>

  <span class="hljs-comment">/**
   * 记录枚举
   */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">valueMap</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">EnumBase</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

  <span class="hljs-comment">/**
   * 构造函数
   * <span class="hljs-doctag">@param</span> value 枚举值
   * <span class="hljs-doctag">@param</span> label 枚举描述
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span>, label: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = label
    <span class="hljs-keyword">const</span> cls = <span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">EnumBase</span>
    <span class="hljs-keyword">if</span> (!cls.<span class="hljs-property">valueMap</span>.<span class="hljs-title function_">has</span>(value)) {
      cls.<span class="hljs-property">valueMap</span>.<span class="hljs-title function_">set</span>(value, <span class="hljs-variable language_">this</span>)
    }
  }

  <span class="hljs-comment">/**
   * 获取枚举值
   * <span class="hljs-doctag">@param</span> value 
   * <span class="hljs-doctag">@returns</span> 
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">getValue</span>(): <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>
  }

  <span class="hljs-comment">/**
   * 获取枚举描述
   * <span class="hljs-doctag">@param</span> value 
   * <span class="hljs-doctag">@returns</span> 
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">getLabel</span>(): <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span>
  }

  <span class="hljs-comment">/**
   * 根据枚举值转换为枚举
   * <span class="hljs-doctag">@param</span> this 
   * <span class="hljs-doctag">@param</span> value 
   * <span class="hljs-doctag">@returns</span> 
   */</span>
  <span class="hljs-keyword">static</span> convert&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EnumBase</span>&gt;(<span class="hljs-attr">this</span>: <span class="hljs-title function_">new</span>(...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; E, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>): E | <span class="hljs-literal">null</span> {
    <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">valueMap</span>.<span class="hljs-title function_">get</span>(value) || <span class="hljs-literal">null</span>
  }
}
</code></pre>
</li>
<li>
<p>继承实现具体的枚举（可根据需要扩展）</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">/**
 * 审核状态
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ENApproveState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EnumBase</span> {
  <span class="hljs-comment">/**
   * 未审核
   */</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-variable constant_">NOTAPPROVED</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ENApproveState</span>(<span class="hljs-string">'1'</span>, <span class="hljs-string">'未审核'</span>)
  <span class="hljs-comment">/**
   * 已审核
   */</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-variable constant_">APPROVED</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ENApproveState</span>(<span class="hljs-string">'2'</span>, <span class="hljs-string">'已审核'</span>)
  <span class="hljs-comment">/**
   * 审核失败
   */</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-variable constant_">FAILAPPROVE</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ENApproveState</span>(<span class="hljs-string">'3'</span>, <span class="hljs-string">'审核失败'</span>)
  <span class="hljs-comment">/***
   * 审核中
   */</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-variable constant_">APPROVING</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ENApproveState</span>(<span class="hljs-string">'4'</span>, <span class="hljs-string">'审核中'</span>)
}
</code></pre>
</li>
<li>
<p>使用</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-title function_">test</span>(<span class="hljs-string">'ENCancelState.NOCANCEL equal 1'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">expect</span>(<span class="hljs-title class_">ENApproveState</span>.<span class="hljs-property">NOTAPPROVED</span>.<span class="hljs-title function_">getValue</span>()).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">'1'</span>)
  <span class="hljs-title function_">expect</span>(<span class="hljs-title class_">ENApproveState</span>.<span class="hljs-property">APPROVING</span>.<span class="hljs-title function_">getValue</span>()).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">'4'</span>)
  <span class="hljs-title function_">expect</span>(<span class="hljs-title class_">ENApproveState</span>.<span class="hljs-property">FAILAPPROVE</span>.<span class="hljs-title function_">getLabel</span>()).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">'审核失败'</span>)
  <span class="hljs-title function_">expect</span>(<span class="hljs-title class_">ENApproveState</span>.<span class="hljs-title function_">convert</span>(<span class="hljs-string">'2'</span>)).<span class="hljs-title function_">toBe</span>(<span class="hljs-title class_">ENApproveState</span>.<span class="hljs-property">APPROVED</span>)
  <span class="hljs-title function_">expect</span>(<span class="hljs-title class_">ENApproveState</span>.<span class="hljs-title function_">convert</span>(<span class="hljs-string">'99'</span>)).<span class="hljs-title function_">toBe</span>(<span class="hljs-literal">null</span>)
})
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0c7b41eb5d9941d9964360b642520b4e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTXVycGh5Q2hlbg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1748307699&amp;x-signature=e6XC6PB7tv5YorhVebKiyQ1sF4I%3D" alt="image.png" loading="lazy"></p>
</li>
</ol>
<h2 data-id="heading-14">4. 总结</h2>
<ul>
<li>TS <strong>可擦除语法</strong> 是指 <code>type</code>、<code>interface</code>、<code>n:number</code> 等可以直接去掉的、仅在编译时存在、不会生成额外运行时代码的语法</li>
<li>TS <strong>不可擦除语法</strong> 是指 <code>enum</code>、<code>constructor(public x: number) {}</code> 等不可直接去除且会生成额外运行时代码的语法</li>
<li>Node.js 23.6.0 版本开始 <strong>默认支持直接执行可擦除语法</strong> 的 TS 文件</li>
<li><code>enum</code> 的替代方案有多种，取决于实际需求。用字面量类型 + <code>as const</code> 是比较常用的一种方案。</li>
</ul>
<p>TS 官方为了兼容 Node.js 23.6.0 这种可执行 TS 文件特性，出了 <code>erasableSyntaxOnly</code> 配置禁用不可擦除语法，反映了 TypeScript 官方对减少运行时开销和优化编译输出的关注，而不是要放弃 <code>enum</code>。</p>
<p>但或许未来就是要朝着这个方向把 enum 优化掉也说不定呢？</p>
<h2 data-id="heading-15">5. 参考链接</h2>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.disintegrator.dev%2Fposts%2Fode-to-typescript-enums%2F" target="_blank" title="https://blog.disintegrator.dev/posts/ode-to-typescript-enums/" ref="nofollow noopener noreferrer">An ode to typescript enums</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Frelease-notes%2Ftypescript-5-8.html%23the---erasablesyntaxonly-option" target="_blank" title="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-8.html#the---erasablesyntaxonly-option" ref="nofollow noopener noreferrer">TypeScript --erasablesyntaxonly-option</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2Fapi%2Ftypescript.html%23type-stripping" target="_blank" title="https://nodejs.org/api/typescript.html#type-stripping" ref="nofollow noopener noreferrer">Node.js type-stripping</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2Fen%2Fblog%2Frelease%2Fv23.6.0%23unflagging---experimental-strip-types" target="_blank" title="https://nodejs.org/en/blog/release/v23.6.0#unflagging---experimental-strip-types" ref="nofollow noopener noreferrer">Node.js --experimental-strip-types</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Fenums.html%23const-enums" target="_blank" title="https://www.typescriptlang.org/docs/handbook/enums.html#const-enums" ref="nofollow noopener noreferrer">TypeScript const-enums</a></li>
<li><a href="https://juejin.cn/post/7433233514348789795" target="_blank" title="https://juejin.cn/post/7433233514348789795">TypeScript使用枚举封装和装饰器优雅的定义字典</a></li>
</ul></div></div>