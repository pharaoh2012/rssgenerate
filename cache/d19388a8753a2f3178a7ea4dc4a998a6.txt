
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/heavenYJJ/p/18634226" title="发布于 2024-12-27 08:45">
    <span role="heading" aria-level="2">面试官：不会“不定高”虚拟列表，你在简历上面提他干嘛？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前言">前言</h1>
<p>很多同学将虚拟列表当做亮点写在简历上面，但是却不知道如何手写，那么这个就不是加分项而是减分项了。在上一篇文章欧阳教会你 <a href="https://mp.weixin.qq.com/s/unNbvl6L6vLHXcnyheI1UQ" target="_blank" rel="noopener nofollow">如何实现一个定高虚拟列表</a> ，但是实际项目中更多的是<code>不定高虚拟列表</code>，这篇文章欧阳来教你不定高如何实现。PS：建议先看看欧阳的上一篇 <a href="https://mp.weixin.qq.com/s/unNbvl6L6vLHXcnyheI1UQ" target="_blank" rel="noopener nofollow">如何实现一个定高虚拟列表</a> 后再来看这篇效果更佳。</p>
<p><strong>欧阳也在找工作，坐标成都求内推！</strong></p>
<h1 id="什么是不定高虚拟列表">什么是不定高虚拟列表</h1>
<p>不定高的意思很简单，就是不知道每一项item的具体高度，如下图：<br>
<img src="https://img2024.cnblogs.com/blog/1217259/202412/1217259-20241226213229649-445909208.png" alt="v1" loading="lazy"></p>
<p>现在我们有个问题，<strong>在不定高的情况下我们就不能根据当前滚动条的<code>scrollTop</code>去计算可视区域里面实际渲染的第一个item的index位置，也就是<code>start</code>的值。</strong></p>
<p>没有<code>start</code>，那么就无法实现在滚动的时候只渲染可视区域的那几个item了。</p>
<h1 id="预估高度">预估高度</h1>
<p>既然我们不知道每个item的高度，那么就采用<code>预估高度</code>的方式去实现。比如这样：</p>
<pre><code class="language-javascript">const { listData, itemSize } = defineProps({
  // 列表数据
  listData: {
    type: Array,
    default: () =&gt; [],
  },
  // 预估item高度，不是真实item高度
  itemSize: {
    type: Number,
    default: 300,
  },
});
</code></pre>
<p>还是和上一篇一样的套路，计算出当前可视区域的高度<code>containerHeight</code>，然后结合预估的<code>itemSize</code>就可以得到当前可视区域里面渲染的item数量。代码如下：</p>
<pre><code class="language-javascript">const renderCount = computed(() =&gt; Math.ceil(containerHeight.value / itemSize));
</code></pre>
<p>注意：由于我们是预估的高度，所以这个<code>renderCount</code>的数量是不准的。</p>
<p>如果预估的高度比实际高太多，那么实际渲染的item数量就会不够，导致页面下方出现白屏的情况。</p>
<p>如果预估的高度太小，那么这里的item数量就会渲染的太多了，性能又没之前那么好。</p>
<p>所以预估item高度需要根据实际业务去给一个适当的值，理论上是宁可预估小点，也不预估的大了（大了会出现白屏）。</p>
<p>start初始值为0，并且算出了<code>renderCount</code>，此时我们也就知道了可视区域渲染的最后一个<code>end</code>的值。如下：</p>
<pre><code class="language-javascript">const end = computed(() =&gt; start.value + renderCount.value);
</code></pre>
<p>和上一篇一样计算end时在下方多渲染了一个item，第一个item有一部分滚出可视区域的情况时，如果不多渲染可能就会出现白屏的情况。</p>
<p>有了<code>start</code>和<code>end</code>，那么就知道了可视区域渲染的<code>renderList</code>，代码如下：</p>
<pre><code class="language-javascript">const renderList = computed(() =&gt; listData.slice(start.value, end.value + 1));
</code></pre>
<p>这样我们就知道了，初始化时可视区域应该渲染哪些item了，但是因为我们之前是给每个item<strong>预估高度</strong>，所以我们应该将这些高度的值<strong>纠正过来</strong>。</p>
<h1 id="更新高度">更新高度</h1>
<p>为了记录不定高的list里面的每个item的高度，所以我们需要一个数组来存每个item的高度。所以我们需要定义一个<code>positions</code>数组来存这些值。</p>
<p>既然都存了每个item的高度，那么同样可以使用<code>top</code>、<code>bottom</code>这两个字段去记录每个item在列表中的<code>开始位置</code>和<code>结束位置</code>。注意<code>bottom - top</code>的值肯定等于<code>height</code>的值。</p>
<p>还有一个<code>index</code>字段记录每个item的index的值。<code>positions</code>定义如下：</p>
<pre><code class="language-javascript">const positions = ref&lt;
  {
    index: number;
    height: number;
    top: number;
    bottom: number;
  }[]
&gt;([]);
</code></pre>
<p><code>positions</code>的初始化值为空数组，那么什么时候给这个数组赋值呢？</p>
<p>答案很简单，虚拟列表渲染的是props传入进来的<code>listData</code>。所以我们watch监听<code>listData</code>，加上<code>immediate: true</code>。这样就可以实现初始化时给<code>positions</code>赋值，代码如下：</p>
<pre><code class="language-javascript">watch(() =&gt; listData, initPosition, {
  immediate: true,
});

function initPosition() {
  positions.value = [];
  listData.forEach((_item, index) =&gt; {
    positions.value.push({
      index,
      height: itemSize,
      top: index * itemSize,
      bottom: (index + 1) * itemSize,
    });
  });
}
</code></pre>
<p>遍历<code>listData</code>结合预估的<code>itemSize</code>，我们就可以得出每一个item里面的<code>height</code>、<code>top</code>、<code>bottom</code>这几个字段的值。</p>
<p>还有一个问题，我们需要一个元素来撑开滚动条。在定高的虚拟列表中我们是通过<code>itemSize * listData.length</code>得到的。显然这里不能那样做了，由于<code>positions</code>数组中存的是所有item的位置，<strong>那么最后一个item的bottom的值就是列表的真实高度</strong>。前面也是不准的，会随着我们纠正<code>positions</code>中的值后他就是越来越准的了。</p>
<p>所以列表的真实高度为：</p>
<pre><code class="language-javascript">const listHeight = computed(
  () =&gt; positions.value[positions.value.length - 1].bottom
);
</code></pre>
<p>此时<code>positions</code>数组中就已经记录了每个item的具体位置，虽然这个位置是错的。接下来我们就需要将这些错误的值纠正过来，如何纠正呢？</p>
<p>答案很简单，使用Vue的<code>onUpdated</code>钩子函数，这个钩子函数会在<strong>响应式状态变更而更新其 DOM 树之后调用。</strong>也就是会在<code>renderList</code>渲染成DOM后触发！</p>
<p>此时这些item已经渲染成了DOM节点，那么我们就可以遍历这些item的DOM节点拿到每个item的真实高度。都知道每个item的真实高度了，那么也就能够更新里面所有item的<code>top</code>和<code>bottom</code>了。代码如下：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div ref="container" class="container" @scroll="handleScroll($event)"&gt;
    &lt;div class="placeholder" :style="{ height: listHeight + 'px' }"&gt;&lt;/div&gt;
    &lt;div class="list-wrapper" :style="{ transform: getTransform }"&gt;
      &lt;div
        class="card-item"
        v-for="item in renderList"
        :key="item.index"
        ref="itemRefs"
        :data-index="item.index"
      &gt;
        &lt;span style="color: red"
          &gt;{{ item.index }}
          &lt;img width="200" :src="item.imgUrl" alt="" /&gt;
        &lt;/span&gt;
        {{ item.value }}
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
onUpdated(() =&gt; {
  updatePosition();
});

function updatePosition() {
  itemRefs.value.forEach((el) =&gt; {
    const index = +el.getAttribute("data-index");
    const realHeight = el.getBoundingClientRect().height;
    let diffVal = positions.value[index].height - realHeight;
    const curItem = positions.value[index];
    if (diffVal !== 0) {
      // 说明item的高度不等于预估值
      curItem.height = realHeight;
      curItem.bottom = curItem.bottom - diffVal;
      for (let i = index + 1; i &lt; positions.value.length - 1; i++) {
        positions.value[i].top = positions.value[i].top - diffVal;
        positions.value[i].bottom = positions.value[i].bottom - diffVal;
      }
    }
  });
}
&lt;/script&gt;
</code></pre>
<p>使用<code>:data-index="item.index"</code>将<code>index</code>绑定到item上面，更新时就可以通过<code>+el.getAttribute("data-index")</code>拿到对应item的<code>index</code>。</p>
<p><code>itemRefs</code>中存的是所有item的DOM元素，遍历他就可以拿到每一个item，然后拿到每个item在长列表中的<code>index</code>和真实高度<code>realHeight</code>。</p>
<p><code>diffVal的值是预估的高度比实际的高度大多少</code>，如果<code>diffVal</code>的值不等于0，说明预估的高度不准。此时就需要将当前item的高度<code>height</code>更新了，由于高度只会影响<code>bottom</code>的值，所以只需要更新当前item的<code>height</code>和<code>bottom</code>。</p>
<p>由于当前item的高度变了，假如<code>diffVal</code>的值为正值，说明我们预估的高度多了。此时我们需要从当前item的下一个元素开始遍历，直到遍历完整个长列表。我们预估多了，那么只需要将后面的所有item整体都向上移一移，移动的距离就是预估的差值<code>diffVal</code>。</p>
<p>所以这里需要从<code>index + 1</code>开始遍历，将遍历到的所有元素的<code>top</code>和<code>bottom</code>的值都减去<code>diffVal</code>。</p>
<p>将可视区域渲染的所有item都遍历一遍，将每个item的高度和位置都纠正过来，同时会将后面没有渲染到的item的<code>top</code>和<code>bottom</code>都纠正过来，这样就实现了高度的更新。理论上从头滚到尾，那么整个长列表里面的所有位置和高度都纠正完了。</p>
<h1 id="开始滚动">开始滚动</h1>
<p>通过前面我们已经实现了预估高度值的纠正，渲染过的item的高度和位置都是纠正过后的了。此时我们需要在滚动后如何计算出新的<code>start</code>的位置，以及<code>offset</code>偏移量的值。</p>
<p>还是和定高同样的套路，<strong>当滚动条在item中间滚动时复用浏览器的滚动条，从一个item滚到另外一个item时才需要更新start的值以及offset偏移量的值。如果你看不懂这句话，建议先看我上一篇<a href="https://mp.weixin.qq.com/s/unNbvl6L6vLHXcnyheI1UQ" target="_blank" rel="noopener nofollow">如何实现一个定高虚拟列表</a> 文章。</strong></p>
<p>此时应该如何计算最新的<code>start</code>值呢？</p>
<p>很简单！在<code>positions</code>中存了两个字段分别是<code>top</code>和<code>bottom</code>，分别表示当前item的<code>开始位置</code>和<code>结束位置</code>。如果当前滚动条的<code>scrollTop</code>刚好在<code>top</code>和<code>bottom</code>之间，也就是<code>scrollTop &gt;= top &amp;&amp; scrollTop &lt; bottom</code>，那么是不是就说明当前刚好滚到这个item的位置呢。</p>
<p>并且由于在<code>positions</code>数组中<code>bottom</code>的值是递增的，那么问题不就变成了查找第一个item的<code>scrollTop &lt; bottom</code>。所以我们得出：</p>
<pre><code class="language-javascript">function getStart(scrollTop) {
  return positions.value.findIndex((item) =&gt; scrollTop &lt; item.bottom);
}
</code></pre>
<p>每次scroll滚动都会触发一次这个查找，那么我们可以优化上面的算法吗？</p>
<p><code>positions</code>数组中的<code>bottom</code>字段是递增的，这很符合<code>二分查找</code>的规律。不了解二分查找的同学可以看看leetcode上面的这道题： <a href="https://leetcode.cn/problems/search-insert-position/description/" target="_blank" rel="noopener nofollow">https://leetcode.cn/problems/search-insert-position/description/</a>。</p>
<p>所以上面的代码可以优化成这样：</p>
<pre><code class="language-javascript">function getStart(scrollTop) {
  let left = 0;
  let right = positions.value.length - 1;
  while (left &lt;= right) {
    const mid = Math.floor((left + right) / 2);
    if (positions.value[mid].bottom === scrollTop) {
      return mid + 1;
    } else if (positions.value[mid].bottom &lt; scrollTop) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left;
}
</code></pre>
<p>和定高的虚拟列表一样，当在<code>start</code>的item中滚动时直接复用浏览器的滚动，无需做任何事情。所以此时的<code>offset</code>偏移量就应该等于当前<code>start</code>的item的<code>top</code>值，也就是<code>start</code>的item前面的所有item加起来的高度。所以得出<code>offset</code>的值为：</p>
<pre><code class="language-javascript">offset.value = positions.value[start.value].top;
</code></pre>
<p>可能有的小伙伴会迷惑，在<code>start</code>的item中的滚动值为什么不算到<code>offset</code>偏移中去呢？</p>
<p>因为在<code>start</code>的item范围内滚动时都是直接使用的浏览器滚动，已经有了scrollTop，所以无需加到<code>offset</code>偏移中去。</p>
<p>所以我们得出当scroll事件触发时代码如下：</p>
<pre><code class="language-javascript">function handleScroll(e) {
  const scrollTop = e.target.scrollTop;
  start.value = getStart(scrollTop);
  offset.value = positions.value[start.value].top;
}
</code></pre>
<p>同样<code>offset</code>偏移值使用<code>translate3d</code>应用到可视区域的div上面，代码如下：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div ref="container" class="container" @scroll="handleScroll($event)"&gt;
    &lt;div class="placeholder" :style="{ height: listHeight + 'px' }"&gt;&lt;/div&gt;
    &lt;div class="list-wrapper" :style="{ transform: getTransform }"&gt;
      ...省略
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
const props = defineProps({
  offset: {
    type: Number,
    default: 0,
  },
});
const getTransform = computed(() =&gt; `translate3d(0,${props.offset}px,0)`);
&lt;/script&gt;
</code></pre>
<p>这个是最终的运行效果图：<br>
<img src="https://img2024.cnblogs.com/blog/1217259/202412/1217259-20241226213246891-65797667.gif" alt="demo" loading="lazy"></p>
<p>完整的父组件代码如下：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div style="height: 100vh; width: 100vw"&gt;
    &lt;VirtualList :listData="data" :itemSize="50" /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import VirtualList from "./dynamic.vue";
import { faker } from "@faker-js/faker";
import { ref } from "vue";

const data = ref([]);
for (let i = 0; i &lt; 1000; i++) {
  data.value.push({
    index: i,
    value: faker.lorem.sentences(),
  });
}
&lt;/script&gt;

&lt;style&gt;
html {
  height: 100%;
}
body {
  height: 100%;
  margin: 0;
}
#app {
  height: 100%;
}
&lt;/style&gt;
</code></pre>
<p>完整的虚拟列表子组件代码如下：</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div ref="container" class="container" @scroll="handleScroll($event)"&gt;
    &lt;div class="placeholder" :style="{ height: listHeight + 'px' }"&gt;&lt;/div&gt;
    &lt;div class="list-wrapper" :style="{ transform: getTransform }"&gt;
      &lt;div
        class="card-item"
        v-for="item in renderList"
        :key="item.index"
        ref="itemRefs"
        :data-index="item.index"
      &gt;
        &lt;span style="color: red"
          &gt;{{ item.index }}
          &lt;img width="200" :src="item.imgUrl" alt="" /&gt;
        &lt;/span&gt;
        {{ item.value }}
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, computed, watch, onMounted, onUpdated } from "vue";
const { listData, itemSize } = defineProps({
  // 列表数据
  listData: {
    type: Array,
    default: () =&gt; [],
  },
  // 预估item高度，不是真实item高度
  itemSize: {
    type: Number,
    default: 300,
  },
});

const container = ref(null);
const containerHeight = ref(0);
const start = ref(0);
const offset = ref(0);
const itemRefs = ref();
const positions = ref&lt;
  {
    index: number;
    height: number;
    top: number;
    bottom: number;
  }[]
&gt;([]);

const end = computed(() =&gt; start.value + renderCount.value);
const renderList = computed(() =&gt; listData.slice(start.value, end.value + 1));
const renderCount = computed(() =&gt; Math.ceil(containerHeight.value / itemSize));
const listHeight = computed(
  () =&gt; positions.value[positions.value.length - 1].bottom
);
const getTransform = computed(() =&gt; `translate3d(0,${offset.value}px,0)`);

watch(() =&gt; listData, initPosition, {
  immediate: true,
});

function handleScroll(e) {
  const scrollTop = e.target.scrollTop;
  start.value = getStart(scrollTop);
  offset.value = positions.value[start.value].top;
}

function getStart(scrollTop) {
  let left = 0;
  let right = positions.value.length - 1;
  while (left &lt;= right) {
    const mid = Math.floor((left + right) / 2);
    if (positions.value[mid].bottom === scrollTop) {
      return mid + 1;
    } else if (positions.value[mid].bottom &lt; scrollTop) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left;
}

function initPosition() {
  positions.value = [];
  listData.forEach((_item, index) =&gt; {
    positions.value.push({
      index,
      height: itemSize,
      top: index * itemSize,
      bottom: (index + 1) * itemSize,
    });
  });
}

function updatePosition() {
  itemRefs.value.forEach((el) =&gt; {
    const index = +el.getAttribute("data-index");
    const realHeight = el.getBoundingClientRect().height;
    let diffVal = positions.value[index].height - realHeight;
    const curItem = positions.value[index];
    if (diffVal !== 0) {
      // 说明item的高度不等于预估值
      curItem.height = realHeight;
      curItem.bottom = curItem.bottom - diffVal;
      for (let i = index + 1; i &lt; positions.value.length - 1; i++) {
        positions.value[i].top = positions.value[i].top - diffVal;
        positions.value[i].bottom = positions.value[i].bottom - diffVal;
      }
    }
  });
}

onMounted(() =&gt; {
  containerHeight.value = container.value.clientHeight;
});

onUpdated(() =&gt; {
  updatePosition();
});
&lt;/script&gt;

&lt;style scoped&gt;
.container {
  height: 100%;
  overflow: auto;
  position: relative;
}

.placeholder {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  z-index: -1;
}

.card-item {
  padding: 10px;
  color: #777;
  box-sizing: border-box;
  border-bottom: 1px solid #e1e1e1;
}
&lt;/style&gt;
</code></pre>
<h1 id="总结">总结</h1>
<p>这篇文章我们讲了不定高的虚拟列表如何实现，首先给每个item设置一个预估高度<code>itemSize</code>。然后根据传入的长列表数据<code>listData</code>初始化一个<code>positions</code>数组，数组中的<code>top</code>、<code>bottom</code>、<code>height</code>等属性表示每个item的位置。然后根据可视区域的高度加上<code>itemSize</code>算出可视区域内可以渲染多少<code>renderCount</code>个item。接着就是在<code>onUpdated</code>钩子函数中根据每个item的实际高度去修正<code>positions</code>数组中的值。</p>
<p>在滚动时查找第一个item的bottom大于scrollTop，这个item就是<code>start</code>的值。<code>offset</code>偏移的值为<code>start</code>的<code>top</code>属性。</p>
<p>值得一提的是如果不定高的列表中有图片就不能在<code>onUpdated</code>钩子函数中修正<code>positions</code>数组中的值，而是应该监听图片加载完成后再去修正<code>positions</code>数组。可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver" target="_blank" rel="noopener nofollow">ResizeObserver</a> 去监听渲染的这一堆item，注意<code>ResizeObserver</code>的回调会触发两次，第一次为渲染item的时候，第二次为item中的图片加载完成后。</p>
<p>关注公众号：【前端欧阳】，给自己一个进阶vue的机会</p>
<p><img src="https://img2024.cnblogs.com/blog/1217259/202406/1217259-20240606112202286-1547217900.jpg" alt="" loading="lazy"></p>
<p>另外欧阳写了一本开源电子书<a href="https://vue-compiler.iamouyang.cn/" target="_blank" rel="noopener nofollow">vue3编译原理揭秘</a>，看完这本书可以让你对vue编译的认知有质的提升。这本书初、中级前端能看懂，完全免费，只求一个star。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.011343978645833334" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-27 08:46">2024-12-27 08:45</span>&nbsp;
<a href="https://www.cnblogs.com/heavenYJJ">前端欧阳</a>&nbsp;
阅读(<span id="post_view_count">14</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18634226" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18634226);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18634226', targetLink: 'https://www.cnblogs.com/heavenYJJ/p/18634226', title: '面试官：不会“不定高”虚拟列表，你在简历上面提他干嘛？' })">举报</a>
</div>
        