
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tianqing/p/18653852" title="发布于 2025-01-13 09:06">
    <span role="heading" aria-level="2">.NET 9 new features-Microsoft.ML.Tokenizers 库</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>在 .NET 9 中，微软引入了 <code>Microsoft.ML.Tokenizers</code> 库，为 .NET 开发者提供了强大的文本标记化功能。</p>
<p><strong><span style="font-size: 18px"><span style="font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif">一、什么是Microsoft.ML.Tokenizers</span></span></strong></p>
<p><code>　　　Microsoft.ML.Tokenizers</code> 是一个用于文本标记化的库，是 .NET 生态系统中的一个强大库旨在将文本转换为令牌（tokens）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;以便在自然语言处理（NLP）任务中使用。该库支持多种标记化算法，包括字节对编码（BPE）、SentencePiece 和 WordPiece，满足不同模型和应用的需求。</p>
<h2>二、主要应用场景</h2>
<ol>
<li>
<p><strong>自然语言处理（NLP）</strong>：在训练和推理阶段，将文本转换为模型可处理的令牌格式。</p>
</li>
<li>
<p><strong>预处理步骤</strong>：在文本分析、情感分析、机器翻译等任务中，对输入文本进行标记化处理。</p>
</li>
<li>
<p><strong>自定义词汇表</strong>：开发者可以导入自定义词汇表，使用 BPE Tokenizer 处理特定领域的文本数据。</p>
</li>
</ol>
<h2>三、支持的模型和服务</h2>
<p style="margin-left: 30px"><code>Microsoft.ML.Tokenizers</code> 针对多种流行的模型系列进行了优化，包括：</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>
<p><strong>GPT 系列</strong>：如 GPT-4、GPT-o1 等。</p>
</li>
<li>
<p><strong>Llama 系列</strong>。</p>
</li>
<li>
<p><strong>Phi 系列</strong>。</p>
</li>
<li>
<p><strong>Bert 系列</strong>。</p>
</li>
</ul>
</li>
</ul>
<p style="margin-left: 30px">此外，该库还与其他 AI 服务集成，如 Azure、OpenAI 等，为开发者提供统一的 C# 抽象层，简化与 AI 服务的交互。</p>
<h2>四、主要类Class</h2>
<h3 style="margin-left: 30px">1. <code>Tokenizer</code> 类</h3>
<p style="margin-left: 30px"><code>Tokenizer</code> 类充当文本处理的管道，接受原始文本输入并输出 <code>TokenizerResult</code> 对象。它允许设置不同的模型、预处理器和规范化器，以满足特定需求。</p>
<p style="margin-left: 30px"><strong>主要方法：</strong></p>
<ul>
<li style="list-style-type: none">
<ul>
<li>
<p><code>Encode(string text)</code>: 将输入文本编码为包含令牌列表、令牌 ID 和令牌偏移映射的对象。</p>
</li>
<li>
<p><code>Decode(IEnumerable&lt;int&gt; ids, bool skipSpecialTokens = true)</code>: 将给定的令牌 ID 解码回字符串。</p>
</li>
<li>
<p><code>TrainFromFiles(Trainer trainer, ReportProgress reportProgress, params string[] files)</code>: 使用输入文件训练标记器模型。</p>
</li>
</ul>
</li>
</ul>
<p style="margin-left: 30px"><strong>主要属性：</strong></p>
<ul>
<li style="list-style-type: none">
<ul>
<li>
<p><code>Model</code>: 获取或设置标记器使用的模型。</p>
</li>
<li>
<p><code>PreTokenizer</code>: 获取或设置标记器使用的预处理器。</p>
</li>
<li>
<p><code>Normalizer</code>: 获取或设置标记器使用的规范化器。</p>
</li>
<li>
<p><code>Decoder</code>: 获取或设置标记器使用的解码器。</p>
</li>
</ul>
</li>
</ul>
<h3 style="margin-left: 30px">2. <code>Model</code> 类</h3>
<p style="margin-left: 30px"><code>Model</code> 类是标记化过程中使用的模型的抽象基类，如 BPE、WordPiece 或 Unigram。具体模型（如 <code>Bpe</code>）继承自该类，并实现其方法。</p>
<p style="margin-left: 30px"><strong>主要方法：</strong></p>
<ul>
<li style="list-style-type: none">
<ul>
<li>
<p><code>GetTrainer()</code>: 获取用于训练模型的训练器对象。</p>
</li>
<li>
<p><code>GetVocab()</code>: 获取将令牌映射到 ID 的词汇表。</p>
</li>
<li>
<p><code>GetVocabSize()</code>: 获取词汇表的大小。</p>
</li>
<li>
<p><code>TokenToId(string token)</code>: 将令牌映射到标记化 ID。</p>
</li>
<li>
<p><code>IdToToken(int id, bool skipSpecialTokens = true)</code>: 将标记化 ID 映射到令牌。</p>
</li>
<li>
<p><code>Tokenize(string sequence)</code>: 将字符串序列标记化为令牌列表。</p>
</li>
<li>
<p><code>Save(string vocabPath, string mergesPath)</code>: 将模型数据保存到词汇和合并文件中。</p>
</li>
</ul>
</li>
</ul>
<h3 style="margin-left: 30px">3. <code>Bpe</code> 类</h3>
<p style="margin-left: 30px"><code>Bpe</code> 类表示字节对编码（Byte Pair Encoding）模型，是 <code>Model</code> 类的具体实现之一。它用于将文本拆分为子词单元，以提高对未登录词的处理能力。</p>
<p style="margin-left: 30px"><strong>主要属性：</strong></p>
<ul>
<li style="list-style-type: none">
<ul>
<li>
<p><code>UnknownToken</code>: 获取或设置未知令牌。在遇到未知字符时使用。</p>
</li>
<li>
<p><code>FuseUnknownTokens</code>: 获取或设置是否允许多个未知令牌融合。</p>
</li>
<li>
<p><code>ContinuingSubwordPrefix</code>: 用于仅存在于另一个子词后面的任何子词的可选前缀。</p>
</li>
<li>
<p><code>EndOfWordSuffix</code>: 用于描述词尾子词特征的可选后缀。</p>
</li>
</ul>
</li>
</ul>
<p style="margin-left: 30px"><strong>主要方法：</strong></p>
<ul>
<li style="list-style-type: none">
<ul>
<li>
<p><code>Save(string vocabPath, string mergesPath)</code>: 将模型数据保存到词汇和合并文件中。</p>
</li>
<li>
<p><code>Tokenize(string sequence)</code>: 将字符串序列标记化为令牌列表。</p>
</li>
<li>
<p><code>GetTrainer()</code>: 获取用于训练模型的训练器对象，并生成词汇和合并数据。</p>
</li>
</ul>
</li>
</ul>
<h3 style="margin-left: 30px">4. <code>EnglishRoberta</code> 类</h3>
<p style="margin-left: 30px"><code>EnglishRoberta</code> 类是专门为英语 Roberta 模型设计的标记器模型。它继承自 <code>Model</code> 类，并实现了特定于 Roberta 的标记化逻辑。</p>
<p style="margin-left: 30px"><strong>主要属性：</strong></p>
<ul>
<li style="list-style-type: none">
<ul>
<li>
<p><code>PadIndex</code>: 获取符号列表中填充符号的索引。</p>
</li>
<li>
<p><code>SymbolsCount</code>: 获取符号列表的长度。</p>
</li>
</ul>
</li>
</ul>
<p style="margin-left: 30px"><strong>主要方法：</strong></p>
<ul>
<li style="list-style-type: none">
<ul>
<li>
<p><code>AddMaskSymbol(string maskSymbol)</code>: 将掩码符号添加到符号列表。</p>
</li>
<li>
<p><code>IdsToOccurrenceRanks(IReadOnlyList&lt;int&gt; ids)</code>: 将令牌 ID 列表转换为最高出现次数排名。</p>
</li>
<li>
<p><code>OccurrenceRanksIds(IReadOnlyList&lt;int&gt; ranks)</code>: 将最高出现次数排名的列表转换为令牌 ID 列表。</p>
</li>
<li>
<p><code>Save(string vocabPath, string mergesPath)</code>: 将模型数据保存到词汇、合并和匹配项映射文件中。&nbsp;</p>
</li>
</ul>
</li>
</ul>
<h3 style="margin-left: 30px">5. <code>RobertaPreTokenizer</code> 类</h3>
<p style="margin-left: 30px"><code>RobertaPreTokenizer</code> 类是为英语 Roberta 标记器设计的预处理器。它负责在标记化之前对文本进行初步拆分和处理。</p>
<p style="margin-left: 30px"><strong>主要方法：</strong></p>
<ul>
<li style="list-style-type: none">
<ul>
<li><code>PreTokenize(string text)</code>: 对输入文本进行预标记化处理。</li>
</ul>
</li>
</ul>
<h3 style="margin-left: 30px">6. <code>Split</code> 类</h3>
<p style="margin-left: 30px"><code>Split</code> 类表示将原始字符串拆分后的子字符串。每个子字符串由一个标记表示，最终可能代表原始输入字符串的各个部分。</p>
<p style="margin-left: 30px"><strong>主要属性：</strong></p>
<ul>
<li style="list-style-type: none">
<ul>
<li><code>TokenString</code>: 获取基础拆分令牌。</li>
</ul>
</li>
</ul>
<p><strong><span style="font-size: 18px">&nbsp;五、示例代码</span></strong></p>
<p>&nbsp; &nbsp; 使用 <code>Microsoft.ML.Tokenizers</code> 库对文本进行标记化，以适配 GPT-4 模型，可以按照以下步骤进行：</p>
<ol>
<li>
<p><strong>安装必要的 NuGet 包</strong>：确保项目引用了 <code>Microsoft.ML.Tokenizers</code> 包。</p>
</li>
<li>
<p><strong>加载 GPT-4 的词汇表和合并对文件</strong>：从官方或可信来源获取 GPT-4 模型的词汇表（<code>vocab.json</code>）和合并对（<code>merges.txt</code>）文件。</p>
</li>
<li>
<p><strong>初始化 BPE 模型并加载词汇表</strong>：使用 <code>Microsoft.ML.Tokenizers</code> 库中的 <code>Bpe</code> 类加载词汇表和合并对文件。</p>
</li>
<li>
<p><strong>创建标记器并进行文本标记化和解码</strong>：使用 <code>Tokenizer</code> 类对输入文本进行标记化，并根据需要解码回原始文本。</p>
</li>
</ol>
<p>&nbsp; &nbsp; 以下是示例代码：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> System;
</span><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> Microsoft.ML.Tokenizers;

</span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Program
{
    </span><span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> Main(<span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)">[] args)
    {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 初始化 BPE 模型</span>
        <span style="color: rgba(0, 0, 255, 1)">var</span> bpe = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Bpe();

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 加载 GPT-4 的词汇表和合并对文件</span>
        bpe.Load(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">path_to_vocab.json</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">path_to_merges.txt</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 创建标记器</span>
        <span style="color: rgba(0, 0, 255, 1)">var</span> tokenizer = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Tokenizer(bpe);

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输入文本</span>
        <span style="color: rgba(0, 0, 255, 1)">var</span> inputText = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">这是一个用于测试的文本。</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 对文本进行标记化</span>
        <span style="color: rgba(0, 0, 255, 1)">var</span> encoded =<span style="color: rgba(0, 0, 0, 1)"> tokenizer.Encode(inputText);

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出标记化结果</span>
        Console.WriteLine(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Tokens:</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">foreach</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> token <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> encoded.Tokens)
        {
            Console.WriteLine(token);
        }

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 解码回原始文本</span>
        <span style="color: rgba(0, 0, 255, 1)">var</span> decodedText =<span style="color: rgba(0, 0, 0, 1)"> tokenizer.Decode(encoded.Ids);
        Console.WriteLine($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Decoded Text: {decodedText}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
    }
}</span></pre>
</div>
<ul>
<li>
<p><strong>路径设置</strong>：将 <code>"path_to_vocab.json"</code> 和 <code>"path_to_merges.txt"</code> 替换为实际的文件路径。</p>
</li>
<li>
<p><strong>词汇表和合并对文件的获取</strong>：确保从官方或可信来源获取与 GPT-4 模型兼容的词汇表和合并对文件。</p>
</li>
<li>
<p><strong>模型兼容性</strong>：虽然此代码使用了通用的 BPE 标记器，但在实际应用中，可能需要根据 GPT-4 模型的具体要求进行调整。</p>
</li>
</ul>
<p>周国庆</p>
<p>2025/1/6</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07548262290046297" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-13 09:06">2025-01-13 09:06</span>&nbsp;
<a href="https://www.cnblogs.com/tianqing">Eric zhou</a>&nbsp;
阅读(<span id="post_view_count">139</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18653852" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18653852);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18653852', targetLink: 'https://www.cnblogs.com/tianqing/p/18653852', title: '.NET 9 new features-Microsoft.ML.Tokenizers 库' })">举报</a>
</div>
        