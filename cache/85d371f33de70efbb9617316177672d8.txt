
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/seven97-top/p/18992744" title="发布于 2025-07-21 09:00">
    <span role="heading" aria-level="2">char和varchar的区别?VARCHAR(100)和 VARCHAR(10)的区别？Mysql字段类型20连问</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="整数类型的-unsigned-属性有什么用">整数类型的 UNSIGNED 属性有什么用？</h2>
<p>MySQL 中的整数类型可以使用可选的 UNSIGNED 属性来表示不允许负值的无符号整数。使用 UNSIGNED 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。</p>
<p>例如， TINYINT UNSIGNED 类型的取值范围是 0 ~ 255，而普通的 TINYINT 类型的值范围是 -128 ~ 127。INT UNSIGNED 类型的取值范围是 0 ~ 4,294,967,295，而普通的 INT 类型的值范围是 -2,147,483,648 ~ 2,147,483,647。</p>
<p>对于从 0 开始递增的 ID 列，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。</p>
<h2 id="char和varchar的区别">char和varchar的区别</h2>
<p>CHAR</p>
<ul>
<li>CHAR类型用于存储固定长度字符串：MySQL总是<strong>根据定义的字符串长度分配足够的空间</strong>。当存储CHAR值时，MySQL会删除字符串中的末尾空格同时，CHAR值会根据需要采用空格进行剩余空间填充，以方便比较和检索。但正因为其长度固定，所以会占据多余的空间，也是一种空间换时间的策略；</li>
<li>CHAR适合存储很短或长度近似的字符串。例如，<strong>CHAR非常适合存储密码的MD5值、定长的身份证等，因为这些是定长的值</strong>。</li>
<li>对于经常变更的数据，CHAR也比VARCHAR更好，因为定长的CHAR类型占用磁盘的存储空间是连续分配的，不容易产生碎片。</li>
<li>对于非常短的列，CHAR比VARCHAR在存储空间上也更有效率。例如用CHAR(1)来存储只有Y和N的值，如果采用单字节字符集只需要一个字节，但是VARCHAR(1)却需要两个字节，因为还有一个记录长度的额外字节。</li>
</ul>
<p>VARCHAR：</p>
<ul>
<li>
<p>VARCHAR类型用于存储可变长度字符串，是最常见的字符串数据类型。它<strong>比固定长度类型更节省空间</strong>，因为它仅使用必要的空间(根据实际字符串的长度改变存储空间)。</p>
</li>
<li>
<p>VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。假设采用latinl字符集，一个VARCHAR(10)的列需要11个字节的存储空间。VARCHAR(1000)的列则需要1002 个字节，因为需要2个字节存储长度信息。</p>
</li>
<li>
<p>VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是变长的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，在这种情况下，不同的存储引擎的处理方式是不一样的。例如，MylSAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。</p>
</li>
<li>
<p>操作内存的方式：对于varchar数据类型来说，硬盘上的存储空间虽然都是根据字符串的实际长度来存储空间的，但在内存中是根据varchar类型定义的长度来分配占用的内存空间的，而不是根据字符串的实际长度来分配的。显然，这对于排序和临时表会较大的性能影响。</p>
</li>
</ul>
<h2 id="varchar100和-varchar10的区别是什么">VARCHAR(100)和 VARCHAR(10)的区别是什么？</h2>
<p>VARCHAR(100)和 VARCHAR(10)都是变长类型，表示能存储最多 100 个字符和 10 个字符。因此，VARCHAR (100) 可以满足更大范围的字符存储需求，有更好的业务拓展性。而 VARCHAR(10)存储超过 10 个字符时，就需要修改表结构才可以。</p>
<p>虽说 VARCHAR(100)和 VARCHAR(10)能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点。</p>
<p>不过，VARCHAR(100) 会消耗更多的内存。这是因为 VARCHAR 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，VARCHAR(100)是按照 100 这个长度来进行的，也就会消耗更多内存。</p>
<h2 id="decimal-和-floatdouble-的区别是什么">DECIMAL 和 FLOAT/DOUBLE 的区别是什么？</h2>
<p>DECIMAL 和 FLOAT 的区别是：<strong>DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT/DOUBLE 只能存储近似的小数值。</strong></p>
<p>DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。</p>
<p>在 Java 中，MySQL 的 DECIMAL 类型对应的是 Java 类 <code>java.math.BigDecimal</code>。</p>
<h2 id="在-mysql-中存储金额数据应该使用什么数据类型">在 MySQL 中存储金额数据，应该使用什么数据类型?</h2>
<p>在数据库中业界常用两种类型来存储金额：bigint和 decimal。</p>
<ul>
<li>
<p>bigint 代码中用 long。</p>
<ul>
<li>范围：可以存储的整数范围为-2^63到 2^63-1(在 MySQL 中为 64 位有符号整数)</li>
<li>存储空间：占用8字节(64位)</li>
<li>精度：精确存储整数，但不支持小数部分，存储的金额单位是分</li>
</ul>
</li>
<li>
<p>decimal 代码中使用 BigDecimal。</p>
<ul>
<li>范围：可以存储的数字范围和小数位数由定义的精度和标度决定</li>
<li>存储空间：存储空间取决于定义的精度和标度，存储较大数值时会占用更多空间</li>
<li>精度：支持高精度的小数运算，精确存储定点数，一般用 decimal(18,6)，18 是总位数，6 是小数</li>
</ul>
</li>
</ul>
<h2 id="项目中到底选择-long-还是-bigdecimal">项目中到底选择 Long 还是 BigDecimal?</h2>
<p>long 类型保存到分，使得小数位(厘)的数据不好处理(需要手动处理，比较麻烦)，因此精度不够高。</p>
<p>在高精度金额计算场景下不合适，有些三方支付系统是需要抽成的，例千分之三、万分之一等等，这类的抽成要求精度比较高，例如 会得到1234.5678 这样的金额，乘以 100 后仍然无法存储为精确整教，还是小数,，存储则会丢失精度。0.0078 看似很少，但抽成的笔数一多，比如一天 30 万笔，每笔少个 0.0078，每天的差额也得 2340 元！一年不得 85 万！所以高精度的计算不推荐使用 bigint。</p>
<p>BigDeimnal则很活用于高精度金额场景，且非常灵活，只不过相对于long性能会差一些，但是在大部分业务上我个人认为可以忽略这个性能问题，除非是特殊场景要求极端性能，所以一般情况下我推荐使用 gDecimal.</p>
<h2 id="int10和char10的区别">int(10)和char(10)的区别？</h2>
<p>int(10)中的10表示的是显示数据的长度，而char(10)表示的是存储数据的长度。</p>
<h2 id="为什么不推荐使用-text-和-blob">为什么不推荐使用 TEXT 和 BLOB？</h2>
<p>数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：</p>
<ul>
<li>不能有默认值。</li>
<li>在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。</li>
<li>检索效率较低。</li>
<li>不能直接创建索引，需要指定前缀长度。</li>
<li>可能会消耗大量的网络和 IO 带宽。</li>
<li>可能导致表上的 DML 操作变慢。</li>
<li>……</li>
</ul>
<h2 id="text-类型最大可以存储多长的文本">TEXT 类型最大可以存储多长的文本?</h2>
<p>TEXT 是非标准字符串类型，除了它还有 TINYTEXT、MEDIUMTEXT 和 LONGTEXT，一般我们存储一些不确定的较长文本才会使用到它们，例如文章之类的。</p>
<p>它们的存储的文本长度汇总如下:</p>
<ul>
<li>TINYTEXT：最大长度为 255 字节。</li>
<li>TEXT：最大长度为 65,535 字节(约 64 KB)。</li>
<li>MEDIUMTEXT：最大长度为16,777,215字节(约16 MB)</li>
<li>LONGTEXT：最大长度为 4,294,967,295 字节(约4GB)。</li>
</ul>
<h2 id="datetime-和-timestamp-的区别是什么">DATETIME 和 TIMESTAMP 的区别是什么？</h2>
<p>DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。</p>
<p>TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p>
<ul>
<li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>
<li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li>
</ul>
<h2 id="boolean-类型如何表示">Boolean 类型如何表示？</h2>
<p>MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。</p>
<h2 id="为什么不建议使用null作为默认值">为什么不建议使用null作为默认值</h2>
<p>Mysql不建议用Null作为列默认值不是因为不能使用索引，而是因为：</p>
<ul>
<li>索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化。比如进行索引统计时，<a href="https://www.seven97.top/database/mysql/04-tuning-overviewoftuning.html#count-%E5%92%8C-count-1-%E5%93%AA%E4%B8%AA%E5%BF%AB" target="_blank" rel="noopener nofollow">count(1),max(),min() 会省略值为NULL 的行</a>。</li>
<li>NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式 (opens new window)中<strong>至少会用 1 字节空间存储 NULL 值列表</strong>。建议用""或默认值0来代替NULL</li>
</ul>
<p>不建议使用null作为默认值，并且<strong>建议必须设置默认值</strong>，原因如下：</p>
<ul>
<li>既然都不可为空了，那就必须要有默认值，否则不插入这列的话，就会报错；</li>
<li>数据库不应该是用来查问题的，不能靠mysql报错来告知业务有问题，该不该插入应该由业务说了算；</li>
<li>对于DBA来说，允许使用null是没有规范的，因为不同的人不同的用法。</li>
</ul>
<blockquote>
<p>但像<code>合同生效时间</code>、<code>获奖时间</code> 等这种不可控字段，是可以不设置默认值的，但同样需要not null</p>
</blockquote>
<h2 id="为什么禁止使用外键">为什么禁止使用外键</h2>
<ul>
<li>外键会降低数据库的性能。在MySQL中，外键会自动加上索引，这会使得对该表的查询等操作变得缓慢，尤其是在大型数据表中。</li>
<li>外键也会限制了表结构的调整和更改。在实际应用中，表结构经常需要进行更改，而如果表之间使用了外键约束，这些更改可能会非常难以实现。因为更改一个表的结构，需要涉及到所有以其为父表的子表，这会导致长时间锁定整个数据库表，甚至可能会导致数据丢失。</li>
<li>在MySQL中，外键约束可能还会引发死锁问题。当想要对多个表中的数据进行插入、更新、删除操作时，由于外键约束的存在，可能会导致死锁，需要等待其他事务释放锁。</li>
<li>MySQL中使用外键还会增加开发难度。开发人员需要处理数据在表之间的关系，而这样的处理需要花费更多的时间和精力，以及对数据库的深入理解。同时，外键也会增加代码的复杂度，使得SQL语句变得难以理解和调试。</li>
</ul>
<p>在阿里巴巴开发手册中也有提到，<a href="https://www.seven97.top/books/software-quality/alibaba-developmentmanual.html#sql-%E8%AF%AD%E5%8F%A5" target="_blank" rel="noopener nofollow">传送门</a></p>
<h2 id="使用自增主键有什么好处">使用自增主键有什么好处？</h2>
<p>自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑，在查询的时候，效率也就更高。</p>
<h2 id="自增主键保存在什么地方">自增主键保存在什么地方？</h2>
<p>不同的引擎对于自增值的保存策略不同：</p>
<ul>
<li>MyISAM引擎的自增值保存在数据文件中。</li>
<li>在MySQL8.0以前，InnoDB引擎的自增值是存在内存中。MySQL重启之后内存中的这个值就丢失了，每次重启后第一次打开表的时候，会找自增值的最大值max(id)，然后将最大值加1作为这个表的自增值；MySQL8.0版本会将自增值的变更记录在redo log中，重启时依靠redo log恢复。</li>
</ul>
<h2 id="自增主键一定是连续的吗">自增主键一定是连续的吗？</h2>
<p>不一定，有几种情况会导致自增主键不连续。</p>
<p>1、唯一键冲突导致自增主键不连续。当我们向一个自增主键的InnoDB表中插入数据的时候，如果违反表中定义的唯一索引的唯一约束，会导致插入数据失败。此时表的自增主键的键值是会向后加1滚动的。下次再次插入数据的时候，就不能再使用上次因插入数据失败而滚动生成的键值了，必须使用新滚动生成的键值。</p>
<p>2、事务回滚导致自增主键不连续。当我们向一个自增主键的InnoDB表中插入数据的时候，如果显式开启了事务，然后因为某种原因最后回滚了事务，此时表的自增值也会发生滚动，而接下里新插入的数据，也将不能使用滚动过的自增值，而是需要重新申请一个新的自增值。</p>
<p>3、批量插入导致自增值不连续。MySQL有一个批量申请自增id的策略：</p>
<ul>
<li>语句执行过程中，第一次申请自增id，分配1个自增id</li>
<li>1个用完以后，第二次申请，会分配2个自增id</li>
<li>2个用完以后，第三次申请，会分配4个自增id</li>
<li>依次类推，每次申请都是上一次的两倍（最后一次申请不一定全部使用）</li>
</ul>
<p>如果下一个事务再次插入数据的时候，则会基于上一个事务申请后的自增值基础上再申请。此时就出现自增值不连续的情况出现。</p>
<p>4、自增步长不是1，也会导致自增主键不连续。</p>
<h2 id="innodb的自增值为什么不能回收利用">InnoDB的自增值为什么不能回收利用？</h2>
<p>主要为了提升插入数据的效率和并行度。</p>
<p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请。</p>
<p>假设事务 A 申请到了 id=2， 事务 B 申请到 id=3，那么这时候表 t 的自增值是 4，之后继续执行。</p>
<p>事务 B 正确提交了，但事务 A 出现了唯一键冲突。</p>
<p>如果允许事务 A 把自增 id 回退，也就是把表 t 的当前自增值改回 2，那么就会出现这样的情况：表里面已经有 id=3 的行，而当前的自增 id 值是 2。</p>
<p>接下来，继续执行的其他事务就会申请到 id=2，然后再申请到 id=3。这时，就会出现插入语句报错“主键冲突”。</p>
<p>而为了解决这个主键冲突，有两种方法：</p>
<ul>
<li>每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是，这个方法的成本很高。因为，本来申请 id 是一个很快的操作，现在还要再去主键索引树上判断 id 是否存在。</li>
<li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li>
</ul>
<p>可见，这两个方法都会导致性能问题。</p>
<p>因此，InnoDB 放弃了“允许自增 id 回退”这个设计，语句执行失败也不回退自增 id。</p>
<h2 id="自增主键会遇到什么问题">自增主键会遇到什么问题？</h2>
<p>使用数据库的自增主键，虽然在很多情况下都很方便，但也可能遇到一些问题：</p>
<ul>
<li>插入性能问题：对于非常高并发的插入操作，自增主键可能会成为性能瓶颈。因为每次插入新记录时，都需要获取一个新的自增ID，这个操作是串行的，无法并发执行。</li>
<li>主键耗尽：如果表的记录非常多，可能会出现自增主键耗尽的情况。尤其是对于定义为整型的自增主键，如果插入的记录数超过了整型的最大值，就无法再插入新的记录。</li>
<li>分布式系统问题：在分布式系统中，如果多个数据库节点都需要生成自增主键，就需要保证生成的主键在全局是唯一的。这通常需要引入额外的机制或工具，比如分布式ID生成器。</li>
</ul>
<h2 id="如果-innodb-表没有配置主键有最大值上限吗">如果 InnoDB 表没有配置主键，有最大值上限吗?</h2>
<p>如果我们在 InnoDB 表中不配置主键，那么默认 InnoDB 会创建一个不可见的长度为 6 个字节的 row id.</p>
<p>InnoDB 在全局维护了一个 dict_sys.row_id 值，所有需要用到 row id 的表，每次插入一行数据，都会获取这个值，然后将其+1。</p>
<p>这个值的范周是 0~2^48-1。如果这个值达到上限后，又会从0开始，然后继续循环，如果插入的新数据的 row id 在表中已存在，那么老的数据会被这个新数据覆盖，不会产生有任何报错。</p>
<p>如果要验证这个情况，可以通过 gbd 动态地将 mysgl 的 dict sys.row id 修改，执行多次插入就能发现覆盖的问题。</p>
<p>一般生产环境中不会有表没有设置主键的情况，这个仅做了解即可。</p>
<h2 id="utf8-utf8mb3和-utf8mb4的区别">utf8 、utf8mb3和 utf8mb4的区别</h2>
<p><strong>utf8mb3</strong>：只支持最长三个字节的BMP（Basic Multilingual Plane，基本多文种平面）字符（不支持补充字符）。</p>
<p><strong>utf8mb4</strong>：mb4即 most bytes 4，即最多使用4个字节来表示完整的UTF-8，具有以下特征：</p>
<ul>
<li>支持BMP和补充字符。</li>
<li>每个多字节字符最多需要四个字节。</li>
</ul>
<p>utf8mb4是utf8的超集并完全兼容它，是MySQL 在 5.5.3 版本之后增加的一个新的字符集，能够用四个字节存储更多的字符，几乎包含了世界上所有能看到见的语言字符。</p>
<ul>
<li><strong>差异比较</strong></li>
</ul>
<table>
<thead>
<tr>
<th>差异点</th>
<th>utf8mb3</th>
<th>utf8mb4</th>
</tr>
</thead>
<tbody>
<tr>
<td>最大使用字节数</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>支持字符类型</td>
<td>BMP</td>
<td>BMP+其它字符</td>
</tr>
<tr>
<td>字符类型</td>
<td>常见的 Unicode 字符</td>
<td>常见的 Unicode 字符 + 部分罕用汉字 + emoji表情 + 新增的 Unicode 字符等</td>
</tr>
<tr>
<td>Unicode范围</td>
<td>U0000 - U+FFFF（即BMP)</td>
<td>U0000 - U+10FFFF</td>
</tr>
<tr>
<td>占用存储空间</td>
<td>略小（如CHAR(10) 需要10 * 3 = 30 个字节的空间；VARCHAR 类型需要额外使用1个字节来记录字符串的长度）</td>
<td>稍大（如CHAR(10) 需要 10 * 4 = 40 个字节的空间；VARCHAR 类型需要额外使用2个字节来记录字符串的长度）</td>
</tr>
<tr>
<td>兼容性</td>
<td>切换至utf8mb4 一般不会有问题，但要注意存储空间够不够、排序规则是否变化</td>
<td>切换至utf8mb3可能会有问题，字符丢失、报错或乱码</td>
</tr>
<tr>
<td>安全性</td>
<td>稍低，更容易被恶意字符串攻击</td>
<td>较高，保留恶意字符串，然后报错或乱码提示</td>
</tr>
</tbody>
</table>
<blockquote>
<p>如何选择？一句话就是，根据具体的业务需求和实际情况，选择最合适的字符集。</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-21 09:00">2025-07-21 09:00</span>&nbsp;
<a href="https://www.cnblogs.com/seven97-top">程序员Seven</a>&nbsp;
阅读(<span id="post_view_count">227</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18992744);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18992744', targetLink: 'https://www.cnblogs.com/seven97-top/p/18992744', title: 'char和varchar的区别?VARCHAR(100)和 VARCHAR(10)的区别？Mysql字段类型20连问' })">举报</a>
</div>
        