
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/DOMLX/p/18783476" title="发布于 2025-03-20 17:14">
    <span role="heading" aria-level="2">halcon 入门教程（六） 图像匹配（基于形状的模板匹配）与缺陷检测区域定位</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><span style="font-size: 14pt">原文作者：aircraft</span></p>
<p><span style="font-size: 14pt">原文链接：<a href="https://www.cnblogs.com/DOMLX/p/18783476" target="_blank">https://www.cnblogs.com/DOMLX/p/18783476</a></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;<span style="font-size: 18px">有兴趣可以多看其他的halcon教程</span></p>
<p><span style="font-size: 18pt">&nbsp;<a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2025-03-18 17:21" href="https://www.cnblogs.com/DOMLX/p/18779348">halcon 学习教程目录</a></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt">　　　　本篇主要讲一下工业中最常用的基于形状的模板匹配，以及根据模板定位锁定待检测区域的位置。注意本篇对于工业的缺陷检测是最基础的也是最重要的！！！如果你学习掌握了本篇的demo示例，基本一些简单的工业缺陷检测是没有什么大问题的。</span></p>
<p><span style="font-size: 18pt">　　　　本来应该是有个halcon的程序集里的示例代码的，但是我没找到比较短的，好入门的，所以我临时手写了一个halcon例子。至于其他的例子可以去看halcon官方的。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250320154724194-646183611.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt">一.模板匹配简介</span></strong></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><strong>　　halcon中的模板匹配</strong>‌是一种图像处理技术，主要用于在新的图像中找到特定模板图像的位置。模板匹配通过算法比较图像和模板之间的相似度，从而实现对目标的定位和识别。HALCON提供了多种模板匹配方法：</span></p>
<h3><span style="font-size: 18px"><strong>1. 基于点的匹配（Point-Based Matching）​</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>原理与特点</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>核心机制</strong>：通过提取图像中的<strong>关键点</strong>​（如SIFT、SURF特征点）进行匹配，依赖局部特征描述符的相似度。</span></li>
<li><span style="font-size: 18px">​<strong>优势</strong>：</span>
<ul>
<li><span style="font-size: 18px">对<strong>视角变化</strong>​（旋转、缩放、倾斜）鲁棒。</span></li>
<li><span style="font-size: 18px">抗<strong>部分遮挡</strong>​（只要保留足够特征点即可匹配）。</span></li>
</ul>
</li>
<li><span style="font-size: 18px">​<strong>局限</strong>：</span>
<ul>
<li><span style="font-size: 18px">需要图像中存在丰富的纹理或角点。</span></li>
<li><span style="font-size: 18px">计算复杂度较高，实时性受限。</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px">​<strong>参数调优</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>关键参数</strong>：</span>
<ul>
<li><span style="font-size: 18px"><code>'keypoint_radius'</code>：特征点邻域半径，影响描述符的区分度。</span></li>
<li><span style="font-size: 18px"><code>'min_score'</code>：匹配分数阈值，过滤低置信度匹配。</span></li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h4><span style="font-size: 18px"><strong>应用场景</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>无人机航拍匹配</strong>：识别地标或建筑特征点。</span></li>
<li><span style="font-size: 18px">​<strong>动态视角检测</strong>：如机器人抓取不同角度的工件。</span></li>
</ul>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>2. 基于灰度值的匹配（Gray-Value-Based Matching）​</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>原理与特点</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>核心机制</strong>：直接比较模板与图像区域的<strong>像素灰度值相似度</strong>​（如SSD、NCC）。</span></li>
<li><span style="font-size: 18px">​<strong>优势</strong>：</span>
<ul>
<li>​<span style="font-size: 18px"><strong>计算极快</strong>，适合实时性要求高的场景。</span></li>
<li><span style="font-size: 18px">无需特征提取，适用于无纹理或低对比度图像。</span></li>
</ul>
</li>
<li><span style="font-size: 18px">​<strong>局限</strong>：</span>
<ul>
<li><span style="font-size: 18px">对<strong>光照变化</strong>、旋转、缩放敏感。</span></li>
<li><span style="font-size: 18px">无法处理形变或遮挡。</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px">​<strong>参数调优</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>关键参数</strong>：</span>
<ul>
<li><code>'<span style="font-size: 18px">mask_size'</span></code><span style="font-size: 18px">：匹配时的掩模大小，影响抗噪声能力。</span></li>
<li><span style="font-size: 18px"><code>'subpixel'</code>：是否启用亚像素精度（<code>'true'</code>/<code>'false'</code>）。</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px"><strong>应用场景</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>印刷品定位</strong>：固定光源下检测标签位置。</span></li>
<li><span style="font-size: 18px">​<strong>电子元件校准</strong>：如LED晶圆的对位。</span></li>
</ul>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>3. 基于形状的匹配（Shape-Based Matching）​--------------<span style="font-size: 18px">工业场景中<strong>最常用</strong>的方法！！！</span></strong></span></h3>
<h4><span style="font-size: 18px">​<strong>原理与特点</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>核心机制</strong>：提取模板的<strong>边缘轮廓</strong>，通过形状相似性（边缘梯度方向）进行匹配。</span></li>
<li><span style="font-size: 18px">​<strong>优势</strong>：</span>
<ul>
<li>​<span style="font-size: 18px"><strong>抗光照变化</strong>​（仅依赖边缘信息）。</span></li>
<li><span style="font-size: 18px">支持<strong>旋转、缩放</strong>​（通过参数化设置范围）。</span></li>
<li><span style="font-size: 18px">工业场景中<strong>最常用</strong>的方法。</span></li>
</ul>
</li>
<li><span style="font-size: 18px">​<strong>局限</strong>：</span>
<ul>
<li><span style="font-size: 18px">对<strong>边缘模糊</strong>或缺失敏感。</span></li>
<li><span style="font-size: 18px">需要清晰的轮廓定义。</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px">​<strong>参数调优</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>关键参数</strong>：</span>
<ul>
<li><span style="font-size: 18px"><code>'angle_step'</code>：角度搜索步长（越小越慢但精度↑）。</span></li>
<li><span style="font-size: 18px"><code>'scale_min'</code>/<code>'scale_max'</code>：允许的缩放范围。</span></li>
<li><span style="font-size: 18px"><code>'min_contrast'</code>：最小边缘对比度（过滤噪声）。</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px"><strong>应用场景</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>机械臂抓取</strong>：定位金属零件轮廓。</span></li>
<li><span style="font-size: 18px">​<strong>OCR预处理</strong>：定位文本区域。</span></li>
</ul>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>4. 基于组件的匹配（Component-Based Matching）​</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>原理与特点</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>核心机制</strong>：将物体分解为<strong>多个子组件</strong>，分别匹配后组合结果。</span></li>
<li><span style="font-size: 18px">​<strong>优势</strong>：</span>
<ul>
<li><span style="font-size: 18px">抗<strong>严重遮挡</strong>​（只要保留关键子组件即可匹配）。</span></li>
<li><span style="font-size: 18px">适合<strong>复杂结构物体</strong>​（如多部件装配体）。</span></li>
</ul>
</li>
<li><span style="font-size: 18px">​<strong>局限</strong>：</span>
<ul>
<li><span style="font-size: 18px">需定义子组件的<strong>空间关系</strong>​（如相对位置、角度）。</span></li>
<li><span style="font-size: 18px">参数配置复杂。</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px"><strong>参数调优</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>关键参数</strong>：</span>
<ul>
<li><span style="font-size: 18px"><code>'component_relation'</code>：子组件间的空间约束（如距离容差）。</span></li>
<li><span style="font-size: 18px"><code>'min_component_score'</code>：单个子组件的最低匹配分数。</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px"><strong>应用场景</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>汽车装配检测</strong>：检查发动机组件的完整性。</span></li>
<li><span style="font-size: 18px">​<strong>货架商品识别</strong>：部分遮挡下的商品匹配。</span></li>
</ul>
<h3>&nbsp;</h3>
<h3><span style="font-size: 18px"><strong>5. 基于局部可变形匹配（Locally Deformable Matching）​</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>原理与特点</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>核心机制</strong>：允许模板在匹配过程中发生<strong>局部非线性形变</strong>​（如拉伸、弯曲）。</span></li>
<li><span style="font-size: 18px">​<strong>优势</strong>：</span>
<ul>
<li><span style="font-size: 18px">处理<strong>弹性变形</strong>​（如布料、橡胶件）。</span></li>
<li><span style="font-size: 18px">对局部缺损鲁棒。</span></li>
</ul>
</li>
<li><span style="font-size: 18px">​<strong>局限</strong>：</span>
<ul>
<li><span style="font-size: 18px">计算复杂度高，实时性差。</span></li>
<li><span style="font-size: 18px">需要高质量的模板图像。</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px"><strong>参数调优</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>关键参数</strong>：</span>
<ul>
<li><span style="font-size: 18px"><code>'deformation_smoothness'</code>：形变平滑度约束（值越高形变越受限）。</span></li>
<li><span style="font-size: 18px"><code>'max_deformation'</code>：最大允许形变量（像素单位）。</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px"><strong>应用场景</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>软包装检测</strong>：如食品袋的褶皱匹配。</span></li>
<li><span style="font-size: 18px">​<strong>生物医学图像</strong>：器官组织的弹性变形分析。</span></li>
</ul>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>6. 基于可变形的匹配（Deformable Matching）​</strong></span></h3>
<h4><span style="font-size: 18px">​<strong>原理与特点</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>核心机制</strong>：通过<strong>参数化变形模型</strong>​（仿射、透视变换）处理全局形变。</span></li>
<li><span style="font-size: 18px">​<strong>优势</strong>：</span>
<ul>
<li><span style="font-size: 18px">支持<strong>透视变换</strong>和3D投影。</span></li>
<li><span style="font-size: 18px">可校正大范围视角倾斜。</span></li>
</ul>
</li>
<li><span style="font-size: 18px">​<strong>局限</strong>：</span>
<ul>
<li><span style="font-size: 18px">需要已知变形参数范围（如倾斜角度限制）。</span></li>
<li><span style="font-size: 18px">对非线性形变（如局部弯曲）处理能力有限。</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px">​<strong>参数调优</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>关键参数</strong>：</span>
<ul>
<li><span style="font-size: 18px"><code>'perspective_model'</code>：是否启用透视模型（<code>'true'</code>/<code>'false'</code>）。</span></li>
<li><span style="font-size: 18px"><code>'max_deformation'</code>：最大形变参数值。</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px"><strong>应用场景</strong></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>倾斜视角校正</strong>：如车牌识别。</span></li>
<li><span style="font-size: 18px">​<strong>AR/VR定位</strong>：虚拟物体的3D叠加。</span></li>
</ul>
<h3><span style="font-size: 18px"><strong>错误排查指南</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">​<strong>现象</strong></span></th><th><span style="font-size: 18px">​<strong>可能原因</strong></span></th><th><span style="font-size: 18px">​<strong>解决方案</strong></span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px">匹配分数低</span></td>
<td><span style="font-size: 18px">模板与图像差异大</span></td>
<td><span style="font-size: 18px">检查光照、对比度，调整<code>min_contrast</code></span></td>
</tr>
<tr>
<td><span style="font-size: 18px">匹配时间过长</span></td>
<td><span style="font-size: 18px">搜索范围过大</span></td>
<td><span style="font-size: 18px">缩小角度/缩放范围，增大<code>angle_step</code></span></td>
</tr>
<tr>
<td><span style="font-size: 18px">误匹配多</span></td>
<td><span style="font-size: 18px">阈值设置过松</span></td>
<td><span style="font-size: 18px">提高<code>min_score</code>，启用<code>max_overlap</code></span></td>
</tr>
<tr>
<td><span style="font-size: 18px">无法创建模型</span></td>
<td><span style="font-size: 18px">模板图像质量差</span></td>
<td><span style="font-size: 18px">使用<code>edges_image</code>强化边缘</span></td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><strong><span style="font-size: 18pt">二.图像匹配以及缺陷区域定位</span></strong></span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">老规矩，直接上图：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250320155730382-1227353008.bmp" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">我们接下来对一个零件建立模板，并且我们建立一个小孔区域的缺陷检测ROI区域，当我们匹配到这个零件的时候，检测缺陷的区域也会到当前零件的小孔位置去，这样我们就可以对其进行区域缺陷检测了（工业中非常常用！！！）</span></p>
<p><span style="font-size: 18px">大概过程如下：</span></p>
<ol>
<li><span style="font-size: 18px">读取并显示图像；</span></li>
<li><span style="font-size: 18px">绘制模板ROI及待检测ROI；</span></li>
<li><span style="font-size: 18px">创建模型；</span></li>
<li><span style="font-size: 18px">匹配模板；</span></li>
<li><span style="font-size: 18px">ROI仿射变换，得到待检测ROI位置。</span></li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">第一步：画模板区域，框选了一颗零件矩形区域。</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250320160009784-444461976.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">第二步：画待检测区域</span></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250320160129139-1958715166.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">第三步：创建模板，默认模板都在左上角，模板中心点没设置的话默认是模板的重心位置&nbsp; 自己可以用<span style="font-size: 18px">set_shape_model_origin</span>（这个算子工业开发中会用到）算子设置一下，基本我们都是设置为裁剪区域的中心点。</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250320160759650-395950368.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">第四步：匹配定位到模板，在将模板以及待检测区域的位置转换过去</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250320171102833-268605633.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250320161013030-738334060.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">第五步：就是检测这个区域了，这里简单的提取个中心显示一下，正常你们是要对其进行某些检测的。比如我在小孔这里画个白色的什么脏东西，你就可以用Blob分析去检测出来，或者这里小孔位置歪了，或者干脆没有小孔，那么你该怎么检测呢？</span></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250320161238953-1462901089.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">&nbsp;OK 实例的过程讲完了，我们在认识一下接下来要用到的算子，然后就直接看代码理解。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong>1.创建形状匹配模板算子<strong>create_shape_model</strong>(<a href="#Template" rel="noopener nofollow"><em>Template</em></a>&nbsp;: :&nbsp;<a href="#NumLevels" rel="noopener nofollow"><em>NumLevels</em></a>,&nbsp;<a href="#AngleStart" rel="noopener nofollow"><em>AngleStart</em></a>,&nbsp;<a href="#AngleExtent" rel="noopener nofollow"><em>AngleExtent</em></a>,&nbsp;<a href="#AngleStep" rel="noopener nofollow"><em>AngleStep</em></a>,&nbsp;<a href="#Optimization" rel="noopener nofollow"><em>Optimization</em></a>,&nbsp;<a href="#Metric" rel="noopener nofollow"><em>Metric</em></a>,&nbsp;<a href="#Contrast" rel="noopener nofollow"><em>Contrast</em></a>,&nbsp;<a href="#MinContrast" rel="noopener nofollow"><em>MinContrast</em></a>&nbsp;:&nbsp;<a href="#ModelID" rel="noopener nofollow"><em>ModelID</em></a>)详解：</strong></strong></span></span></p>
<p><span style="font-size: 18px">函数原型：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">create_shape_model(
    Template        : :  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输入模板图像（ROI区域）</span>
    NumLevels       : :  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 金字塔层级数</span>
    AngleStart      : :  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 起始角度（弧度）</span>
    AngleExtent     : :  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 角度范围（弧度）</span>
    AngleStep       : :  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 角度步长（弧度或'auto'）</span>
    Optimization    : :  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 模型优化模式</span>
    Metric          : :  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 匹配度量方式</span>
    Contrast        : :  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 对比度参数（列表）</span>
    MinContrast     : :  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 最小对比度阈值</span>
    : ModelID           <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出模型句柄</span>
)</span></pre>
</div>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>参数详解与工业配置策略</strong></span></h3>
<h4><span style="font-size: 18px">1. <code>NumLevels</code> (金字塔层级数)</span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>作用</strong>：控制模型的金字塔层级，层级越多，匹配速度越快，但会损失细节。 正常我们都是1-3之间设置自己摸索一下。</span></li>
<li><span style="font-size: 18px">​<strong>推荐值</strong>：</span>
<ul>
<li>​<span style="font-size: 18px"><strong>高速场景</strong>：3-5层（如产线速度&gt;30fps）</span></li>
<li><span style="font-size: 18px">​<strong>高精度场景</strong>：1-3层（需亚像素精度）</span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px">2. <code>AngleStart</code> 与 <code>AngleExtent</code> (角度范围)</span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>作用</strong>：定义模型在匹配时的旋转角度搜索范围。</span></li>
<li><span style="font-size: 18px">​<strong>工业设置</strong>：</span>
<ul>
<li>​<span style="font-size: 18px"><strong>固定角度</strong>：<code>AngleStart=0</code>, <code>AngleExtent=0</code>（无旋转）</span></li>
<li><span style="font-size: 18px">​<strong>全角度检测</strong>：<code>AngleStart=0</code>, <code>AngleExtent=rad(360)</code></span></li>
</ul>
</li>
<li><span style="font-size: 18px">​<strong>案例</strong>：</span>
<ul>
<li><span style="font-size: 18px">传送带零件允许±30°倾斜 → <code>AngleStart=rad(-30)</code>, <code>AngleExtent=rad(60)&nbsp; 一般前面的绝对值是后面一半这样设置</code></span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px">3. <code>AngleStep</code> (角度步长)</span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>作用</strong>：角度搜索的步长，决定角度分辨率。</span></li>
<li><span style="font-size: 18px">​<strong>设置策略</strong>：</span>
<ul>
<li>​<span style="font-size: 18px">**<code>'auto'</code>**：自动计算（推荐优先使用）</span></li>
<li><span style="font-size: 18px">​<strong>手动设置</strong>：根据精度需求调整（越小越精确但速度越慢）</span>
<ul>
<li><span style="font-size: 18px">高速产线：<code>rad(1.0)</code></span></li>
<li><span style="font-size: 18px">高精度检测：<code>rad(0.1)</code></span></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px">4. <code>Optimization</code> (优化模式)</span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>可选值</strong>：</span>
<ul>
<li><span style="font-size: 18px"><code>'none'</code>：不优化（内存占用最小）</span></li>
<li><span style="font-size: 18px"><code>'pregeneration'</code>：预生成模型（匹配最快，内存占用高）</span></li>
<li><span style="font-size: 18px"><code>'no_pregeneration'</code>：不预生成（内存占用低，匹配稍慢）</span></li>
</ul>
</li>
<li><span style="font-size: 18px">​<strong>推荐</strong>：</span>
<ul>
<li>​<span style="font-size: 18px"><strong>实时检测</strong> → <code>'pregeneration'</code></span></li>
<li><span style="font-size: 18px">​<strong>嵌入式设备</strong> → <code>'no_pregeneration'</code></span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px">5. <code>Metric</code> (匹配度量方式)</span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>选项</strong>：</span>
<ul>
<li><span style="font-size: 18px"><code>'use_polarity'</code>：要求模板与目标<strong>对比度极性相同</strong>​（亮/暗一致）</span></li>
<li><span style="font-size: 18px"><code>'ignore_global_polarity'</code>：允许全局极性反转（如白底黑字→黑底白字）</span></li>
<li><span style="font-size: 18px"><code>'ignore_local_polarity'</code>：允许局部极性变化（抗光照不均）</span></li>
</ul>
</li>
<li><span style="font-size: 18px">​<strong>工业场景</strong>：</span>
<ul>
<li><span style="font-size: 18px">金属零件检测 → <code>'use_polarity'</code></span></li>
<li><span style="font-size: 18px">印刷品检测（可变背景） → <code>'ignore_global_polarity'</code></span></li>
</ul>
</li>
</ul>
<h4><span style="font-size: 18px">6. <code>Contrast</code> 与 <code>MinContrast</code> (对比度参数)</span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>作用</strong>：控制模型边缘特征的提取灵敏度。</span></li>
<li><span style="font-size: 18px">​<strong>参数结构</strong>：</span>
<ul>
<li><span style="font-size: 18px"><code>Contrast</code>：各金字塔层的对比度阈值（列表，长度=NumLevels）</span></li>
<li><span style="font-size: 18px"><code>MinContrast</code>：模型允许的<strong>最小边缘对比度</strong></span></li>
</ul>
</li>
</ul>
<h4>&nbsp;</h4>
<h4><span style="font-size: 18px">案例1：高速产线零件定位</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 参数配置
NumLevels :</span>= <span style="color: rgba(128, 0, 128, 1)">4</span>          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 4级金字塔加速匹配</span>
AngleStep := <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">auto</span><span style="color: rgba(128, 0, 0, 1)">'</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 自动角度步长</span>
Optimization := <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">pregeneration</span><span style="color: rgba(128, 0, 0, 1)">'</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 预生成模型</span>
Metric := <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">use_polarity</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 极性一致（稳定光照）</span>
Contrast := [<span style="color: rgba(128, 0, 128, 1)">25</span>,<span style="color: rgba(128, 0, 128, 1)">12</span>,<span style="color: rgba(128, 0, 128, 1)">6</span>,<span style="color: rgba(128, 0, 128, 1)">3</span>] <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 各层对比度阈值</span>
MinContrast := <span style="color: rgba(128, 0, 128, 1)">5</span>        <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 最小边缘对比度</span>

*<span style="color: rgba(0, 0, 0, 1)"> 创建模型
create_shape_model (
    TemplateImage, 
    NumLevels, 
    rad(</span>-<span style="color: rgba(128, 0, 128, 1)">30</span>), rad(<span style="color: rgba(128, 0, 128, 1)">60</span>),  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 允许±30°旋转</span>
<span style="color: rgba(0, 0, 0, 1)">    AngleStep, 
    Optimization, 
    Metric, 
    Contrast, 
    MinContrast, 
    ModelID
)</span></span></pre>
</div>
<h4>&nbsp;</h4>
<h4><span style="font-size: 18px">案例2：低对比度塑料件检测</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 参数配置
NumLevels :</span>= <span style="color: rgba(128, 0, 128, 1)">2</span>          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 高精度模式</span>
AngleStep := rad(<span style="color: rgba(128, 0, 128, 1)">0.5</span>)   <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 小角度步长</span>
Optimization := <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 节省内存</span>
Metric := <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">ignore_local_polarity</span><span style="color: rgba(128, 0, 0, 1)">'</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 抗光照不均</span>
Contrast := [<span style="color: rgba(128, 0, 128, 1)">10</span>,<span style="color: rgba(128, 0, 128, 1)">5</span>]      <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 低对比度阈值</span>
MinContrast := <span style="color: rgba(128, 0, 128, 1)">3</span>        <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 捕捉微弱边缘</span>

*<span style="color: rgba(0, 0, 0, 1)"> 创建模型
create_shape_model (
    TemplateImage, 
    NumLevels, 
    rad(</span><span style="color: rgba(128, 0, 128, 1)">0</span>), rad(<span style="color: rgba(128, 0, 128, 1)">360</span>),   <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 全角度搜索</span>
<span style="color: rgba(0, 0, 0, 1)">    AngleStep, 
    Optimization, 
    Metric, 
    Contrast, 
    MinContrast, 
    ModelID
)</span></span></pre>
</div>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>性能优化技巧</strong></span></h3>
<ol>
<li><span style="font-size: 18px">​<strong>边缘滤波</strong>：</span><br><span style="font-size: 18px">
在创建模型前使用<code>emphasize</code>或<code>laplace</code>增强边缘对比度。</span></li>
<li><span style="font-size: 18px">​<strong>ROI裁剪</strong>：</span><br><span style="font-size: 18px">
使用<code>reduce_domain</code>缩小模板区域，去除无关背景。</span></li>
<li><span style="font-size: 18px">​<strong>亚像素优化</strong>：</span><br><span style="font-size: 18px">
在<code>find_shape_model</code>中启用<code>'least_squares'</code>亚像素模式。</span></li>


</ol>
<p><span style="font-size: 18px">通过精准配置<code>create_shape_model</code>参数，可兼顾速度与精度，满足工业检测的严苛要求。建议使用<code>inspect_shape_model</code>工具验证模型质量，并根据实际场景微调参数。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong>2.模板匹配算子<strong>find_shape_model</strong>(<a href="#Image" rel="noopener nofollow"><em>Image</em></a>&nbsp;: :&nbsp;<a href="#ModelID" rel="noopener nofollow"><em>ModelID</em></a>,&nbsp;<a href="#AngleStart" rel="noopener nofollow"><em>AngleStart</em></a>,&nbsp;<a href="#AngleExtent" rel="noopener nofollow"><em>AngleExtent</em></a>,&nbsp;<a href="#MinScore" rel="noopener nofollow"><em>MinScore</em></a>,&nbsp;<a href="#NumMatches" rel="noopener nofollow"><em>NumMatches</em></a>,&nbsp;<a href="#MaxOverlap" rel="noopener nofollow"><em>MaxOverlap</em></a>,&nbsp;<a href="#SubPixel" rel="noopener nofollow"><em>SubPixel</em></a>,&nbsp;<a href="#NumLevels" rel="noopener nofollow"><em>NumLevels</em></a>,&nbsp;<a href="#Greediness" rel="noopener nofollow"><em>Greediness</em></a>&nbsp;:&nbsp;<a href="#Row" rel="noopener nofollow"><em>Row</em></a>,&nbsp;<a href="#Column" rel="noopener nofollow"><em>Column</em></a>,&nbsp;<a href="#Angle" rel="noopener nofollow"><em>Angle</em></a>,&nbsp;<a href="#Score" rel="noopener nofollow"><em>Score</em></a>)详解：</strong></strong></span></span></span></p>
<p><span style="font-size: 18px">函数原型：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">find_shape_model(
    Image       : :          </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输入图像（单通道灰度）</span>
    ModelID     : :          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 形状模型句柄</span>
    AngleStart  : :          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 起始角度（弧度）</span>
    AngleExtent : :          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 角度范围（弧度）</span>
    MinScore    : :          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 最小匹配分数（0-1）</span>
    NumMatches  : :          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 最大匹配数量</span>
    MaxOverlap  : :          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 最大重叠度（0-1）</span>
    SubPixel    : :          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 亚像素模式</span>
    NumLevels   : :          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 搜索金字塔层级范围（[起始层, 结束层]）</span>
    Greediness  : :          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 贪婪系数（0-1）</span>
    : Row, Column, Angle, Score  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出坐标、角度及分数</span>
)</span></pre>
</div>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>参数详解与工业配置策略</strong></span></h3>
<h4><span style="font-size: 18px">1. <code>AngleStart</code> 与 <code>AngleExtent</code></span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>作用</strong>：限定匹配时的<strong>角度搜索范围</strong>，减少计算量。</span></li>
<li><span style="font-size: 18px">​<strong>推荐设置</strong>：​<strong>技巧</strong>：</span>
<ul>
<li>​<span style="font-size: 18px"><strong>固定角度</strong> → <code>AngleStart=0</code>, <code>AngleExtent=0</code></span></li>
<li><span style="font-size: 18px">​<strong>允许±30°旋转</strong> → <code>AngleStart=rad(-30)</code>, <code>AngleExtent=rad(60)</code></span></li>
</ul>
</li>
<li><br><span style="font-size: 18px">
若模型创建时已限定角度范围，此处应保持一致。</span></li>


</ul>
<h4><span style="font-size: 18px">2. <code>MinScore</code> (最小匹配分数)</span></h4>
<ul>
<ul>
<li><span style="font-size: 18px">​<strong>作用</strong>：过滤低质量匹配（范围0~1，1为完全匹配）。</span></li>
<li><span style="font-size: 18px">​<strong>工业建议</strong>：</span>
<ul>
<li>​<span style="font-size: 18px"><strong>高精度检测</strong> → 0.7-0.9</span></li>
<li><span style="font-size: 18px">​<strong>高速场景</strong> → 0.5-0.7</span></li>


</ul>



</li>


</ul>

</ul>
<h4><span style="font-size: 18px">3. <code>NumMatches</code> (最大匹配数量)</span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>作用</strong>：限制返回的匹配结果数量。</span></li>
<li><span style="font-size: 18px">​<strong>场景</strong>：</span>
<ul>
<li>​<span style="font-size: 18px"><strong>单一目标定位</strong> → 1</span></li>
<li><span style="font-size: 18px">​<strong>多目标检测</strong> → 根据图像中预期目标数设置（如5）</span></li>

</ul>

</li>

</ul>
<h4><span style="font-size: 18px">4. <code>MaxOverlap</code> (最大重叠度)</span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>作用</strong>：控制重叠区域的匹配结果去重。</span></li>
<li><span style="font-size: 18px">​<strong>设置规则</strong>：</span>
<ul>
<li>​<span style="font-size: 18px"><strong>密集排列物体</strong> → 0.3-0.5</span></li>
<li><span style="font-size: 18px">​<strong>孤立物体</strong> → 0.8（几乎不抑制）</span></li>

</ul>

</li>

</ul>
<h4><span style="font-size: 18px">5. <code>SubPixel</code> (亚像素模式)</span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>选项</strong>：</span>
<ul>
<li><span style="font-size: 18px"><code>'none'</code>：禁用（最快）</span></li>
<li><span style="font-size: 18px"><code>'interpolation'</code>：插值法（平衡）</span></li>
<li><span style="font-size: 18px"><code>'least_squares'</code>：最小二乘优化（最精确）</span></li>

</ul>

</li>
<li><span style="font-size: 18px">​<strong>推荐</strong>：</span>
<ul>
<li>​<span style="font-size: 18px"><strong>坐标精度要求≤0.5像素</strong> → <code>'least_squares'</code></span></li>
<li><span style="font-size: 18px">​<strong>实时检测</strong> → <code>'interpolation'</code> 或 <code>'none'</code></span></li>

</ul>

</li>

</ul>
<h4><span style="font-size: 18px">6. <code>NumLevels</code> (金字塔层级范围)</span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>格式</strong>：<code>[起始层, 结束层]</code>（需≤创建模型时的金字塔层数）</span></li>
<li><span style="font-size: 18px">​<strong>策略</strong>：</span>
<ul>
<li>​<span style="font-size: 18px"><strong>高速优先</strong> → <code>[3,1]</code>（从低分辨率到高分辨率）</span></li>
<li><span style="font-size: 18px">​<strong>精度优先</strong> → <code>[0,2]</code>（从高分辨率开始）</span></li>

</ul>

</li>

</ul>
<h4><span style="font-size: 18px">7. <code>Greediness</code> (贪婪系数)</span></h4>
<ul>
<li><span style="font-size: 18px">​<strong>作用</strong>：平衡<strong>速度</strong>与<strong>漏检率</strong>​（值越高速度越快，但可能漏检）。</span></li>
<li><span style="font-size: 18px">​<strong>建议</strong>：</span>
<ul>
<li>​<span style="font-size: 18px"><strong>稳定环境</strong> → 0.7-0.9</span></li>
<li><span style="font-size: 18px">​<strong>复杂背景</strong> → 0.4-0.6</span></li>

</ul>

</li>

</ul>
<p>&nbsp;</p>
<h4><span style="font-size: 18px">案例1：高精度零件定位（亚像素+严格过滤）</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">find_shape_model (
    Image, ModelID, 
    rad(</span>-<span style="color: rgba(128, 0, 128, 1)">10</span>), rad(<span style="color: rgba(128, 0, 128, 1)">20</span>),   <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 允许±10°旋转</span>
    <span style="color: rgba(128, 0, 128, 1)">0.8</span>,                 <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 最小分数0.8</span>
    <span style="color: rgba(128, 0, 128, 1)">1</span>,                   <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 只找最佳匹配</span>
    <span style="color: rgba(128, 0, 128, 1)">0.5</span>,                 <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 最大重叠度0.5</span>
    <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">least_squares</span><span style="color: rgba(128, 0, 0, 1)">'</span>,     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 亚像素优化</span>
    [<span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">3</span>],              <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 使用所有金字塔层</span>
    <span style="color: rgba(128, 0, 128, 1)">0.7</span>,                 <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 中等贪婪度</span>
<span style="color: rgba(0, 0, 0, 1)">    Row, Column, Angle, Score
)</span></span></pre>
</div>
<p>&nbsp;</p>
<h4><span style="font-size: 18px">案例2：高速产线多目标检测</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">find_shape_model (
    Image, ModelID,
    </span><span style="color: rgba(128, 0, 128, 1)">0</span>, rad(<span style="color: rgba(128, 0, 128, 1)">360</span>),         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 全角度搜索</span>
    <span style="color: rgba(128, 0, 128, 1)">0.6</span>,                 <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 容忍较低分数</span>
    <span style="color: rgba(128, 0, 128, 1)">5</span>,                   <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 最多5个匹配</span>
    <span style="color: rgba(128, 0, 128, 1)">0.3</span>,                 <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 抑制重叠&gt;30%的结果</span>
    <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">interpolation</span><span style="color: rgba(128, 0, 0, 1)">'</span>,     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 快速亚像素</span>
    [<span style="color: rgba(128, 0, 128, 1)">2</span>, <span style="color: rgba(128, 0, 128, 1)">1</span>],              <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 从第2层开始搜索</span>
    <span style="color: rgba(128, 0, 128, 1)">0.9</span>,                 <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 高贪婪度</span>
<span style="color: rgba(0, 0, 0, 1)">    Row, Column, Angle, Score
)</span></span></pre>
</div>
<h3><span style="font-size: 18px"><strong>错误排查与调试</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">​<strong>现象</strong></span></th><th><span style="font-size: 18px">​<strong>可能原因</strong></span></th><th><span style="font-size: 18px">​<strong>解决方案</strong></span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px">无匹配结果</span></td>
<td><span style="font-size: 18px"><code>MinScore</code>过高</span></td>
<td><span style="font-size: 18px">逐步降低至0.3，观察是否出现匹配</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">匹配位置偏移</span></td>
<td><span style="font-size: 18px">亚像素模式未启用</span></td>
<td><span style="font-size: 18px">设置<code>SubPixel='least_squares'</code></span></td>
</tr>
<tr>
<td><span style="font-size: 18px">检测时间过长</span></td>
<td><span style="font-size: 18px"><code>Greediness</code>过低</span></td>
<td><span style="font-size: 18px">逐步提高至0.9</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">重复匹配同一物体</span></td>
<td><span style="font-size: 18px"><code>MaxOverlap</code>过低</span></td>
<td><span style="font-size: 18px">调整至0.6-0.8</span></td>
</tr>
</tbody>
</table>
</div>
<h3><span style="font-size: 18px"><strong>最佳实践总结</strong></span></h3>
<ol>
<li><span style="font-size: 18px">​<strong>参数联动调整</strong>：创建模型时的<code>Contrast</code>与搜索时的<code>NumLevels</code>需协同优化。</span></li>
<li><span style="font-size: 18px">​<strong>结果验证</strong>：使用<code>dev_display_shape_matching_results</code>可视化匹配结果。</span></li>
<li><span style="font-size: 18px">​<strong>资源释放</strong>：循环结束后调用<code>clear_shape_model</code>避免内存泄漏。</span></li>
</ol>
<p><span style="font-size: 18px">通过合理配置<code>find_shape_model</code>参数，可在工业检测中实现<strong>高精度</strong>、<strong>高速度</strong>的物体定位。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong>3.旋转矩阵生成算子<strong>hom_mat2d_rotate</strong>( : :&nbsp;<a href="#HomMat2D" rel="noopener nofollow"><em>HomMat2D</em></a>,&nbsp;<a href="#Phi" rel="noopener nofollow"><em>Phi</em></a>,&nbsp;<a href="#Px" rel="noopener nofollow"><em>Px</em></a>,&nbsp;<a href="#Py" rel="noopener nofollow"><em>Py</em></a>&nbsp;:&nbsp;<a href="#HomMat2DRotate" rel="noopener nofollow"><em>HomMat2DRotate</em></a>)详解：</strong></strong></span></span></span></span></p>
<p><span style="font-size: 18px">函数原型：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">hom_mat2d_rotate(
    : : 
    HomMat2D,      </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输入齐次变换矩阵</span>
    Phi,           <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 旋转角度（弧度，正值逆时针）</span>
    Px, Py,        <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 旋转中心坐标（原始坐标系中的点）</span>
    : HomMat2DRotate <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出旋转后的变换矩阵</span>
)</span></pre>
</div>
<h3><span style="font-size: 18px">参数解释</span></h3>
<ul>
<li><span style="font-size: 18px">​<strong>HomMat2D</strong>：输入的二维齐次变换矩阵。若初始为单位矩阵，表示无先前变换。</span></li>
<li><span style="font-size: 18px">​<strong>Phi</strong>：旋转角度（弧度）。例如，<code>rad(30)</code> 表示逆时针旋转30度。</span></li>
<li><span style="font-size: 18px">​<strong>Px, Py</strong>：旋转中心在<strong>原始坐标系</strong>中的坐标。无论之前的变换如何，旋转始终绕此点进行。</span></li>
<li><span style="font-size: 18px">​<strong>HomMat2DRotate</strong>：输出的新变换矩阵，将输入矩阵与旋转变换组合。</span></li>
</ul>
<h3><span style="font-size: 18px">功能描述</span></h3>
<ul>
<li><span style="font-size: 18px">​<strong>旋转变换</strong>：生成的矩阵会先执行原始变换（<code>HomMat2D</code>），再绕<strong>原始坐标系</strong>中的点 <code>(Px, Py)</code> 旋转角度 <code>Phi</code>。</span></li>
<li><span style="font-size: 18px">​<strong>矩阵组合</strong>：新矩阵 = 旋转变换矩阵 × 原始矩阵。即，先应用原始变换，再执行旋转。</span></li>
</ul>
<p>&nbsp;</p>
<h4><span style="font-size: 18px">示例1：绕图像中心旋转30度</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 读取图像并获取尺寸
read_image(Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">part.png</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
get_image_size(Image, Width, Height)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 计算图像中心坐标
CenterX :</span>= Width / <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">
CenterY :</span>= Height / <span style="color: rgba(128, 0, 128, 1)">2</span>

*<span style="color: rgba(0, 0, 0, 1)"> 创建初始单位矩阵
hom_mat2d_identity(HomMat2D)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 绕中心点旋转30度（逆时针）
hom_mat2d_rotate(HomMat2D, rad(</span><span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">), CenterX, CenterY, HomMat2DRotate)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 应用变换到图像
affine_trans_image(Image, ImageRotated, HomMat2DRotate, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">constant</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">false</span><span style="color: rgba(128, 0, 0, 1)">'</span>)</span></pre>
</div>
<p>&nbsp;</p>
<h4><span style="font-size: 18px">示例2：平移后绕新位置旋转</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">* 将物体平移到(<span style="color: rgba(128, 0, 128, 1)">200</span>,<span style="color: rgba(128, 0, 128, 1)">200</span><span style="color: rgba(0, 0, 0, 1)">)，再绕该点旋转45度
hom_mat2d_identity(HomMat2D)
hom_mat2d_translate(HomMat2D, </span><span style="color: rgba(128, 0, 128, 1)">200</span>, <span style="color: rgba(128, 0, 128, 1)">200</span><span style="color: rgba(0, 0, 0, 1)">, HomMat2DTranslate)
hom_mat2d_rotate(HomMat2DTranslate, rad(</span><span style="color: rgba(128, 0, 128, 1)">45</span>), <span style="color: rgba(128, 0, 128, 1)">200</span>, <span style="color: rgba(128, 0, 128, 1)">200</span><span style="color: rgba(0, 0, 0, 1)">, HomMat2DRotate)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 应用变换到区域
affine_trans_region(Region, RegionTrans, HomMat2DRotate, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">nearest_neighbor</span><span style="color: rgba(128, 0, 0, 1)">'</span>)</span></pre>
</div>
<p>&nbsp;</p>
<h3><span style="font-size: 18px">关键注意事项</span></h3>
<ol>
<li><span style="font-size: 18px">​<strong>旋转中心</strong>：<code>(Px, Py)</code> 必须是<strong>原始坐标系</strong>中的坐标。若之前的变换已移动物体，需计算其在原始坐标系中的目标位置。</span></li>
<li><span style="font-size: 18px">​<strong>变换顺序</strong>：新矩阵按 <code>旋转 × 原始</code> 组合，意味着先执行原始变换，再旋转。</span></li>
<li><span style="font-size: 18px">​<strong>角度方向</strong>：正值表示逆时针旋转，使用 <code>rad()</code> 函数转换角度。</span></li>
</ol>
<h3><span style="font-size: 18px">错误排查</span></h3>
<ul>
<li><span style="font-size: 18px">​<strong>非预期旋转中心</strong>：检查 <code>Px, Py</code> 是否在原始坐标系中计算。</span></li>
<li><span style="font-size: 18px">​<strong>角度错误</strong>：确认使用弧度而非角度，例如 <code>rad(30)</code> 而非直接 <code>30</code>。</span></li>
</ul>
<h3><span style="font-size: 18px">可视化验证</span></h3>
<p><span style="font-size: 18px">使用 <code>affine_trans_pixel</code> 变换关键点并绘制，确认旋转中心正确：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 变换旋转中心点（应保持不变）
affine_trans_pixel(HomMat2DRotate, Px, Py, TransPx, TransPy)
gen_cross_contour_xld(Cross, TransPy, TransPx, </span><span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">0.785398</span><span style="color: rgba(0, 0, 0, 1)">) 
dev_display(Image)
dev_display(Cross) </span></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong>4.平移矩阵生成算子<strong>hom_mat2d_translate</strong>( : :&nbsp;<a href="#HomMat2D" rel="noopener nofollow"><em>HomMat2D</em></a>,&nbsp;<a href="#Tx" rel="noopener nofollow"><em>Tx</em></a>,&nbsp;<a href="#Ty" rel="noopener nofollow"><em>Ty</em></a>&nbsp;:&nbsp;<a href="#HomMat2DTranslate" rel="noopener nofollow"><em>HomMat2DTranslate</em></a>)详解：</strong></strong></span></span></span></span></span></p>
<p><span style="font-size: 18px">函数原型：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">hom_mat2d_translate(
    : : 
    HomMat2D,          </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输入齐次变换矩阵</span>
    Tx, Ty,            <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> X/Y方向平移量（像素单位）</span>
    : HomMat2DTranslate <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出平移后的变换矩阵</span>
)</span></pre>
</div>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>参数详解</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">参数名</span></th><th><span style="font-size: 18px">类型</span></th><th><span style="font-size: 18px">说明</span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px"><code>HomMat2D</code></span></td>
<td><span style="font-size: 18px">矩阵</span></td>
<td><span style="font-size: 18px">输入的二维齐次变换矩阵。若初始为单位矩阵（无变换），可通过<code>hom_mat2d_identity</code>创建。</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>Tx</code>, <code>Ty</code></span></td>
<td><span style="font-size: 18px">数值</span></td>
<td><span style="font-size: 18px">X和Y方向的平移量（像素单位）。正值为向右/下平移，负值为向左/上平移。</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>HomMat2DTranslate</code></span></td>
<td><span style="font-size: 18px">矩阵</span></td>
<td><span style="font-size: 18px">输出矩阵，包含原矩阵的变换叠加平移后的结果。</span></td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>功能描述</strong></span></h3>
<ul>
<ul>
<li><span style="font-size: 18px">​<strong>作用</strong>：在现有变换矩阵的基础上叠加<strong>平移变换</strong>，生成新的变换矩阵。</span></li>
<li><span style="font-size: 18px">​<strong>数学原理</strong>：</span><br><span style="font-size: 18px">
若原矩阵为 ​<strong>H</strong>，平移矩阵为 ​<strong>T</strong>，则新矩阵为：
</span></li>


</ul>

</ul>
<p><span style="font-size: 18px"><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250320165129417-1699580824.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 18px">&nbsp;这意味着<strong>先执行原矩阵的变换，再进行平移</strong>。</span></p>
<h4><span style="font-size: 18px">示例1：纯平移变换（无初始变换）</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 创建单位矩阵（无变换）
hom_mat2d_identity(HomMat2D)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 向右平移50像素，向下平移30像素
hom_mat2d_translate(HomMat2D, </span><span style="color: rgba(128, 0, 128, 1)">50</span>, <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">, HomMat2DTranslate)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 应用平移变换到图像
affine_trans_image(Image, ImageTranslated, HomMat2DTranslate, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">constant</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">false</span><span style="color: rgba(128, 0, 0, 1)">'</span>)</span></pre>
</div>
<p>&nbsp;</p>
<h4><span style="font-size: 18px">示例2：组合变换（旋转+平移）</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 绕图像中心旋转30度后，再平移
hom_mat2d_identity(HomMat2D)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 计算图像中心坐标
get_image_size(Image, Width, Height)
CenterX :</span>= Width / <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">
CenterY :</span>= Height / <span style="color: rgba(128, 0, 128, 1)">2</span>
*<span style="color: rgba(0, 0, 0, 1)"> 旋转
hom_mat2d_rotate(HomMat2D, rad(</span><span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">), CenterX, CenterY, HomMat2DRotate)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 平移（在旋转后的坐标系中平移）
hom_mat2d_translate(HomMat2DRotate, </span><span style="color: rgba(128, 0, 128, 1)">100</span>, -<span style="color: rgba(128, 0, 128, 1)">50</span><span style="color: rgba(0, 0, 0, 1)">, HomMat2DTranslate)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 应用复合变换
affine_trans_image(Image, ImageTransformed, HomMat2DTranslate, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">constant</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">false</span><span style="color: rgba(128, 0, 0, 1)">'</span>)</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>注意事项</strong></span></h3>
<ol><ol>
<li><span style="font-size: 18px">​<strong>变换顺序</strong>：<br>
矩阵乘法顺序决定变换执行顺序。例如：</span>
<ul>
<li>​<span style="font-size: 18px"><strong>先旋转后平移</strong> → 物体绕原点旋转，再移动到新位置。</span></li>
<li><span style="font-size: 18px">​<strong>先平移后旋转</strong> → 物体移动到新位置后绕该点旋转。</span></li>


</ul>


</li>


</ol></ol>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 顺序不同，结果不同！
hom_mat2d_rotate → hom_mat2d_translate : 旋转后平移
hom_mat2d_translate → hom_mat2d_rotate : 平移后旋转</span></span></pre>
</div>
<ul>
<ul>
<li><span style="font-size: 18px"><strong>坐标系基准</strong>：</span><br><span style="font-size: 18px">
平移量 <code>(Tx, Ty)</code> ​<strong>始终基于原始坐标系</strong>。若之前有旋转/缩放，需手动计算偏移方向。</span></li>
<li><span style="font-size: 18px">​<strong>复合变换验证</strong>：</span><br><span style="font-size: 18px">
使用<code>affine_trans_pixel</code>验证关键点变换结果：
</span></li>


</ul>

</ul>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">* 测试点 (<span style="color: rgba(128, 0, 128, 1)">0</span>,<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">) 的变换结果
affine_trans_pixel(HomMat2DTranslate, </span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, Qx, Qy)
disp_message(WindowHandle, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">平移后坐标: (</span><span style="color: rgba(128, 0, 0, 1)">'</span> + Qx + <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">,</span><span style="color: rgba(128, 0, 0, 1)">'</span> + Qy + <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">)</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">window</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">'</span>)</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>错误排查</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">​<strong>现象</strong></span></th><th><span style="font-size: 18px">​<strong>原因</strong></span></th><th><span style="font-size: 18px">​<strong>解决方案</strong></span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px">平移方向相反</span></td>
<td><span style="font-size: 18px">坐标系方向理解错误</span></td>
<td><span style="font-size: 18px">HALCON中Y轴向下为正，检查符号。</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">变换结果偏离预期</span></td>
<td><span style="font-size: 18px">变换顺序错误</span></td>
<td><span style="font-size: 18px">调整<code>hom_mat2d_rotate</code>和<code>hom_mat2d_translate</code>调用顺序。</span></td>
</tr>
<tr>
<td><span style="font-size: 18px">平移后图像边缘被裁剪</span></td>
<td><span style="font-size: 18px">未扩展画布</span></td>
<td><span style="font-size: 18px">使用<code>affine_trans_image</code>时设置<code>'adapt_size'</code>参数为<code>'true'</code>。</span></td>
</tr>
</tbody>
</table>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong>5.<span style="font-size: 18px">仿射</span>变换算子（轮廓）<strong>affine_trans_contour_xld</strong>(<a href="#Contours" rel="noopener nofollow"><em>Contours</em></a>&nbsp;:&nbsp;<a href="#ContoursAffineTrans" rel="noopener nofollow"><em>ContoursAffineTrans</em></a>&nbsp;:&nbsp;<a href="#HomMat2D" rel="noopener nofollow"><em>HomMat2D</em></a>&nbsp;: )详解：</strong></strong></span></span></span></span></span></span></p>
<p><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong>函数原型：</strong></strong></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">affine_trans_contour_xld(
    Contours             : :  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输入：原始XLD轮廓</span>
    HomMat2D            : :  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输入：2D仿射变换矩阵</span>
    : ContoursAffineTrans  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出：变换后的XLD轮廓</span>
)</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>功能描述</strong></span></h3>
<ul>
<ul>
<li><span style="font-size: 18px">​<strong>作用</strong>：将输入的 <code>XLD轮廓</code> 通过指定的仿射变换矩阵 <code>HomMat2D</code> 进行几何变换（平移、旋转、缩放、剪切等），生成变换后的新轮廓。</span></li>
<li><span style="font-size: 18px">​<strong>数学原理</strong>：</span><br><span style="font-size: 18px">
对轮廓中的每个点 <code>(x, y)</code> 应用变换：
</span></li>


</ul>

</ul>
<p><span style="font-size: 18px"><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250320165546676-267982237.png" alt="" loading="lazy"></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">&nbsp;其中 <code>(x', y')</code> 是变换后的坐标。</span></p>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>参数说明</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">参数</span></th><th><span style="font-size: 18px">类型</span></th><th><span style="font-size: 18px">说明</span></th></tr>

</thead>
<tbody>
<tr>
<td><span style="font-size: 18px"><code>Contours</code></span></td>
<td><span style="font-size: 18px">XLD对象</span></td>
<td><span style="font-size: 18px">输入的XLD轮廓（如边缘、多边形等）。</span></td>

</tr>
<tr>
<td><span style="font-size: 18px"><code>HomMat2D</code></span></td>
<td><span style="font-size: 18px">矩阵</span></td>
<td><span style="font-size: 18px">二维齐次变换矩阵，由 <code>hom_mat2d_rotate</code>、<code>hom_mat2d_translate</code> 等生成。</span></td>

</tr>
<tr>
<td><span style="font-size: 18px"><code>ContoursAffineTrans</code></span></td>
<td><span style="font-size: 18px">XLD对象</span></td>
<td><span style="font-size: 18px">输出的变换后轮廓，保留原始属性（如闭合性、点顺序）。</span></td>

</tr>

</tbody>

</table>

</div>
<p>&nbsp;</p>
<h4><span style="font-size: 18px">案例1：平移矩形轮廓</span></h4>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 创建矩形XLD轮廓
gen_rectangle2_contour_xld (Rectangle, </span><span style="color: rgba(128, 0, 128, 1)">100</span>, <span style="color: rgba(128, 0, 128, 1)">100</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">50</span>, <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 生成平移变换矩阵（向右50像素，向下30像素）
hom_mat2d_identity (HomMat2D)
hom_mat2d_translate (HomMat2D, </span><span style="color: rgba(128, 0, 128, 1)">50</span>, <span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">, HomMat2DTranslate)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 应用平移变换
affine_trans_contour_xld (Rectangle, HomMat2DTranslate, RectangleTrans)</span></span></pre>
</div>
<p>&nbsp;</p>
<h4><span style="font-size: 18px">案例2：绕中心旋转并缩放</span></h4>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 生成圆形XLD轮廓
gen_circle_contour_xld (Circle, </span><span style="color: rgba(128, 0, 128, 1)">200</span>, <span style="color: rgba(128, 0, 128, 1)">200</span>, <span style="color: rgba(128, 0, 128, 1)">50</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">6.28318</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">positive</span><span style="color: rgba(128, 0, 0, 1)">'</span>, <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">)

</span>* 绕中心点(<span style="color: rgba(128, 0, 128, 1)">200</span>,<span style="color: rgba(128, 0, 128, 1)">200</span><span style="color: rgba(0, 0, 0, 1)">)旋转30度并缩放0.8倍
hom_mat2d_identity (HomMat2D)
hom_mat2d_rotate (HomMat2D, rad(</span><span style="color: rgba(128, 0, 128, 1)">30</span>), <span style="color: rgba(128, 0, 128, 1)">200</span>, <span style="color: rgba(128, 0, 128, 1)">200</span><span style="color: rgba(0, 0, 0, 1)">, HomMat2DRotate)
hom_mat2d_scale (HomMat2DRotate, </span><span style="color: rgba(128, 0, 128, 1)">0.8</span>, <span style="color: rgba(128, 0, 128, 1)">0.8</span>, <span style="color: rgba(128, 0, 128, 1)">200</span>, <span style="color: rgba(128, 0, 128, 1)">200</span><span style="color: rgba(0, 0, 0, 1)">, HomMat2DScale)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 应用复合变换
affine_trans_contour_xld (Circle, HomMat2DScale, CircleTrans)</span></span></pre>
</div>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>关键注意事项</strong></span></h3>
<ol><ol>
<li>
<p><span style="font-size: 18px">​<strong>变换顺序</strong>：</span><br><span style="font-size: 18px">
矩阵乘法顺序决定变换执行顺序。例如：</span></p>


</li>


</ol></ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 先平移后旋转 vs 先旋转后平移
hom_mat2d_translate → hom_mat2d_rotate → 平移后旋转
hom_mat2d_rotate → hom_mat2d_translate → 旋转后平移</span></span></pre>
</div>
<p>&nbsp;</p>
<ol>
<li value="2">
<p><span style="font-size: 18px"><strong>坐标系方向</strong>：</span><br><span style="font-size: 18px">
HALCON图像坐标系原点在左上角，x轴向右，y轴向下。变换矩阵中的坐标需与此一致。</span></p>



</li>
<li>
<p>​<strong>性能优化</strong>：</p>
<ul>
<li><span style="font-size: 18px">避免频繁变换：若需多次应用相同变换，可预计算矩阵。</span></li>
<li><span style="font-size: 18px">使用<code>hom_mat2d_invert</code>快速逆变换。</span></li>


</ul>



</li>


</ol>
<h3><span style="font-size: 18px"><strong>应用场景</strong></span></h3>
<ol>
<li><span style="font-size: 18px">​<strong>目标定位</strong>：</span><br><span style="font-size: 18px">
将模板轮廓变换到检测位置，用于匹配验证。</span></li>
<li><span style="font-size: 18px">​<strong>运动补偿</strong>：</span><br><span style="font-size: 18px">
动态调整轮廓以跟踪运动物体。</span></li>
<li><span style="font-size: 18px">​<strong>图像配准</strong>：</span><br><span style="font-size: 18px">
对齐不同视角或时间点的轮廓数据。</span></li>


</ol>
<h3><span style="font-size: 18px"><strong>错误排查</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">​<strong>现象</strong></span></th><th><span style="font-size: 18px">​<strong>可能原因</strong></span></th><th><span style="font-size: 18px">​<strong>解决方案</strong></span></th></tr>


</thead>
<tbody>
<tr>
<td><span style="font-size: 18px">变换后轮廓消失</span></td>
<td><span style="font-size: 18px">矩阵错误导致轮廓移出图像范围</span></td>
<td><span style="font-size: 18px">检查变换参数或扩展图像区域。</span></td>


</tr>
<tr>
<td><span style="font-size: 18px">轮廓形状畸变</span></td>
<td><span style="font-size: 18px">缩放/剪切参数不合理</span></td>
<td><span style="font-size: 18px">验证矩阵是否包含非法操作（如负缩放）。</span></td>


</tr>
<tr>
<td><span style="font-size: 18px">性能低下</span></td>
<td><span style="font-size: 18px">高密度轮廓+复杂变换</span></td>
<td><span style="font-size: 18px">简化轮廓或优化矩阵生成逻辑。</span></td>


</tr>


</tbody>


</table>


</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong>6.<span style="font-size: 18px">仿射变换算子（区域）<strong>affine_trans_region</strong>(<a href="#Region" rel="noopener nofollow"><em>Region</em></a>&nbsp;:&nbsp;<a href="#RegionAffineTrans" rel="noopener nofollow"><em>RegionAffineTrans</em></a>&nbsp;:&nbsp;<a href="#HomMat2D" rel="noopener nofollow"><em>HomMat2D</em></a>,&nbsp;<a href="#Interpolate" rel="noopener nofollow"><em>Interpolate</em></a>&nbsp;: )详解：</span></strong></strong></span></span></span></span></span></span></strong></strong></span></span></span></span></span></span></p>
<p><span style="font-size: 18px">函数原型：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">affine_trans_region(
    Region            : :  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输入：待变换的区域（Region）</span>
    HomMat2D         : :  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输入：二维齐次变换矩阵</span>
    Interpolate      : :  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输入：插值方法（区域像素处理方式）</span>
    : RegionAffineTrans  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出：变换后的区域</span>
)</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>参数详解</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">参数</span></th><th><span style="font-size: 18px">类型</span></th><th><span style="font-size: 18px">说明</span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px"><code>Region</code></span></td>
<td><span style="font-size: 18px">Region</span></td>
<td><span style="font-size: 18px">输入区域（需为非空区域）。</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>HomMat2D</code></span></td>
<td><span style="font-size: 18px">Matrix</span></td>
<td><span style="font-size: 18px">二维齐次变换矩阵，由 <code>hom_mat2d_rotate</code>、<code>hom_mat2d_scale</code> 等生成。</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>Interpolate</code></span></td>
<td><span style="font-size: 18px">String</span></td>
<td><span style="font-size: 18px">插值方法，控制变换后区域的像素填充方式，可选值：<code>'nearest_neighbor'</code>（最近邻，速度快）、<code>'bilinear'</code>（双线性插值，边缘更平滑）、<code>'constant'</code>（固定值填充）。</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>RegionAffineTrans</code></span></td>
<td><span style="font-size: 18px">Region</span></td>
<td><span style="font-size: 18px">输出区域，执行仿射变换后的结果。</span></td>
</tr>
</tbody>
</table>
</div>
<h3><span style="font-size: 18px"><strong>核心功能</strong></span></h3>
<ol><ol>
<li>
<p><span style="font-size: 18px">​<strong>几何变换</strong></span><br><span style="font-size: 18px">
对输入区域执行 ​<strong>平移、旋转、缩放、剪切</strong> 等复合变换，生成新区域。</span></p>



</li>
<li>
<p>​<strong>插值控制</strong><br>
根据 <code>Interpolate</code> 参数选择不同的像素处理策略：</p>
<ul>
<li>​<span style="font-size: 18px">**<code>'nearest_neighbor'</code>**：速度快，但边缘可能产生锯齿（适合二值区域）。</span></li>
<li><span style="font-size: 18px">​**<code>'bilinear'</code>**：边缘平滑，适合需要亚像素精度的场景（如测量）。</span></li>
<li><span style="font-size: 18px">​**<code>'constant'</code>**：用固定灰度值填充空白区域（需配合 <code>set_grayval</code> 使用）。</span></li>


</ul>



</li>


</ol></ol>
<h4><span style="font-size: 18px">示例1：旋转区域（工业零件定位）</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 创建初始矩形区域
gen_rectangle1 (Region, </span><span style="color: rgba(128, 0, 128, 1)">100</span>, <span style="color: rgba(128, 0, 128, 1)">100</span>, <span style="color: rgba(128, 0, 128, 1)">200</span>, <span style="color: rgba(128, 0, 128, 1)">300</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 生成旋转变换矩阵（绕左上角原点旋转30度）
hom_mat2d_identity (HomMat2D)
hom_mat2d_rotate (HomMat2D, rad(</span><span style="color: rgba(128, 0, 128, 1)">30</span>), <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, HomMat2DRotate)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 应用变换（使用双线性插值保持边缘平滑）
affine_trans_region (Region, HomMat2DRotate, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">bilinear</span><span style="color: rgba(128, 0, 0, 1)">'</span>, RegionRotated)</span></pre>
</div>
<h4><span style="font-size: 18px">示例2：平移+缩放区域（图像ROI调整）</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 生成复合变换矩阵（先缩放0.5倍，再平移）
hom_mat2d_identity (HomMat2D)
hom_mat2d_scale (HomMat2D, </span><span style="color: rgba(128, 0, 128, 1)">0.5</span>, <span style="color: rgba(128, 0, 128, 1)">0.5</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, HomMat2DScale)
hom_mat2d_translate (HomMat2DScale, </span><span style="color: rgba(128, 0, 128, 1)">50</span>, <span style="color: rgba(128, 0, 128, 1)">100</span><span style="color: rgba(0, 0, 0, 1)">, HomMat2DTranslate)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 应用变换（最近邻插值，快速处理）
affine_trans_region (Region, HomMat2DTranslate, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">nearest_neighbor</span><span style="color: rgba(128, 0, 0, 1)">'</span>, RegionTrans)</span></pre>
</div>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>应用场景</strong></span></h3>
<ol><ol>
<li><span style="font-size: 18px">​<strong>目标姿态调整</strong></span><br><span style="font-size: 18px">
将检测到的区域变换到标准位置，用于后续测量或比对。</span></li>
<li><span style="font-size: 18px">​<strong>ROI动态跟踪</strong></span><br><span style="font-size: 18px">
根据运动估计更新感兴趣区域的位置和角度。</span></li>
<li><span style="font-size: 18px">​<strong>图像增强</strong></span><br><span style="font-size: 18px">
生成旋转/缩放的训练数据（数据增强）。</span></li>


</ol></ol>
<h3><span style="font-size: 18px"><strong>注意事项</strong></span></h3>
<ol>
<li>
<p>​<strong>插值选择</strong>：</p>
<ul>
<li>​<span style="font-size: 18px"><strong>二值区域</strong> → 优先使用 <code>'nearest_neighbor'</code>（避免灰度插值引入噪声）。</span></li>
<li><span style="font-size: 18px">​<strong>灰度区域</strong> → 选择 <code>'bilinear'</code> 或 <code>'constant'</code>（保持边缘平滑）。</span></li>

</ul>

</li>
<li>
<p>​<strong>性能优化</strong>：</p>
<ul>
<li><span style="font-size: 18px">对二值区域，<code>'nearest_neighbor'</code> 比 <code>'bilinear'</code> ​<strong>快3-5倍</strong>。</span></li>
<li><span style="font-size: 18px">提前裁剪区域（<code>reduce_domain</code>）以减少计算量。</span></li>

</ul>

</li>
<li>
<p>​<strong>边界处理</strong>：</p>
<ul>
<li><span style="font-size: 18px">若变换后区域超出图像范围，超界部分会被自动裁剪。</span></li>
<li><span style="font-size: 18px">使用 <code>full_domain</code> 恢复完整区域（可能包含无效像素）。</span></li>

</ul>

</li>

</ol>
<p>&nbsp;</p>
<h3><span style="font-size: 18px"><strong>可视化验证</strong></span></h3>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 显示原始区域和变换后的区域
dev_display (Region)
dev_set_color (</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">green</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
dev_display (RegionAffineTrans)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 显示变换矩阵作用点（如旋转中心）
affine_trans_pixel (HomMat2D, </span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, TransX, TransY)
gen_cross_contour_xld (Cross, TransY, TransX, </span><span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">0.785</span><span style="color: rgba(0, 0, 0, 1)">)
dev_display (Cross)</span></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><span style="font-size: 18px"><strong><strong>7.生<span style="font-size: 18px">成刚体变换矩阵算子<strong>vector_angle_to_rigid</strong>( : :&nbsp;<a href="#Row1" rel="noopener nofollow"><em>Row1</em></a>,&nbsp;<a href="#Column1" rel="noopener nofollow"><em>Column1</em></a>,&nbsp;<a href="#Angle1" rel="noopener nofollow"><em>Angle1</em></a>,&nbsp;<a href="#Row2" rel="noopener nofollow"><em>Row2</em></a>,&nbsp;<a href="#Column2" rel="noopener nofollow"><em>Column2</em></a>,&nbsp;<a href="#Angle2" rel="noopener nofollow"><em>Angle2</em></a>&nbsp;:&nbsp;<a href="#HomMat2D" rel="noopener nofollow"><em>HomMat2D</em></a>)详解：</span></strong></strong></span></span></span></span></span></span></span></p>
<p><span style="font-size: 18px">函数原型：</span></p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px"><span style="color: rgba(0, 0, 0, 1)">vector_angle_to_rigid(
    : : 
    Row1, Column1, Angle1,   </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 原始坐标系下的参考点及角度</span>
    Row2, Column2, Angle2,   <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 目标坐标系下的参考点及角度</span>
    : HomMat2D                <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出的刚体变换矩阵</span>
)</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>参数详解</strong></span></h3>
<div class="hyc-common-markdown__table-wrapper">
<table>
<thead>
<tr><th><span style="font-size: 18px">参数</span></th><th><span style="font-size: 18px">类型</span></th><th><span style="font-size: 18px">说明</span></th></tr>
</thead>
<tbody>
<tr>
<td><span style="font-size: 18px"><code>Row1</code>, <code>Column1</code></span></td>
<td><span style="font-size: 18px">浮点数</span></td>
<td><span style="font-size: 18px">原始坐标系中的参考点坐标（如模板中心点）。</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>Angle1</code></span></td>
<td><span style="font-size: 18px">浮点数</span></td>
<td><span style="font-size: 18px">原始坐标系中的角度（弧度），通常为0（模板的初始角度）。</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>Row2</code>, <code>Column2</code></span></td>
<td><span style="font-size: 18px">浮点数</span></td>
<td><span style="font-size: 18px">目标坐标系中的参考点坐标（如检测到的目标中心点）。</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>Angle2</code></span></td>
<td><span style="font-size: 18px">浮点数</span></td>
<td><span style="font-size: 18px">目标坐标系中的角度（弧度），表示相对于原始角度的旋转量。</span></td>
</tr>
<tr>
<td><span style="font-size: 18px"><code>HomMat2D</code></span></td>
<td><span style="font-size: 18px">矩阵</span></td>
<td><span style="font-size: 18px">输出的2D刚体变换矩阵（包含平移和旋转，无缩放/剪切）。</span></td>
</tr>
</tbody>
</table>
</div>
<h3><span style="font-size: 18px"><strong>功能描述</strong></span></h3>
<ul>
<ul>
<li><span style="font-size: 18px">​<strong>作用</strong>：生成一个刚体变换矩阵，将<strong>原始参考点</strong> <code>(Row1, Column1)</code> 旋转并平移到<strong>目标参考点</strong> <code>(Row2, Column2)</code>，同时将角度 <code>Angle1</code> 调整到 <code>Angle2</code>。</span></li>
<li><span style="font-size: 18px">​<strong>数学原理</strong>：</span><br><span style="font-size: 18px">
变换矩阵 ​<strong>H</strong> 的构成：
</span></li>


</ul>

</ul>
<p><span style="font-size: 18px"><img src="https://img2024.cnblogs.com/blog/1251892/202503/1251892-20250320170627874-324373194.png" alt="" loading="lazy"></span></p>
<p><span style="font-size: 18px">&nbsp;</span></p>
<ul>
<li><span style="font-size: 18px"><strong>R</strong> 为旋转矩阵（角度差为 <code>Angle2 - Angle1</code>）</span></li>
<li><span style="font-size: 18px">​<strong>T</strong> 为平移矩阵（平移量为 <code>(Row2 - Row1, Column2 - Column1)</code>）</span></li>

</ul>
<p>&nbsp;</p>
<h4><span style="font-size: 18px">场景1：模板匹配后的姿态对齐</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">* 假设模板中心为(<span style="color: rgba(128, 0, 128, 1)">100</span>,<span style="color: rgba(128, 0, 128, 1)">100</span><span style="color: rgba(0, 0, 0, 1)">)，角度为0
</span>* 检测到目标中心为(<span style="color: rgba(128, 0, 128, 1)">150</span>,<span style="color: rgba(128, 0, 128, 1)">200</span><span style="color: rgba(0, 0, 0, 1)">)，旋转角度为30°
vector_angle_to_rigid(</span><span style="color: rgba(128, 0, 128, 1)">100</span>, <span style="color: rgba(128, 0, 128, 1)">100</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">150</span>, <span style="color: rgba(128, 0, 128, 1)">200</span>, rad(<span style="color: rgba(128, 0, 128, 1)">30</span><span style="color: rgba(0, 0, 0, 1)">), HomMat2D)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 将模板区域变换到目标位置
affine_trans_region(TemplateRegion, RegionTrans, HomMat2D, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">nearest_neighbor</span><span style="color: rgba(128, 0, 0, 1)">'</span>)</span></pre>
</div>
<p>&nbsp;</p>
<h4><span style="font-size: 18px">场景2：机械臂抓取坐标转换</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">* 视觉系统检测到物体中心为(<span style="color: rgba(128, 0, 128, 1)">300</span>,<span style="color: rgba(128, 0, 128, 1)">250</span><span style="color: rgba(0, 0, 0, 1)">)，旋转角度45°
</span>* 机械臂坐标系需要平移到(<span style="color: rgba(128, 0, 128, 1)">500</span>,<span style="color: rgba(128, 0, 128, 1)">600</span><span style="color: rgba(0, 0, 0, 1)">)，并调整角度到0°
vector_angle_to_rigid(</span><span style="color: rgba(128, 0, 128, 1)">300</span>, <span style="color: rgba(128, 0, 128, 1)">250</span>, rad(<span style="color: rgba(128, 0, 128, 1)">45</span>), <span style="color: rgba(128, 0, 128, 1)">500</span>, <span style="color: rgba(128, 0, 128, 1)">600</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, HomMat2D)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 转换抓取点坐标
affine_trans_pixel(HomMat2D, GraspX, GraspY, TransX, TransY)</span></span></pre>
</div>
<h4><span style="font-size: 18px">零件旋转角度补偿</span></h4>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 读取图像并定位目标
read_image(Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">part.png</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
find_shape_model(Image, ModelID, ..., Row, Column, Angle, Score)

</span>* 生成刚体变换矩阵（从模板原点(<span style="color: rgba(128, 0, 128, 1)">0</span>,<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)到检测位置）
vector_angle_to_rigid(</span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, Row, Column, Angle, HomMat2D)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 变换模板ROI到目标位置
affine_trans_region(TemplateROI, TransformedROI, HomMat2D, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">nearest_neighbor</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 在变换后的ROI内执行检测
reduce_domain(Image, TransformedROI, ImageCropped)
threshold(ImageCropped, Region, </span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">128</span>)</span></pre>
</div>
<h3><span style="font-size: 18px"><strong>关键注意事项</strong></span></h3>
<ol><ol>
<li>
<p><span style="font-size: 18px">​<strong>角度单位</strong>：</span><br><span style="font-size: 18px">
HALCON中角度必须使用<strong>弧度</strong>，可用<code>rad(角度)</code>转换，如 <code>rad(30)</code> 表示30度。</span></p>



</li>
<li>
<p><span style="font-size: 18px">​<strong>坐标系方向</strong>：</span><br><span style="font-size: 18px">
HALCON图像坐标系原点在左上角，Y轴向下。若与机械臂坐标系（通常Y轴向上）不一致，需额外转换。</span></p>



</li>
<li>
<p><span style="font-size: 18px">​<strong>复合变换</strong>：</span><br><span style="font-size: 18px">
若需叠加缩放或剪切，需手动组合矩阵：</span></p>


</li>


</ol></ol>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 先缩放后刚体变换
hom_mat2d_scale(HomMat2D, </span><span style="color: rgba(128, 0, 128, 1)">0.5</span>, <span style="color: rgba(128, 0, 128, 1)">0.5</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, HomMat2DScale)
hom_mat2d_compose(HomMat2DScale, HomMat2D, HomMat2DCombined)</span></span></pre>
</div>
<h3><span style="font-size: 18px"><strong>可视化验证</strong></span></h3>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 显示变换前后关键点
gen_cross_contour_xld(Cross1, Row1, Column1, </span><span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">0.785</span>)  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 原始点</span>
gen_cross_contour_xld(Cross2, Row2, Column2, <span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">0.785</span>)  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 目标点</span>
affine_trans_contour_xld(Cross1, HomMat2D, Cross1Trans)  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 变换后的点</span>
<span style="color: rgba(0, 0, 0, 1)">dev_display(Image)
dev_display(Cross1)
dev_display(Cross2)
dev_display(Cross1Trans)  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 应重合于Cross2</span></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 14pt">关于矩阵知识的是大学的线性代数课程，有兴趣可以学一下我这篇博客：<a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2020-01-09 15:42" href="https://www.cnblogs.com/DOMLX/p/12166896.html">关于opengl中的三维矩阵平移代码，矩阵旋转代码，推导过程理解 OpenGL计算机图形学的一些必要矩阵运算知识 glTranslatef（x,y,z）glRotatef(angle,x,y,z)函数详解</a></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px">接下来进入正题实例代码（注释我都打好了，结合上面的算子和矩阵你们应该还是非常好理解的，这个demo会了以后，正常的工业检测都是这样的套路，先找到个不变得模板定位，然后将区域转换过去检测）：</span></p>
<p><span style="font-size: 18px">对已经定位到的区域进行检测的一些方法总结也可以看看这篇博客，或者我的halcon入门教程（五）：</span></p>
<div id="mainContent">
<div class="forFlow">
<div id="post_detail">
<div id="topics">
<div class="post">
<h1 class="postTitle"><a id="cb_post_title_url" class="postTitle2 vertical-middle" title="发布于 2021-06-10 16:02" href="https://www.cnblogs.com/xyf327/p/14871414.html"> <span>halcon——缺陷检测常用方法总结（光度立体） </span></a></h1>
</div>
</div>
</div>
</div>
</div>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="font-size: 18px">*<span style="color: rgba(0, 0, 0, 1)"> 打开一个黑色背景的显示窗口，用于后续图像和结果的展示
dev_open_window (</span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">1000</span>, <span style="color: rgba(128, 0, 128, 1)">1000</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">black</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">, WindowHandle)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 获取当前窗口句柄，用于后续绘图操作
dev_get_window (WindowHandle1)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 读取图像文件并转换为灰度图像
read_image (Image, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">0.bmp</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
</span>*<span style="color: rgba(0, 0, 0, 1)">如果已经是单通道图像直接忽略
rgb1_to_gray (Image, GrayImage)

</span>* -------- 模板区域定义 ---------
*<span style="color: rgba(0, 0, 0, 1)"> 在窗口上手动绘制矩形ROI（用于创建模板）   这边选择的是带方向的矩形，也可以直接画普通矩形
draw_rectangle2 (WindowHandle1, RowMod, ColumnMod, PhiMod, LengthMod1, LengthMod2)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 根据绘制的参数生成矩形区域对象
gen_rectangle2 (Rectangle1, RowMod, ColumnMod, PhiMod, LengthMod1, LengthMod2)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 裁剪出矩形区域的图像（模板图像）
reduce_domain (GrayImage, Rectangle1, ImageReduced1)

</span>* -------- 检测区域定义 ---------
*<span style="color: rgba(0, 0, 0, 1)"> 在窗口上手动绘制第二个矩形ROI（用于检测区域）
draw_rectangle2 (WindowHandle1, Row1, Column1, Phi, Length1, Length2)
gen_rectangle2 (Rectangle, Row1, Column1, Phi, Length1, Length2)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 裁剪检测区域图像
reduce_domain (GrayImage, Rectangle, ImageReduced)
</span>* 对检测区域进行阈值分割（灰度0~<span style="color: rgba(128, 0, 128, 1)">80</span><span style="color: rgba(0, 0, 0, 1)">）
threshold (ImageReduced, Region, </span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">80</span><span style="color: rgba(0, 0, 0, 1)">)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 计算区域面积和中心坐标
area_center (Region, Area, Row222, Column222)

</span>* -------- 形状模板建模 ---------
* 创建形状匹配模型（金字塔级别=<span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">，全角度搜索）
</span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
</span>*   [<span style="color: rgba(128, 0, 128, 1)">14</span>,<span style="color: rgba(128, 0, 128, 1)">31</span>,<span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">] : 最小对比度参数（金字塔各级对比度阈值）
</span>*   <span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">        : 模型生成时的最大边缘噪声容限
create_shape_model (ImageReduced1, </span><span style="color: rgba(128, 0, 128, 1)">3</span>, rad(<span style="color: rgba(128, 0, 128, 1)">0</span>), rad(<span style="color: rgba(128, 0, 128, 1)">360</span>), rad(<span style="color: rgba(128, 0, 128, 1)">1.5523</span>), [<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">none</span><span style="color: rgba(128, 0, 0, 1)">'</span>,<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">no_pregeneration</span><span style="color: rgba(128, 0, 0, 1)">'</span>], <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">use_polarity</span><span style="color: rgba(128, 0, 0, 1)">'</span>, [<span style="color: rgba(128, 0, 128, 1)">14</span>,<span style="color: rgba(128, 0, 128, 1)">31</span>,<span style="color: rgba(128, 0, 128, 1)">4</span>], <span style="color: rgba(128, 0, 128, 1)">6</span><span style="color: rgba(0, 0, 0, 1)">, ModelID)
</span>*<span style="color: rgba(0, 0, 0, 1)"> 获取模型的轮廓用于可视化
get_shape_model_contours (ModelContours, ModelID, </span><span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">)

</span>* -------- 图像预处理 ---------
*<span style="color: rgba(0, 0, 0, 1)"> 对原图进行25度旋转（模拟物体倾斜场景）
rotate_image (GrayImage, ImageRotate, </span><span style="color: rgba(128, 0, 128, 1)">25</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">constant</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)

</span>* -------- 形状匹配过程 ---------
*<span style="color: rgba(0, 0, 0, 1)"> 在旋转后的图像中搜索模板
</span>*<span style="color: rgba(0, 0, 0, 1)"> 参数说明：
</span>*   [<span style="color: rgba(128, 0, 128, 1)">3</span>,<span style="color: rgba(128, 0, 128, 1)">2</span>]     : 金字塔级别范围（从3到2级）  越大速度越快精度越低，<span style="color: rgba(128, 0, 128, 1)">1</span>-<span style="color: rgba(0, 0, 0, 1)">3之间是比较合适的
</span>*   <span style="color: rgba(128, 0, 128, 1)">0.75</span><span style="color: rgba(0, 0, 0, 1)">      : 最小匹配分数阈值
</span>*   <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">least_squares</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)"> : 亚像素精度优化方法  一般固定选择一个就行
find_shape_model (ImageRotate, ModelID, rad(</span><span style="color: rgba(128, 0, 128, 1)">0</span>), rad(<span style="color: rgba(128, 0, 128, 1)">360</span>), <span style="color: rgba(128, 0, 128, 1)">0.5</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0.5</span>, <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">least_squares</span><span style="color: rgba(128, 0, 0, 1)">'</span>, [<span style="color: rgba(128, 0, 128, 1)">3</span>,<span style="color: rgba(128, 0, 128, 1)">2</span>], <span style="color: rgba(128, 0, 128, 1)">0.75</span><span style="color: rgba(0, 0, 0, 1)">, Row, Column, Angle, Score)

</span>* -------- 匹配结果后处理 ---------
<span style="color: rgba(0, 0, 255, 1)">for</span> Index := <span style="color: rgba(128, 0, 128, 1)">0</span> to |Row|-<span style="color: rgba(128, 0, 128, 1)">1</span> by <span style="color: rgba(128, 0, 128, 1)">1</span>
    *<span style="color: rgba(0, 0, 0, 1)"> 生成仿射变换矩阵  后面两步的前置变量生成，说白了就是随便创建个矩阵变量
    hom_mat2d_identity (HomMat2D)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 将矩阵叠加旋转和平移变换  想象一下：后两个参数为0 就是绕自身旋转调整角度后直接平移  不为0就是绕某点坐标选择
    hom_mat2d_rotate (HomMat2D, Angle[Index], </span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, HomMat2D)
    hom_mat2d_translate (HomMat2D, Row[Index], Column[Index], HomMat2D)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 通过前面设置的移动矩阵参数  将模板轮廓变换到匹配位置
    affine_trans_contour_xld (ModelContours, TransContours, HomMat2D)
    dev_display (TransContours)  
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 显示变换后的轮廓

    </span>*<span style="color: rgba(0, 0, 0, 1)"> 生成刚体变换矩阵（从模板原点变换到匹配位置）这个给后面的检测区域变换使用  
    </span>*<span style="color: rgba(0, 0, 0, 1)">RowMod  ColumnMod是绘制检测区域的中心点 想象一下：让这个区域跟随你的模板匹配走一样路程到相对应的位置
    vector_angle_to_rigid (RowMod, ColumnMod, </span><span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">,  Row[Index], Column[Index], Angle[Index], HomMat2D2)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 将检测区域ROI变换到匹配位置
    affine_trans_region (Rectangle, RegionAffineTrans2, HomMat2D2, </span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">nearest_neighbor</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 在变换后的ROI内进行阈值分割
    reduce_domain (ImageRotate, RegionAffineTrans2, ImageReduced2)
    threshold (ImageReduced2, Region2, </span><span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">80</span><span style="color: rgba(0, 0, 0, 1)">)
    
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 计算并显示目标中心点
    area_center (Region2, Area2, Row4, Column4)
    gen_cross_contour_xld (Cross, Row4, Column4, </span><span style="color: rgba(128, 0, 128, 1)">15</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)  
    </span>*<span style="color: rgba(0, 0, 0, 1)"> 生成十字标记
endfor
clear_shape_model (ModelID)

</span>*<span style="color: rgba(0, 0, 0, 1)"> 注意：实际工业应用中需添加以下内容：
</span>* <span style="color: rgba(128, 0, 128, 1)">1</span>. 错误处理（<span style="color: rgba(0, 0, 255, 1)">try</span>/<span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)">）
</span>* <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">. 模型资源释放（clear_shape_model）
</span>* <span style="color: rgba(128, 0, 128, 1)">3</span>. 匹配分数过滤（如只保留Score&gt;<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">.65的结果）
</span>* <span style="color: rgba(128, 0, 128, 1)">4</span>. 坐标单位转换（像素到物理尺寸）</span></pre>
</div>
<p>&nbsp;</p>
</div>
<div id="MySignature" role="contentinfo">
    转发和使用本文，请注明作者信息和原文地址---本文原作者为aircraft

---大家好我是徐飞机，有没有大佬们的公司招c++开发/图像处理/opengl/opencv/halcon实习的啊，带上我一个呗QAQ。。。hhhhhh  想要免费获取前端，后端，c/c++,matlab，Python，opencv，机器学习，深度学习，安卓，java，等等全套视频教程请关注机器视觉开发公众号，转发集赞28即可百度云获得hhhhhhhh
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3863909552314815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-20 17:14">2025-03-20 17:14</span>&nbsp;
<a href="https://www.cnblogs.com/DOMLX">aircraft</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18783476" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18783476);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18783476', targetLink: 'https://www.cnblogs.com/DOMLX/p/18783476', title: 'halcon 入门教程（六） 图像匹配（基于形状的模板匹配）与缺陷检测区域定位' })">举报</a>
</div>
        