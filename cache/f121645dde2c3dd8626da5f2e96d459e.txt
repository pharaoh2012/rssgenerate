
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Okalun/p/18678801" title="发布于 2025-01-18 20:15">
    <span role="heading" aria-level="2">unified-message(统一消息平台)开源项目介绍</span>
    

</a>

	</div>
	<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>unified-message(统一消息平台)，为业务系统提供了标准的消息发送功能</p>
<ul>
<li>支持发送短信、邮件、企业微信等消息,可以扩展支持其它的消息类型</li>
<li>可以通过手机号、邮件、企业微信用户名直接发送, 可以直接通过用户名发送短信等</li>
</ul>
<h2 id="项目地址">项目地址</h2>
<p>gitee:  <a href="https://gitee.com/wei772/unified-message" target="_blank" rel="noopener nofollow">https://gitee.com/wei772/unified-message</a></p>
<p>github: <a href="https://github.com/wei772/unified-message" target="_blank" rel="noopener nofollow">https://github.com/wei772/unified-message</a></p>
<h2 id="使用方法">使用方法</h2>
<ul>
<li>
<p>运行项目</p>
</li>
<li>
<p>调用发送消息接口</p>
</li>
</ul>
<pre><code class="language-curl-windows">curl --location --request POST "http://localhost:8080/api/message/send" ^
--header "Content-Type: application/json" ^
--data-raw "{    \"channelName\":\"wecom\",    \"content\":\"测试\",    \"recipients\":[\"LiWei\"]}"
</code></pre>
<h2 id="包结构和主要类介绍">包结构和主要类介绍</h2>
<ul>
<li>domain包
<ul>
<li>包含Message相关领域类</li>
</ul>
</li>
<li>repository包
<ul>
<li>访问数据存储相关类</li>
<li>使用MongoDb存储数据</li>
</ul>
</li>
<li>client包
<ul>
<li>访问第三方服务</li>
<li>使用原始feign访问第三方web接口</li>
</ul>
</li>
<li>command包
<ul>
<li>对应用户用例的实现</li>
<li>使用标准的Command接口</li>
</ul>
</li>
<li>controller包
<ul>
<li>对外提供web接口访问</li>
</ul>
</li>
<li>sender包
<ul>
<li>实现发送Message相关类</li>
</ul>
</li>
</ul>
<h3 id="整洁架构">整洁架构</h3>
<p><img src="https://img2024.cnblogs.com/blog/404395/202501/404395-20250118201504517-713157557.png" alt="整洁架构" loading="lazy"></p>
<p>来源 Robert C. Martin 的《架构整洁之道》，详情查看第22章 整洁架构</p>
<ul>
<li>
<p>业务实体，业务核心包含应用的业务对象</p>
<ul>
<li>包含domain包</li>
</ul>
</li>
<li>
<p>用例，通常包含特定应用场景的业务逻辑</p>
<ul>
<li>包含command包</li>
</ul>
</li>
<li>
<p>接口适配器，软件的接口适配器层中通常是一组数据转换器，它们负责将数据从对用例和业务实体而言最方便操作的格式，转化成外部系统（譬如数据库以及Web）最方便操作的格式。<br>
通常这一层的代码也会负责将数据从对业务实体与用例而言最方便操作的格式，转化为对所采用的持久性框架(譬如数据库)最方便的格式。</p>
<ul>
<li>包含 client 部分抽象和具体类，访问外部接口的网关</li>
<li>包含 repository 的抽象类，比如MessageRepository，是一种数据库网关</li>
<li>包含controller包，对外提供Web接口。接收和返回Web请求数据</li>
</ul>
</li>
<li>
<p>框架与驱动程序，最外层的模型一般是由数据库、Web 框架等组成的。</p>
<ul>
<li>包含client包下的实现类，比如Feign使用BlacktelSendService生成的请求类，对应外部接口</li>
<li>repository实现相关代码，比如MongoMessageRepository，对应数据库访问。</li>
<li>包含Tomcat Web容器和Spring MVC等框架细节</li>
</ul>
</li>
</ul>
<h2 id="测试驱动开发">测试驱动开发</h2>
<p>本项目使用测试驱动开发的方法开发</p>
<h3 id="复杂类的默认态与运行态">复杂类的默认态与运行态</h3>
<p>复杂类一般会依赖外部环境,在代码中体系依赖外部接口。这些外部接口可能也会依赖其它复杂对象。<br>
在Java中IoC框架存在就是用来创建这些复杂类，使用起来十分方便</p>
<p>但是这样创建的类确难以进行单元测试</p>
<ul>
<li>单元测试不应该依赖任何复杂框架，太过笨重，也太过复杂</li>
<li>严重影响单元测试的速度</li>
</ul>
<p>为了兼容单元测试和实际运行的两种情况，我将类分成默认态与运行态的方式。这样保持了类的测试性，又保证了类的功能性</p>
<ul>
<li>使用默认构造函数生成默认状态，用于单元测试
<ul>
<li>默认的实现可以依赖外部，也可以基于Mock依赖，主要看外部调用是否方便、稳定、代价是否合理，比如发送短信代价有点高必须Mock</li>
</ul>
</li>
<li>还有一个由main函数进行组装的，比如基于Spring IoC，用于运行环境的状态
<ul>
<li>使用@Autowired注解指定构造函数，实现该功能</li>
</ul>
</li>
</ul>
<h3 id="效果与感受">效果与感受</h3>
<ul>
<li>
<p>流畅的组织所有开发活动的技术,测试驱动开发这种先写测试再开发的方式很流畅。</p>
<ul>
<li>不要绞尽脑汁再脑中、用文字还有图去思考设计，这种方法浪费时间，想象力也无法有效发挥。</li>
<li>也不会一上来就编码，编写难以执行代码，代码基本没有设计，想到哪写到哪。</li>
<li>使用单元测试可以持续重构，一直保持设计和编码变得更好的</li>
</ul>
</li>
</ul>
<h3 id="测试驱动开发本质">测试驱动开发本质</h3>
<p>下面一些经典数据的一些论述，涉及到测试驱动开发本质</p>
<p>《测试驱动开发 (Kent Beck) 》当中有几段话让我印象深刻，体现了这种方法的核心作用</p>
<ul>
<li>而我从书本上学到的却恰好相反:“编码为今天，设计为明天。”而测试驱动开发看起来已经彻底推翻了这一论点: **“为明天编码，为今天设计。”<br>
** 。</li>
<li>测试(Test)--自动、具体、切实的测试。按一个键就可以让测试运行。具有讽刺意味的是<strong>测试驱动开发不是一种测试技术(Cunningham<br>
Koan)。 它是一种分析技术、设计技术，更是一种组织所有开发活动的技术</strong>。</li>
</ul>
<p>《敏捷整洁之道：回归本源》关于<strong>复式记账</strong>的论述</p>
<ul>
<li>会计师们在1000年前发明了一条法则，并将其称为复式记账。每笔交易会写入账本两次:在一组账户中记一笔贷项，然后相应地在另一组账户中记为借项。<br>
这些账户最终汇总到收支平衡表文件中，用总资产减去总负债和权益。差额必须为零。如果不为零，肯定就出错了</li>
<li><strong>复式记账与TDD这两种纪律是等效的。它们都具有相同的功用:在极其重要的文档中避免错误，确保每个符号都正确。</strong><br>
尽管编程对社会来说已经必不可少，<br>
但我们还没有用法律强制实施 TDD。可是，既然编写糟糕的软件已经造成了生命财产损失，立法还会远吗?</li>
</ul>
<h3 id="测试驱动开发步骤">测试驱动开发步骤</h3>
<p>首先编写任务清单，一般包含设计想法、要实现用例、重构任务等等，将TODO的事情要一个简单的文档记录，整个过程比较随意，有价值的想法就记录下来，完成之后将对应的任务划上删除线。</p>
<p>然后是具体编写过程</p>
<ol>
<li>从任务清单中挑选任务,针对任务编写不通过的单元测试，包括无法编译和运行错误的用例</li>
<li>使单元测试运行通过</li>
<li>重构现有代码，使设计更佳。</li>
</ol>
<p>每次写代码都重复这3个步骤，直到没有需要完成的任务。</p>
<h3 id="其它测试经验">其它测试经验</h3>
<ul>
<li>
<p>单元测试相关代码也很重要</p>
<ul>
<li>Mock代码挺重要，好的Mock代码能够尽可能模拟真实情况，减少gap</li>
<li>执行单元测试的代码的重要性也不言而喻，是测试驱动开发的开始。</li>
</ul>
</li>
<li>
<p>Disabled的单元测试</p>
<ul>
<li>基本都是运行代价比较大或者不稳定的的测试，通常是面向外部依赖。</li>
<li>默认不执行测试，可以单独去执行的测试</li>
</ul>
</li>
<li>
<p>在单元测试注释记录异常</p>
<ul>
<li>在单元测试注释里记录曾经遇过的异常，以及分析还有解决方案，感觉很有趣。</li>
<li>能记录一下曾经遇到过什么问题，并且怎么解决了，既有成就感，又可以有经验的积累和传播</li>
</ul>
</li>
<li>
<p>单元测试不能替代验收测试</p>
<ul>
<li>单元测试通过不保证基本功能正常</li>
<li>但是能极大简化验收测试，一般是因为环境、IoC依赖等出现问题</li>
<li>可以考虑用spring-test进行简单的验收测试</li>
</ul>
</li>
</ul>

</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.005184729506944445" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-18 20:16">2025-01-18 20:15</span>&nbsp;
<a href="https://www.cnblogs.com/Okalun">Okalun</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18678801" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18678801);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18678801', targetLink: 'https://www.cnblogs.com/Okalun/p/18678801', title: 'unified-message(统一消息平台)开源项目介绍' })">举报</a>
</div>
