
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18707646" title="发布于 2025-02-10 13:12">
    <span role="heading" aria-level="2">manim边学边做--通用变换</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在 <code>Manim</code> 动画制作中，<code>Transform</code>、<code>TransformFromCopy</code>、<code>ReplacementTransform</code>和<code>Restore</code>是四个通用的对象变换动画类。</p>
<p>这几个类能够实现从一个对象到另一个对象的<strong>平滑过渡</strong>、<strong>复制并变换</strong>、<strong>直接替换</strong>以及<strong>状态恢复</strong>等多种效果。</p>
<ol>
<li><code>Transform</code>：将一个<code>Mobject</code>平滑地变换为另一个<code>Mobject</code></li>
<li><code>TransformFromCopy</code>：从一个对象复制出一个副本，并将该副本变换为目标对象</li>
<li><code>ReplacementTransform</code>：将一个<code>Mobject</code>替换为另一个 <code>Mobject</code>，并且在变换过程中，原始对象会被目标对象完全替代</li>
<li><code>Restore</code>：将一个<code>Mobject</code>恢复到其之前保存的状态时使用</li>
</ol>
<p>通过这些动画类，我们可以清晰地展示对象之间的关系、强调变换过程、突出替换逻辑，以及灵活地在不同状态之间切换。</p>
<p>它们在数学公式推导、图形变换、场景切换等场景中发挥着重要作用，为动画制作提供了强大的工具，帮助创作者以直观且富有表现力的方式呈现复杂的概念和过程。</p>
<h1 id="1-动画概述">1. 动画概述</h1>
<h2 id="11-transform">1.1. Transform</h2>
<p><code>Transform</code>用于将一个<code>Mobject</code>平滑地变换为另一个<code>Mobject</code>。比如将一个正方形逐渐变为圆形，或者将一段文本替换为另一段文本。</p>
<p>它常用于数学公式推导、图形变换等场景，能够直观地展示从一种状态到另一种状态的过渡。</p>
<p><code>Transform</code> 是一个通用的变换类，可以对形状、位置、颜色等多种属性进行变换。</p>
<p>变换过程中，原始对象和目标对象都会保留在场景中，直到动画结束。如果需要在变换后移除原始对象，需要手动操作。</p>
<p>它的参数主要有：</p>
<table>
<thead>
<tr>
<th><strong>参数名称</strong></th>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>mobject</td>
<td>Mobject</td>
<td>要被变换的对象</td>
</tr>
<tr>
<td>target_mobject</td>
<td>Mobject</td>
<td>变换的目标对象</td>
</tr>
<tr>
<td>path_arc</td>
<td>float</td>
<td>如果使用圆形路径，指定点移动的弧度</td>
</tr>
<tr>
<td>path_func</td>
<td>func</td>
<td>定义了   mobject   的点在变换过程中所走的路径。可以使用 Manim 提供的路径函数或自定义函数。</td>
</tr>
<tr>
<td>path_arc_axis</td>
<td>np.ndarray</td>
<td>如果使用圆形路径，指定旋转的轴</td>
</tr>
<tr>
<td>path_arc_centers</td>
<td>np.ndarray</td>
<td>如果设置了此参数且未设置<code>path_func</code>，则会生成一个沿圆形路径的路径函数。此参数定义了圆形路径的中心。</td>
</tr>
<tr>
<td>replace_mobject_with_target_in_scene</td>
<td>bool</td>
<td>控制动画完成后，是否用<code>target_mobject</code>替换<code>mobject</code></td>
</tr>
</tbody>
</table>
<h2 id="12-transformfromcopy">1.2. TransformFromCopy</h2>
<p>当需要从一个对象复制出一个副本，并将该副本变换为目标对象时使用<code>TransformFromCopy</code>。例如，在讲解数学公式时，从一个已有的公式中复制一部分并将其变换为新的表达式。</p>
<p><code>TransformFromCopy</code>适用于强调某个对象的复制和变换过程，使观众更清楚地看到变换的来源。</p>
<p><code>TransformFromCopy</code>实际上是<code>Transform</code>的一个变体，它先对原始对象进行复制，然后对复制的对象执行变换动画。</p>
<p>原始对象在动画过程中保持不变，变换的是其副本，这使得动画效果更加清晰，避免了原始对象的直接改变。</p>
<p>它的参数类似<code>Transform</code>的参数。</p>
<h2 id="13-replacementtransform">1.3. ReplacementTransform</h2>
<p><code>ReplacementTransform</code>用于将一个<code>Mobject</code>替换为另一个<code>Mobject</code>，并且在变换过程中，原始对象会被目标对象完全替代。</p>
<p>例如，在展示数学公式推导时，将一个公式直接替换为另一个公式，强调两者的等价性或替换关系。</p>
<p><code>ReplacementTransform</code>适用于需要明确表示对象被替换的场景，强调变换的<strong>“替代”</strong>性质。</p>
<p><code>ReplacementTransform</code>继承自<code>Transform</code>类，但它在变换完成后会移除原始对象，只保留目标对象。</p>
<p>它更强调<strong>“替换”</strong>的效果，而不是像<code>Transform</code>那样保留原始对象和目标对象同时存在一段时间。</p>
<p>它的参数类似<code>Transform</code>的参数。</p>
<h2 id="14-restore">1.4. Restore</h2>
<p>当需要将一个<code>Mobject</code>恢复到其之前保存的状态时使用<code>Restore</code>。</p>
<p>例如，在对一个图形进行了一系列复杂的变换后，需要将其恢复到初始状态，或者在展示一个对象的多种变换后，恢复到某个特定的中间状态。</p>
<p><code>Restore</code>适用于需要反复展示对象不同状态的场景，如对比不同变换效果、演示可逆变换等。</p>
<p>它需要先通过<code>Mobject.save_state()</code>方法保存对象的状态，然后才能使用<code>Restore</code>动画将其恢复。</p>
<p>它的参数主要有：</p>
<table>
<thead>
<tr>
<th><strong>参数名称</strong></th>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>mobject</td>
<td>Mobject</td>
<td>要恢复的对象</td>
</tr>
</tbody>
</table>
<h1 id="2-使用示例">2. 使用示例</h1>
<p>下面通过示例来演示这几个转换动画的效果。</p>
<h2 id="21-通用转换transform">2.1. 通用转换Transform</h2>
<p>这个示例中，将一个数学公式和一个图形平滑地变换为另一个公式和图形。</p>
<p>变换中，设置了<code>path_arc</code>参数，以一个弧形的路径变换为目标对象。</p>
<pre><code class="language-python"># 创建初始公式
f1 = MathTex("a^2 + b^2 = c^2").shift(UP)
# 创建目标公式
f2 = MathTex("c = \\sqrt{a^2 + b^2}").shift(DOWN)

# 创建一个正方形
square = Square(side_length=1, color=BLUE).shift(DOWN)
# 创建一个圆形
circle = Circle(radius=0.6).shift(UP)

self.add(f1, square)
self.wait()
# 使用 Transform 将公式1变换为公式2,将正方形变换为圆形
self.play(
    Transform(f1, f2, path_arc=PI),
    Transform(square, circle, path_arc=PI),
)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202502/83005-20250210131118623-1076534197.gif" alt="" loading="lazy"></p>
<h2 id="22-比较replace和copy的不同">2.2. 比较Replace和Copy的不同</h2>
<p>通过这个示例，可以了解<code>TransformFromCopy</code>和<code>ReplacementTransform</code>两种动画效果的区别，帮助我们根据实际需求选择合适的动画类。</p>
<p>对于<code>TransformFromCopy</code>：</p>
<ol>
<li>从原始对象复制出一个副本，并对副本进行变换</li>
<li>原始对象保持不变，变换的是副本</li>
<li>适用于需要保留原始对象的场景</li>
</ol>
<p>对于<code>ReplacementTransform</code>：</p>
<ol>
<li>直接将原始对象替换为目标对象</li>
<li>原始对象在动画结束后被移除，目标对象取代其位置</li>
<li>适用于需要明确表示对象被替换的场景</li>
</ol>
<p>下面的示例中，<code>TransformFromCopy</code>每次转换都会保存原对象，而<code>ReplacementTransform</code>则只保留变换后的目标对象。</p>
<pre><code class="language-python"># 创建两个相同的正方形作为原对象
s1 = Square().shift(LEFT * 1.5)
s2 = Square().shift(RIGHT * 1.5)

# 创建两个圆形作为目标对象
c1 = Circle().shift(LEFT * 1.5)
c2 = Circle().shift(RIGHT * 1.5)

t1 = Triangle().shift(LEFT * 1.5)
t2 = Triangle().shift(RIGHT * 1.5)

# 添加原对象到场景中
self.add(s1, s2)
self.wait(1)

# 添加标题用于区分两种变换
title1 = Text(
    "TransformFrom Copy",
    t2g={"Copy": [BLUE, RED, YELLOW]},
    font_size=25,
).next_to(s1, UP)
title2 = Text(
    "Replacement Transform",
    t2g={"Replacement": [BLUE, RED, YELLOW]},
    font_size=25,
).next_to(s2, DOWN)
self.add(title1, title2)
self.wait()

# 使用 TransformFromCopy 对左边的图形进行变换
# 使用 ReplacementTransform 对右边的图形进行变换
self.play(
    TransformFromCopy(s1, c1),
    ReplacementTransform(s2, c2),
)
self.wait()
self.play(
    TransformFromCopy(c1, t1),
    ReplacementTransform(c2, t2),
)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202502/83005-20250210131119018-1096667034.gif" alt="" loading="lazy"></p>
<h2 id="23-恢复初始状态restore">2.3. 恢复初始状态Restore</h2>
<p>这个示例中，先创建一个<strong>六边形</strong>，先变换成<strong>星形</strong>，再经过一系列其他的变换，比如颜色，透明度，移动，放大，翻转等变换。</p>
<p>最后通过<code>Restore</code>直接恢复成原始状态。</p>
<pre><code class="language-python"># 创建一个六边形
hexagon = RegularPolygon(n=6)
# 保存六边形的初始状态
self.add(hexagon)
hexagon.save_state()
# 将六边形变换为一个星形
star = Star(color=RED)
self.play(Transform(hexagon, star), run_time=run_time)
self.wait()
self.play(Restore(hexagon))

self.play(hexagon.animate.set_color(YELLOW).set_opacity(0.4), run_time=run_time)
self.play(hexagon.animate.shift(RIGHT).scale(2), run_time=run_time)
self.play(hexagon.animate.rotate(PI * 0.75), run_time=run_time)

# 使用 Restore 恢复六边形的初始状态
self.play(Restore(hexagon))
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202502/83005-20250210131118747-918235155.gif" alt="" loading="lazy"></p>
<h1 id="3-附件">3. 附件</h1>
<p>文中的代码只是关键部分的截取，完整的代码共享在网盘中（<code>transform.py</code>），</p>
<p>下载地址: <a href="https://url11.ctfile.com/d/45455611-64751047-a5be65?p=6872" target="_blank" rel="noopener nofollow">完整代码</a> (访问密码: 6872)</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.047299646295138886" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-10 13:12">2025-02-10 13:12</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18707646" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18707646);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18707646', targetLink: 'https://www.cnblogs.com/wang_yb/p/18707646', title: 'manim边学边做--通用变换' })">举报</a>
</div>
        