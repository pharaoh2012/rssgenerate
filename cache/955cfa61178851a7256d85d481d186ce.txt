
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kklldog/p/19020718" title="发布于 2025-08-04 00:18">
    <span role="heading" aria-level="2">如何正确实现一个 BackgroundService</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>相信大家都知道如何在 .NET 中执行后台（定时）任务。首先我们会选择实现 IHostedService 接口或者继承BackgroundService 来实现后台任务。然后注册到容器内，然后注册到容器内，之后这些后台任务 service 就会自动被 触发（trigger）。本文不是初级的入门教程，而是试图告诉读者一些容易被忽略的细节。</p>
<h2 id="ihostedservice">IHostedService</h2>
<p>IHostedService 是一个.NET Core 的接口，用于实现后台服务。通过实现这个接口，你可以在应用程序运行期间在后台执行任务，例如定时任务、监听事件、处理队列等。IHostedService 提供了 StartAsync() 和 StopAsync() 方法，分别用于启动和停止后台服务，并且框架会根据应用程序的生命周期自动调用这两个方法。<br>
以下是这个接口的源码：</p>
<p>其中 <code>StartAsync</code> 方法由 <code>IApplicationLifetime.ApplicationStarted</code> 事件触发<br>
其中 <code>StopAsync</code> 方法由 <code>IApplicationLifetime.ApplicationStopped</code> 事件触发</p>
<pre><code> //
 // 摘要:
 //     Defines methods for objects that are managed by the host.
 public interface IHostedService
 {
  
     Task StartAsync(CancellationToken cancellationToken);

     Task StopAsync(CancellationToken cancellationToken);
 }
</code></pre>
<p>通常我们的后台任务会被框在一个while循环里，定时去执行某些逻辑。以下是我们模拟的一段演示代码。StartAsync 方法被 call 的时候就会执行这个 while。代码很简单，不过多解释。</p>
<pre><code>    public class HostServiceTest_A : IHostedService
    {
        public async Task StartAsync(CancellationToken cancellationToken)
        {
            Console.WriteLine("HostServiceTest_A starting.");

            while (!cancellationToken.IsCancellationRequested)
            {
                // Simulate some work
                Console.WriteLine("HostServiceTest_A is doing work.");

                await Task.Delay(3000, cancellationToken); // Delay for 3 second
            }
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            // to do

            return Task.CompletedTask;
        }
    }

</code></pre>
<p>把这个服务注册到容器内。</p>
<pre><code>    builder.Services.AddHostedService&lt;HostServiceTest_A&gt;();
</code></pre>
<p>下面让我们启动一下程序试试。可以看到程序可以启动，这个 while 循环也是一直在工作。咋看好像没啥问题，但是仔细看看的话好像缺了点什么。</p>
<h3 id="问题">问题</h3>
<p>对了，我们这个 ASP.NET Core 程序启动日志没有了。也就是整个程序的启动过程被 block 住了。原因在于 HostedService 是顺序的，一旦某个 HostedService 的 StartAsync 方法没有尽快 return 的话，后面所有的任务全部不能执行了。比如你注册了多个 HostedService，第一个使用了这种错误的方法来执行任务，后面的 HostedService 全部都没有机会被执行。</p>
<pre><code>HostServiceTest_A starting.
HostServiceTest_A is doing work.
HostServiceTest_A is doing work.
HostServiceTest_A is doing work.
HostServiceTest_A is doing work.
···
</code></pre>
<p>下面让我们改进一下，使用 Task.Run 来让这个任务变成异步，并且不去 await 这个 task。</p>
<pre><code>    public class HostServiceTest_A : IHostedService
    {
        public Task StartAsync(CancellationToken cancellationToken)
        {
            Console.WriteLine("HostServiceTest_A starting.");

            Task.Run(async () =&gt; {
                while (!cancellationToken.IsCancellationRequested)
                {
                    // Simulate some work
                    Console.WriteLine("HostServiceTest_A is doing work.");

                    await Task.Delay(3000, cancellationToken); // Delay for 3 second
                }
            });

            return Task.CompletedTask;
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            return Task.CompletedTask;
        }
    }
</code></pre>
<p>再次执行一下程序，可以看到 HostedService 跟 ASP.NET Core 主程序都可以正确执行了。</p>
<pre><code>HostServiceTest_A starting.
HostServiceTest_A is doing work.
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5221
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
info: Microsoft.Hosting.Lifetime[0]
      Content root path: D:\workspace\BackgroundServiceDemo\BackgroundServiceDemo
HostServiceTest_A is doing work.
</code></pre>
<h3 id="改进">改进</h3>
<p>我们的后台任务通常是一个长期任务，这种情况下更加推荐 LongRunning Task 来 handle 这种任务。至于为什么可以参考以下文档：<br>
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcreationoptions?view=net-9.0" target="_blank" rel="noopener nofollow">https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcreationoptions?view=net-9.0</a></p>
<pre><code>           Task.Factory.StartNew(async () =&gt; {
               while (!cancellationToken.IsCancellationRequested)
               {
                   // Simulate some work
                   Console.WriteLine("HostServiceTest_A is doing work.");

                   await Task.Delay(3000, cancellationToken); // Delay for 3 second
               }
           }, TaskCreationOptions.LongRunning);

           return Task.CompletedTask;
</code></pre>
<h3 id="退出">退出</h3>
<p>以上我们都在说如何启动后台任务，还没讨论如何取消这个后台任务。参入的那个 cancellationToken 在 Application 被 stop 的时候并不会主动 cancel。所以我们需要在 StopAsync 方法触发的时候手动来 Cancel 这个 token。</p>
<pre><code>    public class HostServiceTest_A : IHostedService
    {
        private CancellationTokenSource _cancellationTokenSource;

        public Task StartAsync(CancellationToken cancellationToken)
        {
            Console.WriteLine("HostServiceTest_A starting.");

            _cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

            Task.Factory.StartNew(async () =&gt; {
                while (!_cancellationTokenSource.Token.IsCancellationRequested)
                {
                    // Simulate some work
                    Console.WriteLine("HostServiceTest_A is doing work.");

                    await Task.Delay(1000, cancellationToken); // Delay for 3 second
                }

                Console.WriteLine("HostServiceTest_A task done.");

            }, TaskCreationOptions.LongRunning);

            return Task.CompletedTask;
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {

            if (!cancellationToken.IsCancellationRequested)
            {
                _cancellationTokenSource.Cancel();
            }

            Console.WriteLine("HostServiceTest_A stop.");

            return Task.CompletedTask;
        }
    }
</code></pre>
<p>让我们运行一下，然后按下 Ctrl + C 来主动退出程序，可以看到我们的 while 被安全退出了。</p>
<pre><code>HostServiceTest_A starting.
HostServiceTest_A is doing work.
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5221
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
info: Microsoft.Hosting.Lifetime[0]
      Content root path: D:\workspace\BackgroundServiceDemo\BackgroundServiceDemo
HostServiceTest_A is doing work.
HostServiceTest_A is doing work.
HostServiceTest_A is doing work.
info: Microsoft.Hosting.Lifetime[0]
      Application is shutting down...
HostServiceTest_A stop.
HostServiceTest_A task done.
</code></pre>
<h2 id="backgroundservice">BackgroundService</h2>
<p>除了，<code>HostedService</code>，微软还给我们提供了 <code>BackgroundService</code> 这个类。一看这个类名就知道他能干嘛。其实也未必想的这么简单。BackgroundService 实际上是 IHostedService 的一个实现类。它的核心是将后台任务逻辑放在 <code>ExecuteAsync</code> 这个抽象方法中。下面我们通过一个具体案例来分析。。</p>
<pre><code>    public class BackgroundServiceTest_A : BackgroundService
    {
        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                Console.WriteLine("ExecuteAsyncA is running.");

                await Task.Delay(3000);
            }
        }
    }
</code></pre>
<p>运行这个代码，可以看到 BackgroundService 正常启动了，而且也没 block 住 ASP.NET Core 的程序。看是一切完美。</p>
<pre><code>ExecuteAsyncA is running.
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5221
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
info: Microsoft.Hosting.Lifetime[0]
      Content root path: D:\workspace\BackgroundServiceDemo\BackgroundServiceDemo
ExecuteAsyncA is running.
ExecuteAsyncA is running.
ExecuteAsyncA is running.
ExecuteAsyncA is running.
ExecuteAsyncA is running.
</code></pre>
<h3 id="问题-1">问题</h3>
<p>以上代码真的没有问题吗？其实不尽然。让我们上点强度。如果我们在循环中加一个耗时很长的步骤。事实上这个很常见。比如以下代码：</p>
<pre><code>    public class BackgroundServiceTest_A : BackgroundService
    {
        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                Console.WriteLine("ExecuteAsyncA is running.");

                LongTermTask();

                await Task.Delay(3000);
            }
        }

        private void LongTermTask()
        {
            // Simulate some work
            Console.WriteLine("LongTermTaskA is doing work.");
            Thread.Sleep(30000);
        }
    }
</code></pre>
<p>再次运行以下，我们可以发现 ASP.NET Core 的主程序起不来了，被 block 住了。只有等第一个循环周期过后，主程序才能启动起来。</p>
<pre><code>ExecuteAsyncA is running.
LongTermTaskA is doing work.
</code></pre>
<p>那么问题到底出在哪？让我们看看 <code>BackgroundService</code> 的源码。</p>
<pre><code>        public virtual Task StartAsync(CancellationToken cancellationToken)
        {
            // Create linked token to allow cancelling executing task from provided token
            _stoppingCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

            // Store the task we're executing
            _executeTask = ExecuteAsync(_stoppingCts.Token);

            // If the task is completed then return it, this will bubble cancellation and failure to the caller
            if (_executeTask.IsCompleted)
            {
                return _executeTask;
            }

            // Otherwise it's running
            return Task.CompletedTask;
        }
</code></pre>
<p>可以看到 <code>StartAsync</code> 方法会调用 <code>ExecuteAsync</code>，但是它没有 await 这个方法，也就是说 <code>StartAsync</code> 内部实现是个同步方法。也就是说 <code>ExecuteAsync</code> 方法跟 <code>StartAsync</code> 会在同一个线程上被执行（在遇到第一个 await 之前）。如果你注册了多个 <code>BackgroundService</code> 并且他们一次 loop 都非常耗时，那么这个程序启动将会非常耗时。其实微软已经在文档上提醒大家了：</p>
<blockquote>
<p>Avoid performing long, blocking initialization work in ExecuteAsync.</p>
</blockquote>
<h3 id="改进-1">改进</h3>
<p>那么改进方法，同样使用 Task.Factory.StartNew 来构造一个  LongRunning 的 task 就可以解决。</p>
<pre><code>    public class BackgroundServiceTest_A : BackgroundService
    {
        protected override Task ExecuteAsync(CancellationToken stoppingToken)
        {
            return Task.Factory.StartNew(async () =&gt;
            {
                while (!stoppingToken.IsCancellationRequested)
                {
                    // Simulate some work
                    Console.WriteLine("HostServiceTest_A is doing work.");

                    LongTermTask();

                    await Task.Delay(1000, stoppingToken); // Delay for 1 second
                }

                Console.WriteLine("HostServiceTest_A task done.");

            }, TaskCreationOptions.LongRunning);
        }

        private void LongTermTask()
        {
            // Simulate some work
            Console.WriteLine("LongTermTaskA is doing work.");
            Thread.Sleep(30000);
        }
    }
</code></pre>
<p>运行一下，完美启动后台任务跟主程序。</p>
<pre><code>HostServiceTest_A is doing work.
LongTermTaskA is doing work.
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://localhost:5221
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
info: Microsoft.Hosting.Lifetime[0]
      Content root path: D:\workspace\BackgroundServiceDemo\BackgroundServiceDemo
</code></pre>
<h3 id="继续改进">继续改进</h3>
<p>如果要继续吹毛求疵的话，我们还可以改进一下。从 .NET6 开始 <code>PeriodicTimer</code> 被加入进来。它是一个 timer，可以替换一部分 <code>Task.Delay</code> 活。使用 <code>PeriodicTimer</code> 话相对于 <code>Task.Delay</code> 来说可以让 loop 的间隔更加精准的被控制。<br>
详见这里 <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.periodictimer.waitfornexttickasync?view=net-9.0" target="_blank" rel="noopener nofollow">https://learn.microsoft.com/en-us/dotnet/api/system.threading.periodictimer.waitfornexttickasync?view=net-9.0</a></p>
<pre><code>     protected override Task ExecuteAsync(CancellationToken stoppingToken)
     {
         return Task.Factory.StartNew(async () =&gt;
         {
             var timer = new PeriodicTimer(TimeSpan.FromSeconds(1));

             while (await timer.WaitForNextTickAsync(stoppingToken))
             {
                 // Simulate some work
                 Console.WriteLine("HostServiceTest_A is doing work.");
                 LongTermTask();
             }

             Console.WriteLine("HostServiceTest_A task done.");

         }, TaskCreationOptions.LongRunning);
     }
</code></pre>
<h2 id="总结">总结</h2>
<p>通过以上的演示，我们可以感受到，实现一个后台任务还是有非常多的点需要被注意的。特别是不要在 StartAsync 或者 <code>ExcuteAsync</code> 方法内执行耗时的同步方法。如果有耗时任务请包裹在新的 Task 内执行。我们要保证这两个方法轻量化能够被快速的执行完毕，这样的话不会影响应用程序的启动。</p>

</div>
<div id="MySignature" role="contentinfo">
    <div id="AllanboltSignature">        
<p id="PSignature" style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 10px; font-family: 微软雅黑; font-size: 11px">       
QQ群：1022985150 VX：kklldog 一起探讨学习.NET技术
<br>
作者：<a href="http://www.cnblogs.com/kklldog" target="_blank">Agile.Zhou(kklldog)</a>            
<br> 
出处：<a href="http://www.cnblogs.com/kklldog/" target="_blank">http://www.cnblogs.com/kklldog/</a>
<br>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。
 </p>  
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-04 00:18">2025-08-04 00:18</span>&nbsp;
<a href="https://www.cnblogs.com/kklldog">Agile.Zhou</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19020718);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19020718', targetLink: 'https://www.cnblogs.com/kklldog/p/19020718', title: '如何正确实现一个 BackgroundService' })">举报</a>
</div>
        