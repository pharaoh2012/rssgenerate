
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chenshibao/p/18733041" title="发布于 2025-02-23 23:05">
    <span role="heading" aria-level="2">Redis中的缓存穿透，缓存击穿和缓存雪崩</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="概述">概述</h1>
<p>缓存击穿、缓存穿透、缓存雪崩这三个问题是Reids在实际项目中会经常遇到问题，同时，这三个问题也是面试的热点问题，下面，就本篇文章搞懂缓存穿透、缓存击穿、缓存雪崩三大问题的原因及解决方法。</p>
<p>Redis在项目中作为缓存中间件是如何工作的？如图所示<br>
<img src="https://img2024.cnblogs.com/blog/2212230/202502/2212230-20250223224312403-1170793372.png" alt="image" loading="lazy"></p>
<p>客户端发起一个查询请求的时候，首先去缓存中查询，如果数据在缓存中存在，则直接将缓存中的数据返回给客户端；如果数据在缓存中不存在，则继续查询数据库，如果数据在数据库中存在，则将该数据放入缓存中，并返回给客户端，如果数据在数据库中也不存在，则直接返回null给客户端。</p>
<h2 id="1缓存穿透">1.缓存穿透</h2>
<h3 id="11-什么是缓存穿透">1.1 什么是缓存穿透</h3>
<p>缓存穿透是指查询一个缓存中和数据库中都不存在的数据，导致每次查询这条数据都会透过缓存，直接查库，最后返回空。当用户使用这条不存在的数据疯狂发起查询请求的时候，对数据库造成的压力就非常大，甚至可能直接挂掉。这种情况的流程就变成下图这样了：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202502/2212230-20250223224518854-503521277.png" alt="image" loading="lazy"></p>
<h3 id="12-解决方案">1.2 解决方案</h3>
<p>解决缓存穿透的方法一般有两种，第一种是缓存空对象，第二种是使用布隆过滤器。</p>
<h4 id="121-缓存空对象">1.2.1 缓存空对象</h4>
<p>第一种方法比较好理解，就是当数据库中查不到数据的时候，我缓存一个空对象，然后给这个空对象的缓存设置一个过期时间，这样下次再查询该数据的时候，就可以直接从缓存中拿到，从而达到了减小数据库压力的目的。<br>
但这种解决方式有两个缺点：<br>
（1）需要缓存层提供更多的内存空间来缓存这些空对象，当这种空对象很多的时候，就会浪费更多的内存；<br>
（2）会导致缓存层和存储层的数据不一致，即使在缓存空对象时给它设置了一个很短的过期时间，那也会导致这一段时间内的数据不一致问题。</p>
<h4 id="122-布隆过滤器">1.2.2 布隆过滤器</h4>
<p>使用布隆过滤器，这是比较推荐的方法。所谓布隆过滤器，就是一种数据结构，它是由一个长度为m bit的位数组与n个hash函数组成的数据结构，位数组中每个元素的初始值都是0。在初始化布隆过滤器时，会先将所有key进行n次hash运算，这样就可以得到n个位置，然后将这n个位置上的元素改为1。这样，就相当于把所有的key保存到了布隆过滤器中了。</p>
<p>举个例子，比如我们一共有3个key，我们对这3个key分别进行3次hash运算，key1经过三次hash运算后的结果分别为2/6/10，那么就把布隆过滤器中下标为2/6/10的元素值更新为1，然后再分别对key2和key3做同样操作，结果如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202502/2212230-20250223225109294-749323854.png" alt="image" loading="lazy"></p>
<p>这样，当客户端查询时，也对查询的key做3次hash运算得到3个位置，然后看布隆过滤器中对应位置元素的值是否为1，如果所有对应位置元素的值都为1，就证明key在库中存在，则继续向下查询；如果3个位置中有任意一个位置的值不为1，那么就证明key在库中不存在，直接返回客户端空即可。如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202502/2212230-20250223225138993-1792392924.png" alt="image" loading="lazy"></p>
<p>当客户端查询key4时，key4的3次hash运算中，有一个位置8的值为0，就说明key4在库中不存在，直接返回客户端空即可。</p>
<p>所以，布隆过滤器就相当于一个位于客户端与缓存层中间的拦截器一样，负责判断key是否在集合中存在。如下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202502/2212230-20250223225319017-1067353332.png" alt="image" loading="lazy"></p>
<p>布隆过滤器的好处就是解决了第一种缓存空值的不足，但布隆过滤器也存在缺陷，<br>
首先，它有误判的可能，比如在上面客户端查询key4的图中，假如key4经过3次hash运算得到的位置分别是2/4/6，由于这3个位置的值都是1，所以，布隆过滤器就认为key4在库中存在，进而继续向下查询了。所以，布隆过滤器判断存在的key实际上可能是不存在的，但布隆过滤器判断不存在的key是一定不存在的。<br>
它的第二个缺点就是删除元素比较难，比如现在要删除key2这个元素，那么需要将2/7/11三个位置的元素值改为0，但这样就会影响到key1和key3的判断。</p>
<h2 id="2缓存击穿">2.缓存击穿</h2>
<h3 id="21-什么是缓存击穿">2.1 什么是缓存击穿</h3>
<p>缓存击穿是指当缓存中某个热点数据过期了，在该热点数据重新载入缓存之前，有大量的查询请求穿过缓存，直接查询数据库。这种情况会导致数据库压力瞬间骤增，造成大量请求阻塞，甚至直接挂掉。</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202502/2212230-20250223225625151-1740297.png" alt="image" loading="lazy"></p>
<h3 id="22-解决方案">2.2 解决方案</h3>
<p>解决缓存击穿的方法也有两种，第一种是设置key永不过期；第二种是使用分布式锁，保证同一时刻只能有一个查询请求重新加载热点数据到缓存中，这样，其他的线程只需等待该线程运行完毕，即可重新从Redis中获取数据。</p>
<h4 id="221-热点key值永不过期">2.2.1 热点Key值永不过期</h4>
<p>第一种方式比较简单，在设置热点key的时候，不给key设置过期时间即可。不过还有另外一种方式也可以达到key不过期的目的，就是正常给key设置过期时间，不过在后台同时启一个定时任务去定时地更新这个缓存。<br>
<img src="https://img2024.cnblogs.com/blog/2212230/202502/2212230-20250223225833472-1899887355.png" alt="image" loading="lazy"></p>
<h4 id="222-分布式锁并发更新">2.2.2 分布式锁并发更新</h4>
<p>第二种方式使用了加锁的方式，锁的对象就是key，这样，当大量查询同一个key的请求并发进来时，只能有一个请求获取到锁，然后获取到锁的线程查询数据库，然后将结果放入到缓存中，然后释放锁，此时，其他处于锁等待的请求即可继续执行，由于此时缓存中已经有了数据，所以直接从缓存中获取到数据返回，并不会查询数据库。</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202502/2212230-20250223230142703-1231847868.png" alt="image" loading="lazy"></p>
<h2 id="3缓存雪崩">3.缓存雪崩</h2>
<h3 id="31-什么是缓存雪崩">3.1 什么是缓存雪崩</h3>
<p>缓存雪崩是指当缓存中有大量的key在同一时刻过期，或者Redis直接宕机了，导致大量的查询请求全部到达数据库，造成数据库查询压力骤增，甚至直接挂掉。</p>
<p><img src="https://img2024.cnblogs.com/blog/2212230/202502/2212230-20250223230308629-1871854920.png" alt="image" loading="lazy"></p>
<h3 id="32-解决方案">3.2 解决方案</h3>
<p>针对第一种大量key同时过期的情况，解决起来比较简单，只需要将每个key的过期时间打散即可，使它们的失效点尽可能均匀分布。<br>
针对第二种redis发生故障的情况，部署redis时可以使用redis的几种高可用方案部署<br>
除了上面两种解决方式，还可以使用其他策略，比如设置key永不过期、加分布式锁等。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="5.216329518849537" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-23 23:05">2025-02-23 23:05</span>&nbsp;
<a href="https://www.cnblogs.com/chenshibao">似梦亦非梦</a>&nbsp;
阅读(<span id="post_view_count">77</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18733041" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18733041);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18733041', targetLink: 'https://www.cnblogs.com/chenshibao/p/18733041', title: 'Redis中的缓存穿透，缓存击穿和缓存雪崩' })">举报</a>
</div>
        