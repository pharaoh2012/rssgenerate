
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/youzhibing/p/18622761" title="发布于 2024-12-23 09:08">
    <span role="heading" aria-level="2">如果XXL-JOB执行器在执行某任务中被重启了，重启后该任务能够被自动弥补调度吗</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="开心一刻">开心一刻</h2>
<p>上午，走路不小心踩了钉子，去打了破伤风<br>
下午，又特么踩到了钉子，我问医生<br>
我：还需要打针吗<br>
医生：你有那钱还是看看眼睛吧</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225951524-1181034113.gif" alt="宋小宝_红帽大笑" width="200px"></div>
<h2 id="基础回顾">基础回顾</h2>
<p>项目基于 <code>xxl-job 2.1.0</code> 实现的分布式调度，所以我还是基于此来模拟实现我们的项目；关于 <code>XXL-JOB</code>，本文不做额外介绍，大家可以去看官网</p>
<blockquote>
<p><a href="https://www.xuxueli.com/xxl-job/" target="_blank" rel="noopener nofollow">https://www.xuxueli.com/xxl-job/</a></p>
</blockquote>
<p>或者我之前的博客</p>
<blockquote>
<p><a href="https://www.cnblogs.com/youzhibing/p/13237576.html" target="_blank">分布式任务调度平台 → XXL-JOB 初探</a><br><a href="https://www.cnblogs.com/youzhibing/p/13402018.html" target="_blank">分布式任务调度平台 → XXL-JOB 实战</a><br><a href="https://www.cnblogs.com/youzhibing/p/16712462.html" target="_blank">当 xxl-job 遇上 docker → 它晕了，我也乱了！</a><br><a href="https://www.cnblogs.com/youzhibing/p/16935674.html" target="_blank">当 xxl-job 遇上 docker → 它晕了，但我不能乱！</a></p>
</blockquote>
<p><code>XXL-JOB</code> 分两块：<code>调度中心</code> 和 <code>执行器</code></p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950631-787275093.png" alt="xxl-job架构图" width="900px"></div>
<p>其中 <code>调度中心</code> 就是 <code>xxl-job-admin</code>，已经是一个完善的模块，直接部署使用即可；而 <code>执行器</code> ，也就是任务执行器，需要跟我们的业务代码绑定，完成我们的业务逻辑，我们一个一个来部署</p>
<ol>
<li>
<p>调度中心</p>
<p>xxl-job-admin 有自己的表，官方提供了初始化 SQL：<code>tables_xxl-job.sql</code></p>
<pre><code class="language-sql">CREATE database if NOT EXISTS `xxl_job` default character set utf8 collate utf8_general_ci;
use `xxl_job`;


CREATE TABLE `xxl_job_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `job_group` int(11) NOT NULL COMMENT '执行器主键ID',
  `job_cron` varchar(128) NOT NULL COMMENT '任务执行CRON',
  `job_desc` varchar(255) NOT NULL,
  `add_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `author` varchar(64) DEFAULT NULL COMMENT '作者',
  `alarm_email` varchar(255) DEFAULT NULL COMMENT '报警邮件',
  `executor_route_strategy` varchar(50) DEFAULT NULL COMMENT '执行器路由策略',
  `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',
  `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',
  `executor_block_strategy` varchar(50) DEFAULT NULL COMMENT '阻塞处理策略',
  `executor_timeout` int(11) NOT NULL DEFAULT '0' COMMENT '任务执行超时时间，单位秒',
  `executor_fail_retry_count` int(11) NOT NULL DEFAULT '0' COMMENT '失败重试次数',
  `glue_type` varchar(50) NOT NULL COMMENT 'GLUE类型',
  `glue_source` mediumtext COMMENT 'GLUE源代码',
  `glue_remark` varchar(128) DEFAULT NULL COMMENT 'GLUE备注',
  `glue_updatetime` datetime DEFAULT NULL COMMENT 'GLUE更新时间',
  `child_jobid` varchar(255) DEFAULT NULL COMMENT '子任务ID，多个逗号分隔',
  `trigger_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '调度状态：0-停止，1-运行',
  `trigger_last_time` bigint(13) NOT NULL DEFAULT '0' COMMENT '上次调度时间',
  `trigger_next_time` bigint(13) NOT NULL DEFAULT '0' COMMENT '下次调度时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `xxl_job_log` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `job_group` int(11) NOT NULL COMMENT '执行器主键ID',
  `job_id` int(11) NOT NULL COMMENT '任务，主键ID',
  `executor_address` varchar(255) DEFAULT NULL COMMENT '执行器地址，本次执行的地址',
  `executor_handler` varchar(255) DEFAULT NULL COMMENT '执行器任务handler',
  `executor_param` varchar(512) DEFAULT NULL COMMENT '执行器任务参数',
  `executor_sharding_param` varchar(20) DEFAULT NULL COMMENT '执行器任务分片参数，格式如 1/2',
  `executor_fail_retry_count` int(11) NOT NULL DEFAULT '0' COMMENT '失败重试次数',
  `trigger_time` datetime DEFAULT NULL COMMENT '调度-时间',
  `trigger_code` int(11) NOT NULL COMMENT '调度-结果',
  `trigger_msg` text COMMENT '调度-日志',
  `handle_time` datetime DEFAULT NULL COMMENT '执行-时间',
  `handle_code` int(11) NOT NULL COMMENT '执行-状态',
  `handle_msg` text COMMENT '执行-日志',
  `alarm_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '告警状态：0-默认、1-无需告警、2-告警成功、3-告警失败',
  PRIMARY KEY (`id`),
  KEY `I_trigger_time` (`trigger_time`),
  KEY `I_handle_code` (`handle_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `xxl_job_logglue` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `job_id` int(11) NOT NULL COMMENT '任务，主键ID',
  `glue_type` varchar(50) DEFAULT NULL COMMENT 'GLUE类型',
  `glue_source` mediumtext COMMENT 'GLUE源代码',
  `glue_remark` varchar(128) NOT NULL COMMENT 'GLUE备注',
  `add_time` timestamp NULL DEFAULT NULL,
  `update_time` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `xxl_job_registry` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `registry_group` varchar(255) NOT NULL,
  `registry_key` varchar(255) NOT NULL,
  `registry_value` varchar(255) NOT NULL,
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `i_g_k_v` (`registry_group`,`registry_key`,`registry_value`),
  KEY `i_u` (`update_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `xxl_job_group` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `app_name` varchar(64) NOT NULL COMMENT '执行器AppName',
  `title` varchar(12) NOT NULL COMMENT '执行器名称',
  `order` tinyint(4) NOT NULL DEFAULT '0' COMMENT '排序',
  `address_type` tinyint(4) NOT NULL DEFAULT '0' COMMENT '执行器地址类型：0=自动注册、1=手动录入',
  `address_list` varchar(512) DEFAULT NULL COMMENT '执行器地址列表，多地址逗号分隔',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `xxl_job_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL COMMENT '账号',
  `password` varchar(50) NOT NULL COMMENT '密码',
  `role` tinyint(4) NOT NULL COMMENT '角色：0-普通用户、1-管理员',
  `permission` varchar(255) DEFAULT NULL COMMENT '权限：执行器ID列表，多个逗号分割',
  PRIMARY KEY (`id`),
  UNIQUE KEY `i_username` (`username`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `xxl_job_lock` (
  `lock_name` varchar(50) NOT NULL COMMENT '锁名称',
  PRIMARY KEY (`lock_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;


INSERT INTO `xxl_job_group`(`id`, `app_name`, `title`, `order`, `address_type`, `address_list`) VALUES (1, 'xxl-job-executor-sample', '示例执行器', 1, 0, NULL);
INSERT INTO `xxl_job_info`(`id`, `job_group`, `job_cron`, `job_desc`, `add_time`, `update_time`, `author`, `alarm_email`, `executor_route_strategy`, `executor_handler`, `executor_param`, `executor_block_strategy`, `executor_timeout`, `executor_fail_retry_count`, `glue_type`, `glue_source`, `glue_remark`, `glue_updatetime`, `child_jobid`) VALUES (1, 1, '0 0 0 * * ? *', '测试任务1', '2018-11-03 22:21:31', '2018-11-03 22:21:31', 'XXL', '', 'FIRST', 'demoJobHandler', '', 'SERIAL_EXECUTION', 0, 0, 'BEAN', '', 'GLUE代码初始化', '2018-11-03 22:21:31', '');
INSERT INTO `xxl_job_user`(`id`, `username`, `password`, `role`, `permission`) VALUES (1, 'admin', 'e10adc3949ba59abbe56e057f20f883e', 1, NULL);
INSERT INTO `xxl_job_lock` ( `lock_name`) VALUES ( 'schedule_lock');

commit;
</code></pre>
<p>我们先通过此 SQL 把库、表创建好</p>
 <div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950195-984259667.png" alt="admin库表"></div>
<p>官方提供了 Docker 镜像，我们直接用 Docker 来部署</p>
<blockquote>
<p>docker run -d -e PARAMS="--spring.datasource.url=jdbc:mysql://192.168.2.118:3312/xxl_job?Unicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai <br>
--spring.datasource.username=root <br>
--spring.datasource.password=123456 <br>
--xxl.job.accessToken=qsl.token" <br>
-p 8080:8080 <br>
--name xxl-job-admin --restart=always xuxueli/xxl-job-admin:2.1.0</p>
</blockquote>
<p>不出意外的话，xxl-job-admin 就部署成功了</p>
 <div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950499-1732677399.png" alt="admin部署成功"></div>
</li>
<li>
<p>执行器</p>
<p>为了方便演示，直接在本地 IDEA 中启动；我们基于 <code>Spring Boot</code> 搭建，pom.xml 很简单</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.qsl&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-xxl-job-executor&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.7.18&lt;/version&gt;
    &lt;/parent&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;
            &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;
            &lt;version&gt;2.1.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<p>配置文件：application.yml</p>
<pre><code class="language-yaml">xxl:
  job:
    executor:
      appName: qsl-job-executor
      admin-addresses: http://192.168.2.118:8080/xxl-job-admin
      access-token: qsl.token
</code></pre>
<p>xxl-job spring executor：XxlJobSpringExecutor</p>
<pre><code class="language-java">/**
 * @author 青石路
 */
@Configuration
public class XxlJobConfig {
	private final Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);

	@Bean(initMethod = "start",destroyMethod = "destroy")
	public XxlJobSpringExecutor xxlJobExecutor(XxlJobProperties xxlJob) {
		logger.info("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.");
		XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();
		xxlJobSpringExecutor.setAdminAddresses(xxlJob.getAdminAddresses());
		xxlJobSpringExecutor.setAppName(xxlJob.getAppName());
		xxlJobSpringExecutor.setIp(xxlJob.getIp());
		xxlJobSpringExecutor.setPort(xxlJob.getPort());
		xxlJobSpringExecutor.setAccessToken(xxlJob.getAccessToken());
		xxlJobSpringExecutor.setLogPath(xxlJob.getLogPath());
		xxlJobSpringExecutor.setLogRetentionDays(xxlJob.getLogRetentionDays());
		return xxlJobSpringExecutor;
	}
}
</code></pre>
<p>最后剩一个 JobHandler：QslJobHandler</p>
<pre><code class="language-java">/**
 * @author 青石路
 */
@Component
@JobHandler("qslJobHandler")
public class QslJobHandler extends IJobHandler {

    private static final Logger LOG = LoggerFactory.getLogger(QslJobHandler.class);

    @Override
    public ReturnT&lt;String&gt; execute(String param) throws Exception {
        LOG.info("param = {}", param);
        // TODO 业务处理
        return ReturnT.SUCCESS;
    }
}
</code></pre>
<p>代码完整地址：<a href="https://gitee.com/youzhibing/qsl-project/tree/065fc079c72eaef645390fdd0364f50975ee224c/spring-boot-xxl-job-executor" target="_blank" rel="noopener nofollow">spring-boot-xxl-job-executor</a></p>
<p>我们启动执行器，不出意外的话，执行器会启动成功</p>
 <div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950280-461978847.png" alt="executor启动成功"></div>
</li>
</ol>
<p><code>调度中心</code> 和 <code>执行器</code> 都启动成功后，还需要在调度中心注册执行器和添加任务，页面操作即可</p>
<ol>
<li>
<p>注册执行器</p>
 <div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950260-842240432.png" alt="新增执行器"></div>
<p>这里的 <code>AppName</code> 不能随意填写，需要与 application.yml 中</p>
<pre><code class="language-yaml">xxl:
  job:
    executor:
      appName: qsl-job-executor
</code></pre>
<p>配置的值保持一致，即填写：<code>qsl-job-executor</code></p>
<p><code>名称</code> 和 <code>排序</code> 可以随意填，推荐填的有业务含义，特别是名称，最好见名知意</p>
<p><code>注册方式</code> 采用 <code>手动录入</code> 的方式，因为调度中心是采用 Docker 部署的，而执行器是通过本地 IDEA 启动的，自动注册会导致调度中心与执行器之间网络不通</p>
<p><code>机器地址</code> 填本地 IDEA 所在机器的 IP，端口是 <code>9999</code>，而非 <code>8080</code>，所以完整地址是：<code>192.168.2.13:9999</code>；多个地址间用英文逗号隔开即可</p>
<p>最后点击 <code>保存</code> 即可</p>
 <div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950757-645483062.png" alt="执行器列表"></div>
</li>
<li>
<p>添加任务</p>
 <div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950621-85850281.png" alt="新增任务"></div>
<p>如上的任务参数，我都是按我们项目的生产参数来配置的，每个参数的详细说明，大家可以去看 XXL-JOB 官方的 <a href="https://www.xuxueli.com/xxl-job/#%E4%B8%89%E3%80%81%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3" target="_blank" rel="noopener nofollow">任务详解</a></p>
</li>
</ol>
<p>至此就算全部配置完成，我们执行下任务试试</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950811-2005478272.png" alt="执行任务测试" width="900px"></div>
<p>执行结果如下</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950654-1349396407.png" alt="执行任务测试成功" width="900px"></div>
<p>IDEA 控制台输出如下</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950714-157926940.png" alt="执行任务测试成功_控制台输出" width="900px"></div>
<p>一切似乎都是那么正常</p>
<h2 id="线上问题">线上问题</h2>
<p>我们的生产环境是基于 <code>k8s</code> 部署的，当执行器的内存使用率占用分配内存的 90% 时，会触发 k8s 的重启机制；因为不好模拟生产环境，所以我们需要调整下 <code>QslJobHandler</code> 来模拟线上问题</p>
<pre><code class="language-java">/**
 * @author 青石路
 */
@Component
@JobHandler("qslJobHandler")
public class QslJobHandler extends IJobHandler {

    private static final Logger LOG = LoggerFactory.getLogger(QslJobHandler.class);

    @Override
    public ReturnT&lt;String&gt; execute(String param) throws Exception {
        LOG.info("param = {}", param);

        LOG.info("QslJobHandler 业务处理开始");
        // TODO 业务处理
        TimeUnit.SECONDS.sleep(30);
        LOG.info("QslJobHandler 业务处理完成");
        return ReturnT.SUCCESS;
    }
}
</code></pre>
<p>任务执行的过程中（即业务处理中，还未处理完成），我们重启下执行器</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225951308-662415700.png" alt="job还未执行完重启执行器" width="900px"></div>
<p>模拟的是任务执行的时候，执行器 <code>OOM</code> 导致内存使用率超过 90%，触发 k8s 的重启机制，导致执行器重启；那么有什么问题呢，我们来看下调度日志</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950626-842309620.png" alt="重启_调度日志" width="900px"></div>
<p>这个数据，你们都能看懂吧，因为任务在执行过程中，执行器重启导致没有给调度中心进行响应，所以调度中心一直在苦苦等待执行器的回信，殊不知执行器已喝孟婆汤完成了转生</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950708-1903511049.jpg" alt="我都到花儿都谢了"></div>
<p>那这对我们的业务有什么影响吗，肯定有影响，因为我们配置的 cron（<code>0 50 5 * * ?</code>）是每天只执行一次，这次没执行成功，今天就不会被调度执行了，然后我们就喜提一个 <code>生产事故</code></p>
<p>从根因上来讲，罪魁祸首是 OOM，但一轮排查下来，发现这个吊毛隐藏的挺深，加上又是偶发一次，一时半会还真查不出来 OOM 的原因；所以我们得想办法对这种偶发问题进行弥补，如果是上班时间，我们可以根据重启告警进行人工弥补调度，但如果不是上班时间呢，甚至是半夜呢，所以我们应该通过程序去自动弥补调度，人工弥补调度只是最后的兜底；这个时候如果调度中心能够监测出哪些任务需要弥补调度并自动进行弥补，那就美滋滋了！</p>
<h2 id="期望自动弥补">期望自动弥补</h2>
<p>调度中心如何监测呢，是不是可以通过 <code>任务超时时间</code> 来实现？如果指定时间内，执行器没有返回任务执行结果，调度中心就认为任务执行失败了，重新发送一次调度请求，然后结合 <code>失败重试次数</code> 来避免无限重试；而 XXL-JOB 正好提供了这两个配置，其说明如下</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225951713-406293962.png" alt="任务超时时间与失败重试次数说明" width="900px"></div>
<p>针对 <code>失败重试</code>，官方还有这样一段说明</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950876-435620831.png" alt="失败重试生效阶段" width="900px"></div>
<p>这两段说明结合起来看，不知道你们有没有什么想法，我心中倒是涌起了一股不祥的预感</p>
<blockquote>
<p>我前面说的美好预想都是基于 <code>任务超时时间</code> 是在 <code>调度中心</code> 实现的，或者说 <code>调度中心</code> 和 <code>执行器</code> 都有实现，只有这样，调度中心才能实现监测；但 <code>主动中断任务</code>、<code>调度 + 执行</code> 这些字眼，让我觉得 <code>调度中心</code> 不会实现 <code>任务超时时间</code>，<code>执行器</code> 才会实现它</p>
</blockquote>
<p>至于 XXL-JOB 具体是如何实现的，我们一测便知</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225951522-315282770.png" alt="任务超时时间与失败重试次数配置"></div>
<p>然后重复之前执行器的重启过程（调度请求到了执行器后，立马重启执行器），我们再来看看执行结果</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950823-2092055121.png" alt="重启不算超时" width="900px"></div>
<p>结果显示任务并未终止，调度中心也没有按我们预期的那样就行重试，我的不祥预感成真了！</p>
<blockquote>
<p><code>任务超时时间</code> 只在 <code>执行器</code> 端做了实现，精确的控制任务执行时长，并及时的进行超时中断<br><code>调度重试次数</code> 在 调度 与 执行 阶段都可以生效，前提是触发了重试机制，重试的方式是再次触发调度</p>
</blockquote>
<p>当我们去手动 <code>终止任务</code>，调度中心过几秒后会进行重试</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950909-256074631.png" alt="失败重试记录" width="900px"></div>
<p>点击调度备注的查看，可以看到任务触发类型是：失败重试触发</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225951131-1409698857.png" alt="任务触发类型"></div>
<p>所以结论是</p>
<blockquote>
<p>XXL-JOB 有任务执行超时后的重试功能，但前提是执行器不能重启<br>这也得出了标题的答案：<strong>执行中的任务在执行器重启后不会自动弥补调度</strong></p>
</blockquote>
<h2 id="总结">总结</h2>
<ol>
<li>
<p>上述的结论都是基于 XXL-JOB 2.1.0，不一定适配其他版本</p>
<blockquote>
<p>XXL-JOB 有任务执行超时后的重试功能，但前提是执行器不能重启；执行中的任务在执行器重启后不会自动弥补调度</p>
</blockquote>
<p>也许 XXL-JOB 在 2.1.0 之后的某个版本已经满足标题的需求，或者在未来的版本中会支持，但不会是 2.1.0</p>
</li>
<li>
<p>针对标题中的问题，只能先加重启监控进行人工弥补，同时去找 OOM 的原因并进行修复</p>
</li>
<li>
<p>关于 <code>任务超时控制</code>，官方特意强调了一些注意点</p>
 <div align="center"><img src="https://img2024.cnblogs.com/blog/747662/202412/747662-20241222225950925-653242698.png" alt="任务超时控制"></div>
<p>另外，也推荐大家去查看下 <a href="https://www.xuxueli.com/xxl-job/#4.9%20%E7%BB%88%E6%AD%A2%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1" target="_blank" rel="noopener nofollow">4.9 终止运行中的任务</a></p>
</li>
<li>
<p>示例代码：<a href="https://gitee.com/youzhibing/qsl-project/tree/065fc079c72eaef645390fdd0364f50975ee224c/spring-boot-xxl-job-executor" target="_blank" rel="noopener nofollow">spring-boot-xxl-job-executor</a></p>
</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.23636242997337964" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-23 09:18">2024-12-23 09:08</span>&nbsp;
<a href="https://www.cnblogs.com/youzhibing">青石路</a>&nbsp;
阅读(<span id="post_view_count">14</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18622761" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18622761);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18622761', targetLink: 'https://www.cnblogs.com/youzhibing/p/18622761', title: '如果XXL-JOB执行器在执行某任务中被重启了，重启后该任务能够被自动弥补调度吗' })">举报</a>
</div>
        