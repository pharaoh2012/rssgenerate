
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18976429" title="发布于 2025-07-10 10:48">
    <span role="heading" aria-level="2">订单初版—4.取消订单链路中的技术问题说明文档</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="4" data-pm-slice="1 1 []"><strong>大纲</strong></p>
<p data-track="5"><strong>1.超时自动取消订单功能的业务背景</strong></p>
<p data-track="6"><strong>2.超时自动取消订单和支付的并发问题</strong></p>
<p data-track="7"><strong>3.分布式锁解决超时订单取消和支付的并发</strong></p>
<p data-track="8"><strong>4.定时任务解决延时消费的消息的丢失问题</strong></p>
<p data-track="9"><strong>5.超时自动取消订单代码流程</strong></p>
<p data-track="10"><strong>6.RocketMQ延迟消息实现原理</strong></p>
<p data-track="11"><strong>7.取消订单务场景和接口被调用的情况</strong></p>
<p data-track="12"><strong>8.取消订单的业务链路</strong></p>
<p data-track="13"><strong>9.为什么拦截履约要同步而释放资产是异步</strong></p>
<p data-track="14"><strong>10.支付回调分别互斥预支付和取消订单</strong></p>
<p data-track="15"><strong>11.支付回调和取消订单互斥下的两种场景分析</strong></p>
<p data-track="16"><strong>12.拦截履约的具体业务流程</strong></p>
<p data-track="17"><strong>13.拦截履约和取消订单的Seata事务原理分析</strong></p>
<p data-track="18"><strong>14.取消订单全链路Seata回滚原理与并发分析</strong></p>
<p data-track="19"><strong>15.支付退款时的双异步设计原因(提升性能 + 解耦)</strong></p>
<p data-track="20"><strong>16.释放资产消息的高扩展性设计(多路发送消息)</strong></p>
<p data-track="21"><strong>17.取消订单链路中数据库事务与MQ消息不一致问题</strong></p>
<p data-track="22"><strong>18.释放资产多路MQ故障重试与幂等方案</strong></p>
<p data-track="23"><strong>19.双异步支付退款不一致问题分析</strong></p>
<p data-track="24">&nbsp;</p>
<p data-track="25"><strong>1.超时自动取消订单功能的业务背景</strong></p>
<p data-track="26">用户提交订单，订单系统生成订单后，由于种种原因，用户并没有立即点击去支付或者完成支付。此时默认该订单会在生成30分钟后，自动进行支付检查。也就是如果生成订单超过30分钟还没进行支付，那么就会自动取消订单。</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="572" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/266f7c4fa55d423c9ae907c85df439e8~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250710104308C49EC69ACF591C43F65E&amp;x-expires=2147483647&amp;x-signature=%2BGVgtBjzWn41SO6O09OksLEizSQ%3D" class="lazyload"></div>
<p data-track="27">超时自动取消订单的技术方案：RocketMQ延迟消息 + Redisson分布式锁 + XXL-JOB分布式任务调度。</p>
<p data-track="28">&nbsp;</p>
<p data-track="29"><strong>2.超时自动取消订单和支付的并发问题</strong></p>
<p data-track="30">当用户提交的订单在30分钟后才发起支付时，此时就有可能出现取消订单和支付出现并发的问题。</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="705" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/2cc47522e38949029510d47e0e8b4875~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250710104308C49EC69ACF591C43F65E&amp;x-expires=2147483647&amp;x-signature=gvnFHKo6MZGq0PgFdQC7DVzIN9U%3D" class="lazyload"></div>
<p data-track="31">&nbsp;</p>
<p data-track="32"><strong>3.分布式锁解决超时订单取消和支付的并发</strong></p>
<p data-track="33">在如下位置加同一把分布式锁即可解决超时订单取消和支付的并发问题：</p>
<p data-track="34">一.订单系统处理预支付请求时添加分布式锁</p>
<p data-track="35">二.订单系统处理支付回调请求时添加分布式锁</p>
<p data-track="36">三.订单系统消费延时30m的订单消息进行超时检查时添加分布式锁</p>
<p data-track="37">&nbsp;</p>
<p data-track="38">当处理预支付和消费延时订单消息进行超时检查时产生并发：如果处理预支付先获取锁，则超时检查会被阻塞，之后发现已支付不取消。如果超时检查先获取锁，则预支付被阻塞，之后预支付失败。</p>
<p data-track="39">&nbsp;</p>
<p data-track="40">当处理支付回调和消费延时订单消息进行超时检查时产生并发：如果支付回调先获取锁，则超时检查会被阻塞，之后发现已支付不取消。如果超时检查先获取锁，则支付回调被阻塞，之后支付回调获取锁，发现订单已被超时检查取消，于是需要进行退款处理通知用户。</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="707" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/ec550193961d496a9afd60c16fc2c5a8~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250710104308C49EC69ACF591C43F65E&amp;x-expires=2147483647&amp;x-signature=WkjxEkuv3PGF7965NsvBIKq9MnM%3D" class="lazyload"></div>
<p data-track="41">&nbsp;</p>
<p data-track="42"><strong>4.定时任务解决延时消费的消息的丢失问题</strong></p>
<p data-track="43">如果发送到MQ的延时30m消费的消息丢失，此时会通过定时任务来处理。该定时任务会对MySQL进行扫描，把创建时间超30m + 没支付的订单找出，然后再对这些超时订单进行取消。定时任务一般使用分布式调度框架XXL-JOB来实现。</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="773" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/4e7845bcb626465fae304e0da8c8fbbe~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250710104308C49EC69ACF591C43F65E&amp;x-expires=2147483647&amp;x-signature=7WE60NJKfDtkeBlN7W%2B6fBFQpDU%3D" class="lazyload"></div>
<p data-track="44">以上便是超时自动取消订单的技术方案：RocketMQ延迟消息 + Redisson分布式锁 + XXL-JOB分布式任务调度。</p>
<p data-track="45">&nbsp;</p>
<p data-track="46"><strong>5.超时自动取消订单代码流程</strong></p>
<p data-track="47"><strong>(1)生成订单时发送延时30m才能被消费的消息</strong></p>
<p data-track="48"><strong>(2)订单超时检查监听器</strong></p>
<p data-track="49"><strong>(3)对订单进行正式取消的业务逻辑</strong></p>
<p data-track="50"><strong>(4)定时任务检查创建时间超30m但没取消的订单</strong></p>
<p data-track="51">&nbsp;</p>
<p data-track="52"><strong>(1)生成订单时发送延时30m才能被消费的消息</strong></p>
<pre class="highlighter-hljs"><code>@Service
public class OrderServiceImpl implements OrderService {
    ...
    //提交订单/生成订单接口
    //@param createOrderRequest 提交订单请求入参
    @GlobalTransactional(rollbackFor = Exception.class)
    @Override
    public CreateOrderDTO createOrder(CreateOrderRequest createOrderRequest) {
        //1.入参检查
        checkCreateOrderRequestParam(createOrderRequest);
        //2.风控检查
        checkRisk(createOrderRequest);
        //3.获取商品信息
        List&lt;ProductSkuDTO&gt; productSkuList = listProductSkus(createOrderRequest);
        //4.计算订单价格
        CalculateOrderAmountDTO calculateOrderAmountDTO = calculateOrderAmount(createOrderRequest, productSkuList);
        //5.验证订单实付金额
        checkRealPayAmount(createOrderRequest, calculateOrderAmountDTO);
        //6.锁定优惠券
        lockUserCoupon(createOrderRequest);
        //7.锁定商品库存
        lockProductStock(createOrderRequest);
        //8.生成订单到数据库
        addNewOrder(createOrderRequest, productSkuList, calculateOrderAmountDTO);
        //9.发送订单延迟消息用于支付超时自动关单
        sendPayOrderTimeoutDelayMessage(createOrderRequest);
        //返回订单信息
        CreateOrderDTO createOrderDTO = new CreateOrderDTO();
        createOrderDTO.setOrderId(createOrderRequest.getOrderId());
        return createOrderDTO;
    }

    //发送支付订单超时延迟消息，用于支付超时自动关单
    private void sendPayOrderTimeoutDelayMessage(CreateOrderRequest createOrderRequest) {
        PayOrderTimeoutDelayMessage message = new PayOrderTimeoutDelayMessage();
        message.setOrderId(createOrderRequest.getOrderId());
        message.setBusinessIdentifier(createOrderRequest.getBusinessIdentifier());
        message.setCancelType(OrderCancelTypeEnum.TIMEOUT_CANCELED.getCode());
        message.setUserId(createOrderRequest.getUserId());
        message.setOrderType(createOrderRequest.getOrderType());
        message.setOrderStatus(OrderStatusEnum.CREATED.getCode());
        String msgJson = JsonUtil.object2Json(message);
        defaultProducer.sendMessage(
            RocketMqConstant.PAY_ORDER_TIMEOUT_DELAY_TOPIC,
            msgJson,
            RocketDelayedLevel.DELAYED_30m, 
            "支付订单超时延迟消息"
        );
    }
    ...
}

@Component
public class DefaultProducer {
    private final DefaultMQProducer producer;

    @Autowired
    public DefaultProducer(RocketMQProperties rocketMQProperties) {
        producer = new DefaultMQProducer(RocketMqConstant.ORDER_DEFAULT_PRODUCER_GROUP);
        producer.setNamesrvAddr(rocketMQProperties.getNameServer());
        start();
    }

    //对象在使用之前必须要调用一次，只能初始化一次
    public void start() {
        try {
            this.producer.start();
        } catch (MQClientException e) {
            log.error("producer start error", e);
        }
    }
    ...

    //发送消息
    public void sendMessage(String topic, String message, Integer delayTimeLevel, String type) {
        Message msg = new Message(topic, message.getBytes(StandardCharsets.UTF_8));
        try {
            if (delayTimeLevel &gt; 0) {
                msg.setDelayTimeLevel(delayTimeLevel);
            }
            SendResult send = producer.send(msg);
            if (SendStatus.SEND_OK == send.getSendStatus()) {
                log.info("发送MQ消息成功, type:{}, message:{}", type, message);
            } else {
                throw new OrderBizException(send.getSendStatus().toString());
            }
        } catch (Exception e) {
            log.error("发送MQ消息失败：", e);
            throw new OrderBizException(OrderErrorCodeEnum.SEND_MQ_FAILED);
        }
    }
    ...
}</code></pre>
<p data-track="54"><strong>(2)订单超时检查监听器</strong></p>
<pre class="highlighter-hljs"><code>@Configuration
public class ConsumerConfig {
    @Autowired
    private RocketMQProperties rocketMQProperties;
    ...

    //支付订单超时延迟消息消费者
    @Bean("payOrderTimeoutConsumer")
    public DefaultMQPushConsumer payOrderTimeoutConsumer(PayOrderTimeoutListener payOrderTimeoutListener) throws MQClientException {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(PAY_ORDER_TIMEOUT_DELAY_CONSUMER_GROUP);
        consumer.setNamesrvAddr(rocketMQProperties.getNameServer());
        consumer.subscribe(PAY_ORDER_TIMEOUT_DELAY_TOPIC, "*");
        consumer.registerMessageListener(payOrderTimeoutListener);
        consumer.start();
        return consumer;
    }
    ...
}

//监听支付订单超时延迟消息
@Component
public class PayOrderTimeoutListener implements MessageListenerConcurrently {
    @Autowired
    private OrderAfterSaleService orderAfterSaleService;

    @Autowired
    private OrderInfoDAO orderInfoDAO;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt messageExt : list) {
                String message = new String(messageExt.getBody());
                PayOrderTimeoutDelayMessage payOrderTimeoutDelayMessage = JSON.parseObject(message, PayOrderTimeoutDelayMessage.class);
                //消费延迟消息，执行关单逻辑
                CancelOrderRequest cancelOrderRequest = new CancelOrderRequest();
                cancelOrderRequest.setOrderId(payOrderTimeoutDelayMessage.getOrderId());
                cancelOrderRequest.setBusinessIdentifier(payOrderTimeoutDelayMessage.getBusinessIdentifier());
                cancelOrderRequest.setCancelType(payOrderTimeoutDelayMessage.getOrderType());
                cancelOrderRequest.setUserId(payOrderTimeoutDelayMessage.getUserId());
                cancelOrderRequest.setOrderType(payOrderTimeoutDelayMessage.getOrderType());
                cancelOrderRequest.setOrderStatus(payOrderTimeoutDelayMessage.getOrderStatus());
                //查询当前数据库的订单实时状态
                OrderInfoDO orderInfoDO = orderInfoDAO.getByOrderId(payOrderTimeoutDelayMessage.getOrderId());
                Integer orderStatusDatabase = orderInfoDO.getOrderStatus();
                if (!OrderStatusEnum.CREATED.getCode().equals(orderStatusDatabase)) {
                    //订单实时状态不等于已创建
                    return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
                }
                //当前时间 小于 订单实际支付截止时间
                if (new Date().before(orderInfoDO.getExpireTime())) {
                    return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
                }
                orderAfterSaleService.cancelOrder(cancelOrderRequest);
                log.info("关闭订单，orderId:{}", cancelOrderRequest.getOrderId());
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
}</code></pre>
<p data-track="56"><strong>(3)对订单进行正式取消的业务逻辑</strong></p>
<pre class="highlighter-hljs"><code>@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //取消订单/超时未支付取消
    @Override
    public JsonResult&lt;Boolean&gt; cancelOrder(CancelOrderRequest cancelOrderRequest) {
        //入参检查
        checkCancelOrderRequestParam(cancelOrderRequest);
        //分布式锁，这里的锁和预支付及支付回调使用的分布式锁一样
        String orderId = cancelOrderRequest.getOrderId();
        String key = RedisLockKeyConstants.ORDER_PAY_KEY + orderId;
        try {
            boolean lock = redisLock.lock(key);
            if (!lock) {
                throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_REPEAT);
            }
            //执行取消订单
            executeCancelOrder(cancelOrderRequest, orderId);
            return JsonResult.buildSuccess(true);
        } catch (Exception e) {
            throw new OrderBizException(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
    }

    @Override
    @GlobalTransactional(rollbackFor = Exception.class)
    public void executeCancelOrder(CancelOrderRequest cancelOrderRequest, String orderId) {
        //1.组装数据
        CancelOrderAssembleRequest cancelOrderAssembleRequest = buildAssembleRequest(orderId, cancelOrderRequest);
        //幂等校验：防止多个线程同时操作取消同一笔订单
        if (OrderStatusEnum.CANCELED.getCode().equals(cancelOrderAssembleRequest.getOrderInfoDTO().getOrderStatus())) {
            return;
        }

        //2.检验订单支付状态
        checkOrderPayStatus(cancelOrderAssembleRequest);

        //3.更新订单状态和记录订单操作日志
        updateOrderStatusAndSaveOperationLog(cancelOrderAssembleRequest);
        //超时未支付的订单不用继续再往下执行取消履约和释放资产
        if (OrderStatusEnum.PAID.getCode() &gt; cancelOrderAssembleRequest.getOrderInfoDTO().getOrderStatus()) {
            return;
        }

        //4.履约取消
        cancelFulfill(cancelOrderAssembleRequest);

        //5.发送释放资产消息到MQ
        defaultProducer.sendMessage(RocketMqConstant.RELEASE_ASSETS_TOPIC, JSONObject.toJSONString(cancelOrderAssembleRequest), "释放资产");
    }

    //更新订单状态和记录订单操作日志
    private void updateOrderStatusAndSaveOperationLog(CancelOrderAssembleRequest cancelOrderAssembleRequest) {
        //更新订单表
        OrderInfoDO orderInfoDO = cancelOrderAssembleRequest.getOrderInfoDTO().clone(OrderInfoDO.class);
        orderInfoDO.setCancelType(cancelOrderAssembleRequest.getCancelType().toString());
        orderInfoDO.setOrderStatus(OrderStatusEnum.CANCELED.getCode());
        orderInfoDO.setCancelTime(new Date());
        orderInfoDAO.updateOrderInfo(orderInfoDO);
        log.info("更新订单信息OrderInfo状态: orderId:{},status:{}", orderInfoDO.getOrderId(), orderInfoDO.getOrderStatus());

        //新增订单操作操作日志表
        Integer cancelType = Integer.valueOf(orderInfoDO.getCancelType());
        String orderId = orderInfoDO.getOrderId();
        OrderOperateLogDO orderOperateLogDO = new OrderOperateLogDO();
        orderOperateLogDO.setOrderId(orderId);
        orderOperateLogDO.setPreStatus(cancelOrderAssembleRequest.getOrderInfoDTO().getOrderStatus());
        orderOperateLogDO.setCurrentStatus(OrderStatusEnum.CANCELED.getCode());
        orderOperateLogDO.setOperateType(OrderOperateTypeEnum.AUTO_CANCEL_ORDER.getCode());
        if (OrderCancelTypeEnum.USER_CANCELED.getCode().equals(cancelType)) {
            orderOperateLogDO.setOperateType(OrderOperateTypeEnum.MANUAL_CANCEL_ORDER.getCode());
            orderOperateLogDO.setRemark(OrderOperateTypeEnum.MANUAL_CANCEL_ORDER.getMsg()
                + orderOperateLogDO.getPreStatus() + "-" + orderOperateLogDO.getCurrentStatus());
        }
        if (OrderCancelTypeEnum.TIMEOUT_CANCELED.getCode().equals(cancelType)) {
            orderOperateLogDO.setOperateType(OrderOperateTypeEnum.AUTO_CANCEL_ORDER.getCode());
            orderOperateLogDO.setRemark(OrderOperateTypeEnum.AUTO_CANCEL_ORDER.getMsg()
                + orderOperateLogDO.getPreStatus() + "-" + orderOperateLogDO.getCurrentStatus());
        }
        orderOperateLogDAO.save(orderOperateLogDO);
        log.info("新增订单操作日志OrderOperateLog状态,orderId:{}, PreStatus:{},CurrentStatus:{}", orderInfoDO.getOrderId(),
            orderOperateLogDO.getPreStatus(), orderOperateLogDO.getCurrentStatus());
    }
    ...
}</code></pre>
<p data-track="58"><strong>(4)定时任务检查创建时间超30m但没取消的订单</strong></p>
<pre class="highlighter-hljs"><code>//自动取消超时订单任务
@Component
public class AutoCancelExpiredOrderTask {
    @Autowired
    private OrderInfoDAO orderInfoDAO;
    @Autowired
    private OrderAfterSaleService orderAfterSaleService;
    @Autowired
    private OrderProperties orderProperties;
    @Autowired
    private RedisLock redisLock;

    //执行任务逻辑
    @Scheduled(fixedRate = 30 * 60 * 1000)
    public void execute() {
        //扫描当前时间 - 订单超时时间 -&gt; 前的一小段时间范围(时间范围用配置中心配置)
        //比如当前时间11:40，订单超时时间是30分钟，扫描11:09:00 -&gt; 11:10:00这一分钟的未支付订单，
        //缺点：有一个订单超过了30 + 1 = 31分钟，都没有被处理(取消)，这笔订单就永久待支付
        for (OrderInfoDO order : orderInfoDAO.listAllUnPaid()) {
            if (new Date().getTime() - order.getExpireTime().getTime() &gt;= orderProperties.getExpireTime()) {
                //分布式锁
                String orderId = order.getOrderId();
                String key = RedisLockKeyConstants.ORDER_PAY_KEY + orderId;
                try {
                    boolean lock = redisLock.lock(key);
                    if (!lock) {
                        throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_REPEAT);
                    }
                    //超过30min未支付
                    CancelOrderRequest request = new CancelOrderRequest();
                    request.setOrderId(order.getOrderId());
                    request.setUserId(order.getUserId());
                    request.setBusinessIdentifier(order.getBusinessIdentifier());
                    request.setOrderType(order.getOrderType());
                    request.setCancelType(OrderCancelTypeEnum.TIMEOUT_CANCELED.getCode());
                    request.setOrderStatus(order.getOrderStatus());
                    try {
                        orderAfterSaleService.cancelOrder(request);
                    } catch (Exception e) {
                        log.error("AutoCancelExpiredOrderTask execute error:", e);
                    }
                } catch (Exception e) {
                    throw new OrderBizException(e.getMessage());
                } finally {
                    redisLock.unlock(key);
                }
            }
        }
    }
}</code></pre>
<p data-track="60">&nbsp;</p>
<p data-track="61"><strong>6.RocketMQ延迟消息实现原理</strong></p>
<p data-track="62">发送需要延迟消费的消息到RocketMQ的某Topic时，RocketMQ会将该消息进行改写，投递到重试Topic，而非指定的某Topic。RocketMQ将该消息转发到重试Topic对应的ConsumerQueue后，RocketMQ内部会有一个内部的延迟调度组件ScheduleService，该组件便会消费重试Topic对应的ConsumerQueue里的消息，并判断里面的消息是否到达延迟时间。如果到达延迟时间，则会重新改写消息Topic，投递到开始指定的某Topic。</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="490" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/14be8d9942e447ceabd3cd1d1a4b73b9~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250710104308C49EC69ACF591C43F65E&amp;x-expires=2147483647&amp;x-signature=26GFZmcp01zbvgQrAxwRPG9PtLY%3D" class="lazyload"></div>
<p data-track="63">&nbsp;</p>
<p data-track="64"><strong>7.取消订单的业务场景和接口被调用的情况</strong></p>
<p data-track="65"><strong>(1)发生取消订单的三种场景</strong></p>
<p data-track="66"><strong>(2)调用取消订单接口的三种情况</strong></p>
<p data-track="67">&nbsp;</p>
<p data-track="68"><strong>(1)发生取消订单的三种场景</strong></p>
<p data-track="69"><strong>场景一：</strong>用户生成订单后还没支付，就取消订单。取消订单可能是用户手动取消，也可能是超时检查自动取消，此时只需要释放锁定的优惠券和库存即可。</p>
<p data-track="70">&nbsp;</p>
<p data-track="71"><strong>场景二：</strong>用户生成订单后完成支付，还没拣货出库，用户就取消订单。此时不仅需要释放锁定的优惠券和库存，还需取消履约以及退款。</p>
<p data-track="72">&nbsp;</p>
<p data-track="73"><strong>场景三：</strong>用户生成订单后完成支付，已拣货出库，开始物流配送。此时用户想要取消订单，只能等收到货以后，发起售后退货申请。</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="453" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/0cdb3158b58347f19bb6f8580bb43c66~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250710104308C49EC69ACF591C43F65E&amp;x-expires=2147483647&amp;x-signature=vU8EA6ApOUsxSsY8A5qC9WE4xmI%3D" class="lazyload"></div>
<p data-track="74"><strong>(2)调用取消订单接口的三种情况</strong></p>
<p data-track="75">情况一：⼿动取消，订单出库状态前都可取消</p>
<p data-track="76">情况二：正向⽣成订单后，会发送延迟30分钟消费的订单消息到MQ。订单系统在30分钟后消费到该MQ消息时，若发现仍未⽀付则取消该订单</p>
<p data-track="77">情况三：定时扫描，超过30分钟未⽀付才取消</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="1162" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/0aa821cc3bfc4f228067ad96c78b7567~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250710104308C49EC69ACF591C43F65E&amp;x-expires=2147483647&amp;x-signature=mE0M5CqU2yV0%2Fdjb3ipIewwK6Ic%3D" class="lazyload"></div>
<p data-track="78">&nbsp;</p>
<p data-track="79"><strong>8.取消订单的业务链路和代码流程</strong></p>
<p data-track="80"><strong>(1)实现概述</strong></p>
<p data-track="81"><strong>(2)对取消订单的处理</strong></p>
<p data-track="82"><strong>(3)对取消履约+更新订单状态+新增订单日志的处理</strong></p>
<p data-track="83"><strong>(4)对释放资产的处理</strong></p>
<p data-track="84"><strong>(5)对退款的退款前处理</strong></p>
<p data-track="85"><strong>(6)对退款的实际退款处理</strong></p>
<p data-track="86">&nbsp;</p>
<p data-track="87"><strong>(1)实现概述</strong></p>
<p data-track="88"><strong>一.实现流程图</strong></p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="862" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/94125b751d7f40499f373466b3126686~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250710104308C49EC69ACF591C43F65E&amp;x-expires=2147483647&amp;x-signature=rFQMkAvbRxX7BDn%2BF%2B%2B3045f0XI%3D" class="lazyload"></div>
<p data-track="89"><strong>二.技术要点</strong></p>
<p data-track="90">要点一：更新订单状态、取消履约、发送释放资产是⼀个分布式事务，需要将Seata的AT模式替换成RocketMQ的事务消息。</p>
<p data-track="91">&nbsp;</p>
<p data-track="92">要点二：超时订单的处理⽅案是⽣成订单后发送⼀个延迟30分钟后才被消费的消息到MQ。订单系统消费该延迟消息时，会验证订单是否已支付，否就调⽤取消订单的接⼝。</p>
<p data-track="93">&nbsp;</p>
<p data-track="94"><strong>(2)对取消订单的处理</strong></p>
<pre class="highlighter-hljs"><code>//订单中心-逆向售后业务接口
@DubboService(version = "1.0.0", interfaceClass = AfterSaleApi.class, retries = 0)
public class AfterSaleApiImpl implements AfterSaleApi {
    @Autowired
    private OrderLackService orderLackItemService;

    @Autowired
    private OrderAfterSaleService orderAfterSaleService;

    //取消订单/超时未支付取消
    @Override
    public JsonResult&lt;Boolean&gt; cancelOrder(CancelOrderRequest cancelOrderRequest) {
        try {
            return orderAfterSaleService.cancelOrder(cancelOrderRequest);
        } catch (OrderBizException e) {
            log.error("biz error", e);
            return JsonResult.buildError(e.getErrorCode(), e.getErrorMsg());
        } catch (Exception e) {
            log.error("system error", e);
            return JsonResult.buildError(e.getMessage());
        }
    }
    ...
}

//取消订单入参
@Data
public class CancelOrderRequest extends AbstractObject implements Serializable {
    private static final long serialVersionUID = -4035579903997700971L;
    private String orderId;//订单号
    private Integer businessIdentifier;//订单渠道来源
    private Integer cancelType;//订单取消类型 0-手动取消 1-超时未支付
    private String userId;//用户id
    private Integer orderType;//订单类型
    private Integer orderStatus;//订单状态
    private Integer oldOrderStatus;//原订单状态
}

@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //取消订单/超时未支付取消
    @Override
    public JsonResult&lt;Boolean&gt; cancelOrder(CancelOrderRequest cancelOrderRequest) {
        //入参检查
        checkCancelOrderRequestParam(cancelOrderRequest);

        //分布式锁
        String orderId = cancelOrderRequest.getOrderId();
        String key = RedisLockKeyConstants.CANCEL_KEY + orderId;
        try {
            boolean lock = redisLock.lock(key);
            if (!lock) {
                throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_REPEAT);
            }
            //执行取消订单
            return executeCancelOrder(cancelOrderRequest, orderId);
        } catch (Exception e) {
            throw new OrderBizException(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
    }

    @Override
    public JsonResult&lt;Boolean&gt; executeCancelOrder(CancelOrderRequest cancelOrderRequest, String orderId) {
        //1.组装数据
        OrderInfoDO orderInfoDO = findOrderInfo(orderId, cancelOrderRequest.getCancelType());
        CancelOrderAssembleRequest cancelOrderAssembleRequest = buildAssembleRequest(orderId, cancelOrderRequest, orderInfoDO);
        if (cancelOrderAssembleRequest.getOrderInfoDTO().getOrderStatus() &gt;= OrderStatusEnum.OUT_STOCK.getCode()) {
            throw new OrderBizException(OrderErrorCodeEnum.CURRENT_ORDER_STATUS_CANNOT_CANCEL);
        }

        TransactionMQProducer producer = defaultProducer.getProducer();
        producer.setTransactionListener(new TransactionListener() {
            @Override
            public LocalTransactionState executeLocalTransaction(Message message, Object o) {
                try {
                    //2.执行履约取消、更新订单状态、新增订单日志操作
                    afterSaleManager.cancelOrderFulfillmentAndUpdateOrderStatus(cancelOrderAssembleRequest);
                    return LocalTransactionState.COMMIT_MESSAGE;
                } catch (Exception e) {
                    log.error("system error", e);
                    return LocalTransactionState.ROLLBACK_MESSAGE;
                }
            }

            @Override
            public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {
                //查询订单状态是否已更新为"已取消"
                OrderInfoDO orderInfoByDatabase = orderInfoDAO.getByOrderId(orderId);
                if (OrderStatusEnum.CANCELED.getCode().equals(orderInfoByDatabase.getOrderStatus())) {
                    return LocalTransactionState.COMMIT_MESSAGE;
                }
                return LocalTransactionState.ROLLBACK_MESSAGE;
            }
        });

        try {
            Message message = new Message(RocketMqConstant.RELEASE_ASSETS_TOPIC, JSONObject.toJSONString(cancelOrderAssembleRequest).getBytes(StandardCharsets.UTF_8));
            //3.发送事务消息 释放权益资产
            TransactionSendResult result = producer.sendMessageInTransaction(message, cancelOrderAssembleRequest);
            if (!result.getLocalTransactionState().equals(LocalTransactionState.COMMIT_MESSAGE)) {
                throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_PROCESS_FAILED);
            }
            return JsonResult.buildSuccess(true);
        } catch (Exception e) {
            throw new OrderBizException(OrderErrorCodeEnum.SEND_TRANSACTION_MQ_FAILED);
        }
    }
    ...
}</code></pre>
<p data-track="96"><strong>(3)对取消履约+更新订单状态+新增订单日志的处理</strong></p>
<pre class="highlighter-hljs"><code>@Service
public class AfterSaleManagerImpl implements AfterSaleManager {
    ...
    @Override
    public void cancelOrderFulfillmentAndUpdateOrderStatus(CancelOrderAssembleRequest cancelOrderAssembleRequest) {
        //履约取消
        cancelFulfill(cancelOrderAssembleRequest);

        //更新订单状态和记录订单操作日志
        updateOrderStatusAndSaveOperationLog(cancelOrderAssembleRequest);
    }

    //调用履约拦截订单
    private void cancelFulfill(CancelOrderAssembleRequest cancelOrderAssembleRequest) {
        OrderInfoDTO orderInfoDTO = cancelOrderAssembleRequest.getOrderInfoDTO();
        if (OrderStatusEnum.CREATED.getCode().equals(orderInfoDTO.getOrderStatus())) {
            return;
        }
        CancelFulfillRequest cancelFulfillRequest = orderInfoDTO.clone(CancelFulfillRequest.class);
        JsonResult&lt;Boolean&gt; jsonResult = fulfillApi.cancelFulfill(cancelFulfillRequest);
        if (!jsonResult.getSuccess()) {
            throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_FULFILL_ERROR);
        }
    }

    //更新订单状态和记录订单操作日志
    private void updateOrderStatusAndSaveOperationLog(CancelOrderAssembleRequest cancelOrderAssembleRequest) {
        //更新订单表
        OrderInfoDO orderInfoDO = cancelOrderAssembleRequest.getOrderInfoDTO().clone(OrderInfoDO.class);
        orderInfoDO.setCancelType(cancelOrderAssembleRequest.getCancelType().toString());
        orderInfoDO.setOrderStatus(OrderStatusEnum.CANCELED.getCode());
        orderInfoDO.setCancelTime(new Date());
        orderInfoDAO.updateOrderInfo(orderInfoDO);
        log.info("更新订单信息OrderInfo状态: orderId:{},status:{}", orderInfoDO.getOrderId(), orderInfoDO.getOrderStatus());

        //新增订单操作操作日志表
        Integer cancelType = Integer.valueOf(orderInfoDO.getCancelType());
        String orderId = orderInfoDO.getOrderId();
        OrderOperateLogDO orderOperateLogDO = new OrderOperateLogDO();
        orderOperateLogDO.setOrderId(orderId);
        orderOperateLogDO.setPreStatus(cancelOrderAssembleRequest.getOrderInfoDTO().getOrderStatus());
        orderOperateLogDO.setCurrentStatus(OrderStatusEnum.CANCELED.getCode());
        orderOperateLogDO.setOperateType(OrderOperateTypeEnum.AUTO_CANCEL_ORDER.getCode());
        if (OrderCancelTypeEnum.USER_CANCELED.getCode().equals(cancelType)) {
            orderOperateLogDO.setOperateType(OrderOperateTypeEnum.MANUAL_CANCEL_ORDER.getCode());
            orderOperateLogDO.setRemark(OrderOperateTypeEnum.MANUAL_CANCEL_ORDER.getMsg()
                + orderOperateLogDO.getPreStatus() + "-" + orderOperateLogDO.getCurrentStatus());
        }
        if (OrderCancelTypeEnum.TIMEOUT_CANCELED.getCode().equals(cancelType)) {
            orderOperateLogDO.setOperateType(OrderOperateTypeEnum.AUTO_CANCEL_ORDER.getCode());
            orderOperateLogDO.setRemark(OrderOperateTypeEnum.AUTO_CANCEL_ORDER.getMsg()
                + orderOperateLogDO.getPreStatus() + "-" + orderOperateLogDO.getCurrentStatus());
        }
        orderOperateLogDAO.save(orderOperateLogDO);
        log.info("新增订单操作日志OrderOperateLog状态,orderId:{}, PreStatus:{},CurrentStatus:{}", orderInfoDO.getOrderId(),
            orderOperateLogDO.getPreStatus(), orderOperateLogDO.getCurrentStatus());
    }
    ...
}</code></pre>
<p data-track="98"><strong>(4)对释放资产的处理</strong></p>
<pre class="highlighter-hljs"><code>@Configuration
public class ConsumerConfig {
    @Autowired
    private RocketMQProperties rocketMQProperties;
    ...

    //释放资产消息消费者
    @Bean("releaseAssetsConsumer")
    public DefaultMQPushConsumer releaseAssetsConsumer(ReleaseAssetsListener releaseAssetsListener) throws MQClientException {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(RELEASE_ASSETS_CONSUMER_GROUP);
        consumer.setNamesrvAddr(rocketMQProperties.getNameServer());
        consumer.subscribe(RELEASE_ASSETS_TOPIC, "*");
        consumer.registerMessageListener(releaseAssetsListener);
        consumer.start();
        return consumer;
    }
}

//消费MQ的释放资产消息
@Component
public class ReleaseAssetsListener implements MessageListenerConcurrently {
    @Autowired
    private DefaultProducer defaultProducer;

    @Autowired
    private OrderItemDAO orderItemDAO;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt messageExt : list) {
                //1.消费到释放资产message
                String message = new String(messageExt.getBody());
                log.info("ReleaseAssetsListener message:{}", message);
                CancelOrderAssembleRequest cancelOrderAssembleRequest = JSONObject.parseObject(message, CancelOrderAssembleRequest.class);
                OrderInfoDTO orderInfoDTO = cancelOrderAssembleRequest.getOrderInfoDTO();

                //2.发送取消订单退款请求MQ
                if (orderInfoDTO.getOrderStatus() &gt; OrderStatusEnum.CREATED.getCode()) {
                    defaultProducer.sendMessage(RocketMqConstant.CANCEL_REFUND_REQUEST_TOPIC,
                        JSONObject.toJSONString(cancelOrderAssembleRequest), "取消订单退款");
                }

                //3.发送释放库存MQ
                ReleaseProductStockRequest releaseProductStockRequest = buildReleaseProductStock(orderInfoDTO, orderItemDAO);
                defaultProducer.sendMessage(RocketMqConstant.CANCEL_RELEASE_INVENTORY_TOPIC,
                    JSONObject.toJSONString(releaseProductStockRequest), "取消订单释放库存");

                //4.发送释放优惠券MQ
                if (!Strings.isNullOrEmpty(orderInfoDTO.getCouponId())) {
                    ReleaseUserCouponRequest releaseUserCouponRequest = buildReleaseUserCoupon(orderInfoDTO);
                    defaultProducer.sendMessage(RocketMqConstant.CANCEL_RELEASE_PROPERTY_TOPIC,
                        JSONObject.toJSONString(releaseUserCouponRequest), "取消订单释放优惠券");
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }

    //组装释放优惠券数据
    private ReleaseUserCouponRequest buildReleaseUserCoupon(OrderInfoDTO orderInfoDTO) {
        ReleaseUserCouponRequest releaseUserCouponRequest = new ReleaseUserCouponRequest();
        releaseUserCouponRequest.setCouponId(orderInfoDTO.getCouponId());
        releaseUserCouponRequest.setUserId(orderInfoDTO.getUserId());
        releaseUserCouponRequest.setOrderId(orderInfoDTO.getOrderId());
        return releaseUserCouponRequest;
    }

    //组装释放库存数据
    private ReleaseProductStockRequest buildReleaseProductStock(OrderInfoDTO orderInfoDTO, OrderItemDAO orderItemDAO) {
        String orderId = orderInfoDTO.getOrderId();
        List&lt;ReleaseProductStockRequest.OrderItemRequest&gt; orderItemRequestList = new ArrayList&lt;&gt;();

        //查询订单条目
        ReleaseProductStockRequest.OrderItemRequest orderItemRequest;
        List&lt;OrderItemDO&gt; orderItemDOList = orderItemDAO.listByOrderId(orderId);
        for (OrderItemDO orderItemDO : orderItemDOList) {
            orderItemRequest = new ReleaseProductStockRequest.OrderItemRequest();
            orderItemRequest.setSkuCode(orderItemDO.getSkuCode());
            orderItemRequest.setSaleQuantity(orderItemDO.getSaleQuantity());
            orderItemRequestList.add(orderItemRequest);
        }
        ReleaseProductStockRequest releaseProductStockRequest = new ReleaseProductStockRequest();
        releaseProductStockRequest.setOrderId(orderInfoDTO.getOrderId());
        releaseProductStockRequest.setOrderItemRequestList(orderItemRequestList);
        return releaseProductStockRequest;
    }
}

@Configuration
public class ConsumerConfig {
    @Autowired
    private RocketMQProperties rocketMQProperties;
    ...

    //消费退款请求消息 消费者
    @Bean("cancelRefundConsumer")
    public DefaultMQPushConsumer cancelRefundConsumer(CancelRefundListener cancelRefundListener) throws MQClientException {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(RocketMqConstant.REQUEST_CONSUMER_GROUP);
        consumer.setNamesrvAddr(rocketMQProperties.getNameServer());
        consumer.subscribe(RocketMqConstant.CANCEL_REFUND_REQUEST_TOPIC, "*");
        consumer.registerMessageListener(cancelRefundListener);
        consumer.start();
        return consumer;
    }
}

//消费取消订单退款请求的消息
@Component
public class CancelRefundListener implements MessageListenerConcurrently {
    @Autowired
    private OrderAfterSaleService orderAfterSaleService;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt messageExt : list) {
                String message = new String(messageExt.getBody());
                CancelOrderAssembleRequest cancelOrderAssembleRequest = JSONObject.parseObject(message, CancelOrderAssembleRequest.class);
                log.info("CancelRefundConsumer message:{}", message);
                //执行 取消订单/超时未支付取消 前的操作
                JsonResult&lt;Boolean&gt; jsonResult = orderAfterSaleService.processCancelOrder(cancelOrderAssembleRequest);
                if (!jsonResult.getSuccess()) {
                    throw new OrderBizException(OrderErrorCodeEnum.CONSUME_MQ_FAILED);
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
}

@Configuration
public class ConsumerConfig {
    @Autowired
    private RocketMQProperties rocketMQProperties;

    //释放库存消息消费者
    @Bean("releaseInventoryConsumer")
    public DefaultMQPushConsumer releaseInventoryConsumer(ReleaseInventoryListener releaseInventoryListener) throws MQClientException {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(RocketMqConstant.RELEASE_INVENTORY_CONSUMER_GROUP);
        consumer.setNamesrvAddr(rocketMQProperties.getNameServer());
        consumer.subscribe(RocketMqConstant.CANCEL_RELEASE_INVENTORY_TOPIC, "*");
        consumer.registerMessageListener(releaseInventoryListener);
        consumer.start();
        return consumer;
    }
    ...
}

//消费释放库存的消息
@Component
public class ReleaseInventoryListener implements MessageListenerConcurrently {
    @DubboReference(version = "1.0.0")
    private InventoryApi inventoryApi;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt msg : list) {
                String content = new String(msg.getBody(), StandardCharsets.UTF_8);
                log.info("ReleaseInventoryConsumer message:{}", content);
                CancelOrderReleaseProductStockRequest cancelOrderReleaseProductStockRequest = JSONObject.parseObject(content, CancelOrderReleaseProductStockRequest.class);
                JsonResult&lt;Boolean&gt; jsonResult = inventoryApi.cancelOrderReleaseProductStock(cancelOrderReleaseProductStockRequest);
                if (!jsonResult.getSuccess()) {
                    throw new InventoryBizException(InventoryErrorCodeEnum.CONSUME_MQ_FAILED);
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
}

@Configuration
public class ConsumerConfig {
    @Autowired
    private RocketMQProperties rocketMQProperties;

    //释放资产权益消息消费者
    @Bean("releaseInventoryConsumer")
    public DefaultMQPushConsumer releaseInventoryConsumer(ReleasePropertyListener releasePropertyListener) throws MQClientException {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(RocketMqConstant.RELEASE_PROPERTY_CONSUMER_GROUP);
        consumer.setNamesrvAddr(rocketMQProperties.getNameServer());
        consumer.subscribe(RocketMqConstant.CANCEL_RELEASE_PROPERTY_TOPIC, "*");
        consumer.registerMessageListener(releasePropertyListener);
        consumer.start();
        return consumer;
    }
    ...
}

//消费释放优惠券的消息
@Component
public class ReleasePropertyListener implements MessageListenerConcurrently {
    @DubboReference(version = "1.0.0")
    private MarketApi marketApi;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt msg : list) {
                String content = new String(msg.getBody(), StandardCharsets.UTF_8);
                log.info("ReleasePropertyConsumer message:{}", content);
                CancelOrderReleaseUserCouponRequest cancelOrderReleaseUserCouponRequest = JSONObject.parseObject(content, CancelOrderReleaseUserCouponRequest.class);
                JsonResult&lt;Boolean&gt; jsonResult = marketApi.cancelOrderReleaseCoupon(cancelOrderReleaseUserCouponRequest);
                if (!jsonResult.getSuccess()) {
                    throw new MarketBizException(MarketErrorCodeEnum.CONSUME_MQ_FAILED);
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
}</code></pre>
<p data-track="100"><strong>(5)对退款的退款前处理</strong></p>
<pre class="highlighter-hljs"><code>@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    @Override
    public JsonResult&lt;Boolean&gt; processCancelOrder(CancelOrderAssembleRequest cancelOrderAssembleRequest) {
        String orderId = cancelOrderAssembleRequest.getOrderId();
        //分布式锁
        String key = RedisLockKeyConstants.REFUND_KEY + orderId;
        try {
            boolean lock = redisLock.lock(key);
            if (!lock) {
                throw new OrderBizException(OrderErrorCodeEnum.PROCESS_REFUND_REPEAT);
            }

            //执行退款前的准备工作
            //生成售后订单号
            OrderInfoDTO orderInfoDTO = cancelOrderAssembleRequest.getOrderInfoDTO();
            OrderInfoDO orderInfoDO = orderInfoDTO.clone(OrderInfoDO.class);
            String afterSaleId = orderNoManager.genOrderId(OrderNoTypeEnum.AFTER_SALE.getCode(), orderInfoDO.getUserId());

            //1.计算 取消订单 退款金额
            CancelOrderRefundAmountDTO cancelOrderRefundAmountDTO = calculatingCancelOrderRefundAmount(cancelOrderAssembleRequest);
            cancelOrderAssembleRequest.setCancelOrderRefundAmountDTO(cancelOrderRefundAmountDTO);

            TransactionMQProducer producer = defaultProducer.getProducer();
            producer.setTransactionListener(new TransactionListener() {
                @Override
                public LocalTransactionState executeLocalTransaction(Message message, Object o) {
                    try {
                        //2.取消订单操作 记录售后信息
                        afterSaleManager.insertCancelOrderAfterSale(cancelOrderAssembleRequest, AfterSaleStatusEnum.REVIEW_PASS.getCode(), orderInfoDO, afterSaleId);
                        return LocalTransactionState.COMMIT_MESSAGE;
                    } catch (Exception e) {
                        log.error("system error", e);
                        return LocalTransactionState.ROLLBACK_MESSAGE;
                    }
                }

                @Override
                public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {
                    // 查询售后数据是否插入成功
                    AfterSaleInfoDO afterSaleInfoDO = afterSaleInfoDAO.getOneByAfterSaleId(Long.valueOf(afterSaleId));
                    List&lt;AfterSaleItemDO&gt; afterSaleItemDOList = afterSaleItemDAO.listByAfterSaleId(Long.valueOf(afterSaleId));
                    List&lt;AfterSaleLogDO&gt; afterSaleLogDOList = afterSaleLogDAO.listByAfterSaleId(Long.valueOf(afterSaleId));
                    List&lt;AfterSaleRefundDO&gt; afterSaleRefundDOList = afterSaleRefundDAO.listByAfterSaleId(Long.valueOf(afterSaleId));
                    if (afterSaleInfoDO != null &amp;&amp; afterSaleItemDOList.isEmpty() &amp;&amp; afterSaleLogDOList.isEmpty() &amp;&amp; afterSaleRefundDOList.isEmpty()) {
                        return LocalTransactionState.COMMIT_MESSAGE;
                    }
                    return LocalTransactionState.ROLLBACK_MESSAGE;
                }
            });

            try {
                //3.组装事务MQ消息
                ActualRefundMessage actualRefundMessage = new ActualRefundMessage();
                actualRefundMessage.setOrderId(cancelOrderAssembleRequest.getOrderId());
                actualRefundMessage.setLastReturnGoods(cancelOrderAssembleRequest.isLastReturnGoods());
                actualRefundMessage.setAfterSaleId(Long.valueOf(afterSaleId));
                Message message = new Message(RocketMqConstant.ACTUAL_REFUND_TOPIC, JSONObject.toJSONString(actualRefundMessage).getBytes(StandardCharsets.UTF_8));

                //4.发送事务MQ消息
                TransactionSendResult result = producer.sendMessageInTransaction(message, actualRefundMessage);
                if (!result.getLocalTransactionState().equals(LocalTransactionState.COMMIT_MESSAGE)) {
                    throw new OrderBizException(OrderErrorCodeEnum.PROCESS_REFUND_FAILED);
                }
                return JsonResult.buildSuccess(true);
            } catch (Exception e) {
                throw new OrderBizException(OrderErrorCodeEnum.SEND_TRANSACTION_MQ_FAILED);
            }
        } finally {
            redisLock.unlock(key);
        }
    }
    ...
}

@Service
public class AfterSaleManagerImpl implements AfterSaleManager {
    ...
    //取消订单操作 记录售后信息
    @Transactional(rollbackFor = Exception.class)
    @Override
    public void insertCancelOrderAfterSale(CancelOrderAssembleRequest cancelOrderAssembleRequest, Integer afterSaleStatus, OrderInfoDO orderInfoDO, String afterSaleId) {
        OrderInfoDTO orderInfoDTO = cancelOrderAssembleRequest.getOrderInfoDTO();
        //取消订单过程中的 申请退款金额 和 实际退款金额 都是实付退款金额 金额相同
        AfterSaleInfoDO afterSaleInfoDO = new AfterSaleInfoDO();
        afterSaleInfoDO.setApplyRefundAmount(orderInfoDO.getPayAmount());
        afterSaleInfoDO.setRealRefundAmount(orderInfoDO.getPayAmount());

        //1.新增售后订单表
        Integer cancelOrderAfterSaleStatus = AfterSaleStatusEnum.REVIEW_PASS.getCode();
        insertCancelOrderAfterSaleInfoTable(orderInfoDO, cancelOrderAfterSaleStatus, afterSaleInfoDO, afterSaleId);
        cancelOrderAssembleRequest.setAfterSaleId(afterSaleId);

        //2.新增售后条目表
        String orderId = cancelOrderAssembleRequest.getOrderId();
        List&lt;OrderItemDTO&gt; orderItemDTOList = cancelOrderAssembleRequest.getOrderItemDTOList();
        insertAfterSaleItemTable(orderId, orderItemDTOList, afterSaleId);

        //3.新增售后变更表
        insertCancelOrderAfterSaleLogTable(afterSaleId, orderInfoDTO, AfterSaleStatusEnum.UN_CREATED.getCode(), afterSaleStatus);

        //4.新增售后支付表
        AfterSaleRefundDO afterSaleRefundDO = insertAfterSaleRefundTable(orderInfoDTO, afterSaleId, afterSaleInfoDO);
        cancelOrderAssembleRequest.setAfterSaleRefundId(afterSaleRefundDO.getId());
    }
    ...
}</code></pre>
<p data-track="102"><strong>(6)对退款的实际退款处理</strong></p>
<pre class="highlighter-hljs"><code>@Configuration
public class ConsumerConfig {
    @Autowired
    private RocketMQProperties rocketMQProperties;
    ...

    @Bean("actualRefundConsumer")
    public DefaultMQPushConsumer actualRefundConsumer(ActualRefundListener actualRefundListener) throws MQClientException {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(ACTUAL_REFUND_CONSUMER_GROUP);
        consumer.setNamesrvAddr(rocketMQProperties.getNameServer());
        consumer.subscribe(ACTUAL_REFUND_TOPIC, "*");
        consumer.registerMessageListener(actualRefundListener);
        consumer.start();
        return consumer;
    }
}

//实际退款消费者
@Component
public class ActualRefundListener implements MessageListenerConcurrently {
    @Autowired
    private OrderAfterSaleService orderAfterSaleService;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt messageExt : list) {
                String message = new String(messageExt.getBody());
                ActualRefundMessage actualRefundMessage = JSONObject.parseObject(message, ActualRefundMessage.class);
                log.info("ActualRefundConsumer message:{}", message);
                JsonResult&lt;Boolean&gt; jsonResult = orderAfterSaleService.refundMoney(actualRefundMessage);
                if (!jsonResult.getSuccess()) {
                    throw new OrderBizException(jsonResult.getErrorCode(), jsonResult.getErrorMessage());
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
}

@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //执行退款
    @Override
    public JsonResult&lt;Boolean&gt; refundMoney(ActualRefundMessage actualRefundMessage) {
        Long afterSaleId = actualRefundMessage.getAfterSaleId();
        String key = RedisLockKeyConstants.REFUND_KEY + afterSaleId;
        try {
            boolean lock = redisLock.lock(key);
            if (!lock) {
                throw new OrderBizException(OrderErrorCodeEnum.REFUND_MONEY_REPEAT);
            }
            AfterSaleInfoDO afterSaleInfoDO = afterSaleInfoDAO.getOneByAfterSaleId(actualRefundMessage.getAfterSaleId());
            AfterSaleRefundDO afterSaleRefundDO = afterSaleRefundDAO.findOrderAfterSaleStatus(String.valueOf(afterSaleId));

            //1.封装调用支付退款接口的数据
            PayRefundRequest payRefundRequest = buildPayRefundRequest(actualRefundMessage, afterSaleRefundDO);

            //2.执行退款
            if (!payApi.executeRefund(payRefundRequest)) {
                throw new OrderBizException(OrderErrorCodeEnum.ORDER_REFUND_AMOUNT_FAILED);
            }

            //3.本次售后的订单条目是当前订单的最后一笔，发送事务MQ退优惠券，此时isLastReturnGoods标记是true
            if (actualRefundMessage.isLastReturnGoods()) {
                TransactionMQProducer producer = defaultProducer.getProducer();
                //组装事务MQ消息体
                ReleaseUserCouponRequest releaseUserCouponRequest = buildLastOrderReleasesCouponMessage(producer, afterSaleInfoDO, afterSaleId, actualRefundMessage);
                try {
                    //4.发送事务消息 释放优惠券
                    Message message = new Message(RocketMqConstant.CANCEL_RELEASE_PROPERTY_TOPIC, JSONObject.toJSONString(releaseUserCouponRequest).getBytes(StandardCharsets.UTF_8));
                    TransactionSendResult result = producer.sendMessageInTransaction(message, releaseUserCouponRequest);
                    if (!result.getLocalTransactionState().equals(LocalTransactionState.COMMIT_MESSAGE)) {
                        throw new OrderBizException(OrderErrorCodeEnum.REFUND_MONEY_RELEASE_COUPON_FAILED);
                    }
                    return JsonResult.buildSuccess(true);
                } catch (Exception e) {
                    throw new OrderBizException(OrderErrorCodeEnum.SEND_TRANSACTION_MQ_FAILED);
                }
            } else {
                //当前售后条目非本订单的最后一笔 和 取消订单，在此更新售后状态后流程结束
                //更新售后单状态
                updateAfterSaleStatus(afterSaleInfoDO, AfterSaleStatusEnum.REVIEW_PASS.getCode(), AfterSaleStatusEnum.REFUNDING.getCode());
                return JsonResult.buildSuccess(true);
            }
        } catch (OrderBizException e) {
            log.error("system error", e);
            return JsonResult.buildError(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
    }

    private ReleaseUserCouponRequest buildLastOrderReleasesCouponMessage(TransactionMQProducer producer, AfterSaleInfoDO afterSaleInfoDO, Long afterSaleId, ActualRefundMessage actualRefundMessage) {
        producer.setTransactionListener(new TransactionListener() {
            @Override
            public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {
                try {
                    //更新售后单状态
                    updateAfterSaleStatus(afterSaleInfoDO, AfterSaleStatusEnum.REVIEW_PASS.getCode(), AfterSaleStatusEnum.REFUNDING.getCode());
                    return LocalTransactionState.COMMIT_MESSAGE;
                } catch (Exception e) {
                    log.error("system error", e);
                    return LocalTransactionState.ROLLBACK_MESSAGE;
                }
            }

            @Override
            public LocalTransactionState checkLocalTransaction(MessageExt msg) {
                //查询售后单状态是"退款中"
                AfterSaleInfoDO afterSaleInfoDO = afterSaleInfoDAO.getOneByAfterSaleId(afterSaleId);
                if (AfterSaleStatusEnum.REFUNDING.getCode().equals(afterSaleInfoDO.getAfterSaleStatus())) {
                    return LocalTransactionState.COMMIT_MESSAGE;
                }
                return LocalTransactionState.ROLLBACK_MESSAGE;
            }
        });

        //组装释放优惠券权益消息数据
        String orderId = actualRefundMessage.getOrderId();
        OrderInfoDO orderInfoDO = orderInfoDAO.getByOrderId(orderId);
        ReleaseUserCouponRequest releaseUserCouponRequest = new ReleaseUserCouponRequest();
        releaseUserCouponRequest.setCouponId(orderInfoDO.getCouponId());
        releaseUserCouponRequest.setUserId(orderInfoDO.getUserId());
        return releaseUserCouponRequest;
    }
    ...
}</code></pre>
<p data-track="104">&nbsp;</p>
<p data-track="105"><strong>9.为什么拦截履约要同步而释放资产是异步</strong></p>
<p data-track="106"><strong>(1)在正向订单流程中触发履约采用异步柔性事务</strong></p>
<p data-track="107"><strong>(2)在逆向订单流程中拦截履约采用同步刚性事务</strong></p>
<p data-track="108">&nbsp;</p>
<p data-track="109"><strong>(1)在正向订单流程中触发履约采用异步柔性事务</strong></p>
<p data-track="110">生成订单写库、锁优惠券、锁库存这三个动作会绑定在一个刚性事务里，从而实现"生成订单写库 + 锁优惠券 + 锁库存"的强同步效果。但是当支付成功完成支付回调后，推送订单消息进行履约时，则通过MQ异步推送。也就是说："生单 + 锁优惠券 + 锁库存"采用了同步刚性事务，而"推送订单消息触发履约"则采用了异步柔性事务。</p>
<p data-track="111">&nbsp;</p>
<p data-track="112"><strong>原因一：</strong>在正向订单流程中，生单会使用到优惠券及涉及扣减库存。如果不采用同步刚性事务，则可能会出现虽然订单已经生成了，但是用户却还是能看到其优惠券的状态还处于未使用，或库存还没扣减。这样就可能对用户造成困惑，数据产生了短暂的不一致问题。严重可能会导致用户重复使用优惠券，以及库存超卖问题。</p>
<p data-track="113">&nbsp;</p>
<p data-track="114">所以"生单 + 锁优惠券 + 锁库存"采用同步刚性事务，当生单操作一旦完成，用户就可以看到优惠券已使用 + 库存已扣减。</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="453" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/8f5e729d355d4504825f1d53f253e462~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250710104308C49EC69ACF591C43F65E&amp;x-expires=2147483647&amp;x-signature=GL62U2OPIDEa9v6okPps1%2F%2F9DrA%3D" class="lazyload"></div>
<p data-track="115"><strong>原因二：</strong>推送订单消息触发履约可以采用异步柔性事务，是因为用户支付完一个订单后，并没有必要马上看到订单已在履约处理，所以"推送订单进行履约"是天然可以被用户接受延迟的。</p>
<p data-track="116">&nbsp;</p>
<p data-track="117"><strong>(2)在逆向订单流程中拦截履约采用同步刚性事务</strong></p>
<p data-track="118">与正向订单流程刚好相反："修改订单状态 + 拦截订单不被履约"采用了同步刚性事务，而"释放优惠券 + 释放库存"则采用了异步柔性事务。因为取消订单的第一要务必然是拦截履约。</p>
<p data-track="119">&nbsp;</p>
<p data-track="120">如果"修改订单状态 + 拦截订单不被履约"采用了异步柔性事务，那么可能出现订单状态已经改为已取消，但是由于异步拦截履约慢了，导致订单都已经被打包发货了，这样就可能发生纠纷和资损了。</p>
<p data-track="121">&nbsp;</p>
<p data-track="122">如果订单还没被支付就进行了取消，此时订单状态被修改后，可以不用立刻关注库存和优惠券。在用户看来，其还没释放的优惠券最多不能马上恢复使用，影响不严重。最差也不会出现优惠券被用户重复使用的恶劣情况，以及库存超卖问题。</p>
<p data-track="21" data-pm-slice="1 1 []">&nbsp;</p>
<p data-track="121"><strong>10.支付回调分别互斥预支付和取消订单</strong></p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="773" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/8d19c837ee57469b8dfc000ddcc80169~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202507101043093CA8EF9F302A50B5613F&amp;x-expires=2147483647&amp;x-signature=%2Bu1nLgN7WMBEss5Pq5gUPqIkr48%3D" class="lazyload"></div>
<p data-track="122">首先，预支付和支付回调会加同一把锁：ORDER_PAY_KEY。然后，支付回调和取消订单也会加同一把锁：CANCEL_KEY。所以支付回调会加两把锁：ORDER_PAY_KEY和CANCEL_KEY，这可以通过Redisson的MutiLock来实现。</p>
<pre class="highlighter-hljs"><code>@Service
public class OrderServiceImpl implements OrderService {
    ...
    //预支付订单
    @Override
    @Transactional(rollbackFor = Exception.class)
    public PrePayOrderDTO prePayOrder(PrePayOrderRequest prePayOrderRequest) {
        //入参检查
        checkPrePayOrderRequestParam(prePayOrderRequest);
        String orderId = prePayOrderRequest.getOrderId();
        Integer payAmount = prePayOrderRequest.getPayAmount();

        //加分布式锁(与订单支付回调时加的是同一把锁)
        String key = RedisLockKeyConstants.ORDER_PAY_KEY + orderId;
        boolean lock = redisLock.lock(key);
        if (!lock) {
            throw new OrderBizException(OrderErrorCodeEnum.ORDER_PRE_PAY_ERROR);
        }
        try {
            ...
        } finally {
            //释放分布式锁
            redisLock.unlock(key);
        }
    }
    ...

    //支付回调
    //支付回调有2把分布式锁的原因说明：同一笔订单在同一时间只能支付or取消
    //不可以同时对一笔订单，既发起支付，又发起取消
    @Override
    public void payCallback(PayCallbackRequest payCallbackRequest) {
        //入参检查
        checkPayCallbackRequestParam(payCallbackRequest);
        String orderId = payCallbackRequest.getOrderId();
        Integer payAmount = payCallbackRequest.getPayAmount();
        Integer payType = payCallbackRequest.getPayType();
        List&lt;String&gt; redisKeyList = Lists.newArrayList();

        //加支付分布式锁避免支付系统并发回调
        String orderPayKey = RedisLockKeyConstants.ORDER_PAY_KEY + orderId;

        //加取消订单分布式锁避免支付和取消订单同时操作同一笔订单
        String cancelOrderKey = RedisLockKeyConstants.CANCEL_KEY + orderId;
        redisKeyList.add(orderPayKey);
        redisKeyList.add(cancelOrderKey);

        boolean lock = redisLock.multiLock(redisKeyList);
        if (!lock) {
            throw new OrderBizException(OrderErrorCodeEnum.ORDER_PAY_CALLBACK_ERROR);
        }
        try {
            ...
        } catch (Exception e) {
            throw new OrderBizException(e.getMessage());
        } finally {
            //释放分布式锁
            redisLock.unMultiLock(redisKeyList);
        }
    }
    ...
}

@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //取消订单/超时未支付取消
    @Override
    @GlobalTransactional(rollbackFor = Exception.class)
    public JsonResult&lt;Boolean&gt; cancelOrder(CancelOrderRequest cancelOrderRequest) {
        //入参检查
        checkCancelOrderRequestParam(cancelOrderRequest);

        //分布式锁
        String orderId = cancelOrderRequest.getOrderId();
        String key = RedisLockKeyConstants.CANCEL_KEY + orderId;
        boolean lock = redisLock.lock(key);
        if (!lock) {
            throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_REPEAT);
        }
        try {
            //执行取消订单
            return executeCancelOrder(cancelOrderRequest, orderId);
        } catch (Exception e) {
            log.error("biz error", e);
            throw new OrderBizException(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
    }
    ...
}</code></pre>
<p data-track="124">&nbsp;</p>
<p data-track="125"><strong>11.支付回调和取消订单互斥下的两种场景分析</strong></p>
<p data-track="126">支付回调的处理过程中，会对异常场景进行判断：</p>
<p data-track="127">&nbsp;</p>
<p data-track="128"><strong>一.如果订单状态是"已创建"</strong></p>
<p data-track="129">那么会更新订单状态为已支付，并发送事务消息。</p>
<p data-track="130">&nbsp;</p>
<p data-track="131"><strong>二.如果订单状态不是"已创建"</strong></p>
<p data-track="132">那么判断订单状态是否是取消状态，如果是取消状态，则继续判断订单是否未支付。若是未支付，则进行退款，并抛出异常。若不是未支付，则按支付方式抛出不同的异常。如果不是取消状态，则判断支付回调是否是同种支付方式。如果是，则返回。如果不是，则进行退款，并抛出异常。</p>
<pre class="highlighter-hljs"><code>@Service
public class OrderServiceImpl implements OrderService {
    ...
    //支付回调
    //支付回调有2把分布式锁的原因说明：同一笔订单在同一时间只能支付or取消
    //不可以同时对一笔订单，既发起支付，又发起取消
    @Override
    public void payCallback(PayCallbackRequest payCallbackRequest) {
        //1.入参检查
        checkPayCallbackRequestParam(payCallbackRequest);

        String orderId = payCallbackRequest.getOrderId();
        Integer payAmount = payCallbackRequest.getPayAmount();
        Integer payType = payCallbackRequest.getPayType();
        List&lt;String&gt; redisKeyList = Lists.newArrayList();

        //2.加支付分布式锁避免支付系统并发回调
        String orderPayKey = RedisLockKeyConstants.ORDER_PAY_KEY + orderId;
        //加取消订单分布式锁避免支付和取消订单同时操作同一笔订单
        String cancelOrderKey = RedisLockKeyConstants.CANCEL_KEY + orderId;
        redisKeyList.add(orderPayKey);
        redisKeyList.add(cancelOrderKey);
        boolean lock = redisLock.multiLock(redisKeyList);
        if (!lock) {
            throw new OrderBizException(OrderErrorCodeEnum.ORDER_PAY_CALLBACK_ERROR);
        }
        try {
            //从数据库中查询出当前订单信息
            OrderInfoDO orderInfoDO = orderInfoDAO.getByOrderId(orderId);
            OrderPaymentDetailDO orderPaymentDetailDO = orderPaymentDetailDAO.getPaymentDetailByOrderId(orderId);
            //3.校验参数
            if (orderInfoDO == null || orderPaymentDetailDO == null) {
                throw new OrderBizException(OrderErrorCodeEnum.ORDER_INFO_IS_NULL);
            }
            if (!payAmount.equals(orderInfoDO.getPayAmount())) {
                throw new OrderBizException(OrderErrorCodeEnum.ORDER_CALLBACK_PAY_AMOUNT_ERROR);
            }

            //4.异常场景判断
            Integer orderStatus = orderInfoDO.getOrderStatus();
            if (OrderStatusEnum.CREATED.getCode().equals(orderStatus)) {
                //如果订单状态是"已创建"，直接更新订单状态为已支付，并发送事务消息
                TransactionMQProducer transactionMQProducer = defaultProducer.getProducer();
                transactionMQProducer.setTransactionListener(new TransactionListener() {
                    @Override
                    public LocalTransactionState executeLocalTransaction(Message message, Object o) {
                        try {
                            orderManager.updateOrderStatusPaid(payCallbackRequest, orderInfoDO, orderPaymentDetailDO);
                            return LocalTransactionState.COMMIT_MESSAGE;
                        } catch (BaseBizException e) {
                            throw e;
                        } catch (Exception e) {
                            log.error("system error", e);
                            return LocalTransactionState.ROLLBACK_MESSAGE;
                        }
                    }

                    @Override
                    public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {
                        //检查订单是否是已支付
                        OrderInfoDO orderInfoDO = orderInfoDAO.getByOrderId(orderId);
                        if (orderInfoDO != null &amp;&amp; OrderStatusEnum.PAID.getCode().equals(orderInfoDO.getOrderStatus())) {
                            return LocalTransactionState.COMMIT_MESSAGE;
                        }
                        return LocalTransactionState.ROLLBACK_MESSAGE;
                    }
                });
                //发送 "订单已完成支付" 消息
                sendPaidOrderSuccessMessage(transactionMQProducer, orderInfoDO);
            } else {
                //如果订单状态不是 "已创建"
                if (OrderStatusEnum.CANCELED.getCode().equals(orderStatus)) {
                    //如果订单状态是取消状态
                    Integer payStatus = orderPaymentDetailDO.getPayStatus();
                    if (PayStatusEnum.UNPAID.getCode().equals(payStatus)) {
                        //调用退款
                        executeOrderRefund(orderInfoDO, orderPaymentDetailDO);
                        throw new OrderBizException(OrderErrorCodeEnum.ORDER_CANCEL_PAY_CALLBACK_ERROR);
                    } else if (PayStatusEnum.PAID.getCode().equals(payStatus)) {
                        if (payType.equals(orderPaymentDetailDO.getPayType())) {
                            throw new OrderBizException(OrderErrorCodeEnum.ORDER_CANCEL_PAY_CALLBACK_PAY_TYPE_SAME_ERROR);
                        } else {
                            throw new OrderBizException(OrderErrorCodeEnum.ORDER_CANCEL_PAY_CALLBACK_PAY_TYPE_NO_SAME_ERROR);
                        }
                    }
                } else {
                    //如果订单状态不是取消状态
                    if (PayStatusEnum.PAID.getCode().equals(orderPaymentDetailDO.getPayStatus())) {
                        if (payType.equals(orderPaymentDetailDO.getPayType())) {
                            return;
                        }
                        //调用退款
                        executeOrderRefund(orderInfoDO, orderPaymentDetailDO);
                        throw new OrderBizException(OrderErrorCodeEnum.ORDER_CANCEL_PAY_CALLBACK_REPEAT_ERROR);
                    }
                }
            }
        } catch (Exception e) {
            throw new OrderBizException(e.getMessage());
        } finally {
            //释放分布式锁
            redisLock.unMultiLock(redisKeyList);
        }
    }

    //发送订单已完成支付消息，触发订单进行履约
    private void sendPaidOrderSuccessMessage(TransactionMQProducer transactionMQProducer, OrderInfoDO orderInfoDO) throws MQClientException {
        String orderId = orderInfoDO.getOrderId();
        PaidOrderSuccessMessage message = new PaidOrderSuccessMessage();
        message.setOrderId(orderId);
        String topic = RocketMqConstant.PAID_ORDER_SUCCESS_TOPIC;
        byte[] body = JSON.toJSONString(message).getBytes(StandardCharsets.UTF_8);
        Message mq = new Message(topic, body);
        TransactionSendResult result = transactionMQProducer.sendMessageInTransaction(mq, orderInfoDO);
        if (!result.getLocalTransactionState().equals(LocalTransactionState.COMMIT_MESSAGE)) {
            throw new OrderBizException(OrderErrorCodeEnum.ORDER_PAY_CALLBACK_SEND_MQ_ERROR);
        }
    }
    ...
}

//支付系统回调请求对象
@Data
public class PayCallbackRequest extends AbstractObject implements Serializable {
    private static final long serialVersionUID = 3685085492927992753L;
    private String orderId;//订单ID
    private String payAccount;//支付账户
    private Integer payAmount;//支付金额
    private String outTradeNo;//支付系统交易单号
    private Integer payType;//支付方式
    private String merchantId;//商户号
    private String payChannel;//支付渠道
    private String appid;//微信平台 appid
}</code></pre>
<p data-track="134">&nbsp;</p>
<p data-track="135"><strong>12.拦截履约的具体业务流程</strong></p>
<p data-track="136">流程图如下：</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="548" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/54ac0545135946148bd2c2a8044752e1~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202507101043093CA8EF9F302A50B5613F&amp;x-expires=2147483647&amp;x-signature=CfpdbpONZqoohXl7fcOZVobQtbQ%3D" class="lazyload"></div>
<p data-track="137">代码如下：</p>
<p data-track="138"><strong>一.取消订单入口</strong></p>
<pre class="highlighter-hljs"><code>@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    @Autowired
    private AfterSaleManager afterSaleManager;
    ...

    //取消订单/超时未支付取消
    @Override
    @GlobalTransactional(rollbackFor = Exception.class)
    public JsonResult&lt;Boolean&gt; cancelOrder(CancelOrderRequest cancelOrderRequest) {
        //入参检查
        checkCancelOrderRequestParam(cancelOrderRequest);
        //分布式锁
        String orderId = cancelOrderRequest.getOrderId();
        String key = RedisLockKeyConstants.CANCEL_KEY + orderId;
        boolean lock = redisLock.lock(key);
        if (!lock) {
            throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_REPEAT);
        }
        try {
            //执行取消订单
            return executeCancelOrder(cancelOrderRequest, orderId);
        } catch (Exception e) {
            log.error("biz error", e);
            throw new OrderBizException(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
    }

    @Override
    public JsonResult&lt;Boolean&gt; executeCancelOrder(CancelOrderRequest cancelOrderRequest, String orderId) {
        //1.组装数据
        OrderInfoDO orderInfoDO = findOrderInfo(orderId, cancelOrderRequest.getCancelType());
        CancelOrderAssembleRequest cancelOrderAssembleRequest = buildAssembleRequest(orderId, cancelOrderRequest, orderInfoDO);
        if (cancelOrderAssembleRequest.getOrderInfoDTO().getOrderStatus() &gt;= OrderStatusEnum.OUT_STOCK.getCode()) {
            throw new OrderBizException(OrderErrorCodeEnum.CURRENT_ORDER_STATUS_CANNOT_CANCEL);
        }
        TransactionMQProducer producer = defaultProducer.getProducer();
        producer.setTransactionListener(new TransactionListener() {
            @Override
            public LocalTransactionState executeLocalTransaction(Message message, Object o) {
                try {
                    //2.执行履约取消、更新订单状态、新增订单日志操作
                    afterSaleManager.cancelOrderFulfillmentAndUpdateOrderStatus(cancelOrderAssembleRequest);
                    return LocalTransactionState.COMMIT_MESSAGE;
                } catch (Exception e) {
                    log.error("system error", e);
                    return LocalTransactionState.ROLLBACK_MESSAGE;
                }
            }

            @Override
            public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {
                //查询订单状态是否已更新为"已取消"
                OrderInfoDO orderInfoByDatabase = orderInfoDAO.getByOrderId(orderId);
                if (OrderStatusEnum.CANCELED.getCode().equals(orderInfoByDatabase.getOrderStatus())) {
                    return LocalTransactionState.COMMIT_MESSAGE;
                }
                return LocalTransactionState.ROLLBACK_MESSAGE;
            }
        });

        try {
            Message message = new Message(RocketMqConstant.RELEASE_ASSETS_TOPIC, JSONObject.toJSONString(cancelOrderAssembleRequest).getBytes(StandardCharsets.UTF_8));
            //3.发送事务消息 释放权益资产
            TransactionSendResult result = producer.sendMessageInTransaction(message, cancelOrderAssembleRequest);
            if (!result.getLocalTransactionState().equals(LocalTransactionState.COMMIT_MESSAGE)) {
                throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_PROCESS_FAILED);
            }
            return JsonResult.buildSuccess(true);
        } catch (Exception e) {
            throw new OrderBizException(OrderErrorCodeEnum.SEND_TRANSACTION_MQ_FAILED);
        }
    }
    ...
}</code></pre>
<p data-track="140"><strong>二.拦截履约处理</strong></p>
<pre class="highlighter-hljs"><code>@Service
public class AfterSaleManagerImpl implements AfterSaleManager {
    @DubboReference(version = "1.0.0")
    private FulfillApi fulfillApi;
    ...

    @Override
    public void cancelOrderFulfillmentAndUpdateOrderStatus(CancelOrderAssembleRequest cancelOrderAssembleRequest) {
        //履约取消
        cancelFulfill(cancelOrderAssembleRequest);
        //更新订单状态和记录订单操作日志
        updateOrderStatusAndSaveOperationLog(cancelOrderAssembleRequest);
    }

    //调用履约拦截订单
    private void cancelFulfill(CancelOrderAssembleRequest cancelOrderAssembleRequest) {
        OrderInfoDTO orderInfoDTO = cancelOrderAssembleRequest.getOrderInfoDTO();
        if (OrderStatusEnum.CREATED.getCode().equals(orderInfoDTO.getOrderStatus())) {
            return;
        }
        CancelFulfillRequest cancelFulfillRequest = orderInfoDTO.clone(CancelFulfillRequest.class);
        JsonResult&lt;Boolean&gt; jsonResult = fulfillApi.cancelFulfill(cancelFulfillRequest);
        if (!jsonResult.getSuccess()) {
            throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_FULFILL_ERROR);
        }
    }
    ...
}

@DubboService(version = "1.0.0", interfaceClass = FulfillApi.class, retries = 0)
public class FulfillApiImpl implements FulfillApi {
    @Autowired
    private FulfillService fulfillService;

    @DubboReference(version = "1.0.0", retries = 0)
    private WmsApi wmsApi;

    @DubboReference(version = "1.0.0", retries = 0)
    private TmsApi tmsApi;
    ...

    @Override
    public JsonResult&lt;Boolean&gt; cancelFulfill(CancelFulfillRequest cancelFulfillRequest) {
        log.info("取消履约：request={}", JSONObject.toJSONString(cancelFulfillRequest));
        //1.取消履约单
        fulfillService.cancelFulfillOrder(request.getOrderId());
        //2.取消捡货
        wmsApi.cancelPickGoods(request.getOrderId());
        //3.取消发货
        tmsApi.cancelSendOut(request.getOrderId());

        return JsonResult.buildSuccess(true);
    }
    ...
}

@Service
public class FulfillServiceImpl implements FulfillService {
    @Autowired
    private OrderFulfillDAO orderFulfillDAO;

    @Autowired
    private OrderFulfillItemDAO orderFulfillItemDAO;
    ...

    @Override
    public void cancelFulfillOrder(String orderId) {
        //1.查询履约单
        OrderFulfillDO orderFulfill = orderFulfillDAO.getOne(orderId);
        //2.移除履约单
        if (null != orderFulfill) {
            orderFulfillDAO.removeById(orderFulfill.getId());
            //3.查询履约单条目
            List&lt;OrderFulfillItemDO&gt; fulfillItems = orderFulfillItemDAO.listByFulfillId(orderFulfill.getFulfillId());
            //4.移除履约单条目
            for (OrderFulfillItemDO item : fulfillItems) {
                orderFulfillItemDAO.removeById(item.getId());
            }
        }
    }
    ...
}

@DubboService(version = "1.0.0", interfaceClass = WmsApi.class, retries = 0)
public class WmsApiImpl implements WmsApi {
    ...
    @Transactional(rollbackFor = Exception.class)
    @Override
    public JsonResult&lt;Boolean&gt; cancelPickGoods(String orderId) {
        log.info("取消捡货，orderId={}", orderId);
        //1.查询出库单
        List&lt;DeliveryOrderDO&gt; deliveryOrders = deliveryOrderDAO.listByOrderId(orderId);
        //2.移除出库单和条目
        if (CollectionUtils.isNotEmpty(deliveryOrders)) {
            for (DeliveryOrderDO order : deliveryOrders) {
                List&lt;DeliveryOrderItemDO&gt; items = deliveryOrderItemDAO.listByDeliveryOrderId(order.getDeliveryOrderId());
                for (DeliveryOrderItemDO item : items) {
                    deliveryOrderItemDAO.removeById(item.getId());
                }
                deliveryOrderDAO.removeById(order.getId());
            }
        }
        return JsonResult.buildSuccess(true);
    }
    ...
}

@DubboService(version = "1.0.0", interfaceClass = TmsApi.class, retries = 0)
public class TmsApiImpl implements TmsApi {
    ...
    @Transactional(rollbackFor = Exception.class)
    @Override
    public JsonResult&lt;Boolean&gt; cancelSendOut(String orderId) {
        log.info("取消发货，orderId={}", orderId);
        //1.查询物流单
        List&lt;LogisticOrderDO&gt; logisticOrders = logisticOrderDAO.listByOrderId(orderId);
        //2.移除物流单
        for (LogisticOrderDO order : logisticOrders) {
            logisticOrderDAO.removeById(order.getId());
        }
        return JsonResult.buildSuccess(true);
    }
    ...
}</code></pre>
<p data-track="142">&nbsp;</p>
<p data-track="143"><strong>13.拦截履约和取消订单的Seata事务原理分析</strong></p>
<p data-track="144"><strong>(1)取消订单接口使用Seata事务的AT模式</strong></p>
<p data-track="145"><strong>(2)Seata事务AT模式的原理</strong></p>
<p data-track="146">&nbsp;</p>
<p data-track="147"><strong>(1)取消订单接口使用Seata事务的AT模式</strong></p>
<p data-track="148">如果拦截履约时发现，订单已经出库配送，那么就会拦截失败。当拦截失败时，就不能更新订单状态了，可使用Seata的刚性事务实现。具体就是，在分布式事务入口添加@GlobalTransactional注解，在各分支事务添加@Transactional注解。</p>
<pre class="highlighter-hljs"><code>@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //取消订单/超时未支付取消
    @Override
    @GlobalTransactional(rollbackFor = Exception.class)
    public JsonResult&lt;Boolean&gt; cancelOrder(CancelOrderRequest cancelOrderRequest) {
        //入参检查
        checkCancelOrderRequestParam(cancelOrderRequest);
        //分布式锁
        String orderId = cancelOrderRequest.getOrderId();
        String key = RedisLockKeyConstants.CANCEL_KEY + orderId;
        boolean lock = redisLock.lock(key);
        if (!lock) {
            throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_REPEAT);
        }

        try {
            //执行取消订单
            return executeCancelOrder(cancelOrderRequest, orderId);
        } catch (Exception e) {
            log.error("biz error", e);
            throw new OrderBizException(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
    }

    @Override
    public JsonResult&lt;Boolean&gt; executeCancelOrder(CancelOrderRequest cancelOrderRequest, String orderId) {
        //1.组装数据
        OrderInfoDO orderInfoDO = findOrderInfo(orderId, cancelOrderRequest.getCancelType());
        CancelOrderAssembleRequest cancelOrderAssembleRequest = buildAssembleRequest(orderId, cancelOrderRequest, orderInfoDO);
        if (cancelOrderAssembleRequest.getOrderInfoDTO().getOrderStatus() &gt;= OrderStatusEnum.OUT_STOCK.getCode()) {
            throw new OrderBizException(OrderErrorCodeEnum.CURRENT_ORDER_STATUS_CANNOT_CANCEL);
        }

        TransactionMQProducer producer = defaultProducer.getProducer();
        producer.setTransactionListener(new TransactionListener() {
            @Override
            public LocalTransactionState executeLocalTransaction(Message message, Object o) {
                try {
                    //2.执行履约取消、更新订单状态、新增订单日志操作
                    afterSaleManager.cancelOrderFulfillmentAndUpdateOrderStatus(cancelOrderAssembleRequest);
                    return LocalTransactionState.COMMIT_MESSAGE;
                } catch (Exception e) {
                    log.error("system error", e);
                    return LocalTransactionState.ROLLBACK_MESSAGE;
                }
            }
 
            @Override
            public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {
                //查询订单状态是否已更新为"已取消"
                OrderInfoDO orderInfoByDatabase = orderInfoDAO.getByOrderId(orderId);
                if (OrderStatusEnum.CANCELED.getCode().equals(orderInfoByDatabase.getOrderStatus())) {
                    return LocalTransactionState.COMMIT_MESSAGE;
                }
                return LocalTransactionState.ROLLBACK_MESSAGE;
            }
        });

        try {
            Message message = new Message(RocketMqConstant.RELEASE_ASSETS_TOPIC, JSONObject.toJSONString(cancelOrderAssembleRequest).getBytes(StandardCharsets.UTF_8));
            //3.发送事务消息 释放权益资产
            TransactionSendResult result = producer.sendMessageInTransaction(message, cancelOrderAssembleRequest);
            if (!result.getLocalTransactionState().equals(LocalTransactionState.COMMIT_MESSAGE)) {
                throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_PROCESS_FAILED);
            }
            return JsonResult.buildSuccess(true);
        } catch (Exception e) {
            throw new OrderBizException(OrderErrorCodeEnum.SEND_TRANSACTION_MQ_FAILED);
        }
    }
    ...
}</code></pre>
<p data-track="150"><strong>(2)Seata事务AT模式的原理</strong></p>
<pre class="highlighter-hljs"><code>一.取消订单接口的入口会向Seata Server注册一个全局事务XID
二.调用的履约服务会向Seata Server注册一个分支事务Branch ID
三.在履约服务更新数据前，要先获取本地锁
四.在履约服务在获取本地锁成功后，会插入undo log表数据
五.然后，履约服务会向Seata Server服务器获取全局锁
六.接着，履约服务才提交本地事务并释放本地锁
七.最后，履约服务会向Seata Server上报分支事务成功</code></pre>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="720" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/b86c6e313eda4489a569ac97a020af5a~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202507101043093CA8EF9F302A50B5613F&amp;x-expires=2147483647&amp;x-signature=iSAdBgV08%2B%2Fmm0ScjolImKy9R0k%3D" class="lazyload"></div>
<p data-track="152">&nbsp;</p>
<p data-track="153"><strong>14.取消订单全链路Seata回滚原理与并发分析</strong></p>
<p data-track="154"><strong>(1)回滚原理</strong></p>
<p data-track="155"><strong>(2)并发分析</strong></p>
<p data-track="156">&nbsp;</p>
<p data-track="157"><strong>(1)回滚原理</strong></p>
<p data-track="158">如果分支事务出现异常，就会上报Seata Server需要回滚全局事务。如果某些分支事务还没提交，那么直接就不需要执行了。如果某些分支事务已经提交成功，那么就根据undo log进行数据恢复。</p>
<p data-track="159">&nbsp;</p>
<p data-track="160"><strong>(2)并发分析</strong></p>
<p data-track="161">拦截履约的各分支事务并不会出现并发竞争全局锁的问题。因为取消履约、取消出库、取消配送都是针对一个订单操作，同一时刻不会出现大量对一个订单的操作。</p>
<p data-track="162">&nbsp;</p>
<p data-track="163"><strong>15.支付退款时的双异步设计原因(提升性能 + 解耦)</strong></p>
<p data-track="164">支付退款的时候会有两个消费者(双异步)：一个是退款准备消费者，一个是实际退款消费者。如果两个消费者合并成一个消费者，可能会出现两个问题。</p>
<p data-track="165">&nbsp;</p>
<p data-track="166">问题一：退款速度可能会比较慢，因为一个消费者需要处理的事情多了。</p>
<p data-track="167">&nbsp;</p>
<p data-track="168">问题二：如果第三方退款接口出现异常或报错，耦合比较严重特别不合理。这时计算好的数据和插入的记录，可能需要回滚或者重新消费消息。在故障情况下，第三方一直报错，那么系统就一直回滚，而且还会导致用户不能及时通过售后记录查看售后信息。</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="862" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/fc6b99ff99294761983ed5b803fb8076~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202507101043093CA8EF9F302A50B5613F&amp;x-expires=2147483647&amp;x-signature=EUnOO2%2BE%2FrgDdi1DwkQlKHgZI1M%3D" class="lazyload"></div>
<p data-track="169">&nbsp;</p>
<p data-track="170"><strong>16.释放资产消息的高扩展性设计(多路发送消息)</strong></p>
<p data-track="171">订单系统的取消订单接口被调用时，会先发送一个释放资产的消息到MQ，然后订单系统会消费释放资产的消息。在消费释放资产的消息时，才发送具体释放哪些资产的消息到MQ，接着各个系统才能对各自监听的释放资产消息进行消费。</p>
<p data-track="172">&nbsp;</p>
<p data-track="173">如果取消订单的核心业务代码，直接把具体的释放资产消息到MQ。那么当资产种类增加时，比如增加虚拟币、积分、权益等各种资产，就需要修改订单系统取消订单的核心业务代码了，扩展性会很差。</p>
<p data-track="174">&nbsp;</p>
<p data-track="175">如果取消订单的核心业务代码，只发一个释放资产的消息到MQ。那么后续增加资产种类时，只需在消费释放资产的消息处进行改动即可，这样就可以大大提高了代码的扩展性。</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="857" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/2f584e5300014b229a42ade036178750~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202507101043093CA8EF9F302A50B5613F&amp;x-expires=2147483647&amp;x-signature=OHecM2fRW5loRlCHFd3O5H4Q4pM%3D" class="lazyload"></div>
<p data-track="176">&nbsp;</p>
<p data-track="177"><strong>17.取消订单链路中数据库事务与MQ消息不一致问题</strong></p>
<p data-track="178"><strong>(1)数据库事务与MQ消息不一致情况</strong></p>
<p data-track="179"><strong>(2)取消订单全链路数据不丢失的方案设计</strong></p>
<p data-track="180">&nbsp;</p>
<p data-track="181"><strong>(1)数据库事务与MQ消息不一致情况</strong></p>
<p data-track="182">在v1版本的取消订单接口中，由于"更新订单状态 + 取消履约 + 发送释放资产消息到MQ"属于刚性事务，所以其中任何一个操作出现Exception，都会进行全局回滚保证数据一致。但是更新数据库和发送消息到MQ，还是可能会出现数据不一致的情况。</p>
<p data-track="183">&nbsp;</p>
<p data-track="184">比如代码顺序是：先发送释放资产消息，再更新订单状态，再取消履约。先发送释放资产消息到MQ成功，更新订单状态也成功，但取消履约失败。那么此时回滚只能回滚更新订单状态，发送到MQ的消息却不能回滚了。所以会存在这种不一致的风险，因此需要一种强一致的方案。</p>
<p data-track="185">&nbsp;</p>
<p data-track="186">如下是v1版本的取消订单实现：</p>
<pre class="highlighter-hljs"><code>@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //取消订单/超时未支付取消
    @Override
    public JsonResult&lt;Boolean&gt; cancelOrder(CancelOrderRequest cancelOrderRequest) {
        //入参检查
        checkCancelOrderRequestParam(cancelOrderRequest);
        //分布式锁
        String orderId = cancelOrderRequest.getOrderId();
        String key = RedisLockKeyConstants.CANCEL_KEY + orderId;

        try {
            boolean lock = redisLock.lock(key);
            if (!lock) {
                throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_REPEAT);
            }
            //执行取消订单
            executeCancelOrder(cancelOrderRequest, orderId);
            return JsonResult.buildSuccess(true);
        } catch (Exception e) {
            throw new OrderBizException(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
    }

    @Override
    @GlobalTransactional(rollbackFor = Exception.class)
    public void executeCancelOrder(CancelOrderRequest cancelOrderRequest, String orderId) {
        //1.组装数据
        CancelOrderAssembleRequest cancelOrderAssembleRequest = buildAssembleRequest(orderId, cancelOrderRequest);
        //幂等校验：防止多个线程同时操作取消同一笔订单
        if (OrderStatusEnum.CANCELED.getCode().equals(cancelOrderAssembleRequest.getOrderInfoDTO().getOrderStatus())) {
            return;
        }
        //2.检验订单支付状态
        checkOrderPayStatus(cancelOrderAssembleRequest);
        //3.更新订单状态和记录订单操作日志
        updateOrderStatusAndSaveOperationLog(cancelOrderAssembleRequest);
        //超时未支付的订单不用继续再往下执行取消履约和释放资产
        if (OrderStatusEnum.PAID.getCode() &gt; cancelOrderAssembleRequest.getOrderInfoDTO().getOrderStatus()) {
            return;
        }
        //4.履约取消
        cancelFulfill(cancelOrderAssembleRequest);
        //5.发送释放资产消息到MQ
        defaultProducer.sendMessage(RocketMqConstant.RELEASE_ASSETS_TOPIC, JSONObject.toJSONString(cancelOrderAssembleRequest), "释放资产");
    }
    ...
}</code></pre>
<p data-track="188"><strong>(2)取消订单全链路数据不丢失的方案设计</strong></p>
<p data-track="189">为保证取消订单的链路中，数据库的更新事务与推送给MQ的消息强一致，需要将两者包裹在一个事务中，保证它们要么一起成功，要么一起失败。于是，就需要通过RocketMQ的事务机制来实现了。</p>
<p data-track="190">&nbsp;</p>
<p data-track="191">如下是v2版本的取消订单实现，保证了数据库事务与MQ消息强一致。</p>
<pre class="highlighter-hljs"><code>@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //取消订单/超时未支付取消
    @Override
    @GlobalTransactional(rollbackFor = Exception.class)
    public JsonResult&lt;Boolean&gt; cancelOrder(CancelOrderRequest cancelOrderRequest) {
        //入参检查
        checkCancelOrderRequestParam(cancelOrderRequest);
        //分布式锁
        String orderId = cancelOrderRequest.getOrderId();
        String key = RedisLockKeyConstants.CANCEL_KEY + orderId;
        boolean lock = redisLock.lock(key);
        if (!lock) {
            throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_REPEAT);
        }
        try {
            //执行取消订单
            return executeCancelOrder(cancelOrderRequest, orderId);
        } catch (Exception e) {
            log.error("biz error", e);
            throw new OrderBizException(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
    }

    @Override
    public JsonResult&lt;Boolean&gt; executeCancelOrder(CancelOrderRequest cancelOrderRequest, String orderId) {
        //1.组装数据
        OrderInfoDO orderInfoDO = findOrderInfo(orderId, cancelOrderRequest.getCancelType());
        CancelOrderAssembleRequest cancelOrderAssembleRequest = buildAssembleRequest(orderId, cancelOrderRequest, orderInfoDO);
        if (cancelOrderAssembleRequest.getOrderInfoDTO().getOrderStatus() &gt;= OrderStatusEnum.OUT_STOCK.getCode()) {
            throw new OrderBizException(OrderErrorCodeEnum.CURRENT_ORDER_STATUS_CANNOT_CANCEL);
        }

        TransactionMQProducer producer = defaultProducer.getProducer();
        producer.setTransactionListener(new TransactionListener() {
            @Override
            public LocalTransactionState executeLocalTransaction(Message message, Object o) {
                try {
                    //2.执行履约取消、更新订单状态、新增订单日志操作
                    afterSaleManager.cancelOrderFulfillmentAndUpdateOrderStatus(cancelOrderAssembleRequest);
                    return LocalTransactionState.COMMIT_MESSAGE;
                } catch (Exception e) {
                    log.error("system error", e);
                    return LocalTransactionState.ROLLBACK_MESSAGE;
                }
            }

            @Override
            public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {
                //查询订单状态是否已更新为"已取消"
                OrderInfoDO orderInfoByDatabase = orderInfoDAO.getByOrderId(orderId);
                if (OrderStatusEnum.CANCELED.getCode().equals(orderInfoByDatabase.getOrderStatus())) {
                    return LocalTransactionState.COMMIT_MESSAGE;
                }
                return LocalTransactionState.ROLLBACK_MESSAGE;
            }
        });

        try {
            Message message = new Message(RocketMqConstant.RELEASE_ASSETS_TOPIC, JSONObject.toJSONString(cancelOrderAssembleRequest).getBytes(StandardCharsets.UTF_8));
            //3.发送事务消息 释放权益资产
            TransactionSendResult result = producer.sendMessageInTransaction(message, cancelOrderAssembleRequest);
            if (!result.getLocalTransactionState().equals(LocalTransactionState.COMMIT_MESSAGE)) {
                throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_PROCESS_FAILED);
            }
            return JsonResult.buildSuccess(true);
        } catch (Exception e) {
            throw new OrderBizException(OrderErrorCodeEnum.SEND_TRANSACTION_MQ_FAILED);
        }
    }
    ...
}</code></pre>
<p data-track="193">&nbsp;</p>
<p data-track="194"><strong>18.释放资产多路MQ故障重试与幂等方案</strong></p>
<p data-track="195">如果发送消息到MQ过程中出现故障，那么就会通过返回RECONSUME_LATER来进行重试。</p>
<p data-track="196">&nbsp;</p>
<p data-track="197">此外，消费消息时调用的接口可能会出现同一请求多次被调用。因此，必须对调用的接口，使用分布式锁 + 状态前置校验进行幂等处理。加分布式锁是为了防止并非请求进来后可能会避开状态的前置校验。</p>
<pre class="highlighter-hljs"><code>@Configuration
public class ConsumerConfig {
    @Autowired
    private RocketMQProperties rocketMQProperties;
    ...

    //释放资产消息消费者
    @Bean("releaseAssetsConsumer")
    public DefaultMQPushConsumer releaseAssetsConsumer(ReleaseAssetsListener releaseAssetsListener) throws MQClientException {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(RELEASE_ASSETS_CONSUMER_GROUP);
        consumer.setNamesrvAddr(rocketMQProperties.getNameServer());
        consumer.subscribe(RELEASE_ASSETS_TOPIC, "*");
        consumer.registerMessageListener(releaseAssetsListener);
        consumer.start();
        return consumer;
    }
}

//监听并消费释放资产消息
@Component
public class ReleaseAssetsListener implements MessageListenerConcurrently {
    @Autowired
    private DefaultProducer defaultProducer;

    @Autowired
    private OrderItemDAO orderItemDAO;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt messageExt : list) {
                //1.消费到释放资产message
                String message = new String(messageExt.getBody());
                log.info("ReleaseAssetsListener message:{}", message);
                CancelOrderAssembleRequest cancelOrderAssembleRequest = JSONObject.parseObject(message, CancelOrderAssembleRequest.class);
                OrderInfoDTO orderInfoDTO = cancelOrderAssembleRequest.getOrderInfoDTO();
                //2.发送取消订单退款请求MQ
                if (orderInfoDTO.getOrderStatus() &gt; OrderStatusEnum.CREATED.getCode()) {
                    defaultProducer.sendMessage(RocketMqConstant.CANCEL_REFUND_REQUEST_TOPIC,
                        JSONObject.toJSONString(cancelOrderAssembleRequest), "取消订单退款");
                }
                //3.发送释放库存MQ
                ReleaseProductStockRequest releaseProductStockRequest = buildReleaseProductStock(orderInfoDTO, orderItemDAO);
                defaultProducer.sendMessage(RocketMqConstant.CANCEL_RELEASE_INVENTORY_TOPIC,
                    JSONObject.toJSONString(releaseProductStockRequest), "取消订单释放库存");
                //4.发送释放优惠券MQ
                if (!Strings.isNullOrEmpty(orderInfoDTO.getCouponId())) {
                    ReleaseUserCouponRequest releaseUserCouponRequest = buildReleaseUserCoupon(orderInfoDTO);
                    defaultProducer.sendMessage(RocketMqConstant.CANCEL_RELEASE_PROPERTY_TOPIC,
                        JSONObject.toJSONString(releaseUserCouponRequest), "取消订单释放优惠券");
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
    ...
}

@Configuration
public class ConsumerConfig {
    @Autowired
    private RocketMQProperties rocketMQProperties;

    //释放优惠券消息消费者
    @Bean("releaseInventoryConsumer")
    public DefaultMQPushConsumer releaseInventoryConsumer(ReleasePropertyListener releasePropertyListener) throws MQClientException {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(RocketMqConstant.RELEASE_PROPERTY_CONSUMER_GROUP);
        consumer.setNamesrvAddr(rocketMQProperties.getNameServer());
        consumer.subscribe(RocketMqConstant.CANCEL_RELEASE_PROPERTY_TOPIC, "*");
        consumer.registerMessageListener(releasePropertyListener);
        consumer.start();
        return consumer;
    }
}

@Component
public class ReleasePropertyListener implements MessageListenerConcurrently {
    @DubboReference(version = "1.0.0")
    private MarketApi marketApi;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt msg : list) {
                String content = new String(msg.getBody(), StandardCharsets.UTF_8);
                log.info("ReleasePropertyConsumer message:{}", content);
                ReleaseUserCouponRequest releaseUserCouponRequest = JSONObject.parseObject(content, ReleaseUserCouponRequest.class);
                //释放优惠券
                JsonResult&lt;Boolean&gt; jsonResult = marketApi.releaseUserCoupon(releaseUserCouponRequest);
                if (!jsonResult.getSuccess()) {
                    throw new MarketBizException(MarketErrorCodeEnum.CONSUME_MQ_FAILED);
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
}

@DubboService(version = "1.0.0", interfaceClass = MarketApi.class, retries = 0)
public class MarketApiImpl implements MarketApi {
    ...
    //回退用户使用的优惠券
    @Override
    public JsonResult&lt;Boolean&gt; releaseUserCoupon(ReleaseUserCouponRequest releaseUserCouponRequest) {
        log.info("开始执行回滚优惠券,couponId:{}", releaseUserCouponRequest.getCouponId());
        //分布式锁
        String couponId = releaseUserCouponRequest.getCouponId();
        String key = RedisLockKeyConstants.RELEASE_COUPON_KEY + couponId;
        boolean lock = redisLock.lock(key);
        if (!lock) {
            throw new MarketBizException(MarketErrorCodeEnum.RELEASE_COUPON_FAILED);
        }
        try {
            //执行释放优惠券
            Boolean result = couponService.releaseUserCoupon(releaseUserCouponRequest);
            return JsonResult.buildSuccess(result);
        } catch (MarketBizException e) {
            log.error("biz error", e);
            return JsonResult.buildError(e.getErrorCode(), e.getErrorMsg());
        } catch (Exception e) {
            log.error("system error", e);
            return JsonResult.buildError(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
    }
    ...
}

@Service
public class CouponServiceImpl implements CouponService {
    ...
    //释放用户优惠券
    @Override
    public Boolean releaseUserCoupon(ReleaseUserCouponRequest releaseUserCouponRequest) {
        String userId = releaseUserCouponRequest.getUserId();
        String couponId = releaseUserCouponRequest.getCouponId();
        CouponDO couponAchieve = couponDAO.getUserCoupon(userId, couponId);
        if (CouponUsedStatusEnum.UN_USED.getCode().equals(couponAchieve.getUsed())) {
            log.info("当前用户未使用优惠券,不用回退,userId:{},couponId:{}", userId, couponId);
            return true;
        }
        couponAchieve.setUsed(CouponUsedStatusEnum.UN_USED.getCode());
        couponAchieve.setUsedTime(null);
        couponDAO.updateById(couponAchieve);
        return true;
    }
    ...
}</code></pre>
<p data-track="199">&nbsp;</p>
<p data-track="200"><strong>19.双异步支付退款不一致问题分析</strong></p>
<p data-track="201">在退款准备消费者中，如果先写售后记录到数据库，再发退款消息到MQ。如果写入售后记录到数据库成功了，但发送实际退款消息到MQ却失败了，那么此时就会产生数据库与MQ的数据不一致问题。</p>
<p data-track="202">&nbsp;</p>
<p data-track="203">在退款准备消费者中，如果先发退款消息到MQ，再写售后记录到数据库。如果发送退款消息到MQ成功了，但写入售后记录到数据库却失败了，那么同样会产生数据库与MQ的数据不一致问题。</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="862" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/32363f8c7bb945aab455575a893dabc3~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202507101043093CA8EF9F302A50B5613F&amp;x-expires=2147483647&amp;x-signature=3L%2BX84d4XRp4tNxa4lwuqcQKkCI%3D" class="lazyload"></div>
<p data-track="204">此时就可以使用RocketMQ的事务消息机制；</p>
<pre class="highlighter-hljs"><code>@Configuration
public class ConsumerConfig {
    @Autowired
    private RocketMQProperties rocketMQProperties;
    ...

    //消费退款准备请求消息消费者
    @Bean("cancelRefundConsumer")
    public DefaultMQPushConsumer cancelRefundConsumer(CancelRefundListener cancelRefundListener) throws MQClientException {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(RocketMqConstant.REQUEST_CONSUMER_GROUP);
        consumer.setNamesrvAddr(rocketMQProperties.getNameServer());
        consumer.subscribe(RocketMqConstant.CANCEL_REFUND_REQUEST_TOPIC, "*");
        consumer.registerMessageListener(cancelRefundListener);
        consumer.start();
        return consumer;
    }
    ...
}

//消费退款准备请求消息
@Component
public class CancelRefundListener implements MessageListenerConcurrently {
    @Autowired
    private OrderAfterSaleService orderAfterSaleService;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt messageExt : list) {
                String message = new String(messageExt.getBody());
                CancelOrderAssembleRequest cancelOrderAssembleRequest = JSONObject.parseObject(message, CancelOrderAssembleRequest.class);
                log.info("CancelRefundConsumer message:{}", message);
                //执行 取消订单/超时未支付取消 前的操作
                JsonResult&lt;Boolean&gt; jsonResult = orderAfterSaleService.processCancelOrder(cancelOrderAssembleRequest);
                if (!jsonResult.getSuccess()) {
                    throw new OrderBizException(OrderErrorCodeEnum.CONSUME_MQ_FAILED);
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
}

@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    @Override
    public JsonResult&lt;Boolean&gt; processCancelOrder(CancelOrderAssembleRequest cancelOrderAssembleRequest) {
        String orderId = cancelOrderAssembleRequest.getOrderId();
        //分布式锁
        String key = RedisLockKeyConstants.REFUND_KEY + orderId;
        try {
            boolean lock = redisLock.lock(key);
            if (!lock) {
                throw new OrderBizException(OrderErrorCodeEnum.PROCESS_REFUND_REPEAT);
            }

            //执行退款前的准备工作
            //生成售后订单号
            OrderInfoDTO orderInfoDTO = cancelOrderAssembleRequest.getOrderInfoDTO();
            OrderInfoDO orderInfoDO = orderInfoDTO.clone(OrderInfoDO.class);
            String afterSaleId = orderNoManager.genOrderId(OrderNoTypeEnum.AFTER_SALE.getCode(), orderInfoDO.getUserId());

            //1.计算 取消订单 退款金额
            CancelOrderRefundAmountDTO cancelOrderRefundAmountDTO = calculatingCancelOrderRefundAmount(cancelOrderAssembleRequest);
            cancelOrderAssembleRequest.setCancelOrderRefundAmountDTO(cancelOrderRefundAmountDTO);
            TransactionMQProducer producer = defaultProducer.getProducer();
            producer.setTransactionListener(new TransactionListener() {
                @Override
                public LocalTransactionState executeLocalTransaction(Message message, Object o) {
                    try {
                        //2.取消订单操作 记录售后信息
                        afterSaleManager.insertCancelOrderAfterSale(cancelOrderAssembleRequest, AfterSaleStatusEnum.REVIEW_PASS.getCode(), orderInfoDO, afterSaleId);
                        return LocalTransactionState.COMMIT_MESSAGE;
                    } catch (Exception e) {
                        log.error("system error", e);
                        return LocalTransactionState.ROLLBACK_MESSAGE;
                    }
                }

                @Override
                public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {
                    //查询售后数据是否插入成功
                    AfterSaleInfoDO afterSaleInfoDO = afterSaleInfoDAO.getOneByAfterSaleId(Long.valueOf(afterSaleId));
                    List&lt;AfterSaleItemDO&gt; afterSaleItemDOList = afterSaleItemDAO.listByAfterSaleId(Long.valueOf(afterSaleId));
                    List&lt;AfterSaleLogDO&gt; afterSaleLogDOList = afterSaleLogDAO.listByAfterSaleId(Long.valueOf(afterSaleId));
                    List&lt;AfterSaleRefundDO&gt; afterSaleRefundDOList = afterSaleRefundDAO.listByAfterSaleId(Long.valueOf(afterSaleId));
                    if (afterSaleInfoDO != null &amp;&amp; afterSaleItemDOList.isEmpty() &amp;&amp; afterSaleLogDOList.isEmpty() &amp;&amp; afterSaleRefundDOList.isEmpty()) {
                        return LocalTransactionState.COMMIT_MESSAGE;
                    }
                    return LocalTransactionState.ROLLBACK_MESSAGE;
                }
            });

            try {
                //3.组装事务MQ消息
                ActualRefundMessage actualRefundMessage = new ActualRefundMessage();
                actualRefundMessage.setOrderId(cancelOrderAssembleRequest.getOrderId());
                actualRefundMessage.setLastReturnGoods(cancelOrderAssembleRequest.isLastReturnGoods());
                actualRefundMessage.setAfterSaleId(Long.valueOf(afterSaleId));
                Message message = new Message(RocketMqConstant.ACTUAL_REFUND_TOPIC, JSONObject.toJSONString(actualRefundMessage).getBytes(StandardCharsets.UTF_8));
                //4.发送事务MQ消息--实际退款消息
                TransactionSendResult result = producer.sendMessageInTransaction(message, actualRefundMessage);
                if (!result.getLocalTransactionState().equals(LocalTransactionState.COMMIT_MESSAGE)) {
                    throw new OrderBizException(OrderErrorCodeEnum.PROCESS_REFUND_FAILED);
                }
                return JsonResult.buildSuccess(true);
            } catch (Exception e) {
                throw new OrderBizException(OrderErrorCodeEnum.SEND_TRANSACTION_MQ_FAILED);
            }
        } finally {
            redisLock.unlock(key);
        }
    }
    ...
}</code></pre>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-10 10:48">2025-07-10 10:48</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">150</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18976429);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18976429', targetLink: 'https://www.cnblogs.com/mjunz/p/18976429', title: '订单初版—4.取消订单链路中的技术问题说明文档' })">举报</a>
</div>
        