
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/johnnyzen/p/18949896" title="发布于 2025-06-26 14:10">
    <span role="heading" aria-level="2">[Java/字节流/BytesReader] 核心源码精讲: ByteArrayInputStream(字节数组输入流，JDK 1.0-)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="序">序</h1>
<ul>
<li>在物联网领域、通信领域，时常涉及直接从二进制字节数据中读取指定区域的字节数据，完成通信协议报文的解析/反序列化等操作。</li>
</ul>
<blockquote>
<p>直接读取字节数据，能节约诸多资源、提高程序处理性能。<br>
而Java idk io模块内自带的 ByteArrayInputStream 是一个很好的<strong>字节流处理</strong>组件。(本文聚焦的对象)</p>
</blockquote>
<ul>
<li>
<p>最近半年，笔者约摸70-80％的时间都花在了研究、设计、处理【端云通信协议】及其二进制报文数据。<br>
此篇，是用到jdk中的一个较为底层的组件。感兴趣的朋友可以阅读一二。</p>
</li>
<li>
<p>也推荐阅读: java io模块的<strong>字符流处理</strong>组件 StringReader。</p>
</li>
</ul>
<blockquote>
<p>(参见文末的推荐阅读文献)</p>
</blockquote>
<h1 id="概述--bytearrayinputstream字节数组输入流">概述 : ByteArrayInputStream(字节数组输入流)</h1>
<h2 id="简介">简介</h2>
<ul>
<li><strong>字节数组输入流</strong>在内存中创建一个<strong>字节数组缓冲区</strong>，从<strong>输入流</strong>读取的数据保存在该<strong>字节数组缓冲区</strong>中。</li>
</ul>
<blockquote>
<ul>
<li><code>java.io.ByteArrayInputStream</code> : 自 JDK 1.0 起即有此类</li>
</ul>
</blockquote>
<h2 id="创建对象的方式">创建对象的方式</h2>
<blockquote>
<p>创建字节数组输入流对象有以下几种方式。</p>
</blockquote>
<ul>
<li>方式1 接收字节数组作为参数创建：</li>
</ul>
<pre><code class="language-java">ByteArrayInputStream bArray = new ByteArrayInputStream(byte [] a);
</code></pre>
<ul>
<li>方式2 接收一个字节数组，和两个整形变量 off、len，off表示第一个读取的字节，len表示读取字节的长度。</li>
</ul>
<pre><code class="language-java">ByteArrayInputStream bArray = new ByteArrayInputStream(byte []a, int off, int len)
</code></pre>
<p>成功创建<strong>字节数组输入流对象</strong>后，可以参见以下列表中的方法，对流进行读操作或其他操作。</p>
<h2 id="常用api">常用API</h2>
<table>
<thead>
<tr>
<th style="text-align: left">序号</th>
<th style="text-align: left">方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">1</td>
<td style="text-align: left"><strong>public int read()</strong>     从此输入流中读取下一个数据字节。</td>
</tr>
<tr>
<td style="text-align: left">2</td>
<td style="text-align: left"><strong>public int read(byte[] r, int off, int len)</strong> 将最多 <code>len</code> 个数据字节从此输入流读入字节数组。</td>
</tr>
<tr>
<td style="text-align: left">3</td>
<td style="text-align: left"><strong>public int available()</strong> 返回可不发生阻塞地从此输入流读取的字节数。</td>
</tr>
<tr>
<td style="text-align: left">4</td>
<td style="text-align: left"><strong>public void mark(int read)</strong> 设置流中的当前标记位置。</td>
</tr>
<tr>
<td style="text-align: left">5</td>
<td style="text-align: left"><strong>public long skip(long n)</strong> 从此输入流中跳过 <code>n</code> 个输入字节。</td>
</tr>
</tbody>
</table>
<h2 id="示例">示例</h2>
<blockquote>
<p>下面的例子演示了ByteArrayInputStream 和 ByteArrayOutputStream的使用：</p>
</blockquote>
<pre><code class="language-java">import java.io.*;

public class ByteStreamTest {

   public static void main(String args[])throws IOException {

      ByteArrayOutputStream bOutput = new ByteArrayOutputStream(12);

      while( bOutput.size()!= 10 ) {
         // 获取用户输入值
         bOutput.write(System.in.read());
      }

      byte b [] = bOutput.toByteArray();
      System.out.println("Print the content");
      for(int x= 0 ; x &lt; b.length; x++) {
         // 打印字符
         System.out.print((char)b[x]  + "   ");
      }
      System.out.println("   ");

      int c;

      ByteArrayInputStream bInput = new ByteArrayInputStream(b);

      System.out.println("Converting characters to Upper case " );
      for(int y = 0 ; y &lt; 1; y++ ) {
         while(( c= bInput.read())!= -1) {
            System.out.println(Character.toUpperCase((char)c));
         }
         bInput.reset();
      }
   }
}
</code></pre>
<blockquote>
<p>out</p>
</blockquote>
<pre><code class="language-log">asdfghjkly
Print the content
a   s   d   f   g   h   j   k   l   y
Converting characters to Upper case
A
S
D
F
G
H
J
K
L
Y
</code></pre>
<h1 id="最佳实践">最佳实践</h1>
<h2 id="基于封装-bytearrayinputstream-的-bytesreader">基于封装 ByteArrayInputStream 的 <code>BytesReader</code></h2>
<h3 id="bytesreader">BytesReader</h3>
<pre><code class="language-java">import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import sun.misc.Unsafe;

import java.io.*;
import java.lang.reflect.Field;
import java.util.Map;

/**
 * 以字节数据为源的读取器
 * @note 核心原理: 基于字节流工具类 {@link ByteArrayInputStream } 读取字节数据
 * @updateTime 2025.6.26 13:50
 */
@Slf4j
public class BytesReader {
    private ByteArrayInputStream byteArrayInputStream;

    public BytesReader(byte [] bytes) {
        this.byteArrayInputStream = new ByteArrayInputStream(bytes);
    }

    public BytesReader(byte [] bytes, int offset, int length) {
        this.byteArrayInputStream = new ByteArrayInputStream(bytes, offset, length);
    }

    public int read(){
        return this.byteArrayInputStream.read();
    }

    /**
     * 读取1个字节
     * @return
     */
    public byte readByte(){
        int byteSize = 1;
        byte [] targetBuffer = new byte[byteSize];
        int off = 0;//目标字节数组的起始位置
        int readSize = read(targetBuffer, off, byteSize);
        if(log.isDebugEnabled()){
            log.debug("off:{}, readSize:{}", off, readSize);
        }
        return targetBuffer[0];
    }

    public Map.Entry&lt;Integer, byte[]&gt; readBytes(int length){
        byte [] destinationBuffer = new byte[ length];
        int destinationBufferOffset = 0;
        int destinationBufferLength = destinationBuffer.length;
        int actualLength = this.byteArrayInputStream.readNBytes(destinationBuffer, destinationBufferOffset, destinationBufferLength);

        final Map.Entry&lt;Integer, byte[]&gt; result = new Map.Entry&lt;Integer, byte[]&gt;() {
            @Override
            public Integer getKey() {
                return actualLength;
            }

            @Override
            public byte[] getValue() {
                return destinationBuffer;
            }

            @Override
            public byte[] setValue(byte[] value) {
                throw new RuntimeException("Not support set value method!");
            }
        };
        return result;
    }

    /**
     * 从指定的位置读取最多 length 个字节数据，并存放到 targetBuffer 中
     * @param destinationBuffer 目标字节数组
     * @param destinationBufferOffset 目标字节数组的起始位置 （容易理解错误，多注意）
     * @param length 要读取的字节数
     * @return
     */
    public int read(byte destinationBuffer[], int destinationBufferOffset, int length){
        return this.byteArrayInputStream.readNBytes(destinationBuffer, destinationBufferOffset, length);
    }
    public int read(byte destinationBuffer[], int length){
        int destinationBufferOffset = 0;
        return this.byteArrayInputStream.readNBytes(destinationBuffer, destinationBufferOffset, length);
    }
    public int read(byte destinationBuffer[]){
        int destinationBufferOffset = 0;
        int destinationBufferLength = destinationBuffer.length;
        return this.byteArrayInputStream.readNBytes(destinationBuffer, destinationBufferOffset, destinationBufferLength);
    }

    public long skip(int length){
        return byteArrayInputStream.skip(length);
    }

    /**
     * 获取下一字节的位置
     * @description
     *  1. 利用反射原理，将 java.io.ByteArrayInputStream 的 private 属性 pos 读取出来
     *  2. 不建议高频调用 (影响调用程序的性能)
     * @return
     */
    @SneakyThrows
    public int next(){
        int next = Integer.MIN_VALUE; //读取失败时，以此值为标志
        //反射方法1 : Java 17 中需结合 VM Option 参数 : `--add-opens java.base/java.io=ALL-UNNAMED`
        //java.lang.reflect.Field field = java.io.ByteArrayInputStream.class.getDeclaredField("pos");
        //field.setAccessible(true);
        //next = field.getInt( this );//读取 next 的值
        ////field.set(this, Integer.MIN_VALUE);//设置字段的值

        //反射方法2: 基于 Unsafe
        Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");
        unsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafeField.get(null);
        // 获取私有字段的偏移量
        Field nextField = ByteArrayInputStream.class.getDeclaredField("pos");
        long offset = unsafe.objectFieldOffset(nextField);
        next = unsafe.getInt(this.byteArrayInputStream, offset);
        //unsafe.putInt(byteArrayInputStream, offset, 10);// 设置字段值

        return next;//next : 下标从 0 开始; 即将读取的下一个 char 的下标位置
    }

    public Boolean hasNext(){
        return byteArrayInputStream.available() &gt; 0;
    }
}
</code></pre>
<h3 id="demo">Demo</h3>
<pre><code class="language-java">
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;

import java.util.Map;

@Slf4j
public class BytesReaderTest {
    /**
     * 读取字节数据
     */
    @Test
    public void readBytesTest(){
        byte bytes [] = new byte [] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16 };
        BytesReader bytesReader = new BytesReader(bytes);
        int offset = 0;
        while (bytesReader.hasNext()) {
            try {
                offset = bytesReader.next();
                //log.info("bytes[{}] : 0x{}", offset,  BytesUtils.byteToHexString( bytesReader.readByte() ) );//每次读取1个字节

                int readSize = 3;//每次读取的字节数
                Map.Entry&lt;Integer, byte[]&gt; readResult = bytesReader.readBytes(readSize);
                int actualLength = readResult.getKey();
                byte [] readBytes = readResult.getValue();
                log.info("bytes[offset={}] : 0x{}, actualLength:{}", offset,  BytesUtils.bytesToHexString( readBytes ), actualLength );//eg: "bytes[offset=0] : 0x010203, actualLength:3" , "bytes[offset=15] : 0x160000, actualLength:1"
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<blockquote>
<p>out</p>
</blockquote>
<pre><code class="language-log">[2025/06/26 14:12:54.921] [INFO ] [main] [com.xxx.sdk.utils.bytes.BytesReaderTest                     :27 readBytesTest] bytes[offset=0] : 0x010203, actualLength:3
[2025/06/26 14:12:54.927] [INFO ] [main] [com.xxx.sdk.utils.bytes.BytesReaderTest                     :27 readBytesTest] bytes[offset=3] : 0x040506, actualLength:3
[2025/06/26 14:12:54.928] [INFO ] [main] [com.xxx.sdk.utils.bytes.BytesReaderTest                     :27 readBytesTest] bytes[offset=6] : 0x070809, actualLength:3
[2025/06/26 14:12:54.929] [INFO ] [main] [com.xxx.sdk.utils.bytes.BytesReaderTest                     :27 readBytesTest] bytes[offset=9] : 0x101112, actualLength:3
[2025/06/26 14:12:54.929] [INFO ] [main] [com.xxx.sdk.utils.bytes.BytesReaderTest                     :27 readBytesTest] bytes[offset=12] : 0x131415, actualLength:3
[2025/06/26 14:12:54.930] [INFO ] [main] [com.xxx.sdk.utils.bytes.BytesReaderTest                     :27 readBytesTest] bytes[offset=15] : 0x160000, actualLength:1
</code></pre>
<h1 id="y-推荐文献">Y 推荐文献</h1>
<ul>
<li><a href="https://www.cnblogs.com/johnnyzen/p/18858582" target="_blank">[Java/HexStringReader] 核心源码精讲：java.io.StringReader类(JDK1.1-) - 博客园/千千寰宇</a></li>
<li><a href="https://www.cnblogs.com/johnnyzen/p/18293230" target="_blank">[Java SE] 基础工具类：ByteUtils(字节操作) - 博客园/千千寰宇</a></li>
</ul>
<h1 id="x-参考文献">X 参考文献</h1>
<ul>
<li><a href="https://www.runoob.com/java/java-bytearrayinputstream.html" target="_blank" rel="noopener nofollow">Java ByteArrayInputStream类 - 菜鸟教程</a></li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <div class="essaySuffix-box">
    <div class="essaySuffix-box-left" style=" margin: 6px auto; ">
        <img src="https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148" alt="QQ沟通交流群" onload="changeImg(this,200,100)">
    </div>
<div class="essaySuffix-box-right">
    <span class="essaySuffix-right-title">本文作者</span>：
        <strong><span><a href="https://github.com/Johnny-ZTSD" target="_blank">千千寰宇</a></span></strong>
    <br>
    <span style="font-weight: bold; white-space:nowrap;">本文链接</span>：
        <a href="https://www.cnblogs.com/johnnyzen" target="_blank" id="articleLinkElement"> https://www.cnblogs.com/johnnyzen</a>
    <br>
    <span class="essaySuffix-right-title">关于博文</span>：评论和私信会在第一时间回复，或<a href="https://msg.cnblogs.com/msg/send/johnnyzen" target="_blank">直接私信</a>我。
    <br>
    <span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a title="https://creativecommons.org/licenses/by-nc-nd/4.0/" href="http://blog.sina.com.cn/s/blog_896327b90102y6c6.html" alt="BY-NC-SA" target="_blank">BY-NC-SA</a> 
    许可协议。转载请注明出处！<br>
    <span class="essaySuffix-right-title">日常交流</span>：大数据与软件开发-QQ交流群: 774386015<strong>
        <span style="color: #ff0000; font-size: 12pt;">【<a id="post-up" onclick="votePost(getArticleNumber(),'Digg')" href="javascript:void(0);">入群二维码</a>】</span></strong>参见左下角。您的支持、鼓励<span style="color: #ff0000; font-size: 12pt;"></span>是博主技术写作的重要动力！
    <br>
</div>
<div style="clear: both;">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3298611111111111" data-date-updated="2025-06-26 22:05">2025-06-26 14:10</span>&nbsp;
<a href="https://www.cnblogs.com/johnnyzen">千千寰宇</a>&nbsp;
阅读(<span id="post_view_count">69</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18949896);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18949896', targetLink: 'https://www.cnblogs.com/johnnyzen/p/18949896', title: '[Java/字节流/BytesReader] 核心源码精讲: ByteArrayInputStream(字节数组输入流，JDK 1.0-)' })">举报</a>
</div>
        