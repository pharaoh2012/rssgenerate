
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mingupupu/p/19039195" title="发布于 2025-08-15 10:57">
    <span role="heading" aria-level="2">WPF Stylet可以如何实现导航功能？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250815105635276-1298300439.png" class="lazyload"></p>
<h2 id="前言">前言</h2>
<p>本文是学习Stylet中导航Demo的总结，希望对你有所帮助。</p>
<p>Demo所在的位置：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250815105635177-1377207930.png" class="lazyload"></p>
<p>先看一下导航的效果：</p>
<p>首页</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250815105635238-1211092723.png" class="lazyload"></p>
<p>通过上面导航到Page 2：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250815105635279-1001969600.png" class="lazyload"></p>
<p>通过Page1导航到Page2：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250815105635202-2095102836.png" class="lazyload"></p>
<h2 id="stylet是如何实现导航的">Stylet是如何实现导航的？</h2>
<p>先来看一下页面布局：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250815105635136-1492359097.png" class="lazyload"></p>
<p>一共有ShellView、HeaderView、Page1View与Page2View一共四个View。</p>
<p>ShellView的xaml如下：</p>
<pre><code class="language-xaml">&lt;Window x:Class="Stylet.Samples.NavigationController.Pages.ShellView"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:Stylet.Samples.NavigationController.Pages"
        mc:Ignorable="d"
        Title="Navigation Controller sample" Height="450" Width="800"
        xmlns:s="https://github.com/canton7/Stylet"
        d:DataContext="{d:DesignInstance local:ShellViewModel}"&gt;
    &lt;DockPanel&gt;
        &lt;ContentControl DockPanel.Dock="Top" s:View.Model="{Binding HeaderViewModel}"/&gt;
        &lt;ContentControl s:View.Model="{Binding ActiveItem}"/&gt;
    &lt;/DockPanel&gt;
&lt;/Window&gt;
</code></pre>
<p>页面的上部分通过<code>s:View.Model="{Binding HeaderViewModel}"</code>绑定到了HearView。</p>
<p>下部分通过<code>s:View.Model="{Binding ActiveItem}"</code>绑定到了激活项的View。</p>
<p>这里你可能会感到疑惑，ActiveItem这个属性是哪里来的呢？</p>
<p>ActiveItem这个属性是在<code>ConductorBaseWithActiveItem&lt;T&gt;</code>中定义的：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250815105635264-2111854321.png" class="lazyload"></p>
<p><code>ShellViewModel</code>继承<code> Conductor&lt;IScreen&gt;</code>，<code> Conductor&lt;IScreen&gt;</code>继承<code> ConductorBaseWithActiveItem&lt;T&gt;</code>。</p>
<p>这里你就把ActiveItem理解成导航激活的那个ViewModel就行了，这个例子中要么是Page1ViewModel要么就是Page2ViewModel。</p>
<p>现在来看一下NavigationController：</p>
<pre><code class="language-csharp">public class NavigationController : INavigationController
{
    private readonly Func&lt;Page1ViewModel&gt; page1ViewModelFactory;
    private readonly Func&lt;Page2ViewModel&gt; page2ViewModelFactory;

    public INavigationControllerDelegate Delegate { get; set; }

    public NavigationController(Func&lt;Page1ViewModel&gt; page1ViewModelFactory, Func&lt;Page2ViewModel&gt; page2ViewModelFactory)
    {
        this.page1ViewModelFactory = page1ViewModelFactory ?? throw new ArgumentNullException(nameof(page1ViewModelFactory));
        this.page2ViewModelFactory = page2ViewModelFactory ?? throw new ArgumentNullException(nameof(page2ViewModelFactory));
    }

    public void NavigateToPage1()
    {
        this.Delegate?.NavigateTo(this.page1ViewModelFactory());
    }

    public void NavigateToPage2(string initiator)
    {
        Page2ViewModel vm = this.page2ViewModelFactory();
        vm.Initiator = initiator;
        this.Delegate?.NavigateTo(vm);
    }
}
</code></pre>
<p>看一下INavigationController：</p>
<pre><code class="language-csharp">public interface INavigationController
{
    void NavigateToPage1();
    void NavigateToPage2(string initiator);
}
</code></pre>
<p>首先解决一个疑问，这里为什么使用<code>private readonly Func&lt;Page1ViewModel&gt; page1ViewModelFactory;</code>而不是直接使用<code>Page1ViewModel</code>呢？</p>
<p>我们知道在C#中<code>Func&lt;Page1ViewModel&gt;</code>表示一个没有参数，返回值为Page1ViewModel的委托。</p>
<p>再看看Bootstrapper中的ConfigureIoC方法：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250815105635243-1589929219.png" class="lazyload"></p>
<p>这样写的目的就是不是一开始就将Page1ViewModel与Page2ViewModel注入进来，而是在使用的时候才注入进来。</p>
<p>我们发现在NavigationController中具体实现导航是通过<code>INavigationControllerDelegate</code>接口实现的，让我们再来看看这个接口：</p>
<pre><code class="language-csharp">public interface INavigationControllerDelegate
{
    void NavigateTo(IScreen screen);
}
</code></pre>
<p>回到ShellViewModel，我们发现它实现了这个接口。</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250815105635216-1929211076.png" class="lazyload"></p>
<p>来看下它的实现：</p>
<pre><code class="language-csharp"> public void NavigateTo(IScreen screen)
 {
     this.ActivateItem(screen);
 }
</code></pre>
<p>使用的是 <code>Conductor&lt;T&gt;</code>中的<code>ActivateItem</code>方法：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250815105635120-878724671.png" class="lazyload"></p>
<p>当我们从页面1导航到页面2时：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250815105635241-542610924.png" class="lazyload"></p>
<p>由于要导航去的Page2ViewModel不是当前的激活项Page1ViewModel，就会来到<code>ChangeActiveItem</code>方法：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250815105635159-1631744560.png" class="lazyload"></p>
<p>关闭之前的激活项，设置新的激活项。</p>
<p>就成功导航到Page2ViewModel了，然后根据Page2ViewModel就会找到Page2View了，这样就成功实现导航功能了。</p>
<p>最后再来看一下有一个循环依赖问题：</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3288240/202508/3288240-20250815105635197-1079612842.png" class="lazyload"></p>
<p>这里存在一个循环依赖关系：ShellViewModel -&gt; HeaderViewModel -&gt; NavigationController -&gt; ShellViewModel。</p>
<p>如果直接在NavigationController的构造函数中注入ShellViewModel就会引发这个循环依赖问题。</p>
<p>作者通过在构建 NavigationController 后，再将 ShellViewModel 赋值给它的方式来打破这一循环依赖。</p>
<h2 id="最后">最后</h2>
<p>Stylet导航功能的实现主要是通过<code>Conductor&lt;T&gt;</code>实现的。</p>
<p>从作者的这个示例中学习了如何使用Stylet实现一个导航应用，还是学习到了很多知识的，感谢作者的付出！！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-15 10:57">2025-08-15 10:57</span>&nbsp;
<a href="https://www.cnblogs.com/mingupupu">mingupupup</a>&nbsp;
阅读(<span id="post_view_count">181</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19039195);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19039195', targetLink: 'https://www.cnblogs.com/mingupupu/p/19039195', title: 'WPF Stylet可以如何实现导航功能？' })">举报</a>
</div>
        