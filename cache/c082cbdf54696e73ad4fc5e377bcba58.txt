
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/seven97-top/p/18805538" title="发布于 2025-04-03 08:15">
    <span role="heading" aria-level="2">【Guava】IO工具</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="引言">引言</h2>
<p>Guava 使用术语 <strong>流</strong>来表示可关闭的，并且在底层资源中有位置状态的 I/O 数据流。字节流对应的工具类为 ByteSterams，字符流对应的工具类为 CharStreams。<br>
Guava 中为了避免和流直接打交道，抽象出可读的 <strong>源 source</strong> 和可写的 <strong>汇 sink</strong> 两个概念，指可以从中打开流的资源，比如 File、URL，同样也分别有字节和字符对应的源和汇，定义了一系列读写的方法。</p>
<p>Guava IO 极大简化了文件和流的操作。比如说，读写文件这种看似简单的操作，在Java原生代码中可能要写好几行，还不包括错误处理。Guava则可以用一两行搞定，简洁到让人惊叹。其次，它还提供了更丰富的功能，比如对不同字符集的处理，还有资源的高效管理。这些都是在开发过程中经常遇到的问题，Guava给了我们优雅的解决方案。</p>
<p>来看个简单的例子，比如说读取一个文本文件的内容。在Java原生代码中，可能得这么写：</p>
<pre><code class="language-java">try (BufferedReader br = new BufferedReader(new FileReader("example.txt"))) {
    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre>
<p>但是用Guava，就可以变得超级简单：</p>
<pre><code class="language-java">List&lt;String&gt; lines = Files.asCharSource(new File("example.txt"), Charsets.UTF_8).readLines();
lines.forEach(System.out::println);
</code></pre>
<p>看到区别了吧？Guava的代码不仅更短，而且可读性也强很多。而且，Guava还考虑了很多细节，比如字符集处理，在这里用的是<code>Charsets.UTF_8</code>，这在处理有不同编码的文件时特别有用。</p>
<h2 id="文件操作简化">文件操作简化</h2>
<p>在Java的世界里，文件操作是个老生常谈的话题。传统的Java I/O操作，虽然功能强大，但代码写起来往往既长又复杂，但是，有了Guava，这一切都变得轻松多了。</p>
<h3 id="读取文件">读取文件</h3>
<p>读取文件场景中，在Java原生方法里，可能需要创建<code>FileReader</code>，然后再包装成<code>BufferedReader</code>，最后一行一行地读。但在Guava中，只需要几行代码，就能搞定。</p>
<p>看这个例子：</p>
<pre><code class="language-java">// 使用Guava读取文件
File file = new File("example.txt");
List&lt;String&gt; lines = Files.asCharSource(file, Charsets.UTF_8).readLines();
for (String line : lines) {
    System.out.println(line);
}
</code></pre>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202407171502823.png" alt="" loading="lazy"></p>
<p>在这段代码里，<code>Files.asCharSource</code>方法创建了一个字符源（CharSource），这样就可以直接读取文件中的内容了。再也不用担心<code>FileNotFoundException</code>和<code>IOException</code>这些让人头疼的异常了，Guava都处理好了一切。</p>
<h3 id="写入文件">写入文件</h3>
<p>在传统的Java I/O中，写文件也是一大堆代码，需要处理流的打开和关闭，还得小心处理异常。但在Guava中，这也变得超级简单：</p>
<pre><code class="language-java">// 使用Guava写入文件
List&lt;String&gt; content = Arrays.asList("Line 1", "Line 2", "Line 3");
File file = new File("example-write.txt");
Files.asCharSink(file, Charsets.UTF_8).writeLines(content);
</code></pre>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202407171502063.png" alt="img" loading="lazy"></p>
<p>在这里，<code>Files.asCharSink</code>创建了一个字符汇（CharSink），它能轻松写入数据到文件中。这些代码不仅简洁，而且易于理解和维护。</p>
<h3 id="复制和移动文件">复制和移动文件</h3>
<p>但Guava的魔法不止于此。想要复制或者移动文件？也是分分钟的事情。看看这个：</p>
<pre><code class="language-java">// 复制文件
File original = new File("source.txt");
File copy = new File("destination.txt");
Files.copy(original, copy);

// 移动文件
File toMove = new File("toMove.txt");
File destination = new File("moved.txt");
Files.move(toMove, destination);
</code></pre>
<h2 id="流处理与转换">流处理与转换</h2>
<p>在Java中，流（Streams）是处理数据的核心，不论是文件I/O还是网络通信，流都扮演着至关重要的角色。但有时候，处理Java原生的InputStream和OutputStream会让人觉得有点小复杂。幸好，Guava在这方面提供了非常便捷的工具，让流处理变得既简单又高效。</p>
<h3 id="简化的流读取">简化的流读取</h3>
<p>在传统的Java I/O中，从InputStream读取数据通常需要创建一个buffer，然后一点点读取。但用Guava，整个过程就变得异常简单：</p>
<pre><code class="language-java">// 使用Guava从InputStream读取字符串
InputStream input = new FileInputStream("example.txt");
String text = CharStreams.toString(new InputStreamReader(input, Charsets.UTF_8));
input.close();
</code></pre>
<p>在这里，<code>CharStreams.toString</code>方法直接将整个InputStream转换为字符串。再也不需要手动创建buffer和循环读取了，一行代码就搞定。</p>
<h3 id="流的转换和处理">流的转换和处理</h3>
<p>有时候，需要对流中的数据进行某种形式的处理或转换。Guava在这方面也提供了很大的帮助。看看这个例子：</p>
<pre><code class="language-java">// 使用Guava对InputStream进行转换
InputStream input = new FileInputStream("example.txt");
FluentIterable&lt;String&gt; lines = 
    CharStreams.readLines(new InputStreamReader(input, Charsets.UTF_8))
               .transform(line -&gt; line.toUpperCase()); // 将每一行都转换为大写
input.close();
</code></pre>
<p>在这个例子中，<code>CharStreams.readLines</code>方法读取了所有行，并且通过<code>transform</code>方法对每一行进行了转换，这里是将其转换为大写。Guava的流式处理风格让这种转换变得非常优雅。</p>
<h3 id="高效的流拷贝">高效的流拷贝</h3>
<p>在Java中，从一个流拷贝数据到另一个流通常需要手动创建buffer，并循环进行读写。但在Guava中，这也变得简单多了：</p>
<pre><code class="language-java">// 使用Guava进行流拷贝
InputStream input = new FileInputStream("source.txt");
OutputStream output = new FileOutputStream("dest.txt");
ByteStreams.copy(input, output); // 将数据从input流拷贝到output流
input.close();
output.close();
</code></pre>
<p>在这个例子中，<code>ByteStreams.copy</code>方法就直接完成了从一个流到另一个流的数据拷贝。Guava把复杂的操作隐藏在了简洁的API背后，大大降低了编码的复杂性。</p>
<h2 id="字符集与编码处理">字符集与编码处理</h2>
<p>在Java世界里，字符集和编码经常会让人头疼，特别是当处理不同来源的数据时，比如从不同的文件或网络。字符编码问题能让一个简单的任务变得异常复杂。但别担心，Guava来帮忙了！</p>
<h3 id="字符编码的挑战">字符编码的挑战</h3>
<p>在Java中，处理不同编码的文本，尤其是在I/O操作中，经常会遇到<code>UnsupportedEncodingException</code>。这是因为不同的系统和文本文件可能使用不同的字符编码。比如，Windows可能默认使用CP1252，而Linux可能使用UTF-8。如果不正确处理这些编码，就会导致乱码或者错误。</p>
<h3 id="guava的charsets">Guava的Charsets</h3>
<p>Guava提供了一套字符集（Charsets）工具，让处理这些问题变得简单。Guava定义了所有标准的Java字符集，这样咱们就不必手动处理那些繁琐的字符串了。比如，当需要转换字节数据到字符串，或者相反的操作时，Guava的Charsets就派上用场了。</p>
<p>看看下面这个例子：</p>
<pre><code class="language-java">// 使用Guava的Charsets处理字符串
String example = "这是一个测试字符串";
byte[] bytes = example.getBytes(Charsets.UTF_8); // 将字符串转换为UTF-8编码的字节
String decoded = new String(bytes, Charsets.UTF_8); // 再将字节解码回字符串
System.out.println(decoded);
</code></pre>
<p>在这段代码里，使用<code>Charsets.UTF_8</code>来确保字符串正确地被编码和解码。Guava的Charsets处理起来既简单又不易出错。</p>
<h3 id="更多字符处理工具">更多字符处理工具</h3>
<p>除了Charsets，Guava还提供了更多字符处理工具。比如，有时咱们需要对字符串中的特定字符进行操作，Guava的<code>CharMatcher</code>类就是专门为此设计的。</p>
<p>来看个例子，假设咱们要从字符串中移除所有数字：</p>
<pre><code class="language-java">// 使用Guava的CharMatcher移除字符串中的数字
String input = "abc123xyz456";
String result = CharMatcher.inRange('0', '9').removeFrom(input);
System.out.println(result); // 输出结果: "abcxyz"
</code></pre>
<p>在这个例子中，<code>CharMatcher.inRange('0', '9')</code>创建了一个匹配所有数字的匹配器，然后<code>removeFrom</code>方法就将这些数字从字符串中移除了。这样的处理不仅代码量少，而且逻辑清晰易懂。</p>
<p>详情可以看这篇文章 <a href="https://www.seven97.top/framework/springboot/guava-string-ints.html" target="_blank" rel="noopener nofollow">String&amp;Ints</a></p>
<h2 id="源source和汇sink模式">源（Source）和汇（Sink）模式</h2>
<p>在处理文件和流的时候，常常需要读数据（Source）和写数据（Sink）。Guava在这方面提供了一套非常优雅的解决方案，让这些操作变得既简单又直观。</p>
<p>在Guava中，Source代表一个数据的来源，可以是文件、URL或者任何其他数据源。而Sink则是数据的目的地，比如文件或者某个输出流。这种抽象的好处是，无论数据来源或去向如何变化，操作逻辑都保持一致。</p>
<h3 id="文件的source和sink">文件的Source和Sink</h3>
<p>先来看看文件操作。在传统的Java I/O中，需要创建FileInputStream或FileOutputStream，然后进行读写操作。但用Guava的Source和Sink，整个过程变得更加清晰。</p>
<p>看这个读文件的例子：</p>
<pre><code class="language-java">// 使用Guava的FileSource读取文件
File file = new File("example.txt");
CharSource charSource = Files.asCharSource(file, Charsets.UTF_8);
String content = charSource.read();
System.out.println(content);
</code></pre>
<p>在这段代码中，<code>Files.asCharSource</code>创建了一个<code>CharSource</code>实例，它代表了文件中的字符数据。<code>charSource.read()</code>方法就能读取整个文件的内容。这样的代码不仅简洁，而且非常容易理解。</p>
<p>再来看看写文件的操作：</p>
<pre><code class="language-java">// 使用Guava的FileSink写入文件
List&lt;String&gt; lines = Arrays.asList("第一行", "第二行", "第三行");
File file = new File("example-write.txt");
CharSink charSink = Files.asCharSink(file, Charsets.UTF_8);
charSink.writeLines(lines);
</code></pre>
<p>这里<code>Files.asCharSink</code>创建了一个<code>CharSink</code>实例，它代表文件的写入点。<code>charSink.writeLines</code>方法可以轻松地将一个字符串列表写入文件。</p>
<h3 id="url的source">URL的Source</h3>
<p>除了文件，Source和Sink还可以用于其他类型的数据源。比如，可以从一个URL读取数据：</p>
<pre><code class="language-java">// 使用Guava的URLSource读取数据
URL url = new URL("http://example.com");
ByteSource byteSource = Resources.asByteSource(url);
byte[] data = byteSource.read();
System.out.println(new String(data, Charsets.UTF_8));
</code></pre>
<p>在这个例子中，<code>Resources.asByteSource</code>创建了一个表示URL数据的<code>ByteSource</code>。然后就可以使用<code>byteSource.read()</code>来读取数据，非常方便。</p>
<h2 id="异常处理与资源管理">异常处理与资源管理</h2>
<p>在Java编程中，正确处理异常和资源是非常重要的，尤其是在进行I/O操作或者处理外部资源时。如果处理不当，很容易造成资源泄露或程序崩溃。Guava在这方面提供了一些非常棒的工具，帮助咱们写出更安全、更可靠的代码。</p>
<h3 id="快速失败preconditions">快速失败：Preconditions</h3>
<p>在开始处理数据之前，检查输入是非常重要的。Guava提供了<code>Preconditions</code>类，帮助咱们快速校验条件，并在条件不满足时立即失败。这种“快速失败”机制有助于尽早发现问题，避免更深层次的错误。</p>
<p>看看这个例子：</p>
<pre><code class="language-java">// 使用Guava的Preconditions进行参数校验
public void processData(String data) {
    Preconditions.checkNotNull(data, "data不能为null");
    // 处理数据
}
</code></pre>
<p>这段代码中，<code>Preconditions.checkNotNull</code>方法确保传入的<code>data</code>不是<code>null</code>。如果是<code>null</code>，它会抛出一个<code>NullPointerException</code>，并附带自定义的错误消息。这样的校验既直观又有效，有助于提高代码的健壮性。</p>
<p>详情可以看这篇文章 <a href="https://www.seven97.top/framework/springboot/guava-string-ints.html" target="_blank" rel="noopener nofollow">String&amp;Ints</a></p>
<h3 id="资源管理closeables和fluentiterable">资源管理：Closeables和FluentIterable</h3>
<p>在Java中，正确管理资源，特别是那些需要关闭的资源，如流或连接，是非常重要的。Guava的<code>Closeables</code>类提供了便捷的方法来关闭这些资源，而不必担心<code>IOException</code>。</p>
<pre><code class="language-java">// 使用Guava的Closeables安全关闭资源
InputStream in = null;
try {
    in = new FileInputStream("example.txt");
    // 使用流
} catch (IOException e) {
    // 异常处理
} finally {
    Closeables.closeQuietly(in); // 安静地关闭流，忽略IOException
}
</code></pre>
<p>在这个例子中，无论在使用流的过程中是否发生异常，<code>Closeables.closeQuietly</code>都会在<code>finally</code>块中安全地关闭流。这样的处理方式不仅简洁，而且可以避免因忘记关闭资源而导致的问题。</p>
<p>Guava的<code>FluentIterable</code>也是资源管理的好帮手。它提供了一种链式的方法来处理集合，使得操作集合变得既简洁又优雅。</p>
<pre><code class="language-java">// 使用Guava的FluentIterable优雅地处理集合
List&lt;String&gt; names = Arrays.asList("Alice", "Bob", "Charlie");
List&lt;String&gt; filtered = FluentIterable.from(names)
                                      .filter(name -&gt; name.startsWith("A"))
                                      .toList();
</code></pre>
<p>在这段代码中，<code>FluentIterable.from</code>创建了一个可迭代的集合视图，<code>filter</code>方法用于过滤，最后<code>toList</code>将结果转换为List。这样的链式调用，不仅代码可读性高，而且易于维护。</p>
<h2 id="guava与java-nio的结合">Guava与Java NIO的结合</h2>
<p>本章我们要聊聊Guava和<a href="https://www.seven97.top/java/io/04-networkprogramming2-nio.html" target="_blank" rel="noopener nofollow">Java NIO（非阻塞I/O）</a>的结合。对于那些需要处理大量数据，或者对性能要求较高的应用来说，Java的NIO库是个非常强大的工具。但是，NIO的API有时候会显得有点复杂。这时候，Guava又一次展示了它的魔力，帮助我们更简单、更优雅地使用NIO。</p>
<h3 id="guava对nio的增强">Guava对NIO的增强</h3>
<p>Guava对Java NIO做了一些增强，让它的使用变得更加友好。Guava提供了类似于<code>ByteSource</code>和<code>ByteSink</code>这样的抽象，使得使用NIO进行文件操作或网络操作更加直观。</p>
<p>来看看这个读取文件内容的例子：</p>
<pre><code class="language-java">// 使用Guava的ByteSource读取文件内容
File file = new File("example.txt");
ByteSource byteSource = Files.asByteSource(file);
byte[] readBytes = byteSource.read();
System.out.println(new String(readBytes, Charsets.UTF_8));
</code></pre>
<p>在这个例子中，<code>Files.asByteSource</code>方法创建了一个<code>ByteSource</code>实例，它代表文件中的字节数据。然后，可以使用<code>byteSource.read()</code>方法读取这些数据。这种方式比直接使用Java NIO的Channel和Buffer要简单得多。</p>
<h3 id="nio与流的转换">NIO与流的转换</h3>
<p>另一个强大的功能是Guava提供的NIO和流之间的转换。在某些情况下，可能需要在NIO的Channel和Java的InputStream/OutputStream之间进行转换。Guava在这方面提供了便利的工具。</p>
<pre><code class="language-java">// 使用Guava将InputStream转换为ReadableByteChannel
InputStream inputStream = new FileInputStream("example.txt");
ReadableByteChannel channel = Channels.newChannel(inputStream);
// 使用channel进行操作
</code></pre>
<p>在这个例子中，<code>Channels.newChannel</code>方法将一个InputStream转换为一个ReadableByteChannel。这样的转换让我们能够在需要使用NIO时，更加灵活地处理流。</p>
<h2 id="往期推荐">往期推荐</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/qb4XACLMRNgsNdi5DdevhA" target="_blank" rel="noopener nofollow">《SpringBoot》EasyExcel实现百万数据的导入导出</a></li>
<li><a href="https://mp.weixin.qq.com/s/MgC_iK536FxTLgm7CJMlqQ" target="_blank" rel="noopener nofollow">《SpringBoot》史上最全SpringBoot相关注解介绍</a></li>
<li><a href="https://mp.weixin.qq.com/s/-3H6VyhKfl9byf6ifnk1ug" target="_blank" rel="noopener nofollow">Spring框架IoC核心详解</a></li>
<li><a href="https://mp.weixin.qq.com/s/O0W6vCuqQfeAH0UB7elpeA" target="_blank" rel="noopener nofollow">万字长文带你窥探Spring中所有的扩展点</a></li>
<li><a href="https://mp.weixin.qq.com/s/tATN-g66NyW5BzyiHWoRkA" target="_blank" rel="noopener nofollow">如何实现一个通用的接口限流、防重、防抖机制</a></li>
<li><a href="https://mp.weixin.qq.com/s/gg6N6e90ZtbA0MH4KIEHlg" target="_blank" rel="noopener nofollow">万字长文带你深入Redis底层数据结构</a></li>
<li><a href="https://mp.weixin.qq.com/s/QhOFMEJWjIJM0jVFsCfJdA" target="_blank" rel="noopener nofollow">volatile关键字最全原理剖析</a></li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.33818153858912037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-03 08:15">2025-04-03 08:15</span>&nbsp;
<a href="https://www.cnblogs.com/seven97-top">seven97_top</a>&nbsp;
阅读(<span id="post_view_count">87</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18805538" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18805538);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18805538', targetLink: 'https://www.cnblogs.com/seven97-top/p/18805538', title: '【Guava】IO工具' })">举报</a>
</div>
        