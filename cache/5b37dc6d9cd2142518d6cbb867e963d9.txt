
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ivictor/p/18776392" title="发布于 2025-03-17 10:58">
    <span role="heading" aria-level="2">深入解析 Druid 连接池：连接有效性检测与 Keep-Alive 机制</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        
        应用出现“Communications link failure The last packet successfully received from the server was xxx milliseconds ago.”错误，你的 Druid 连接池配置对了吗？
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">背景</span></h1>
<p data-tool="mdnice编辑器">在 Java 程序中，下面是一个经常会碰到的错误。</p>
<pre data-tool="mdnice编辑器"><code>Caused&nbsp;by:&nbsp;com.mysql.cj.exceptions.CJCommunicationsException:&nbsp;Communications&nbsp;link&nbsp;failure<br><br>The&nbsp;last&nbsp;packet&nbsp;successfully&nbsp;received&nbsp;from&nbsp;the&nbsp;server&nbsp;was&nbsp;30,027&nbsp;milliseconds&nbsp;ago.&nbsp;The&nbsp;last&nbsp;packet&nbsp;sent&nbsp;successfully&nbsp;to&nbsp;the&nbsp;server&nbsp;was&nbsp;30,028&nbsp;milliseconds&nbsp;ago.<br></code></pre>
<p data-tool="mdnice编辑器">该错误通常是由于 MySQL 连接意外断开导致的，常见原因包括：</p>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>
<p>客户端连接池（如 HikariCP、Druid）配置不当，包括：</p>
</li>
<ul class="list-paddingleft-1">
<li>空闲连接超时时间超过 MySQL&nbsp;<code>wait_timeout</code>（默认是 28800 秒，即 8 小时），导致连接被 MySQL 服务端关闭。</li>
<li>未配置适当的 Keep-Alive 机制，导致连接长时间未使用而被 MySQL 服务器关闭。</li>
<li>未进行连接有效性检查，可能导致客户端获取到失效连接。</li>
</ul>
<li>
<p>连接未及时释放。</p>
<p>长时间未释放的连接无法通过连接池的 Keep-Alive 机制保持活跃，更容易因空闲超时被 MySQL 服务端或中间件关闭。</p>
</li>
<li>
<p>中间层组件的超时限制。</p>
<p>如果客户端与 MySQL 之间存在代理（如 ProxySQL）或负载均衡器（LB），这些组件可能会有独立的空闲连接超时设置，导致连接被提前断开。</p>
</li>
<li>
<p>网络问题，包括高延迟、丢包或短暂网络中断都会影响数据库连接的稳定性。</p>
</li>
<li>
<p>连接被 MySQL 服务器主动断开，如 DBA 手动执行<code>KILL</code>操作终止连接。</p>
</li>
</ol>
<p data-tool="mdnice编辑器">本文将深入解析 Druid 连接池的连接有效性检测机制，重点探讨以下内容：</p>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>Druid 在哪些情况下会检查连接是否可用？</li>
<li>Druid 如何保持连接的活跃状态（Keep-Alive 机制）？</li>
<li>Druid 连接池中常见参数的具体含义及其作用。</li>
<li>为什么 MySQL 的 general log 看不到<code>validationQuery</code>定义的检测语句执行？</li>
</ol>
<p data-tool="mdnice编辑器">希望通过本篇分析，帮助大家更深入理解 Druid 连接池的运行机制。</p>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">什么场景下会检测连接的有效性</span></h1>
<p data-tool="mdnice编辑器">Druid 连接池在以下四种场景下会检测连接的有效性：</p>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>申请连接。</li>
<li>归还连接。</li>
<li>创建新的物理连接。</li>
<li>定期检测。</li>
</ol>
<p data-tool="mdnice编辑器">下面我们看看这四种场景的具体实现逻辑。</p>
<h2 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">1. 申请连接</span></h2>
<p data-tool="mdnice编辑器">当应用从连接池申请空闲连接时，会检查连接的有效性，与之相关的参数有两个：testOnBorrow 和 testWhileIdle。</p>
<p data-tool="mdnice编辑器">申请连接是在<code>getConnectionDirect</code>方法中实现的，下面我们看看该方法的具体实现细节。</p>
<pre data-tool="mdnice编辑器"><code>public&nbsp;DruidPooledConnection&nbsp;getConnectionDirect(long&nbsp;maxWaitMillis)&nbsp;throws&nbsp;SQLException&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;notFullTimeoutRetryCnt&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;&nbsp;;&nbsp;)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DruidPooledConnection&nbsp;poolableConnection;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;从连接池中获取空闲连接<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poolableConnection&nbsp;=&nbsp;getConnectionInternal(maxWaitMillis);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(GetConnectionTimeoutException&nbsp;ex)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果testOnBorrow为true，则会调用testConnectionInternal检测连接的有效性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(testOnBorrow)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;validated&nbsp;=&nbsp;testConnectionInternal(poolableConnection.holder,&nbsp;poolableConnection.conn);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!validated)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(LOG.isDebugEnabled())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG.debug("skip&nbsp;not&nbsp;validated&nbsp;connection.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果连接无效，则会调用discardConnection丢弃该连接，并继续从连接池中获取新的空闲连接。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;discardConnection(poolableConnection.holder);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果testOnBorrow不为true，且testWhileIdle为true，则判断连接的空闲时间是否超过timeBetweenEvictionRunsMillis，如果超过，也会调用testConnectionInternal检测连接的有效性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(testWhileIdle)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;DruidConnectionHolder&nbsp;holder&nbsp;=&nbsp;poolableConnection.holder;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;currentTimeMillis&nbsp;=&nbsp;System.currentTimeMillis();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;lastActiveTimeMillis&nbsp;=&nbsp;holder.lastActiveTimeMillis;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;idleMillis&nbsp;=&nbsp;currentTimeMillis&nbsp;-&nbsp;lastActiveTimeMillis;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idleMillis&nbsp;&gt;=&nbsp;timeBetweenEvictionRunsMillis<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;idleMillis&nbsp;&lt;&nbsp;0&nbsp;//&nbsp;unexcepted&nbsp;branch<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;validated&nbsp;=&nbsp;testConnectionInternal(poolableConnection.holder,&nbsp;poolableConnection.conn);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!validated)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(LOG.isDebugEnabled())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOG.debug("skip&nbsp;not&nbsp;validated&nbsp;connection.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果连接无效，则会调用discardConnection丢弃该连接，并继续从连接池中获取新的空闲连接。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;discardConnection(poolableConnection.holder);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;poolableConnection;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code></pre>
<p data-tool="mdnice编辑器">该方法的实现逻辑如下：</p>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>首先从连接池中获取一个空闲连接。</li>
<li>如果<code>testOnBorrow</code>为 true，则调用 testConnectionInternal 检测连接的有效性。若连接有效，则直接返回；若无效，则丢弃该连接并重新获取新的空闲连接。</li>
<li>如果<code>testOnBorrow</code>为 false 且<code>testWhileIdle</code>为 true，则判断连接的空闲时间是否超过 timeBetweenEvictionRunsMillis。若超过，则调用 testConnectionInternal 进行检测；若未超过或检测通过，则直接返回连接。</li>
</ol>
<p data-tool="mdnice编辑器">testOnBorrow、testWhileIdle、timeBetweenEvictionRunsMillis &nbsp;这三个参数的默认值分别为 false、true 和 60000（即 60 秒）。</p>
<p data-tool="mdnice编辑器">这就意味着，在默认配置下，当从连接池申请一个连接时，如果该连接空闲时间超过 60 秒，系统会对该连接的有效性进行检查。这样的逻辑适用于大多数场景，因为在大多数情况下，连接在 60 秒内被中断的概率较小。</p>
<p data-tool="mdnice编辑器">如果应用对连接的可用性要求极高（例如金融、支付等场景），可以考虑将 testOnBorrow 设置为 true，以确保每次获取的连接都是可用的。但需要注意，这会有一定的性能开销。</p>
<h2 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">2. 归还连接</span></h2>
<p data-tool="mdnice编辑器">当应用调用<code>connection.close()</code>关闭连接时，连接并不会被立即销毁，而是被归还到连接池中，以便后续复用。</p>
<p data-tool="mdnice编辑器">如果 testOnReturn（默认为 false） 为 true，会在连接归还时验证其有效性，确保不会将无效连接放回给连接池。</p>
<pre data-tool="mdnice编辑器"><code>//&nbsp;DruidDataSource.java<br>protected&nbsp;void&nbsp;recycle(DruidPooledConnection&nbsp;pooledConnection)&nbsp;throws&nbsp;SQLException&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;DruidConnectionHolder&nbsp;holder&nbsp;=&nbsp;pooledConnection.holder;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(testOnReturn)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;validated&nbsp;=&nbsp;testConnectionInternal(holder,&nbsp;physicalConnection);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!validated)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JdbcUtils.close(physicalConnection);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code></pre>
<h2 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">3. 创建新的物理连接</span></h2>
<p data-tool="mdnice编辑器">创建新的物理连接是在<code>createPhysicalConnection</code>方法中实现的。</p>
<pre data-tool="mdnice编辑器"><code>public&nbsp;PhysicalConnectionInfo&nbsp;createPhysicalConnection()&nbsp;throws&nbsp;SQLException&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;url&nbsp;=&nbsp;this.getUrl();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Properties&nbsp;connectProperties&nbsp;=&nbsp;getConnectProperties();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;这里会调用驱动的&nbsp;connect&nbsp;方法来建立连接<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn&nbsp;=&nbsp;createPhysicalConnection(url,&nbsp;physicalConnectProperties);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connectedNanos&nbsp;=&nbsp;System.nanoTime();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(conn&nbsp;==&nbsp;null)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;SQLException("connect&nbsp;error,&nbsp;url&nbsp;"&nbsp;+&nbsp;url&nbsp;+&nbsp;",&nbsp;driverClass&nbsp;"&nbsp;+&nbsp;this.driverClass);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!initSqls(conn,&nbsp;variables,&nbsp;globalVariables))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validateConnection(conn);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;PhysicalConnectionInfo(conn,&nbsp;connectStartNanos,&nbsp;connectedNanos,&nbsp;initedNanos,&nbsp;validatedNanos,&nbsp;variables,&nbsp;globalVariables);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code></pre>
<p data-tool="mdnice编辑器">在连接建立后，如果<code>initSqls(conn, variables, globalVariables)</code>为 false，则会调用<code>validateConnection</code>来验证连接的有效性。</p>
<p data-tool="mdnice编辑器">以下是 initSqls(conn, variables, globalVariables) 为 false 需要满足的条件：</p>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>connectionInitSqls 为空（默认值）。connectionInitSqls 常用来设置一些连接初始化语句，如<code>set NAMES 'utf8mb4'</code>。</li>
<li>initVariants 为 false（默认值）。如果该参数为 true，则会执行 show variables 获取连接的会话变量。</li>
<li>initGlobalVariants 为 false（默认值）。如果该参数为 true，则会执行 show global variables 获取全局变量。</li>
</ol>
<h2 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">4. 定期检测</span></h2>
<p data-tool="mdnice编辑器">Druid 在初始化连接池时，会启动一个后台守护线程 (<code>DestroyConnectionThread</code>)，用于定期销毁连接池中的过期连接。</p>
<p data-tool="mdnice编辑器">该线程按照一定的时间间隔（由 timeBetweenEvictionRunsMillis 参数决定，默认为 60秒）调用<code>shrink(true, keepAlive)</code>方法，执行具体的连接销毁操作。</p>
<p data-tool="mdnice编辑器">下面，我们看看该方法的具体实现细节。</p>
<pre data-tool="mdnice编辑器"><code>public&nbsp;void&nbsp;shrink(boolean&nbsp;checkTime,&nbsp;boolean&nbsp;keepAlive)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;needFill&nbsp;=&nbsp;false;&nbsp;//&nbsp;是否需要填充连接池中的空闲连接<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;evictCount&nbsp;=&nbsp;0;&nbsp;//&nbsp;需要销毁的连接数量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;keepAliveCount&nbsp;=&nbsp;0;&nbsp;//&nbsp;需要保持活跃的连接数量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;int&nbsp;checkCount&nbsp;=&nbsp;poolingCount&nbsp;-&nbsp;minIdle;&nbsp;//&nbsp;计算连接池中可以回收的连接数量（总连接数减去最小空闲连接数）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;long&nbsp;currentTimeMillis&nbsp;=&nbsp;System.currentTimeMillis();&nbsp;//&nbsp;获取系统当前时间<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;remaining&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;&nbsp;i&nbsp;&lt;&nbsp;poolingCount;&nbsp;++i)&nbsp;{&nbsp;//&nbsp;遍历连接池中的连接<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DruidConnectionHolder&nbsp;connection&nbsp;=&nbsp;connections[i];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(checkTime)&nbsp;{&nbsp;// shrink被DestroyConnectionThread调用时，checkTime默认为true。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(phyTimeoutMillis&nbsp;&gt;&nbsp;0)&nbsp;{&nbsp;//&nbsp;物理超时检查<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;phyConnectTimeMillis&nbsp;=&nbsp;currentTimeMillis&nbsp;-&nbsp;connection.connectTimeMillis;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果连接的存活时间超过了物理超时时间，则将该连接加入销毁列表。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(phyConnectTimeMillis&nbsp;&gt;&nbsp;phyTimeoutMillis)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evictConnections[evictCount++]&nbsp;=&nbsp;connection;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;计算连接的空闲时间<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;idleMillis&nbsp;=&nbsp;currentTimeMillis&nbsp;-&nbsp;connection.lastActiveTimeMillis;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果连接的空闲时间小于&nbsp;minEvictableIdleTimeMillis&nbsp;和&nbsp;keepAliveBetweenTimeMillis，则退出当前循环<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idleMillis&nbsp;&lt;&nbsp;minEvictableIdleTimeMillis<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;idleMillis&nbsp;&lt;&nbsp;keepAliveBetweenTimeMillis)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果连接的空闲时间大于maxEvictableIdleTimeMillis，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;或者连接的空闲时间大于等于&nbsp;minEvictableIdleTimeMillis&nbsp;且连接的序号小于可以回收的连接数量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;才将该连接加入销毁列表。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idleMillis&nbsp;&gt;=&nbsp;minEvictableIdleTimeMillis)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;&lt;&nbsp;checkCount)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evictConnections[evictCount++]&nbsp;=&nbsp;connection;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(idleMillis&nbsp;&gt;&nbsp;maxEvictableIdleTimeMillis)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evictConnections[evictCount++]&nbsp;=&nbsp;connection;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果&nbsp;keepAlive&nbsp;启用，并且连接空闲时间达到了&nbsp;keepAliveBetweenTimeMillis，则将其加入&nbsp;keepAliveConnections，后续会检测连接的有效性<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(keepAlive&nbsp;&amp;&amp;&nbsp;idleMillis&nbsp;&gt;=&nbsp;keepAliveBetweenTimeMillis<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;currentTimeMillis&nbsp;-&nbsp;connection.lastKeepTimeMillis&nbsp;&gt;=&nbsp;keepAliveBetweenTimeMillis)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keepAliveConnections[keepAliveCount++]&nbsp;=&nbsp;connection;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;!=&nbsp;remaining)&nbsp;{&nbsp;//&nbsp;将不需要销毁的连接移到新的位置<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connections[remaining]&nbsp;=&nbsp;connection;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remaining++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;计算需要移除的连接数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;removeCount&nbsp;=&nbsp;evictCount&nbsp;+&nbsp;keepAliveCount;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;将未被检查的连接移动到 remaining 之后的位置，确保有效连接的连续性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(removeCount&nbsp;&gt;&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;breakedCount&nbsp;=&nbsp;poolingCount&nbsp;-&nbsp;i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(breakedCount&nbsp;&gt;&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.arraycopy(connections,&nbsp;i,&nbsp;connections,&nbsp;remaining,&nbsp;breakedCount);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remaining&nbsp;+=&nbsp;breakedCount;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.arraycopy(nullConnections,&nbsp;0,&nbsp;connections,&nbsp;remaining,&nbsp;removeCount);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poolingCount&nbsp;-=&nbsp;removeCount;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keepAliveCheckCount&nbsp;+=&nbsp;keepAliveCount;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(keepAlive&nbsp;&amp;&amp;&nbsp;poolingCount&nbsp;+&nbsp;activeCount&nbsp;&lt;&nbsp;minIdle)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;needFill&nbsp;=&nbsp;true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;关闭需要销毁的连接<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(evictCount&nbsp;&gt;&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;evictCount;&nbsp;++i)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DruidConnectionHolder&nbsp;item&nbsp;=&nbsp;evictConnections[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Connection&nbsp;connection&nbsp;=&nbsp;item.getConnection();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JdbcUtils.close(connection);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destroyCountUpdater.incrementAndGet(this);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.arraycopy(nullConnections,&nbsp;0,&nbsp;evictConnections,&nbsp;0,&nbsp;evictConnections.length);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;检测 keepAliveConnections 中连接的有效性，若有效，将其放回连接池。如果校验失败，则丢弃连接。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(keepAliveCount&nbsp;&gt;&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;keepAliveCount&nbsp;-&nbsp;1;&nbsp;i&nbsp;&gt;=&nbsp;0;&nbsp;--i)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DruidConnectionHolder&nbsp;holder&nbsp;=&nbsp;keepAliveConnections[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Connection&nbsp;connection&nbsp;=&nbsp;holder.getConnection();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holder.incrementKeepAliveCheckCount();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;validate&nbsp;=&nbsp;false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.validateConnection(connection);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validate&nbsp;=&nbsp;true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Throwable&nbsp;error)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;discard&nbsp;=&nbsp;!validate;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(validate)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;holder.lastKeepTimeMillis&nbsp;=&nbsp;System.currentTimeMillis();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;putOk&nbsp;=&nbsp;put(holder,&nbsp;0L,&nbsp;true);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!putOk)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;discard&nbsp;=&nbsp;true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.getDataSourceStat().addKeepAliveCheckCount(keepAliveCount);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.arraycopy(nullConnections,&nbsp;0,&nbsp;keepAliveConnections,&nbsp;0,&nbsp;keepAliveConnections.length);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(needFill)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.lock();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果连接池中的总连接数&nbsp;(activeCount + poolingCount + createTaskCount)&nbsp;小于 minIdle，则补充新的连接。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fillCount&nbsp;=&nbsp;minIdle&nbsp;-&nbsp;(activeCount&nbsp;+&nbsp;poolingCount&nbsp;+&nbsp;createTaskCount);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emptySignal(fillCount);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(fatalErrorIncrement&nbsp;&gt;&nbsp;0)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.lock();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;emptySignal();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.unlock();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code></pre>
<p data-tool="mdnice编辑器">该方法的处理流程如下：</p>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>
<p>通过 checkCount = poolingCount - minIdle 计算当前池中可以回收的连接数量。其中<code>minIdle</code>是 Druid 参数，用于指定连接池需保留的最小空闲连接数。</p>
</li>
<li>
<p>遍历连接池中的连接，并执行以下检查：</p>
</li>
<ul class="list-paddingleft-1">
<li>
<p>物理连接存活时间检查：如果 phyTimeoutMillis &gt; 0，检查物理连接的存活时长是否超过<code>phyTimeoutMillis</code>，如果超过，则将该连接加入销毁列表（evictConnections）。</p>
</li>
<li>
<p>空闲时间检查：如果连接的空闲时间大于 maxEvictableIdleTimeMillis，或空闲时间大于等于 minEvictableIdleTimeMillis 且连接的序号小于 checkCount（可回收连接数），则将该连接加入销毁列表。</p>
</li>
<li>
<p>保持连接活跃：若连接需要保持活跃（<code>keepAlive</code>开启）且空闲时间超过<code>keepAliveBetweenTimeMillis</code>，则将该连接加入 keepAliveConnections 列表。</p>
</li>
</ul>
<li>
<p>将未被检查的连接移动到 remaining 之后的位置，确保有效连接的连续性。</p>
</li>
<li>
<p>如果 evictCount 大于 0，表示有连接需要销毁，遍历销毁列表（evictConnections）关闭这些连接。</p>
</li>
<li>
<p>如果 keepAliveCount 大于 0，表示有连接需要保持活跃，遍历 keepAliveConnections 列表，检查连接有效性，若有效，将其放回连接池。如果校验失败，则丢弃连接。</p>
</li>
<li>
<p>如果 needFill 为 true，表示连接池中空闲连接不足，触发填充信号以创建新连接。</p>
</li>
</ol>
<p data-tool="mdnice编辑器">所以，Druid 连接池默认情况下，每 60 秒（由&nbsp;<code>timeBetweenEvictionRunsMillis</code>&nbsp;参数控制）执行一次连接回收和维护操作，并保持一定数量的空闲连接。其核心逻辑包括：</p>
<ul class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>
<p>回收超时或多余的空闲连接：</p>
</li>
<ul class="list-paddingleft-1">
<li>连接的空闲时间超过 maxEvictableIdleTimeMillis 或 phyConnectTimeMillis，将被回收。</li>
<li>当连接池的数量超过最小空闲连接数 minIdle 时，如果连接的空闲时间超过 minEvictableIdleTimeMillis，也会被回收。</li>
</ul>
<li>
<p>维护 Keep-Alive 机制（如果<code>keepAlive</code>开启）：</p>
</li>
<ul class="list-paddingleft-1">
<li>当连接的空闲时间超过 keepAliveBetweenTimeMillis，且距离上次 Keep-Alive 检测时间超过 keepAliveBetweenTimeMillis 时，执行有效性检测。</li>
<li>通过 validateConnection 进行检测，合格的连接重新加入池中，不合格的连接被销毁。</li>
</ul>
<li>
<p>必要时补充新的连接：</p>
<p>若当前连接数（activeCount + poolingCount）低于 minIdle，则触发连接补充机制，创建新的连接。</p>
</li>
</ul>
<p data-tool="mdnice编辑器"><strong>需要注意的是，即使连接开启了定期探活检测，若发生超时，仍会被回收</strong>。</p>
<p data-tool="mdnice编辑器">接下来，我们看看上述参数的默认值：</p>
<ul class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>timeBetweenEvictionRunsMillis：默认 60000 毫秒（60 秒）。</li>
<li>minEvictableIdleTimeMillis：默认 1800000 毫秒（30 分钟）。</li>
<li>maxEvictableIdleTimeMillis：默认 25200000 毫秒（7 小时）。</li>
<li>phyTimeoutMillis：默认 -1。</li>
<li>keepAlive：默认为 false。</li>
<li>keepAliveBetweenTimeMillis：默认 120000 毫秒（120 秒）。</li>
</ul>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">为什么设置的 validationQuery 没有效果？</span></h1>
<p data-tool="mdnice编辑器">在 Druid 连接池中，判断连接是否有效时，通常调用&nbsp;<code>testConnectionInternal</code>&nbsp;或&nbsp;<code>validateConnection</code>&nbsp;方法。这两个方法的核心逻辑基本相同，具体如下：</p>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>
<p>优先使用 validConnectionChecker 进行连接校验：</p>
</li>
<ul class="list-paddingleft-1">
<li>validConnectionChecker 是一个接口，定义了 isValidConnection 方法，用于检测数据库连接的有效性。</li>
<li>具体的数据库有对应的实现类，例如：MySQL 由<code>MySqlValidConnectionChecker</code>实现，Oracle 由 OracleValidConnectionChecker 实现。</li>
<li>validConnectionChecker 在 initValidConnectionChecker 方法中初始化，并根据数据库驱动类型选择合适的实现类。</li>
</ul>
<li>
<p>如果 validConnectionChecker 未初始化，则执行默认检查：</p>
</li>
<ul class="list-paddingleft-1">
<li>
<p>通过 validationQuery 执行 SQL 语句，验证连接是否有效。</p>
</li>
<li>
<p>该方法适用于所有数据库，但会带来一定的性能开销。</p>
</li>
</ul>
</ol>
<p data-tool="mdnice编辑器">以下是 MySQL 实现类（MySqlValidConnectionChecker）中<code>isValidConnection</code>方法的具体实现。</p>
<pre data-tool="mdnice编辑器"><code>//&nbsp;druid-1.2.24/core/src/main/java/com/alibaba/druid/pool/vendor/MySqlValidConnectionChecker.java<br>public&nbsp;boolean&nbsp;isValidConnection(Connection&nbsp;conn,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;validateQuery,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;validationQueryTimeout)&nbsp;throws&nbsp;Exception&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(conn.isClosed())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(usePingMethod&nbsp;||&nbsp;StringUtils.isEmpty(validateQuery))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validateQuery&nbsp;=&nbsp;DEFAULT_VALIDATION_QUERY;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ValidConnectionCheckerAdapter.execValidQuery(conn,&nbsp;validateQuery,&nbsp;validationQueryTimeout);<br>}<br></code></pre>
<p data-tool="mdnice编辑器">方法中的 usePingMethod 受<code>druid.mysql.usePingMethod</code>参数控制，其默认值为 true。</p>
<p data-tool="mdnice编辑器">当 usePingMethod 等于 true 时，validateQuery 将被设置为 DEFAULT_VALIDATION_QUERY，即<code>/* ping */ SELECT 1</code>，而非用户自定义的 validationQuery。</p>
<p data-tool="mdnice编辑器">execValidQuery() 方法执行 validateQuery 时，如果查询语句以<code>/* ping */</code>开头，MySQL JDBC 驱动会进行特殊处理。</p>
<p data-tool="mdnice编辑器">具体来说，MySQL JDBC 在解析 SQL 语句时，会判断它是否以 PING_MARKER（即<code>/* ping */</code>）开头，如果是，则不会执行 SQL 语句，而是调用<code>doPingInstead()</code>，直接向 MySQL 服务器发送 COM_PING &nbsp;命令，这样可以减少 SQL 解析和执行的开销，提高性能。</p>
<pre data-tool="mdnice编辑器"><code>//&nbsp;mysql-connector-j-8.0.33/src/main/user-impl/java/com/mysql/cj/jdbc/StatementImpl.java<br>public&nbsp;java.sql.ResultSet&nbsp;executeQuery(String&nbsp;sql)&nbsp;throws&nbsp;SQLException&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;(checkClosed().getConnectionMutex())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JdbcConnection&nbsp;locallyScopedConn&nbsp;=&nbsp;this.connection;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sql.charAt(0)&nbsp;==&nbsp;'/')&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sql.startsWith(PING_MARKER))&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doPingInstead();&nbsp;//&nbsp;直接发送&nbsp;COM_PING&nbsp;命令<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this.results;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></code></pre>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">关于参数设置的几点建议</span></h1>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>
<p><code>minEvictableIdleTimeMillis</code>，<code>maxEvictableIdleTimeMillis</code>不宜设置过小，因为频繁销毁和创建连接会带来额外的性能开销。</p>
</li>
<li>
<p>建议开启 keepAlive 机制，尤其是在客户端与 MySQL 之间存在代理的情况下，这些组件可能会有独立的空闲连接超时设置，导致连接被提前断开。</p>
</li>
<li>
<p>在连接申请时检测连接的有效性（通过设置 testOnBorrow 为 true）是最有效的方式，可以确保每次获取的连接都是可用的。但这种方式会对应用性能产生一定影响，尤其是在高并发场景下。</p>
<p>因此，建议根据业务需求权衡性能与可靠性，选择合适的检测策略。</p>
</li>
<li>
<p>考虑到网络可能的故障，即使 Druid 连接池定期检测连接的有效性，也无法 100% 保证所有连接都可用，所以应用端一定要做好容错处理。</p>
</li>
<li>
<p>对于代码中未及时归还使用过的连接，一方面可能导致连接泄漏，使连接池耗尽可用连接。另一方面，未释放的连接无法通过 Druid 的 Keep-Alive 机制保持活跃状态，更容易因空闲超时被 MySQL 服务器或中间件关闭。</p>
<p>为了避免这些问题，建议在应用的测试环境开启以下参数来识别长时间未归还的连接：<code>logAbandoned</code>，<code>removeAbandoned</code>，<code>removeAbandonedTimeoutMillis</code>。</p>
</li>
</ol>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">总结</span></h1>
<ol class="list-paddingleft-1" data-tool="mdnice编辑器">
<li>
<p>Druid 连接池在以下四种场景下会检测连接的有效性：申请连接、归还连接、创建新物理连接以及定期检测。</p>
</li>
<li>
<p>Druid 通过开启 keepAlive 参数，定期对空闲连接进行有效性检测，确保连接保持活跃状态。</p>
<p>当连接的空闲时间超过 keepAliveBetweenTimeMillis 时，Druid 会触发 Keep-Alive 检测，验证连接的有效性。如果连接有效，则重新放回连接池；如果无效，则将其销毁。</p>
</li>
<li>
<p>Druid 默认使用 MySQL 的 COM_PING 命令进行连接有效性检测，这种方式比执行 SQL 语句更高效。</p>
<p>由于 COM_PING 的优先级高于用户自定义的 validationQuery，因此在默认配置下，validationQuery 不会被执行。</p>
<p>如果用户希望使用自定义的 validationQuery 进行连接检测，可将 <code>druid.mysql.usePingMethod</code> 参数设置为 false 来实现。</p>
</li>
</ol>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3968840087465278" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-17 10:59">2025-03-17 10:58</span>&nbsp;
<a href="https://www.cnblogs.com/ivictor">iVictor</a>&nbsp;
阅读(<span id="post_view_count">68</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18776392" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18776392);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18776392', targetLink: 'https://www.cnblogs.com/ivictor/p/18776392', title: '深入解析 Druid 连接池：连接有效性检测与 Keep-Alive 机制' })">举报</a>
</div>
	