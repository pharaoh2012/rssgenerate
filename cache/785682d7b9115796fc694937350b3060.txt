
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zwwhnly/p/18846441" title="发布于 2025-04-25 13:18">
    <span role="heading" aria-level="2">【踩坑系列】使用Comparator.comparing对中文字符串排序结果不对</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0.20820450060416668" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-25 13:18">2025-04-25 13:18</span>&nbsp;
<a href="https://www.cnblogs.com/zwwhnly">申城异乡人</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18846441);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18846441', targetLink: 'https://www.cnblogs.com/zwwhnly/p/18846441', title: '【踩坑系列】使用Comparator.comparing对中文字符串排序结果不对' })">举报</a>
</small>
    <div class="entry">
            <div id="cnblogs_post_description" style="display: none">
        
        使用Comparator.comparing对中文字符串排序结果不对解决方案。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-踩坑经历">1. 踩坑经历</h2>
<p>假设有这样一个业务场景，需要对各个城市的订单量排序，排序规则为：</p>
<p>先根据订单量倒序排列，再根据城市名称正序排列。</p>
<p>示例代码：</p>
<pre><code class="language-java">import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
public class OrderStatisticsInfo {
    private String cityName;
    private Integer orderCount;

    public OrderStatisticsInfo(String cityName, Integer orderCount) {
        this.cityName = cityName;
        this.orderCount = orderCount;
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
    List&lt;OrderStatisticsInfo&gt; orderStatisticsInfoList = Arrays.asList(
            new OrderStatisticsInfo("上海", 1000),
            new OrderStatisticsInfo("北京", 1000),
            new OrderStatisticsInfo("成都", 700),
            new OrderStatisticsInfo("常州", 700),
            new OrderStatisticsInfo("广州", 900),
            new OrderStatisticsInfo("深圳", 800)
    );

    orderStatisticsInfoList.sort(Comparator.comparing(OrderStatisticsInfo::getOrderCount, Comparator.reverseOrder())
            .thenComparing(OrderStatisticsInfo::getCityName));
    orderStatisticsInfoList.forEach(System.out::println);
}
</code></pre>
<p>预期结果：</p>
<blockquote>
<p>北京 1000</p>
<p>上海 1000</p>
<p>广州 900</p>
<p>深圳 800</p>
<p>常州 700</p>
<p>成都 700</p>
</blockquote>
<p>实际结果：</p>
<blockquote>
<p>OrderStatisticsInfo(cityName=上海, orderCount=1000)<br>
OrderStatisticsInfo(cityName=北京, orderCount=1000)<br>
OrderStatisticsInfo(cityName=广州, orderCount=900)<br>
OrderStatisticsInfo(cityName=深圳, orderCount=800)<br>
OrderStatisticsInfo(cityName=常州, orderCount=700)<br>
OrderStatisticsInfo(cityName=成都, orderCount=700)</p>
</blockquote>
<p>从以上结果可以看出，根据订单量倒序排列没啥问题，但根据城市名称正序排列不符合预期：</p>
<p>上海竟然排到了北京的前面，但常州与成都的顺序又是对的。</p>
<h2 id="2-原因分析">2. 原因分析</h2>
<p><code>Comparator.comparing</code>对字符串类型进行排序时，默认使用的是字符串的自然排序，即<code>String</code>的<code>compareTo</code>方法，该方法是基于</p>
<p>Unicode编码值进行比较的，未考虑语言特定的字符顺序（如中文拼音）。</p>
<p>先看下<code>String</code>的<code>compareTo</code>方法的源码：</p>
<pre><code class="language-java">public int compareTo(String anotherString) {
    int len1 = value.length;
    int len2 = anotherString.value.length;
    int lim = Math.min(len1, len2);
    char v1[] = value;
    char v2[] = anotherString.value;

    int k = 0;
    while (k &lt; lim) {
        char c1 = v1[k];
        char c2 = v2[k];
        if (c1 != c2) {
            return c1 - c2;
        }
        k++;
    }
    return len1 - len2;
}
</code></pre>
<p>以上海与北京的比较为例，先比较第一个字符，也就是字符上和字符北，字符上对应的Unicode编码值是19978，因此c1 = 19978，</p>
<p>字符北对应的Unicode编码值是21271，因此c2 = 21271，因为c1 != c2，所以返回值为-1293，</p>
<p>也就是说上海小于北京（要排在北京的前面），不符合预期。</p>
<p>以常州与成都的比较为例，先比较第一个字符，也就是字符常和字符成，字符常对应的Unicode编码值是24120，因此c1 = 24120，</p>
<p>字符成对应的Unicode编码值是25104，因此c2 = 25104，因为c1 != c2，所以返回值为-984，</p>
<p>也就是说常州小于成都（要排在成都的前面），符合预期。</p>
<p>可以通过<code>Character.codePointAt</code>方法获取字符的Unicode编码值：</p>
<pre><code class="language-java">// 输出:19978
System.out.println(Character.codePointAt("上海", 0));
// 输出:21271
System.out.println(Character.codePointAt("北京", 0));
// 输出:24120
System.out.println(Character.codePointAt("常州", 0));
// 输出:25104
System.out.println(Character.codePointAt("成都", 0));
</code></pre>
<h2 id="3-解决方案">3. 解决方案</h2>
<p>Java提供了本地化的排序规则，可以按特定语言规则排序（如中文拼音），代码如下所示：</p>
<pre><code class="language-java">orderStatisticsInfoList.sort(Comparator.comparing(OrderStatisticsInfo::getOrderCount, Comparator.reverseOrder())
                .thenComparing(OrderStatisticsInfo::getCityName, Collator.getInstance(Locale.CHINA)));
orderStatisticsInfoList.forEach(System.out::println);
</code></pre>
<p>此时的输出结果为：</p>
<blockquote>
<p>OrderStatisticsInfo(cityName=北京, orderCount=1000)<br>
OrderStatisticsInfo(cityName=上海, orderCount=1000)<br>
OrderStatisticsInfo(cityName=广州, orderCount=900)<br>
OrderStatisticsInfo(cityName=深圳, orderCount=800)<br>
OrderStatisticsInfo(cityName=常州, orderCount=700)<br>
OrderStatisticsInfo(cityName=成都, orderCount=700)</p>
</blockquote>
<p>可以看到，北京排到了上海的前面，符合预期。</p>
<p>上述代码指定了<code>Collator.getInstance(Locale.CHINA)</code>，在排序比较时不再执行<code>String</code>的<code>compareTo</code>方法，</p>
<p>而是执行<code>Collator</code>的<code>compare</code>方法，实际上是<code>RuleBasedCollator</code>的<code>compare</code>方法。</p>
<p>可以执行以下代码单独看下上海与北京的比较结果：</p>
<pre><code class="language-java">Collator collator = Collator.getInstance(Locale.CHINA);
// 输出:1，代表上海大于北京，也就是要排在北京的后面
System.out.println(collator.compare("上海", "北京"));
</code></pre>
<blockquote>
<p>文章持续更新，欢迎关注微信公众号「申城异乡人」第一时间阅读！</p>
</blockquote>

</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="zwwhnly" blog-id="121761" post-id="18846441"></vc:categories-tags>
    </ul>
