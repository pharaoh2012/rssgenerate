
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18654323" title="发布于 2025-01-06 09:01">
    <span role="heading" aria-level="2">探索Python @dataclass的内部原理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>之前写过一篇介绍<code>Python</code>中<code>dataclass</code>的文章：<a href="https://www.cnblogs.com/wang_yb/p/18077397" target="_blank">《掌握python的dataclass，让你的代码更简洁优雅》</a>。</p>
<p>那篇侧重于介绍<code>dataclass</code>的使用，今天想探索一下这个有趣的特性是如何实现的。</p>
<p>表面上看，<code>dataclass</code>就是一个普通的装饰器，但是它又在<code>class</code>上实现了很多神奇的功能，</p>
<p>为我们在<code>Python</code>中定义和使用<code>class</code>带来了极大的便利。</p>
<p>如果你也好奇它在幕后是如何工作的，本篇我们就一同揭开<code>Python</code>中<code>dataclass</code>的神秘面纱，</p>
<p>深入探究一下其内部原理。</p>
<h1 id="1-dataclass简介">1. dataclass简介</h1>
<p><code>dataclass</code>为我们提供了一种简洁而高效的方式来定义类，特别是那些主要用于存储数据的类。</p>
<p>它能自动为我们生成一些常用的方法，如<code>__init__</code>、<code>__repr__</code>等，大大减少了样板代码的编写。</p>
<p>例如，我在量化中经常用的一个<strong>K线</strong>数据，用dataclass来定义的话，如下所示：</p>
<pre><code class="language-python">from dataclasses import dataclass
from datetime import datetime

@dataclass
class KLine:
    name: str = "BTC"
    open_price: float = 0.0
    close_price: float = 0.0
    high_price: float = 0.0
    low_price: float = 0.0
    begin_time: datetime = datetime.now()

if __name__ == "__main__":
    kl = KLine()
    print(kl)
</code></pre>
<p>这样，我们无需手动编写<code>__init__</code>方法来初始化对象，就可以轻松创建<code>KLine</code>类的实例，</p>
<p>并且直接打印对象也可以得到清晰，易于阅读的输出。</p>
<pre><code class="language-powershell">$  python.exe .\kline.py
KLine(name='BTC', open_price=0.0, close_price=0.0, 
high_price=0.0, low_price=0.0, 
begin_time=datetime.datetime(2025, 1, 2, 17, 45, 53, 44463))
</code></pre>
<p>但这背后究竟发生了什么呢？</p>
<h1 id="2-核心概念">2. 核心概念</h1>
<p><code>dataclass</code>从<code>Python3.7</code>版本开始，已经加入到标准库中了。</p>
<p>代码就在<code>Python</code>安装目录中的<code>Lib/dataclasses.py</code>文件中。</p>
<p>实现这个装饰器功能的核心有两个：<code>__annotations__</code>属性和<code>exec</code>函数。</p>
<h2 id="21-__annotations__属性">2.1. __annotations__属性</h2>
<p><code>__annotations__</code>是 <code>Python</code> 中一个隐藏的宝藏，它以字典的形式存储着变量、属性以及函数参数或返回值的类型提示。</p>
<p>对于<code>dataclass</code>来说，它就像是一张地图，装饰器通过它来找到用户定义的字段。</p>
<p>比如，在上面的<code>KLine</code>类中，<code>__annotations__</code>会返回字段的相关信息。</p>
<p>这使得<code>dataclass</code>装饰器能够清楚地知道类中包含哪些字段以及它们的类型，为后续的操作提供了关键信息。</p>
<pre><code class="language-python">if __name__ == "__main__":
    print(KLine.__annotations__)

# 运行结果：
{'name': &lt;class 'str'&gt;, 'open_price': &lt;class 'float'&gt;, 
'close_price': &lt;class 'float'&gt;, 'high_price': &lt;class 'float'&gt;, 
'low_price': &lt;class 'float'&gt;, 'begin_time': &lt;class 'datetime.datetime'&gt;}
</code></pre>
<h2 id="22-exec-函数">2.2. exec 函数</h2>
<p><code>exec</code>函数堪称<code>dataclass</code>实现的魔法棒，它能够将字符串形式的代码转换为 <code>Python</code> 对象。</p>
<p>在<code>dataclass</code>的世界里，它被用来创建各种必要的方法。</p>
<p>我们可以通过构建函数定义的字符串，然后使用<code>exec</code>将其转化为真正的函数，并添加到类中。</p>
<p>这就是<code>dataclass</code>装饰器能够自动生成<code>__init__</code>、<code>__repr__</code>等方法的秘密所在。</p>
<p>下面的代码通过<code>exec</code>，将一个字符串代码转换成一个真正可使用的函数。</p>
<pre><code class="language-python"># 定义一个存储代码的字符串
code_string = """
def greet(name):
    print(f"Hello, {name}!")
"""

# 使用 exec 函数执行代码字符串
exec(code_string)

# 调用通过 exec 生成的函数
greet("Alice")
</code></pre>
<h1 id="3-自定义dataclass装饰器">3. 自定义dataclass装饰器</h1>
<p>掌握了上面的核心概念，我们就可以开始尝试实现自己的<code>dataclass</code>装饰器。</p>
<p>当然，这里只是简单实现个雏形，目的是为了了解<code>Python</code>标准库中<code>dataclass</code>的原理。</p>
<p>下面主要实现两个功能<code>__init__</code>和<code>__repr__</code>。</p>
<p>通过这两个功能来理解<code>dataclass</code>的实现原理。</p>
<h2 id="31-定义架构">3.1. 定义架构</h2>
<p>我们首先定义一个<code>dataclass</code>装饰器，它的结构如下：</p>
<pre><code class="language-python">def dataclass(cls=None, init=True, repr=True):

    def wrap(cls):
        # 这里将对类进行修改
        return cls

    if cls is None:
        return wrap
    return wrap(cls)
</code></pre>
<p>接下来，我们在这个装饰器中实现<code>__init__</code>和<code>__repr__</code>。</p>
<h2 id="32-初始化init">3.2. 初始化：<strong>init</strong></h2>
<p>当<code>init</code>参数为<code>True</code>时，我们为类添加<code>__init__</code>方法。</p>
<p>通过<code>_init_fn</code>函数来实现，它会根据类的字段生成<code>__init__</code>方法的函数定义字符串，然后使用<code>_create_fn</code>函数将其转换为真正的方法并添加到类中。</p>
<pre><code class="language-python">def _create_fn(cls, name, fn):
    ns = {}
    exec(fn, None, ns)
    method = ns[name]
    setattr(cls, name, method)


def _init_fn(cls, fields):
    args = ", ".join(fields)

    lines = [f"self.{field} = {field}" for field in fields]
    body = "\n".join(f"  {line}" for line in lines)

    txt = f"def __init__(self, {args}):\n{body}"

    _create_fn(cls, "__init__", txt)
</code></pre>
<h2 id="33-美化输出repr">3.3. 美化输出：<strong>repr</strong></h2>
<p><code>__repr__</code>方法让我们能够以一种清晰易读的方式打印出类的实例。</p>
<p>为了实现这个功能，我们创建<code>_repr_fn</code>函数，它生成<code>__repr__</code>方法的定义字符串。</p>
<p>这个方法会获取实例的<code>__dict__</code>属性中的所有变量，并使用 <code>f-string</code> 进行格式化输出。</p>
<pre><code class="language-python">def _repr_fn(cls, fields):
    txt = (
        "def __repr__(self):\n"
        "    fields = [f'{key}={val!r}' for key, val in self.__dict__.items()]\n"
        "    return f'{self.__class__.__name__}({\"\\n \".join(fields)})'"
    )
    _create_fn(cls, "__repr__", txt)
</code></pre>
<h2 id="34-合在一起">3.4. 合在一起</h2>
<p>最终的代码如下，代码中使用的是自己的<code>dataclass</code>装饰器，而不是标准库中的<code>dataclass</code>。</p>
<pre><code class="language-python">from datetime import datetime


def dataclass(cls=None, init=True, repr=True):

    def wrap(cls):
        fields = cls.__annotations__.keys()

        if init:
            _init_fn(cls, fields)

        if repr:
            _repr_fn(cls, fields)

        return cls

    if cls is None:  # 如果装饰器带参数
        return wrap

    return wrap(cls)


def _create_fn(cls, name, fn):
    ns = {}
    exec(fn, None, ns)
    method = ns[name]
    setattr(cls, name, method)


def _init_fn(cls, fields):
    args = ", ".join(fields)

    lines = [f"self.{field} = {field}" for field in fields]
    body = "\n".join(f"  {line}" for line in lines)

    txt = f"def __init__(self, {args}):\n{body}"

    _create_fn(cls, "__init__", txt)


def _repr_fn(cls, fields):
    txt = (
        "def __repr__(self):\n"
        "    fields = [f'{key}={val!r}' for key, val in self.__dict__.items()]\n"
        "    return f'{self.__class__.__name__}({\"\\n \".join(fields)})'"
    )
    _create_fn(cls, "__repr__", txt)


@dataclass
class KLine:
    name: str = "BTC"
    open_price: float = 0.0
    close_price: float = 0.0
    high_price: float = 0.0
    low_price: float = 0.0
    begin_time: datetime = datetime.now()


if __name__ == "__main__":
    kl = KLine(
        name="ETH",
        open_price=1000.5,
        close_price=3200.5,
        high_price=3400,
        low_price=200,
        begin_time=datetime.now(),
    )
    print(kl)
</code></pre>
<p>运行的效果如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/83005/202501/83005-20250106085927305-325673437.png" alt="" loading="lazy"></p>
<p>可以看出，我们自己实现的<code>dataclass</code>装饰器也可以实现类的初始化和美化输出，这里输出时每个属性占一行。</p>
<h1 id="4-总结">4. 总结</h1>
<p>通过自定义<code>dataclass</code>装饰器的构建过程，我们深入了解了 <code>Python</code> 中<code>dataclass</code>的内部原理。</p>
<p>利用<code>__annotations__</code>获取字段信息，借助<code>exec</code>创建各种方法，从而实现简洁高效的<code>dataclass</code>定义。</p>
<p>不过，实际的 <code>Python</code>标准库中的<code>dataclass</code>还有更多的功能和优化，了解了其原理之后，可以参考它的源码再进一步学习。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3053157158414352" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-06 09:01">2025-01-06 09:01</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">20</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18654323" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18654323);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18654323', targetLink: 'https://www.cnblogs.com/wang_yb/p/18654323', title: '探索Python @dataclass的内部原理' })">举报</a>
</div>
        