
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cplmlm/p/19053115" title="发布于 2025-08-25 08:49">
    <span role="heading" aria-level="2">WPF+MVVM入门学习</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>最近在学WPF的MVVM，有两种方式实现，一种是自己实现，一种是借助MVVM框架，接下来通过一个医院自助打印报告机键盘输入界面来演示自己实现、框架CommunityToolkit和Prism的区别。</p>
<p>项目源码：<a href="https://gitee.com/cplmlm/SelfServiceReportPrinter" target="_blank" rel="noopener nofollow">https://gitee.com/cplmlm/SelfServiceReportPrinter</a></p>
<p><a href="https://github.com/cplmlm/SelfServiceReportPrinter" target="_blank" rel="noopener nofollow">https://github.com/cplmlm/SelfServiceReportPrinter</a></p>
<p>推荐学习博主：<a href="https://space.bilibili.com/600592?spm_id_from=333.1369.opus.module_author_name.click" target="_blank" rel="noopener nofollow">B站UP十月的寒流</a></p>
<h2><strong><span style="font-size: 18px">一、自己实现</span></strong></h2>
<p>1、首先我们创建一个BaseNotifyPropertyChanged类，继承INotifyPropertyChanged，这个方法的作用是属性值变化时自动更新UI界面。</p>
<pre class="language-csharp highlighter-hljs"><code> public class BaseNotifyPropertyChanged : INotifyPropertyChanged
 {
     public event PropertyChangedEventHandler? PropertyChanged;
     public void RaisePropertyChanged(string propertyName)
     {
         if (!string.IsNullOrEmpty(propertyName))
         {
             PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
         }
     }
 }</code></pre>
<p>2、创建一个KeyPressViewModel类，继承BaseNotifyPropertyChanged。</p>
<pre class="language-csharp highlighter-hljs"><code> public class KeyPressViewModel : BaseNotifyPropertyChanged
 {
     private string cardNumber;
     private int selectionStart=0;

     /// &lt;summary&gt;
     /// 输入文本框的值
     /// &lt;/summary&gt;
     public string CardNumber
     {
         get { return cardNumber; }
         set
         {
             cardNumber = value;
             RaisePropertyChanged(nameof(CardNumber));
         }
     }

     /// &lt;summary&gt;
     /// 输入框光标位置
     /// &lt;/summary&gt;
     public int SelectionStart
     {
         get { return selectionStart; }
         set { RaisePropertyChanged(nameof(SelectionStart)); }
     }

     /// &lt;summary&gt;
     /// 数字按钮绑定事件
     /// &lt;/summary&gt;
     public ICommand NumberCommand
     {
         get { return new RelayCommand&lt;string&gt;(Number); }
     }

     /// &lt;summary&gt;
     /// 清空按钮绑定事件
     /// &lt;/summary&gt;
     public ICommand ClearCommand
     {
         get { return new RelayCommand(Clear); }
     }

     /// &lt;summary&gt;
     /// 删除按钮绑定事件    
     /// &lt;/summary&gt;

     public ICommand DeleteCommand
     {
         get { return new RelayCommand(Delete); }
     }

     /// &lt;summary&gt;
     /// 数字点击事件
     /// &lt;/summary&gt;
     /// &lt;param name="key"&gt;&lt;/param&gt;
     private void Number(string? key)
     {
         CardNumber += key;
     }

     /// &lt;summary&gt;
     /// 清空点击事件
     /// &lt;/summary&gt;
     private void Clear()
     {
         CardNumber = string.Empty;
     }
     /// &lt;summary&gt;
     /// 删除点击事件
     /// &lt;/summary&gt;
     private void Delete()
     {
         // 光标在输入框时，删除光标前一个字符
         if (!string.IsNullOrEmpty(CardNumber) &amp;&amp; SelectionStart &gt; 0)
         {
             CardNumber = CardNumber.Remove(SelectionStart - 1, 1);
         }
         //光标没有在输入框时，删除最后一个字符
         if (SelectionStart == 0)
         {
             CardNumber = CardNumber.Remove(CardNumber.Length - 1, 1);
         }
     }
 }</code></pre>
<p>3、创建RelayCommand类，这个类的作用是绑定事件的操作，一个泛型版本，一个是非泛型。</p>
<pre class="language-csharp highlighter-hljs"><code>public class RelayCommand : ICommand
{

    private Action _execute;
    private Func&lt;bool&gt; _canExecute;


    public RelayCommand(Action execute) : this(execute, null)
    {
    }

    public RelayCommand(Action execute, Func&lt;bool&gt; canExecute)
    {
        if (execute == null)
            throw new ArgumentNullException("execute");
        _execute = execute;
        _canExecute = canExecute;
    }

    public event EventHandler? CanExecuteChanged
    {
        add
        {
            if (_canExecute != null)
            {
                CommandManager.RequerySuggested += value;
            }
        }
        remove
        {
            if (_canExecute != null)
            {
                CommandManager.RequerySuggested -= value;
            }
        }
    }

    public bool CanExecute(object parameter)
    {
        return _canExecute == null ? true : _canExecute();
    }

    public void Execute(object parameter)
    {
        _execute();
    }
}</code></pre>
<pre class="language-csharp highlighter-hljs"><code>public class RelayCommand&lt;T&gt; : ICommand
{
    private readonly Predicate&lt;T&gt; _canExecute;
    private readonly Action&lt;T&gt; _execute;

    public RelayCommand(Action&lt;T&gt; execute) : this(execute, null)
    {
    }

    public RelayCommand(Action&lt;T&gt; execute, Predicate&lt;T&gt; canExecute)
    {
        if (execute == null)
            throw new ArgumentNullException("execute");
        _execute = execute;
        _canExecute = canExecute;
    }

    public event EventHandler? CanExecuteChanged
    {
        add { CommandManager.RequerySuggested += value; }
        remove { CommandManager.RequerySuggested -= value; }
    }

    public bool CanExecute(object parameter)
    {
        return _canExecute == null ? true : _canExecute((T)parameter);
    }

    public void Execute(object parameter)
    {
        _execute((T)parameter);
    }
}</code></pre>
<p>4、通过binding绑定输入框的值和事件的操作，代替传统直接在后台cs文件写事件。</p>
<pre class="language-csharp highlighter-hljs"><code>&lt;TextBox Text="{Binding CardNumber}"     x:Name="CardNumberTextBox"   local:TextBoxSelectionHelper.SelectionStart="{Binding SelectionStart, Mode=TwoWay}" Height="40"     Width="460" /&gt;  
&lt;Button  Content="1" Style="{StaticResource NumberButtonStyle}" Command="{Binding NumberCommand}"  CommandParameter="1"/&gt;
&lt;Button  Content="删除" Style="{StaticResource RedButtonStyle}" Command="{Binding DeleteCommand}"   /&gt;
&lt;Button  Content="清空" Style="{StaticResource RedButtonStyle}" Command="{Binding ClearCommand}"   /&gt;</code></pre>
<p>5、将MainWindow的DataContext赋值给ViewModel，我这里用了依赖注入的方法，所以直接是在app.cs里面赋值的，也可以在MainWindow.cs。</p>
<pre class="language-csharp highlighter-hljs"><code>  public partial class App : Application
  {
      public App()
      {
          Services = ConfigureServices();
          this.InitializeComponent();
      }

      /// &lt;summary&gt;
      /// Gets the current &lt;see cref="App"/&gt; instance in use
      /// &lt;/summary&gt;
      public new static App Current =&gt; (App)Application.Current;

      /// &lt;summary&gt;
      /// Gets the &lt;see cref="IServiceProvider"/&gt; instance to resolve application services.
      /// &lt;/summary&gt;
      public IServiceProvider Services { get; }

      /// &lt;summary&gt;
      /// Configures the services for the application.
      /// &lt;/summary&gt;
      private static IServiceProvider ConfigureServices()
      {          
          var services = new ServiceCollection();
          services.AddTransient&lt;KeyPressViewModelCommunityToolkit&gt;();
          services.AddTransient&lt;KeyPressViewModelPrism&gt;();
          services.AddTransient&lt;KeyPressViewModel&gt;();
          services.AddTransient(sp=&gt;new MainWindow() { DataContext=sp.GetRequiredService&lt;KeyPressViewModelCommunityToolkit&gt;()});
          return services.BuildServiceProvider();
      }

      protected override void OnStartup(StartupEventArgs e)
      {
          base.OnStartup(e);
          MainWindow= Services.GetRequiredService&lt;MainWindow&gt;();
          MainWindow.Show();
      }
  }</code></pre>
<pre class="language-csharp highlighter-hljs"><code>    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            DataContext =App.Current.Services.GetService&lt;KeyPressViewModel&gt;();
        }
    }</code></pre>
<p>6、如果不用依赖注入的方式，可以在MainWindow.xaml或者MainWindow.cs将MainWindow的DataContext赋值给ViewModel。</p>
<pre class="language-csharp highlighter-hljs"><code>&lt;Window x:Class="SelfServiceReportPrinter.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:selfservicereportprinter="clr-namespace:SelfServiceReportPrinter"      
        xmlns:local="clr-namespace:SelfServiceReportPrinter" 
        mc:Ignorable="d"
        WindowStartupLocation="CenterScreen" 
        AllowsTransparency="True"
        WindowStyle="None"
        Title="MainWindow" 
        Height="1080" 
        Width="1920"&gt;
    &lt;Window.DataContext&gt;
        &lt;local:KeyPressViewModel /&gt;
    &lt;/Window.DataContext&gt;</code></pre>
<pre class="language-csharp highlighter-hljs"><code> public partial class MainWindow : Window
 {
     public MainWindow()
     {
         InitializeComponent();
         DataContext =new KeyPressViewModel();
     }
 }</code></pre>
<p>以上就是自己去实现mvvm的方式，会比较繁琐，如果不是复杂的项目大多数还是用社区的CommunityToolkit.MVVM，复杂的项目可以使用Prism</p>
<h2><span style="font-size: 18px"><strong>二、使用微软社区的CommunityToolkit.MVVM</strong></span></h2>
<p>1、首先安装CommunityToolkit.MVVM的包。</p>
<p><img alt="image" data-src="https://img2024.cnblogs.com/blog/1127956/202508/1127956-20250822170538360-2033014506.png" class="lazyload"></p>
<p>2、创建一个新的类KeyPressViewModelCommunityToolkit类，继承ObservableObject，CommunityToolkit代码就简洁很多了，直接在方法或者属性上面加特性就可以。</p>
<pre class="language-csharp highlighter-hljs"><code>public partial class KeyPressViewModelCommunityToolkit : ObservableObject
{
    [ObservableProperty]
    private string cardNumber = string.Empty;

    [ObservableProperty]
    private int selectionStart;

    /// &lt;summary&gt;
    /// 数字点击事件
    /// &lt;/summary&gt;
    /// &lt;param name="key"&gt;&lt;/param&gt;
    [RelayCommand]
    private void Number(string? key)
    {
        CardNumber += key;
    }

    /// &lt;summary&gt;
    /// 清空输入框
    /// &lt;/summary&gt;
    [RelayCommand]
    private void Clear()
    {
        CardNumber = string.Empty;
    }

    /// &lt;summary&gt;
    /// 删除点击事件
    /// &lt;/summary&gt;
    [RelayCommand]
    private void Delete()
    {
        // 光标在输入框时，删除光标前一个字符
        if (!string.IsNullOrEmpty(CardNumber) &amp;&amp; SelectionStart &gt; 0)
        {
            CardNumber = CardNumber.Remove(SelectionStart - 1, 1);
        }
        //光标没有在输入框时，删除最后一个字符
        if (SelectionStart == 0)
        {
            CardNumber = CardNumber.Remove(CardNumber.Length - 1, 1);
        }
    }
}</code></pre>
<h2><span style="font-size: 18px"><strong>三、Prism</strong></span></h2>
<p><span style="font-size: 14px">1、安装Prism.Core和Prism.Wpf,其他的包根据后续实际使用在安装。</span></p>
<p><span style="font-size: 14px"><img alt="image" data-src="https://img2024.cnblogs.com/blog/1127956/202508/1127956-20250825083930590-1369482595.png" class="lazyload"></span></p>
<p><span style="font-size: 14px">2、创建一个KeyPressViewModelPrism类继承BindableBase。</span></p>
<pre class="language-csharp highlighter-hljs"><code>public partial class KeyPressViewModelPrism : BindableBase
{
    private string cardNumber;
    private int selectionStart;

    public string CardNumber
    {
        get { return cardNumber; }
        set { SetProperty(ref cardNumber, value); }
    }

    public int SelectionStart
    {
        get { return selectionStart; }
        set { SetProperty(ref selectionStart, value); }
    }

    public DelegateCommand&lt;string&gt; NumberCommand { get; }
    public DelegateCommand ClearCommand { get; }
    public DelegateCommand DeleteCommand { get; }
    public KeyPressViewModelPrism()
    {
        NumberCommand = new DelegateCommand&lt;string&gt;(Number);
        ClearCommand = new DelegateCommand(Clear);
        DeleteCommand = new DelegateCommand(Delete);
    }

    /// &lt;summary&gt;
    /// 数字点击事件
    /// &lt;/summary&gt;
    /// &lt;param name="key"&gt;&lt;/param&gt;
    private void Number(string? key)
    {
        CardNumber += key;
    }

    /// &lt;summary&gt;
    /// 清空点击事件
    /// &lt;/summary&gt;
    private void Clear()
    {
        CardNumber = string.Empty;
    }

    /// &lt;summary&gt;
    /// 删除点击事件
    /// &lt;/summary&gt;
    private void Delete()
    {
        // 光标在输入框时，删除光标前一个字符
        if (!string.IsNullOrEmpty(CardNumber) &amp;&amp; SelectionStart &gt; 0)
        {
            CardNumber = CardNumber.Remove(SelectionStart - 1, 1);
        }
        //光标没有在输入框时，删除最后一个字符
        if (SelectionStart == 0)
        {
            CardNumber = CardNumber.Remove(CardNumber.Length - 1, 1);
        }
    }
}</code></pre>
<h2><span style="font-size: 18px">四、总结</span></h2>
<p>以上就是三种不同ViewModel的实现方式，个人比较推荐使用社区的CommunityToolkit，但是还是要根据自己的项目情况来决定。</p>
</div>
<div class="clear"></div>

		<div class="author">
			posted on 
<span id="post-date" data-last-update-days="0.01597222222222222" data-date-updated="2025-08-25 09:12">2025-08-25 08:49</span>&nbsp;
<a href="https://www.cnblogs.com/cplmlm">一只小小的程序猿</a>&nbsp;
阅读(<span id="post_view_count">31</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19053115);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19053115', targetLink: 'https://www.cnblogs.com/cplmlm/p/19053115', title: 'WPF+MVVM入门学习' })">举报</a>

		</div>
		<div class="linex"></div>
	