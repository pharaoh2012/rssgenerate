
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tyysoft/p/18715876" title="发布于 2025-02-14 18:07">
    <span role="heading" aria-level="2">pytest自动化测试 - 我对测试用例超时处理的一点看法</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>&nbsp;</p>

<p>&nbsp;</p>

<div class="container-fluid">
<div class="row flex-xl-nowrap">
<div id="post-content" class="col-12 col-md-9 col-xl-10 py-md-3 pl-md-5 bd-content">
<div id="vx-content" class="vx-constrain-image-width line-numbers">
<h1 id="1-pytest自动化测试---我对测试用例超时处理的一点看法" class="source-line" data-source-line="0">1 pytest自动化测试 - 我对测试用例超时处理的一点看法</h1>
<h2 id="1.1-背景" class="source-line" data-source-line="1">1.1 背景</h2>
<p class="source-line" data-source-line="2">  用例在执行过程中，可能由于网络等待，或者等待一些特殊的文件，而又由于一些异常，导致这些条件一直不能满足，用例卡死，这种情况在自动化测试中是不允许的，会浪费大量的时间，影响测试任务的进度，甚至导致版本发布周期的延长。<br>  为了给每个用例都设置上超时时间，有以下几种方法：</p>
<h2 id="1.2-方法1：给每个用例添加@pytest.mark.timeout修饰器" class="source-line" data-source-line="5">1.2 方法1：给每个用例添加<code>@pytest.mark.timeout</code>修饰器</h2>
<p class="source-line" data-source-line="6"><span style="color: rgba(255, 0, 0, 1)"><strong>@pytest.mark.timeout在Windows下并不能很好的工作，1 个用例出现超时，整个测试任务就中断了，非常扯淡！</strong></span></p>
<div class="code-toolbar">
<pre class="language-py line-numbers highlighter-hljs"><code>import pytest
import time

@pytest.mark.timeout(5)
def test_case1():
    time.sleep(2)
    assert True

@pytest.mark.timeout(5)
def test_case2():
    time.sleep(6)  # 此用例会超时
    assert True

def test_case3():
    print("用例3：Windows下不会执行")
    assert 3 == 3</code></pre>
</div>
<h2 id="1.3-方法2：使用钩子函数给每个用例添加一个timeout修饰器" class="source-line" data-source-line="26">1.3 方法2：使用钩子函数给每个用例添加一个timeout修饰器</h2>
<p class="source-line" data-source-line="27">  然而，<span style="color: rgba(255, 0, 0, 1)"><strong>下面这个做法，在Windows下并没有什么卵用！</strong></span>，超时的那个用例也执行成功了！</p>
<div class="code-toolbar">
<pre class="language-py line-numbers highlighter-hljs"><code>import pytest
import time

def pytest_collection_modifyitems(session, config, items):
    for item in items:
        item.add_marker(pytest.mark.timeout(3))

def setup_function():
    print()

def test_case3():
    print("用例3：开始")
    time.sleep(3)
    assert True
    print("用例3：结束")

def test_case4():
    print("用例4：开始")
    time.sleep(5)  # 此用例会超时，但Windows不超时，神奇！
    assert True
    print("用例4：结束")

def test_case5():
    print("用例5: 开始")
    assert 3 == 3
    print("用例5: 结束")</code></pre>
</div>
<p class="source-line" data-source-line="56">Windows下的执行结果：</p>
<div class="code-toolbar">
<pre class="language-cmd line-numbers highlighter-hljs"><code>============================= test session starts =============================
platform win32 -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0
rootdir: D:\TYYSOFT\Study\Python\pytest
configfile: pytest.ini
plugins: check-2.4.1, html-4.1.1, metadata-3.1.1, timeout-2.3.1, xdist-3.6.1
collected 3 items

test_timeout_004.py 
用例3：开始
用例3：结束
.
用例4：开始
用例4：结束
.
用例5: 开始
用例5: 结束
.

-- Generated html report: file:///D:/TYYSOFT/Study/Python/pytest/report.html --
============================== 3 passed in 8.03s ==============================</code></pre>
</div>
<p class="source-line" data-source-line="80"><span style="color: rgba(255, 0, 0, 1)">其他所谓的使用<code>timeout</code>标记的超时处理在Windows下都没有什么卵用！</span></p>
<h2 id="1.4-方法3：介绍一个自己写的使用线程处理用例超时的方法" class="source-line" data-source-line="82">1.4 方法3：介绍一个自己写的使用线程处理用例超时的方法</h2>
<p class="source-line" data-source-line="83">  用例的超时，其实主要是监控每条任务的超时情况，通过创建1个基础函数<code>base_func</code>这个函数每次调用时都创建1个线程，并给线程设置超时时间，用例中的执行语句都通过这个线程函数<code>base_func</code>来执行，<code>base_func</code>中对超时任务会设置失败。</p>
<div class="code-toolbar">
<pre class="language-py line-numbers highlighter-hljs"><code>import pytest
import threading
import time

# 核心函数：该函数创建1个线程，并执行给定的task，超时后会把用例设置为失败
def base_func(task, timeout=5):
    thread = threading.Thread(target=task)
    thread.start()
    thread.join(timeout) #设置超时

    if thread.is_alive():
        print(f"::{task.__name__}: 语句执行超时...")
        assert False

# 1个长时间任务
def long_time_task():
    time.sleep(2)

# 模块发送消息的基础函数
def send_msg(msg):
    print(msg)

# 预置条件
def setup_function():
    print()
    base_func(print("预置条件！"))

# 这是用例1
def test_timeout_001():
    base_func(send_msg("用例1开始"))
    base_func(long_time_task)
    base_func(send_msg("用例1结束"))

def test_timeout_002():
    base_func(send_msg("用例2开始"))
    base_func(send_msg("用例2结束"))</code></pre>
</div>
<p class="source-line" data-source-line="123">输出结果：</p>
<div class="code-toolbar">
<pre class="language-cmd line-numbers highlighter-hljs"><code>============================= test session starts =============================
platform win32 -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0
rootdir: D:\TYYSOFT\Study\Python\pytest
configfile: pytest.ini
plugins: check-2.4.1, html-4.1.1, metadata-3.1.1, timeout-2.3.1, xdist-3.6.1
collected 2 items

test_timeout_002.py 
预置条件！
用例1开始
::long_time_task: 语句执行超时...
F
预置条件！
用例2开始
用例2结束
.

================================== FAILURES ===================================
______________________________ test_timeout_001 _______________________________

    def test_timeout_001():
        base_func(send_msg("用例1开始"))
&gt;       base_func(long_time_task)

test_timeout_002.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

task = &lt;function long_time_task at 0x000001AAE4112DE0&gt;, timeout = 5

    def base_func(task, timeout=5):
        thread = threading.Thread(target=task)
        thread.start()
        thread.join(timeout) #设置超时
    
        if thread.is_alive():
            print(f"::{task.__name__}: 语句执行超时...")
&gt;           assert False
E           assert False

test_timeout_002.py:13: AssertionError
-- Generated html report: file:///D:/TYYSOFT/Study/Python/pytest/report.html --
=========================== short test summary info ===========================
FAILED test_timeout_002.py::test_timeout_001 - assert False
========================= 1 failed, 1 passed in 5.11s =========================</code></pre>
</div>
<p class="source-line" data-source-line="170">两个用例都执行了， 第2个用例并没有因为第1个用例超时而中止执行！</p>
<p class="source-line" data-source-line="172">使用基础函数来包装测试执行语句的必要性， 因为实际在测试执行时， 每个语句都有可能执行超时，对其进行封装执行可以保证测试脚本的严谨性。</p>
<hr>
<p class="source-line" data-source-line="175">作者声明：本文用于记录和分享作者的学习心得，可能有部分文字或示例来自AI平台，如：豆包、<strong>DeepSeek(硅基流动)</strong><a href="https://cloud.siliconflow.cn/i/46A7o0CE" rel="noopener nofollow">(注册链接)</a>等，由于本人水平有限，难免存在表达错误，欢迎留言交流和指教！<br>Copyright © 2022~2025 All rights reserved.</p>
</div>
</div>
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.005124083910879629" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-14 18:08">2025-02-14 18:07</span>&nbsp;
<a href="https://www.cnblogs.com/tyysoft">tyysoft</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18715876" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18715876);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18715876', targetLink: 'https://www.cnblogs.com/tyysoft/p/18715876', title: 'pytest自动化测试 - 我对测试用例超时处理的一点看法' })">举报</a>
</div>
        