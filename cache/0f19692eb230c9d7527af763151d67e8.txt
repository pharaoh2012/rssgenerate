
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ACaiGarden/p/18788403" title="发布于 2025-03-23 22:08">
    <span role="heading" aria-level="2">【技术分析】简单了解 AccessControl</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>当我们开发一个智能合约，但是里面有一些函数不能随便让别人调用，只能“拥有权限”的管理员能够调用，那么这时候我们会用到权限管理机制。</p>
<p>实现起来也很简单，设置一个 <code>owner</code> 变量，通过 <code>modifier onlyOwner()</code> 检查调用 <code>onlyOwnerCanCall()</code> 的地址是否等于预先设置好的 <code>woner</code>，这样就可以保证只有 <code>owner</code> 能够调用这个函数。</p>
<pre><code>contract AccessControl {
    address private owner;

    constructor() {
        owner = msg.sender;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Caller is not the owner");
        _;
    }
    
    function onlyOwnerCanCall() public onlyOwner {
        // ...
    }
}
</code></pre>
<p>由于权限控制这个机制被广泛应用在不同的场景中，为了避免重复开发以及保证实现质量，开发者可以从 openzeppelin 的标准库中使用 <code>openzeppelin-contracts/contracts/access</code> 目录下的标准库进行实现。</p>
<p>目前为 5.2.0 版本：<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v5.2.0/contracts/access" target="_blank" rel="noopener nofollow">https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v5.2.0/contracts/access</a></p>
<p>主要分为 3 种方案：</p>
<ol>
<li>Ownable：只要单一的 owner 权限，owner 权限可以转移，放弃（置为 0 地址）。</li>
<li>Ownable2Step：在 Ownable 基础上避免了将 owner 权限转移到了错误的地址导致权限丢失，Ownable2Step 在权限转移这个环节，添加了接受权限的地址需要调用 acceptOwnership() 进行领取的步骤。</li>
<li>AccessControl：不再采用单一的 owner 进行权限管理，而是更细粒度地细分到了多种权限账户。</li>
</ol>
<p>在接下来的文章中会对 AccessControl 进行展开介绍。</p>
<h1 id="accesscontrol">AccessControl</h1>
<p>代码实现：<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.2.0/contracts/access/AccessControl.sol" target="_blank" rel="noopener nofollow">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.2.0/contracts/access/AccessControl.sol</a></p>
<p>AccessControl 中存储所有管理员信息的全局变量是 <code>_roles</code> ，其次是代表默认管理员的 <code>DEFAULT_ADMIN_ROLE</code> 。</p>
<p><img src="https://img2024.cnblogs.com/blog/1483609/202503/1483609-20250323220619793-1075736290.png" alt="image" loading="lazy"></p>
<h2 id="权限检查">权限检查</h2>
<p>当需要对某个函数进行调用权限的限制时，可以通过添加 <code>modifier onlyRole(bytes32 role)</code> 的方式来检查 <code>msg.sender</code> 是否满足指定权限角色 <code>ROLE</code> 的要求。</p>
<pre><code>function privilegedFunctions() public onlyRole(ROLE){...}
</code></pre>
<p><code>modifier onlyRole(bytes32 role)</code> 会调用以下的函数来进行检查</p>
<pre><code>modifier onlyRole(bytes32 role) {
    _checkRole(role);
    _;
}

function _checkRole(bytes32 role) internal view virtual {
    _checkRole(role, _msgSender());
}

function _checkRole(bytes32 role, address account) internal view virtual {
    if (!hasRole(role, account)) {
        revert AccessControlUnauthorizedAccount(account, role);
    }
}

function hasRole(bytes32 role, address account) public view virtual returns (bool) {
    return _roles[role].hasRole[account];
}
</code></pre>
<p>当用户调用需要 <code>ROLE</code> 权限的函数时，<code>modifier onlyRole(bytes32 role)</code> 会检查 <code>_roles[ROLE].hasRole[mag.sender]</code> 是否为 <code>true</code>。</p>
<p><img src="https://img2024.cnblogs.com/blog/1483609/202503/1483609-20250323220635034-1872044911.png" alt="image" loading="lazy"></p>
<h2 id="权限角色管理">权限角色管理</h2>
<p>而当需要通过权限管理员来管理权限角色时：</p>
<ol>
<li>通过 <code>grantRole(bytes32 role, address account)</code> 来授予 account 地址 role 权限角色。</li>
<li>通过 <code>revokeRole(bytes32 role, address account)</code> 来移除 account 地址 role 权限角色。</li>
</ol>
<pre><code>function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
    return _roles[role].adminRole;
}

function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
    _grantRole(role, account);
}

function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
    if (!hasRole(role, account)) {
        _roles[role].hasRole[account] = true;
        emit RoleGranted(role, account, _msgSender());
        return true;
    } else {
        return false;
    }
}

function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
    _revokeRole(role, account);
}

function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
    if (hasRole(role, account)) {
        _roles[role].hasRole[account] = false;
        emit RoleRevoked(role, account, _msgSender());
        return true;
    } else {
        return false;
    }
}
</code></pre>
<p>当需要添加 ROLE 的权限时，则需要通过 <code>onlyRole(getRoleAdmin(role)</code> 检查 <code>_roles[_roles[role].adminRole].hasRole[mag.sender]</code> 是否为 <code>true</code>。也就是说每一个权限角色（ROLE）的管理员，都是对应着另一个权限角色（ROLE_ADMIN）。</p>
<p><img src="https://img2024.cnblogs.com/blog/1483609/202503/1483609-20250323220649913-543943196.png" alt="image" loading="lazy"></p>
<h2 id="默认管理员">默认管理员</h2>
<p>那么权限角色有管理员，管理员还有他自己的管理员，那岂不是无穷尽也？这个时候就用到 <code>DEFAULT_ADMIN_ROLE</code> 角色了，由于它的值被设定为 <code>0x00</code>，所以只要你不为某一个权限角色设置 <code>adminRole</code>，那么 <code>adminRole</code> 的值就会指向 <code>DEFAULT_ADMIN_ROLE(0x00)</code> 。</p>
<p><img src="https://img2024.cnblogs.com/blog/1483609/202503/1483609-20250323220707706-1650539121.png" alt="image" loading="lazy"></p>
<h2 id="应用实例">应用实例</h2>
<p>根据上面的内容，实现了一个简单的 Demo 协助读者理解（仅供参考，请勿用作生产代码）。</p>
<pre><code>contract RoleDemo is AccessControl {
    // Define roles
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    constructor() {
        // Grant DEFAULT_ADMIN_ROLE to contract deployer
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        // Grant ADMIN_ROLE to contract deployer
        _grantRole(ADMIN_ROLE, address(0x01));
        // Grant MINTER_ROLE to contract deployer
        _grantRole(MINTER_ROLE, address(0x02));
        
        // Set ADMIN_ROLE as the admin role for MINTER_ROLE
        _setRoleAdmin(MINTER_ROLE, ADMIN_ROLE);
    }

		// Function can only be called by addresses with DEFAULT_ADMIN_ROLE
    function defultAdminFunction() public onlyRole(DEFAULT_ADMIN_ROLE) {
        // Default admin function implementation
    }
		
    // Function can only be called by addresses with ADMIN_ROLE
    function adminFunction() public onlyRole(ADMIN_ROLE) {
        // Admin function implementation
    }

    // Function can only be called by addresses with MINTER_ROLE
    function minterFunction() public onlyRole(MINTER_ROLE) {
        // Minter function implementation
    }
}
</code></pre>
<p>这段代码实现了以下的功能：</p>
<ol>
<li>设置默认管理员 <code>DEFAULT_ADMIN_ROLE</code> 为合约部署者 <code>deployer</code></li>
<li>设置 <code>address(0x02)</code> 为 <code>MINTER_ROLE</code> 权限角色</li>
<li>设置 <code>address(0x01)</code> 为 <code>MINTER_ROLE</code> 权限的管理员 <code>ADMIN_ROLE</code>，可以移除或添加 <code>MINTER_ROLE</code> 权限角色。</li>
<li><code>DEFAULT_ADMIN_ROLE</code> 默认作为 <code>ADMIN_ROLE</code> 的管理员，可以移除或添加 <code>ADMIN_ROLE</code> 权限角色。</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.007473371436342593" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-23 22:09">2025-03-23 22:08</span>&nbsp;
<a href="https://www.cnblogs.com/ACaiGarden">ACai_sec</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18788403" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18788403);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18788403', targetLink: 'https://www.cnblogs.com/ACaiGarden/p/18788403', title: '【技术分析】简单了解 AccessControl' })">举报</a>
</div>
        