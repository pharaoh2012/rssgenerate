
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TianTianChaoFangDe/p/18744980" title="发布于 2025-03-01 16:12">
    <span role="heading" aria-level="2">Codeforces Round 1007 (Div. 2) 比赛记录</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="codeforces-round-1007-div-2-比赛记录">Codeforces Round 1007 (Div. 2) 比赛记录</h1>
<p><a href="https://codeforces.com/contest/2071" target="_blank" rel="noopener nofollow">比赛链接</a><br>
很喜欢的一场比赛，题目质量很高，不是手速场，做出题超级有成就感，赛时切掉了 A - D1，上大分了。<br>
B卡得有点久，其实是一个很常用的构造手法但一开始没想到。<br>
过题记录：<br>
<img src="https://img2024.cnblogs.com/blog/3572902/202503/3572902-20250301151258920-923096484.png" alt="image" loading="lazy"></p>
<h2 id="a-the-play-never-ends">A. The Play Never Ends</h2>
<p>题意大概就是，每场两个人打，一个人观战。如果有一个人以及连续打了两场，则这场无论如何这个人都要下去，否则输的那个下去，问第 <span class="math inline">\(k\)</span> 场的时候第一场观战的人能否观战。<br>
假设第一场打的人分别是 A 和 B，A 获胜，观战者是 C，手玩一下小一点的样例发现，第二场 C 一定上场，此时 A 已经打了一场，那么 A 和 C 打完后，无论如何，下的都是 A，再打一场后，由于 C 已经打了两场了，所以无论如何，下的都是 C，如此进行下去可以发现，输赢无所谓，因为总有一方连续打了两场，必须下，因此实际上就是三个人轮换，所以 C 观战的时候就是 <span class="math inline">\(k \bmod 3 = 1\)</span> 的时候</p>
<pre><code class="language-cpp">void solve()
{
    int n;cin &gt;&gt; n;

    if(n % 3 == 1)cout &lt;&lt; "YES\n";
    else cout &lt;&lt; "NO\n";
}
</code></pre>
<h2 id="b-perfecto">B. Perfecto</h2>
<p><s>我愿称之为本场前四题最难题，因为我好友列表都被卡了。</s><br>
一开始我天真地以为只有 <span class="math inline">\(1\)</span> 是不可能的，因为公差为 <span class="math inline">\(1\)</span> 的等差数列求和公式，一个奇数一个偶数，偶数除以 <span class="math inline">\(2\)</span> 后一定不和这个奇数相等，除了 <span class="math inline">\(1\)</span>，但是，有没有可能，他们乘起来还是一个平方数，比如：<span class="math inline">\(8\)</span>。<br>
因此首先判断 <span class="math inline">\(-1\)</span> 的情况，也就是总和为平方数的情况，此时无论如何都无解因为总和是平方数。<br>
然后再看如何构造，这里用到了一个构造题很常用的手法，就是先把一般的搞出来，再去修。<br>
我们先初始化答案排列为 <span class="math inline">\(1 - n\)</span> 升序排列。<br>
然后依次遍历，并且记录前缀和，一旦当前 <span class="math inline">\(i\)</span> 的前缀和是平方数，那就交换 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i + 1}\)</span>，为什么？因为 <span class="math inline">\(a_{i + 1} = a_i + 1\)</span>，一个平方数 <span class="math inline">\(+1\)</span> 一定不是一个平方数。<br>
然后再来证一个事情，就是交换的时候 <span class="math inline">\(a_{i + 1} = a_i + 1\)</span>。<br>
假设当前为第 <span class="math inline">\(i\)</span>，因为前 <span class="math inline">\(i\)</span> 项和为 <span class="math inline">\((1 + i) \times i / 2\)</span>，那么前 <span class="math inline">\(i + 1\)</span> 项的和为 <span class="math inline">\((1 + i) \times (2 + i) / 2\)</span>，我们通过打表可以发现，平方数一定不会在相邻两项连续出现，因此若前 <span class="math inline">\(i\)</span> 项是平方数，交换后，前 <span class="math inline">\(i + 1\)</span> 项的值不会改变，仍然不是平方数，因此不会进行交换，也就不会影响后续相邻两项的 <span class="math inline">\(a_{i + 1} = a_i + 1\)</span>。</p>
<pre><code class="language-cpp">const int N = 5e5 + 9;
map&lt;int, bool&gt; vis;
int a[N];

void solve()
{
    int pre = 0;
    int n;cin &gt;&gt; n;

    if(vis.count((n + 1) * n / 2)) {
        cout &lt;&lt; -1 &lt;&lt; '\n';
        return;
    }

    for(int i = 1;i &lt;= n;i ++) {
        a[i] = i;
    }

    for(int i = 1;i &lt;= n;i ++) {
        if(vis.count(pre + a[i])) {
            swap(a[i], a[i + 1]);
        }
        pre += a[i];
    }

    for(int i = 1;i &lt;= n;i ++) {
        cout &lt;&lt; a[i] &lt;&lt; " \n"[i == n];
    }
}

void init() {
    for(int i = 1;i &lt; N;i ++) {
        vis[i * i] = true;
    }
}

signed main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);

    init();

    int t = 1;cin &gt;&gt; t;
    while(t --)solve();

    return 0;
}
</code></pre>
<h2 id="c-trapmigiano-reggiano">C. Trapmigiano Reggiano</h2>
<p>本场最有趣最好玩的题出现了！<br>
题意大概就是，一只老鼠，在树上一个起点，要去树上一个终点，现在要你构造出一个长度为 <span class="math inline">\(n\)</span> 的排列，逐一进行，每次老鼠都会朝着排列中这一位的数的结点的方向走去，让老鼠最后能抵达终点。<br>
手玩了好多样例后发现一定有解，以下是我的见解：<br>
我们以起点作为根，对于每一个结点，它至多有一个子结点的子树是包含终点的，因此我们要让老鼠先把非终点的子树走完。对于非终点的子树，我们从下往上选，一定是可以回到当前结点的，因为我们选的数是从下往上走的，我们的老鼠是从上往下走的，那么二者一定会相遇，而后就一起往上走回去。把非终点的子树选完后，再选择当前这个结点，把老鼠引回来，而后往终点子树走，继续按照上述流程递归下去，最后一定会到达终点。<br>
因此我的代码思路就是：先以起点为根 DFS 一次，标记一下每一棵子树是否有终点，然后再来一次 DFS，按照上述流程加点形成答案序列。<br>
赛后看了群里面大佬的解析并细细品味了一下我的代码，这不就是拓扑排序嘛，我们每次选择度为 <span class="math inline">\(1\)</span> 的非终点结点加进来，最后加终点，一定有解，或者是以终点为起点 BFS，按深度倒序输出。</p>
<pre><code class="language-cpp">const int N = 1e5 + 9;
vector&lt;int&gt; g[N];
bool dp[N];
int n, st, ed;
vector&lt;int&gt; ans;

void dfs(int now, int pre) {
    dp[now] = (now == ed);

    for(auto &amp;i : g[now]) {
        if(i == pre) {
            continue;
        }
        dfs(i, now);
        dp[now] = (dp[now] || dp[i]);
    }

    sort(g[now].begin(), g[now].end(), [] (const int &amp;u, const int &amp;v) {
        return dp[u] &lt; dp[v];
    });
}

void dfs1(int now, int pre) {
    for(auto &amp;i : g[now]) {
        if(i == pre) {
            continue;
        }
        if(dp[i])ans.push_back(now);
        dfs1(i, now);
    }
    if(!dp[now])ans.push_back(now);
}

void init(int n) {
    for(int i = 1;i &lt;= n;i ++) {
        g[i].clear();
        dp[i] = 0;
    }
    ans.clear();
}
 
void solve()
{
    cin &gt;&gt; n &gt;&gt; st &gt;&gt; ed;
    init(n);

    for(int i = 1;i &lt; n;i ++) {
        int u, v;cin &gt;&gt; u &gt;&gt; v;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    dfs(st, 0);
    dfs1(st, 0);

    ans.push_back(ed);

    for(auto &amp;i : ans) {
        cout &lt;&lt; i &lt;&lt; ' ';
    }

    cout &lt;&lt; '\n';
}
</code></pre>
<h2 id="d1-infinite-sequence-easy-version">D1. Infinite Sequence (Easy Version)</h2>
<p>思维难度远小于 C 题，我们可以发现，对于一个偶数 <span class="math inline">\(x\)</span> 和一个奇数 <span class="math inline">\(x + 1\)</span>，一定有 <span class="math inline">\(\lfloor x / 2 \rfloor = \lfloor (x + 1) / 2 \rfloor\)</span>，若 <span class="math inline">\(n\)</span> 为偶数，我们先多算一项把 <span class="math inline">\(n\)</span> 变成奇数，因此在第 <span class="math inline">\(n\)</span> 项后，相邻两项的值一定是相同的，又根据异或的性质，相同的数异或后的值为 <span class="math inline">\(0\)</span>，因此后面看似一段连续的序列，实则是离散的，有效点很少。<br>
我们采取递归实现，使用一个 <span class="math inline">\(get(x)\)</span> 函数来获取一个数 <span class="math inline">\(x\)</span> 的前缀异或和，如果 <span class="math inline">\(x\)</span> 为奇数，直接返回 <span class="math inline">\(pre_n\)</span>，因为 <span class="math inline">\(n\)</span> 之后全是 <span class="math inline">\(0\)</span>，如果 <span class="math inline">\(x\)</span> 为偶数，则用这个偶数的单点值，异或上 <span class="math inline">\(pre_n\)</span>，因为这个偶数之前到 <span class="math inline">\(n\)</span> 也全是 <span class="math inline">\(0\)</span>。</p>
<pre><code class="language-cpp">int get(int x) {
    if(x &lt;= n)return pre[x];

    if(x &amp; 1) {
        return pre[n];
    } else {
        return get(x / 2) ^ pre[n];
    }
}

void solve()
{
    cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;
    for(int i = 1;i &lt;= n;i ++)cin &gt;&gt; a[i];
    for(int i = 1;i &lt;= n;i ++)pre[i] = pre[i - 1] ^ a[i];
    
    if(n % 2 == 0) {
        n ++;
        a[n] = pre[n / 2];
        pre[n] = pre[n - 1] ^ a[n];
    } 

    if(l &lt;= n) {
        cout &lt;&lt; a[l] &lt;&lt; '\n';
        return;
    }
    
    cout &lt;&lt; get(l / 2) &lt;&lt; '\n';
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.17523963555324074" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-01 20:04">2025-03-01 16:12</span>&nbsp;
<a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>&nbsp;
阅读(<span id="post_view_count">22</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18744980" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18744980);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18744980', targetLink: 'https://www.cnblogs.com/TianTianChaoFangDe/p/18744980', title: 'Codeforces Round 1007 (Div. 2) 比赛记录' })">举报</a>
</div>
        