
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aser1989/p/18808385" title="发布于 2025-04-14 07:49">
    <span role="heading" aria-level="2">前端艺术实践：用Storybook构建交互式组件文档</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>对于前端来说，组件话已经从热门话题变成了基础能力，自定义组件或自建组件库已是再常见不过的事了。在实际工作中组件库的文档直接决定开发体验和效率，文档建设的重要性不言而喻。今天要推荐的工具叫Storybook，为此我特地通过<a href="https://www.cnblogs.com/aser1989/p/18797001" target="_blank">用99元买的服务器搭了一套CI/CD系统</a>部署了一套Demo，欢迎点击体验：<a href="https://ui.aser1989.cn/" target="_blank" rel="noopener nofollow">Demo</a> (首次加载速度尤为感人，请耐心等待。仅用于效果演示，希望大家别被这潦草的Demo迷惑)。组件库的文档不只是“写说明”，更要做到可视化、可交互、可复用——既能看、又能点、还能直接抄代码。能够满足这些需求的文档工具中，重点推荐以下两款：<strong>Dumi</strong> 和 <strong>Storybook</strong>。<br>
<br></p>
<h2 id="dumi">Dumi</h2>
<hr>
<p>Dumi是一款为组件开发场景而生的静态站点框架，它有个代表作：<a href="https://ant-design.antgroup.com/components/overview-cn/" target="_blank" rel="noopener nofollow">Ant Design</a>。不知是否有人跟我一样，第一眼看上的不是Ant Design的组件，而是它的组件库文档。真心嫉妒他们的这份文档，有案例、有代码、能交互，还有详细的参数说明。如果对它感兴趣可以点击<a href="https://d.umijs.org/" target="_blank" rel="noopener nofollow">Dumi传送门</a>。<br>
<br></p>
<h2 id="storybook">Storybook</h2>
<hr>
<p>Storybook 是一个开源项目，在 GitHub 上已有 83K+ star。它不仅用于构建组件库文档，还能用于组件测试。推荐 Storybook 的主要原因如下：</p>
<ol>
<li>可直接嵌入项目，在编写组件文档的同时进行组件编码和测试；</li>
<li>基于 TypeScript 组件类型定义自动生成组件参数文档；</li>
<li><strong>允许在文档中动态修改组件参数值，实时预览不同效果</strong>。</li>
<li>基础文档建设难度低（大多数 <a href="https://ui.aser1989.cn/" target="_blank" rel="noopener nofollow">Demo</a>  文档的编写时间不超过1分钟，主要得益于我的项目 <a href="https://www.aser1989.cn/" target="_blank" rel="noopener nofollow">Nebula Note</a>，可实现快速内容替换）。</li>
<li>文档中可以使用第三方库来丰富文档效果，如：Swiper、Mermaid、MathJax 等等。</li>
<li>支持多种框架（React、Vue、Angular 等等），并且支持多种语言（TypeScript、JavaScript、HTML、CSS 等等）。</li>
</ol>
<br>
<h2 id="安装">安装</h2>
<hr>
<p>1、在项目根目录下运行以下命令，Storybook 会自动检测你的框架（React、Vue、Angular 等）并进行相应的安装：</p>
<pre><code class="language-shell">npx storybook@latest init
</code></pre>
<p>安装过程可能需要几分钟，完成后它会添加必要的Storybook依赖并生成 .storybook 配置目录然后在 src/stories/ 目录中创建示例组件。</p>
<br>
<h2 id="运行">运行</h2>
<hr>
<pre><code class="language-shell">npm run storybook
</code></pre>
<p>默认情况下，Storybook 会在 <a href="http://localhost:6006/" target="_blank" rel="noopener nofollow">http://localhost:6006/</a> 运行。虽然我们一行代码都没写，但已经可以看到Storybook提供的示例组件文档。</p>
<br>
<h2 id="配置">配置</h2>
<hr>
<p>在编写文档前，首先应该决定文档的存放方式：</p>
<ul>
<li><strong>集中存放：</strong> 将所有文档统一放在指定目录，例如 src/stories/，类似于示例文档的管理方式。</li>
</ul>
<ol>
<li>优点：结构清晰，文档与业务代码解耦，方便统一管理。</li>
<li>适用场景：适合大规模组件库开发，尤其是需要独立维护文档的项目。</li>
</ol>
<ul>
<li><strong>跟随组件：</strong> 每个组件的 Story 文档与组件代码存放在一起，例如 src/components/Button/Button.stories.tsx。</li>
</ul>
<ol>
<li>优点：文档紧贴组件，便于开发和维护，不需要在多个目录之间跳转。</li>
<li>适用场景：适合产品型项目，组件文档随组件代码更新，保持同步。</li>
</ol>
<p>如果选择跟随组件，则需要调整.storybook/main.js（或 main.ts），并指定文档路径，示例代码如下：</p>
<pre><code class="language-typescript">
const config: StorybookConfig = {
    stories: ['../src/**/*.mdx', '../src/**/*.stories.@(js|jsx|mjs|ts|tsx)'],
</code></pre>
<br>
<h2 id="hello-world">Hello World</h2>
<hr>
<p>先分享一个React版的示例。新建一个文档<code>button.stories.ts</code>, 内容如下：</p>
<pre><code class="language-typescript">import { Meta, StoryObj } from '@storybook/react';
import Button, { ButtonProps } from './index';
import { action } from '@storybook/addon-actions';

export default {
    title: 'Atoms/Button',   // 组件在 Storybook 中的分组与显示路径。`'Atoms/Button'` 表示组件会在 `Atoms` 分组下展示为 `Button`。
    component: Button,       // 关联的 React 组件
    tags: ['autodocs'],      // `'autodocs'` 表示启用自动文档生成功能
    argTypes: {},            // 定义组件 props 的控制类型、分类、描述等
    args: {},                // 为组件设置默认的 props 值，在所有 stories 中共享，可在 UI 面板中修改
} as Meta&lt;ButtonProps&gt;;

export type Story = StoryObj&lt;ButtonProps&gt;;
export const Primary: Story = {
  // 指定组件运行的props值，可在 UI 面板中修改
    args: {
        children: 'Button',    
        type: 'primary',
        onClick: action('Button clicked'), 
    },
};

</code></pre>
<p>以上是一个完整的button文档代码。在 Storybook 的 stories 中，可以使用 actions 来监听按钮点击事件,<code>action('Button clicked')</code> 可以在 Action 面板上实时展示事件调用及参数，对于组件自测非常友好，能够帮助开发者快速验证组件的交互行为。<br>
<br><br>
秀一波原创专属文档效果（不是图片，可点击体验）:</p>

<div class="aser1989-demo-box">
<div class="demo-box-header" title="点击界面内容可进行互动"><span class="demo-box-title">效果预览</span><a href="https://ui.aser1989.cn/?path=/docs/atoms-button--docs&amp;from=cnblog" title="点击查看完整Demo" target="_blank" rel="noopener nofollow">完整Demo</a></div>

</div>
<br>
<h2 id="添加交互逻辑让组件动起来">添加交互逻辑：让组件动起来</h2>
<hr>
<p>为了让文档更生动直观，我们会添加一些带交互或状态的组件示例。由于在 Storybook 中的写法几乎和正常开发一样，我们需要将文件后缀改为 .tsx，以支持 JSX 和类型。先上示例代码，这是<a href="https://ui.aser1989.cn/" target="_blank" rel="noopener nofollow">Demo</a>中 <code>Dropdown</code> 组件搜索功能的文档代码片段：</p>
<pre><code class="language-typescript">import React, { useEffect } from 'react';
import { useArgs } from '@storybook/preview-api';
// 此处省略了组件文档定义相关代码
......
export const Primary: Story = {
    args: {
        enableTags: [
            {
                tag: 'two',
                color: '#ff0000',
            },
            {
                tag: 'four',
                color: 'orange',
            },
        ],
        options: [],
    },
    render: () =&gt; {
        const options = [
            {
                value: '1',
                label: 'Option one',
                keyword: '1',
            },
            {
                value: '2',
                label: 'Option two',
                keyword: '2',
            },
            {
                value: '3',
                label: 'Option three',
                keyword: '3',
            },
            {
                value: '4',
                label: 'Option four',
                keyword: '4',
            },
        ];
        const [args, updateArgs] = useArgs&lt;DropdownProps&lt;string&gt;&gt;();
        useEffect(() =&gt; {
            updateArgs({ options: options });
        }, []);
        const handleSearch = (keyword?: string) =&gt; {
            if (keyword) {
                const newOptions = options.filter((option) =&gt;
                    option.label?.includes(keyword),
                );
                updateArgs({ options: newOptions });
            } else {
                updateArgs({ options: options });
            }
        };

        return &lt;Dropdown {...args} onSearch={handleSearch} /&gt;;
    },
};

</code></pre>
<p>因为Dropdown是一个受控组件，所以这里使用了Storybook的<code>useArgs</code> 这个hooks，目的是为了把结果更新到参数面板上。从代码片段上可以看出，Storybook支持我们添加一个<code>render</code>函数来实现自定义的文档逻辑和效果，在<code>render</code>函数中我们可以正常使用<code>React</code>的功能。</p>
<div class="aser1989-demo-box">
<div class="demo-box-header" title="点击界面内容可进行互动"><span class="demo-box-title">效果预览</span><a href="https://ui.aser1989.cn/?path=/docs/atoms-dropdown--docs&amp;from=cnblog" title="点击查看完整Demo" target="_blank" rel="noopener nofollow">完整Demo</a></div>

</div>
<br>
<h2 id="丰富文档内容自动生成-vs-手动编辑">丰富文档内容：自动生成 vs 手动编辑</h2>
<hr>
<p>在<code>Storybook</code>中， 有两种方式可以为文档添加丰富的图文介绍：</p>
<ul>
<li>使用<code>Autodocs</code>自动生成的基础模板,通过Meta配置的<code>parameters.docs</code>属性，为组件添加介绍内容；</li>
<li>使用<code>MDX</code>为每个组件创建自定义的文档页面。</li>
</ul>
<br>
<h3 id="autodocs">Autodocs</h3>
<p>Autodocs 是 Storybook 的一个功能，它通过读取<code>Meta</code>中<code>parameters.docs</code>属性内容自动生成组件文档。Autodocs 生成的文档会优先展示第一个示例（Primary）的内容以及组件的Props列表，然后再依次展示所有的Story。如：</p>
<div class="aser1989-demo-box">
<div class="demo-box-header" title="点击界面内容可进行互动"><span class="demo-box-title">多个Story示例</span><a href="https://ui.aser1989.cn/iframe.html?viewMode=docs&amp;id=molecules-dialog--docs&amp;globals=&amp;from=cnblog" title="点击查看完整Demo" target="_blank" rel="noopener nofollow">完整Demo</a></div>

</div>
<p>Autodocs 的使用方式非常简单，如同上面的案例一样，只需在<code>export default</code>的内容中添加<code> tags: ['autodocs'],</code>即可（ <a href="#hello-world" rel="noopener nofollow">跳转至Hello World</a>查看代码 ）。</p>
<br>
<h3 id="mdx">MDX</h3>
<p>MDX 是 Storybook 提供的一项强大功能，它允许我们在文档中同时使用 Markdown 和 JSX（Vue 用户也可以使用相应语法），从而打造更灵活、更可控的组件文档体验。借助 MDX，我们不仅可以像写博客一样撰写说明文字，还可以在任意位置嵌入组件实例、添加交互示例、引入自定义样式和布局，甚至封装文档模板来复用常见结构。</p>
<p>相比于 Storybook 的 Autodocs（自动生成的参数+交互页面），MDX 提供了完全的内容主导权，我们可以自由决定文档的结构、顺序与样式：比如先讲背景、再展示组件、最后讲参数，或者将多个组件组合成场景化示例页，而不受自动文档生成逻辑的限制。</p>
<p>这种方式特别适合需要讲解上下文、构建复杂交互示例，或者进行教学类文档的场景。它让组件文档不仅“可用”，还“可讲、可演示”，真正实现文档与设计、开发的融合。</p>
<br>
<h2 id="最后">最后</h2>
<hr>
<p>组件文档不是附加项，而是组件库的标配。Storybook 不仅能写文档，还支持组件自动化测试，真的是又能打又好用。如果你还没试过，强烈建议亲自体验一下！</p>
<p>我已将部分 Storybook 相关文档整理发布在个人网站（<a href="https://www.aser1989.cn/docs/storybook/intro" target="_blank" rel="noopener nofollow">aser1989.cn</a>）上，欢迎查阅。</p>
<p>感谢阅读，觉得不错的话，欢迎点赞支持～✌️</p>

</div>
<div id="MySignature" role="contentinfo">
    <br><br> <hr> <p><br>本文来自博客园<br>作者：<a href="https://www.cnblogs.com/aser1989/" target="_blank">ASER_1989</a><br>转载请注明原文链接：<a href="https://www.cnblogs.com/aser1989/p/18808385" target="_blank">https://www.cnblogs.com/aser1989/p/18808385</a></p>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.056817099849537034" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-14 07:49">2025-04-14 07:49</span>&nbsp;
<a href="https://www.cnblogs.com/aser1989">ASER_1989</a>&nbsp;
阅读(<span id="post_view_count">29</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18808385);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18808385', targetLink: 'https://www.cnblogs.com/aser1989/p/18808385', title: '前端艺术实践：用Storybook构建交互式组件文档' })">举报</a>
</div>
	