
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hont/p/18651183" title="发布于 2025-01-06 00:07">
    <span role="heading" aria-level="2">Unity TheHeretic Gawain Demo 异教徒Demo技术学习</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><img src="https://img2024.cnblogs.com/blog/519009/202501/519009-20250105160450932-1989076453.png" alt="" width="687" height="391"></p>
<p>《异教徒 Heretic》是Unity在2019年GDC大会上展示的一款技术Demo，部分资源于2020年中旬公开下载。</p>
<p>这款Demo主要用于展示Unity在数字人技术领域的最新进展，尤其是在写实数字人渲染和面部动画的处理上。</p>
<p>&nbsp;</p>
<p>在写实数字人建模中，面部肌肉的每一处细微变化都会对最终的视觉效果产生显著影响。</p>
<p>传统的基于表情基和骨骼驱动的面部动画方案，虽然能够提供较为流畅的表现，但在精度和真实感上往往存在差距。</p>
<p>为了追求更高的真实还原度，《异教徒》Demo采用了前沿的4D捕捉技术。这项技术通过硬件设备精确捕捉每一帧的面部表情数据，</p>
<p>并通过先进的拟合算法进行实时重建，从而实现了前所未有的细节还原和视觉真实感。</p>
<p>&nbsp;</p>
<p>官方Blog：</p>
<p><a href="https://unity.com/blog/technology/making-of-the-heretic-digital-human-character-gawain" target="_blank" rel="noopener nofollow">https://unity.com/blog/technology/making-of-the-heretic-digital-human-character-gawain</a></p>
<p>&nbsp;</p>
<p>百度网盘缓存Demo下载地址（测试所使用版本Unity2021.3.26，HDRP 12）：</p>
<p>链接: <a href="https://pan.baidu.com/s/1Mk3X8VZpeoQq-w5SfmsE2g" target="_blank" rel="noopener nofollow">https://pan.baidu.com/s/1Mk3X8VZpeoQq-w5SfmsE2g</a> 提取码: f75e</p>
<h1>1.SkinDeformation</h1>
<p>这部分主要处理4D设备捕捉到的表情动画，到Unity这个环节的数据应该是经过Wrap3D处理，</p>
<p>直接播放Demo场景里的Timeline即可单独预览：</p>
<p><img src="https://img2024.cnblogs.com/blog/519009/202501/519009-20250104000721337-163648835.png" alt="" width="953" height="592"></p>
<p>&nbsp;SkinDeformationClip是一个SO文件，存放烘焙好的动画信息，而SkinDeformationRenderer负责表情数据的最终渲染输出。</p>
<h2>1.1&nbsp;SkinDeformationRenderer</h2>
<p>该脚本会读取blendInputs字段中的数据并拿来进行处理，该字段的赋值在SkinDeformationTimeline中：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">var</span> inputA =<span style="color: rgba(0, 0, 0, 1)"> playable.GetInput(inputIndexA);
</span><span style="color: rgba(0, 0, 255, 1)">var</span> inputB =<span style="color: rgba(0, 0, 0, 1)"> playable.GetInput(inputIndexB);

</span><span style="color: rgba(0, 0, 255, 1)">var</span> assetA = ((ScriptPlayable&lt;SkinDeformationPlayable&gt;<span style="color: rgba(0, 0, 0, 1)">)inputA).GetBehaviour().clip;
</span><span style="color: rgba(0, 0, 255, 1)">var</span> assetB = ((ScriptPlayable&lt;SkinDeformationPlayable&gt;<span style="color: rgba(0, 0, 0, 1)">)inputB).GetBehaviour().clip;
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">赋值处：</span>
target.SetBlendInput(<span style="color: rgba(128, 0, 128, 1)">0</span>, assetA, (<span style="color: rgba(0, 0, 255, 1)">float</span>)(inputA.GetTime() /<span style="color: rgba(0, 0, 0, 1)"> assetA.Duration), inputWeightA);
target.SetBlendInput(</span><span style="color: rgba(128, 0, 128, 1)">1</span>, assetB, (<span style="color: rgba(0, 0, 255, 1)">float</span>)(inputB.GetTime() / assetB.Duration), inputWeightB);</pre>
</div>
<p>&nbsp;</p>
<p>该脚本中的数据结构有标记Lo、Hi后缀字段，看上去似乎和低频高频数据有关，但实际上储存的是</p>
<p>当前帧和上一帧数据，以及插值数值。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i != subframeCount; i++<span style="color: rgba(0, 0, 0, 1)">)
{
    subframes[i].frameIndexLo </span>=<span style="color: rgba(0, 0, 0, 1)"> i;
    subframes[i].frameIndexHi </span>= i + <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
    subframes[i].fractionLo </span>= <span style="color: rgba(128, 0, 128, 1)">0.0f</span><span style="color: rgba(0, 0, 0, 1)">;
    subframes[i].fractionHi </span>= <span style="color: rgba(128, 0, 128, 1)">1.0f</span><span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<p>还有一组Albedo的有关数据，但没有看到被使用：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span> BlendInputShaderPropertyIDs[] BlendInputShaderProperties =<span style="color: rgba(0, 0, 0, 1)">
{
    </span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> BlendInputShaderPropertyIDs()
    {
        _FrameAlbedoLo </span>= Shader.PropertyToID(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">_BlendInput0_FrameAlbedoLo</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
        _FrameAlbedoHi </span>= Shader.PropertyToID(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">_BlendInput0_FrameAlbedoHi</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
        _FrameFraction </span>= Shader.PropertyToID(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">_BlendInput0_FrameFraction</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
        _ClipWeight </span>= Shader.PropertyToID(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">_BlendInput0_ClipWeight</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
    },
    </span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> BlendInputShaderPropertyIDs()
    {
        _FrameAlbedoLo </span>= Shader.PropertyToID(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">_BlendInput1_FrameAlbedoLo</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
        _FrameAlbedoHi </span>= Shader.PropertyToID(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">_BlendInput1_FrameAlbedoHi</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
        _FrameFraction </span>= Shader.PropertyToID(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">_BlendInput1_FrameFraction</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
        _ClipWeight </span>= Shader.PropertyToID(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">_BlendInput1_ClipWeight</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">),
    },
};</span></pre>
</div>
<p>&nbsp;</p>
<p>数据在导入时会通过MeshLaplacian进行降噪：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">var</span> laplacianResolve = (laplacianConstraintCount &lt;<span style="color: rgba(0, 0, 0, 1)"> frameVertexCount);
</span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (laplacianResolve)
{
</span><span style="color: rgba(0, 0, 255, 1)">#if</span> SOLVE_FULL_LAPLACIAN<span style="color: rgba(0, 0, 0, 1)">
    laplacianTransform </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> MeshLaplacianTransform(weldedAdjacency, laplacianConstraintIndices);
</span><span style="color: rgba(0, 0, 255, 1)">#else</span><span style="color: rgba(0, 0, 0, 1)">
    laplacianTransform </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> MeshLaplacianTransformROI(weldedAdjacency, laplacianROIIndices, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">);
    {
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i != denoiseIndices.Length; i++<span style="color: rgba(0, 0, 0, 1)">)
            denoiseIndices[i] </span>=<span style="color: rgba(0, 0, 0, 1)"> laplacianTransform.internalFromExternal[denoiseIndices[i]];
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i != transplantIndices.Length; i++<span style="color: rgba(0, 0, 0, 1)">)
            transplantIndices[i] </span>=<span style="color: rgba(0, 0, 0, 1)"> laplacianTransform.internalFromExternal[transplantIndices[i]];
    }
</span><span style="color: rgba(0, 0, 255, 1)">#endif</span><span style="color: rgba(0, 0, 0, 1)">
    laplacianTransform.ComputeMeshLaplacian(meshLaplacianDenoised, meshBuffersReference);
    laplacianTransform.ComputeMeshLaplacian(meshLaplacianReference, meshBuffersReference);
}</span></pre>
</div>
<p>&nbsp;</p>
<p>在SkinDeformationClipEditor.cs中存放有ImportClip的逻辑。</p>
<p>当点击SO的Import按钮时触发。</p>
<p>&nbsp;</p>
<h2>1.2&nbsp;SkinDeformationFitting</h2>
<p>该脚本主要通过最小二乘得到拟合表情的各个BlendShape权重。</p>
<p>并通过Accord.NET子集得到非负数结果，这个在官方技术文章里有提到。</p>
<p>&nbsp;最小二乘后的计算结果会存放在frames.fittedWeights中：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> remap weights to shape indices</span>
<span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> j = <span style="color: rgba(128, 0, 128, 1)">0</span>; j != sharedJobData.numVariables; j++<span style="color: rgba(0, 0, 0, 1)">)
{
    sharedJobData.frames[k].fittedWeights[sharedJobData.blendShapeIndices[j]] </span>= (<span style="color: rgba(0, 0, 255, 1)">float</span><span style="color: rgba(0, 0, 0, 1)">)x[j];
}</span></pre>
</div>
<p>在运行时存放在：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> SkinDeformationClip : ScriptableObject
{
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">unsafe</span> <span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> Frame
    {
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">float</span>*<span style="color: rgba(0, 0, 0, 1)"> deltaPositions;
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">float</span>*<span style="color: rgba(0, 0, 0, 1)"> deltaNormals;
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">float</span>* fittedWeights;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">&lt;---</span>
        <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> Texture2D albedo;
    }</span></pre>
</div>
<p>最后会传入Renderer：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> SkinDeformationRenderer : MeshInstanceBehaviour
{
    [NonSerialized]
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">float</span>[] fittedWeights = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">float</span>[<span style="color: rgba(128, 0, 128, 1)">0</span>];<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> used externally</span></pre>
</div>
<p>&nbsp;</p>
<p>在Renderer中混合代码如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i != fittedWeights.Length; i++<span style="color: rgba(0, 0, 0, 1)">)
    smr.SetBlendShapeWeight(i, </span><span style="color: rgba(128, 0, 128, 1)">100.0f</span> * (fittedWeights[i] * renderFittedWeightsScale));</pre>
</div>
<p>&nbsp;</p>
<p>补充：当最小二乘逻辑执行时，若当前矩阵与b矩阵数值相差过大，则结果越接近于0，反之矩阵之间数值越接近则结果数值越大。</p>
<p>在最小二乘法求解过程中，如果<strong>当前矩阵</strong>与<strong>b矩阵</strong><span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="base"><span class="strut"><span class="mord mathnormal">之间的数值差异较大，那么解的结果通常会趋近于零。</span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="base"><span class="strut"><span class="mord mathnormal">相反，<strong>当前矩阵</strong>与<strong>b矩阵</strong><span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="base"><span class="strut"><span class="mord mathnormal">的数值较为接近时，求解结果的数值则相对较大。</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="base"><span class="strut"><span class="mord mathnormal"><span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="base"><span class="strut"><span class="mord mathnormal">这一点也符合最终混合权重系数时的逻辑。</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<h2>1.3 Frame信息读取</h2>
<p>在Renderer脚本中，会调用clip.GetFrame获得当前帧的信息。即Clip中的</p>
<p>这样一个unsafe结构：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> SkinDeformationClip : ScriptableObject
{
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">unsafe</span> <span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> Frame
    {
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">float</span>*<span style="color: rgba(0, 0, 0, 1)"> deltaPositions;
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">float</span>*<span style="color: rgba(0, 0, 0, 1)"> deltaNormals;
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">float</span>*<span style="color: rgba(0, 0, 0, 1)"> fittedWeights;
        </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> Texture2D albedo;
    }</span></pre>
</div>
<p>&nbsp;</p>
<p>读取时会从frameData取得数据，该字段为NativeFrameStream类型，内部为Unity的异步文件读取实现。</p>
<p>加载时，如果是编辑器下就从对应目录的bin文件加载否则从StreamingAssets加载：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> LoadFrameData()
{
</span><span style="color: rgba(0, 0, 255, 1)">#if</span> UNITY_EDITOR
    <span style="color: rgba(0, 0, 255, 1)">string</span> filename = AssetDatabase.GetAssetPath(<span style="color: rgba(0, 0, 255, 1)">this</span>) + <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">_frames.bin</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">#else</span>
    <span style="color: rgba(0, 0, 255, 1)">string</span> filename = Application.streamingAssetsPath +<span style="color: rgba(0, 0, 0, 1)"> frameDataStreamingAssetsPath;
    Debug.Log(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">LoadFrameData </span><span style="color: rgba(128, 0, 0, 1)">"</span> + filename + <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">)</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 0, 255, 1)">#endif</span></pre>
</div>
<h1>2.SnappersHead</h1>
<p>该脚本提供对控制器、BlendShape、Mask贴图强度信息的逻辑控制。</p>
<h2>2.1 控制器</h2>
<p><img src="https://img2024.cnblogs.com/blog/519009/202501/519009-20250105230501965-1982343282.png" alt="" width="472" height="521"></p>
<p>在场景中选中挂有SnappersHeadRenderer脚本的对象，即可在编辑器下预览控制器。</p>
<p>这里控制器只是GameObject，概念上的控制器。</p>
<p>它类似于DCC工具中的控制器导出的空对象，通过脚本获得数值，并在LateUpdate中输出到BlendShape从而起作用。</p>
<p>在层级面板位于Gawain_SnappersControllers/Controllers_Parent下，模板代码使用了136个控制器，</p>
<p>Gawain角色并没有使用所有控制器。</p>
<h2>2.2&nbsp;BlendShape &amp;&nbsp;Mask贴图</h2>
<p>SnappersHead脚本中主要是对之前SkinDeformation处理过的BlendShape进行钳制，</p>
<p>其代码应该是自动生成的：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">unsafe</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> ResolveBlendShapes(<span style="color: rgba(0, 0, 255, 1)">float</span>* a, <span style="color: rgba(0, 0, 255, 1)">float</span>* b, <span style="color: rgba(0, 0, 255, 1)">float</span>*<span style="color: rgba(0, 0, 0, 1)"> c)
        {
            b[</span><span style="color: rgba(128, 0, 128, 1)">191</span>] = max(0f, a[<span style="color: rgba(128, 0, 128, 1)">872</span>] / <span style="color: rgba(128, 0, 128, 1)">2.5f</span><span style="color: rgba(0, 0, 0, 1)">);
            b[</span><span style="color: rgba(128, 0, 128, 1)">192</span>] = max(0f, a[<span style="color: rgba(128, 0, 128, 1)">870</span>] / <span style="color: rgba(128, 0, 128, 1)">2.5f</span><span style="color: rgba(0, 0, 0, 1)">);
            b[</span><span style="color: rgba(128, 0, 128, 1)">193</span>] = max(0f, (0f - a[<span style="color: rgba(128, 0, 128, 1)">872</span>]) / <span style="color: rgba(128, 0, 128, 1)">2.5f</span><span style="color: rgba(0, 0, 0, 1)">);
            b[</span><span style="color: rgba(128, 0, 128, 1)">294</span>] = linstep(0f, <span style="color: rgba(128, 0, 128, 1)">0.2f</span>, max(0f, (0f - a[<span style="color: rgba(128, 0, 128, 1)">871</span>]) / <span style="color: rgba(128, 0, 128, 1)">2.5f</span><span style="color: rgba(0, 0, 0, 1)">));
            b[</span><span style="color: rgba(128, 0, 128, 1)">295</span>] = linstep(<span style="color: rgba(128, 0, 128, 1)">0.2f</span>, <span style="color: rgba(128, 0, 128, 1)">0.4f</span>, max(0f, (0f - a[<span style="color: rgba(128, 0, 128, 1)">871</span>]) / <span style="color: rgba(128, 0, 128, 1)">2.5f</span><span style="color: rgba(0, 0, 0, 1)">));
            b[</span><span style="color: rgba(128, 0, 128, 1)">296</span>] = linstep(<span style="color: rgba(128, 0, 128, 1)">0.4f</span>, <span style="color: rgba(128, 0, 128, 1)">0.6f</span>, max(0f, (0f - a[<span style="color: rgba(128, 0, 128, 1)">871</span>]) / <span style="color: rgba(128, 0, 128, 1)">2.5f</span><span style="color: rgba(0, 0, 0, 1)">));
            b[</span><span style="color: rgba(128, 0, 128, 1)">297</span>] = linstep(<span style="color: rgba(128, 0, 128, 1)">0.6f</span>, <span style="color: rgba(128, 0, 128, 1)">0.8f</span>, max(0f, (0f - a[<span style="color: rgba(128, 0, 128, 1)">871</span>]) / <span style="color: rgba(128, 0, 128, 1)">2.5f</span><span style="color: rgba(0, 0, 0, 1)">));
            b[</span><span style="color: rgba(128, 0, 128, 1)">298</span>] = linstep(<span style="color: rgba(128, 0, 128, 1)">0.8f</span>, 1f, max(0f, (0f - a[<span style="color: rgba(128, 0, 128, 1)">871</span>]) / <span style="color: rgba(128, 0, 128, 1)">2.5f</span><span style="color: rgba(0, 0, 0, 1)">));
            b[</span><span style="color: rgba(128, 0, 128, 1)">129</span>] = hermite(0f, 0f, 4f, -4f, max(0f, (0f - a[<span style="color: rgba(128, 0, 128, 1)">541</span>]) / <span style="color: rgba(128, 0, 128, 1)">2.5f</span><span style="color: rgba(0, 0, 0, 1)">));
            b[</span><span style="color: rgba(128, 0, 128, 1)">130</span>] = max(0f, a[<span style="color: rgba(128, 0, 128, 1)">542</span>] / <span style="color: rgba(128, 0, 128, 1)">2.5f</span><span style="color: rgba(0, 0, 0, 1)">);
            b[</span><span style="color: rgba(128, 0, 128, 1)">127</span>] = max(0f, (0f - a[<span style="color: rgba(128, 0, 128, 1)">542</span>]) / <span style="color: rgba(128, 0, 128, 1)">2.5f</span><span style="color: rgba(0, 0, 0, 1)">);
            b[</span><span style="color: rgba(128, 0, 128, 1)">34</span>] = max(0f, (0f - a[<span style="color: rgba(128, 0, 128, 1)">301</span>]) / <span style="color: rgba(128, 0, 128, 1)">2.5f</span><span style="color: rgba(0, 0, 0, 1)">);
...</span></pre>
</div>
<p>Mask贴图也是类似的方式，对Albedo、Normal、Cavity三中贴图进行后期优化与钳制，</p>
<p>最后将Mask混合强度信息传入Shader。</p>
<h1>3.SkinAttachment粘附工具</h1>
<p>这一块主要是眉毛等物件在蒙皮网格上的粘附。</p>
<p>与UE Groom装配的做法类似，通过三角形重心坐标反求回拉伸后的网格位置。</p>
<p>（UE Groom官方讲解： <a href="https://www.bilibili.com/video/BV1k5411f7JD" target="_blank" rel="noopener nofollow">https://www.bilibili.com/video/BV1k5411f7JD</a>)</p>
<p>&nbsp;</p>
<p>SkinAttachment组件表示每个粘附物件，SkinAttachmentTarget组件表示所有粘附物件的父容器，</p>
<p>模型顶点和边信息查找用到了KDTree，在项目内的KdTree3.cs脚本中，</p>
<p>三角形重心坐标相关函数在Barycentric.cs脚本中。</p>
<p>查找时，每个独立Mesh块被定义为island，在这个结构之下再去做查找，</p>
<p>例如眉毛的islands如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/519009/202501/519009-20250105234622065-487270511.png" alt="" width="639" height="364"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>通过Editor代码，每个挂载有SkinAttachment组件的面板上会重绘一份Target Inspector GUI，方便编辑。</p>
<p>当点击编辑器下Attach按钮时，会调用到SkinAttachment的Attach函数：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> Attach(<span style="color: rgba(0, 0, 255, 1)">bool</span> storePositionRotation = <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">)
{
    EnsureMeshInstance();

    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (targetActive != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">)
        targetActive.RemoveSubject(</span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">);

    targetActive </span>=<span style="color: rgba(0, 0, 0, 1)"> target;
    targetActive.AddSubject(</span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">);

    </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (storePositionRotation)
    {
        attachedLocalPosition </span>=<span style="color: rgba(0, 0, 0, 1)"> transform.localPosition;
        attachedLocalRotation </span>=<span style="color: rgba(0, 0, 0, 1)"> transform.localRotation;
    }

    attached </span>= <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<p>&nbsp;</p>
<p>SkinAttachmentTarget组件会在编辑器下保持执行，因此在更新到LateUpdate时候会触发如下逻辑：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> LateUpdate()
{
    </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (UpdateMeshBuffers())
    {
        ResolveSubjects();
    }
}</span></pre>
</div>
<h1>4.眼球</h1>
<h2>4.1 眼球结构</h2>
<p>说一下几个关键性的结构：</p>
<ul>
<li>角膜（cornea） 最外边的结构，位于房水之外，它的主要作用是屈光，帮助光线聚焦到眼内</li>
<li>房水（aqueoushumor）晶状体后的半球形水体，图形上经常要处理的眼球焦散、折射都是因为存在该结构的原因</li>
<li>虹膜（Iris）关键性的结构，位于晶状体外，房水内。眼睛颜色不同也是因为该结构的色素不一样导致，虹膜起到收缩瞳孔的效果</li>
<li>瞳孔（pupil）不多解释</li>
<li>巩膜（sclera）眼白部分，通常需要一张带血丝的眼白贴图</li>
</ul>
<p>虽然房水这样的结构在多数图形相关文章中未被提起，但博主认为物理层面这仍很重要。</p>
<h2>4.2&nbsp;EyeRenderer</h2>
<p>该Demo中的EyeRenderer实现了角膜、瞳孔、巩膜等效果的参数调节，后续这块内容被集成在HDRP的Eye Shader中，</p>
<p>并在Ememies Demo中得到再次升级。</p>
<h2>4.3 眼球AO</h2>
<p>使用ASG制作了眼球AO，ASG指AnisotropicSphericalGaussian各向异性球面高斯。</p>
<p>隐藏面部网格后，单独调节参数效果：</p>
<p><img src="https://img2024.cnblogs.com/blog/519009/202501/519009-20250106001411248-312622651.jpg" alt="" width="464" height="400"></p>
<p>&nbsp;</p>
<p>该技术类似球谐函数的其中一个波瓣，参数可自行微调。</p>
<p>将ASG单独提取测试效果：</p>
<p><img src="https://img2024.cnblogs.com/blog/519009/202501/519009-20250105173942657-889596777.jpg" alt="" width="857" height="324"></p>
<p>原代码中给到了2个该技术的参考链接：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> AnisotropicSphericalSuperGaussian
{
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> (Anisotropic) Higher-Order Gaussian Distribution aka (Anisotropic) Super-Gaussian Distribution extended to be evaluated across the unit sphere.
    </span><span style="color: rgba(0, 128, 0, 1)">//</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Source for Super-Gaussian Distribution:
    </span><span style="color: rgba(0, 128, 0, 1)">//</span> <span style="color: rgba(0, 128, 0, 1); text-decoration: underline">https://en.wikipedia.org/wiki/Gaussian_function</span><span style="color: rgba(0, 128, 0, 1)">#Higher-order_Gaussian_or_super-Gaussian_function
    </span><span style="color: rgba(0, 128, 0, 1)">//</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Source for Anisotropic Spherical Gaussian Distribution:
    </span><span style="color: rgba(0, 128, 0, 1)">//</span> <span style="color: rgba(0, 128, 0, 1); text-decoration: underline">http://www.jp.square-enix.com/info/library/pdf/Virtual%20Spherical%20Gaussian%20Lights%20for%20Real-Time%20Glossy%20Indirect%20Illumination%20</span><span style="color: rgba(0, 128, 0, 1)">(supplemental%20material).pdf
    </span><span style="color: rgba(0, 128, 0, 1)">//
</span>    <span style="color: rgba(0, 0, 255, 1)">float</span><span style="color: rgba(0, 0, 0, 1)"> amplitude;
    float2 sharpness;
    </span><span style="color: rgba(0, 0, 255, 1)">float</span><span style="color: rgba(0, 0, 0, 1)"> power;
    float3 mean;
    float3 tangent;
    float3 bitangent;
};</span></pre>
</div>
<h1>5.Teeth&amp;Jaw 颌骨</h1>
<h2>5.1 下颌骨位置修正</h2>
<p>TeethJawDriver脚本提供了修改参数Jaw Forward，可单独对下颌位置进行微调，</p>
<p>隐藏了头部网格后非常明显（右侧参数为2）：</p>
<p><img src="https://img2024.cnblogs.com/blog/519009/202501/519009-20250105233849502-1375098345.jpg" alt="" width="686" height="154"></p>
<p>另外该参数没有被动画驱动。</p>
<p>&nbsp;</p>
<h2>5.2 颌骨AO</h2>
<p>颌骨AO（或者叫衰减更合理）通过外部围绕颌骨的6个点（随蒙皮绑定）代码计算得到。</p>
<p><img src="https://img2024.cnblogs.com/blog/519009/202501/519009-20250104225101190-7719450.png" alt="" width="649" height="307"></p>
<p>&nbsp;</p>
<p>通过球面多边形技术实现，在SphericalPolygon.hlsl中可查看：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">void</span> SphericalPolygon_CalcInteriorAngles(<span style="color: rgba(0, 0, 255, 1)">in</span> float3 P[SPHERICALPOLYGON_MAX_VERTS], <span style="color: rgba(0, 0, 255, 1)">out</span> <span style="color: rgba(0, 0, 255, 1)">float</span><span style="color: rgba(0, 0, 0, 1)"> A[SPHERICALPOLYGON_MAX_VERTS])
{
    </span><span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">int</span> LAST_VERT = (SPHERICALPOLYGON_NUM_VERTS - <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">);

    float3 N[SPHERICALPOLYGON_MAX_VERTS];

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> calc plane normals
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> where N[i] = normal of incident plane
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">   eg. N[i+0] = cross(C, A);
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">       N[i+1] = cross(A, B);</span>
<span style="color: rgba(0, 0, 0, 1)">    {
        N[</span><span style="color: rgba(128, 0, 128, 1)">0</span>] = -normalize(cross(P[LAST_VERT], P[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">]));
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">1</span>; i != SPHERICALPOLYGON_NUM_VERTS; i++<span style="color: rgba(0, 0, 0, 1)">)
        {
            N[i] </span>= -normalize(cross(P[i - <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">], P[i]));
        }
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> calc interior angles</span>
<span style="color: rgba(0, 0, 0, 1)">    {
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i != LAST_VERT; i++<span style="color: rgba(0, 0, 0, 1)">)
        {
            A[i] </span>= PI - sign(dot(N[i], P[i + <span style="color: rgba(128, 0, 128, 1)">1</span>])) * acos(clamp(dot(N[i], N[i + <span style="color: rgba(128, 0, 128, 1)">1</span>]), -<span style="color: rgba(128, 0, 128, 1)">1.0</span>, <span style="color: rgba(128, 0, 128, 1)">1.0</span><span style="color: rgba(0, 0, 0, 1)">));
        }
        A[LAST_VERT] </span>= PI - sign(dot(N[LAST_VERT], P[<span style="color: rgba(128, 0, 128, 1)">0</span>])) * acos(clamp(dot(N[LAST_VERT], N[<span style="color: rgba(128, 0, 128, 1)">0</span>]), -<span style="color: rgba(128, 0, 128, 1)">1.0</span>, <span style="color: rgba(128, 0, 128, 1)">1.0</span><span style="color: rgba(0, 0, 0, 1)">));
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<h1>6.杂项</h1>
<h2>6.1 ArrayUtils.ResizeCheckedIfLessThan</h2>
<p>项目中许多数组都使用了这个方法，该方法可确保目标缓存数组的长度不小于来源数组。</p>
<p>一方面避免使用List，另一方面可很好的做到缓存，避免预分配。</p>
<p>该类还提供了一个ArrayUtils.CopyChecked接口，可直接执行分配+拷贝。</p>
<p>&nbsp;</p>
<h2>6.2 头部骨架</h2>
<p>头部使用FACS (Facial Action Coding System) 骨架结构进行搭建。</p>
<p>&nbsp;</p>
<h2>6.3 总结</h2>
<p>在该Demo中，网格处理相对复杂，尤其是通过MeshAdjacency进行了顶点融合等操作。</p>
<p>这点在SkinAttachment粘附部分运用较多，时间原因不继续展开研究。</p>
<p>这些技术在Enemies Demo中得到了进一步升级。</p>
<p>项目中广泛使用了指针操作与Unity Job系统的结合，虽然不能确定仅仅使用指针就一定优于Unity.Mathematics，</p>
<p>但这一做法在性能优化上可能有所帮助。</p>
<p>&nbsp;</p>
<p>可以预见，从传统的骨骼蒙皮技术，到更精细的面部肌肉拉伸蒙皮，再到利用机器学习实现的布料模拟，</p>
<p>角色渲染的提升方向至少已经有了明确的思路可循。在实时渲染领域，技术的不断进步为未来的渲染效果提供了新的可能性。</p>
<p>&nbsp;</p>
<hr>
<p><strong>&nbsp;参考&amp;扩展阅读：</strong></p>
<p>官方Blog Heretic Demo页：<a href="https://unity.com/blog/technology/making-of-the-heretic-digital-human-character-gawain" target="_blank" rel="noopener nofollow">https://unity.com/blog/technology/making-of-the-heretic-digital-human-character-gawain</a></p>
<p>Megacity Unity Demo工程学习：<a href="https://www.cnblogs.com/hont/p/18337785" target="_blank">https://www.cnblogs.com/hont/p/18337785</a></p>
<p>Unity FPSSample Demo研究：<a href="https://www.cnblogs.com/hont/p/18360437" target="_blank">https://www.cnblogs.com/hont/p/18360437</a></p>
<p>Book of the Dead 死者之书Demo工程回顾与学习：<a href="https://www.cnblogs.com/hont/p/15815167.html" target="_blank">https://www.cnblogs.com/hont/p/15815167.html</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3630747733738426" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-06 00:22">2025-01-06 00:07</span>&nbsp;
<a href="https://www.cnblogs.com/hont">HONT</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18651183" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18651183);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18651183', targetLink: 'https://www.cnblogs.com/hont/p/18651183', title: 'Unity TheHeretic Gawain Demo 异教徒Demo技术学习' })">举报</a>
</div>
        