
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/renzhesuanfa/p/18712368" title="发布于 2025-02-13 01:29">
    <span role="heading" aria-level="2">【忍者算法】从十字路口相遇到链表交点：探索相交链表问题｜LeetCode第160题 相交链表</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="从十字路口相遇到链表交点探索相交链表问题">从十字路口相遇到链表交点：探索相交链表问题</h1>
<h2 id="生活中的相遇问题">生活中的相遇问题</h2>
<p>想象两个人从不同的地方出发，最后在一个十字路口相遇。他们可能走过不同长度的路程，但最终会在同一个点汇合。这就很像我们今天要讨论的相交链表问题：两个链表从不同的起点出发，在某个节点相交，然后共享后续的路径。</p>
<h2 id="问题描述">问题描述</h2>
<p>LeetCode第160题"相交链表"是这样描述的：给你两个单链表的头节点 headA 和 headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null。</p>
<p>例如：</p>
<pre><code>A链表：      a1 → a2
                    ↘
                      c1 → c2 → c3
                    ↗            
B链表： b1 → b2 → b3

输出：返回节点c1
</code></pre>
<h2 id="最直观的解法哈希表记录">最直观的解法：哈希表记录</h2>
<p>就像在一个城市里标记每个人走过的地方，最简单的方法是用一个哈希表记录第一个人走过的所有位置，然后看第二个人的路径中是否有重复的地方。</p>
<h3 id="哈希表方法的实现">哈希表方法的实现</h3>
<pre><code class="language-java">public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 使用HashSet记录链表A中的所有节点
        Set&lt;ListNode&gt; visited = new HashSet&lt;&gt;();
        
        // 遍历链表A，将节点加入集合
        ListNode current = headA;
        while (current != null) {
            visited.add(current);
            current = current.next;
        }
        
        // 遍历链表B，查找第一个在集合中出现的节点
        current = headB;
        while (current != null) {
            if (visited.contains(current)) {
                return current;
            }
            current = current.next;
        }
        
        return null;
    }
}
</code></pre>
<h2 id="优化解法双指针技巧">优化解法：双指针技巧</h2>
<p>仔细思考，我们发现一个有趣的现象：如果两个人分别走对方的路，他们最终一定会相遇！这就是双指针解法的灵感来源。</p>
<h3 id="双指针方法的原理">双指针方法的原理</h3>
<p>想象两个人在散步：</p>
<ol>
<li>A从链表A出发，走完后转到链表B继续走</li>
<li>B从链表B出发，走完后转到链表A继续走</li>
<li>如果链表相交，他们一定会在相交点相遇
<ul>
<li>因为他们走过的总路程是相同的：链表A长度 + 链表B长度</li>
</ul>
</li>
</ol>
<h3 id="示例运行">示例运行</h3>
<p>假设链表A：1→2→3→4，链表B：5→6→3→4（3是相交点）</p>
<pre><code>指针A：1 → 2 → 3 → 4 → 5 → 6 → [3] ← 相遇！
指针B：5 → 6 → 3 → 4 → 1 → 2 → [3] ← 相遇！
</code></pre>
<h3 id="java代码实现">Java代码实现</h3>
<pre><code class="language-java">public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        
        // 初始化两个指针
        ListNode pointerA = headA;
        ListNode pointerB = headB;
        
        // 当两个指针不相等时继续移动
        while (pointerA != pointerB) {
            // 移动指针A，如果到达末尾则转到链表B
            pointerA = (pointerA == null) ? headB : pointerA.next;
            // 移动指针B，如果到达末尾则转到链表A
            pointerB = (pointerB == null) ? headA : pointerB.next;
        }
        
        // 返回相交点（如果不存在相交点，两个指针都会是null）
        return pointerA;
    }
}
</code></pre>
<h2 id="解法比较">解法比较</h2>
<p>让我们比较这两种方法：</p>
<p>哈希表法：</p>
<ul>
<li>时间复杂度：O(m+n)</li>
<li>空间复杂度：O(m)，m为链表A的长度</li>
<li>优点：思路直观，容易理解</li>
<li>缺点：需要额外的空间存储节点</li>
</ul>
<p>双指针法：</p>
<ul>
<li>时间复杂度：O(m+n)</li>
<li>空间复杂度：O(1)</li>
<li>优点：不需要额外空间，优雅简洁</li>
<li>缺点：理解起来稍微有点难度</li>
</ul>
<h2 id="实用技巧总结">实用技巧总结</h2>
<p>解决链表相交问题的关键点：</p>
<ol>
<li>理解相交后的节点都是共享的</li>
<li>考虑特殊情况（如空链表、不相交的情况）</li>
<li>善用双指针技巧</li>
<li>利用数学特性（路程相等原理）</li>
</ol>
<p>相关的链表问题：</p>
<ul>
<li>判断链表是否有环</li>
<li>找到链表环的入口</li>
<li>链表的中间节点</li>
</ul>
<h2 id="小结">小结</h2>
<p>通过相交链表这道题，我们学会了如何巧妙地使用双指针技巧来解决看似复杂的问题。这种思维方式不仅能解决算法题，在处理数据流、文件比较等实际问题时也很有用。记住，当遇到需要找到两个序列共同元素的问题时，双指针技巧往往能提供一个优雅的解决方案！</p>
<p><strong>延伸思考：</strong></p>
<ol>
<li>如果链表可能有环，这个算法还有效吗？</li>
<li>如果要找到所有的相交节点，应该如何修改算法？</li>
<li>在分布式系统中，如何处理类似的"路径相交"问题？</li>
</ol>
<hr>
<p>作者：忍者算法<br>
公众号：忍者算法</p>
<p>🎯 回复【刷题清单】获取更多经典题目解析<br>
👥 回复【加群】加入算法/面试交流群，一起学习进步<br>
🧑‍💻 回复【代码】获取GitHub完整题解项目，包含Java/Python/JavaScript/Go/C++多语言实现</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.035651913903935184" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-13 01:29">2025-02-13 01:29</span>&nbsp;
<a href="https://www.cnblogs.com/renzhesuanfa">忍者算法</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18712368" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18712368);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18712368', targetLink: 'https://www.cnblogs.com/renzhesuanfa/p/18712368', title: '【忍者算法】从十字路口相遇到链表交点：探索相交链表问题｜LeetCode第160题 相交链表' })">举报</a>
</div>
        