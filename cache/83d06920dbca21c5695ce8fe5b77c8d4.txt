
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/renzhesuanfa/p/18721053" title="发布于 2025-02-17 23:33">
    <span role="heading" aria-level="2">【忍者算法】从公路跑步到链表成环：探索环形链表检测｜LeetCode第141题 环形链表</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="从公路跑步到链表成环探索环形链表检测">从公路跑步到链表成环：探索环形链表检测</h1>
<h2 id="生活中的环形">生活中的环形</h2>
<p>想象两个人在环形跑道上跑步，一个跑得快，一个跑得慢。如果他们一直跑下去，快的跑者一定会从后面追上慢的跑者。这就是我们今天要讨论的环形链表问题的现实映射。在跑道上，两个速度不同的跑者相遇就说明跑道是环形的；同样在链表中，如果两个速度不同的指针相遇，就说明链表中存在环。</p>
<h2 id="问题描述">问题描述</h2>
<p>LeetCode第141题"环形链表"要求：给你一个链表的头节点 head，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。</p>
<p>例如：</p>
<pre><code>输入：3 → 2 → 0 → -4
         ↑___________|
输出：true
解释：链表中存在一个环，尾节点连接到第二个节点

输入：1 → 2
     ↑___|
输出：true
解释：链表中存在一个环，尾节点连接到第一个节点

输入：1 → 2 → 3 → 4
输出：false
解释：链表中不存在环
</code></pre>
<h2 id="简单解法哈希表记录">简单解法：哈希表记录</h2>
<p>最直观的想法是用一个哈希表记录每个走过的节点。就像在跑道上撒面包屑，如果遇到已经撒过面包屑的地方，说明路径形成了环。</p>
<h3 id="哈希表解法实现">哈希表解法实现</h3>
<pre><code class="language-java">public boolean hasCycle(ListNode head) {
    Set&lt;ListNode&gt; seen = new HashSet&lt;&gt;();
    
    while (head != null) {
        // 如果已经见过这个节点，说明有环
        if (seen.contains(head)) {
            return true;
        }
        // 记录当前节点
        seen.add(head);
        head = head.next;
    }
    
    return false;
}
</code></pre>
<h2 id="优化解法快慢指针floyd判圈算法">优化解法：快慢指针（Floyd判圈算法）</h2>
<p>这个经典算法也被称为"龟兔赛跑算法"，就像我们开始说的跑步场景：让一快一慢两个指针在链表上移动，如果存在环，快指针最终一定会追上慢指针。</p>
<h3 id="为什么快慢指针一定会相遇">为什么快慢指针一定会相遇？</h3>
<p>想象在环形跑道上：</p>
<ol>
<li>快指针每次走2步，慢指针每次走1步</li>
<li>相对来说，快指针每次都在追赶慢指针1步</li>
<li>如果有环，这就像在操场上追赶，快指针一定会追上慢指针</li>
<li>如果无环，快指针会先到达终点</li>
</ol>
<h3 id="代码实现与详解">代码实现与详解</h3>
<pre><code class="language-java">public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    
    // 初始化快慢指针
    ListNode slow = head;
    ListNode fast = head;
    
    // 快指针每次走两步，慢指针每次走一步
    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;          // 慢指针走一步
        fast = fast.next.next;     // 快指针走两步
        
        // 如果两个指针相遇，说明有环
        if (slow == fast) {
            return true;
        }
    }
    
    // 如果快指针到达链表末尾，说明无环
    return false;
}
</code></pre>
<h3 id="图解过程">图解过程</h3>
<p>以一个有环链表为例：</p>
<pre><code>1) 初始状态：
3 → 2 → 0 → 4
    ↑_________|
S,F
(S=slow, F=fast)

2) 第一次移动后：
3 → 2 → 0 → 4
    ↑_________|
    S   F

3) 第二次移动后：
3 → 2 → 0 → 4
    ↑_________|
        S   F

4) 最终相遇：
3 → 2 → 0 → 4
    ↑_________|
        S,F
</code></pre>
<h2 id="复杂度比较">复杂度比较</h2>
<p>哈希表解法：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)，需要存储已访问节点</li>
<li>优点：思路直观，容易实现</li>
<li>缺点：需要额外空间</li>
</ul>
<p>快慢指针解法：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)，只需要两个指针</li>
<li>优点：空间效率高，实现优雅</li>
<li>缺点：需要理解快慢指针的数学原理</li>
</ul>
<h2 id="核心原理解析">核心原理解析</h2>
<h3 id="1-数学证明">1. 数学证明</h3>
<p>为什么快慢指针一定会相遇？</p>
<ul>
<li>假设环长为K，入环前长度为N</li>
<li>慢指针走S步时，快指针走2S步</li>
<li>快指针多走的S步一定是环长K的整数倍</li>
<li>因此快慢指针一定会在入环后的K-N步内相遇</li>
</ul>
<h3 id="2-临界情况分析">2. 临界情况分析</h3>
<ul>
<li>空链表</li>
<li>单节点链表</li>
<li>环的长度为1（自环）</li>
<li>入环点在开头或结尾</li>
</ul>
<h2 id="实用技巧总结">实用技巧总结</h2>
<p>解决环形问题的关键点：</p>
<ol>
<li>掌握快慢指针技巧</li>
<li>理解环形结构的特性</li>
<li>考虑边界情况</li>
<li>注意指针移动的顺序</li>
</ol>
<p>相关的环形问题：</p>
<ul>
<li>找到环的入口点</li>
<li>计算环的长度</li>
<li>找到环中的特定节点</li>
</ul>
<h2 id="小结">小结</h2>
<p>环形链表的检测问题是链表操作中的一个经典问题。它教会我们：</p>
<ol>
<li>如何用最小的空间解决复杂问题</li>
<li>快慢指针这个强大的算法技巧</li>
<li>如何将现实问题映射到算法思维</li>
<li>优雅解法往往来自于深刻的数学原理</li>
</ol>
<p>建议：多思考快慢指针的应用场景，它不仅用于检测环，还可以：</p>
<ul>
<li>找到链表中点</li>
<li>判断链表是否为回文</li>
<li>找到倒数第K个节点</li>
</ul>
<p>这些问题都可以用类似的思维方式来解决！</p>
<hr>
<p>作者：忍者算法<br>
公众号：忍者算法</p>
<p>我准备了一份刷题清单，以及这些题目的详细题解，覆盖了绝大部分常见面试题。我可以很负责任地说，只要你把这些题真正掌握了，80%的算法面试都能遇到相似题目。公众号回复【刷题清单】获取～</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03121144823726852" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-17 23:33">2025-02-17 23:33</span>&nbsp;
<a href="https://www.cnblogs.com/renzhesuanfa">忍者算法</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18721053" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18721053);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18721053', targetLink: 'https://www.cnblogs.com/renzhesuanfa/p/18721053', title: '【忍者算法】从公路跑步到链表成环：探索环形链表检测｜LeetCode第141题 环形链表' })">举报</a>
</div>
        