
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18758730" title="发布于 2025-03-07 22:58">
    <span role="heading" aria-level="2">分布式锁—6.Redisson的同步器组件</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="3" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="4"><strong>1.Redisson的分布式锁简单总结</strong></p>
<p data-track="5"><strong>2.Redisson的Semaphore简介</strong></p>
<p data-track="6"><strong>3.Redisson的Semaphore源码剖析</strong></p>
<p data-track="7"><strong>4.Redisson的CountDownLatch简介</strong></p>
<p data-track="8"><strong>5.Redisson的CountDownLatch源码剖析</strong></p>
<p data-track="9">&nbsp;</p>
<p data-track="10"><strong>1.Redisson的分布式锁简单总结</strong></p>
<p data-track="11"><strong>(1)可重入锁RedissonLock</strong></p>
<p data-track="12"><strong>(2)公平锁RedissonFairLock</strong></p>
<p data-track="13"><strong>(3)联锁MultiLock</strong></p>
<p data-track="14"><strong>(4)红锁RedLock</strong></p>
<p data-track="15"><strong>(5)读写锁之读锁RedissonReadLock和写锁RedissonWriteLock</strong></p>
<p data-track="16">&nbsp;</p>
<p data-track="17">Redisson分布式锁包括：可重入锁、公平锁、联锁、红锁、读写锁。</p>
<p data-track="18">&nbsp;</p>
<p data-track="19"><strong>(1)可重入锁RedissonLock</strong></p>
<p data-track="20">非公平锁，最基础的分布式锁，最常用的锁。</p>
<p data-track="21">&nbsp;</p>
<p data-track="22"><strong>(2)公平锁RedissonFairLock</strong></p>
<p data-track="23">各个客户端尝试获取锁时会排队，按照队列的顺序先后获取锁。</p>
<p data-track="24">&nbsp;</p>
<p data-track="25"><strong>(3)联锁MultiLock</strong></p>
<p data-track="26">可以一次性加多把锁，从而实现一次性锁多个资源。</p>
<p data-track="27">&nbsp;</p>
<p data-track="28"><strong>(4)红锁RedLock</strong></p>
<p data-track="29">RedLock相当于一把锁。虽然利用了MultiLock包裹了多个小锁，但这些小锁并不对应多个资源，而是每个小锁的key对应一个Redis实例。只要大多数的Redis实例加锁成功，就可以认为RedLock加锁成功。RedLock的健壮性要比其他普通锁要好。</p>
<p data-track="30">&nbsp;</p>
<p data-track="31">但是RedLock也有一些场景无法保证正确性，当然RedLock只要求部署主库。比如客户端A尝试向5个Master实例加锁，但仅仅在3个Maste中加锁成功。不幸的是此时3个Master中有1个Master突然宕机了，而且锁key还没同步到该宕机Master的Slave上，此时Salve切换为Master。于是在这5个Master中，由于其中有一个是新切换过来的Master，所以只有2个Master是有客户端A加锁的数据，另外3个Master是没有锁的。但继续不幸的是，此时客户端B来加锁，那么客户端B就很有可能成功在没有锁数据的3个Master上加到锁，从而满足了过半数加锁的要求，最后也完成了加锁，依然发生重复加锁。</p>
<p data-track="32">&nbsp;</p>
<p data-track="33"><strong>(5)读写锁之读锁RedissonReadLock和写锁RedissonWriteLock</strong></p>
<p data-track="34">不同客户端线程的四种加锁情况：</p>
<p data-track="35">情况一：先加读锁再加读锁，不互斥</p>
<p data-track="36">情况二：先加读锁再加写锁，互斥</p>
<p data-track="37">情况三：先加写锁再加读锁，互斥</p>
<p data-track="38">情况四：先加写锁再加写锁，互斥</p>
<p data-track="39">&nbsp;</p>
<p data-track="40">同一个客户端线程的四种加锁情况：</p>
<p data-track="41">情况一：先加读锁再加读锁，不互斥</p>
<p data-track="42">情况二：先加读锁再加写锁，互斥</p>
<p data-track="43">情况三：先加写锁再加读锁，不互斥</p>
<p data-track="44">情况四：先加写锁再加写锁，不互斥</p>
<p data-track="45">&nbsp;</p>
<p data-track="46"><strong>2.Redisson的Semaphore简介</strong></p>
<p data-track="47"><strong>(1)Redisson的Semaphore原理图</strong></p>
<p data-track="48">Semaphore也是Redisson支持的一种同步组件。Semaphore作为一个锁机制，可以允许多个线程同时获取一把锁。任何一个线程释放锁之后，其他等待的线程就可以尝试继续获取锁。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/1e9c1f307cbd40c8a3eabf4dcf32c410~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250307223727DEE8653500EBA48A1A29&amp;x-expires=2147483647&amp;x-signature=gt7rievnpz7m10hgND1HcY9O44M%3D" data-ic="false" data-width="1080" data-height="508" data-ic-uri=""></div>
<p data-track="49"><strong>(2)Redisson的Semaphore使用演示</strong></p>
<pre class="highlighter-hljs"><code>public class RedissonDemo {
    public static void main(String[] args) throws Exception {
        //连接3主3从的Redis CLuster
        Config config = new Config();
        ...
        //Semaphore
        RedissonClient redisson = Redisson.create(config);
        final RSemaphore semaphore = redisson.getSemaphore("semaphore");
        semaphore.trySetPermits(3);
        for (int i = 0; i &lt; 10; i++) {
            new Thread(new Runnable() {
                public void run() {
                    try {
                        System.out.println(new Date() + "：线程[" + Thread.currentThread().getName() + "]尝试获取Semaphore锁");
                        semaphore.acquire();
                        System.out.println(new Date() + "：线程[" + Thread.currentThread().getName() + "]成功获取到了Semaphore锁，开始工作");
                        Thread.sleep(3000);
                        semaphore.release();
                        System.out.println(new Date() + "：线程[" + Thread.currentThread().getName() + "]释放Semaphore锁");
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
}</code></pre>
<p data-track="51">&nbsp;</p>
<p data-track="52"><strong>3.Redisson的Semaphore源码剖析</strong></p>
<p data-track="53"><strong>(1)Semaphore的初始化</strong></p>
<p data-track="54"><strong>(2)Semaphore设置允许获取的锁数量</strong></p>
<p data-track="55"><strong>(3)客户端尝试获取Semaphore的锁</strong></p>
<p data-track="56"><strong>(4)客户端释放Semaphore的锁</strong></p>
<p data-track="57">&nbsp;</p>
<p data-track="58"><strong>(1)Semaphore的初始化</strong></p>
<pre class="highlighter-hljs"><code>public class Redisson implements RedissonClient {
    //Redis的连接管理器，封装了一个Config实例
    protected final ConnectionManager connectionManager;
    //Redis的命令执行器，封装了一个ConnectionManager实例
    protected final CommandAsyncExecutor commandExecutor;
    ...
    protected Redisson(Config config) {
        this.config = config;
        Config configCopy = new Config(config);
        //初始化Redis的连接管理器
        connectionManager = ConfigSupport.createConnectionManager(configCopy);
        ...  
        //初始化Redis的命令执行器
        commandExecutor = new CommandSyncService(connectionManager, objectBuilder);
        ...
    }

    @Override
    public RSemaphore getSemaphore(String name) {
        return new RedissonSemaphore(commandExecutor, name);
    }
    ...
}

public class RedissonSemaphore extends RedissonExpirable implements RSemaphore {
    private final SemaphorePubSub semaphorePubSub;
    final CommandAsyncExecutor commandExecutor;

    public RedissonSemaphore(CommandAsyncExecutor commandExecutor, String name) {
        super(commandExecutor, name);
        this.commandExecutor = commandExecutor;
        this.semaphorePubSub = commandExecutor.getConnectionManager().getSubscribeService().getSemaphorePubSub();
    }
    ...
}</code></pre>
<p data-track="60"><strong>(2)Semaphore设置允许获取的锁数量</strong></p>
<pre class="highlighter-hljs"><code>public class RedissonSemaphore extends RedissonExpirable implements RSemaphore {
    ...
    @Override
    public boolean trySetPermits(int permits) {
        return get(trySetPermitsAsync(permits));
    }

    @Override
    public RFuture&lt;Boolean&gt; trySetPermitsAsync(int permits) {
        RFuture&lt;Boolean&gt; future = commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
            //执行命令"get semaphore"，获取到当前的数值
            "local value = redis.call('get', KEYS[1]); " +
            "if (value == false) then " +
                //然后执行命令"set semaphore 3"
                //设置这个信号量允许客户端同时获取锁的总数量为3
                "redis.call('set', KEYS[1], ARGV[1]); " +
                "redis.call('publish', KEYS[2], ARGV[1]); " +
                "return 1;" +
            "end;" +
            "return 0;",
            Arrays.asList(getRawName(), getChannelName()),
            permits
        );

        if (log.isDebugEnabled()) {
            future.onComplete((r, e) -&gt; {
                if (r) {
                    log.debug("permits set, permits: {}, name: {}", permits, getName());
                } else {
                    log.debug("unable to set permits, permits: {}, name: {}", permits, getName());
                }
            });
        }
        return future;
    }
    ...
}</code></pre>
<p data-track="62">首先执行命令"get semaphore"，获取到当前的数值。然后执行命令"set semaphore 3"，也就是设置这个信号量允许客户端同时获取锁的总数量为3。</p>
<p data-track="63">&nbsp;</p>
<p data-track="64"><strong>(3)客户端尝试获取Semaphore的锁</strong></p>
<pre class="highlighter-hljs"><code>public class RedissonSemaphore extends RedissonExpirable implements RSemaphore {
    ...
    private final SemaphorePubSub semaphorePubSub;
    final CommandAsyncExecutor commandExecutor;

    public RedissonSemaphore(CommandAsyncExecutor commandExecutor, String name) {
        super(commandExecutor, name);
        this.commandExecutor = commandExecutor;
        this.semaphorePubSub = commandExecutor.getConnectionManager().getSubscribeService().getSemaphorePubSub();
    }

    @Override
    public void acquire() throws InterruptedException {
        acquire(1);
    }
    
    @Override
    public void acquire(int permits) throws InterruptedException {
        if (tryAcquire(permits)) {
            return;
        }
        CompletableFuture&lt;RedissonLockEntry&gt; future = subscribe();
        commandExecutor.syncSubscriptionInterrupted(future);
        try {
            while (true) {
                if (tryAcquire(permits)) {
                    return;
                }
                //获取Redisson的Semaphore失败，于是便调用本地JDK的Semaphore的acquire()方法，此时当前线程会被阻塞
                //之后如果Redisson的Semaphore释放了锁，那么当前客户端便会通过监听订阅事件释放本地JDK的Semaphore，唤醒被阻塞的线程，继续执行while循环
                //注意：getLatch()返回的是JDK的Semaphore = "new Semaphore(0)" ==&gt; (state - permits)


                //首先调用CommandAsyncService.getNow()方法
                //然后调用RedissonLockEntry.getLatch()方法
                //接着调用JDK的Semaphore的acquire()方法
                commandExecutor.getNow(future).getLatch().acquire();
            }
        } finally {
            unsubscribe(commandExecutor.getNow(future));
        }
    }
    
    @Override
    public boolean tryAcquire(int permits) {
        //异步转同步
        return get(tryAcquireAsync(permits));
    }
    
    @Override
    public RFuture&lt;Boolean&gt; tryAcquireAsync(int permits) {
        if (permits &lt; 0) {
            throw new IllegalArgumentException("Permits amount can't be negative");
        }
        if (permits == 0) {
            return RedissonPromise.newSucceededFuture(true);
        }
        return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
            //执行命令"get semaphore"，获取到当前值
            "local value = redis.call('get', KEYS[1]); "+
            //如果semaphore的当前值不是false，且大于客户端线程申请获取锁的数量
            "if (value ~= false and tonumber(value) &gt;= tonumber(ARGV[1])) then " +
                //执行"decrby semaphore 1"，将信号量允许获取锁的总数量递减1
                "local val = redis.call('decrby', KEYS[1], ARGV[1]); " +
                "return 1; " +
            "end; " +
            //如果semaphore的值变为0，那么客户端就无法获取锁了，此时返回false
            "return 0;",
            Collections.&lt;Object&gt;singletonList(getRawName()),
            permits//ARGV[1]默认是1
        );
    }
    ...
}

public class CommandAsyncService implements CommandAsyncExecutor {
    ...
    @Override
    public &lt;V&gt; V getNow(CompletableFuture&lt;V&gt; future) {
        try {
            return future.getNow(null);
        } catch (Exception e) {
            return null;
        }
    }
    ...
}

public class RedissonLockEntry implements PubSubEntry&lt;RedissonLockEntry&gt; {
    private final Semaphore latch;
    ...
    public RedissonLockEntry(CompletableFuture&lt;RedissonLockEntry&gt; promise) {
        super();
        this.latch = new Semaphore(0);
        this.promise = promise;
    }
    
    public Semaphore getLatch() {
        return latch;
    }
    ...
}</code></pre>
<p data-track="66">执行命令"get semaphore"，获取到semaphore的当前值。如果semaphore的当前值不是false，且大于客户端线程申请获取锁的数量。那么就执行"decrby semaphore 1"，将信号量允许获取锁的总数量递减1。</p>
<p data-track="67">&nbsp;</p>
<p data-track="68">如果semaphore的值变为0，那么客户端就无法获取锁了，此时tryAcquire()方法返回false。表示获取semaphore的锁失败了，于是当前客户端线程便会通过本地JDK的Semaphore进行阻塞。</p>
<p data-track="69">&nbsp;</p>
<p data-track="70">当客户端后续收到一个订阅事件把本地JDK的Semaphore进行释放后，便会唤醒阻塞线程继续while循环。在while循环中，会不断尝试获取这个semaphore的锁，如此循环往复，直到成功获取。</p>
<p data-track="71">&nbsp;</p>
<p data-track="72"><strong>(4)客户端释放Semaphore的锁</strong></p>
<pre class="highlighter-hljs"><code>public class RedissonSemaphore extends RedissonExpirable implements RSemaphore {
    ...
    @Override
    public void release() {
        release(1);
    }

    @Override
    public void release(int permits) {
        get(releaseAsync(permits));
    }

    @Override
    public RFuture&lt;Void&gt; releaseAsync(int permits) {
        if (permits &lt; 0) {
            throw new IllegalArgumentException("Permits amount can't be negative");
        }
        if (permits == 0) {
            return RedissonPromise.newSucceededFuture(null);
        }

        RFuture&lt;Void&gt; future = commandExecutor.evalWriteAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_VOID,
            //执行命令"incrby semaphore 1"
            "local value = redis.call('incrby', KEYS[1], ARGV[1]); " +
            "redis.call('publish', KEYS[2], value); ",
            Arrays.asList(getRawName(), getChannelName()),
            permits
        );
        if (log.isDebugEnabled()) {
            future.onComplete((o, e) -&gt; {
                if (e == null) {
                    log.debug("released, permits: {}, name: {}", permits, getName());
                }
            });
        }
        return future;
    }
    ...
}

//订阅semaphore不为0的事件，semaphore不为0时会触发执行这里的监听回调
public class SemaphorePubSub extends PublishSubscribe&lt;RedissonLockEntry&gt; {
    public SemaphorePubSub(PublishSubscribeService service) {
        super(service);
    }
    
    @Override
    protected RedissonLockEntry createEntry(CompletableFuture&lt;RedissonLockEntry&gt; newPromise) {
        return new RedissonLockEntry(newPromise);
    }
    
    @Override
    protected void onMessage(RedissonLockEntry value, Long message) {
    Runnable runnableToExecute = value.getListeners().poll();
        if (runnableToExecute != null) {
            runnableToExecute.run();
        }
        //将客户端本地JDK的Semaphore进行释放
        value.getLatch().release(Math.min(value.acquired(), message.intValue()));
    }
}

//订阅锁被释放的事件，锁被释放为0时会触发执行这里的监听回调
public class LockPubSub extends PublishSubscribe&lt;RedissonLockEntry&gt; {
    public static final Long UNLOCK_MESSAGE = 0L;
    public static final Long READ_UNLOCK_MESSAGE = 1L;
    
    public LockPubSub(PublishSubscribeService service) {
        super(service);
    }  
      
    @Override
    protected RedissonLockEntry createEntry(CompletableFuture&lt;RedissonLockEntry&gt; newPromise) {
        return new RedissonLockEntry(newPromise);
    }
    
    @Override
    protected void onMessage(RedissonLockEntry value, Long message) {
        if (message.equals(UNLOCK_MESSAGE)) {
            Runnable runnableToExecute = value.getListeners().poll();
            if (runnableToExecute != null) {
                runnableToExecute.run();
            }
            value.getLatch().release();
        } else if (message.equals(READ_UNLOCK_MESSAGE)) {
            while (true) {
                Runnable runnableToExecute = value.getListeners().poll();
                if (runnableToExecute == null) {
                    break;
                }
                runnableToExecute.run();
            }
            //将客户端本地JDK的Semaphore进行释放
            value.getLatch().release(value.getLatch().getQueueLength());
        }
    }
}</code></pre>
<p data-track="74">客户端释放Semaphore的锁时，会执行命令"incrby semaphore 1"。每当客户端释放掉permits个锁，就会将信号量的值累加permits，这样Semaphore信号量的值就不再是0了。然后通过publish命令发布一个事件，之后订阅了该事件的其他客户端都会对getLatch()返回的本地JDK的Semaphore进行加1。于是其他客户端正在被本地JDK的Semaphore进行阻塞的线程，就会被唤醒继续执行。此时其他客户端就可以尝试获取到这个信号量的锁，然后再次将这个Semaphore的值递减1。</p>
<p data-track="75">&nbsp;</p>
<p data-track="76"><strong>4.Redisson的CountDownLatch简介</strong></p>
<p data-track="77"><strong>(1)Redisson的CountDownLatch原理图解</strong></p>
<p data-track="78"><strong>(2)Redisson的CountDownLatch使用演示</strong></p>
<p data-track="79">&nbsp;</p>
<p data-track="80"><strong>(1)Redisson的CountDownLatch原理图解</strong></p>
<p data-track="81">CountDownLatch的基本原理：要求必须有n个线程来进行countDown，才能让执行await的线程继续执行。如果没有达到指定数量的线程来countDown，会导致执行await的线程阻塞。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7fae3a1245ba4dc1a806d58d92befb33~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250307223727DEE8653500EBA48A1A29&amp;x-expires=2147483647&amp;x-signature=M%2FfGMGJ4IZJXMe7kX1bn1ZIY1uw%3D" data-ic="false" data-width="1080" data-height="403" data-ic-uri=""></div>
<p data-track="82"><strong>(2)Redisson的CountDownLatch使用演示</strong></p>
<pre class="highlighter-hljs"><code>public class RedissonDemo {
    public static void main(String[] args) throws Exception {
        //连接3主3从的Redis CLuster
        Config config = new Config();
        ...
        //CountDownLatch
        final RedissonClient redisson = Redisson.create(config);
        RCountDownLatch latch = redisson.getCountDownLatch("myCountDownLatch");
        //1.设置可以countDown的数量为3
        latch.trySetCount(3);
        System.out.println(new Date() + "：线程[" + Thread.currentThread().getName() + "]设置了必须有3个线程执行countDown，进入等待中。。。");

        for (int i = 0; i &lt; 3; i++) {
            new Thread(new Runnable() {
                public void run() {
                    try {
                        System.out.println(new Date() + "：线程[" + Thread.currentThread().getName() + "]在做一些操作，请耐心等待。。。。。。");
                        Thread.sleep(3000);
                        RCountDownLatch localLatch = redisson.getCountDownLatch("myCountDownLatch");
                        localLatch.countDown();
                        System.out.println(new Date() + "：线程[" + Thread.currentThread().getName() + "]执行countDown操作");
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
        latch.await();
        System.out.println(new Date() + "：线程[" + Thread.currentThread().getName() + "]收到通知，有3个线程都执行了countDown操作，可以继续往下执行");
    }
}</code></pre>
<p data-track="84">&nbsp;</p>
<p data-track="85"><strong>5.Redisson的CountDownLatch源码剖析</strong></p>
<p data-track="86"><strong>(1)CountDownLatch的初始化</strong></p>
<p data-track="87"><strong>(2)trySetCount()方法设置countDown的数量</strong></p>
<p data-track="88"><strong>(3)awati()方法进行阻塞等待</strong></p>
<p data-track="89"><strong>(4)countDown()方法对countDown的数量递减</strong></p>
<p data-track="90">&nbsp;</p>
<p data-track="91"><strong>(1)CountDownLatch的初始化</strong></p>
<pre class="highlighter-hljs"><code>public class Redisson implements RedissonClient {
    //Redis的连接管理器，封装了一个Config实例
    protected final ConnectionManager connectionManager;
    //Redis的命令执行器，封装了一个ConnectionManager实例
    protected final CommandAsyncExecutor commandExecutor;
    ...
    protected Redisson(Config config) {
        this.config = config;
        Config configCopy = new Config(config);
        //初始化Redis的连接管理器
        connectionManager = ConfigSupport.createConnectionManager(configCopy);
        ...  
        //初始化Redis的命令执行器
        commandExecutor = new CommandSyncService(connectionManager, objectBuilder);
        ...
    }

    @Override
    public RCountDownLatch getCountDownLatch(String name) {
        return new RedissonCountDownLatch(commandExecutor, name);
    }
    ...
}

public class RedissonCountDownLatch extends RedissonObject implements RCountDownLatch {
    ...
    private final CountDownLatchPubSub pubSub;
    private final String id;
    protected RedissonCountDownLatch(CommandAsyncExecutor commandExecutor, String name) {
        super(commandExecutor, name);
        this.id = commandExecutor.getConnectionManager().getId();
        this.pubSub = commandExecutor.getConnectionManager().getSubscribeService().getCountDownLatchPubSub();
    }
    ...
}</code></pre>
<p data-track="93"><strong>(2)trySetCount()方法设置countDown的数量</strong></p>
<p data-track="94">trySetCount()方法的工作就是执行命令"set myCountDownLatch 3"。</p>
<pre class="highlighter-hljs"><code>public class RedissonCountDownLatch extends RedissonObject implements RCountDownLatch {
    ...
    @Override
    public boolean trySetCount(long count) {
        return get(trySetCountAsync(count));
    }

    @Override
    public RFuture&lt;Boolean&gt; trySetCountAsync(long count) {
        return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
            "if redis.call('exists', KEYS[1]) == 0 then " +
                "redis.call('set', KEYS[1], ARGV[2]); " +
                "redis.call('publish', KEYS[2], ARGV[1]); " +
                "return 1 " +
            "else " +
                "return 0 " +
            "end",
            Arrays.asList(getRawName(), getChannelName()),
            CountDownLatchPubSub.NEW_COUNT_MESSAGE,
            count
        );
    }
    ...
}</code></pre>
<p data-track="96"><strong>(3)awati()方法进行阻塞等待</strong></p>
<pre class="highlighter-hljs"><code>public class RedissonCountDownLatch extends RedissonObject implements RCountDownLatch {
    ...
    @Override
    public void await() throws InterruptedException {
        if (getCount() == 0) {
            return;
        }
        CompletableFuture&lt;RedissonCountDownLatchEntry&gt; future = subscribe();
        try {
            commandExecutor.syncSubscriptionInterrupted(future);
            while (getCount() &gt; 0) {
                // waiting for open state
                //获取countDown的数量还大于0，就先阻塞线程，然后再等待唤醒，执行while循环
                //其中getLatch()返回的是JDK的semaphore = "new Semaphore(0)" ==&gt; (state - permits)
                commandExecutor.getNow(future).getLatch().await();
            }
        } finally {
            unsubscribe(commandExecutor.getNow(future));
        }
    }

    @Override
    public long getCount() {
        return get(getCountAsync());
    }

    @Override
    public RFuture&lt;Long&gt; getCountAsync() {
        //执行命令"get myCountDownLatch"
        return commandExecutor.writeAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.GET_LONG, getRawName());
    }
    ...
}</code></pre>
<p data-track="98">在while循环中，首先会执行命令"get myCountDownLatch"去获取countDown值。如果该值不大于0，就退出循环不阻塞线程。如果该值大于0，则说明还没有指定数量的线程去执行countDown操作，于是就会先阻塞线程，然后再等待唤醒来继续循环。</p>
<p data-track="99">&nbsp;</p>
<p data-track="100"><strong>(4)countDown()方法对countDown的数量递减</strong></p>
<pre class="highlighter-hljs"><code>public class RedissonCountDownLatch extends RedissonObject implements RCountDownLatch {
    ...
    @Override
    public void countDown() {
        get(countDownAsync());
    }

    @Override
    public RFuture&lt;Void&gt; countDownAsync() {
        return commandExecutor.evalWriteNoRetryAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
            "local v = redis.call('decr', KEYS[1]);" +
            "if v &lt;= 0 then redis.call('del', KEYS[1]) end;" +
            "if v == 0 then redis.call('publish', KEYS[2], ARGV[1]) end;",
            Arrays.&lt;Object&gt;asList(getRawName(), getChannelName()),
            CountDownLatchPubSub.ZERO_COUNT_MESSAGE
        );
    }
    ...
}</code></pre>
<p data-track="102">countDownAsync()方法会执行decr命令，将countDown的数量进行递减1。如果这个值已经小于等于0，就执行del命令删除掉该CoutDownLatch。如果是这个值为0，还会发布一条消息：</p>
<pre class="highlighter-hljs"><code>publish redisson_countdownlatch__channel__{anyCountDownLatch} 0</code></pre>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.056021907649305556" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-07 22:58">2025-03-07 22:58</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18758730" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18758730);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18758730', targetLink: 'https://www.cnblogs.com/mjunz/p/18758730', title: '分布式锁—6.Redisson的同步器组件' })">举报</a>
</div>
        