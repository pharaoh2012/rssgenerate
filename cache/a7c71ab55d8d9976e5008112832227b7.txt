
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18978634" title="发布于 2025-07-15 11:55">
    <span role="heading" aria-level="2">【乐观锁实现】StampedLock 的乐观读机制</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>StampedLock 的乐观读机制主要解决了<strong>读多写少场景下，传统读写锁（如 <code>ReentrantReadWriteLock</code>）可能存在的写线程饥饿或性能瓶颈问题</strong>。它通过一种“乐观”的策略，允许读操作在特定条件下<strong>完全不阻塞</strong>写操作，从而显著提高系统的整体吞吐量。</p>
<h2 id="解决的问题">解决的问题</h2>
<ol>
<li><strong>写线程饥饿：</strong>
<ul>
<li>在传统的读写锁（<code>ReentrantReadWriteLock</code>）中，读锁是共享的。当有大量读线程持续持有读锁时，写线程可能长时间无法获取写锁（因为写锁需要独占访问），导致写操作被“饿死”。</li>
</ul>
</li>
<li><strong>悲观锁的开销：</strong>
<ul>
<li>即使没有写操作正在进行，传统的读锁在获取和释放时仍然需要一定的同步开销（CAS操作、维护内部状态等）。在超高并发的读场景下，这些开销累积起来可能成为性能瓶颈。</li>
</ul>
</li>
<li><strong>读操作占主导：</strong>
<ul>
<li>在大多数应用场景（如缓存、配置读取）中，读操作的频率远高于写操作。传统读写锁的设计（读优先或公平策略）在这种场景下效率不高。</li>
</ul>
</li>
</ol>
<h2 id="乐观读机制的核心思想">乐观读机制的核心思想</h2>
<ol>
<li><strong>“乐观”假设：</strong> 假设在读操作进行期间，<strong>很可能没有写操作发生</strong>。</li>
<li><strong>不阻塞写：</strong> 乐观读<strong>不获取真正的锁</strong>，因此它<strong>完全不会阻塞</strong>试图获取写锁的线程。写线程总是可以立即尝试获取写锁。</li>
<li><strong>版本验证：</strong> 在乐观读完成之后、使用读取到的数据之前，必须<strong>验证</strong>在读操作期间是否发生过写操作。这是通过检查一个“戳记”来实现的。</li>
<li><strong>失败降级：</strong> 如果验证失败（表明在读操作期间发生了写操作），则乐观读的结果可能无效。此时，调用者可以选择重试、放弃或者降级为获取一个<strong>悲观的读锁</strong>（会阻塞写）来确保读取到一致的数据。</li>
</ol>
<h2 id="如何使用乐观读">如何使用乐观读</h2>
<p>使用 StampedLock 的乐观读遵循以下模式：</p>
<pre><code class="language-java">import java.util.concurrent.locks.StampedLock;

public class OptimisticReadingExample {
    private final StampedLock lock = new StampedLock();
    private double x, y; // 共享数据

    // 计算距离的方法 (使用乐观读)
    public double distanceFromOrigin() {
        // 1. 尝试乐观读：获取一个戳记(stamp)
        long stamp = lock.tryOptimisticRead();

        // 2. 将共享变量读入本地局部变量（此时数据可能被其他线程修改！）
        double currentX = x;
        double currentY = y;

        // 3. 关键：验证戳记是否仍然有效（自获取戳记以来是否有过写操作？）
        if (!lock.validate(stamp)) {
            // 3a. 验证失败：乐观读期间发生了写操作！戳记已失效。
            //     降级为获取悲观的读锁（会阻塞写，确保读取一致性）
            stamp = lock.readLock(); // 这是一个阻塞调用
            try {
                // 在悲观读锁保护下重新读取数据
                currentX = x;
                currentY = y;
            } finally {
                // 无论如何都要释放读锁
                lock.unlockRead(stamp);
            }
        }
        // 3b. 如果验证成功，或者降级后重新读取成功，则使用 currentX 和 currentY 进行计算
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }

    // 写操作方法
    public void move(double deltaX, double deltaY) {
        long stamp = lock.writeLock(); // 获取独占写锁
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            lock.unlockWrite(stamp); // 释放写锁
        }
    }
}
</code></pre>
<h3 id="关键步骤详解">关键步骤详解</h3>
<ol>
<li>
<p><strong><code>long stamp = lock.tryOptimisticRead();</code></strong></p>
<ul>
<li>尝试获取一个乐观读戳记 (<code>stamp</code>)。<strong>这个方法非常快，通常只是一个内存读取或简单的原子操作，不涉及锁竞争，不会阻塞任何线程（包括写线程）</strong>。</li>
<li>这个 <code>stamp</code> 代表了数据当前的一个“版本”或“状态”。如果之后没有写操作发生，这个版本应该保持不变。</li>
</ul>
</li>
<li>
<p><strong>读取共享数据到局部变量 (<code>currentX = x; currentY = y;</code>)</strong></p>
<ul>
<li>将你需要访问的共享数据复制到方法的局部变量中。<strong>这是必须的</strong>，因为后续的验证只保证到验证那一刻为止的状态，如果验证成功后你又去直接读 <code>x</code> 或 <code>y</code>，数据可能又被修改了。</li>
<li><strong>重要：</strong> 在这个读取过程中，没有任何锁阻止其他线程（尤其是写线程）修改 <code>x</code> 和 <code>y</code>！所以此时读取到的 <code>currentX</code> 和 <code>currentY</code> 可能是<strong>不一致</strong>的（例如，<code>x</code> 被修改了但 <code>y</code> 还没改），或者<strong>过时</strong>的。</li>
</ul>
</li>
<li>
<p><strong><code>if (!lock.validate(stamp)) { ... }</code></strong></p>
<ul>
<li>这是<strong>最核心</strong>的步骤。调用 <code>validate(stamp)</code> 检查自你获取乐观读戳记 (<code>stamp</code>) 以来，是否有任何线程成功获取了写锁并修改了数据。</li>
<li><strong>如果返回 <code>true</code> (验证成功)：</strong>
<ul>
<li>意味着在你获取 <code>stamp</code> 之后，<strong>直到 <code>validate</code> 调用执行的那一刻</strong>，没有发生过写操作。你可以确信第 2 步读取到的 <code>currentX</code> 和 <code>currentY</code> 是<strong>一致</strong>且<strong>有效</strong>的（至少是某个一致状态下的快照）。你可以安全地使用它们进行计算 (<code>return Math.sqrt(...)</code>)。</li>
</ul>
</li>
<li><strong>如果返回 <code>false</code> (验证失败)：</strong>
<ul>
<li>意味着在你读取数据（第 2 步）的过程中或之后，在 <code>validate</code> 调用之前，<strong>至少发生了一次成功的写操作</strong>。你第 2 步读取的数据 <code>currentX</code> 和 <code>currentY</code> 可能无效（不一致或过时），<strong>绝对不能使用它们！</strong></li>
<li>此时，你需要<strong>降级 (downgrade)</strong> 为传统的、悲观的策略：<strong>获取一个读锁 (<code>stamp = lock.readLock();</code>)</strong>。这个调用<strong>可能会阻塞</strong>，等待当前可能存在的写锁释放。</li>
<li>在获取到读锁后，<strong>重新读取</strong>共享数据 (<code>x</code> 和 <code>y</code>) 到局部变量 (<code>currentX</code>, <code>currentY</code>)。因为现在持有读锁，所以能保证在读取过程中不会有写操作发生，读取到的数据是一致的。</li>
<li>在 <code>finally</code> 块中<strong>释放读锁</strong> (<code>lock.unlockRead(stamp);</code>)。</li>
<li>最后，使用在悲观读锁保护下读取到的、一致的数据进行计算。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>使用数据 (<code>return Math.sqrt(...)</code>)</strong></p>
<ul>
<li>无论是乐观读验证成功，还是降级到悲观读后成功读取，最终都使用局部变量 <code>currentX</code> 和 <code>currentY</code> 进行计算并返回结果。这些局部变量要么代表一个验证通过的快照（乐观成功），要么代表在悲观读锁保护下获取的最新一致状态（乐观失败后降级）。</li>
</ul>
</li>
</ol>
<h2 id="使用乐观读的注意事项">使用乐观读的注意事项</h2>
<ol>
<li><strong>验证 (<code>validate</code>) 是必须的：</strong> 绝对不能在未验证或验证失败的情况下使用乐观读读取的数据。</li>
<li><strong>数据拷贝到局部变量：</strong> 必须在获取乐观读戳记后、验证之前，将共享数据复制到方法内部的局部变量。验证通过后只使用这些局部变量。</li>
<li><strong>乐观读适合短小的读操作：</strong> 乐观读操作本身（从获取戳记到验证）应该<strong>尽可能短</strong>。如果读操作本身耗时很长，那么在此期间发生写操作的概率就非常大，导致验证失败的概率很高，最终可能还是需要降级为悲观读锁，反而失去了性能优势，甚至更慢。</li>
<li><strong>乐观读不修改共享状态：</strong> 乐观读只适用于<strong>只读</strong>操作。如果你需要在读操作中修改状态，必须使用写锁或其它同步机制。</li>
<li><strong>乐观读不是锁：</strong> <code>tryOptimisticRead()</code> 返回的只是一个戳记 (stamp)，<strong>不是锁对象</strong>。你不能用它来解锁。</li>
<li><strong><code>StampedLock</code> 不可重入：</strong> 同一个线程试图重复获取锁（即使是读锁）会导致死锁。</li>
<li><strong>没有条件变量：</strong> <code>StampedLock</code> 不直接支持 <code>Condition</code>，而 <code>ReentrantReadWriteLock</code> 的写锁可以。</li>
<li><strong>小心转换：</strong> <code>StampedLock</code> 提供了 <code>tryConvertToWriteLock</code> 等方法，但使用它们需要非常小心，容易出错。</li>
</ol>
<h2 id="总结">总结</h2>
<p>StampedLock 的乐观读机制通过牺牲“读操作总是能看到最新数据”的绝对保证（通过后续验证和可能的降级来补偿），换取了在<strong>读多写少</strong>场景下的<strong>超高读并发性能</strong>和<strong>避免写线程饥饿</strong>。其核心在于 <code>tryOptimisticRead()</code> 获取戳记、将数据拷贝到局部变量、<code>validate(stamp)</code> 验证、验证失败则降级获取悲观读锁重新读取这一套流程。正确使用乐观读可以显著提升高并发读取场景的系统吞吐量，但必须严格遵守使用模式并理解其注意事项。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-15 11:55">2025-07-15 11:55</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18978634);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18978634', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18978634', title: '【乐观锁实现】StampedLock 的乐观读机制' })">举报</a>
</div>
        