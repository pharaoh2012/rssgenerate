
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TianTianChaoFangDe/p/18796248" title="发布于 2025-03-27 16:09">
    <span role="heading" aria-level="2">【CF比赛记录】Codeforces Round 1013 (Div. 3)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><a href="https://codeforces.com/contest/2091" target="_blank" rel="noopener nofollow">比赛链接</a><br>
本文发布于博客园，会跟随补题进度实时更新，若您在其他平台阅读到此文，请前往<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18796248" title="博客园" target="_blank">博客园</a>获取更好的阅读体验。<br>
跳转链接：<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18796248" target="_blank">https://www.cnblogs.com/TianTianChaoFangDe/p/18796248</a></p>
<h2 id="开题情况">开题情况</h2>
<p><img src="https://img2024.cnblogs.com/blog/3572902/202503/3572902-20250327160550850-1610907095.png" alt="image" loading="lazy"><br>
打回蓝了。<br>
很基础的一场，不过怎么有人会因为没取模白挂两发啊啊啊！太羞耻了！</p>
<h2 id="a-olympiad-date">A. Olympiad Date</h2>
<p>很简单，判断一下日期里面的数字什么时候全部数量充足就行了。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">//20250103

void solve()
{
    int n;std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n);
    std::vector&lt;int&gt; cnt(10);

    for(auto &amp;i : a) {
        std::cin &gt;&gt; i;
    }

    auto check = [&amp;]() -&gt; bool {
        if(cnt[0] &lt; 3)return false;
        if(cnt[1] &lt; 1)return false;
        if(cnt[2] &lt; 2)return false;
        if(cnt[3] &lt; 1)return false;
        if(cnt[5] &lt; 1)return false;

        return true;
    };

    for(int i = 0;i &lt; n;i ++) {
        cnt[a[i]] ++;

        if(check()) {
            std::cout &lt;&lt; i + 1 &lt;&lt; '\n';
            return;
        }
    }

    std::cout &lt;&lt; 0 &lt;&lt; '\n';
}
</code></pre>
</details>
<h2 id="b-team-training">B. Team Training</h2>
<p>首先很明显从大到小排序，然后双指针搜索就行了。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">void solve()
{
    int n;std::cin &gt;&gt; n;
    i64 x;std::cin &gt;&gt; x;
    std::vector&lt;i64&gt; a(n + 1);

    for(int i = 1;i &lt;= n;i ++)std::cin &gt;&gt; a[i];

    std::sort(a.begin() + 1, a.end(), std::greater());

    int sum = 0;
    for(int i = 1, j = 1;i &lt;= n;i = j + 1) {
        j = i;
        while(j + 1 &lt;= n &amp;&amp; a[j] * (j - i + 1) &lt; x)j ++;

        if(a[j] * (j - i + 1) &gt;= x) {
            sum ++;
        }
    }

    std::cout &lt;&lt; sum &lt;&lt; '\n';
}
</code></pre>
</details>
<h2 id="c-combination-lock">C. Combination Lock</h2>
<p>说实话这题做了有点久，因为验证结论的时候算错了一步导致误以为结论是错的。<br>
根据样例猜的，偶数一定无解，奇数的话，把题目样例都变成 <span class="math inline">\(1\)</span> 开头，很明显就是先奇数后偶数就行。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf32 1e9
#define inf64 2e18
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

const int N = 2e5 + 9;

void solve()
{
    int n;std::cin &gt;&gt; n;

    if(n % 2 == 0) {
        std::cout &lt;&lt; -1 &lt;&lt; '\n';
        return;
    }

    for(int i = 1;i &lt;= n;i += 2) {
        std::cout &lt;&lt; i &lt;&lt; ' ';
    }

    for(int i = 2;i &lt;= n;i += 2) {
        std::cout &lt;&lt; i &lt;&lt; ' ';
    }

    std::cout &lt;&lt; '\n';
}
</code></pre>
</details>
<h2 id="d-place-of-the-olympiad">D. Place of the Olympiad</h2>
<p>凳子越长肯定可以坐越多人，所以答案具有单调性，因此可以二分。<br>
在二分的 check 中，尽可能只留一个格子作为过道，使能坐的人尽可能多，看能否坐下所有人。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">void solve()
{
    i64 n, m, k;std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;

    i64 l = 0, r = m + 1;

    auto check = [&amp;](i64 x) -&gt; bool {
        i64 ch = m % (x + 1);
        i64 sum = m / (x + 1) * x * n;

        sum += ch * n;
        return sum &gt;= k;
    };

    while(l + 1 != r) {
        int mid = l + r &gt;&gt; 1;
        if(check(mid))r = mid;
        else l = mid;
    } 

    std::cout &lt;&lt; r &lt;&lt; '\n';
}
</code></pre>
</details>
<h2 id="e-interesting-ratio">E. Interesting Ratio</h2>
<p>根据唯一分解定理，我们可以把两个数 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 分解成一系列素数的素数的幂次的乘积，并且有：两个数的最大公因数，就是对每个素数的指数取小的那个乘起来，两个数的最小公倍数，就是对每个素数的指数取大的那个乘起来。<br>
因此，如果满足两个数的最小公倍数和最大公因数的商是一个素数，这两个数应该有且仅有一个素数的指数不同，并且差值为 <span class="math inline">\(1\)</span>。<br>
那么这题的思路就很明确了，对于每一个素数，看他在范围内能乘多少个数，就是这个素数对应的答案。<br>
对所有素数的答案求和即为总的答案。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf32 1e9
#define inf64 2e18
#define int long long
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

const int N = 1e7 + 9;
int prime[N];
bool notprime[N];
int tot = 0;

void init() {
    notprime[0] = notprime[1] = true;

    for(int i = 2;i &lt;= 10'000'000;i ++) {
        if(!notprime[i])prime[++ tot] = i;

        for(int j = 1;j &lt;= tot &amp;&amp; i * prime[j] &lt;= 10'000'000;j ++) {
            notprime[i * prime[j]] = true;
            if(i % prime[j] == 0) {
                break;
            }
        }
    } 
}

void solve()
{
    int n;std::cin &gt;&gt; n;

    i64 ans = 0;
    for(int i = 1;i &lt;= tot &amp;&amp; prime[i] &lt;= n;i ++) {
        int a = 1;
        int b = prime[i];
        ans += n / b;
    }

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}

signed main()
{
    std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);

    init();

    int t = 1;std::cin &gt;&gt; t;
    while(t --)solve();

    return 0;
}
</code></pre>
</details>
<h2 id="f-igor-and-mountain">F. Igor and Mountain</h2>
<p><s>没错，就是这个题，赛时没看到输出那里有个 998244353，挂了一发，血压起来了。</s><br>
这个题是一个很简单的 DP，因为题目限制得很明确：</p>
<ul>
<li>只能一层一层爬。</li>
<li>每一层最多使用两个可抓点。</li>
</ul>
<p>那么思路就很明晰了，首先从低一层往当前层进行状态转移，然后再在同层进行状态转移。<br>
由于手臂距离为 <span class="math inline">\(d\)</span>，所以低一层的第 <span class="math inline">\(j\)</span> 个点位向当前层转移的范围应该是 <span class="math inline">\([j - \sqrt{d ^ 2 - 1}, j - \sqrt{d ^ 2 - 1}]\)</span>，由于相邻两个平方数之间的差值至少都是 <span class="math inline">\(1\)</span>，因此 <span class="math inline">\(\sqrt{d ^ 2 - 1} = d - 1\)</span>，避免浮点数精度误差。<br>
同层转移也是一样的，对于当前层第 <span class="math inline">\(j\)</span> 个点的转移范围应该是 <span class="math inline">\([j - d, j + d]\)</span>。<br>
但是如果暴力转移，复杂度为 <span class="math inline">\(O(nm^2)\)</span>，因此要考虑优化：我们发现，每一个状态向周围的转移都是一个区间，那么我们就可以使用差分来优化区间修改，时间复杂度优化为 <span class="math inline">\(O(nm)\)</span>，足以通过此题。</p>
<details>
<summary>点击查看代码（省略了取模类）</summary>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define inf32 1e9
#define inf64 2e18
#define int long long
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

void solve()
{
    int n, m, d;std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;
    std::vector&lt;std::vector&lt;char&gt;&gt; a(n + 1, std::vector&lt;char&gt;(m + 1));
    int x = d - 1;

    for(int i = 1;i &lt;= n;i ++) {
        for(int j = 1;j &lt;= m;j ++) {
            std::cin &gt;&gt; a[i][j];
        }
    }

    std::vector&lt;std::vector&lt;Z&gt;&gt; dp(n + 1, std::vector&lt;Z&gt;(m + 1, 0));

    std::vector&lt;Z&gt; f(m + 2, 0);
    for(int i = n;i &gt;= 1;i --) {
        for(auto &amp;i : f)i = 0;
        if(i == n) {
            for(int j = 1;j &lt;= m;j ++) {
                if(a[n][j] == 'X')dp[n][j] = 1;
                else dp[n][j] = 0;
            }
        } else {
            for(int j = 1;j &lt;= m;j ++) {
                int d = x;
                if(a[i + 1][j] == 'X') {
                    int l = std::max(j - d, 1ll);
                    int r = std::min(j + d, m);
                    f[l] += dp[i + 1][j];
                    f[r + 1] -= dp[i + 1][j];
                }
            }
            for(int j = 1;j &lt;= m;j ++) {
                f[j] += f[j - 1];
                if(a[i][j] == 'X') {
                    dp[i][j] += f[j];
                }
            }
        }

        for(auto &amp;i : f)i = 0;
    
        for(int j = 1;j &lt;= m;j ++) {
            if(a[i][j] == 'X') {
                int l = std::max(j - d, 1ll);
                int r = std::min(j + d, m);
                f[l] += dp[i][j];
                f[j] -= dp[i][j];
                f[j + 1] += dp[i][j];
                f[r + 1] -= dp[i][j];
            }
        }
        
        for(int j = 1;j &lt;= m;j ++) {
            f[j] += f[j - 1];
            if(a[i][j] == 'X') {
                dp[i][j] += f[j];
            }
        }
    }

    Z sum = 0;
    for(int j = 1;j &lt;= m;j ++) {
        sum += dp[1][j];
    }

    std::cout &lt;&lt; sum &lt;&lt; '\n';
}
</code></pre>
</details>

</div>
<div id="MySignature" role="contentinfo">
    <!-- 版权保护 -->
<div style="background:#ffcccc; color:#0; font-size:small;">
    <p>
            作者：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>
    </p>
    <p>
            出处：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">https://www.cnblogs.com/TianTianChaoFangDe</a>
    </p>
    <p>
            关于作者：ACMer，算法竞赛爱好者
    </p>
    <p>
             本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显醒目位置给出,
             <a href="#" onclick="Curgo()" style="background:#b6ff00; color:#0; font-size:medium;">原文链接</a>
             如有问题， 可邮件（1005333612@qq.com）咨询.
    </p>
    
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.005883263070601852" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-27 16:13">2025-03-27 16:09</span>&nbsp;
<a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18796248" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18796248);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18796248', targetLink: 'https://www.cnblogs.com/TianTianChaoFangDe/p/18796248', title: '【CF比赛记录】Codeforces Round 1013 (Div. 3)' })">举报</a>
</div>
        