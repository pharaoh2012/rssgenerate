
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/buaaczw/p/19026050" title="发布于 2025-08-07 23:15">
    <span role="heading" aria-level="2">JDK源码之Object</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>1、Object类简介</h1>
<pre>　　java中所有的类都会继承Object类，属于java.lang包。<br>　　Object类提供的方法如下：其中registerNatives()、getClass()、hashCode()、clone()、notify()、notifyAll()、wait(long timeout)为native方法，后面挑几个重要的方法讲一下。<br><br></pre>
　　<img alt="image" loading="lazy" style="font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-size: 14px" data-src="https://img2024.cnblogs.com/blog/2355347/202508/2355347-20250806224605700-105038675.png" class="lazyload">
<p>&nbsp;　　<strong>native</strong> 为java的一个关键字</p>
<p>　　JNI：Java Native Interface ，<span class="text_hMg13" data-text="true">从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码<span class="text_hMg13" data-text="true"><span class="text_hMg13" data-text="true">进行交互，例如C或者C++代码。</span></span></span></p>
<p><span class="text_hMg13" data-text="true"><span class="text_hMg13" data-text="true"><span class="text_hMg13" data-text="true">　　</span></span></span><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2355347/202508/2355347-20250806230242414-322351067.png" class="lazyload"></p>
<h1>2、源码</h1>
<h2>2.1、getClass方法　</h2>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">final</span> <span style="color: rgba(0, 0, 255, 1)">native</span> Class&lt;?&gt; getClass();</pre>
</div>
<p>　　getClass()方法返回对象运行时类。</p>
<h2>2.2、hashCode方法</h2>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">native</span> <span style="color: rgba(0, 0, 255, 1)">int</span> hashCode();</pre>
</div>
<p>　　hashCode()返回对象的hash值，为int类型。那么对象创建好之后何时计算hashCode值？计算出的hashCode的值存放在那里呢？那么我们来看一下一个java对象组成 。</p>
<p>　　<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2355347/202508/2355347-20250807221704480-1007393633.png" class="lazyload"></p>
<p>　　对象由对象头（对象头包括Mark Word 和 Class Pointer类型指针）、实例数据、对齐填充部分组成，数组对象比较特殊，会多数组长度部分。对齐填充部分时为了保证对象的大小是8字节的整数倍。　　</p>
<p>　　对象头中Mark Word用于存储对象自身的一些数据，具体存储信息如下图所示，对象头的大小在不同的虚拟机上的大小有所差异，通常为32bit或者64bit。</p>
<p>　　对象的hashCode值是在对象使用时调用hashCode函数时计算，并不是对象创建时就计算好的。</p>
<p>　　<img alt="image" width="1002" height="295" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2355347/202508/2355347-20250807222504472-1352987501.png" class="lazyload"></p>
<p>　　<img alt="image" width="1006" height="338" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2355347/202508/2355347-20250807222534086-541711270.png" class="lazyload"></p>
<p>&nbsp;</p>
<h2>2.3、equals方法</h2>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">boolean</span><span style="color: rgba(0, 0, 0, 1)"> equals(Object obj) {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> (<span style="color: rgba(0, 0, 255, 1)">this</span> ==<span style="color: rgba(0, 0, 0, 1)"> obj);
    }</span></pre>
</div>
<p>　　由源码可以看出，在Object这个类中，equals()方法和==是相同的，比较的是两个对象的引用是否相同。</p>
<p>　　我们比较两个字符串是否相等时，需要比较字符串本身的内容是否相等，而不希望比较字符串的引用地址是否相同，所有String类重写了equals()方法，让我一起看看源码。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">boolean</span><span style="color: rgba(0, 0, 0, 1)"> equals(Object anObject) {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (<span style="color: rgba(0, 0, 255, 1)">this</span> ==<span style="color: rgba(0, 0, 0, 1)"> anObject) { //如果引用的地址相同，那么这两个字符串必然相同，直接返回true
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (anObject <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> String) {//判断对象是否为String类型
            String anotherString </span>=<span style="color: rgba(0, 0, 0, 1)"> (String)anObject;//强转为String对象
            </span><span style="color: rgba(0, 0, 255, 1)">int</span> n =<span style="color: rgba(0, 0, 0, 1)"> value.length;//获取对象长度
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (n ==<span style="color: rgba(0, 0, 0, 1)"> anotherString.value.length) {
                </span><span style="color: rgba(0, 0, 255, 1)">char</span> v1[] =<span style="color: rgba(0, 0, 0, 1)"> value;
                </span><span style="color: rgba(0, 0, 255, 1)">char</span> v2[] =<span style="color: rgba(0, 0, 0, 1)"> anotherString.value;
                </span><span style="color: rgba(0, 0, 255, 1)">int</span> i = 0<span style="color: rgba(0, 0, 0, 1)">;
                </span><span style="color: rgba(0, 0, 255, 1)">while</span> (n-- != 0<span style="color: rgba(0, 0, 0, 1)">) { //依次比较每个字符
                    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (v1[i] !=<span style="color: rgba(0, 0, 0, 1)"> v2[i]) 
                        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">; //有一个不相同则返回false
                    i</span>++<span style="color: rgba(0, 0, 0, 1)">;
                }
                </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">; //内容完全，返回true
            }
        }
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">; //不是String对象直接返回false
    }</span></pre>
</div>
<p>　　如果在程序开发中需要比较对象的属性值是否相同，应该重写Object的equals方法，否则会调用Object的equals方法，使用==比较两个对象引用地址是否相同。</p>
<h2>2.4、clone方法</h2>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">native</span> Object clone() <span style="color: rgba(0, 0, 255, 1)">throws</span> CloneNotSupportedException;</pre>
</div>
<p>　　该方法实现对象的浅拷贝，使用<code class="dqa-code-span">clone()</code>方法时，记得捕获<code class="dqa-code-span">CloneNotSupportedException</code>异常，或者在类上实现<code class="dqa-code-span">Cloneable</code>接口但不抛出该异常（尽管这在实际操作中不常见）。此外，使用<code class="dqa-code-span">clone()</code>方法时要小心，因为它可能会导致性能问题或者在复杂对象图中出现问题（比如循环引用）。在Java中，通常推荐使用构造器或拷贝构造函数来实现浅拷贝或深拷贝，特别是在处理复杂对象时。。</p>
<p>&nbsp;　　浅拷贝（Shallow Copy）指的是创建一个新的对象，然后将原始对象的数据（字段）复制到新对象中。如果原始对象的字段是值类型（如int、double等基本数据类型，或者它们的包装类如Integer、Double等），这些值会被复制到新对象中。如果原始对象的字段是引用类型（如对象、数组等），那么这些引用类型的字段不会被复制其内容，而是复制引用本身的地址。这意味着新的对象和原始对象将引用同一个内存地址。</p>
<p>　　深拷贝：不仅复制对象本身，还递归地复制对象内部引用的所有对象。这意味着原始对象和副本对象不会共享任何引用指向的对象。</p>
<h2>2.5、finalize方法</h2>
<div class="cnblogs_code">
<pre> <span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> finalize() <span style="color: rgba(0, 0, 255, 1)">throws</span> Throwable { }</pre>
</div>
<p>　　当一个Java对象被垃圾回收器标记为不再使用时，垃圾回收器会调用对象的finalize()方法来清理这个对象。但是垃圾回收器并不保证会立马调用该方法，可能会在后面某个何时的时间再调用。</p>
<p>　　</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-07 23:16">2025-08-07 23:15</span>&nbsp;
<a href="https://www.cnblogs.com/buaaczw">buaa_czw</a>&nbsp;
阅读(<span id="post_view_count">48</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19026050);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19026050', targetLink: 'https://www.cnblogs.com/buaaczw/p/19026050', title: 'JDK源码之Object' })">举报</a>
</div>
        