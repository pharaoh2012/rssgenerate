
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ENchantedN/p/18899492" title="发布于 2025-05-27 22:20">
    <span role="heading" aria-level="2">计算机图形学——Games101深度解析_第一章</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="写在前面">写在前面</h1>
<p>关于Games101深度解析参考了很多佬的文章，并且加上了自己的理解。主要感觉games101课程里面还有很多由于时间原因都没讲的很详细，略过了很多，所以我对于课程中困难的知识点进行了更多的步骤思路解释，希望能对正在学习这篇课程的后者提供更清晰的思路。</p>
<p>本文建议配上games101视频以及games101网站中的PDF配合学习https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html</p>
<p>这一章含有大量线代的几何知识，对于线代的几何理解可以跳到这学习（一步一步看完基本上就没有太大的问题了）：<a href="https://www.bilibili.com/video/BV1Ys411k7yQ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=93699bcffa78a7a266992d3b23c6dc20" target="_blank" rel="noopener nofollow">https://www.bilibili.com/video/BV1Ys411k7yQ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=93699bcffa78a7a266992d3b23c6dc20</a><br>
这一章由于知识点都较为简单，所以看起来会很杂，但是后面从第二章开始就开始有章法了。刚开始的数学基础知识就不再提了，我们从线代在图形学的应用开始。</p>
<p>参考文章：<br>
<a href="https://zhuanlan.zhihu.com/p/394932478" target="_blank" rel="noopener nofollow">https://zhuanlan.zhihu.com/p/394932478</a><br>
<a href="https://iewug.github.io/book/GAMES101.html#2-3d-transformation" target="_blank" rel="noopener nofollow">https://iewug.github.io/book/GAMES101.html#2-3d-transformation</a><br>
<a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html" target="_blank" rel="noopener nofollow">https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html</a><br>
<a href="https://caterpillarstudygroup.github.io/GAMES101_mdbook/index.html" target="_blank" rel="noopener nofollow">https://caterpillarstudygroup.github.io/GAMES101_mdbook/index.html</a></p>
<h1 id="向量叉乘的应用">向量叉乘的应用</h1>
<p><img src="https://img2024.cnblogs.com/blog/3033596/202505/3033596-20250527215832942-1317410837.png" alt="" loading="lazy"><br>
上图中，判断p是否在三角形ABC的内侧，只用将p点与ABC三点相连接，然后再分别叉乘三个边，看结果的符号是否一致，若一致，那么就在内侧，反之亦然。<br>
比如AP叉乘AB，然后BP叉乘BC，然后CP叉乘CA，他们的符号都是一致的，则P就在三角形的里面</p>
<h1 id="指令矩阵在图形学的应用">指令矩阵在图形学的应用</h1>
<p></p><div class="math display">\[\begin{pmatrix} -1 &amp; 0 \\ 0 &amp; 1 \end{pmatrix} \begin{pmatrix} x \\ y \end{pmatrix} = \begin{pmatrix} -x \\ y \end{pmatrix}
\]</div><p></p><p>上面的矩阵做的就是：在二维里面，我们把整个图形以y轴为对称轴做一个对称图形。<br>
那么我们y轴就不用变，把x的数都换个符号就行。上面不止是指令矩阵的角度，线性变换也是这个角度。</p>
<h2 id="几种变换">几种变换</h2>
<p>根据上面的内容我们就可以得到下面的效果</p>
<ul>
<li>
<p>缩放矩阵<br>
<img src="https://img2024.cnblogs.com/blog/3033596/202505/3033596-20250527220356597-2053731512.png" alt="" loading="lazy"></p>
</li>
<li>
<p>拉伸变换<br>
<img src="https://img2024.cnblogs.com/blog/3033596/202505/3033596-20250527220432438-1249336265.png" alt="" loading="lazy"></p>
</li>
<li>
<p>旋转变换<br>
<img src="https://img2024.cnblogs.com/blog/3033596/202505/3033596-20250527220451621-267976749.png" alt="" loading="lazy"></p>
</li>
</ul>
<p><strong>平移变换</strong><br>
我们前面看了这么多变换都是基于原点的变换，但是如果是下面的这个变换（平移）我们该怎么表示呢？<br>
<img src="https://img2024.cnblogs.com/blog/3033596/202505/3033596-20250527220539659-198897222.png" alt="" loading="lazy"></p>
<p>我们这个时候就发现了，我们常规的矩阵往往都只能表示一个向量，但是我们明白，向量平移是不会改变什么的，常规矩阵就是没有办法去表示平移这个动作。<br>
这个时候我们就引入一个新的东西：齐次坐标（homogeneous coordinates）</p>
<blockquote>
<p>齐次坐标是用N+1个数来表示N维坐标的一种方式。</p>
</blockquote>
<p>要制作二维齐次坐标，我们只需在现有坐标中增加一个额外的变量w，这个w并不代表更高维度的一个坐标，简单说就是表示这里的（x,y）是一个向量或者是一个点。<br>
因此，笛卡尔坐标中的一点，(X，Y)在齐次坐标中就变成了(x，y，w)。<strong>在w=1的时候，齐次坐标就是一个点，而w=0的时候，齐次坐标表示的就是一个向量</strong>。而笛卡儿坐标中的X和Y在齐次坐标中的x、y和w则重新表达为（这里把所有的坐标都除了一个<span class="math inline">\(w\)</span> ,这样<span class="math inline">\(w\)</span> 的值就必定是1，那就是一个向量）</p>
<p></p><div class="math display">\[\begin{align}
X = x/w\\  
Y = y/w\\
\end{align}
\]</div><p></p><p>那怎么应用到实际的平移中呢，就是以下的变换。这样的变换成功表示了每一个平移的点，而且直观的有了一个平移的指令矩阵</p>
<p></p><div class="math display">\[\begin{bmatrix} x' \\ y' \\ w' \end{bmatrix} = \begin{bmatrix} 1 &amp; 0 &amp; t_x \\ 0 &amp; 1 &amp; t_y \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \cdot \begin{bmatrix} x \\ y \\ 1 \end{bmatrix} = \begin{bmatrix} x + t_x \\ y + t_y \\ 1 \end{bmatrix}
\]</div><p></p><h3 id="欧氏空间中数学证明两条平行线可以相交">欧氏空间中数学证明：两条平行线可以相交</h3>
<p>考虑以下欧氏空间的线性系统。</p>
<p></p><div class="math display">\[\begin{cases} 
Ax + By + C = 0 \\ 
Ax + By + D = 0 
\end{cases}
\]</div><p></p><p>而我们知道，由于 <span class="math inline">\(C \neq D\)</span>，所以上述方程没有解。如果 <span class="math inline">\(C = D\)</span>，那么两条线是相同的（重叠的）。<br>
让我们重写投影空间的方程，将 \( x \) 和 \( y \) 分别替换为 \( x/w \)，\( y/w \)。</p>
<p></p><div class="math display">\[\begin{cases} 
A\frac{x}{w} + B\frac{y}{w} + C = 0 \\ 
A\frac{x}{w} + B\frac{y}{w} + D = 0 
\end{cases}
\Rightarrow
\begin{cases} 
Ax + By + Cw = 0 \\ 
Ax + By + Dw = 0 
\end{cases}
\]</div><p></p><p>现在，我们有一个解，(x, y, 0)，因为 (C-D)w = 0，所以 w = 0。因此，两条平行线在  (x, y, 0)  处相交。<br>
(x, y, 0)  在几何上代表一条没有起点与终点，也没有长度的射线，它只有方向。</p>
<h3 id="点与向量的加减">点与向量的加减</h3>
<ul>
<li>vector + vector = vector</li>
<li>point - point = vector</li>
<li>point + vector = vector</li>
<li>point + point = 两点的中点 (因为<span class="math inline">\((x_1,y_1,1)\)</span> + <span class="math inline">\((x_2,y_2,1)\)</span> = <span class="math inline">\((x_1+x_2,y_1+y_2,2)\)</span> = <span class="math inline">\((\frac{x_1+x_2}{2},\frac{y_1+y_2}{2},1)\)</span>）)</li>
</ul>
<h3 id="仿射变换">仿射变换</h3>
<p></p><div class="math display">\[\begin{pmatrix}x' \\y'\end{pmatrix}=\begin{pmatrix}a &amp; b \\c &amp; d\end{pmatrix}\cdot\begin{pmatrix}x \\y\end{pmatrix}+\begin{pmatrix}t_x \\t_y\end{pmatrix}
\]</div><p></p><p>像这样线性变换之后加上平移量的变换叫做放射变换<br>
所有的放射变换都可以写成齐次坐标的形式</p>
<p></p><div class="math display">\[\begin{pmatrix}
x' \\
y' \\
1
\end{pmatrix}
=
\begin{pmatrix}
a &amp; b &amp; t_x \\
c &amp; d &amp; t_y \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\cdot
\begin{pmatrix}
x \\
y \\
1
\end{pmatrix}
\]</div><p></p><blockquote>
<p>[!danger]<br>
<strong>注意</strong>: 在上面的变换中我们能够发现，是先线性变换再进行平移的</p>
</blockquote>
<ol>
<li>缩放矩阵</li>
</ol>
<p></p><div class="math display">\[\mathbf{S}(s_x, s_y) = 
\begin{pmatrix}
s_x &amp; 0 &amp; 0 \\
0 &amp; s_y &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\]</div><p></p><ol start="2">
<li>旋转矩阵</li>
</ol>
<p></p><div class="math display">\[\mathbf{R}(\alpha) = 
\begin{pmatrix}
\cos \alpha &amp; -\sin \alpha &amp; 0 \\
\sin \alpha &amp; \cos \alpha &amp; 0 \\


0 &amp; 0 &amp; 1
\end{pmatrix}
\]</div><p></p><ol start="3">
<li>平移矩阵 ：</li>
</ol>
<p></p><div class="math display">\[\mathbf{T}(t_x, t_y) = 
\begin{pmatrix}
1 &amp; 0 &amp; t_x \\
0 &amp; 1 &amp; t_y \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\]</div><p></p><h2 id="逆变换">逆变换</h2>
<p><img src="https://img2024.cnblogs.com/blog/3033596/202505/3033596-20250527220833938-1799865903.png" alt="" loading="lazy"></p>
<blockquote>
<p>[!note]<br>
逆变换刚好对应矩阵中：一个矩阵 x 该矩阵的逆矩阵 = 单位矩阵（什么都没做）</p>
</blockquote>
<p>值得注意的是，如果旋转负角度，我们就能发现:</p>
<blockquote>
<p>[!note]<br>
旋转矩阵的逆矩阵就是旋转矩阵的转置矩阵：<span class="math inline">\({R_\alpha}^T={R_\alpha}^{-1}\)</span></p>
</blockquote>
<blockquote>
<p>[!note] 如果一个矩阵的逆等于他的转置，那么我们称此矩阵为正交矩阵</p>
</blockquote>
<p><span class="math inline">\(\mathbf{R}(\alpha) = \begin{pmatrix}\cos \alpha &amp; -\sin \alpha  \\\sin \alpha &amp; \cos \alpha  \\\end{pmatrix}\)</span>      <span class="math inline">\(\mathbf{R}(-\alpha) = \begin{pmatrix}\cos \alpha &amp; \sin \alpha  \\-\sin \alpha &amp; \cos \alpha  \\\end{pmatrix} ={R_\alpha}^T={R_\alpha}^{-1}\)</span></p>
<h2 id="矩阵的乘法没有交换律变换的顺序会导致结果不同">矩阵的乘法没有交换律：变换的顺序会导致结果不同</h2>
<p>先平移再旋转如下：<br>
<img src="https://img2024.cnblogs.com/blog/3033596/202505/3033596-20250527220924770-1771814746.png" alt="" loading="lazy"></p>
<p>先旋转再平移如下：<br>
<img src="https://img2024.cnblogs.com/blog/3033596/202505/3033596-20250527220939039-663534290.png" alt="" loading="lazy"></p>
<p>这里就能够体现出两者的变换顺序不同对应着矩阵的乘法没有交换律。<br>
当然，多个线性变换由于有结合律的缘故，我们可以对线性变换先进行线性变换，最后得到一个大的线性变换再对其最开始的向量进行线性变换都行</p>
<h2 id="任意点的旋转">任意点的旋转</h2>
<p>我们前面只知道怎么沿着原点旋转，如果要沿着其他的一个点旋转一个图形，我们就可以先平移到原点，然后进行旋转，最后我们旋转完之后再平移回去是一样的。<br>
<img src="https://img2024.cnblogs.com/blog/3033596/202505/3033596-20250527221002767-566063851.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.08221069675694445" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-27 22:21">2025-05-27 22:20</span>&nbsp;
<a href="https://www.cnblogs.com/ENchantedN">ENchantEd丨</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18899492);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18899492', targetLink: 'https://www.cnblogs.com/ENchantedN/p/18899492', title: '计算机图形学——Games101深度解析_第一章' })">举报</a>
</div>
        