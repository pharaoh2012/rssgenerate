
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ivictor/p/18801558" title="发布于 2025-03-31 09:25">
    <span role="heading" aria-level="2">如何定位 Druid &amp; HikariCP 连接池的连接泄漏问题？</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        
        在数据库连接池的使用中，连接泄漏是一个常见且严重的问题。本文通过分析一个实际的案例，探讨了连接泄漏的危害、产生原因以及如何在 Druid 和 HikariCP 这两种常见的连接池中定位和解决连接泄漏问题。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">背景</span></h1>
<p data-tool="mdnice编辑器"><span>最近碰到一个 case，一个 Java 应用无法获取新的数据库连接，日志中出现了以下错误：</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpcJtqyGNNKFqWHWMeXtTk1DbEEpngJQ0FUtTrysZNcM3iaveOZjnCXmVhYvucSsAVJUCicibHTTbE02/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis&nbsp;5001<span>, active&nbsp;20<span>, maxActive&nbsp;20<span>, creating&nbsp;0<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; at com.alibaba.druid.pool.DruidDataSource.getConnectionInternal(DruidDataSource.java:1894<span>)<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; at com.alibaba.druid.pool.DruidDataSource.getConnectionDirect(DruidDataSource.java:1502<span>)<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1482<span>)<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1463<span>)<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>active 等于 maxActive，说明连接池中的连接已耗尽。</span></p>
<p data-tool="mdnice编辑器"><span>分析报错时间段的数据库连接情况，发现数据库的连接数（Threads_connected）显著增加，但活跃线程数（Threads_running）较低且平稳。活跃线程数低且平稳意味着没有慢查询占用连接。但连接数增加明显，说明连接未被及时释放回连接池。</span></p>
<p data-tool="mdnice编辑器"><span>对于这种在一定时间内没有进行任何操作，但又未及时归还到连接池的连接，其实有个专用名词，即泄漏连接（<code><span>Leaked Connection</span></code><span>）。</span></span></p>
<p data-tool="mdnice编辑器"><span>下面，我们聊聊泄漏连接的相关问题，包括：</span></p>
<ol class="list-paddingleft-1">
<li><span>泄漏连接的危害。</span></li>
<li><span>泄漏连接的产生原因。</span></li>
<li><span>Druid 中如何定位泄漏连接。</span></li>
<li><span>HikariCP 中如何定位泄漏连接。</span></li>
</ol>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">泄漏连接的危害</span></h1>
<p data-tool="mdnice编辑器"><span>泄漏连接可能引发以下问题：</span></p>
<ol class="list-paddingleft-1">
<li>
<p><span>连接池耗尽：泄漏的连接会持续占用连接池中的资源，导致可用连接逐渐减少，最终耗尽连接池。</span></p>
</li>
<li>
<p><span>应用性能下降：当连接池中的连接被耗尽时，新的数据库操作无法获取连接，导致请求阻塞或失败，这可能导致应用程序无法正常运行。</span></p>
</li>
<li>
<p><span>数据库资源浪费：泄漏的连接会占用数据库的连接资源，可能导致数据库的连接数达到上限。</span></p>
</li>
<li>
<p><span>连接失效风险：长时间未释放的连接无法通过连接池的 Keep-Alive 机制保持活跃，更容易因空闲超时被 MySQL 服务端或中间件关闭。</span></p>
<p><span>当使用这些已关闭的连接执行数据库操作时，会触发经典的 “Communications link failure. The last packet successfully received from the server was xxx milliseconds ago.” 错误。</span></p>
</li>
</ol>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">泄漏连接的产生原因</span></h1>
<p data-tool="mdnice编辑器"><span>泄漏连接通常由以下原因导致：</span></p>
<p data-tool="mdnice编辑器"><span>1. 长事务或长连接。</span></p>
<p data-tool="mdnice编辑器"><span>事务长时间未提交或连接长时间未释放。</span></p>
<p data-tool="mdnice编辑器"><span>2. 未关闭连接。</span></p>
<p data-tool="mdnice编辑器"><span>在使用完连接后，未调用<code><span>close()</span></code><span>方法将连接归还到连接池。如，</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpcJtqyGNNKFqWHWMeXtTk1DbEEpngJQ0FUtTrysZNcM3iaveOZjnCXmVhYvucSsAVJUCicibHTTbE02/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>Connection conn = dataSource.getConnection();<span><br>// 执行数据库操作<span><br>// 忘记调用 conn.close();<span><br></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>3. 异常未处理。</span></p>
<p data-tool="mdnice编辑器"><span>在数据库操作过程中发生异常，导致连接未正常关闭。如，</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpcJtqyGNNKFqWHWMeXtTk1DbEEpngJQ0FUtTrysZNcM3iaveOZjnCXmVhYvucSsAVJUCicibHTTbE02/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>Connection conn =&nbsp;null<span>;<span><br>try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; conn = dataSource.getConnection();<span><br><span>&nbsp; &nbsp;&nbsp;// 执行数据库操作<span><br><span>&nbsp; &nbsp;&nbsp;thrownew<span>&nbsp;RuntimeException("模拟异常"<span>);<span><br><span>}&nbsp;catch<span>&nbsp;(SQLException e) {<span><br><span>&nbsp; &nbsp; e.printStackTrace();<span><br><span>}&nbsp;finally<span>&nbsp;{<span><br><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(conn !=&nbsp;null<span>) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conn.close();&nbsp;// 异常发生后，可能不会执行到此处<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;catch<span>&nbsp;(SQLException e) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.printStackTrace();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; }<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">Druid 中如何定位泄漏连接</span></h1>
<p data-tool="mdnice编辑器"><span>在 Druid 连接池中，可以通过以下参数开启未归还连接的检测：</span></p>
<ul class="list-paddingleft-1">
<li><span>removeAbandoned：是否回收超时未归还的连接，默认值为 false，表示不回收。</span></li>
<li><span>removeAbandonedTimeoutMillis：未归还连接的超时时间（单位：毫秒）。默认值为 300000（即 300 秒）。</span></li>
<li><span>logAbandoned：是否将超时未归还的连接信息打印到日志中。默认值为 false，表示不打印。</span></li>
</ul>
<p data-tool="mdnice编辑器"><span>需要注意的是，logAbandoned 仅在 removeAbandoned 为 true 时生效。也就是说，Druid 连接池不支持仅打印，但不回收超时未归还连接的功能。</span></p>
<h2 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">实现细节</span></h2>
<p data-tool="mdnice编辑器"><span>在从连接池获取连接时，如果<code><span>removeAbandoned</span></code><span>为 true，则会记录连接的堆栈信息和创建时间，用于检测未归还连接。</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpcJtqyGNNKFqWHWMeXtTk1DbEEpngJQ0FUtTrysZNcM3iaveOZjnCXmVhYvucSsAVJUCicibHTTbE02/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>public<span>&nbsp;DruidPooledConnection&nbsp;<span>getConnectionDirect<span>(<span>long<span>&nbsp;maxWaitMillis)<span>&nbsp;<span>throws<span>&nbsp;SQLException&nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; ...<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for<span>&nbsp;(; ; ) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DruidPooledConnection poolableConnection;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; poolableConnection = getConnectionInternal(maxWaitMillis);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;catch<span>&nbsp;(GetConnectionTimeoutException ex) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(removeAbandoned) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 记录堆栈信息，方便调试，找出未及时关闭连接的代码位置<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();&nbsp;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; poolableConnection.connectStackTrace = stackTrace;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 设置连接的connectedTimeNano为当前时间<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; poolableConnection.setConnectedTimeNano();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; poolableConnection.traceEnable =&nbsp;true<span>;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 将连接加入活跃连接列表，用于后续的未归还连接检测。<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; activeConnectionLock.lock();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; activeConnections.put(poolableConnection, PRESENT);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;finally<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; activeConnectionLock.unlock();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return<span>&nbsp;poolableConnection;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; }<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<h2 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">什么时候会检测连接是否超时呢？</span></h2>
<p data-tool="mdnice编辑器"><span>这个实际上是在<code><span>DestroyConnectionThread</span></code><span>的周期任务中进行的，在上一篇文章中，我们提到过<code><span>DestroyConnectionThread</span></code><span>按照一定的时间间隔（由 timeBetweenEvictionRunsMillis 参数决定，默认为 60秒）调用<code><span>shrink(true, keepAlive)</span></code><span>方法，销毁连接池中的过期连接。其实，除了 shrink 方法，它还会调用<code><span>removeAbandoned()</span></code><span>来关闭那些超时未归还的连接。</span></span></span></span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpcJtqyGNNKFqWHWMeXtTk1DbEEpngJQ0FUtTrysZNcM3iaveOZjnCXmVhYvucSsAVJUCicibHTTbE02/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code>public<span>&nbsp;<span>class<span>&nbsp;<span>DestroyTask<span>&nbsp;<span>implements<span>&nbsp;<span>Runnable<span>&nbsp;<span>{<span><br><span>&nbsp; &nbsp;&nbsp;<span>public<span>&nbsp;<span>DestroyTask<span>()<span>&nbsp;<span>{<span><br><span>&nbsp; &nbsp; }<span><br><span><br><span>&nbsp; &nbsp;&nbsp;@Override<span><br><span>&nbsp; &nbsp;&nbsp;<span>public<span>&nbsp;<span>void<span>&nbsp;<span>run<span>()<span>&nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; shrink(true<span>, keepAlive);<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(isRemoveAbandoned()) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; removeAbandoned();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; }<span><br><span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>下面，我们看看<code><span>removeAbandoned()</span></code><span>具体的实现细节。</span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpcJtqyGNNKFqWHWMeXtTk1DbEEpngJQ0FUtTrysZNcM3iaveOZjnCXmVhYvucSsAVJUCicibHTTbE02/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>public<span>&nbsp;<span>int<span>&nbsp;<span>removeAbandoned<span>()<span>&nbsp;<span>{<span><br><span>&nbsp; &nbsp;&nbsp;int<span>&nbsp;removeCount =&nbsp;0<span>;<span><br><span>&nbsp; &nbsp;&nbsp;// 如果当前没有活跃连接（activeConnections 为空），则直接返回<span><br><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(activeConnections.size() ==&nbsp;0<span>) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return<span>&nbsp;removeCount;<span><br><span>&nbsp; &nbsp; }<span><br><span><br><span>&nbsp; &nbsp;&nbsp;long<span>&nbsp;currrentNanos = System.nanoTime();<span><br><span><br><span>&nbsp; &nbsp; List&lt;DruidPooledConnection&gt; abandonedList =&nbsp;new<span>&nbsp;ArrayList&lt;DruidPooledConnection&gt;();<span><br><span><br><span>&nbsp; &nbsp; activeConnectionLock.lock();<span><br><span>&nbsp; &nbsp;&nbsp;try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; Iterator&lt;DruidPooledConnection&gt; iter = activeConnections.keySet().iterator();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 遍历活跃连接<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for<span>&nbsp;(; iter.hasNext(); ) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DruidPooledConnection pooledConnection = iter.next();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 如果连接正在运行（isRunning()），则跳过<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(pooledConnection.isRunning()) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;continue<span>;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 计算连接的使用时间（timeMillis），即当前时间减去连接的借出时间。<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;long<span>&nbsp;timeMillis = (currrentNanos - pooledConnection.getConnectedTimeNano()) / (1000<span>&nbsp;*&nbsp;1000<span>);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 如果连接的使用时间超过了 removeAbandonedTimeoutMillis，则将其从活跃连接列表中移除，并加入 abandonedList<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(timeMillis &gt;= removeAbandonedTimeoutMillis) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iter.remove();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pooledConnection.setTraceEnable(false<span>);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abandonedList.add(pooledConnection);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; }&nbsp;finally<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; activeConnectionLock.unlock();<span><br><span>&nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp;&nbsp;// 遍历 abandonedList，对每个未归还的连接调用 JdbcUtils.close() 关闭连接<span><br><span>&nbsp; &nbsp;&nbsp;if<span>&nbsp;(abandonedList.size() &gt;&nbsp;0<span>) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for<span>&nbsp;(DruidPooledConnection pooledConnection : abandonedList) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JdbcUtils.close(pooledConnection);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pooledConnection.abandond();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; removeAbandonedCount++;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; removeCount++;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 如果 logAbandoned 为 true，则记录未归还连接的详细信息<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(isLogAbandoned()) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringBuilder buf =&nbsp;new<span>&nbsp;StringBuilder();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf.append("abandon connection, owner thread: "<span>);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf.append(pooledConnection.getOwnerThread().getName());<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf.append(", connected at : "<span>);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG.error(buf.toString());<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; }<span><br><span><br><span>&nbsp; &nbsp;&nbsp;return<span>&nbsp;removeCount;<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>该方法的处理流程如下：</span></p>
<ol class="list-paddingleft-1">
<li><span>遍历当前活跃连接（activeConnections），检查每个连接的使用时间。连接的使用时间等于当前时间减去连接的借出时间（即<code><span>borrow</span></code><span>时刻的时间戳）。</span></span></li>
<li><span>如果某个连接的使用时间超过了<code><span>removeAbandonedTimeoutMillis</span></code><span>，则将其加入 abandonedList。</span></span></li>
<li><span>遍历 abandonedList，关闭这些未归还的连接。如果<code><span>logAbandoned</span></code><span>为 true，则会在日志中打印未归还连接的详细信息。通过分析日志，可以定位泄漏连接的代码位置。</span></span></li>
</ol>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">HikariCP 中如何定位泄漏连接</span></h1>
<p data-tool="mdnice编辑器"><span>在 HikariCP 连接池中，可以通过以下参数开启连接泄漏检测：</span></p>
<ul class="list-paddingleft-1">
<li><span>leakDetectionThreshold：连接泄漏检测阈值（单位：毫秒）。如果一个连接在从连接池获取后超过指定时间未被关闭，则认为是泄漏连接。默认为 0，表示禁用连接泄漏检测。最小可设置为 2000（2 秒）。</span></li>
</ul>
<p data-tool="mdnice编辑器"><span>当出现泄漏连接时，HikariCP 日志中会打印以下信息</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpcJtqyGNNKFqWHWMeXtTk1DbEEpngJQ0FUtTrysZNcM3iaveOZjnCXmVhYvucSsAVJUCicibHTTbE02/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>Connection leak detection triggered&nbsp;for<span>&nbsp;com.mysql.cj.jdbc.ConnectionImpl@5<span>dd31d98 on thread com.example.HikariCPTest.main(), stack trace follows<span><br><span>java.lang.Exception: Apparent connection leak detected<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:100<span>)<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; at com.example.HikariCPTest.main(HikariCPTest.java:27<span>)<span><br><span>...<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<h2 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">实现细节</span></h2>
<p data-tool="mdnice编辑器"><span>在从连接池获取连接后，系统会调用<code><span>leakTaskFactory.schedule(poolEntry)</span></code><span>启动一个 ProxyLeakTask 定时任务。该任务将在<code><span>leakDetectionThreshold</span></code><span>毫秒后触发<code><span>run()</span></code><span>方法，用于检测并打印连接泄漏信息。</span></span></span></span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpcJtqyGNNKFqWHWMeXtTk1DbEEpngJQ0FUtTrysZNcM3iaveOZjnCXmVhYvucSsAVJUCicibHTTbE02/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>public<span>&nbsp;Connection&nbsp;<span>getConnection<span>(<span>final<span>&nbsp;<span>long<span>&nbsp;hardTimeout)<span>&nbsp;<span>throws<span>&nbsp;SQLException<span><br><span>&nbsp; &nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp; suspendResumeLock.acquire();<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;finalvar<span>&nbsp;startTime = currentTime();<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;try<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var<span>&nbsp;timeout = hardTimeout;<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;do<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 从连接池中获取空闲连接<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;var<span>&nbsp;poolEntry = connectionBag.borrow(timeout, MILLISECONDS);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(poolEntry ==&nbsp;null<span>) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break<span>;&nbsp;// We timed out... break and throw exception<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;finalvar<span>&nbsp;now = currentTime();<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 若连接已被标记为驱逐 (evict) 或检测到无效，则关闭该连接<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(poolEntry.isMarkedEvicted() || (elapsedMillis(poolEntry.lastAccessed, now) &gt; aliveBypassWindowMs &amp;&amp; isConnectionDead(poolEntry.connection))) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;closeConnection(poolEntry, poolEntry.isMarkedEvicted() ? EVICTED_CONNECTION_MESSAGE : DEAD_CONNECTION_MESSAGE);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;timeout = hardTimeout - elapsedMillis(startTime);<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;else<span>&nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 返回一个代理连接，并启动连接泄漏检测任务<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return<span>&nbsp;poolEntry.createProxyConnection(leakTaskFactory.schedule(poolEntry));<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}&nbsp;while<span>&nbsp;(timeout &gt;&nbsp;0L<span>);<span><br><span>&nbsp; &nbsp; &nbsp;...<span><br><span>&nbsp; &nbsp;}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<p data-tool="mdnice编辑器"><span>如果连接在<code><span>leakDetectionThreshold</span></code><span>时间内被归还（即调用了<code><span>close()</span></code><span>方法），系统会调用<code><span>leakTask.cancel()</span></code><span>取消定时任务，从而避免触发<code><span>run()</span></code><span>方法。</span></span></span></span></span></p>
<p data-tool="mdnice编辑器"><span>如果连接超时未归还，系统将执行 run() 方法，打印连接泄漏信息。</span></p>
<p data-tool="mdnice编辑器"><span>以下是 ProxyLeakTask 的具体实现。</span></p>
<pre data-tool="mdnice编辑器"><span data-cacheurl="" data-remoteid="" data-lazy-bgimg="https://mmbiz.qpic.cn/mmbiz_svg/BO1qQiajiacVll2lZZ7QEHpcJtqyGNNKFqWHWMeXtTk1DbEEpngJQ0FUtTrysZNcM3iaveOZjnCXmVhYvucSsAVJUCicibHTTbE02/640?wx_fmt=svg&amp;from=appmsg" data-fail="0"><code><span>class<span>&nbsp;<span>ProxyLeakTask<span>&nbsp;<span>implements<span>&nbsp;<span>Runnable<span><br><span>{<span><br><span>&nbsp; ...<span><br><span>&nbsp; &nbsp;ProxyLeakTask(final<span>&nbsp;PoolEntry poolEntry)<span><br><span>&nbsp; &nbsp;{<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;this<span>.exception =&nbsp;new<span>&nbsp;Exception("Apparent connection leak detected"<span>);<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;this<span>.threadName = Thread.currentThread().getName();<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;this<span>.connectionName = poolEntry.connection.toString();<span><br><span>&nbsp; &nbsp;}<span><br><span>&nbsp; &nbsp;...<span><br><span>&nbsp; &nbsp;<span>void<span>&nbsp;<span>schedule<span>(ScheduledExecutorService executorService,&nbsp;<span>long<span>&nbsp;leakDetectionThreshold)<span><br><span>&nbsp; &nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp; scheduledFuture = executorService.schedule(this<span>, leakDetectionThreshold, TimeUnit.MILLISECONDS);<span><br><span>&nbsp; &nbsp;}<span><br><span><br><span>&nbsp; &nbsp;<span>/** {<span>@inheritDoc<span>} */<span><br><span>&nbsp; &nbsp;@Override<span><br><span>&nbsp; &nbsp;<span>public<span>&nbsp;<span>void<span>&nbsp;<span>run<span>()<span><br><span>&nbsp; &nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp; isLeaked =&nbsp;true<span>;<span><br><span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;finalvar<span>&nbsp;stackTrace = exception.getStackTrace();<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;finalvar<span>&nbsp;trace =&nbsp;new<span>&nbsp;StackTraceElement[stackTrace.length -&nbsp;5<span>];<span><br><span><br><span>&nbsp; &nbsp; &nbsp; System.arraycopy(stackTrace,&nbsp;5<span>, trace,&nbsp;0<span>, trace.length);<span><br><span><br><span>&nbsp; &nbsp; &nbsp; exception.setStackTrace(trace);<span><br><span>&nbsp; &nbsp; &nbsp; LOGGER.warn("Connection leak detection triggered for {} on thread {}, stack trace follows"<span>, connectionName, threadName, exception);<span><br><span>&nbsp; &nbsp;}<span><br><span><br><span>&nbsp; &nbsp;<span>void<span>&nbsp;<span>cancel<span>()<span><br><span>&nbsp; &nbsp;<span>{<span><br><span>&nbsp; &nbsp; &nbsp; scheduledFuture.cancel(false<span>);<span><br><span>&nbsp; &nbsp; &nbsp;&nbsp;if<span>&nbsp;(isLeaked) {<span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LOGGER.info("Previously reported leaked connection {} on thread {} was returned to the pool (unleaked)"<span>, connectionName, threadName);<span><br><span>&nbsp; &nbsp; &nbsp; }<span><br><span>&nbsp; &nbsp;}<span><br><span>}<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></span></pre>
<h1 data-tool="mdnice编辑器"><span style="color: rgba(0, 128, 0, 1)">总结</span></h1>
<p data-tool="mdnice编辑器"><span>泄漏连接是指在使用完数据库连接后未及时归还连接池的连接。泄漏连接的主要危害包括连接池耗尽、应用性能下降、数据库资源浪费以及潜在的连接失效风险。泄漏连接的产生原因通常包括未正确关闭连接、未处理异常或长事务等。</span></p>
<p data-tool="mdnice编辑器"><span>Druid 和 HikariCP 两大常用连接池提供了相应的泄漏连接检测机制。Druid 通过<code><span>DestroyConnectionThread</span></code><span>周期性检测未归还的连接，并在超时后关闭这些连接。如果<code><span>logAbandoned</span></code><span>为 true，还会打印未归还连接的详细信息。HikariCP 则通过<code><span>leakDetectionThreshold</span></code><span>参数开启连接泄漏检测。当连接在指定时间内未被归还时，HikariCP 会触发<code><span>ProxyLeakTask</span></code><span>，打印连接泄漏信息。</span></span></span></span></span></p>
<p data-tool="mdnice编辑器"><span>在开发和测试环境中，建议开启连接泄漏检测功能，以便尽早发现问题并进行修复。</span></p>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.06940776783217592" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-31 09:25">2025-03-31 09:25</span>&nbsp;
<a href="https://www.cnblogs.com/ivictor">iVictor</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18801558" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18801558);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18801558', targetLink: 'https://www.cnblogs.com/ivictor/p/18801558', title: '如何定位 Druid &amp;amp; HikariCP 连接池的连接泄漏问题？' })">举报</a>
</div>
	