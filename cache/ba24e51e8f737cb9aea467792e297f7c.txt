
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ttdb-huu/p/18794990" title="发布于 2025-03-26 23:02">
    <span role="heading" aria-level="2">io流</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="io流">io流</h1>
<p>java为了操作文件提供的File类，file代表文本，io流读写数据</p>
<h2 id="file">File</h2>
<h3 id="创建对象">创建对象</h3>
<pre><code class="language-java">public File(String pathname)
    //根据文件路径创建文件对象
    //路径中，D:/resource即可，反斜杠需要写两个一个转义 D:\\resource
    //分隔符File.separator---常量
    //一般使用相对路径
</code></pre>
<pre><code class="language-java">public File(String parent,String child)
//根据父路径和子路径名字创建文件对象
public File(File parent,String child)
//根据父路径对应文件对象和子路径名字创建文件对象
</code></pre>
<h3 id="判断文件类型获取文件信息">判断文件类型，获取文件信息</h3>
<ul>
<li>方法很多建议自己查</li>
</ul>
<pre><code class="language-java">//1.创建文件对象，指代某个文件
File f1 = new File(pathname:"D:/resource/ab.txt");
//2、public boolean exists（）：判断当前文件对象，对应的文件路径是否存在，存在返回true，

//3、pubLic boolean isFile（）：判断当前文件对象指代的是否是文件，是文件返回true，反之。

//4、pubLic boolean isDirectory（）：判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。

//5.public String getName（）：获取文件的名称（包含后缀）

//6.public long length（：获取文件的大小，返回字节个数

//8.pubLic String qetPath（）：获取创建文件对象时，使用的路径

//9.public String getAbsolutePath（)：获取绝对路径
</code></pre>
<h3 id="创建文件删除文件">创建文件、删除文件</h3>
<pre><code class="language-java">1、public boolean createNewFile():创建一个新文件（文件内容为空），创建成功返回true
    
2、public boolean mkdir():用于创定文件夹，注意：创定一级文件夹
    
3、public boolean mkdirs():用于创建文件夹，注意：可以创建多级文件夹
    
3、public boolean delete():别除文件，或者空文件，注意：不能除非空文件夹
    //删除非空需要使用递归删除
</code></pre>
<h3 id="遍历文件夹">遍历文件夹</h3>
<pre><code class="language-java">//1、public String[] List():获取当前目录下所有的"一级文件名称"到一个字符串数组中去返回.
File f1 new File(pathname:"")
//2、public File[] listFiles():(重点)获取当前目录下所有的"级文件对象"到个文件对象数组中去返回（重点）
</code></pre>
<p>使用listFiles方法时的<strong>注意事项</strong>：</p>
<ul>
<li>当主调是文件，或者路径不存在时，返回null</li>
<li>当主调是空文件夹时，返回一个长度为0的数组</li>
<li>当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹的路径放在File数组中返回</li>
<li>当主调是一个文件夹，且里面有隐藏文件时，将里面所有文件和文件夹的路径放在Flie数组中返回，包含隐藏文件</li>
<li>当主调是一个文件夹，但是没有权限访问该文件夹时，返回null</li>
</ul>
<h2 id="方法递归">方法递归</h2>
<h3 id="认识递归">认识递归</h3>
<p>自己调自己</p>
<h3 id="应用执行流程算法思想">应用，执行流程、算法思想</h3>
<p>斐波那契数列、二叉树等</p>
<h3 id="文件搜索">文件搜索</h3>
<p>递归很经典建议多看多学</p>
<pre><code class="language-java">public static void searchFile（File dir,String fileName){
	//1、把非法的情况都拦截住
	if（dir == null ll !dir.exists() || dir.isFile()){
		return;//代表无法搜索
	//2、dir不是nuLl，存在，一定是目录对象。
	//获取当前目录下的全部一级文件对象。
	File[] files=dir.listFiles();
	//3、判断当前目录下是否存在一级文件对象，以及是否可以拿到一级文件对象。
	if(files != null &amp;&amp; files.length &gt; θ）{
	//4、遍历全部一级文件对象。
	for (File f : files){
	//5、判断文件是否是文件，还是文件夹
		if(f.isFile()){
		//是文件，判断这个文件名是否是我们要找的
			if（f.getName().contains（fileName)){
				System.out.println（"找到了："+f.getAbsolutePath());
            }
        }else {
            //是文件夹，重复
            searchFile(f,fileName);
		}
    }
</code></pre>
<h2 id="字符集">字符集</h2>
<h3 id="常见字符集">常见字符集</h3>
<p>处理信息需要将字符存在计算机中，计算机只能存01，所以为字符编码所以产生了字符集：</p>
<ul>
<li>ASCII字符集---1个字节存储，首位一定是零，因为7位够用但不够8位，所以加零</li>
<li>GBK，国标，一个中文两个字节存储，兼容ASCIII，汉字第一位必须为1，解码时遇见1则解码两个字节中文，解码遇见零则为英文和数字等</li>
<li>Unicode字符集，万国码，容纳世界上所有的文字和符合的字符集，4个字节表示，直接4个4个解码
<ul>
<li>缺点占存储空间，通信效率变低</li>
</ul>
</li>
</ul>
<hr>
<p>UTF-8，为了解决缺点而诞生的Unicode字符集，可变长方案</p>
<ul>
<li>英文字符、数字等只占1个字节（兼容标准ASCII编码），汉字字符占用3个字节</li>
<li><img alt="image-20250326193141074" loading="lazy"></li>
</ul>
<h3 id="编码解码">编码解码</h3>
<ul>
<li>byte[] getBytes()------使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中</li>
<li>byte[] getBytes(String charsetName)-----使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中</li>
<li>String(byte[] bytes)-----通过使用平台的默认字符集解码指定的字节数组来构造新的String</li>
<li>String(byte[] bytes,String charsetName)-----通过指定的字符集解码指定的字节数组来构造新的String</li>
</ul>
<h2 id="io流分类">Io流分类</h2>
<ol>
<li>I指lnput，称为输入流：负责把数据读到内存中去</li>
<li>O指Output,称为输出流：负责写数据出去</li>
</ol>
<p><img alt="image-20250326193631719" loading="lazy"></p>
<p>总结流的四大类：</p>
<ul>
<li>字节输入流（InputStream）：以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流</li>
<li>字节输出流（OutStream）：以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流。</li>
<li>字符输入流（Reader）：以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流。</li>
<li>字符输出流（Writer）：以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流。</li>
</ul>
<h2 id="io字节流">io字节流</h2>
<h3 id="fileinputstream">FileInputStream</h3>
<pre><code class="language-java">public FileInputStream(File file)  //创建字节输入流管道与源文件接通
public FileInputStream(String pathname) //创建字节输入流管道与源文件接通

</code></pre>
<pre><code class="language-java">public int read()
//每次读取一个字节返回，如果发现没有数据可读会返回-1.
//每次用一个字节数组去读取数据，返回字节数组读取了多少个字节，
</code></pre>
<p>使用Read每次只能读一个，同时汉字是多个字节的会出现论码</p>
<pre><code class="language-java">public int read(byte[] buffer)
//如果发现没有数据可读会返回-1.
 //2、开始读取文件中的字节数据：每次读取多个字节.
byte[] buffer new byte[3];
int len = is.read(buffer);
String rs new String(buffer);
System.out.println(rs);
System.out.println("当次读取的字节数量："+len):
//buffer [abci
//buffer [66c]
//buffer会覆盖记得控制
int len2 = is.read(buffer);
String rs2 = new String(buffer);
System.out.println(rs2);
System.out.println("当次读取的字节数量："+ Len2):
</code></pre>
<p>可以直接循环读，但也可能破坏汉字的编码</p>
<h3 id="文件字节输入流一次读取完全部字节">文件字节输入流：一次读取完全部字节</h3>
<ol>
<li>
<p>定义buffer足够大一次性读取</p>
<ul>
<li>很显然不太合理</li>
</ul>
</li>
<li>
<p>readAllBytes</p>
<pre><code class="language-java">byte[]buffer=is.readAllBytes();
System.out.println(new String（buffer));
//文件过大也会出现问题
</code></pre>
</li>
<li>
<p>读写文本使用字符流，上面两种字节流不合适</p>
</li>
</ol>
<h3 id="fileoutstream">FileOutStream</h3>
<p>文件字节输出流：写字节出去</p>
<pre><code class="language-java">public FileOutputStream(File file)//创建字节输出流管道与源文件对象接通
public FileOutputStream(String filepath)//创建字节输出流管道与源文件路径接通
public FileOutputStream(File file,boolean append)
//创建字节输出流管道与源文件对象接通，可追加数据
public File0utputStream(String filepath,boolean append)
//创建字节输出流管道与源文件路径接通，可追加数据

public void write(int a)
//写一个字节出去
public void write(byte[] buffer）
//写一个字节数组出去
public void write（byte[] buffer，int pos，int len)
//写一个字节数组的一部分出去。
public void close() throws I0Exception
//关闭流。
</code></pre>
<h2 id="io流-资源释放方式">io流-资源释放方式</h2>
<p>为保证关闭，需要异常处理</p>
<h3 id="try-catch-finally">try-catch-finally</h3>
<ul>
<li>finally代码区的特点：无论try中的程序是正常执行了，还是出现了异常，最后都一定会执行finally区，除非VM终止。</li>
<li>作用：一般用于在程序执行完成后进行资源的释放操作（专业级做法）。</li>
</ul>
<h3 id="try-with-resource">try-with-resource</h3>
<p>jdk7新增的</p>
<pre><code class="language-java">try(定义资源1;定义资源2;...){
		可能出现异常的代码；
}catch(异常类名变量名){
		异常的处理代码；
}
</code></pre>
<h2 id="io字符流">io字符流</h2>
<ul>
<li>字节流：适合复制文件等，不适合读写文本文件</li>
<li>字符流：适合读写文本文件内容</li>
</ul>
<h3 id="filereader">FileReader</h3>
<pre><code class="language-java">public FileReader(File file)
//创建字符输入流管道与源文件接通
public FileReader(String pathname)
//创建字符输入流管道与源文件接通

public int read()
//每次读取一个字符返回，如果发现没有数据可读会返回-1·
//每次用一个字符数组去读取数据，返回字符数组读取了多少个字符，
public int read(char[]buffer)
//如果发现没有数据可读会返回-1.
</code></pre>
<h3 id="filewrite">FileWrite</h3>
<pre><code class="language-java">public FileWriter(File file)
//创建字节输出流管道与源文件对象接通
public FileWriter(String filepath)
//创建字节输出流管道与源文件路径接通
public FileWriter(File file,boolean append)
//创建字节输出流管道与源文件对象接通，可追加数据
public FileWriter(String filepath,boolean append)
//创建字节输出流管道与源文件路径接通，可追加数据

void write(int )
//写一个字符
void write(String str)
//写一个字符串
void write(String str,int off,int len)
//写一个字符串的一部分
void write(char[] cbuf)
//写入一个字符数组
void write(char] cbuf, int off,int len)
//写入字符数组的一部分
</code></pre>
<ul>
<li>注意事项</li>
</ul>
<p>​		字符输出流写出数据后，必须刷新流，或者关闭流，写出去的数据才能生效</p>
<pre><code class="language-java">fw.flush();//刷新流
fw.close();//关闭刷新，但关闭就不能使用了
</code></pre>
<h2 id="io缓冲流">io缓冲流</h2>
<pre><code class="language-java">BufferedInputStream //字节缓冲输入流
BufferedOutputStream //字节缓冲输出流
BufferedReader //字符缓冲输入流
BufferedWriter //字符缓冲输出流
</code></pre>
<p>缓冲流提升读写性能，缓冲区就是为提升性能而诞生的</p>
<p><img alt="image-20250326200830340" loading="lazy"></p>
<pre><code class="language-java">Inputstream is = new FileInputStream(name:"io-app2/src/itheima01.txt");
//1、定义一个字节缓冲输入流包装原始的字节输入流
InputStream bis = new BufferedInputstream(is, 8192*2);//size
//封装可以直接new BufferedInputstream(new FileInputStream(name:"io-app2/src/itheima01.txt"),8192*2)

Outputstream os = new Fileoutputstream(name:"io-app2/src/itheima01_bak.txt");
//2、定义一个字节缓冲输出流包装原始的字节输出流
Outputstream bos = new BufferedOutputstream(os);
</code></pre>
<pre><code class="language-java">public BufferedReader(Reader r)
//把低级的字符输入流包装成字符缓冲输入流管道，从而提高字符输入流读字符数据的性能
//字符缓冲输入流新增的功能：按照行读取字符

public String readLine()
//读取一行数据返回，如果没有数据可读了，会返回u11
    
public BufferedWriter(Writer r)
    
public void newLine() //换行
</code></pre>
<h2 id="io转换流">io转换流</h2>
<ul>
<li>如果代码编码和被读取的文本文件的编码是一致的，使用字符流读取文本文件时不会出现乱码！</li>
<li>如果代码编码和被读取的文本文件的编码是不一致的，使用字符流读取文本文件时就会出现乱码！</li>
</ul>
<p>字符输入转换流----InputStreamReader</p>
<p>​		先获取文件的原始字节流，再将其按真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了。</p>
<pre><code class="language-java">public InputStreamReader（InputStream is，String charset)
//把原始的字节输入流，按照指定字符集编码转成字符输入流（重点）
</code></pre>
<p>字符输出转换流</p>
<pre><code class="language-java">public OutputStreamWriter(OutputStream os,String charst)
//可以把原始的字节输出流，按照指定编码转换成字符输出流（重点）
</code></pre>
<h2 id="io打印流">io打印流</h2>
<p>PrintStream/PrintWriter(打印流)<br>
作用：打印流可以实现更方便、更高效的打印数据出去，能实现打印啥出去就是啥出去。</p>
<pre><code class="language-java">public PrintStream(OutputStream/File/String)
//打印流直接通向字节输出流/文件/文件路径
public PrintStren(String fileName, Charset charset)
//可以指定写出去的字符编码
public PrintStream(OutputStream out, boolean autoFlush)
//可以指定实现自动刷新
public PrintStream（OutputStreamout, booleanautoFlush, Stringencoding）
//可以指定实现自动刷新，并可指定字符的编码
    
public PrintWriter(OutputStream/Writer/File/String)
//打印流直接通向字节输出流/文件/文件路径
public Printwriter(String fileName,Charset charset)
//可以指定写出去的字符编码
public Printwriter(OutputStream out/Writer,boolean autoFlush)
//可以指定实现自动刷新
public PrintWriter(Outputstream out,boolean autoFlush,String encoding)
//可以指定实现自动刷新，并可指定字符的编码
</code></pre>
<pre><code class="language-java">public void println(Xxx xx)
//打印任意类型的数据出去
public void write（int/byte[]/byte[]一部分）
//可以支持写字节数据出去
</code></pre>
<h2 id="io数据流">io数据流</h2>
<ul>
<li>DataInputStream</li>
</ul>
<pre><code class="language-java">public DataInputstream(Inputstream is)
创建新数据输入流包装基础的字节输入流

Public final byte readByte()throws IOException
读取字节数据返回
public final int readInt()throws IOException
读取int类型的数据返回
public final double readDouble()throws IOException
读取double类型的数据返回

public final String readUTF()throws IOException
读取字符串数(UTF-8)据返回
public int readInt()/read(byte[])
支持读字节数据进来
</code></pre>
<ul>
<li>DataOutputStream</li>
</ul>
<pre><code class="language-java">public DataOutputStream（outputStream out)
创建新数据输出流包装基础的字节输出流

public final void writeByte(int v) throws IoException
将byte类型的数据写入基础的字节输出流
public final void writeInt(int v) throws IoException
将int类型的数据写入基础的字节输出流
public final void writeDouble(Double v) throws I0Exception
将double类型的数据写入基础的字节输出流
public final void writeUTF(String str) throws IoException
将字符串数据以UTF-8编码成字节写入基础的字节输出流
public void write(int/byte[]/byte[]一部分）
支持写字节数据出去
</code></pre>
<h2 id="io序列化流">io序列化流</h2>
<p>序列化：---implements Serializable</p>
<p>注意：对象如果要参与序列化，必须实现序列化接口(java.io.Serializable)</p>
<p>对象序列化：把java对象写入到文件中去</p>
<p>对象反序列化：把文件里的java对象读出来</p>
<ul>
<li>ObjectInputStream</li>
</ul>
<pre><code class="language-java">public objectInputstream(Inputstream is)
创建对象字节输入流，包装基础的字节输入流

public final object readobject()
把存储在文件中的Java对象读出来
</code></pre>
<p>当参数不希望序列化时：</p>
<pre><code class="language-java">//transient这个成员变量将不参与序列化：
private transient String passWord;
</code></pre>
<ul>
<li>ObjectOutputStream</li>
</ul>
<pre><code class="language-java">public objectoutputstream(Outputstream out)
创建对象字节输出流，包装基础的字节输出流

public final void writeobject(object o)throws IOException
把对象写出去
</code></pre>
<ul>
<li>
<p>如果要一次序列化多个对象，咋整？</p>
<p>用一个ArrayList集合存储多个对象，然后直接对集合进行序列化即可</p>
<p>注意：ArrayList集合已经实现了序列化接口！</p>
</li>
</ul>
<h2 id="补充知识io框架">补充知识：io框架</h2>
<h3 id="什么是框架">什么是框架</h3>
<ul>
<li>解决某类问题，编写的一套类、接口等，可以理解成一个半成品，大多框架都是第三方研发的。</li>
<li>好处：在框架的基础上开发，可以得到优秀的软件架构，并能提高开发效率</li>
<li>框架的形式：一般是把类、接口等编译成classi形式，再压缩成一个jar结尾的文件发行出去。</li>
</ul>
<h3 id="什么是io框架">什么是IO框架？</h3>
<p>封装了Java提供的对文件、数据进行操作的代码，对外提供了更简单的方式来对文件进行操作，对数据进行读写等。</p>
<h3 id="commons-io">Commons-io</h3>
<pre><code class="language-java">FileUtils类提供的部分方法展示:
public static void copyFile(File srcFile, File destFile)
复制文件。
public static void copyDirectory(File srcDir,File destDir)
复制文件夹
public static void deleteDirectory(File directory)
删除文件夹
public static String readFileToString(File file,String encoding)
读数据
public static void writeStringToFile（File file，String data,String charname,boolean append)
写数据
</code></pre>
<pre><code class="language-java">lOUtils类提供的部分方法展示
public static int copy(Inputstreaminputstream,Outputstreamoutputstream)
复制文件。
public static int copy(Reader reader,Writer writer)
复制文件。
public static void write(String data,Outputstream output,String charsetName)
写数据
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.05599214744212963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-26 23:02">2025-03-26 23:02</span>&nbsp;
<a href="https://www.cnblogs.com/ttdb-huu">TTDB</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18794990" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18794990);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18794990', targetLink: 'https://www.cnblogs.com/ttdb-huu/p/18794990', title: 'io流' })">举报</a>
</div>
        