<!----> <meta itemprop="headline" content="前端请求API知识梳理"> <meta itemprop="keywords" content="前端,JavaScript,Ajax"> <meta itemprop="datePublished" content="2024-10-21T01:51:38.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="黑色的枫"> <meta itemprop="url" content="https://juejin.cn/user/2365804756348103"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7cdd11fb="">
            前端请求API知识梳理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7cdd11fb=""><div class="author-info-box" data-v-7cdd11fb=""><div class="author-name" data-v-7cdd11fb=""><a href="/user/2365804756348103/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-7cdd11fb=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    黑色的枫
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-7cdd11fb=""><time datetime="2024-10-21T01:51:38.000Z" title="Mon Oct 21 2024 01:51:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7cdd11fb="">
                    2024-10-21
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7cdd11fb=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7cdd11fb=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7cdd11fb=""></circle></svg> <span class="views-count" data-v-7cdd11fb="">
                    12,507
                  </span> <span class="read-time" data-v-7cdd11fb=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7cdd11fb=""><rect width="16" height="16" fill="none" data-v-7cdd11fb=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7cdd11fb=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7cdd11fb=""></path></svg>
                    阅读30分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7cdd11fb=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7cdd11fb=""><div class="article-viewer markdown-body result"><p>浏览器中用于发起网络请求的 API 主要包括以下几种：</p>
<ol>
<li>
<p><strong>XMLHttpRequest</strong>：这是一个老牌的 API，用于在浏览器和服务器之间发送 HTTP 请求。它支持异步请求，并可以通过设置回调函数来处理响应。尽管它已经被更现代的 API 取代，但在一些旧的浏览器或特定的场景中仍然有用。</p>
<p><em>对于前端开发的我们来说，这个API再熟悉不过了，XHR 是最早接触到的网络请求 API，可以说是“老朋友”了。在很多老项目中，我们和后端沟通基本都用它。在我们平常所接触到的项目中，很多都是使用的Axios，在浏览器中，Axios底层也是使用了XMLHttpRequest对象来发送HTTP请求。</em></p>
</li>
<li>
<p><strong>Fetch</strong>：Fetch 是一个现代、功能强大的网络 API，它使用 Promise 使异步操作更加容易。Fetch 提供了更简洁的语法和更好的错误处理机制，并支持发送和接收各种类型的数据（如 JSON、文本、Blob 等）。</p>
<p><em>Fetch 可以说是网络请求的“新宠”，不仅语法简洁优雅，性能也非常出色。很多开发者都选择 Fetch 作为 XMLHTTPRequest 的替代方案，特别是在处理复杂的异步操作时，Fetch 显得更加得心应手。值得一提的是，Fetch的性能是要强于XMLHttpRequest,axios的默认请求方式已经改为了Fetch。</em></p>
</li>
<li>
<p><strong>Beacon API</strong>：<code>navigator.sendBeacon()</code>&nbsp;方法允许异步地发送少量数据到服务器，通常用于在页面卸载时发送分析或诊断信息。这个方法确保数据发送成功，即使页面已经关闭或用户已经导航到其他页面。</p>
<p><em>Beacon API 可以说是“默默无闻”的小帮手，特别适合在页面关闭或跳转时发送一些统计数据。不过，我自己学过但还没用过，希望以后有机会实践一下。</em></p>
</li>
<li>
<p><strong>WebSocket API</strong>：WebSocket 提供了一个全双工的通信通道，允许浏览器和服务器之间进行长时间的实时数据交换。这不同于传统的 HTTP 请求，HTTP 请求通常是客户端发起并等待服务器响应的模式。</p>
<p><em>实时通信，像我们一些告警需求，不是用的轮询就是用的WebSockets。</em></p>
</li>
<li>
<p><strong>Server-Sent Events (SSE)</strong> ：服务器发送事件允许服务器向客户端推送实时事件。与 WebSockets 不同，SSE 是单向的，只允许服务器向客户端发送数据。SSE 基于 HTTP，因此它们比 WebSockets 更简单，并且能够在现有的 HTTP 基础设施上工作。</p>
<p><em>SSE 是一个简单实用的好方案，对于需要服务器单向推送数据的场景非常合适，比如实时更新股票价格。比起轮询和 WebSocket，SSE 的实现更简单，而且性能也不错。</em></p>
</li>
<li>
<p><strong>XMLHttpRequest Level 2</strong>（包括 FormData 和 Blob 对象）：虽然这仍然是 XMLHttpRequest 的一部分，但值得注意的是，XMLHttpRequest Level 2 引入了一些改进和新功能，如 FormData 和 Blob 对象，它们使得发送表单数据和二进制数据更加容易。</p>
<p><em>XMLHttpRequest Level 2 是老朋友的“进阶版”，增加了很多实用功能。虽然它已经不再是最热门的选择，但在处理文件上传和复杂数据提交时，仍然是一个不错的工具。</em></p>
</li>
<li>
<p><strong>WebRTC (Web Real-Time Communication)</strong> ：虽然 WebRTC 主要用于实时音频、视频和数据通信，但它也可以用于在浏览器之间建立点对点（peer-to-peer）的连接，并通过这些连接发送数据。这不是一个典型的“请求-响应”模型，而是一种更复杂的通信协议。</p>
<p><em>WebRTC，大多数都用于音视频，有去了解过这方面的知识，给我的感觉就是，和前端开发不像是一个赛道，但是还是挺好玩的，</em></p>
</li>
</ol>
<h2 data-id="heading-0">1. XMLHttpRequest</h2>
<p>XMLHttpRequest (XHR) 是 JavaScript 中用于与服务器进行异步通信的 API。它允许我们在不刷新页面的情况下从服务器获取数据或向服务器发送数据。</p>
<p>XHR 对象可用于执行以下操作：</p>
<ul>
<li>从服务器获取数据</li>
<li>向服务器发送数据</li>
<li>上传文件</li>
<li>监控请求进度</li>
<li>处理服务器响应</li>
</ul>
<blockquote>
<p>这些也是与服务器进行异步通信的 API的基础功能。</p>
</blockquote>
<h3 data-id="heading-1">1.1 XHR 的优点</h3>
<p>XHR 具有以下优点：</p>
<ul>
<li>
<p>异步：XHR 请求不会阻塞页面渲染</p>
</li>
<li>
<p>灵活：XHR 可用于执行各种操作</p>
</li>
<li>
<p>强大：XHR 可用于上传文件和监控请求进度</p>
</li>
</ul>
<h3 data-id="heading-2">1.2 XHR 的缺点</h3>
<p>XHR 具有以下缺点：</p>
<ul>
<li>复杂：XHR 的 API 比较复杂</li>
<li>不支持跨域请求：XHR 默认不支持跨域请求</li>
</ul>
<blockquote>
<p>默认不支持跨域请求的原因是浏览器为了安全，实施了同源策略（Same-origin policy）。</p>
</blockquote>
<p>**<br>
**</p>
<p><strong>XHR 还支持以下高级用法：</strong></p>
<ul>
<li>
<p>跨域请求：使用 CORS 允许跨域请求</p>
</li>
<li>
<p>上传文件：使用 FormData 对象上传文件</p>
</li>
<li>
<p>监控请求进度：使用 xhr.upload 对象监控请求进度</p>
</li>
</ul>
<h3 data-id="heading-3">1.3 创建 XMLHttpRequest 对象</h3>
<p>这是使用&nbsp;<code>XMLHttpRequest</code>&nbsp;的第一步。通过&nbsp;<code>new XMLHttpRequest()</code>&nbsp;可以创建一个新的&nbsp;<code>XMLHttpRequest</code>&nbsp;对象。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">xhr</span> = new XMLHttpRequest()<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-4">1.4 初始化请求</h3>
<p>使用&nbsp;<code>open</code>&nbsp;方法来初始化请求。它有三个主要参数：请求方法（GET, POST 等）、请求URL，以及是否异步（布尔值）。</p>
<pre><code class="hljs language-kotlin" lang="kotlin">xhr.<span class="hljs-keyword">open</span>(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'https://www.feng.com/data'</span>, <span class="hljs-literal">true</span>);
</code></pre>
<p><strong>参数说明</strong></p>
<ol>
<li>
<p><strong>method</strong>:</p>
<ul>
<li>
<p>指定HTTP请求方法。</p>
</li>
<li>
<p>常用方法包括:</p>
<ul>
<li>"GET"：从服务器获取数据。</li>
<li>"POST"：向服务器发送数据。</li>
<li>"PUT"：更新服务器上的数据。</li>
<li>"DELETE"：删除服务器上的数据。</li>
<li>"HEAD"：与GET类似，但只请求响应头。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>url</strong>:</p>
<ul>
<li>指定请求的目标URL。</li>
<li>可以是相对路径（如&nbsp;<code>/data</code>）或者绝对路径（如&nbsp;<code>https://api.example.com/data</code>）。</li>
</ul>
</li>
<li>
<p><strong>async</strong>:</p>
<ul>
<li>一个布尔值，指定请求是否异步执行。</li>
<li>默认为&nbsp;<code>true</code>。</li>
<li>如果设置为&nbsp;<code>false</code>，请求会同步执行，浏览器会在请求完成之前被阻塞（不推荐使用，因为会影响用户体验）。</li>
</ul>
</li>
<li>
<p><strong>user</strong>:</p>
<ul>
<li>一个可选参数，用于指定HTTP身份验证的用户名。</li>
</ul>
</li>
<li>
<p><strong>password</strong>:</p>
</li>
<li>
<ul>
<li>一个可选参数，用于指定HTTP身份验证的密码。</li>
</ul>
</li>
</ol>
<p><strong>HTTP 请求方法</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a28f01ea0a5d43758e58d83284e571e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6buR6Imy55qE5p6r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1736324852&amp;x-signature=r9U2fgAHdFaVqJynV7ICoeRs7ss%3D" alt="" loading="lazy"></p>
<h3 data-id="heading-5">1.5 设置请求头</h3>
<p>使用&nbsp;<code>setRequestHeader</code>&nbsp;方法来设置请求头，这在发送POST请求或需要特定的请求头时特别有用。</p>
<pre><code class="hljs language-arduino" lang="arduino">xhr.<span class="hljs-built_in">setRequestHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'application/json'</span>);
</code></pre>
<ul>
<li>常用的请求头包括&nbsp;<code>Content-Type</code>（指定请求体的媒体类型）、<code>Authorization</code>（授权信息）等。</li>
</ul>
<p><strong>常见HTTP请求头</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4fb14e510cb54d44a5d23138fe54d5f4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6buR6Imy55qE5p6r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1736324852&amp;x-signature=xM8Oa6b6OcnZzECFVYZJhZLZAx4%3D" alt="" loading="lazy"></p>
<h3 data-id="heading-6">1.6 发送请求</h3>
<p>使用&nbsp;<code>send</code>&nbsp;方法来发送请求。对于GET请求，可以不传递参数；对于POST请求，可以传递请求体数据。</p>
<pre><code class="hljs language-ini" lang="ini">xhr.send()<span class="hljs-comment">;</span>
</code></pre>
<p>对于POST请求，传递请求体数据：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">data</span> = JSON.stringify({ name: <span class="hljs-string">'Feng'</span>, age: <span class="hljs-number">26</span> })<span class="hljs-comment">;</span>
xhr.send(data)<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-7">1.7 处理响应</h3>
<p>使用&nbsp;<code>onreadystatechange</code>&nbsp;事件处理响应。每当&nbsp;<code>readyState</code>&nbsp;属性改变时，<code>onreadystatechange</code>&nbsp;事件会被触发。可以通过检查&nbsp;<code>readyState</code>&nbsp;和&nbsp;<code>status</code>&nbsp;来确定请求的状态和结果。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">xhr.onreadystatechange</span> = function() {
    if (<span class="hljs-attr">xhr.readyState</span> === <span class="hljs-number">4</span>) { // 请求完成
        if (<span class="hljs-attr">xhr.status</span> === <span class="hljs-number">200</span>) { // 成功
            console.log(xhr.responseText)<span class="hljs-comment">;</span>
        } else {
            console.error('Error:', xhr.statusText)<span class="hljs-comment">;</span>
        }
    }
}<span class="hljs-comment">;</span>
</code></pre>
<p><strong>readyState 属性：</strong></p>
<p><code>readyState</code>&nbsp;属性表示请求的状态。它有五个可能的值：</p>
<ul>
<li><code>0</code>&nbsp;(UNSENT): 代理已被创建，但尚未调用&nbsp;<code>open</code>&nbsp;方法。</li>
<li><code>1</code>&nbsp;(OPENED):&nbsp;<code>open</code>&nbsp;方法已经被调用。</li>
<li><code>2</code>&nbsp;(HEADERS_RECEIVED):&nbsp;<code>send</code>&nbsp;方法已经被调用，并且头部和状态已经可获得。</li>
<li><code>3</code>&nbsp;(LOADING): 下载中；<code>responseText</code>&nbsp;属性已经包含部分数据。</li>
<li><code>4</code>&nbsp;(DONE): 下载操作已完成。</li>
</ul>
<p><strong>status 属性：</strong></p>
<p><code>status</code>&nbsp;属性表示HTTP状态码。例如：</p>
<ul>
<li><code>200</code>&nbsp;(OK): 请求成功。</li>
<li><code>404</code>&nbsp;(Not Found): 请求的资源未找到。</li>
<li><code>500</code>&nbsp;(Internal Server Error): 服务器错误。</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1e82f48e45144b67bd2b2cdc0815e64f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6buR6Imy55qE5p6r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1736324852&amp;x-signature=a6oUn2wFu3U8wRV%2BtyOUHJaiKR0%3D" alt="" loading="lazy"></p>
<h3 data-id="heading-8">1.8 responseText 和 responseXML 属性</h3>
<ul>
<li>
<p><code>responseText</code>: 返回字符串形式的响应数据，适用于大多数情况。</p>
</li>
<li>
<p><code>responseXML</code>: 返回解析后的XML文档对象，适用于返回XML数据的情况。</p>
</li>
</ul>
<h3 data-id="heading-9">1.9 异步与同步请求</h3>
<ul>
<li><strong>异步请求</strong>:&nbsp;<code>open</code>&nbsp;方法的&nbsp;<code>async</code>&nbsp;参数为&nbsp;<code>true</code>。这是推荐的方式，因为它不会阻塞浏览器的UI线程。</li>
<li><strong>同步请求</strong>:&nbsp;<code>open</code>&nbsp;方法的&nbsp;<code>async</code>&nbsp;参数为&nbsp;<code>false</code>。这种方式会阻塞浏览器的UI线程，直到请求完成，不推荐使用。</li>
</ul>
<blockquote>
<p>同步请求很少用到，但是也不是没有使用场景。</p>
</blockquote>
<h3 data-id="heading-10">1.10 处理错误</h3>
<p>可以在&nbsp;<code>onreadystatechange</code>&nbsp;事件处理程序中检查状态码，并处理可能的错误。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">xhr.onreadystatechange</span> = function() {
    if (<span class="hljs-attr">xhr.readyState</span> === <span class="hljs-number">4</span>) {
        if (<span class="hljs-attr">xhr.status</span> === <span class="hljs-number">200</span>) {
            console.log(xhr.responseText)<span class="hljs-comment">;</span>
        } else {
            console.error('Error:', xhr.status, xhr.statusText)<span class="hljs-comment">;</span>
        }
    }
}<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-11">1.11 其他常用方法和属性</h3>
<ul>
<li>
<p><code>abort()</code>: 取消当前请求。</p>
</li>
<li>
<p><code>getAllResponseHeaders()</code>: 获取所有响应头。</p>
</li>
<li>
<p><code>getResponseHeader(header)</code>: 获取指定的响应头。</p>
</li>
</ul>
<h3 data-id="heading-12">1.12 跨域请求</h3>
<p>由于同源策略的限制，跨域请求需要服务器设置CORS（Cross-Origin Resource Sharing）头。示例如下：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">xhr.<span class="hljs-keyword">open</span>(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'https://www.feng.com/data'</span>, <span class="hljs-literal">true</span>);
xhr.setRequestHeader(<span class="hljs-string">'Origin'</span>, <span class="hljs-string">'https://yourdomain.com'</span>);
xhr.send();
</code></pre>
<p>服务器需要返回允许跨域的头部：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">Access-Control-Allow-Origin: https://yourdomain.com</span>
<span class="hljs-section">Access-Control-Allow-Methods: GET, POST</span>
<span class="hljs-section">Access-Control-Allow-Headers: Content-Type</span>
</code></pre>
<h3 data-id="heading-13">1.13 示例代码</h3>
<h4 data-id="heading-14">GET 请求示例</h4>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">xhr</span> = new XMLHttpRequest()<span class="hljs-comment">;</span>
xhr.open('GET', 'https://www.feng.com/data', true)<span class="hljs-comment">;</span>

<span class="hljs-attr">xhr.onreadystatechange</span> = function() {
    if (<span class="hljs-attr">xhr.readyState</span> === <span class="hljs-number">4</span>) {
        if (<span class="hljs-attr">xhr.status</span> === <span class="hljs-number">200</span>) {
            console.log(JSON.parse(xhr.responseText))<span class="hljs-comment">;</span>
        } else {
            console.error('Error:', xhr.statusText)<span class="hljs-comment">;</span>
        }
    }
}<span class="hljs-comment">;</span>

xhr.send()<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-15">POST 请求示例</h4>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">xhr</span> = new XMLHttpRequest()<span class="hljs-comment">;</span>
xhr.open('POST', 'https://www.feng.com/data', true)<span class="hljs-comment">;</span>
xhr.setRequestHeader('Content-Type', 'application/json')<span class="hljs-comment">;</span>

<span class="hljs-attr">xhr.onreadystatechange</span> = function() {
    if (<span class="hljs-attr">xhr.readyState</span> === <span class="hljs-number">4</span>) {
        if (<span class="hljs-attr">xhr.status</span> === <span class="hljs-number">200</span>) {
            console.log(JSON.parse(xhr.responseText))<span class="hljs-comment">;</span>
        } else {
            console.error('Error:', xhr.statusText)<span class="hljs-comment">;</span>
        }
    }
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">data</span> = JSON.stringify({ name: <span class="hljs-string">'Feng'</span>, age: <span class="hljs-number">26</span> })<span class="hljs-comment">;</span>
xhr.send(data)<span class="hljs-comment">;</span>
</code></pre>
<h2 data-id="heading-16">2. Fetch API</h2>
<p>Fetch API 是一种现代化的 JavaScript 接口，用于执行网络请求。它提供了一个更强大和灵活的方式来发出网络请求和处理响应，取代了旧有的 XMLHttpRequest（XHR）API。Fetch API 采用基于 Promise 的设计，使异步请求处理更加简洁和直观。</p>
<blockquote>
<p>很推荐大家有机会可以在项目里使用Fetch。</p>
</blockquote>
<h3 data-id="heading-17">2.1 Fetch API 的优点</h3>
<ol>
<li>
<p>简洁的语法：Fetch API 使用 Promise，大大简化了异步请求的代码。</p>
</li>
<li>
<p>支持更多功能：Fetch API 支持跨域请求、流媒体、请求和响应对象的完全控制等高级功能。</p>
</li>
<li>
<p>一致的接口：Fetch API 提供了一致且统一的请求和响应处理接口。</p>
</li>
<li>
<p>更好的错误处理：Promise 使得错误处理更加清晰和易于管理。</p>
</li>
</ol>
<h3 data-id="heading-18">2.2 Fetch API 的缺点</h3>
<ol>
<li>不支持同步请求：Fetch API 只能用于异步请求，不支持同步请求。</li>
<li>CORS 限制：Fetch API 遵循同源策略，跨域请求需要服务器配置 CORS（Cross-Origin Resource Sharing）。</li>
<li>复杂的流媒体处理：对于流媒体处理，Fetch API 相比 XHR 需要更多的代码处理。</li>
</ol>
<blockquote>
<p>有的小伙伴可能会想，是不是可以用async和await代替，但是呢，async和await并不会让fetch请求变成同步，只是会让请求看起来像是同步的，这里的异步是指会在异步环境中运行，并不会堵塞其他代码。</p>
</blockquote>
<blockquote>
<p>具体可以参考我的另一篇文章：<a href="https://juejin.cn/post/7039213171680215070" target="_blank" title="https://juejin.cn/post/7039213171680215070">juejin.cn/post/703921…</a></p>
</blockquote>
<h3 data-id="heading-19">2.3 Fetch API 的用法</h3>
<p>Fetch API 的基本用法涉及创建一个网络请求并处理响应。它返回一个 Promise，该 Promise 会在请求完成后解析为一个 Response 对象。</p>
<h4 data-id="heading-20">基本用法</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://www.Feng.com/data'</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Network response was not ok'</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'There was a problem with the fetch operation:'</span>, error);
  });
</code></pre>
<h4 data-id="heading-21">创建请求</h4>
<p>Fetch API 的 fetch 方法可以接受两个参数：请求的 URL 和可选的配置对象。配置对象允许指定请求方法、请求头、请求体等。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://www.Feng.com/data'</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
  },
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Feng'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> })
})
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))
.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error:'</span>, error));
</code></pre>
<h4 data-id="heading-22">请求方法</h4>
<p>Fetch API 支持各种 HTTP 请求方法，包括 GET、POST、PUT、DELETE 等。以下是一些常见的请求方法及其示例。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// GET 请求</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://www.Feng.com/data'</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error:'</span>, error));

<span class="hljs-comment">// POST 请求</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://www.Feng.com/data'</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
  },
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Feng'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> })
})
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))
.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error:'</span>, error));

<span class="hljs-comment">// PUT 请求</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://www.Feng.com/data/1'</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'PUT'</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
  },
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Feng'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> })
})
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))
.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error:'</span>, error));

<span class="hljs-comment">// DELETE 请求</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://www.Feng.com/data/1'</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'DELETE'</span>
})
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))
.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error:'</span>, error));
</code></pre>
<h4 data-id="heading-23">设置请求头</h4>
<p>可以通过配置对象的 headers 属性来设置请求头。常用的请求头包括 Content-Type、Authorization 等。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://www.Feng.com/data'</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
    <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">'Bearer token'</span>
  },
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Feng'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> })
})
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))
.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error:'</span>, error));
</code></pre>
<h4 data-id="heading-24">处理响应</h4>
<p>Fetch API 的 Response 对象提供了多种方法来处理响应数据。常用的方法包括 json()、text()、blob() 等。</p>
<pre><code class="hljs language-ini" lang="ini">// 处理 JSON 响应
fetch('https://www.Feng.com/data')
  .then(<span class="hljs-attr">response</span> =&gt; response.json())
  .then(<span class="hljs-attr">data</span> =&gt; console.log(data))
  .catch(<span class="hljs-attr">error</span> =&gt; console.error(<span class="hljs-string">'Error:'</span>, error))<span class="hljs-comment">;</span>

// 处理文本响应
fetch('https://www.Feng.com/data')
  .then(<span class="hljs-attr">response</span> =&gt; response.text())
  .then(<span class="hljs-attr">data</span> =&gt; console.log(data))
  .catch(<span class="hljs-attr">error</span> =&gt; console.error(<span class="hljs-string">'Error:'</span>, error))<span class="hljs-comment">;</span>

// 处理 Blob 响应
fetch('https://www.Feng.com/data')
  .then(<span class="hljs-attr">response</span> =&gt; response.blob())
  .then(<span class="hljs-attr">blob</span> =&gt; {
    const <span class="hljs-attr">url</span> = URL.createObjectURL(blob)<span class="hljs-comment">;</span>
    const <span class="hljs-attr">img</span> = document.createElement(<span class="hljs-string">'img'</span>)<span class="hljs-comment">;</span>
    <span class="hljs-attr">img.src</span> = url<span class="hljs-comment">;</span>
    document.body.appendChild(img)<span class="hljs-comment">;</span>
  })
  .catch(<span class="hljs-attr">error</span> =&gt; console.error(<span class="hljs-string">'Error:'</span>, error))<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-25">处理错误</h4>
<p>Fetch API 提供了一个清晰的方式来处理请求和响应中的错误。通过链式的 catch 方法，可以捕获和处理任何在请求过程中发生的错误。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://www.Feng.com/data'</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Network response was not ok'</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'There was a problem with the fetch operation:'</span>, error));
</code></pre>
<h4 data-id="heading-26">跨域请求</h4>
<p>Fetch API 遵循同源策略，但可以通过服务器配置 CORS 来允许跨域请求。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://www.Feng.com/data'</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'cors'</span>, <span class="hljs-comment">// 请求模式，默认是 'cors'</span>
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
  }
})
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))
.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error:'</span>, error));
</code></pre>
<h3 data-id="heading-27">2.4 示例代码</h3>
<p>以下是一个完整的示例代码，展示了如何使用 Fetch API 来执行各种网络请求，并处理响应数据。</p>
<p><strong>HTML：</strong></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Fetch API Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getButton"</span>&gt;</span>GET Data<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"postButton"</span>&gt;</span>POST Data<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"output"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"fetch.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>JavaScript：</strong></p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">const</span> getButton = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'getButton'</span>);
<span class="hljs-keyword">const</span> postButton = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'postButton'</span>);
<span class="hljs-keyword">const</span> output = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'output'</span>);

getButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://www.Feng.com/data'</span>)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Network response was not ok'</span>);
      }
      <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();
    })
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
      output.<span class="hljs-property">textContent</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);
    })
    .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'There was a problem with the fetch operation:'</span>, error);
    });
});

postButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://www.Feng.com/data'</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
    },
    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Feng'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> })
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Network response was not ok'</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    output.<span class="hljs-property">textContent</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);
  })
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'There was a problem with the fetch operation:'</span>, error);
  });
});
</code></pre>
<h3 data-id="heading-28">2.5 安全性</h3>
<p>Fetch API 提供了多种机制来确保请求和响应的安全性：</p>
<ol>
<li><strong>CORS</strong>：通过服务器配置 CORS 头，允许跨域请求，同时保护服务器免受未授权的访问。</li>
<li><strong>HTTPS</strong>：始终使用 HTTPS 协议来加密请求和响应数据，防止中间人攻击。</li>
<li><strong>请求验证</strong>：在请求头中包含授权信息，如 JWT（JSON Web Token）或 API 密钥，确保请求的合法性。</li>
</ol>
<h3 data-id="heading-29">2.6 使用场景</h3>
<p>Fetch API 广泛应用于以下场景：</p>
<ol>
<li><strong>数据获取和提交</strong>：如获取用户数据、提交表单等。</li>
<li><strong>文件上传和下载</strong>：如上传图片、下载文件等。</li>
<li><strong>流媒体处理</strong>：如处理视频流、音频流等。</li>
<li><strong>与第三方 API 交互</strong>：如与社交媒体 API、支付网关 API 等进行交互。</li>
</ol>
<h2 data-id="heading-30">3. Beacon API</h2>
<p>Beacon API 是一种专门用于从网页向服务器发送小量数据的 API，主要用于统计和诊断信息的传递。它在页面卸载（如页面关闭或导航到新页面）时特别有用，因为它能够确保数据在页面卸载前成功发送到服务器。</p>
<h3 data-id="heading-31">3.1 Beacon API 的优点</h3>
<ul>
<li>
<p>可靠性高：在页面卸载时，能够保证数据发送成功。</p>
</li>
<li>
<p>简洁易用：API 简单易用，只需调用一个方法即可发送数据。</p>
</li>
<li>
<p>非阻塞：不会阻塞页面的卸载操作，提升用户体验。</p>
</li>
<li>
<p>适用于传输小量数据：特别适合发送统计和诊断信息等小量数据。</p>
</li>
</ul>
<h3 data-id="heading-32">3.2 Beacon API 的缺点</h3>
<ul>
<li>
<p>只适用于小量数据：不适合传输大文件或大量数据。</p>
</li>
<li>
<p>不支持自定义请求头：无法自定义请求头，限制了某些高级用法。</p>
</li>
<li>
<p>有限的错误处理：无法直接获取发送失败的反馈。</p>
</li>
</ul>
<h3 data-id="heading-33">3.3 Beacon API 的用法</h3>
<h4 data-id="heading-34">1. 基本用法</h4>
<p>使用&nbsp;<code>navigator.sendBeacon</code>&nbsp;方法发送数据。它接受两个参数：目标 URL 和要发送的数据。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">url</span> = <span class="hljs-string">'https://www.example.com/log'</span><span class="hljs-comment">;</span>
const <span class="hljs-attr">data</span> = JSON.stringify({ event: <span class="hljs-string">'pageUnload'</span>, timestamp: Date.now() })<span class="hljs-comment">;</span>
navigator.sendBeacon(url, data)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-35">2. 发送数据类型</h4>
<p><code>sendBeacon</code>&nbsp;方法支持发送多种类型的数据，包括字符串、Blob、ArrayBuffer 等。</p>
<ul>
<li>发送字符串数据：</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">data</span> = <span class="hljs-string">'event=pageUnload&amp;timestamp='</span> + Date.now()<span class="hljs-comment">;</span>
navigator.sendBeacon(url, data)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>发送 Blob 数据：</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">blob</span> = new Blob([<span class="hljs-string">'event=pageUnload&amp;timestamp='</span> + Date.now()], { type: <span class="hljs-string">'application/x-www-form-urlencoded'</span> })<span class="hljs-comment">;</span>
navigator.sendBeacon(url, blob)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>发送 ArrayBuffer 数据：</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">buffer</span> = new ArrayBuffer(<span class="hljs-number">16</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">view</span> = new DataView(buffer)<span class="hljs-comment">;</span>
view.setUint32(0, Date.now())<span class="hljs-comment">;</span>
navigator.sendBeacon(url, buffer)<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-36">3.4 使用场景</h3>
<p>Beacon API 主要用于以下场景：</p>
<ul>
<li>
<p><strong>用户行为分析</strong>：发送用户点击、页面浏览等行为数据。</p>
</li>
<li>
<p><strong>性能监控</strong>：发送页面加载时间、资源加载时间等性能数据。</p>
</li>
<li>
<p><strong>错误报告</strong>：发送 JavaScript 错误、网络错误等错误信息。</p>
</li>
<li>
<p><strong>应用诊断</strong>：发送应用状态、日志信息等诊断数据。</p>
</li>
</ul>
<h3 data-id="heading-37">3.5 兼容性</h3>
<p>Beacon API 支持的浏览器包括 Chrome、Firefox、Edge、Safari 等，但不支持 Internet Explorer。建议在使用前检查浏览器兼容性。</p>
<h3 data-id="heading-38">3.6 发送数据示例</h3>
<p>以下是一些使用 Beacon API 发送数据的示例代码：</p>
<ul>
<li><strong>发送用户行为数据</strong></li>
</ul>

<pre><code class="hljs language-ini" lang="ini">window.addEventListener('beforeunload', function() {
    const <span class="hljs-attr">url</span> = <span class="hljs-string">'https://www.example.com/log'</span><span class="hljs-comment">;</span>
    const <span class="hljs-attr">data</span> = JSON.stringify({ event: <span class="hljs-string">'pageUnload'</span>, timestamp: Date.now() })<span class="hljs-comment">;</span>
    navigator.sendBeacon(url, data)<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li><strong>发送性能监控数据</strong></li>
</ul>

<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'beforeunload'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> url = <span class="hljs-string">'https://www.example.com/performance'</span>;
    <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
        <span class="hljs-attr">loadTime</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span>.<span class="hljs-property">timing</span>.<span class="hljs-property">loadEventEnd</span> - <span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span>.<span class="hljs-property">timing</span>.<span class="hljs-property">navigationStart</span>,
        <span class="hljs-attr">resources</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span>.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">'resource'</span>)
    });
    navigator.<span class="hljs-title function_">sendBeacon</span>(url, data);
});
</code></pre>
<ul>
<li><strong>发送错误报告</strong></li>
</ul>

<pre><code class="hljs language-vbnet" lang="vbnet">window.addEventListener(<span class="hljs-comment">'error', function(event) {</span>
    <span class="hljs-keyword">const</span> url = <span class="hljs-comment">'https://www.example.com/error';</span>
    <span class="hljs-keyword">const</span> data = JSON.stringify({
        message: <span class="hljs-keyword">event</span>.message,
        source: <span class="hljs-keyword">event</span>.filename,
        line: <span class="hljs-keyword">event</span>.lineno,
        col: <span class="hljs-keyword">event</span>.colno,
        <span class="hljs-keyword">error</span>: <span class="hljs-keyword">event</span>.<span class="hljs-keyword">error</span>
    });
    navigator.sendBeacon(url, data);
});
</code></pre>
<ul>
<li><strong>发送应用诊断数据</strong></li>
</ul>

<pre><code class="hljs language-ini" lang="ini">window.addEventListener('beforeunload', function() {
    const <span class="hljs-attr">url</span> = <span class="hljs-string">'https://www.example.com/diagnostics'</span><span class="hljs-comment">;</span>
    const <span class="hljs-attr">data</span> = JSON.stringify({
        state: app.getState(),
        logs: app.getLogs()
    })<span class="hljs-comment">;</span>
    navigator.sendBeacon(url, data)<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-39">3.7 数据传输的可靠性</h3>
<p>Beacon API 通过使用 HTTP POST 方法，将数据以非阻塞的方式传输到服务器。它使用浏览器的传输队列来确保数据在页面卸载前发送成功。即使页面已经关闭，浏览器仍会尝试发送数据。</p>
<h3 data-id="heading-40">3.8 数据接收与处理</h3>
<p>服务器端需要处理接收到的 Beacon 数据。以下是一个简单的服务器端处理示例（使用 Node.js 和 Express）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();
app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());

app.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/log'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Received log:'</span>, req.<span class="hljs-property">body</span>);
    res.<span class="hljs-title function_">sendStatus</span>(<span class="hljs-number">200</span>);
});

app.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/performance'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Received performance data:'</span>, req.<span class="hljs-property">body</span>);
    res.<span class="hljs-title function_">sendStatus</span>(<span class="hljs-number">200</span>);
});

app.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/error'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Received error report:'</span>, req.<span class="hljs-property">body</span>);
    res.<span class="hljs-title function_">sendStatus</span>(<span class="hljs-number">200</span>);
});

app.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/diagnostics'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Received diagnostics data:'</span>, req.<span class="hljs-property">body</span>);
    res.<span class="hljs-title function_">sendStatus</span>(<span class="hljs-number">200</span>);
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Server is listening on port 3000'</span>);
});
</code></pre>
<h3 data-id="heading-41">3.9 使用最佳实践</h3>
<ul>
<li>
<p>最小化数据量：尽量减少发送的数据量，以确保数据在页面卸载前能够发送成功。</p>
</li>
<li>
<p>避免敏感信息：由于 Beacon API 无法自定义请求头，发送的数据不应包含敏感信息。</p>
</li>
<li>
<p>多次发送：对于重要数据，可以在页面生命周期中多次发送，以提高数据传输的可靠性。</p>
</li>
<li>
<p>合理使用 Blob：对于二进制数据，可以使用 Blob 对象进行传输。</p>
</li>
</ul>
<h2 data-id="heading-42">4. WebSocket API</h2>
<p>WebSocket API 是一种在单个 TCP 连接上进行全双工通信的协议，允许客户端和服务器之间实时数据交换。与传统的 HTTP 请求-响应模型不同，WebSocket 提供了持续的双向连接，使得数据可以在客户端和服务器之间即时传输，非常适合实时应用如在线聊天、实时更新、在线游戏等。</p>
<blockquote>
<p>这个我们也很熟悉了，比如面试经常会问的心跳机制。</p>
</blockquote>
<h3 data-id="heading-43">4.1 WebSocket API 的优点</h3>
<ul>
<li>
<p>实时通信：提供全双工通信，允许客户端和服务器之间实时传输数据。</p>
</li>
<li>
<p>低延迟：比 HTTP 轮询具有更低的延迟，减少了通信的开销。</p>
</li>
<li>
<p>效率高：在保持连接的情况下，可以持续发送和接收数据，无需每次都建立新的连接。</p>
</li>
<li>
<p>支持二进制数据：除了文本数据，还支持二进制数据传输。</p>
</li>
</ul>
<h3 data-id="heading-44">4.2 WebSocket API 的缺点</h3>
<ul>
<li>
<p>连接维持：需要维持一个持久连接，可能会占用更多的服务器资源。</p>
</li>
<li>
<p>复杂性：相比于 HTTP 请求，WebSocket 的实现和管理更为复杂。</p>
</li>
<li>
<p>防火墙问题：一些防火墙和代理服务器可能会阻止 WebSocket 连接。</p>
</li>
</ul>
<h3 data-id="heading-45">4.3 WebSocket API 的用法</h3>
<h4 data-id="heading-46">1. 创建 WebSocket 对象</h4>
<p>创建 WebSocket 对象是使用 WebSocket 的第一步。通过&nbsp;<code>new WebSocket(url)</code>&nbsp;可以创建一个新的 WebSocket 连接。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">socket</span> = new WebSocket(<span class="hljs-string">'ws://www.example.com/socketserver'</span>)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-47">2. 连接事件处理</h4>
<p>可以使用&nbsp;<code>onopen</code>&nbsp;事件处理程序来处理连接成功事件。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">socket.onopen</span> = function(event) {
    console.log('WebSocket is open now.')<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-48">3. 发送数据</h4>
<p>使用&nbsp;<code>send</code>&nbsp;方法可以向服务器发送数据。数据可以是字符串或二进制数据（Blob、ArrayBuffer）。</p>
<pre><code class="hljs language-arduino" lang="arduino">socket.<span class="hljs-built_in">send</span>(<span class="hljs-string">'Hello Server!'</span>);
</code></pre>
<h4 data-id="heading-49">4. 接收数据</h4>
<p>使用&nbsp;<code>onmessage</code>&nbsp;事件处理程序来处理接收到的数据。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">socket.onmessage</span> = function(event) {
    console.log('Received data from server:', event.data)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-50">5. 关闭连接</h4>
<p>使用&nbsp;<code>close</code>&nbsp;方法可以关闭 WebSocket 连接。</p>
<pre><code class="hljs language-go" lang="go">socket.<span class="hljs-built_in">close</span>();
</code></pre>
<p>使用&nbsp;<code>onclose</code>&nbsp;事件处理程序来处理连接关闭事件。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">socket.onclose</span> = function(event) {
    console.log('WebSocket is closed now.')<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-51">6. 处理错误</h4>
<p>使用&nbsp;<code>onerror</code>&nbsp;事件处理程序来处理连接错误。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">socket.onerror</span> = function(event) {
    console.error('WebSocket error observed:', event)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-52">4.4 WebSocket 连接管理</h3>
<h4 data-id="heading-53">1. 自动重连</h4>
<p>在实际应用中，WebSocket 连接可能会因为各种原因断开。为了提高应用的可靠性，可以实现自动重连机制。</p>
<pre><code class="hljs language-ini" lang="ini">function createWebSocket(url) {
    let <span class="hljs-attr">socket</span> = new WebSocket(url)<span class="hljs-comment">;</span>

    <span class="hljs-attr">socket.onopen</span> = function(event) {
        console.log('WebSocket is open now.')<span class="hljs-comment">;</span>
    }<span class="hljs-comment">;</span>

    <span class="hljs-attr">socket.onmessage</span> = function(event) {
        console.log('Received data from server:', event.data)<span class="hljs-comment">;</span>
    }<span class="hljs-comment">;</span>

    <span class="hljs-attr">socket.onclose</span> = function(event) {
        console.log('WebSocket is closed now. Reconnecting...')<span class="hljs-comment">;</span>
        setTimeout(function() {
            createWebSocket(url)<span class="hljs-comment">;</span>
        }, 1000)<span class="hljs-comment">;</span>
    }<span class="hljs-comment">;</span>

    <span class="hljs-attr">socket.onerror</span> = function(event) {
        console.error('WebSocket error observed:', event)<span class="hljs-comment">;</span>
    }<span class="hljs-comment">;</span>

    return socket<span class="hljs-comment">;</span>
}

const <span class="hljs-attr">socket</span> = createWebSocket(<span class="hljs-string">'ws://www.example.com/socketserver'</span>)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-54">2. 心跳机制</h4>
<p>为了保持 WebSocket 连接的活跃，可以实现心跳机制，定期发送心跳消息到服务器。</p>
<pre><code class="hljs language-scss" lang="scss">let socket;
let heartBeatInterval;

function <span class="hljs-built_in">startHeartBeat</span>() {
    heartBeatInterval = <span class="hljs-built_in">setInterval</span>(function() {
        if (socket.readyState === WebSocket.OPEN) {
            socket<span class="hljs-selector-class">.send</span>('ping');
        }
    }, <span class="hljs-number">30000</span>); <span class="hljs-comment">// 每 30 秒发送一次心跳消息</span>
}

function <span class="hljs-built_in">stopHeartBeat</span>() {
    <span class="hljs-built_in">clearInterval</span>(heartBeatInterval);
}

socket<span class="hljs-selector-class">.onopen</span> = <span class="hljs-built_in">function</span>(event) {
    console<span class="hljs-selector-class">.log</span>('WebSocket is open now.');
    <span class="hljs-built_in">startHeartBeat</span>();
};

socket<span class="hljs-selector-class">.onclose</span> = <span class="hljs-built_in">function</span>(event) {
    console<span class="hljs-selector-class">.log</span>('WebSocket is closed now.');
    <span class="hljs-built_in">stopHeartBeat</span>();
};
</code></pre>
<h3 data-id="heading-55">4.5 WebSocket 数据传输</h3>
<h4 data-id="heading-56">1. 发送文本数据</h4>
<p>WebSocket 允许发送文本数据，例如 JSON 字符串。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">message</span> = JSON.stringify({ type: <span class="hljs-string">'greeting'</span>, content: <span class="hljs-string">'Hello Server!'</span> })<span class="hljs-comment">;</span>
socket.send(message)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-57">2. 发送二进制数据</h4>
<p>WebSocket 也支持发送二进制数据，例如 ArrayBuffer 和 Blob。</p>
<ul>
<li>发送 ArrayBuffer 数据：</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">buffer</span> = new ArrayBuffer(<span class="hljs-number">8</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">view</span> = new Uint8Array(buffer)<span class="hljs-comment">;</span>
view<span class="hljs-section">[0]</span> = 0<span class="hljs-comment">;</span>
view<span class="hljs-section">[1]</span> = 1<span class="hljs-comment">;</span>
view<span class="hljs-section">[2]</span> = 2<span class="hljs-comment">;</span>
socket.send(buffer)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>发送 Blob 数据：</li>
</ul>

<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">blob</span> = new Blob([<span class="hljs-string">'Hello, WebSocket!'</span>], { type: <span class="hljs-string">'text/plain'</span> })<span class="hljs-comment">;</span>
socket.send(blob)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-58">3. 接收文本数据</h4>
<p>接收到的消息可以是文本数据。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">socket.onmessage</span> = function(event) {
    const <span class="hljs-attr">data</span> = event.data<span class="hljs-comment">;</span>
    console.log('Received data:', data)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-59">4. 接收二进制数据</h4>
<p>可以处理接收到的二进制数据。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">socket.binaryType</span> = <span class="hljs-string">'arraybuffer'</span><span class="hljs-comment">;</span>
<span class="hljs-attr">socket.onmessage</span> = function(event) {
    const <span class="hljs-attr">arrayBuffer</span> = event.data<span class="hljs-comment">;</span>
    console.log('Received ArrayBuffer:', arrayBuffer)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-60">4.6 安全性</h3>
<p>WebSocket 可以通过 wss:// 协议进行加密传输，类似于 HTTPS，确保数据传输的安全性。建议在传输敏感数据时使用 wss:// 协议。</p>
<h3 data-id="heading-61">4.7 使用场景</h3>
<p>WebSocket 适用于以下场景：</p>
<ul>
<li>
<p>实时聊天：例如即时通讯应用、聊天室等。</p>
</li>
<li>
<p>实时更新：例如股票行情、体育比分等实时更新的数据。</p>
</li>
<li>
<p>在线游戏：例如多人在线游戏，实时传输游戏状态和操作。</p>
</li>
<li>
<p>实时协作：例如多人协作编辑文档、代码等。</p>
</li>
<li>
<p>物联网：例如传感器数据实时传输、设备控制等。</p>
</li>
</ul>
<h3 data-id="heading-62">4.8 兼容性</h3>
<p>WebSocket API 支持的大多数现代浏览器，包括 Chrome、Firefox、Edge、Safari 等，但需要确保服务器和客户端均支持 WebSocket 协议。</p>
<h2 data-id="heading-63">5. Server-Sent Events (SSE)</h2>
<p>Server-Sent Events (SSE) 是一种服务器推送技术，使服务器能够主动向客户端发送更新，而不需要客户端发出请求。SSE 使用 HTTP 协议，通过一个持续打开的 HTTP 连接，服务器可以在其上不断发送数据更新到客户端。这种方式非常适合实时更新的应用场景，如新闻推送、股票行情、社交媒体更新等。</p>
<blockquote>
<p>小伙伴们是不是想到了WebSocket和轮询，我认为SSE很多方面都比这两种方法强。</p>
</blockquote>
<h3 data-id="heading-64">5.1 SSE 的优点</h3>
<ul>
<li>
<p>简单实现：SSE 基于 HTTP 协议，使用起来非常简单，只需要服务器不断发送更新，客户端接收即可。</p>
</li>
<li>
<p>低开销：相比于轮询或 WebSocket，SSE 的开销较低，适合单向数据流的应用。</p>
</li>
<li>
<p>自动重连：SSE 支持自动重连机制，当连接断开时，浏览器会自动尝试重新连接。</p>
</li>
<li>
<p>浏览器支持好：现代主流浏览器如 Chrome、Firefox、Safari 等都支持 SSE。</p>
</li>
</ul>
<h3 data-id="heading-65">5.2 SSE 的缺点</h3>
<ul>
<li>
<p>单向通信：SSE 仅支持服务器向客户端发送数据，不支持双向通信。如果需要双向通信，需要结合其他技术如 WebSocket。</p>
</li>
<li>
<p>受限于浏览器：某些旧版浏览器不支持 SSE，例如 IE 浏览器不支持 SSE。</p>
</li>
<li>
<p>连接数限制：每个浏览器对同一域名的并发连接数有限制，SSE 会占用一个连接。</p>
</li>
</ul>
<h3 data-id="heading-66">5.3 SSE 的用法</h3>
<h4 data-id="heading-67">1. 创建 EventSource 对象</h4>
<p>创建 EventSource 对象是使用 SSE 的第一步。通过&nbsp;<code>new EventSource(url)</code>&nbsp;可以创建一个新的 SSE 连接。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">eventSource</span> = new EventSource(<span class="hljs-string">'http://www.example.com/events'</span>)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-68">2. 处理事件</h4>
<p>使用&nbsp;<code>onmessage</code>&nbsp;事件处理程序来处理服务器发送的消息。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">eventSource.onmessage</span> = function(event) {
    console.log('Received data from server:', event.data)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-69">3. 自定义事件</h4>
<p>服务器可以发送自定义事件，客户端可以使用&nbsp;<code>addEventListener</code>&nbsp;来监听这些事件。</p>
<pre><code class="hljs language-javascript" lang="javascript">eventSource.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'customEvent'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Received custom event data:'</span>, event.<span class="hljs-property">data</span>);
});
</code></pre>
<h4 data-id="heading-70">4. 处理连接打开和关闭</h4>
<p>使用&nbsp;<code>onopen</code>&nbsp;和&nbsp;<code>onerror</code>&nbsp;事件处理程序来处理连接打开和关闭事件。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">eventSource.onopen</span> = function(event) {
    console.log('Connection to server opened.')<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

<span class="hljs-attr">eventSource.onerror</span> = function(event) {
    if (<span class="hljs-attr">event.eventPhase</span> === EventSource.CLOSED) {
        console.log('Connection to server closed.')<span class="hljs-comment">;</span>
    } else {
        console.error('Error occurred:', event)<span class="hljs-comment">;</span>
    }
}<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-71"></h3>
<h3 data-id="heading-72">5.4 SSE 数据格式</h3>
<p>SSE 的数据格式非常简单，服务器发送的数据格式如下：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">data</span>: This <span class="hljs-keyword">is</span> a message\n\n
</code></pre>
<p>数据格式的详细说明：</p>
<ul>
<li><code>data</code>：发送的数据，可以多行。</li>
<li><code>event</code>：自定义事件类型。</li>
<li><code>id</code>：消息的唯一 ID。</li>
<li><code>retry</code>：客户端重连的时间间隔（毫秒）。</li>
</ul>
<p>示例：</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">data:</span> This <span class="hljs-built_in">is</span> a message\n\n
<span class="hljs-symbol">event:</span> customEvent\ndata: <span class="hljs-keyword">Custom</span> <span class="hljs-keyword">event</span> data\n\n
<span class="hljs-symbol">id:</span> <span class="hljs-number">123</span>\ndata: This <span class="hljs-built_in">is</span> a message <span class="hljs-keyword">with</span> an ID\n\n
<span class="hljs-symbol">retry:</span> <span class="hljs-number">5000</span>\ndata: This <span class="hljs-built_in">is</span> a message <span class="hljs-keyword">with</span> retry interval\n\n
</code></pre>
<h3 data-id="heading-73">5.5 处理断开和重连</h3>
<p>SSE 支持自动重连机制，客户端在连接断开后会自动尝试重新连接。服务器可以通过&nbsp;<code>Last-Event-ID</code>&nbsp;头部字段来处理客户端重连时的消息丢失问题。</p>
<p>服务器发送消息时可以附带消息 ID：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-built_in">id</span>: <span class="hljs-number">123</span>\ndata: This <span class="hljs-keyword">is</span> a message <span class="hljs-keyword">with</span> an ID\n\n
</code></pre>
<p>客户端在重新连接时会发送&nbsp;<code>Last-Event-ID</code>&nbsp;头部字段，服务器可以根据此 ID 来确定从哪条消息开始发送。</p>
<h3 data-id="heading-74">5.6 SSE 的使用场景</h3>
<ul>
<li>
<p>实时更新：如新闻推送、股票行情、体育比分等实时数据更新。</p>
</li>
<li>
<p>通知系统：如邮件通知、系统消息通知等。</p>
</li>
<li>
<p>社交媒体：如社交媒体动态更新、评论实时更新等。</p>
</li>
<li>
<p>监控系统：如服务器监控、应用状态监控等。</p>
</li>
</ul>
<h3 data-id="heading-75">5.7 SSE 与 WebSocket 对比</h3>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fcc5d5f6fbc249e4ae9095bab9d38bc7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6buR6Imy55qE5p6r:q75.awebp?rk3s=f64ab15b&amp;x-expires=1736324852&amp;x-signature=75eIec5RqBa2eEBdarzoEL2W1g4%3D" alt="" loading="lazy"></p>
<h3 data-id="heading-76">5.8 SSE 兼容性</h3>
<p>SSE 支持的大多数现代浏览器，包括 Chrome、Firefox、Safari 等，但 IE 浏览器不支持 SSE。可以使用 polyfill 或者其他替代方案来实现 IE 的支持。</p>
<h2 data-id="heading-77">6. XMLHttpRequest Level 2</h2>
<p><code>XMLHttpRequest Level 2</code>&nbsp;(XHR2) 是对原始 XMLHttpRequest API 的扩展，提供了一些新功能和改进，以满足现代 Web 开发的需求。它使开发者能够更方便地与服务器进行异步通信，处理文件上传，监控请求进度，并支持跨域请求 (CORS)。</p>
<h3 data-id="heading-78">6.1 XMLHttpRequest Level 2 的优点</h3>
<ol>
<li>
<p>跨域请求支持：通过 CORS，XHR2 可以跨域发送请求和接收响应。</p>
</li>
<li>
<p>文件上传支持：使用 FormData 对象，可以方便地上传文件。</p>
</li>
<li>
<p>进度事件：可以监控请求的进度，包括上传和下载。</p>
</li>
<li>
<p>Blob 和 ArrayBuffer 支持：可以发送和接收二进制数据。</p>
</li>
<li>
<p>超时设置：可以设置请求的超时时间。</p>
</li>
</ol>
<h3 data-id="heading-79">6.2 XMLHttpRequest Level 2 的缺点</h3>
<ol>
<li>
<p>复杂性增加：虽然功能更强大，但使用起来比原始的 XMLHttpRequest 更复杂。</p>
</li>
<li>
<p>浏览器兼容性问题：虽然现代浏览器都支持 XHR2，但某些旧版浏览器可能不完全支持。</p>
</li>
<li>
<p>安全性问题：跨域请求可能带来安全风险，需要服务器正确配置 CORS。</p>
</li>
</ol>
<h3 data-id="heading-80">6.3 XMLHttpRequest Level 2 的用法</h3>
<h4 data-id="heading-81">1. 创建 XMLHttpRequest 对象</h4>
<p>这是使用 XMLHttpRequest 的第一步，通过&nbsp;<code>new XMLHttpRequest()</code>&nbsp;创建一个新的 XMLHttpRequest 对象。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">xhr</span> = new XMLHttpRequest()<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-82">2. 初始化请求</h4>
<p>使用&nbsp;<code>open</code>&nbsp;方法来初始化请求。它有三个主要参数：请求方法（GET, POST 等）、请求 URL，以及是否异步（布尔值）。</p>
<pre><code class="hljs language-kotlin" lang="kotlin">xhr.<span class="hljs-keyword">open</span>(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'https://example.com/data'</span>, <span class="hljs-literal">true</span>);
</code></pre>
<h4 data-id="heading-83">3. 设置请求头</h4>
<p>使用&nbsp;<code>setRequestHeader</code>&nbsp;方法来设置请求头，这在发送 POST 请求或需要特定的请求头时特别有用。</p>
<pre><code class="hljs language-arduino" lang="arduino">xhr.<span class="hljs-built_in">setRequestHeader</span>(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'application/json'</span>);
</code></pre>
<h4 data-id="heading-84">4. 发送请求</h4>
<p>使用&nbsp;<code>send</code>&nbsp;方法来发送请求。对于 GET 请求，可以不传递参数；对于 POST 请求，可以传递请求体数据。</p>
<pre><code class="hljs language-ini" lang="ini">xhr.send()<span class="hljs-comment">;</span>
</code></pre>
<p>对于 POST 请求，传递请求体数据：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">data</span> = JSON.stringify({ name: <span class="hljs-string">'Feng'</span>, age:<span class="hljs-number">26</span> })<span class="hljs-comment">;</span>
xhr.send(data)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-85">5. 处理响应</h4>
<p>使用&nbsp;<code>onreadystatechange</code>&nbsp;事件处理响应。每当&nbsp;<code>readyState</code>&nbsp;属性改变时，<code>onreadystatechange</code>&nbsp;事件会被触发。可以通过检查&nbsp;<code>readyState</code>&nbsp;和&nbsp;<code>status</code>&nbsp;来确定请求的状态和结果。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">xhr.onreadystatechange</span> = function() {
    if (<span class="hljs-attr">xhr.readyState</span> === <span class="hljs-number">4</span>) { // 请求完成
        if (<span class="hljs-attr">xhr.status</span> === <span class="hljs-number">200</span>) { // 成功
            console.log(xhr.responseText)<span class="hljs-comment">;</span>
        } else {
            console.error('Error:', xhr.statusText)<span class="hljs-comment">;</span>
        }
    }
}<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-86">6. 进度事件</h4>
<p>XHR2 引入了进度事件，可以用来监控请求的进度。这对于文件上传和下载特别有用。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">xhr.upload.onprogress</span> = function(event) {
    if (event.lengthComputable) {
        const <span class="hljs-attr">percentComplete</span> = (event.loaded / event.total) * <span class="hljs-number">100</span><span class="hljs-comment">;</span>
        console.log(`Upload progress: ${percentComplete}%`)<span class="hljs-comment">;</span>
    }
}<span class="hljs-comment">;</span>

<span class="hljs-attr">xhr.onprogress</span> = function(event) {
    if (event.lengthComputable) {
        const <span class="hljs-attr">percentComplete</span> = (event.loaded / event.total) * <span class="hljs-number">100</span><span class="hljs-comment">;</span>
        console.log(`Download progress: ${percentComplete}%`)<span class="hljs-comment">;</span>
    }
}<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-87">7. 处理错误</h4>
<p>可以在&nbsp;<code>onerror</code>&nbsp;事件处理程序中处理网络错误。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">xhr.onerror</span> = function() {
    console.error('Request failed')<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-88">8. 跨域请求</h4>
<p>XHR2 支持跨域请求，但需要服务器正确配置 CORS。服务器需要返回允许跨域的头部：</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">Access-Control-Allow-Origin: https://yourdomain.com</span>
<span class="hljs-section">Access-Control-Allow-Methods: GET, POST</span>
<span class="hljs-section">Access-Control-Allow-Headers: Content-Type</span>
</code></pre>
<p>前端代码：</p>
<pre><code class="hljs language-ini" lang="ini">xhr.open('GET', 'https://example.com/data', true)<span class="hljs-comment">;</span>
<span class="hljs-attr">xhr.withCredentials</span> = <span class="hljs-literal">true</span><span class="hljs-comment">; // 如果需要发送凭证</span>
xhr.send()<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-89">9. 文件上传</h4>
<p>使用 FormData 对象，可以方便地上传文件。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">formData</span> = new FormData()<span class="hljs-comment">;</span>
formData.append('file', fileInput.files<span class="hljs-section">[0]</span>)<span class="hljs-comment">;</span>

const <span class="hljs-attr">xhr</span> = new XMLHttpRequest()<span class="hljs-comment">;</span>
xhr.open('POST', 'https://example.com/upload', true)<span class="hljs-comment">;</span>

<span class="hljs-attr">xhr.upload.onprogress</span> = function(event) {
    if (event.lengthComputable) {
        const <span class="hljs-attr">percentComplete</span> = (event.loaded / event.total) * <span class="hljs-number">100</span><span class="hljs-comment">;</span>
        console.log(`Upload progress: ${percentComplete}%`)<span class="hljs-comment">;</span>
    }
}<span class="hljs-comment">;</span>

xhr.send(formData)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-90">10. Blob 和 ArrayBuffer 支持</h4>
<p>XHR2 支持发送和接收二进制数据。</p>
<p>发送 Blob：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">const</span> blob = <span class="hljs-built_in">new</span> Blob([<span class="hljs-string">'Hello, world!'</span>], { <span class="hljs-keyword">type</span>: <span class="hljs-string">'text/plain'</span> });

<span class="hljs-keyword">const</span> xhr = <span class="hljs-built_in">new</span> XMLHttpRequest();
xhr.open(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'https://example.com/upload'</span>, <span class="hljs-literal">true</span>);
xhr.send(blob);
</code></pre>
<p>接收 ArrayBuffer：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">xhr.responseType</span> = <span class="hljs-string">'arraybuffer'</span><span class="hljs-comment">;</span>

<span class="hljs-attr">xhr.onload</span> = function() {
    if (<span class="hljs-attr">xhr.status</span> === <span class="hljs-number">200</span>) {
        const <span class="hljs-attr">arrayBuffer</span> = xhr.response<span class="hljs-comment">;</span>
        console.log(arrayBuffer)<span class="hljs-comment">;</span>
    }
}<span class="hljs-comment">;</span>

xhr.open('GET', 'https://example.com/data', true)<span class="hljs-comment">;</span>
xhr.send()<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-91">6.4 示例代码</h3>
<p>以下是一些完整的示例代码，展示如何使用 XMLHttpRequest Level 2 的不同功能。</p>
<ul>
<li><strong>GET 请求示例</strong></li>
</ul>

<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">xhr</span> = new XMLHttpRequest()<span class="hljs-comment">;</span>
xhr.open('GET', 'https://example.com/data', true)<span class="hljs-comment">;</span>

<span class="hljs-attr">xhr.onreadystatechange</span> = function() {
    if (<span class="hljs-attr">xhr.readyState</span> === <span class="hljs-number">4</span>) {
        if (<span class="hljs-attr">xhr.status</span> === <span class="hljs-number">200</span>) {
            console.log(JSON.parse(xhr.responseText))<span class="hljs-comment">;</span>
        } else {
            console.error('Error:', xhr.statusText)<span class="hljs-comment">;</span>
        }
    }
}<span class="hljs-comment">;</span>

xhr.send()<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li><strong>POST 请求示例</strong></li>
</ul>

<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">xhr</span> = new XMLHttpRequest()<span class="hljs-comment">;</span>
xhr.open('POST', 'https://example.com/data', true)<span class="hljs-comment">;</span>
xhr.setRequestHeader('Content-Type', 'application/json')<span class="hljs-comment">;</span>

<span class="hljs-attr">xhr.onreadystatechange</span> = function() {
    if (<span class="hljs-attr">xhr.readyState</span> === <span class="hljs-number">4</span>) {
        if (<span class="hljs-attr">xhr.status</span> === <span class="hljs-number">200</span>) {
            console.log(JSON.parse(xhr.responseText))<span class="hljs-comment">;</span>
        } else {
            console.error('Error:', xhr.statusText)<span class="hljs-comment">;</span>
        }
    }
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">data</span> = JSON.stringify({ name: <span class="hljs-string">'Feng'</span>, age: <span class="hljs-number">26</span> })<span class="hljs-comment">;</span>
xhr.send(data)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li><strong>文件上传示例</strong></li>
</ul>

<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">formData</span> = new FormData()<span class="hljs-comment">;</span>
formData.append('file', fileInput.files<span class="hljs-section">[0]</span>)<span class="hljs-comment">;</span>

const <span class="hljs-attr">xhr</span> = new XMLHttpRequest()<span class="hljs-comment">;</span>
xhr.open('POST', 'https://example.com/upload', true)<span class="hljs-comment">;</span>

<span class="hljs-attr">xhr.upload.onprogress</span> = function(event) {
    if (event.lengthComputable) {
        const <span class="hljs-attr">percentComplete</span> = (event.loaded / event.total) * <span class="hljs-number">100</span><span class="hljs-comment">;</span>
        console.log(`Upload progress: ${percentComplete}%`)<span class="hljs-comment">;</span>
    }
}<span class="hljs-comment">;</span>

xhr.send(formData)<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li><strong>Blob 发送示例</strong></li>
</ul>

<pre><code class="hljs language-go" lang="go"><span class="hljs-keyword">const</span> blob = <span class="hljs-built_in">new</span> Blob([<span class="hljs-string">'Hello, world!'</span>], { <span class="hljs-keyword">type</span>: <span class="hljs-string">'text/plain'</span> });

<span class="hljs-keyword">const</span> xhr = <span class="hljs-built_in">new</span> XMLHttpRequest();
xhr.open(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'https://example.com/upload'</span>, <span class="hljs-literal">true</span>);
xhr.send(blob);
</code></pre>
<ul>
<li><strong>ArrayBuffer 接收示例</strong></li>
</ul>

<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">xhr</span> = new XMLHttpRequest()<span class="hljs-comment">;</span>
<span class="hljs-attr">xhr.responseType</span> = <span class="hljs-string">'arraybuffer'</span><span class="hljs-comment">;</span>

<span class="hljs-attr">xhr.onload</span> = function() {
    if (<span class="hljs-attr">xhr.status</span> === <span class="hljs-number">200</span>) {
        const <span class="hljs-attr">arrayBuffer</span> = xhr.response<span class="hljs-comment">;</span>
        console.log(arrayBuffer)<span class="hljs-comment">;</span>
    }
}<span class="hljs-comment">;</span>

xhr.open('GET', 'https://example.com/data', true)<span class="hljs-comment">;</span>
xhr.send()<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-92">6.5 安全性</h3>
<p>使用 XHR2 时，必须注意安全性问题，特别是跨域请求。确保服务器正确配置了 CORS 头，以防止跨站脚本攻击。此外，可以使用 Content Security Policy (CSP) 来限制脚本的来源，防止恶意代码的执行。</p>
<h3 data-id="heading-93">6.6 常见问题</h3>
<ol>
<li>
<p><strong>请求被阻止</strong>：确保服务器正确配置了 CORS 头。</p>
</li>
<li>
<p><strong>进度事件不触发</strong>：确保请求的 Content-Length 头已正确设置。</p>
</li>
<li>
<p><strong>Blob/ArrayBuffer 不支持</strong>：检查浏览器的支持情况，并确保&nbsp;<code>responseType</code>&nbsp;设置正确。</p>
</li>
</ol>
<h2 data-id="heading-94">7. WebRTC</h2>
<p>WebRTC（Web Real-Time Communication）是一项由W3C（World Wide Web Consortium）和IETF（Internet Engineering Task Force）共同制定的技术标准，用于实现浏览器和移动应用之间的实时音视频通信以及数据共享。WebRTC 提供了简单、强大且可扩展的 API，使开发者能够在其应用中轻松集成实时通信功能。</p>
<h3 data-id="heading-95">7.1 WebRTC 的优点</h3>
<ol>
<li>
<p>实时通信：WebRTC 提供低延迟、高质量的音视频通信，适合实时应用，如视频会议、在线教育等。</p>
</li>
<li>
<p>点对点连接：WebRTC 通过直接的点对点连接，减少了服务器负载和通信延迟。</p>
</li>
<li>
<p>跨平台支持：WebRTC 支持在多个平台上运行，包括桌面浏览器、移动设备和嵌入式系统。</p>
</li>
<li>
<p>开源免费：WebRTC 是一个开源项目，开发者可以免费使用并进行修改。</p>
</li>
<li>
<p>安全性：WebRTC 使用了 SRTP（Secure Real-time Transport Protocol）和 DTLS（Datagram Transport Layer Security）来加密音视频流和数据通道，确保通信的安全性。</p>
</li>
</ol>
<h3 data-id="heading-96">7.2 WebRTC 的缺点</h3>
<ol>
<li>
<p>复杂性增加：WebRTC 的 API 复杂且涉及多种协议，开发和调试需要一定的学习成本。</p>
</li>
<li>
<p>网络条件依赖：WebRTC 的性能和稳定性依赖于网络质量，不良的网络条件可能导致通信质量下降。</p>
</li>
<li>
<p>兼容性问题：虽然现代浏览器都支持 WebRTC，但某些旧版浏览器或特定环境可能不完全支持。</p>
</li>
<li>
<p>NAT 和防火墙穿透：在一些网络环境下，实现 NAT（Network Address Translation）和防火墙穿透可能会遇到困难。</p>
</li>
</ol>
<h3 data-id="heading-97">7.3 WebRTC 的用法</h3>
<p>WebRTC 的基本组成部分包括三个核心 API：<code>MediaStream</code>、<code>RTCPeerConnection</code>&nbsp;和&nbsp;<code>RTCDataChannel</code>。</p>
<h4 data-id="heading-98">1. MediaStream API</h4>
<p>MediaStream API 用于获取和操作媒体流（音频和视频）。可以使用&nbsp;<code>getUserMedia</code>&nbsp;方法来访问用户的摄像头和麦克风。</p>
<pre><code class="hljs language-ini" lang="ini">navigator.mediaDevices.getUserMedia({ video: true, audio: true })
  .then(<span class="hljs-attr">stream</span> =&gt; {
    const <span class="hljs-attr">videoElement</span> = document.querySelector(<span class="hljs-string">'video'</span>)<span class="hljs-comment">;</span>
    <span class="hljs-attr">videoElement.srcObject</span> = stream<span class="hljs-comment">;</span>
  })
  .catch(<span class="hljs-attr">error</span> =&gt; {
    console.error('Error accessing media devices.', error)<span class="hljs-comment">;</span>
  })<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-99">2. RTCPeerConnection API</h4>
<p>RTCPeerConnection 是 WebRTC 的核心组件，用于建立和控制点对点连接。</p>
<h5 data-id="heading-100">创建 RTCPeerConnection</h5>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">configuration</span> = {
  iceServers: <span class="hljs-section">[
    { urls: 'stun:stun.l.google.com:19302' }
  ]</span>
}<span class="hljs-comment">;</span>
const <span class="hljs-attr">peerConnection</span> = new RTCPeerConnection(configuration)<span class="hljs-comment">;</span>
</code></pre>
<h5 data-id="heading-101">添加媒体流到连接</h5>
<pre><code class="hljs language-ini" lang="ini">navigator.mediaDevices.getUserMedia({ video: true, audio: true })
  .then(<span class="hljs-attr">stream</span> =&gt; {
    stream.getTracks().forEach(<span class="hljs-attr">track</span> =&gt; peerConnection.addTrack(track, stream))<span class="hljs-comment">;</span>
  })
  .catch(<span class="hljs-attr">error</span> =&gt; {
    console.error('Error accessing media devices.', error)<span class="hljs-comment">;</span>
  })<span class="hljs-comment">;</span>
</code></pre>
<h5 data-id="heading-102">处理 ICE 候选</h5>
<p>ICE（Interactive Connectivity Establishment）候选是 WebRTC 用于寻找最佳路径以建立点对点连接的机制。</p>
<pre><code class="hljs language-csharp" lang="csharp">peerConnection.onicecandidate = <span class="hljs-keyword">event</span> =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">event</span>.candidate) {
    <span class="hljs-comment">// 发送 ICE 候选到远端对等体</span>
    sendCandidateToRemote(<span class="hljs-keyword">event</span>.candidate);
  }
};
</code></pre>
<h5 data-id="heading-103">创建和交换 SDP</h5>
<p>SDP（Session Description Protocol）是用于描述多媒体通信会话的格式。对等体之间需要交换 SDP 信息来建立连接。</p>
<h6 data-id="heading-104">创建 Offer</h6>
<pre><code class="hljs language-ini" lang="ini">peerConnection.createOffer()
  .then(<span class="hljs-attr">offer</span> =&gt; {
    return peerConnection.setLocalDescription(offer)<span class="hljs-comment">;</span>
  })
  .then(() =&gt; {
    // 发送 SDP Offer 到远端对等体
    sendOfferToRemote(peerConnection.localDescription)<span class="hljs-comment">;</span>
  })
  .catch(<span class="hljs-attr">error</span> =&gt; {
    console.error('Error creating offer.', error)<span class="hljs-comment">;</span>
  })<span class="hljs-comment">;</span>
</code></pre>
<h6 data-id="heading-105">处理 Offer</h6>
<pre><code class="hljs language-typescript" lang="typescript">peerConnection.<span class="hljs-title function_">setRemoteDescription</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RTCSessionDescription</span>(offer))
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> peerConnection.<span class="hljs-title function_">createAnswer</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">answer</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> peerConnection.<span class="hljs-title function_">setLocalDescription</span>(answer);
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 发送 SDP Answer 到远端对等体</span>
    <span class="hljs-title function_">sendAnswerToRemote</span>(peerConnection.<span class="hljs-property">localDescription</span>);
  })
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error handling offer.'</span>, error);
  });
</code></pre>
<h6 data-id="heading-106">处理 Answer</h6>
<pre><code class="hljs language-go" lang="go">peerConnection.setRemoteDescription(<span class="hljs-built_in">new</span> RTCSessionDescription(answer))
  .catch(<span class="hljs-type">error</span> =&gt; {
    console.<span class="hljs-type">error</span>(<span class="hljs-string">'Error setting remote description.'</span>, <span class="hljs-type">error</span>);
  });
</code></pre>
<h4 data-id="heading-107">3. RTCDataChannel API</h4>
<p>RTCDataChannel 提供了在对等体之间发送任意数据的功能。</p>
<h5 data-id="heading-108">创建 Data Channel</h5>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">dataChannel</span> = peerConnection.createDataChannel(<span class="hljs-string">'chat'</span>)<span class="hljs-comment">;</span>

<span class="hljs-attr">dataChannel.onopen</span> = () =&gt; {
  console.log('Data channel is open')<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

<span class="hljs-attr">dataChannel.onmessage</span> = event =&gt; {
  console.log('Received message:', event.data)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h5 data-id="heading-109">接收 Data Channel</h5>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">peerConnection.ondatachannel</span> = event =&gt; {
  const <span class="hljs-attr">dataChannel</span> = event.channel<span class="hljs-comment">;</span>

  <span class="hljs-attr">dataChannel.onopen</span> = () =&gt; {
    console.log('Data channel is open')<span class="hljs-comment">;</span>
  }<span class="hljs-comment">;</span>

  <span class="hljs-attr">dataChannel.onmessage</span> = event =&gt; {
    console.log('Received message:', event.data)<span class="hljs-comment">;</span>
  }<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<h3 data-id="heading-110">7.4 示例代码</h3>
<p>以下是一个完整的示例代码，展示了如何使用 WebRTC API 来建立一个简单的音视频通信和数据通道。</p>
<p><strong>HTML：</strong></p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>WebRTC Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"localVideo"</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">playsinline</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"remoteVideo"</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">playsinline</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"webrtc.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 data-id="heading-111"></h3>
<p><strong>JavaScript：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> localVideo = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'localVideo'</span>);
<span class="hljs-keyword">const</span> remoteVideo = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'remoteVideo'</span>);

<span class="hljs-keyword">const</span> configuration = {
  <span class="hljs-attr">iceServers</span>: [
    { <span class="hljs-attr">urls</span>: <span class="hljs-string">'stun:stun.l.google.com:19302'</span> }
  ]
};
<span class="hljs-keyword">const</span> peerConnection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RTCPeerConnection</span>(configuration);

navigator.<span class="hljs-property">mediaDevices</span>.<span class="hljs-title function_">getUserMedia</span>({ <span class="hljs-attr">video</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">audio</span>: <span class="hljs-literal">true</span> })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">stream</span> =&gt;</span> {
    localVideo.<span class="hljs-property">srcObject</span> = stream;
    stream.<span class="hljs-title function_">getTracks</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">track</span> =&gt;</span> peerConnection.<span class="hljs-title function_">addTrack</span>(track, stream));
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error accessing media devices.'</span>, error);
  });

peerConnection.<span class="hljs-property">onicecandidate</span> = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">candidate</span>) {
    <span class="hljs-title function_">sendCandidateToRemote</span>(event.<span class="hljs-property">candidate</span>);
  }
};

peerConnection.<span class="hljs-property">ontrack</span> = <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
  remoteVideo.<span class="hljs-property">srcObject</span> = event.<span class="hljs-property">streams</span>[<span class="hljs-number">0</span>];
};

peerConnection.<span class="hljs-title function_">createOffer</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">offer</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> peerConnection.<span class="hljs-title function_">setLocalDescription</span>(offer);
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">sendOfferToRemote</span>(peerConnection.<span class="hljs-property">localDescription</span>);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error creating offer.'</span>, error);
  });

<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRemoteOffer</span>(<span class="hljs-params">offer</span>) {
  peerConnection.<span class="hljs-title function_">setRemoteDescription</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RTCSessionDescription</span>(offer))
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">return</span> peerConnection.<span class="hljs-title function_">createAnswer</span>();
    })
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">answer</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> peerConnection.<span class="hljs-title function_">setLocalDescription</span>(answer);
    })
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">sendAnswerToRemote</span>(peerConnection.<span class="hljs-property">localDescription</span>);
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error handling offer.'</span>, error);
    });
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRemoteAnswer</span>(<span class="hljs-params">answer</span>) {
  peerConnection.<span class="hljs-title function_">setRemoteDescription</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RTCSessionDescription</span>(answer))
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error setting remote description.'</span>, error);
    });
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRemoteCandidate</span>(<span class="hljs-params">candidate</span>) {
  peerConnection.<span class="hljs-title function_">addIceCandidate</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RTCIceCandidate</span>(candidate))
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error adding ICE candidate.'</span>, error);
    });
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">sendOfferToRemote</span>(<span class="hljs-params">offer</span>) {
  <span class="hljs-comment">// Implement this function to send the offer to the remote peer</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">sendAnswerToRemote</span>(<span class="hljs-params">answer</span>) {
  <span class="hljs-comment">// Implement this function to send the answer to the remote peer</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">sendCandidateToRemote</span>(<span class="hljs-params">candidate</span>) {
  <span class="hljs-comment">// Implement this function to send the candidate to the remote peer</span>
}
</code></pre>
<h3 data-id="heading-112">7.5 安全性</h3>
<p>WebRTC 使用多种安全协议来保护通信安全，包括：</p>
<ol>
<li>
<p><strong>SRTP</strong>：用于加密音视频流，防止窃听和篡改。</p>
</li>
<li>
<p><strong>DTLS</strong>：用于加密数据通道和信令数据，确保数据完整性和保密性。</p>
</li>
<li>
<p><strong>同源策略</strong>：WebRTC 遵循浏览器的同源策略，防止跨站脚本攻击。</p>
</li>
</ol>
<h3 data-id="heading-113">7.6 使用场景</h3>
<p>WebRTC 广泛应用于以下场景：</p>
<ol>
<li><strong>视频会议</strong>：如 Zoom、Google Meet 等。</li>
<li><strong>在线教育</strong>：如实时教学、远程实验等。</li>
<li><strong>远程医疗</strong>：如医生与患者之间的视频咨询。</li>
<li><strong>社交媒体</strong>：如实时视频聊天和直播。</li>
<li><strong>游戏</strong>：如实时多人游戏中的语音聊天和数据同步。</li>
</ol>
<h2 data-id="heading-114">8. 对比</h2>
<h3 data-id="heading-115">8.1 用途与类型</h3>
<ul>
<li>
<p>XMLHttpRequest 和 XMLHttpRequest Level 2: 早期的AJAX技术，用于从服务器异步获取数据。Level 2是XMLHttpRequest的扩展，增加了更多功能。</p>
</li>
<li>
<p>Fetch API: 现代、基于Promise的API，用于网络请求，支持跨域。</p>
</li>
<li>
<p>Beacon API: 用于在不影响当前页面性能的情况下，发送数据到服务器。</p>
</li>
<li>
<p>WebSocket API: 提供全双工通信渠道，允许服务器与客户端之间的实时、双向通信。</p>
</li>
<li>
<p>Server-Sent Events (SSE): 允许服务器主动向客户端发送更新，基于HTTP协议，但只能单向通信。</p>
</li>
<li>
<p>WebRTC: 不是直接用于HTTP请求，而是用于浏览器之间的实时通信，支持视频、音频和数据共享。</p>
</li>
</ul>
<h3 data-id="heading-116">8.2 同步性与实时性</h3>
<ul>
<li>
<p>XMLHttpRequest 和 XMLHttpRequest Level 2、Fetch API: 异步操作，但非实时通信（除非通过轮询）。</p>
</li>
<li>
<p>Beacon API: 异步，设计用于不阻塞页面的数据发送。</p>
</li>
<li>
<p>WebSocket API 和 WebRTC: 提供实时双向通信。</p>
</li>
<li>
<p>SSE: 实时单向通信（从服务器到客户端）。</p>
</li>
</ul>
<h3 data-id="heading-117">8.3 复杂度</h3>
<ul>
<li>
<p>XMLHttpRequest 和 XMLHttpRequest Level 2: 较为原始，需要处理较多细节。</p>
</li>
<li>
<p>Fetch API: 较为现代，使用Promise，但可能需要额外的库来处理复杂需求（如JSON解析）。</p>
</li>
<li>
<p>Beacon API: 非常简单，用于发送少量数据。</p>
</li>
<li>
<p>WebSocket API、SSE、WebRTC: 复杂度较高，需要处理网络事件和可能的连接问题。</p>
</li>
</ul>
<h3 data-id="heading-118">8.4 兼容性</h3>
<ul>
<li>
<p>XMLHttpRequest 和 XMLHttpRequest Level 2: 广泛支持，几乎所有现代浏览器都支持。</p>
</li>
<li>
<p>Fetch API: 现代浏览器支持，但在一些旧版浏览器中可能需要polyfill。</p>
</li>
<li>
<p>Beacon API、WebSocket API、SSE、WebRTC: 大多数现代浏览器支持，但在某些旧浏览器上可能不可用。</p>
</li>
</ul>
<h3 data-id="heading-119">8.5 使用场景</h3>
<ul>
<li>
<p>XMLHttpRequest 和 XMLHttpRequest Level 2、Fetch API: 适用于需要从服务器异步获取数据的情况。</p>
</li>
<li>
<p>Beacon API: 适用于发送分析数据、日志等，不影响页面性能。</p>
</li>
<li>
<p>WebSocket API: 实时游戏、聊天应用、实时通知等需要双向实时通信的场景。</p>
</li>
<li>
<p>SSE: 实时新闻更新、股票行情等需要从服务器实时获取数据但不需要发送数据的场景。</p>
</li>
<li>
<p>WebRTC: 视频会议、在线游戏等需要实时音视频通信的场景。</p>
</li>
</ul>
<h2 data-id="heading-120">9. 总结</h2>
<p>七种请求方式都梳理完了，好像，貌似，对以后的项目帮助不大，但是学是学到了，以后用不用得到，以后再说吧。</p></div></div>