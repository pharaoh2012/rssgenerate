
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ITnoteforlsy/p/18840486" title="发布于 2025-04-22 15:32">
    <span role="heading" aria-level="2">QT 实现 C++ 数据类与 json 的转换</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>QT 提供了 QJsonDocument、QJsonObject、QJsonArray、QJsonValue 等类用于 JSON 的解析和转换。QJsonValue 支持的数据类型包括：bool、double、string、array、object、null。但是，对于 QRectF、QLineF、QColor 等类以及用户自定义数据类，QJsonObject 就无法转换，更无法生成可读的字符串。此时，需要我们自己来实现转换并定义转换后的 JSON 格式。</p>
<p>上篇文章，<a href="https://www.cnblogs.com/ITnoteforlsy/p/18838786" target="_blank">借助 QT 的反射机制实现数据类的序列化</a> 实现了数据类的序列化，简化了数据类的编写，同时提供了转换为 JSON 的基础。通过元对象系统很容易找到我们通过宏 JSONFIELD 记录的需要序列化的字段，因为记录序列化的方法被导出并标记为 JSON_FLAG 。使用反射机制就可以找到所有记录序列化字段的方法，获取字段名后通过 getValue()、setValue() 即可获取或设置字段值。</p>
<pre><code>// serializable.h
#define JSONFIELD(field, alias, ...) \
using __type_##field = decltype(field) ;\
Q_PROPERTY(__type_##field field READ get##alias WRITE set##alias) \
    public: \
    Q_INVOKABLE JSON_FLAG inline QMap&lt;QString, QString&gt; __get##alias##Info__(){ \
        QMap&lt;QString, QString&gt; info; \
        info["name"] = #field; \
        info["alias"] = #alias; \
        info["args"] = QString(#__VA_ARGS__); \
        return info; \
    } \
    inline __type_##field get##alias() const { return field; } \
    inline void set##alias(const __type_##field &amp;value) { \
            field = value; \
    }
</code></pre>
<h2 id="定义通用的-json-接口">定义通用的 JSON 接口</h2>
<p>JSON 接口主要定义 4 个功能接口：1. 将数据类转换为 QJsonObject 对象；2. 将数据类转换为字符串；3. 将字符串解析为指定的数据类；4. 将 QJsonObject 转换为指定的数据类；<br>
系统允许多个接口实现类，但是全局只允许有一个实例，用于整个工程的 JSON 转换。所以声明了一个全局的 EasyJson 对象 EASYJSON。</p>
<pre><code>#include "serializable.h"

#include &lt;QJsonObject&gt;

class EasyJson{
public:
    EasyJson(){}
    ~EasyJson(){}
    virtual QJsonObject toJson(const Serializable &amp;obj) = 0;
    virtual QString toJsonString(const Serializable &amp;obj) = 0;
    virtual QVariant parseObject(QJsonObject json, QMetaType typeName) = 0;
    virtual QVariant parseObject(QString json, QMetaType typeName) = 0;
};

extern EasyJson *EASYJSON;
</code></pre>
<h2 id="easyjson-的实现类">EasyJson 的实现类</h2>
<p>实现类直接继承 EasyJson 类，完成接口代码即可。QT 中数据类转换为 JSON 的难点在于 QRectF、QSizeF 等类的转换，以及 Serializable 作为数据类字段时的转换。为了便于 QT 内部封装类的解析，需要将解析方法单独封装为一个工具类，这样便于后期添加和修改。工具类的实现见 variantutil.h 文件。</p>
<pre><code>// easyjsonimpl.h
#include "easyjson.h"

class EasyJsonImpl: public EasyJson
{
public:
    EasyJsonImpl();

    // EasyJson interface
private:
    QJsonObject toJson(const Serializable &amp;obj) override;
    QString toJsonString(const Serializable &amp;obj) override;
    QVariant parseObject(QJsonObject json, QMetaType typeName) override;
    QVariant parseObject(QString json, QMetaType typeName) override;
};
</code></pre>
<p>为了便于切换不同的 JSON 实现类，EASYJSON 对象的创建与否需要通过指定的宏来判断一下。如 EasyJsonImpl 源码中规定只有定义了 EASY_JSON_DEFAULT 才会实例化 EasyJsonImpl。<br>
这样在 .pro 文件中添加 <code>DEFINES += EASY_JSON_DEFAULT</code> 即可启用该实现类。如果有不同的实现类，定义不同的宏即可。</p>
<pre><code>// easyjsonimpl.cpp
#include "easyjsonimpl.h"
#include "variantutil.h"

#include &lt;QObject&gt;
#include &lt;QMetaObject&gt;
#include &lt;QMetaProperty&gt;
#include &lt;QColor&gt;
#include &lt;QJsonArray&gt;
#include &lt;QLineF&gt;
#include &lt;QPointF&gt;
#include &lt;QRectF&gt;
#include &lt;QSizeF&gt;
#include &lt;QJsonDocument&gt;

#ifdef EASY_JSON_DEFAULT
EasyJson *EASYJSON = new EasyJsonImpl();
#endif

EasyJsonImpl::EasyJsonImpl() {}

QJsonObject EasyJsonImpl::toJson(const Serializable &amp;obj)
{
    QJsonObject json;
    Serializable *objPtr = const_cast&lt;Serializable*&gt;(&amp;obj);

    const QMetaObject *metaInfo = obj.getMetaInfo();//obj.metaObject();
    do{
        int count = metaInfo-&gt;methodCount();
        for(int i=0; i&lt; count; i++){
            if (QString(metaInfo-&gt;method(i).tag()).compare("JSON_FLAG") == 0){
                QMap&lt;QString, QString&gt; jsonInfo;
                jsonInfo = objPtr-&gt;invokeMethod&lt;QMap&lt;QString, QString&gt;&gt;(metaInfo, i);
                QString alias = jsonInfo["alias"];
                QVariant value = objPtr-&gt;getValue(jsonInfo["name"]);
                QMetaType type = value.metaType();
                // 对 Serializable 子类递归转换
                if (type.id() &gt; QMetaType::User) {
                    auto valueMeta = type.metaObject();
                    auto classInfo = valueMeta-&gt;classInfo(valueMeta-&gt;indexOfClassInfo("base"));
                    if (QString("Serializable").compare(classInfo.value()) == 0) {
                        json.insert(alias, toJson(*reinterpret_cast&lt;const Serializable*&gt;(value.constData())));
                        continue;
                    }
                }
                // 转为json对象
                json.insert(alias, VariantUtil::toJsonValue(value));
            }
        }

        metaInfo = metaInfo-&gt;superClass();
    }while(metaInfo != nullptr);
    return json;
}

QString EasyJsonImpl::toJsonString(const Serializable &amp;obj)
{
    QJsonObject json = toJson(obj);
    QJsonDocument doc(json);
    return QString(doc.toJson(QJsonDocument::Compact));
}

QVariant EasyJsonImpl::parseObject(QJsonObject json, QMetaType typeName)
{
    const QMetaObject *metaInfo = typeName.metaObject();
    QVariant result(typeName);
    Serializable *obj = reinterpret_cast&lt;Serializable*&gt;(result.data());
    do{
        int count = metaInfo-&gt;methodCount();
        for(int i=0; i&lt; count; i++){
            if (QString(metaInfo-&gt;method(i).tag()).compare("JSON_FLAG") == 0){
                QMap&lt;QString, QString&gt; jsonInfo = obj-&gt;invokeMethod&lt;QMap&lt;QString, QString&gt;&gt;(metaInfo, i);

                QMetaProperty fieldType = metaInfo-&gt;property(metaInfo-&gt;indexOfProperty(jsonInfo["name"].toLocal8Bit()));
                QByteArray fieldName = jsonInfo["name"].toLocal8Bit();
                if (!json.contains(jsonInfo["alias"])){
                    continue;
                }
                QJsonValueRef jsonValue = json[jsonInfo["alias"]];
                // 对 Serializable 子类递归解析
                if (fieldType.metaType().id() &gt; QMetaType::User) {
                    auto valueMeta = fieldType.metaType().metaObject();
                    auto classInfo = valueMeta-&gt;classInfo(valueMeta-&gt;indexOfClassInfo("base"));
                    if (QString("Serializable").compare(classInfo.value()) == 0) {
                        obj-&gt;setValue(fieldName,
                                         parseObject(jsonValue.toObject(), fieldType.metaType()));
                        continue;
                    }
                }
                // 设置字段值
                obj-&gt;setValue(fieldName,
                              VariantUtil::fromJsonValue(jsonValue, fieldType.metaType()));
            }
        }
        metaInfo = metaInfo-&gt;superClass();
    }while(metaInfo != nullptr);
    return result;
}

QVariant EasyJsonImpl::parseObject(QString json, QMetaType typeName)
{
    if (json.isEmpty()) {
        return QVariant(typeName);
    }
    QJsonDocument doc = QJsonDocument::fromJson(json.toLocal8Bit());
    return parseObject(doc.object(), typeName);
}
</code></pre>
<p>variantutil 部分源码如下，详细代码请到项目 <a href="https://github.com/lsyeei/dashboard" target="_blank" rel="noopener nofollow">https://github.com/lsyeei/dashboard</a> 的源码目录 /common/ 中查看 variantutil.h 文件。</p>
<pre><code>inline QJsonValue VariantUtil::toJsonValue(const QVariant &amp;var)
{
    auto type = var.metaType();
    switch (type.id()) {
    case QMetaType::QPoint:
        return QJsonArray{var.toPoint().x(), var.toPoint().y()};
        break;
    case QMetaType::QPointF:
        return QJsonArray{var.toPointF().x(), var.toPointF().y()};
        break;
	...
	default:
        if (type.flags().testFlag(QMetaType::IsEnumeration)) {
            return var.toInt();
        } else {
            return QJsonValue::fromVariant(var);
        }
        break;
    }
}

inline QVariant VariantUtil::fromJsonValue(const QJsonValue &amp;val, QMetaType type)
{
    switch (type.id()) {
    case QMetaType::QPoint:
        return [=]{
            QJsonArray array(val.toArray());
            QPoint pt(array[0].toInt(), array[1].toInt());
            return QVariant(pt);}();
        break;
    case QMetaType::QPointF:
        return [=]{
            QJsonArray array(val.toArray());
            QPointF pt(array[0].toDouble(), array[1].toDouble());
            return QVariant(pt);}();
        break;
	...
	default:
        return val.toVariant();
        break;
    }
}
</code></pre>
<h2 id="使用-easyjson">使用 EASYJSON</h2>
<p>首先 .pro 文件中添加 <code>DEFINES += EASY_JSON_DEFAULT</code> 启用该实现类。需要序列化的数据类继承 Serializable 类，然后调用对应的方法即可<code>EASYJSON-&gt;toJsonString(pen)</code>。</p>
<p>项目 <a href="https://github.com/lsyeei/dashboard" target="_blank" rel="noopener nofollow">Compelling Data Designer</a> 用于数据的可视化设计，软件采用可扩展架构，支持扩展图形插件、数据接口。项目仍在开发中，目前已设计完成基本图形、多属性配置、动画等功能。项目中还提供了 JSON 序列化数据类的实现方式。</p>
<p><img src="https://img2024.cnblogs.com/blog/1596700/202504/1596700-20250421163503119-611157632.png" alt="image" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1596700/202504/1596700-20250407102627551-720752550.gif" alt="demo" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.8707686561631944" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-22 15:35">2025-04-22 15:32</span>&nbsp;
<a href="https://www.cnblogs.com/ITnoteforlsy">永不停转</a>&nbsp;
阅读(<span id="post_view_count">175</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18840486);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18840486', targetLink: 'https://www.cnblogs.com/ITnoteforlsy/p/18840486', title: 'QT 实现 C++ 数据类与 json 的转换' })">举报</a>
</div>
        