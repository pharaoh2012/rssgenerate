
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/timothy020/p/18920941" title="发布于 2025-06-09 16:37">
    <span role="heading" aria-level="2">TUF系统概述</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="tuf基本介绍">TUF基本介绍</h2>
<p><strong>TUF</strong> 是一个为软件更新系统设计的安全框架，最初由纽约大学的 Secure Systems Lab 提出。它的目标是解决传统软件更新过程中的各种安全问题（如中间人攻击、回滚攻击、密钥泄露等），<strong>通过多角色职责分离、多签名机制和密钥轮换机制来提高软件供应链的抗攻击能力和韧性</strong>。</p>
<h3 id="职责分派role-delegation"><strong>职责分派（Role Delegation）</strong></h3>
<p>将软件更新所涉及的权限分给不同角色，各自负责不同类型的元数据，降低“单点控制”的风险。</p>
<blockquote>
<p><strong>好处：</strong> 如果一个角色（如 timestamp）密钥泄露，其能力有限；不会影响整个更新系统。</p>
</blockquote>
<h3 id="多密钥--阈值签名threshold-signatures"><strong>多密钥 + 阈值签名（Threshold Signatures）</strong></h3>
<ul>
<li>每个角色可以设置多个密钥，以及一个 <strong>签名阈值 k-of-n</strong>。
<ul>
<li>例如：targets 角色可以设置“必须有 2 个开发者签名才有效”。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>好处：</strong> 即使一个开发者的密钥泄露，攻击者也无法伪造有效更新。</p>
</blockquote>
<h3 id="密钥轮转--撤销key-rotation--revocation"><strong>密钥轮转 &amp; 撤销（Key Rotation &amp; Revocation）</strong></h3>
<ul>
<li>所有公钥都被记录在 root.json 中，因此可以通过发布新版本的 root.json 来更换密钥。</li>
<li>密钥丢失或泄露后，管理员可通过 root 签名发布新的密钥信息。</li>
</ul>
<blockquote>
<p><strong>好处：</strong> 密钥是可更新的，系统不依赖于长期安全的密钥对。</p>
</blockquote>
<h3 id="相比传统软件更新的优势"><strong>相比传统软件更新的优势</strong></h3>
<table>
<thead>
<tr>
<th><strong>传统方式</strong></th>
<th><strong>存在问题</strong></th>
<th><strong>TUF 对应的改进</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>单密钥签名包</td>
<td>密钥泄露 = 全系统沦陷</td>
<td>多密钥 + 阈值签名</td>
</tr>
<tr>
<td>所有操作权限集中在一处</td>
<td>单点失败问题严重</td>
<td>明确角色职责分工，攻击面变小</td>
</tr>
<tr>
<td>没有更新验证链</td>
<td>无法追踪或信任</td>
<td>所有元数据签名链确保完整性</td>
</tr>
<tr>
<td>密钥一旦泄露难以替换</td>
<td>无轮转机制</td>
<td>通过 root.json 灵活轮转密钥</td>
</tr>
<tr>
<td>无法识别元数据或内容是否篡改</td>
<td>无法抵御回滚，冻结攻击<br>，混合匹配攻击</td>
<td>snapshot + timestamp 双重保护</td>
</tr>
</tbody>
</table>
<h2 id="定义元文件">定义元文件</h2>
<h3 id="元文件定义">元文件定义</h3>
<p>TUF中被保护的软件或软件包称为Target File，保护软件包的元文件称为Metadata File，分为<code>Root.json</code>，<code>Timestamp.json</code>，<code>Snapshot.json</code>，<code>Target.json</code>。</p>
<p>Notary中只存储和操作元数据文件，不存储软件或软件包本身。</p>
<h3 id="角色划分">角色划分</h3>
<table>
<thead>
<tr>
<th><strong>角色名称</strong></th>
<th><strong>职责概要</strong></th>
<th><strong>签名对象</strong></th>
<th><strong>密钥位置</strong></th>
<th><strong>由谁管理</strong></th>
<th><strong>签名要求</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Root</strong></td>
<td>管理和分发所有其它角色的公钥。支持密钥轮换、撤销。</td>
<td>Root.json</td>
<td>离线</td>
<td>仓库管理员</td>
<td>一般需 ≥2-of-n 签名</td>
</tr>
<tr>
<td><strong>Targets</strong></td>
<td>指定哪些镜像（或文件）被信任，可发布。支持 Delegation。</td>
<td>Targets.json</td>
<td>离线</td>
<td>项目负责人、开发者团队</td>
<td>一般需 1 或多签名</td>
</tr>
<tr>
<td><strong>Snapshot</strong></td>
<td>确保 targets（及其 delegation）元数据的一致性与版本管理，防止回滚和混合匹配攻击。</td>
<td>Target.json及其Delegation</td>
<td>可存服务端</td>
<td>自动化构建系统或服务器</td>
<td>通常 1 个签名</td>
</tr>
<tr>
<td><strong>Timestamp</strong></td>
<td>指出最新的 snapshot 版本，减轻冻结攻击。</td>
<td>Snapshot.json</td>
<td>服务端</td>
<td>自动化构建系统或服务器</td>
<td></td>
</tr>
</tbody>
</table>
<p><img src="https://my-pic.miaops.sbs/2025/04/20250413164128.png" alt="image.png" loading="lazy"></p>
<h3 id="定义数据格式与验证方式">定义数据格式与验证方式</h3>
<p><a href="https://theupdateframework.github.io/specification/v1.0.33/#file-formats-root" target="_blank" rel="noopener nofollow">参考网址：TUF规范</a><br>
数字签名概念，为什么不依赖信道安全和第三方背书。</p>
<p><img src="https://my-pic.miaops.sbs/2025/04/20250413164118.png" alt="image.png" loading="lazy"></p>
<h2 id="威胁模型">威胁模型</h2>
<ul>
<li>恶意更新，混合匹配攻击：阈值签名，哈希校验</li>
<li>回滚攻击：json文件版本号，snapshot版本号</li>
<li>冻结攻击：timestamp快速过期</li>
<li>密钥泄漏：
<ul>
<li>Timestamp泄漏造成冻结攻击</li>
<li>Release，Target或Release+Target单独泄漏不造成危险</li>
<li>Timestamp+Snapshot造成冻结攻击和Mix-Match</li>
<li>Timestamp+Snapshot+Target全部泄漏或者Root泄漏，系统危险</li>
<li>Root密钥泄漏个数少于<code>Threshold</code>时，不会使系统完全失信</li>
</ul>
</li>
</ul>
<p><img src="https://my-pic.miaops.sbs/2025/04/20250413202405.png" alt="image.png" loading="lazy"></p>
<h2 id="系统架构与工作流">系统架构与工作流</h2>
<h3 id="系统架构与初始化流程">系统架构与初始化流程</h3>
<p>首次信任配置，公钥注册。</p>
<p><img src="https://my-pic.miaops.sbs/2025/06/20250609144839.png" alt="image.png" loading="lazy"></p>
<p><img src="https://my-pic.miaops.sbs/2025/04/20250414101743.png" alt="image.png" loading="lazy"></p>
<h3 id="元数据更新流程">元数据更新流程</h3>
<h4 id="更新rootjson密钥轮转与撤销">更新Root.json（密钥轮转与撤销）</h4>
<ol>
<li>令<code>N</code>表示当前可信根元数据文件的版本号。</li>
<li>尝试下载Root.json的<code>N+1</code>版本，最多X字节</li>
<li><strong>检查是否存在恶意软件攻击</strong>：
<ol>
<li>需要超过<code>Threshold</code>个版本<code>N</code>的Root.json签名验证通过（垂直验证）</li>
<li>需要超过<code>Threshold</code>个版本<code>N+1</code>的Root.json签名验证通过（水平验证）</li>
</ol>
</li>
<li><strong>检查是否存在回滚攻击</strong>：
<ol>
<li>新Root.json版本号 = 旧Root.json版本号 + 1</li>
</ol>
</li>
<li><strong>检查是否存在冻结攻击</strong>：中间Root.json过期没有关系</li>
<li>持久化Root.json</li>
<li>重复2～9步</li>
<li><strong>检查是否存在冻结攻击</strong>：最终的Root.json文件过期时间戳未到，且高于固定更新时间</li>
<li>持久化最新Root.json</li>
</ol>
<blockquote>
<p>Root.json更新需要逐级建立信任链，也就是从版本1，逐级更新到版本N，中间不能跳跃。</p>
</blockquote>
<h4 id="更新timestampjson">更新Timestamp.json</h4>
<ol>
<li>下载Timestamp.json，最多X字节</li>
<li><strong>检查是否存在恶意软件攻击</strong>：用Root.json记录的公钥验证Timestamp.json签名，需要超过<code>Threshold</code>个签名验证通过</li>
<li><strong>检查是否存在回滚攻击</strong>：
<ol>
<li>新Timestamp.json版本号 &gt; 旧Timestamp.json版本号</li>
<li>新Timestamp.json中记录的Snapshot.json版本号 &gt;= 旧Timestamp.json中记录的Snapshot.json版本号</li>
</ol>
</li>
<li><strong>检查是否存在冻结攻击</strong>：新TimeStamp.json文件过期时间戳未到，且高于固定更新时间</li>
<li>持久化Timestamp.json</li>
</ol>
<h4 id="更新snapshotjson">更新Snapshot.json</h4>
<ol>
<li>下载Snapshot.json，最多X字节</li>
<li><strong>防止中间人攻击者的混合搭配攻击</strong>：校验新Snapshot.json的哈希值是否与Timestamp.json记录的哈希值一致</li>
<li><strong>检查是否存在恶意软件攻击</strong>：用Root.json记录的公钥验证Snapshot.json签名，需要超过<code>Threshold</code>个签名验证通过</li>
<li><strong>检查是否存在回滚攻击</strong>：
<ol>
<li>新Snapshot.json版本号 = 最新的Timestamp.json中记录的Snapshot.json版本号</li>
<li>新Snapshot.json中记录的Target.json版本号 &gt;= 旧Snapshot.json中记录的Target.json版本号</li>
</ol>
</li>
<li><strong>检查是否存在冻结攻击</strong>：新Snapshot.json文件过期时间戳未到，且高于固定更新时间</li>
<li>持久化Snapshot.json</li>
</ol>
<h4 id="更新targetjson">更新Target.json</h4>
<ol>
<li>下载Target.json，最多X字节</li>
<li><strong>防止中间人攻击者的混合搭配攻击</strong>：校验新Target.json的哈希值是否与Snapshot.json记录的哈希值一致</li>
<li><strong>检查是否存在恶意软件攻击</strong>：用Root.json记录的公钥验证Target.json签名，需要超过<code>Threshold</code>个签名验证通过</li>
<li><strong>检查是否存在回滚攻击</strong>：
<ol>
<li>新Target.json版本号 = 最新的Snapshot.json中记录的Target.json版本号</li>
</ol>
</li>
<li><strong>检查是否存在冻结攻击</strong>：新Target.json文件过期时间戳未到，且高于固定更新时间</li>
<li>持久化Target.json</li>
</ol>
<h2 id="部署模型">部署模型</h2>
<h3 id="delegation与路径划分">Delegation与路径划分</h3>
<p>在实际生产项目中，镜像往往不是直接挂在顶层的Target.json下，而是创建多个Delegation角色，每个 Delegation 角色（如 targets/releases、targets/dev-team-a）都可以指定它负责的 <strong>路径前缀</strong>（path pattern），用于匹配特定的镜像名或 target 路径。</p>
<pre><code class="language-txt">projects/
├── notary
├── docker
internal/
├── monitor
├── backup
</code></pre>
<table>
<thead>
<tr>
<th><strong>角色</strong></th>
<th><strong>负责路径（path pattern）</strong></th>
<th><strong>所属团队</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>targets/releases</td>
<td>projects/notary/, projects/docker/</td>
<td>官方发布</td>
</tr>
<tr>
<td>targets/notary</td>
<td>projects/notary/dev/*</td>
<td>团队 A 维护</td>
</tr>
<tr>
<td>targets/docker</td>
<td>projects/docker/dev/*</td>
<td>团队 B 维护</td>
</tr>
<tr>
<td>targets/internal</td>
<td>internal/*</td>
<td>内部维护者专属</td>
</tr>
</tbody>
</table>
<h3 id="存在的问题">存在的问题</h3>
<p><img src="https://my-pic.miaops.sbs/2025/04/20250413212143.png" alt="image.png" loading="lazy"></p>
<ul>
<li>委托顺序问题：当多个角色关联到相同文件时，存在歧义<br>
=&gt; 区分优先级：Target.json中的委托声明顺序作为优先级</li>
<li>故障转移问题：无法做到<code>bar-*</code>都通过B角色校验，其他通过C角色校验<br>
=&gt; 引入Terminating标记：比如标记B为Terminating，那么在B所关联的文件中没有找到<code>bar-*</code>文件的话，则也不会在其他角色下搜索相关文件。</li>
</ul>
<h3 id="最大安全模型和传统安全模型">最大安全模型和传统安全模型</h3>
<h4 id="基本描述">基本描述</h4>
<table>
<thead>
<tr>
<th><strong>安全模型</strong></th>
<th><strong>简要描述</strong></th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Maximum Security Model (MSM)</strong></td>
<td>精细化的委托，只有Timestmap Key保存在服务器，其余密钥都离线保存</td>
<td>安全性高，不易部署</td>
</tr>
<tr>
<td><strong>Legacy Security Model (LSM)</strong></td>
<td>部分签名操作由服务器完成，密钥（如 Snapshot、Timestamp）都保存在服务器上</td>
<td>安全性一般，容易部署</td>
</tr>
</tbody>
</table>
<h4 id="project类型">Project类型</h4>
<p>MSM和LSM把各个软件包根据签名与否，划分为如下集合，称为Project：</p>
<table>
<thead>
<tr>
<th><strong>项目类型</strong></th>
<th><strong>定义与特点</strong></th>
<th>密钥类型</th>
<th>签名人</th>
<th>所属模型</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Claimed Project</strong></td>
<td>由开发者认领并签名</td>
<td>离线</td>
<td>开发者</td>
<td>Both</td>
</tr>
<tr>
<td><strong>New Project</strong></td>
<td>刚发布，开发者未注册签名 key</td>
<td>在线</td>
<td>无</td>
<td>Both</td>
</tr>
<tr>
<td><strong>Rarely Updated Project</strong></td>
<td>长期无更新但仍需信任</td>
<td>离线</td>
<td>管理员</td>
<td>MSM</td>
</tr>
<tr>
<td><strong>Unclaimed Project</strong></td>
<td>没有绑定具体维护者，未进行“认领”</td>
<td>在线</td>
<td>无</td>
<td>LSM</td>
</tr>
</tbody>
</table>
<h4 id="软件包生命周期">软件包生命周期</h4>
<p>新镜像</p>
<ul>
<li>刚创建：New Project</li>
<li>开发者进行签名：转移到Claimed Project
<ul>
<li>长久未更新：转移到Rarely Update Project</li>
</ul>
</li>
<li>开发者没有进行签名：转移到Unclaimed Project<br>
原有镜像：</li>
<li>未签名：转移到Unclaimed Project
<ul>
<li>管理员代签：转移到Rarely Project</li>
</ul>
</li>
<li>已签名：转移到Claimed Projet</li>
</ul>
<img src="https://my-pic.miaops.sbs/2025/04/20250413222754.png" width="80%">
<h4 id="lsm转换为msm">LSM转换为MSM</h4>
<p><img src="https://my-pic.miaops.sbs/2025/04/20250413203143.png" alt="image.png" loading="lazy"></p>
<ul>
<li>从上往下：角色优先级递减</li>
<li>LSM -&gt; MSM：Unclaimed Project -&gt; Rarely Update Project</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://theupdateframework.github.io/specification/v1.0.33/" target="_blank" rel="noopener nofollow">TUF规范</a></li>
<li>TUF论文：
<ul>
<li>原理：Survivable Key Compromise in Software Update Systems</li>
<li>实际部署：Diplomat: Using Delegations to Protect Community Repositories</li>
</ul>
</li>
<li><a href="https://github.com/notaryproject/notary/blob/9d2b3b35929392c9945d976b8bdecbe2f53a299e/docs/service_architecture.md" target="_blank" rel="noopener nofollow">Notary文档</a></li>
<li><a href="https://docs.docker.com/engine/security/trust/?utm_source=chatgpt.com" target="_blank" rel="noopener nofollow">DCT文档</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0020833333333333333" data-date-updated="2025-06-09 16:40">2025-06-09 16:37</span>&nbsp;
<a href="https://www.cnblogs.com/timothy020">Miaops</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18920941);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18920941', targetLink: 'https://www.cnblogs.com/timothy020/p/18920941', title: 'TUF系统概述' })">举报</a>
</div>
        