
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/XY-Heruo/p/18698255" title="发布于 2025-02-04 15:52">
    <span role="heading" aria-level="2">[python]png转webp的命令行工具</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        用python的pillow库写一个命令行工具，实现批量转换png格式的图片为webp格式
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>网页上使用webp格式的图片更加省网络流量和存储空间，但本地图片一般是png格式的，所以考虑用python的pillow库将png格式的图片转换为webp格式。</p>
<p>需求：</p>
<ul>
<li>可以在系统任意地方调用。这需要编译成二进制程序或写成脚本放到PATH环境变量下</li>
<li>支持指定图片文件输入目录。默认为当前目录。</li>
<li>支持指定图片文件输出目录。默认为输入文件的同级目录。</li>
<li>支持指定图片压缩质量。默认为80。需要校验传参。</li>
<li>支持并发同时压缩多个图片文件。默认为串行。传参的并发数最大为CPU核心数。</li>
</ul>
<h2 id="代码">代码</h2>
<pre><code class="language-python">from PIL import Image
import argparse
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor
import os
from time import time


def parse_args():
    """解析命令行参数"""
    parser = argparse.ArgumentParser(description="Convert PNG to WEBP", 
        usage="""
        # 直接执行, 默认转换当前目录下的所有png文件到同级目录
        python main.py

        # 将转换后的webp文件保存到output目录下
        python main.py -o output

        # 转换单个png文件, 单独转换时不支持指定输出目录
        python main.py -f 1.png

        # 同时转换, -t 指定最大并发数, 默认为1, 最大不得超过CPU核心数
        python main.py -t 2

        # 指定图片压缩质量, 默认为80, 取值区间为[0, 100], 值越高, 质量越好, 生成图片体积越大
        python main.py -q 75
        """)
    parser.add_argument(
        "-i", type=str, default=os.getcwd(), help="Path to the input PNG image"
    )
    parser.add_argument(
        "-o", type=str, default=os.getcwd(), help="Path to the output WEBP image"
    )
    parser.add_argument("-f", type=str, default="", help="specific file name")
    parser.add_argument("-t", type=int, default=1, help="Number of threads to use")
    parser.add_argument(
        "-q", type=int, default=80, help="Quality of the output WEBP image"
    )
    return parser.parse_args()


def convert_png_to_webp(input_path: Path, output_path: Path, quality=80) -&gt; None:
    """
    转换PNG为WEBP

    Args:
        input_path (Path): 输入文件路径
        output_path (Path): 输出文件路径, 可以是一个目录, 也可以是一个webp文件的路径
        quality (int, optional): 图片压缩质量. 默认为 80.
    """
    # 如果quality不在0到100之间, 则设置为80
    if quality &gt; 100 or quality &lt; 0:
        print("quality must be between 0 and 100, now set to 80")
    real_q = quality if quality &lt;= 100 and quality &gt; 0 else 80

    # 如果输入文件不存在, 则打印错误信息并返回
    if not input_path.exists():
        print(f"input file {input_path} not found")
        return

    # 如果指定了输出目录, 则尝试创建输出目录
    if not output_path.exists() and output_path.suffix.lower() != ".webp":
        try:
            output_path.mkdir(parents=True)
        except Exception as e:
            print(e)
            print("Failed to create output directory")
            return

    # 如果指定了输出目录, 则修改输出文件名为为输入文件名, 并修改扩展名为.webp
    if output_path.suffix.lower() != ".webp":
        output_path = output_path / input_path.with_suffix(".webp").name
    start = time()
    try:
        with Image.open(input_path) as img:
            print(
                f"Converting {input_path}, quality={real_q}, size: {input_path.stat().st_size / 1024:.2f}KB"
            )
            img.save(output_path, "WEBP", quality=real_q)
            print(
                f"Convert png2webp successfully, output file: {output_path.name}, size: {int(output_path.stat().st_size) / 1024:.2f}KB, elapsed time: {time() - start:.2f}s"
            )
    except Exception as e:
        print(f"Convert png2webp failed: {e}")


def multi_thread_convert(max_workers: int, input_path, output_path, quality) -&gt; None:
    """并发转换png为webp"""
    print(f"convert png to webp with multi threads, max_workers: {max_workers}")
    p = Path(input_path)
    op = Path(output_path) if output_path != os.getcwd() else None
    max_workers = max_workers if max_workers &lt; os.cpu_count() else os.cpu_count()
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        for f in p.glob("**/*.png"):
            executor.submit(
                convert_png_to_webp, f, op or f.with_suffix(".webp"), quality
            )


def main():
    start = time()
    args = parse_args()
    if not args.f:
        if args.t &gt; 1:
            multi_thread_convert(args.t, args.i, args.o, args.q)
        else:
            p = Path(args.i)
            op = Path(args.o) if args.o != os.getcwd() else None
            for f in p.glob("**/*.png"):
                convert_png_to_webp(f, op or f.with_suffix(".webp"), args.q)
    else:
        p = Path(args.f)
        convert_png_to_webp(p, p.with_suffix(".webp"), args.q)
    print(f"Finished! Total elapsed time: {time() - start:.2f}s")


if __name__ == "__main__":
    main()
</code></pre>
<h2 id="编译">编译</h2>
<p>因为是在python虚拟环境中安装的pillow，如果要在其它位置调用这个脚本，个人想了两种方式：</p>
<ol>
<li>另外编写一个shell脚本，如果是windows，则编写powershell脚本，在这个脚本内编写调用逻辑，并把这个脚本放到<code>PATH</code>环境变量的路径下。</li>
<li>编译成二进制文件，将编译好的二进制文件放到<code>PATH</code>环境变量下。这比较方便发送给别人，这样别人就不需要在电脑上安装python环境。</li>
</ol>
<p>这里用<code>pyinstaller</code>将程序编译成二进制文件，尽量在python虚拟环境下编译，以减小二进制文件的体积</p>
<ol>
<li>创建虚拟环境</li>
</ol>
<pre><code class="language-python">python -m venv png2webp
</code></pre>
<ol start="2">
<li>激活虚拟环境</li>
</ol>
<pre><code class="language-bash"># linux
cd png2webp
source ./bin/activate

# windows powershell
cd png2webp
.\Scripts\activate
</code></pre>
<ol start="3">
<li>安装依赖</li>
</ol>
<pre><code class="language-bash">python -m pip install pillow pyinstaller
</code></pre>
<ol start="4">
<li>编译。注意修改实际的python文件路径。</li>
</ol>
<pre><code class="language-bash">pyinstaller -F --clean .\main.py
</code></pre>
<ol start="5">
<li>生成的二进制文件在当前目录下的<code>dist</code>目录，将其放置到<code>PATH</code>环境变量下，如有需要可重命名。</li>
<li>测试在其他目录下调用</li>
</ol>
<pre><code class="language-bash">png2webp --help
</code></pre>
<h2 id="使用">使用</h2>
<pre><code class="language-bash"># 直接执行, 默认转换当前目录下的所有png文件到同级目录
png2webp

# 将转换后的webp文件保存到output目录下
png2webp -o output

# 转换单个png文件, 单独转换时不支持指定输出目录
png2webp -f 1.png

# 同时转换, -t 指定最大并发数, 默认为1, 最大不得超过CPU核心数
png2webp -t 2

# 指定图片压缩质量, 默认为80, 取值区间为[0, 100], 值越高, 质量越好, 生成图片体积越大
png2webp -q 75
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/XY-Heruo/" target="_blank">花酒锄作田</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/XY-Heruo/p/18698255" target="_blank">https://www.cnblogs.com/XY-Heruo/p/18698255</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.1011630243900463" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-04 15:52">2025-02-04 15:52</span>&nbsp;
<a href="https://www.cnblogs.com/XY-Heruo">花酒锄作田</a>&nbsp;
阅读(<span id="post_view_count">117</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18698255" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18698255);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18698255', targetLink: 'https://www.cnblogs.com/XY-Heruo/p/18698255', title: '[python]png转webp的命令行工具' })">举报</a>
</div>
        