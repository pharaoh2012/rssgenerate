<!----> <meta itemprop="headline" content="前端权限系统怎么做才不会写吐？我们项目踩过的 3 套失败方案总结"> <meta itemprop="keywords" content="前端,JavaScript,Vue.js"> <meta itemprop="datePublished" content="2025-06-21T08:49:47.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ErpanOmer"> <meta itemprop="url" content="https://juejin.cn/user/3878732754331096"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端权限系统怎么做才不会写吐？我们项目踩过的 3 套失败方案总结
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3878732754331096/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ErpanOmer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-06-21T08:49:47.000Z" title="Sat Jun 21 2025 08:49:47 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-06-21
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    8,416
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><p>上线前两个月，我们的权限系统崩了三次。</p>
<p>不是接口没权限，而是：</p>
<ul>
<li>页面展示和真实权限不一致；</li>
<li>权限判断写得四分五裂；</li>
<li>权限数据和按钮逻辑耦合得死死的，测试一改就炸。</li>
</ul>
<p>于是，我们老老实实把整个权限体系拆了重构，从接口到路由、到组件、到 v-permission 指令，走了一遍完整的流程。</p>
<p>结果：<strong>代码可维护，调试容易，后端调整也能快速兜底。</strong></p>
<p>这篇文章不讲理论，<strong>只还原我们项目真踩过的 3 套失败方案和最终落地方案。</strong></p>
<hr>
<h3 data-id="heading-0">❌ 第一套：按钮级权限直接写死在模板里</h3>
<p>当时我们的写法是这样的：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 用户管理页 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"authList.includes('user:add')"</span>&gt;</span>添加用户<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>
</code></pre>
<p>接口返回的是一个权限数组：</p>
<pre><code class="hljs language-ts" lang="ts">[<span class="hljs-string">"user:add"</span>, <span class="hljs-string">"user:delete"</span>, <span class="hljs-string">"user:list"</span>]
</code></pre>
<p>然后整个项目几十个地方都这么判断。</p>
<p>结果：</p>
<ul>
<li>不能重用，每个组件都判断一次；</li>
<li>权限粒度变更就全崩，比如从 <code>user:add</code> 改成 <code>user:add_user</code>；</li>
<li>后端权限更新后，前端要全局搜索权限 key 改代码；</li>
</ul>
<p><strong>典型的“写起来爽，维护时哭”方案。</strong></p>
<hr>
<h3 data-id="heading-1">❌ 第二套：用 router.meta.permission 统一控制，结果太抽象</h3>
<p>重构后我们尝试统一控制页面级权限：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// router.ts</span>
{
  <span class="hljs-attr">path</span>: <span class="hljs-string">'/user'</span>,
  <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>,
  <span class="hljs-attr">meta</span>: {
    <span class="hljs-attr">permission</span>: <span class="hljs-string">'user:list'</span>
  }
}
</code></pre>
<p>再通过导航守卫：</p>
<pre><code class="hljs language-ts" lang="ts">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> p = to.<span class="hljs-property">meta</span>.<span class="hljs-property">permission</span>
  <span class="hljs-keyword">if</span> (p &amp;&amp; !authList.<span class="hljs-title function_">includes</span>(p)) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(<span class="hljs-string">'/403'</span>)
  }
  <span class="hljs-title function_">next</span>()
})
</code></pre>
<p>这个方案页面级权限是解决了，但<strong>组件级 / 按钮级 / 表单字段级</strong>全都失效了。</p>
<p>而且你会发现，大量页面是“同路由但不同内容区域权限不同”，导致这种 <code>meta.permission</code> 方案显得太粗暴。</p>
<hr>
<h3 data-id="heading-2">❌ 第三套：封装权限组件，结果被吐槽“反人类”</h3>
<p>当时我们团队有人设计了一个组件：</p>
<pre><code class="hljs language-ts" lang="ts">&lt;<span class="hljs-title class_">Permission</span> code=<span class="hljs-string">"user:add"</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span>&gt;</span>添加用户<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span>
&lt;/<span class="hljs-title class_">Permission</span>&gt;
</code></pre>
<p>这个组件内部逻辑是：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> slots = <span class="hljs-title function_">useSlots</span>()
<span class="hljs-keyword">if</span> (!authList.<span class="hljs-title function_">includes</span>(props.<span class="hljs-property">code</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
<span class="hljs-keyword">return</span> slots.<span class="hljs-title function_">default</span>()
</code></pre>
<p>结果：</p>
<ul>
<li>逻辑上看似没问题，但使用非常反直觉；</li>
<li>特别是嵌套多个组件时，调试麻烦，断点打不进真实组件；</li>
<li>TypeScript 报类型错误，编辑器无法识别 slot 类型；</li>
<li>更麻烦的是，权限失效的时候，组件不会渲染，开发环境都看不到是为什么！</li>
</ul>
<hr>
<h3 data-id="heading-3">最终方案：hook + 指令 + 路由统一层级设计</h3>
<p>我们最后把权限体系重构为 3 层：</p>
<h4 data-id="heading-4">🔹1. 接口统一管理权限 key → 后端返回精简列表（扁平权限）</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">AuthCode</span> =
  | <span class="hljs-string">'user:add'</span>
  | <span class="hljs-string">'user:delete'</span>
  | <span class="hljs-string">'user:edit'</span>
  | <span class="hljs-string">'order:export'</span>
  | <span class="hljs-string">'dashboard:view'</span>
</code></pre>
<p>服务端返回用户权限集，保存在 <code>authStore</code>（Pinia / Vuex / Context）中。</p>
<hr>
<h4 data-id="heading-5">🔹2. 统一 Hook 调用：<code>usePermission(code)</code></h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { useAuthStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/store/auth'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">usePermission</span>(<span class="hljs-params">code: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> {
  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useAuthStore</span>()
  <span class="hljs-keyword">return</span> store.<span class="hljs-property">permissionList</span>.<span class="hljs-title function_">includes</span>(code)
}
</code></pre>
<p>用法：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"usePermission('user:add')"</span>&gt;</span>添加用户<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>
</code></pre>
<p>这才是真正组件内部逻辑干净、容易复用、TS 支持的方案。</p>
<hr>
<h4 data-id="heading-6">🔹3. 封装一个 v-permission 指令（可选）</h4>
<pre><code class="hljs language-ts" lang="ts">app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">'permission'</span>, {
  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding</span>) {
    <span class="hljs-keyword">const</span> authList = <span class="hljs-title function_">getUserPermissions</span>() <span class="hljs-comment">// 从全局 store 获取</span>
    <span class="hljs-keyword">if</span> (!authList.<span class="hljs-title function_">includes</span>(binding.<span class="hljs-property">value</span>)) {
      el.<span class="hljs-title function_">remove</span>()
    }
  }
})
</code></pre>
<p>模板中使用：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">v-permission</span>=<span class="hljs-string">"'order:export'"</span>&gt;</span>导出订单<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>
</code></pre>
<p>适合动态组件、render 生成的按钮，<strong>不适合复杂嵌套逻辑</strong>，但实际项目中效果拔群。</p>
<hr>
<h3 data-id="heading-7">🧪 页面级权限怎么做？</h3>
<p>不再用 <code>router.meta</code>，而是把每个路由页封装为权限包裹组件：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">PermissionView</span> <span class="hljs-attr">code</span>=<span class="hljs-string">"dashboard:view"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Dashboard</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">PermissionView</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p>权限组件内部处理：</p>
<ul>
<li>没权限 → 自动跳转 403</li>
<li>有权限 → 渲染内容</li>
</ul>
<p>这样即使权限接口变了，组件逻辑也统一保留，<strong>避免页面空白或者闪跳</strong>。</p>
<hr>
<h3 data-id="heading-8">权限这事，不是实现难，而是维护难。</h3>
<p><strong>最核心的不是你怎么控制显示，而是权限 key 的一致性、复用性、分层能力。</strong></p>
<p>最终我们稳定版本满足了：</p>
<ul>
<li>页面、按钮、字段统一接入权限</li>
<li>新增权限点只需要改枚举，不需要大改</li>
<li>新人接手也能一眼看懂逻辑，能调试</li>
</ul>
<h3 data-id="heading-9">📌 你可以继续看我的系列文章</h3>
<ul>
<li><a href="https://juejin.cn/post/7514947261396205587" target="_blank" title="https://juejin.cn/post/7514947261396205587">《用了三年 Vue，我终于理解为什么“组件设计”才是重灾区》</a></li>
<li><a href="https://juejin.cn/post/7513863217271406601" target="_blank" title="https://juejin.cn/post/7513863217271406601">《我为什么觉得 React 正在逐渐失去吸引力？》</a></li>
<li><a href="https://juejin.cn/post/7512392168783659071" target="_blank" title="https://juejin.cn/post/7512392168783659071">《为什么越来越多 Vue 项目用起了 UnoCSS？》</a></li>
<li><a href="https://juejin.cn/post/7511983823258468391" target="_blank" title="https://juejin.cn/post/7511983823258468391">《为什么我放弃使用 Pinia？》</a></li>
<li><a href="https://juejin.cn/post/7511602231508664361" target="_blank" title="https://juejin.cn/post/7511602231508664361">《为什么我不再相信 Tailwind？三个月重构项目教会我的事》</a></li>
</ul></div></div>