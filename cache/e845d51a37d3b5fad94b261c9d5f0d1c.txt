
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TianTianChaoFangDe/p/18869039" title="发布于 2025-05-10 00:00">
    <span role="heading" aria-level="2">【杭电多校比赛记录】2025“钉耙编程”中国大学生算法设计春季联赛（9）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><a href="https://acm.hdu.edu.cn/contest/problems?cid=1158" title="比赛链接" target="_blank" rel="noopener nofollow">比赛链接</a><br>
本文发布于博客园，会跟随补题进度实时更新，若您在其他平台阅读到此文，请前往<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18869039" title="博客园" target="_blank">博客园</a>获取更好的阅读体验。<br>
跳转链接：<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18869039" target="_blank">https://www.cnblogs.com/TianTianChaoFangDe/p/18869039</a></p>
<h2 id="开题--补题情况">开题 + 补题情况</h2>
<p>最近一直在准备期中考试，好久没写代码了，这场有点糖，前一个小时一题没开，实属红温，尤其是 1007，想了好久好久。<br>
下周打南昌，自己第一次参加全国性的比赛，希望自己加油发挥吧！<br>
<img src="https://img2024.cnblogs.com/blog/3572902/202505/3572902-20250509232805394-245532808.png" alt="image" loading="lazy"></p>
<h2 id="1010---绳子切割">1010 - 绳子切割</h2>
<p>此题考查并查集（实际暴力也可以）。<br>
我们删点是从大到小删，那么倒过来就是加点，加点就是从小到大加。<br>
对于每一个点，连向比它小的结点的连通块，看是否能和 <span class="math inline">\(0\)</span> 在同一块，如果不在，那么直接输出 <span class="math inline">\(0\)</span>，因为这个时候，它不和横梁同属一个连通块，说明它到 <span class="math inline">\(0\)</span> 之间有点被删除了，进而导致该点被提前删除了。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf32 1e9
#define inf64 2e18
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

const int N = 2e5 + 9;

struct DSU {
    std::vector&lt;int&gt; fa;

    DSU(int n) {
        fa.resize(n + 1);
        std::iota(fa.begin(), fa.end(), 0);
    }

    int root(int x) {
        return (fa[x] == x) ? x : (fa[x] = root(fa[x]));
    }

    void merge(int u, int v) {
        if(root(u) == 0) {
            fa[root(v)] = root(fa[u]);
        } else {
            fa[root(u)] = root(fa[v]);
        }
    }
};

void solve()
{
    int n, m;std::cin &gt;&gt; n &gt;&gt; m;
    DSU dsu(n);

    std::vector&lt;std::vector&lt;int&gt;&gt; g(n + 1);

    for(int i = 1;i &lt;= m;i ++) {
        int u, v;std::cin &gt;&gt; u &gt;&gt; v;

        g[u].push_back(v);
        g[v].push_back(u);
    }

    for(int i = 1;i &lt;= n;i ++) {
        for(auto &amp;x : g[i]) {
            if(i &lt; x)continue;
            dsu.merge(i, x);
        }

        if(dsu.root(i) != 0) {
            std::cout &lt;&lt; 0 &lt;&lt; '\n';
            return;
        }
    }

    std::cout &lt;&lt; 1 &lt;&lt; '\n';
}

int main()
{
    std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);

    int t = 1;std::cin &gt;&gt; t;
    while(t --)solve();

    return 0;
}
</code></pre>
</details>
<h2 id="1004---储值购物">1004 - 储值购物</h2>
<p>这个题，先上结论，每次取 <span class="math inline">\(W / 2 + 1\)</span>，一定最优。<br>
简单证明如下：<br>
若某次取了 <span class="math inline">\(\leq W / 2\)</span>，那么这次剩下的，一定 <span class="math inline">\(\geq W / 2\)</span>，那么，当下次取 <span class="math inline">\(W / 2\)</span> 的时候，会继续使用当前这个卡，若取更多，则可以均摊给上次取的，这样的话最后二者都会取到 <span class="math inline">\(W / 2 + 1\)</span>。<br>
因此，每次取 <span class="math inline">\(W / 2 + 1\)</span>，当取不够了的时候，判断是新加一张卡还是使用现有的。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf32 1e9
#define inf64 2e18
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

const int N = 2e5 + 9;

template&lt;typename T&gt;
T up(T x, T y) {
    return (x + y - 1) / y;
}

void solve()
{
    int v, w;std::cin &gt;&gt; v &gt;&gt; w;
    int h = w / 2 + 1;
    int l = w - h;

    int sum = v / h;
    v -= sum * h;

    int ans = 0;
    if(sum) {
        if(v &gt; l)ans = sum + 1;
        else ans = sum;
    } else {
        ans = 1;
    }

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}

int main()
{
    std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);

    int t = 1;std::cin &gt;&gt; t;
    while(t --)solve();

    return 0;
}

</code></pre>
</details>
<h2 id="1005---真爱口上">1005 - 真爱口上</h2>
<p>这个题看似是一个非常恶心的模拟题，但是题目有一个很重要的信息：所有的字符串都是符合规则的音节序列。也就意味着我们不需要判断串的合法性，只需要根据特征计数就行了。</p>
<ul>
<li>基本音节结构：不难发现，一定是以元音结尾，因此只需要计算元音有多少个即可。</li>
<li>鼻音：单算 <code>nn</code> 相连的情况，特别注意比如 <code>nnna</code> 的情况，此时不能算为两个鼻音。</li>
<li>促音：计算 <code>pp</code> <code>tt</code> <code>kk</code> <code>ss</code> 的数量即可。</li>
</ul>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf32 1e9
#define inf64 2e18
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

const int N = 2e5 + 9;

bool isyun(char c) {
    return c == 'a' || c == 'i' || c == 'u' || c == 'e' || c == 'o';
}

bool isptks(char c) {
    return c == 'p' || c == 't' || c == 'k' || c == 's';
}

int getans(std::string &amp;s) {
    int n = s.size();

    int res = 0;
    int pre = -1;
    for(int i = 0;i &lt; n;i ++) {
        if(isyun(s[i])) {
            res ++;
        }

        if(isptks(s[i])) {
            if(i - 1 &gt;= 0 &amp;&amp; s[i - 1] == s[i]) {
                res ++;
            }
        }

        if(s[i] == 'n') {
            if(i - 1 &gt;= 0 &amp;&amp; s[i - 1] == s[i] &amp;&amp; pre != i - 1) {
                res ++;
                pre = i;
            }
        }
    }

    return res;
}

void solve()
{
    std::string s, t;std::cin &gt;&gt; s &gt;&gt; t;

    std::cout &lt;&lt; getans(s) &lt;&lt; ' ' &lt;&lt; getans(t) &lt;&lt; '\n';
}

int main()
{
    std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);

    int t = 1;std::cin &gt;&gt; t;
    while(t --)solve();

    return 0;
}
</code></pre>
</details>
<h2 id="1007---扑克洗牌">1007 - 扑克洗牌</h2>
<p>你没有看错，这是我过的……第五个题……<br>
真的红温了，这题一直没想到思路，但是过的人又那么多，后面猛地想到了。</p>
<p>首先要明晰一件事，对于移动了的牌，它一定是移动且仅移动一次！<br>
为什么？<br>
因为我们可以把它插入任何位置，那么我们就可以直接把它插入到应该处在的位置，并且不要去动它。<br>
然后呢，我们就要考虑，对于目标序列，我们要如何移动得到。<br>
对于原串，所有数字都是连续的，相邻的。<br>
对于移动，是只能从两头进行移动的。<br>
那么就可以得出以下结论：我们最终的目标串，一定是原串某个连续子串，插入两边的扑克牌得到的。<br>
对于原串中的这个子串，它是不需要移动的，因为它是被插入的对象。<br>
所以要让移动次数最小，那么就是要让选择的这个原串子串长度，尽可能的大。<br>
这个长度，我们用简单的 dp 可以很快计算出来。<br>
记 <span class="math inline">\(dp_i\)</span> 为以数字 <span class="math inline">\(i\)</span> 结尾的最长连续子序列的长度。<br>
那么有以下转移：</p>
<ul>
<li>当 <span class="math inline">\(i - 1\)</span> 没有出现过时，<span class="math inline">\(dp_i = 1\)</span>。</li>
<li>当 <span class="math inline">\(i - 1\)</span> 出现过时，<span class="math inline">\(dp_i = dp_{i - 1} + 1\)</span>。</li>
</ul>
<p>对每个 <span class="math inline">\(dp_i\)</span> 执行 <span class="math inline">\(n - dp_i\)</span>，对所有答案取最小值即可。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf32 1e9
#define inf64 2e18
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

const int N = 2e5 + 9;

void solve()
{
    int n;std::cin &gt;&gt; n;

    std::vector&lt;int&gt; a(n + 1);
    std::vector&lt;int&gt; vis(n + 1);
    std::vector&lt;int&gt; dp(n + 1);

    for(int i = 1;i &lt;= n;i ++) {
        std::cin &gt;&gt; a[i];
    }

    vis[0] = true;
    for(int i = 1;i &lt;= n;i ++) {
        if(vis[a[i] - 1]) {
            dp[a[i]] = dp[a[i] - 1] + 1;
        } else {
            dp[a[i]] = 1;
        }

        vis[a[i]] = true;
    }

    int ans = inf32;
    for(int i = 1;i &lt;= n;i ++) {
        ans = std::min(ans, n - dp[i]);
    }

    std::cout &lt;&lt; ans &lt;&lt; '\n';
} 

int main()
{
    std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);

    int t = 1;std::cin &gt;&gt; t;
    while(t --)solve();

    return 0;
}
</code></pre>
</details>
<h2 id="1002---折线绘制">1002 - 折线绘制</h2>
<p>马拉车算法板子题，只不过从回文关系变成了中心对称关系。<br>
为了方便计数，可以插入无关数字 <span class="math inline">\(-1\)</span> 来把奇数长度区间和偶数长度区间的情况统一化。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf32 1e9
#define inf64 2e18
#define int long long
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

const int N = 2e5 + 9;

void solve()
{
    int n;std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(n);

    for(auto &amp;x : a) {
        std::cin &gt;&gt; x;
    }

    std::vector&lt;int&gt; b(2 * n + 1);

    int idx = 0;
    b[idx ++] = -1;
    for(auto &amp;x : a) {
        b[idx ++] = x;
        b[idx ++] = -1;
    }

    n = (int)b.size();

    std::vector&lt;int&gt; d(n);

    auto check = [&amp;](int x, int y, int sum) -&gt; bool {
        if(x &lt; 0 || y &gt;= n) {
            return false;
        }

        if(b[x] == -1 &amp;&amp; b[y] == -1) {
            return true;
        }  

        if(b[x] + b[y] == sum) {
            return true;
        }

        return false;
    };

    int ans = 0;
    for(int i = 0, l = 0, r = -1;i &lt; n;i ++) {
        int k = ((i &gt; r) ? 1 : std::min(r - i + 1, d[l + r - i]));
        int now = -1;
        if(b[i] == -1 &amp;&amp; i - 1 &gt;= 0 &amp;&amp; i + 1 &lt; n) {
            now = b[i - 1] + b[i + 1];
        }

        if(b[i] != -1) {
            now = b[i] * 2;
        }

        while(check(i - k, i + k, now)) {
            k ++;
        }

        d[i] = k --;

        if(i + k &gt; r)l = i - k, r = i + k;

        if(b[i] == -1) {
            ans += k / 2;
        } else {
            ans += d[i] / 2;
        }
    }

    std::cout &lt;&lt; ans &lt;&lt; '\n';
}

signed main()
{
    std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);

    int t = 1;std::cin &gt;&gt; t;
    while(t --)solve();

    return 0;
}
</code></pre>
</details>

</div>
<div id="MySignature" role="contentinfo">
    <!-- 版权保护 -->
<div style="background:#ffcccc; color:#0; font-size:small;">
    <p>
            作者：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>
    </p>
    <p>
            出处：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">https://www.cnblogs.com/TianTianChaoFangDe</a>
    </p>
    <p>
            关于作者：ACMer，算法竞赛爱好者
    </p>
    <p>
             本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显醒目位置给出,
             <a href="#" onclick="Curgo()" style="background:#b6ff00; color:#0; font-size:medium;">原文链接</a>
             如有问题， 可邮件（1005333612@qq.com）咨询.
    </p>
    
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.014298037784722223" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-10 00:00">2025-05-10 00:00</span>&nbsp;
<a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18869039);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18869039', targetLink: 'https://www.cnblogs.com/TianTianChaoFangDe/p/18869039', title: '【杭电多校比赛记录】2025“钉耙编程”中国大学生算法设计春季联赛（9）' })">举报</a>
</div>
        