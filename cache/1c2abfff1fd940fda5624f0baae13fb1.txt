<!----> <meta itemprop="headline" content=" 耗时6个月做的可视化大屏编辑器, 开源!"> <meta itemprop="keywords" content="前端,JavaScript,GitHub"> <meta itemprop="datePublished" content="2024-12-23T01:57:30.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="徐小夕"> <meta itemprop="url" content="https://juejin.cn/user/3808363978429613"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-fcbde74a="">
             耗时6个月做的可视化大屏编辑器, 开源!
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-fcbde74a=""><div class="author-info-box" data-v-fcbde74a=""><div class="author-name" data-v-fcbde74a=""><a href="/user/3808363978429613/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-fcbde74a=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    徐小夕
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-fcbde74a=""><time datetime="2024-12-23T01:57:30.000Z" title="Mon Dec 23 2024 01:57:30 GMT+0000 (Coordinated Universal Time)" class="time" data-v-fcbde74a="">
                    2024-12-23
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-fcbde74a=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-fcbde74a=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-fcbde74a=""></circle></svg> <span class="views-count" data-v-fcbde74a="">
                    6,474
                  </span> <span class="read-time" data-v-fcbde74a=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-fcbde74a=""><rect width="16" height="16" fill="none" data-v-fcbde74a=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-fcbde74a=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-fcbde74a=""></path></svg>
                    阅读11分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-fcbde74a=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-fcbde74a=""><div class="article-viewer markdown-body result"><p>hi, 大家好, 我是徐小夕.&nbsp;</p>
<p>5年前就开始着手设计和研发可视化大屏编辑器, 当时低代码在国内还没有现在那么火, 有人欢喜有人哀, 那个时候我就比较坚定的认为<strong>无码化</strong>搭建未来一定是个趋势, 能极大的帮助企业提高研发效率和降低研发成本, 所以&nbsp;<strong>all in</strong>&nbsp;做了2年, 上线了一个相对闭环的MVP可视化大屏搭建平台——<strong>V6.Dooring.</strong></p>
<p><strong><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c741896230b1417593c32575171a6e7a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=AkG2PH%2FI11ynjJYe3nlUjgW3MWc%3D" alt="图片" loading="lazy"></strong></p>
<p>通过在技术社区不断的分享可视化搭建的技术实践和设计思路, 也参与了很多线上线下的技术分享, 慢慢市场终于“热了”起来.(机缘巧合)</p>
<p>从<strong>V6.Dooring</strong>的技术架构的设计, 到团队组建, 再到帮助企业做解决方案, 当时几乎所有的周末都花在这上面了, 想想收获还是挺大的, 接触到了形形色色的企业需求, 也不断完整着可视化大屏编辑器的功能, 最后推出了一个还算通用的解决方案:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f3fea5d7c32d463f98d5e52fcf3ee343~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=s3duxxusoJCw3anqnRampj60pFk%3D" alt="图片" loading="lazy"></p>
<p>当然上面介绍的还都不是这篇文章的重点.</p>
<p>重点是, 时隔4年, 我们打算把通用的可视化大屏解决方案, 开源!&nbsp;</p>
<p>一方面是供大家学习参考, 更好的解决企业自身的业务需求, 另一方面可以提供一个技术交流的平台, 大家可以对<strong>可视化搭建领域</strong>的技术实践, 提出自己的想法和观点, 共同打造智能化, 体验更好的搭建产品.</p>
<p>先上github地址:&nbsp;<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMrXujiang%2Fv6.dooring.public" target="_blank" title="https://github.com/MrXujiang/v6.dooring.public" ref="nofollow noopener noreferrer">github.com/MrXujiang/v…</a></strong></p>
<p>V6.Dooring开源大屏编辑器演示</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4beeb7a0aa76470993df1475c00cbb33~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=bq5J4GaVsTBmLsR%2FAVtPkh9ahR0%3D" alt="图片" loading="lazy"></p>
<p>其实最近几年我在掘金专栏分享了很多<strong>零代码</strong>和<strong>可视化搭建</strong>的技术实现和产品设计:</p>
<p><a href="https://juejin.cn/column/6963455443528056839" target="_blank" title="https://juejin.cn/column/6963455443528056839">可视化低代码技术精粹</a></p>
<p>&nbsp;这里为了让大家更近一步了解<strong>V6-Dooring</strong>可视化大屏编辑器, 我还是会从<strong>技术设计</strong>到<strong>产品解决方案</strong>设计的角度, 和大家详细分享一下, 让大家在学习我们可视化大屏开源方案的过程中, 对可视化搭建技术产品, 有更深入的理解.</p>
<p>如果大家觉得有帮助, 不要忘记<strong>点赞</strong>&nbsp;+&nbsp;<strong>收藏</strong>哦, 后面我会持续分享最干的互联网干货.</p>
<h2 data-id="heading-0">你将收获</h2>
<ul>
<li><strong>可视化大屏产品设计思路</strong></li>
<li><strong>主流可视化图表库技术选型</strong></li>
<li><strong>大屏编辑器设计思路</strong></li>
<li><strong>大屏可视化编辑器Schema设计</strong></li>
<li><strong>用户数据自治探索</strong></li>
</ul>
<h2 data-id="heading-1">方案实现</h2>
<h3 data-id="heading-2">1.可视化大屏产品设计思路</h3>
<p>目前很多企业或多或少的面临“信息孤岛”问题，各个系统平台之间的数据无法实现互通共享，难以实现一体化的数据分析和实时呈现。</p>
<p>相比于传统手工定制的图表与数据仪表盘，可视化大屏制作平台的出现，可以打破抵消的定制开发, 数据分散的问题，通过数据采集、清洗、分析到直观实时的数据可视化展现，能够多方位、多角度、全景展现各项指标，实时监控，动态一目了然。</p>
<p>针对以上需求, 我们设计了一套可视化大屏解决方案, 具体包含如下几点:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1a2e55953d7444b8389cc338d031b63~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=v590wiLo5CO%2FkkU8wLIghQTiY4E%3D" alt="图片" loading="lazy"></p>
<p>上图是笔者4个月前设计的基本草图, 后期会持续更新. 通过以上的设计分解, 我们基本可以搭建一个可自己定制的数据大屏.</p>
<h3 data-id="heading-3">2.主流可视化图表库技术选型</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/96ef539ba85e44d0880458fb24892e18~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=jxlaAZpq0T5iWQOoY8kYgTwYPkI%3D" alt="图片" loading="lazy"></p>
<p>目前我调研的已知主流可视化库有:</p>
<ul>
<li><strong>echart</strong>&nbsp;一个基于 JavaScript 的老牌开源可视化图表库</li>
<li><strong>D3.js</strong>&nbsp;一个数据驱动的可视化库, 可以不需要其他任何框架独立运行在现代浏览器中，它结合强大的可视化组件来驱动 DOM 操作</li>
<li><strong>antv</strong>&nbsp;包含一套完整的可视化组件体系</li>
<li><strong>Chart.js</strong>&nbsp;基于 HTML5 的 简单易用的 JavaScript 图表库</li>
<li><strong>metrics-graphics</strong>&nbsp;建立在D3之上的可视化库, 针对可视化和布置时间序列数据进行了优化</li>
<li><strong>C3.js</strong>&nbsp;通过包装构造整个图表所需的代码，使生成基于D3的图表变得容易</li>
</ul>
<p>我们使用以上任何一个库都可以实现我们的可视化大屏搭建的需求, 各位可以根据喜好来选择.</p>
<h3 data-id="heading-4">3.大屏编辑器设计思路</h3>
<p>在上面的分析中我们知道一个大屏编辑器需要有个编辑器核心, 主要包含以下部分:</p>
<ul>
<li>组件库</li>
<li>拖拽(自由拖拽, 参考线, 自动提示)</li>
<li>画布渲染器</li>
<li>属性编辑器</li>
</ul>
<p>如下图所示:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4229ef25234e440cb38d70d3990d9990~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=CpguogXM1NcxbgcDfqWED3l%2BLSY%3D" alt="图片" loading="lazy"></p>
<p>组件库我们可以用任何组件封装方式(react/vue等), 这里沿用<strong>H5-Dooring</strong>的可视化组件设计方式, 对组件模型进行优化和设计.</p>
<p>类似的代码如下:</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span>&nbsp;{&nbsp;<span class="hljs-title class_">Chart</span>&nbsp;}&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">'@antv/f2'</span>;
<span class="hljs-keyword">import</span>&nbsp;<span class="hljs-title class_">React</span>,&nbsp;{&nbsp;memo,&nbsp;useEffect,&nbsp;useRef&nbsp;}&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">'react'</span>;

<span class="hljs-keyword">import</span>&nbsp;styles&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">'./index.less'</span>;
<span class="hljs-keyword">import</span>&nbsp;{&nbsp;<span class="hljs-title class_">IChartConfig</span>&nbsp;}&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">'./schema'</span>;

<span class="hljs-keyword">const</span>&nbsp;<span class="hljs-title function_">XChart</span>&nbsp;=&nbsp;(<span class="hljs-params">props:IChartConfig</span>)&nbsp;=&gt;&nbsp;{
&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;{&nbsp;data,&nbsp;color,&nbsp;size,&nbsp;paddingTop,&nbsp;title&nbsp;}&nbsp;=&nbsp;props;
&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;chartRef&nbsp;=&nbsp;<span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);
&nbsp;&nbsp;<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()&nbsp;=&gt;</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;chart&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-title class_">Chart</span>({
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">el</span>:&nbsp;chartRef.<span class="hljs-property">current</span>&nbsp;||&nbsp;<span class="hljs-literal">undefined</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">pixelRatio</span>:&nbsp;<span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>,&nbsp;<span class="hljs-comment">//&nbsp;指定分辨率</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;step&nbsp;2:&nbsp;处理数据</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;dataX&nbsp;=&nbsp;data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span>&nbsp;=&gt;</span>&nbsp;({&nbsp;...item,&nbsp;<span class="hljs-attr">value</span>:&nbsp;<span class="hljs-title class_">Number</span>(item.<span class="hljs-property">value</span>)&nbsp;}));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;Step&nbsp;2:&nbsp;载入数据源</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chart.<span class="hljs-title function_">source</span>(dataX);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// Step 3：创建图形语法，绘制柱状图，由 genre 和 sold 两个属性决定图形位置，genre 映射至 x 轴，sold 映射至 y 轴</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chart
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span class="hljs-title function_">interval</span>()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span class="hljs-title function_">position</span>(<span class="hljs-string">'name*value'</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<span class="hljs-title function_">color</span>(<span class="hljs-string">'name'</span>);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;Step&nbsp;4:&nbsp;渲染图表</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chart.<span class="hljs-title function_">render</span>();
&nbsp;&nbsp;},&nbsp;[data]);
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">className</span>=<span class="hljs-string">{styles.chartWrap}</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">className</span>=<span class="hljs-string">{styles.chartTitle}</span>&nbsp;<span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>&nbsp;<span class="hljs-attr">color</span>,&nbsp;<span class="hljs-attr">fontSize:</span>&nbsp;<span class="hljs-attr">size</span>,&nbsp;<span class="hljs-attr">paddingTop</span>&nbsp;}}&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{title}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">canvas</span>&nbsp;<span class="hljs-attr">ref</span>=<span class="hljs-string">{chartRef}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&nbsp;&nbsp;);
};

<span class="hljs-keyword">export</span>&nbsp;<span class="hljs-keyword">default</span>&nbsp;<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">XChart</span>);
</code></pre>
<p>以上只是一个简单的例子, 更具业务需求的复杂度我们往往会做更多的控制, 比如<strong>动画</strong>(animation),&nbsp;<strong>事件</strong>(event),&nbsp;<strong>数据获取</strong>(data inject)等.</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/875d9fa1751241509d9f72497c803bc4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=Qn3ykshdU4z031JT%2BCnLykQoTzQ%3D" alt="图片" loading="lazy"></p>
<p>当然实际应用中大屏展现的内容和形式远比这复杂， 我们从上图可以提炼出大屏页面的2个直观特征:</p>
<ul>
<li><strong>可视化组件集</strong></li>
<li><strong>空间坐标关系</strong></li>
</ul>
<p>因为我们可视化大屏载体是页面， 是<code>html</code>，&nbsp;所以还有另外一个特征:&nbsp;<strong>事件/交互</strong>。综上我们总结出了可视化大屏的必备要素:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0691e187bfb8438395b41aeea1259a7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=%2BoIto0LgRvBeUpv4x60gu79btrs%3D" alt="图片" loading="lazy"></p>
<p>我们只要充分的理解了可视化大屏的组成和特征， 我们才能更好的设计<strong>可视化大屏搭建引擎</strong>，&nbsp;基于以上分析， 我设计了一张基础引擎的架构图:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f5677868f36d46c186cdf2a61e3ad653~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=aVv334Z7EtQKKyTdl3S0M%2FmLZV8%3D" alt="图片" loading="lazy"></p>
<p>接下来我就带大家一起来拆解并实现上面的搭建引擎。</p>
<h2 data-id="heading-5">大屏搭建引擎核心功能实现</h2>
<p>俗话说: “好的拆解是成功的一半”，&nbsp;<strong>任何一个复杂任务或者系统， 我们只要能将其拆解成很多细小的子模块， 就能很好的解决并实现它</strong>.&nbsp;(学习也是一样)</p>
<p>接下来我们就逐一解决上述基础引擎的几个核心子模块:</p>
<ul>
<li><strong>拖拽器实现</strong></li>
<li><strong>物料中心设计</strong></li>
<li><strong>动态渲染器实现</strong></li>
<li><strong>配置面板设计</strong></li>
<li><strong>控制中心概述</strong></li>
<li><strong>功能辅助设计</strong></li>
</ul>
<h3 data-id="heading-6">1.拖拽器实现</h3>
<p>拖拽器是可视化搭建引擎的核心模块， 也是用来解决上述提到的大屏页面特征中的“<strong>空间坐标关系</strong>”这一问题。我们先来看一下实现效果:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3be1f7367b2e4ab2af6f0e6ee992d471~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=UNaSqXvt7xDUCMMqGGO6dCuq2XE%3D" alt="图片" loading="lazy"></p>
<p>组件拖拽可以采用市面已有的&nbsp;Dragable&nbsp;等插件, 也可以采用&nbsp;<strong>H5-Dooring</strong> 的智能网格拖拽. 这里笔者选择自由拖拽来实现. 已有的有:</p>
<ul>
<li><strong>rc-drag</strong></li>
<li><strong>sortablejs</strong></li>
<li><strong>react-dnd</strong></li>
<li><strong>react-dragable</strong></li>
<li><strong>vue-dragable</strong></li>
</ul>
<p>等等. 具体拖拽呈现流程如下:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5d19580d06344b81bad1a724ef2119ae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=oBvr7pSgaQS0enU2JZJvJhKlV4U%3D" alt="图片" loading="lazy"></p>
<p>具体拖拽流程就是:</p>
<ol>
<li>使用H5 dragable API拖拽左侧组件(component data)进入目标容器(targetBox)</li>
<li>监听拖拽结束事件拿到拖拽事件传递的<code>data</code>来渲染真实的可视化组件</li>
<li>可视化组件挂载,&nbsp;<code>schema</code>注入编辑面板, 编辑面板渲染组件属性编辑器</li>
<li>拖拽, 属性修改, 更新</li>
<li>预览, 发布</li>
</ol>
<p>组件的<code>schema</code>参考<strong>H5-Dooring</strong>&nbsp;DSL设计.</p>
<h3 data-id="heading-7">2.物料中心设计</h3>
<p>物料中心主要为大屏页面提供 <strong>“原材料</strong>”。为了设计健壮且通用的物料， 我们需要设计一套标准组件结构和属性协议。并且为了方便物料管理和查询， 我们还需要对物料进行分类， 我的分类如下:</p>
<ul>
<li><strong>可视化组件</strong>&nbsp;(柱状图， 饼图， 条形图， 地图可视化等)</li>
<li><strong>修饰型组件</strong>&nbsp;(图片， 轮播图， 修饰素材等)</li>
<li><strong>文字类组件</strong>&nbsp;(文本， 文本跑马灯， 文字看板)</li>
</ul>
<p>具体的物料库演示如下:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e3e7d7ad472449d966d0329528b983b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=ZFd2HCwaigPcAHKUnPM9p%2BU8jag%3D" alt="图片" loading="lazy"></p>
<p>这里我拿一个可视化组件的实现来举例说明:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span>&nbsp;<span class="hljs-title class_">React</span>，&nbsp;{&nbsp;memo，&nbsp;useEffect&nbsp;}&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span>&nbsp;{&nbsp;<span class="hljs-title class_">Chart</span>&nbsp;}&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">'@antv/g2'</span>

<span class="hljs-keyword">import</span>&nbsp;{&nbsp;colors&nbsp;}&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">'@/components/BasicShop/common'</span>

<span class="hljs-keyword">import</span>&nbsp;{&nbsp;<span class="hljs-title class_">ChartConfigType</span>&nbsp;}&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">'./schema'</span>

<span class="hljs-keyword">interface</span>&nbsp;<span class="hljs-title class_">ChartComponentProps</span>&nbsp;<span class="hljs-keyword">extends</span>&nbsp;<span class="hljs-title class_">ChartConfigType</span>&nbsp;{
&nbsp;&nbsp;<span class="hljs-attr">id</span>:&nbsp;<span class="hljs-built_in">string</span>
}

<span class="hljs-keyword">const</span>&nbsp;<span class="hljs-title class_">ChartComponent</span>:&nbsp;<span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">ChartComponentProps</span>&gt;&nbsp;=&nbsp;<span class="hljs-function">(<span class="hljs-params">{
&nbsp;&nbsp;id,&nbsp;data,&nbsp;width,&nbsp;height,
&nbsp;&nbsp;toggle,&nbsp;legendPosition,&nbsp;legendLayout,&nbsp;legendShape,
&nbsp;&nbsp;labelColor,&nbsp;axisColor,&nbsp;multiColor,&nbsp;tipEvent,&nbsp;titleEvent,
&nbsp;&nbsp;dataType,&nbsp;apiAddress,&nbsp;apiMethod,&nbsp;apiData,&nbsp;refreshTime,
}</span>)&nbsp;=&gt;</span>&nbsp;{
&nbsp;&nbsp;<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()&nbsp;=&gt;</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span>&nbsp;<span class="hljs-attr">timer</span>:<span class="hljs-built_in">any</span>&nbsp;=&nbsp;<span class="hljs-literal">null</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;chart&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-title class_">Chart</span>({
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">container</span>:&nbsp;<span class="hljs-string">`chart-<span class="hljs-subst">${id}</span>`</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">autoFit</span>:&nbsp;<span class="hljs-literal">true</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;height
&nbsp;&nbsp;&nbsp;&nbsp;})

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;数据过滤，&nbsp;接入</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;dataX&nbsp;=&nbsp;data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span>&nbsp;=&gt;</span>&nbsp;({&nbsp;...item,&nbsp;<span class="hljs-attr">value</span>:&nbsp;<span class="hljs-title class_">Number</span>(item.<span class="hljs-property">value</span>)&nbsp;}))
&nbsp;&nbsp;&nbsp;&nbsp;chart.<span class="hljs-title function_">data</span>(dataX)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;图表属性组装</span>
&nbsp;&nbsp;&nbsp;&nbsp;chart.<span class="hljs-title function_">legend</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toggle
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">position</span>:&nbsp;legendPosition,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">layout</span>:&nbsp;legendLayout,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">marker</span>:&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">symbol</span>:&nbsp;legendShape
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<span class="hljs-literal">false</span>,
&nbsp;&nbsp;&nbsp;&nbsp;)

&nbsp;&nbsp;&nbsp;&nbsp;chart.<span class="hljs-title function_">tooltip</span>({
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">showTitle</span>:&nbsp;<span class="hljs-literal">false</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">showMarkers</span>:&nbsp;<span class="hljs-literal">false</span>,
&nbsp;&nbsp;&nbsp;&nbsp;})

&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;其他图表信息源配置，&nbsp;方法雷同，&nbsp;此处省略</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;...</span>

&nbsp;&nbsp;&nbsp;&nbsp;chart.<span class="hljs-title function_">render</span>()

&nbsp;&nbsp;},&nbsp;[])

&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&nbsp;<span class="hljs-attr">id</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">chart-</span>${<span class="hljs-attr">id</span>}`}&nbsp;/&gt;</span></span>
}

<span class="hljs-keyword">export</span>&nbsp;<span class="hljs-keyword">default</span>&nbsp;<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">ChartComponent</span>)
</code></pre>
<p>以上就是我们的基础物料的实现模式， 可视化组件采用了<code>g2</code>， 当然大家也可以使用熟悉的<code>echart</code>，&nbsp;<code>D3.js</code>等. 不同物料既有通用的&nbsp;<code>props</code>&nbsp;， 也有专有的&nbsp;<code>props</code>， 取决于我们如何定义物料的<code>Schema</code>。</p>
<p>在设计&nbsp;<code>Schema</code>&nbsp;前我们需要明确组件的属性划分， 为了满足组件配置的灵活性和通用性， 我做了如下划分:</p>
<ul>
<li><strong>外观属性</strong>&nbsp;(组件宽高， 颜色， 标签， 展现模式等)</li>
<li><strong>数据配置</strong>&nbsp;(静态数据， 动态数据)</li>
<li><strong>事件/交互</strong>&nbsp;(如单击， 跳转等)</li>
</ul>
<p>有了以上划分， 我们就可以轻松设计想要的通用<code>Schema</code>了。我们先来看看实现后的配置面板:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/703b2f68e34c481d9be59b1af49becee~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=70c92y82DCfsE3IjKyq7arye%2FWc%3D" alt="图片" loading="lazy"></p>
<p>这些属性项都是基于我们定义的<code>schema</code>配置项， 通过&nbsp;<strong>解析引擎</strong>&nbsp;动态渲染出来的， 有关&nbsp;<strong>解析引擎</strong>&nbsp;和配置面板， 我会在下面的章节和大家介绍。我们先看看组件的&nbsp;<code>schema</code>&nbsp;结构:</p>
<pre><code class="hljs language-css" lang="css">const&nbsp;Chart:&nbsp;ChartSchema&nbsp;=&nbsp;{
&nbsp;&nbsp;editAttrs:&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key:&nbsp;<span class="hljs-string">'layerName'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;<span class="hljs-string">'Text'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cate:&nbsp;<span class="hljs-string">'base'</span>，
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key:&nbsp;<span class="hljs-string">'y'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;<span class="hljs-string">'Number'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cate:&nbsp;<span class="hljs-string">'base'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;..<span class="hljs-selector-class">.DataConfig</span>,&nbsp;//&nbsp;数据配置项
&nbsp;&nbsp;&nbsp;&nbsp;..<span class="hljs-selector-class">.eventConfig</span>,&nbsp;//&nbsp;事件配置项
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;]，
&nbsp;&nbsp;config:&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attribute">width</span>:&nbsp;<span class="hljs-number">200</span>,
&nbsp;&nbsp;&nbsp;&nbsp;height:&nbsp;<span class="hljs-number">200</span>,
&nbsp;&nbsp;&nbsp;&nbsp;zIndex:&nbsp;<span class="hljs-number">1</span>,
&nbsp;&nbsp;&nbsp;&nbsp;layerName:&nbsp;<span class="hljs-string">'柱状图'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;labelColor:&nbsp;<span class="hljs-string">'rgba(188，200，212，1)'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...&nbsp;其他配置初始值
&nbsp;&nbsp;&nbsp;&nbsp;multiColor:&nbsp;[<span class="hljs-string">'rgba(91,&nbsp;143,&nbsp;249,&nbsp;1)'</span>,&nbsp;<span class="hljs-string">'rgba(91,&nbsp;143,&nbsp;249,&nbsp;1)'</span>,&nbsp;<span class="hljs-string">'rgba(91,&nbsp;143,&nbsp;249，,1)'</span>,&nbsp;<span class="hljs-string">'rgba(91,&nbsp;143,&nbsp;249,&nbsp;1)'</span>],
&nbsp;&nbsp;&nbsp;&nbsp;data:&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<span class="hljs-string">'A'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value:&nbsp;<span class="hljs-number">25</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}，
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<span class="hljs-string">'B'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value:&nbsp;<span class="hljs-number">66</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;],
&nbsp;&nbsp;},
}
</code></pre>
<p>其中&nbsp;<strong>editAttrs</strong>&nbsp;表示可编辑的属性列表，&nbsp;<strong>config</strong>&nbsp;为属性的初始值， 当然大家也可以根据自己的喜好， 设计类似的通用<code>schema</code>。</p>
<p>我们通过以上设计的标准组件和标准<code>schema</code>， 就可以批量且高效的生产各种物料， 还可以轻松集成任何第三方可视化组件库。</p>
<h3 data-id="heading-8">3.动态渲染器实现</h3>
<p>我们都知道， 一个页面中元素很多时会影响页面整体的加载速度， 因为浏览器渲染页面需要消耗<strong>CPU / GPU</strong>。对于可视化页面来说， 每一个可视化组件都需要渲染大量的信息元， 这无疑会对页面性能造成不小的影响， 所以我们需要设计一种机制， 让组件异步加载到画布上， 而不是一次性加载几十个几百个组件(这样的话页面会有大量的白屏时间， 用户体验极度下降)。</p>
<p>动态加载器就是提供了这样一种机制， 保证组件的加载都是异步的， 一方面可以减少页面体积， 另一方面用户可以更早的看到页面元素。目前我们熟的动态加载机制也有很多，&nbsp;<code>Vue</code>&nbsp;和&nbsp;<code>React</code>&nbsp;生态都提供了开箱即用的解决方案(虽然我们可以用&nbsp;<code>webpack</code>&nbsp;自行设计这样的动态模型， 此处为了提高行文效率， 我们直接基于现成方案封装)。我们先看一下动态渲染组件的过程:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23b6f369ccbf4088b691244ffbf1a077~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=w1htIV1%2BvT1cwxFY7PfsExbxwbI%3D" alt="图片" loading="lazy"></p>
<p>上面的演示可以细微的看出从左侧组件菜单拖动某个组件图标到画布上后， 真正的组件才开始加载渲染。</p>
<p>这里我们以&nbsp;<code>umi3.0</code>&nbsp;提供的&nbsp;<code>dynamic</code>&nbsp;函数来最小化实现一个动态渲染器. 如果不熟悉&nbsp;<code>umi</code>&nbsp;生态的朋友， 也不用着急， 看完我的实现过程和原理之后， 就可以利用任何熟悉的动态加载机制实现它了。实现如下:</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span>&nbsp;<span class="hljs-title class_">React</span>,&nbsp;{&nbsp;useMemo,&nbsp;memo,&nbsp;<span class="hljs-variable constant_">FC</span>&nbsp;}&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span>&nbsp;{&nbsp;dynamic&nbsp;}&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">'umi'</span>

<span class="hljs-keyword">import</span>&nbsp;<span class="hljs-title class_">LoadingComponent</span>&nbsp;<span class="hljs-keyword">from</span>&nbsp;<span class="hljs-string">'@/components/LoadingComponent'</span>


<span class="hljs-keyword">const</span>&nbsp;<span class="hljs-title function_">DynamicFunc</span>&nbsp;=&nbsp;(<span class="hljs-params">cpName:&nbsp;<span class="hljs-built_in">string</span>,&nbsp;category:&nbsp;<span class="hljs-built_in">string</span></span>)&nbsp;=&gt;&nbsp;{
&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-title function_">dynamic</span>({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">async</span>&nbsp;<span class="hljs-title function_">loader</span>(<span class="hljs-params"></span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;&nbsp;动态加载组件</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;{&nbsp;<span class="hljs-attr">default</span>:&nbsp;<span class="hljs-title class_">Graph</span>&nbsp;}&nbsp;=&nbsp;<span class="hljs-keyword">await</span>&nbsp;<span class="hljs-keyword">import</span>(<span class="hljs-string">`@/components/materies/<span class="hljs-subst">${cpName}</span>`</span>)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-function">(<span class="hljs-params">props:&nbsp;DynamicType</span>)&nbsp;=&gt;</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;{&nbsp;config，&nbsp;id&nbsp;}&nbsp;=&nbsp;props
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Graph</span>&nbsp;{<span class="hljs-attr">...config</span>}&nbsp;<span class="hljs-attr">id</span>=<span class="hljs-string">{id}</span>&nbsp;/&gt;</span></span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">loading</span>:&nbsp;<span class="hljs-function">()&nbsp;=&gt;</span>&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoadingComponent</span>&nbsp;/&gt;</span></span>
&nbsp;&nbsp;})
}

<span class="hljs-keyword">const</span>&nbsp;<span class="hljs-title class_">DynamicRenderEngine</span>:&nbsp;<span class="hljs-variable constant_">FC</span>&lt;<span class="hljs-title class_">DynamicType</span>&gt;&nbsp;=&nbsp;<span class="hljs-title function_">memo</span>(<span class="hljs-function">(<span class="hljs-params">props</span>)&nbsp;=&gt;</span>&nbsp;{
&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;{&nbsp;
&nbsp;&nbsp;<span class="hljs-keyword">type</span>,&nbsp;
&nbsp;&nbsp;config,&nbsp;
&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;其他配置...&nbsp;</span>
&nbsp;&nbsp;}&nbsp;=&nbsp;props
&nbsp;&nbsp;<span class="hljs-keyword">const</span>&nbsp;<span class="hljs-title class_">Dynamic</span>&nbsp;=&nbsp;<span class="hljs-title function_">useMemo</span>(<span class="hljs-function">()&nbsp;=&gt;</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-title class_">DynamicFunc</span>(config)
&nbsp;&nbsp;},&nbsp;[config])

&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dynamic</span>&nbsp;{<span class="hljs-attr">...props</span>}&nbsp;/&gt;</span></span>
})

<span class="hljs-keyword">export</span>&nbsp;<span class="hljs-keyword">default</span>&nbsp;<span class="hljs-title class_">DynamicRenderEngine</span>
</code></pre>
<p>是不是很简单? 当然我们也可以根据自身业务需要， 设计更复杂强大的动态渲染器。</p>
<h3 data-id="heading-9">4.配置面板设计</h3>
<p>实现配置面板的前提是对组件&nbsp;<code>Schema</code>&nbsp;结构有一个系统的设计， 在介绍组件库实现中我们介绍了通用组件&nbsp;<code>schema</code>&nbsp;的一个设计案例， 我们基于这样的案例结构， 来实现&nbsp;<strong>动态配置面板</strong>。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/86346a412cec4944b208560bed06257d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=zxPZ9vCobNAAxUj9GtmoOVFLqY8%3D" alt="图片" loading="lazy"></p>
<p>由上图可以知道， 动态配置面板的一个核心要素就是&nbsp;<strong>表单渲染器</strong>。表单渲染器的目的就是基于属性配置列表&nbsp;<code>attrs</code>&nbsp;来动态渲染出对应的表单项。我之前写了一篇文章详细的介绍了表单设计器的技术实现的文章， 大家感兴趣也可以参考一下: Dooring可视化之从零实现动态表单设计器。</p>
<p>我这里来简单实现一个基础的表单渲染器模型:</p>
<pre><code class="hljs language-ini" lang="ini">const&nbsp;<span class="hljs-attr">FormEditor</span>&nbsp;=&nbsp;(props:&nbsp;FormEditorProps)&nbsp;=&gt;&nbsp;{
&nbsp;&nbsp;const&nbsp;{&nbsp;attrs,&nbsp;defaultValue,&nbsp;onSave&nbsp;}&nbsp;=&nbsp;props<span class="hljs-comment">;</span>

&nbsp;&nbsp;const&nbsp;<span class="hljs-attr">onFinish</span>&nbsp;=&nbsp;(values:&nbsp;Store)&nbsp;=&gt;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;保存配置项数据
&nbsp;&nbsp;&nbsp;&nbsp;onSave&nbsp;&amp;&amp;&nbsp;onSave(values)<span class="hljs-comment">;</span>
&nbsp;&nbsp;}<span class="hljs-comment">;</span>
&nbsp;&nbsp;
&nbsp;&nbsp;const&nbsp;<span class="hljs-attr">handlechange</span>&nbsp;=&nbsp;(value)&nbsp;=&gt;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;更新逻辑
&nbsp;&nbsp;}

&nbsp;&nbsp;const&nbsp;<span class="hljs-section">[form]</span>&nbsp;=&nbsp;Form.useForm()<span class="hljs-comment">;</span>

&nbsp;&nbsp;return&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&lt;Form
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">form</span>={form}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{...formItemLayout}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">onFinish</span>={<span class="hljs-literal">on</span>Finish}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">initialValues</span>={defaultValue}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">onValuesChange</span>={handlechange}
&nbsp;&nbsp;&nbsp;&nbsp;&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attrs.map((item,&nbsp;i)&nbsp;=&gt;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;React.Fragment&nbsp;<span class="hljs-attr">key</span>={i}&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="hljs-attr">item.type</span>&nbsp;===&nbsp;<span class="hljs-string">'Number'</span>&nbsp;&amp;&amp;&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Form.Item&nbsp;<span class="hljs-attr">label</span>={item.name}&nbsp;name={item.key}&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;InputNumber&nbsp;/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Form.Item&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="hljs-attr">item.type</span>&nbsp;===&nbsp;<span class="hljs-string">'Text'</span>&nbsp;&amp;&amp;&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Form.Item&nbsp;<span class="hljs-attr">label</span>={item.name}&nbsp;name={item.key}&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Input&nbsp;<span class="hljs-attr">placeholder</span>={item.placeholder}&nbsp;/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Form.Item&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="hljs-attr">item.type</span>&nbsp;===&nbsp;<span class="hljs-string">'TextArea'</span>&nbsp;&amp;&amp;&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Form.Item&nbsp;<span class="hljs-attr">label</span>={item.name}&nbsp;name={item.key}&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;TextArea&nbsp;<span class="hljs-attr">rows</span>={<span class="hljs-number">4</span>}&nbsp;/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Form.Item&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;其他配置类型
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/React.Fragment&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<span class="hljs-comment">;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})}
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/Form&gt;
&nbsp;&nbsp;)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p>如果大家想看更完整的配置面板实现， 可以参考开源项目&nbsp;H5-Dooring | H5可视化编辑器</p>
<p>我们可以看看最终的配置面板实现效果:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2554b55232f74771b36cb60811d357b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=DSPcdVUG5nfweSbqwjyWclSGZgo%3D" alt="图片" loading="lazy"></p>
<h3 data-id="heading-10">5.控制中心概述 &amp; 功能辅助设计</h3>
<p><strong>控制中心</strong>的实现主要是业务层的， 没有涉及太多复杂的技术， 所以这里我简单介绍一下。因为可视化大屏页面展示的信息有些可能是私密数据， 只希望一部分人看到， 所以我们需要对页面的访问进行控制。其次由于企业内部业务战略需求， 可能会对页面进行各种验证， 状态校验， 数据更新频率等， 所以我们需要设计一套控制中心来管理。最基本的就是访问控制， 如下:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6b4dac18c2964d7ba23b860d0925a067~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=3Ka%2FDeibEFH1UcHO8h0UirNS0Y8%3D" alt="图片" loading="lazy"></p>
<p><strong>功能辅助设计</strong>&nbsp;主要是一些用户操作上的优化， 比如快捷键， 画布缩放， 大屏快捷导航， 撤销重做等操作， 这块可以根据具体的产品需求来完善。大家后期设计搭建产品时也可以参考实现。</p>
<h3 data-id="heading-11">可视化大屏数据自治探索</h3>
<p>目前我们实现的搭建平台可以静态的设计数据源, 也可以注入第三方接口, 如下:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c5b2ade01b924b27a86edbc8f00d8930~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=Gq8N%2FQYyzN3KfOKyCNJ31shvYNI%3D" alt="图片" loading="lazy"></p>
<p>我们可以调用内部接口来实时获取数据, 这块在可视化监控平台用的场景比较多, 方式如下:</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/33424878d087402a9d9c979a5eb28394~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=Hskum0MIbirr6keTUe8bT15sIpQ%3D" alt="图片" loading="lazy"></p>
<p>参数(<code>params</code>)编辑区可以自定义接口参数. 代码编辑器笔者这里推荐两款, 大家可以选用:</p>
<ul>
<li><strong>react-monaco-editor</strong></li>
<li><strong>react-codemirror2</strong></li>
</ul>
<p>使用以上之一可以实现<code>mini</code>版<code>vscode</code>, 大家也可以尝试一下.</p>
<h3 data-id="heading-12">辅助功能</h3>
<p><strong>可视化大屏一键截图</strong>&nbsp;一键截图功能还是沿用H5-Dooring&nbsp;的快捷截图方案, 主要用于对大屏的分享, 海报制作等需求, 我们可以使用以下任何一个组件实现:</p>
<ul>
<li><strong>dom-to-image</strong></li>
<li><strong>html2canvas</strong></li>
</ul>
<p><strong>撤销重做</strong>撤销重做功能我们可以使用已有的库比如<code>react-undo</code>, 也可以自己实现, 实现原理:<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e548ee2b5f98469c8a1b7dd3a222a214~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b6Q5bCP5aSV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1742159742&amp;x-signature=y%2FCqfQg7mOxFRiYU9U4sL%2FobcHM%3D" alt="图片" loading="lazy">有点链表的意思, 我们将每一个状态存储到数组中, 通过指针来实现撤销重做的功能, 如果要想更健壮一点, 我们可以设计一套“状态淘汰机制”, 设置可保留的最大状态数, 之前的自动淘汰(删除, 更高大上一点的叫出栈). 这样可以避免复杂操作中的大量状态存储, 节约浏览器内存.<br>
<strong>标尺参考线</strong>&nbsp;标尺和参考线这里我们自己实现, 通过动态dom渲染来实现参考线在缩放后的动态收缩, 实现方案核心如下:</p>
<pre><code class="hljs language-ini" lang="ini">arr.forEach(<span class="hljs-attr">el</span>&nbsp;=&gt;&nbsp;{
&nbsp;&nbsp;let&nbsp;<span class="hljs-attr">dom</span>&nbsp;=&nbsp;[...Array.from(el.querySelectorAll(<span class="hljs-string">'.calibrationNumber'</span>))][<span class="hljs-number">0</span>]&nbsp;as&nbsp;HTMLElement<span class="hljs-comment">;</span>
&nbsp;&nbsp;if&nbsp;(dom)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">dom.style.transform</span>&nbsp;=&nbsp;`translate3d(-<span class="hljs-number">4</span>px,&nbsp;-<span class="hljs-number">8</span>px,&nbsp;<span class="hljs-number">0</span>px)&nbsp;scale(${(multiple&nbsp;+&nbsp;<span class="hljs-number">0.1</span>).toFixed(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,
&nbsp;&nbsp;&nbsp;&nbsp;)})`<span class="hljs-comment">;</span>
&nbsp;&nbsp;}
})<span class="hljs-comment">;</span>
</code></pre>
<p>详细源码可参考:&nbsp;<strong>H5-Dooring</strong>&nbsp;| 参考线设计源码</p>
<p>如果大家有好的建议也欢迎随时交流反馈, 开源不易, 别忘了star哦~</p>
<p>github地址:&nbsp;<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMrXujiang%2Fv6.dooring.public" target="_blank" title="https://github.com/MrXujiang/v6.dooring.public" ref="nofollow noopener noreferrer">github.com/MrXujiang/v…</a></strong></p></div></div>