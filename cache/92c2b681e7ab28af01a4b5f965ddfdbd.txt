
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/liyongqiang-cc/p/18636233" title="发布于 2025-01-13 17:37">
    <span role="heading" aria-level="2">.NET Core 委托原理解析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="net-core-委托原理解析">.NET Core 委托原理解析</h1>
<p>在 .NET Core 中，委托（Delegate）是一种类型安全的函数指针，它允许你将方法作为参数传递给其他方法，或者将方法存储在变量中以便稍后调用。委托在事件处理、回调机制以及异步编程中非常有用。理解委托的运行原理对于掌握 .NET Core 的高级编程技巧至关重要。</p>
<h2 id="1-委托的基本概念">1. 委托的基本概念</h2>
<p>委托是一种引用类型，它引用一个或多个方法。委托定义了方法的签名（参数类型和返回类型），因此只有具有相同签名的方法才能被委托引用。</p>
<h3 id="11-定义委托">1.1 定义委托</h3>
<p>你可以通过 <code>delegate</code> 关键字来定义一个委托类型。例如：</p>
<pre><code>&nbsp;//&nbsp;定义一个委托类型
public&nbsp;delegate&nbsp;void&nbsp;GreetDelegate(string&nbsp;name);
</code></pre>
<p>这个委托类型 <code>GreetDelegate</code> 可以引用任何具有 <code>void</code> 返回类型和 <code>string</code> 参数的方法。</p>
<h3 id="12-实例化委托">1.2 实例化委托</h3>
<p>一旦定义了委托类型，你可以创建该委托的实例，并将方法赋值给它。例如：</p>
<pre><code>&nbsp;&nbsp;//&nbsp;与委托签名匹配的方法
&nbsp;&nbsp;public&nbsp;void&nbsp;Greet(string&nbsp;name)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($"Hello,&nbsp;{name}!");
&nbsp;&nbsp;}

&nbsp;&nbsp;//&nbsp;创建委托实例并绑定方法
&nbsp;&nbsp;GreetDelegate&nbsp;del&nbsp;&nbsp;=&nbsp;new&nbsp;GreetDelegate(Greet);
</code></pre>
<p>在这个例子中，<code>del</code> 是一个委托实例，它引用了 <code>Greet</code> 方法。</p>
<h3 id="13-调用委托">1.3 调用委托</h3>
<p>你可以像调用方法一样调用委托：</p>
<pre><code>//&nbsp;调用委托
del("World");
</code></pre>
<p>这会调用 <code>del</code> 方法，并输出 <code>"Hello, World!"</code>。</p>
<h2 id="2委托的类型">2.委托的类型</h2>
<h3 id="1-单播委托singlecast-delegate">1. 单播委托（Singlecast Delegate）</h3>
<p>单播委托是指一个委托实例只能引用一个方法。这是最基本的委托类型。</p>
<pre><code>public&nbsp;delegate&nbsp;void&nbsp;GreetDelegate(string&nbsp;message);

public&nbsp;void&nbsp;ShowMessage(string&nbsp;message)
{
&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(message);
}

GreetDelegate&nbsp;del&nbsp;=&nbsp;new&nbsp;GreetDelegate(ShowMessage);
del("Hello,&nbsp;World!");&nbsp;//&nbsp;输出：Hello,&nbsp;World!
</code></pre>
<hr>
<h3 id="2-多播委托multicast-delegate">2. 多播委托（Multicast Delegate）</h3>
<p>多播委托是指一个委托实例可以引用多个方法。通过 <code>+=</code> 运算符可以将多个方法添加到委托实例中，并通过 <code>-=</code> 运算符移除方法。</p>
<pre><code>public&nbsp;void&nbsp;ShowMessage1(string&nbsp;message)
{
&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($"Message&nbsp;1:&nbsp;{message}");
}

public&nbsp;void&nbsp;ShowMessage2(string&nbsp;message)
{
&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($"Message&nbsp;2:&nbsp;{message}");
}

public&nbsp;void&nbsp;ShowMessage3(string&nbsp;message)
{
&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine($"Message&nbsp;3:&nbsp;{message}");
}

GreetMulticastDelegate&nbsp;del&nbsp;=&nbsp;new&nbsp;GreetMulticastDelegate(ShowMessage1);
del&nbsp;+=&nbsp;ShowMessage2;
del&nbsp;+=&nbsp;ShowMessage3;
del&nbsp;-=&nbsp;ShowMessage2;

del("Hello,&nbsp;World!");
</code></pre>
<p>在这个例子中，<code>del</code> 委托实例引用了多个方法：将<code>ShowMessage1,ShowMessage2</code> 和 <code>ShowMessage3</code>添加到了多播委托实例中，然后并通过 <code>-=</code> 运算符移除<code>ShowMessage2</code>。然后调用 <code>del("Hello, World!")</code> 时，三个方法都会被调用，输出如下：</p>
<pre><code>Message&nbsp;1:&nbsp;Hello,&nbsp;World!
//ShowMessage2方法已移除
Message&nbsp;3:&nbsp;Hello,&nbsp;World!
</code></pre>
<hr>
<h3 id="3-泛型委托generic-delegate">3. 泛型委托（Generic Delegate）</h3>
<p>泛型委托是 C# 中的一种特殊委托类型，它允许你定义可以处理多种数据类型的委托。通过使用泛型，你可以编写更通用、更灵活的代码，而不需要为每种数据类型单独定义委托。</p>
<p>以下是几个泛型委托的示例，展示了如何使用泛型委托处理不同类型的数据。</p>
<h4 id="31-简单的泛型委托">3.1 简单的泛型委托</h4>
<pre><code>public&nbsp;delegate&nbsp;T&nbsp;MyGenericDelegate&lt;T&gt;(T&nbsp;arg);

public&nbsp;int&nbsp;Square(int&nbsp;x)
{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x&nbsp;*&nbsp;x;
}

public&nbsp;string&nbsp;Reverse(string&nbsp;s)
{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;string(s.Reverse().ToArray());
}

MyGenericDelegate&lt;int&gt;&nbsp;intDelegate&nbsp;=&nbsp;new&nbsp;MyGenericDelegate&lt;int&gt;(Square);
Console.WriteLine(intDelegate(5));&nbsp;//&nbsp;输出：25

MyGenericDelegate&lt;string&gt;&nbsp;stringDelegate&nbsp;=&nbsp;new&nbsp;MyGenericDelegate&lt;string&gt;(Reverse);
Console.WriteLine(stringDelegate("hello"));&nbsp;//&nbsp;输出：olleh
</code></pre>
<ul>
<li>• <strong>说明</strong>：
<ul>
<li>• <code>MyGenericDelegate</code> 实例化了一个处理 <code>int</code> 类型数据的委托。</li>
<li>• <code>MyGenericDelegate</code> 实例化了一个处理 <code>string</code> 类型数据的委托。</li>
</ul>
</li>
</ul>
<h4 id="32-多参数泛型委托">3.2 多参数泛型委托</h4>
<pre><code>public&nbsp;delegate&nbsp;TResult&nbsp;MyGenericDelegate&lt;T1,&nbsp;T2,&nbsp;TResult&gt;(T1&nbsp;arg1,&nbsp;T2&nbsp;arg2);

public&nbsp;int&nbsp;Add(int&nbsp;a,&nbsp;int&nbsp;b)
{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;+&nbsp;b;
}

public&nbsp;string&nbsp;Concat(string&nbsp;s1,&nbsp;string&nbsp;s2)
{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;s1&nbsp;+&nbsp;s2;
}

MyGenericDelegate&lt;int,&nbsp;int,&nbsp;int&gt;&nbsp;intDelegate&nbsp;=&nbsp;new&nbsp;MyGenericDelegate&lt;int,&nbsp;int,&nbsp;int&gt;(Add);
Console.WriteLine(intDelegate(3,&nbsp;5));&nbsp;//&nbsp;输出：8

MyGenericDelegate&lt;string,&nbsp;string,&nbsp;string&gt;&nbsp;stringDelegate&nbsp;=&nbsp;new&nbsp;MyGenericDelegate&lt;string,&nbsp;string,&nbsp;string&gt;(Concat);
Console.WriteLine(stringDelegate("Hello,&nbsp;",&nbsp;"World!"));&nbsp;//&nbsp;输出：Hello,&nbsp;World!
</code></pre>
<ul>
<li>• <strong>说明</strong>：
<ul>
<li>• <code>MyGenericDelegate</code> 实例化了一个处理两个 <code>int</code> 类型参数并返回 <code>int</code> 类型结果的委托。</li>
<li>• <code>MyGenericDelegate</code> 实例化了一个处理两个 <code>string</code> 类型参数并返回 <code>string</code> 类型结果的委托。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-内置委托类型">4. 内置委托类型</h3>
<p>C# 提供了一些内置的泛型委托类型，可以直接使用，而无需自定义委托。</p>
<h4 id="41-action-委托">4.1 <code>Action</code> 委托</h4>
<p><code>Action</code> 委托用于引用没有返回值的方法。它可以有 0 到 16 个参数。</p>
<pre><code>Action&lt;string&gt;&nbsp;action&nbsp;=&nbsp;(message)&nbsp;=&gt;&nbsp;Console.WriteLine(message);
action("Hello,&nbsp;World!");&nbsp;//&nbsp;输出：Hello,&nbsp;World!
</code></pre>
<h4 id="42-func-委托">4.2 <code>Func</code> 委托</h4>
<p><code>Func</code> 委托用于引用有返回值的方法。它可以有 0 到 16 个参数，最后一个泛型参数是返回值类型。</p>
<pre><code>Func&lt;int,&nbsp;int,&nbsp;int&gt;&nbsp;add&nbsp;=&nbsp;(a,&nbsp;b)&nbsp;=&gt;&nbsp;a&nbsp;+&nbsp;b;
Console.WriteLine(add(3,&nbsp;5));&nbsp;//&nbsp;输出：8
</code></pre>
<h4 id="43-predicate-委托">4.3 <code>Predicate</code> 委托</h4>
<p><code>Predicate</code> 委托用于引用返回布尔值的方法，通常用于条件判断。</p>
<pre><code>Predicate&lt;int&gt;&nbsp;isEven&nbsp;=&nbsp;(num)&nbsp;=&gt;&nbsp;num&nbsp;%&nbsp;2&nbsp;==&nbsp;0;
Console.WriteLine(isEven(4));&nbsp;//&nbsp;输出：True
</code></pre>
<hr>
<h3 id="5-匿名方法委托">5. 匿名方法委托</h3>
<p>匿名方法允许你直接定义委托的实现，而无需显式声明一个方法。</p>
<pre><code>MyDelegate&nbsp;del&nbsp;=&nbsp;delegate(string&nbsp;message)
{
&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(message);
};

del("Hello,&nbsp;World!");&nbsp;//&nbsp;输出：Hello,&nbsp;World!
</code></pre>
<hr>
<h3 id="6-lambda-表达式委托">6. Lambda 表达式委托</h3>
<p>Lambda 表达式是一种更简洁的匿名方法写法，通常用于定义委托。</p>
<pre><code>Action&lt;string&gt;&nbsp;action&nbsp;=&nbsp;(message)&nbsp;=&gt;&nbsp;Console.WriteLine(message);
action("Hello,&nbsp;World!");&nbsp;//&nbsp;输出：Hello,&nbsp;World!

Func&lt;int,&nbsp;int,&nbsp;int&gt;&nbsp;add&nbsp;=&nbsp;(a,&nbsp;b)&nbsp;=&gt;&nbsp;a&nbsp;+&nbsp;b;
Console.WriteLine(add(3,&nbsp;5));&nbsp;//&nbsp;输出：8
</code></pre>
<hr>
<h3 id="7-事件委托">7. 事件委托</h3>
<p>事件是一种特殊的委托，通常用于实现观察者模式。事件委托通常与 <code>EventHandler</code> 或 <code>EventHandler</code> 一起使用。</p>
<pre><code>public&nbsp;class&nbsp;Button
{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;event&nbsp;EventHandler&nbsp;Click;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;OnClick()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Click?.Invoke(this,&nbsp;EventArgs.Empty);
&nbsp;&nbsp;&nbsp;&nbsp;}
}

public&nbsp;class&nbsp;Program
{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;Main()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Button&nbsp;button&nbsp;=&nbsp;new&nbsp;Button();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button.Click&nbsp;+=&nbsp;(sender,&nbsp;e)&nbsp;=&gt;&nbsp;Console.WriteLine("Button&nbsp;clicked!");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button.OnClick();&nbsp;//&nbsp;输出：Button&nbsp;clicked!
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<hr>
<h3 id="8-异步委托">8. 异步委托</h3>
<p>异步委托允许你异步调用方法，通常与 <code>BeginInvoke</code> 和 <code>EndInvoke</code> 一起使用。</p>
<pre><code>public&nbsp;delegate&nbsp;int&nbsp;MyAsyncDelegate(int&nbsp;x,&nbsp;int&nbsp;y);

public&nbsp;int&nbsp;Add(int&nbsp;a,&nbsp;int&nbsp;b)
{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;+&nbsp;b;
}

MyAsyncDelegate&nbsp;del&nbsp;=&nbsp;new&nbsp;MyAsyncDelegate(Add);
IAsyncResult&nbsp;result&nbsp;=&nbsp;del.BeginInvoke(3,&nbsp;5,&nbsp;null,&nbsp;null);
int&nbsp;sum&nbsp;=&nbsp;del.EndInvoke(result);
Console.WriteLine(sum);&nbsp;//&nbsp;输出：8
</code></pre>
<hr>
<h3 id="9-动态委托">9. 动态委托</h3>
<p>动态委托允许你在运行时动态创建和调用委托。</p>
<pre><code>public&nbsp;int&nbsp;Multiply(int&nbsp;a,&nbsp;int&nbsp;b)
{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;*&nbsp;b;
}

var&nbsp;method&nbsp;=&nbsp;typeof(Program).GetMethod("Multiply");
var&nbsp;del&nbsp;=&nbsp;Delegate.CreateDelegate(typeof(Func&lt;int,&nbsp;int,&nbsp;int&gt;),&nbsp;null,&nbsp;method);
int&nbsp;result&nbsp;=&nbsp;(del&nbsp;as&nbsp;Func&lt;int,&nbsp;int,&nbsp;int&gt;)(3,&nbsp;5);
Console.WriteLine(result);&nbsp;//&nbsp;输出：15
</code></pre>
<h2 id="3-委托的运行原理">3. 委托的运行原理</h2>
<p>委托的运行原理涉及到 .NET Core 的运行时机制和内部实现。以下是委托运行原理的关键点：</p>
<h3 id="31-委托的内部结构">3.1 委托的内部结构</h3>
<p>在 .NET Core 中，委托是一个类，它继承自 <code>System.MulticastDelegate</code> 类。<code>System.MulticastDelegate</code> 类又继承自 <code>System.Delegate</code> 类。委托类包含以下关键成员：</p>
<ul>
<li>• <code>_target</code>：指向调用方法的对象实例（如果是静态方法，则为 <code>null</code>）。</li>
<li>• <code>_methodPtr</code>：指向方法的函数指针。</li>
<li>• <code>_invocationList</code>：用于存储多播委托中的多个方法。</li>
</ul>
<h3 id="32-委托的调用">3.2 委托的调用</h3>
<p>当你调用委托时，.NET Core 运行时会执行以下步骤：</p>
<ol>
<li>1. <strong>检查委托实例是否为****</strong> <code>**null**</code>：如果委托实例为 <code>null</code>，则会抛出 <code>NullReferenceException</code>。</li>
<li>2. <strong>调用委托的****</strong> <code>**Invoke**</code> <strong>****方法</strong>：委托实例的 <code>Invoke</code> 方法会被调用，该方法会根据 <code>_target</code> 和 <code>_methodPtr</code> 调用实际的方法。</li>
<li>3. <strong>处理多播委托</strong>：如果委托是多播委托（即 <code>_invocationList</code> 不为 <code>null</code>），则 <code>Invoke</code> 方法会遍历 <code>_invocationList</code>，依次调用每个方法。</li>
</ol>
<h3 id="33-委托的优化">3.3 委托的优化</h3>
<p>.NET Core 对委托的调用进行了优化，以提高性能。例如，对于单播委托（即只引用一个方法的委托），.NET Core 会直接调用方法，而不需要通过 <code>Invoke</code> 方法。</p>
<h2 id="4-委托的应用场景">4. 委托的应用场景</h2>
<p>委托在 .NET Core 中有多种应用场景，以下是一些常见的场景：</p>
<h3 id="41-事件处理">4.1 事件处理</h3>
<p>委托在事件处理中非常常见。事件是一种特殊的委托，它允许对象在发生某些事情时通知其他对象。例如：</p>
<pre><code>C#public&nbsp;class&nbsp;Button
{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;event&nbsp;Action&nbsp;Click;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;OnClick()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Click?.Invoke();
&nbsp;&nbsp;&nbsp;&nbsp;}
}

public&nbsp;class&nbsp;Program
{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;Main()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Button&nbsp;button&nbsp;=&nbsp;new&nbsp;Button();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button.Click&nbsp;+=&nbsp;()&nbsp;=&gt;&nbsp;Console.WriteLine("Button&nbsp;clicked!");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button.OnClick();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<p>在这个例子中，<code>Button</code> 类定义了一个 <code>Click</code> 事件，当 <code>OnClick</code> 方法被调用时，事件处理程序会被触发。</p>
<h3 id="42-回调机制">4.2 回调机制</h3>
<p>委托可以用于实现回调机制，允许一个方法在完成时通知另一个方法。例如：</p>
<pre><code>public&nbsp;void&nbsp;DoWork(Action&nbsp;callback)
{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行一些工作
&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Work&nbsp;is&nbsp;done.");

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;调用回调方法
&nbsp;&nbsp;&nbsp;&nbsp;callback?.Invoke();
}

public&nbsp;void&nbsp;Main()
{
&nbsp;&nbsp;&nbsp;&nbsp;DoWork(()&nbsp;=&gt;&nbsp;Console.WriteLine("Callback&nbsp;called."));
}
</code></pre>
<p>在这个例子中，<code>DoWork</code> 方法在完成工作后调用传入的回调方法。</p>
<h3 id="43-异步编程">4.3 异步编程</h3>
<p>委托在异步编程中也非常有用。例如，<code>Task</code> 类的 <code>ContinueWith</code> 方法允许你在任务完成时执行一个委托：</p>
<pre><code>Task.Run(()&nbsp;=&gt;&nbsp;Console.WriteLine("Task&nbsp;is&nbsp;running..."))
&nbsp;&nbsp;&nbsp;&nbsp;.ContinueWith(task&nbsp;=&gt;&nbsp;Console.WriteLine("Task&nbsp;is&nbsp;completed."));
</code></pre>
<h2 id="5-总结">5. 总结</h2>
<p>委托是 .NET Core 中一个非常强大的特性，它允许你将方法作为参数传递、存储和调用。理解委托的运行原理有助于你更好地利用这一特性，特别是在事件处理、回调机制和异步编程中。通过掌握委托，你可以编写更加灵活和可扩展的代码。<br>
<img src="https://img2024.cnblogs.com/blog/2063798/202412/2063798-20241227171104481-839468980.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.0297753800231482" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-13 17:38">2025-01-13 17:37</span>&nbsp;
<a href="https://www.cnblogs.com/liyongqiang-cc">代码拾光</a>&nbsp;
阅读(<span id="post_view_count">223</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18636233" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18636233);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18636233', targetLink: 'https://www.cnblogs.com/liyongqiang-cc/p/18636233', title: '.NET Core 委托原理解析' })">举报</a>
</div>
        