
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhxmdefj/p/18813692" title="发布于 2025-04-07 22:06">
    <span role="heading" aria-level="2">Fast Prefix Sum Implementation Using Subgroups in GLSL Compute Shaders</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        利用&nbsp;Vulkan 1.1 的 subgroup 特性加速 ComputeShader 的前缀和计算
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>利用&nbsp;Vulkan 1.1 的 subgroup 特性加速 ComputeShader 的前缀和计算，参考：<br>
<a href="https://www.khronos.org/blog/vulkan-subgroup-tutorial" target="_blank" rel="noopener nofollow">Vulkan Subgroup Tutorial - Khronos Blog - The Khronos Group Inc</a><br>
<a href="https://research.nvidia.com/publication/2016-03_single-pass-parallel-prefix-scan-decoupled-look-back" target="_blank" rel="noopener nofollow">Single-pass Parallel Prefix Scan with Decoupled Look-back | Research</a></p>
<h1 id="相关知识">相关知识</h1>
<h2 id="compute模型">Compute模型</h2>
<div class="mermaid">flowchart TD
    subgraph Subgroup["Subgroup"]
        Inv0["invocation 0"]
        Inv1["invocation 1"]
        InvDots["..."]
        Inv31["invocation 31"]
    end
    subgraph Workgroup["Workgroup"]
        SG0["Subgroup 0"]
        SG1["Subgroup 1"]
        SGDots["..."]
        SGM["Subgroup m"]
    end
    subgraph Dispatch["Dispatch"]
        WG0["Workgroup 0"]
        WG1["Workgroup 1"]
        WGDots["..."]
        WGN["Workgroup n"]
    end
    
    %% 设置水平排
    WG0 --- WG1 --- WGDots --- WGN
    SG0 --- SG1 --- SGDots --- SGM
    Inv0 --- Inv1 --- InvDots --- Inv31
</div><h2 id="shared-memory">shared memory</h2>
<p>shared 变量在单个 work group 内共享，本文用于记录多个 subgroup 的前缀和结果</p>
<h2 id="subgroup">subgroup</h2>
<p>GPU 上，线程通常以小组（通常为 32 或 64 个线程）的形式执行，本文利用 <strong>subgroupInclusiveAdd</strong>&nbsp;计算单个 subgroup 内的前缀和，具体参考 <a href="https://www.khronos.org/blog/vulkan-subgroup-tutorial" target="_blank" rel="noopener nofollow">https://www.khronos.org/blog/vulkan-subgroup-tutorial</a></p>
<p>假设有8个块，其active状态如下</p>
<pre><code class="language-makefile">id : 0  1  2  3  4  5  6  7
val: 0  1  0  1  1  0  0  1 
//subgroupInclusiveAdd
val: 0  1  1  2  3  3  3  4
</code></pre>
<h1 id="流程概要">流程概要</h1>
<p>目标：计算size = n的数据的前缀和</p>
<ol>
<li>拆分成 <code>work_group_nums = (n + 1023) / 1024</code> 个 local_size = &lt;1024, 1, 1&gt;的 work_group 的前缀和，一个 work_group 有 1024 个 invocation，1024 个 invocation 拆分成 32 个 sub_group 的前缀和 （sub_group_size = 32 on NIVDIA）</li>
<li>subgroupInclusiveAdd 计算 32 个 sub_group 内的前缀和，每个 sub_group 的最后一个结果（local_id = 31）存入 <code>shared uint sg_offset[32];</code> （shared 变量在当前 work_group 内共享）</li>
<li>subgroupInclusiveAdd 计算 sg_offset 的前缀和，直接更新到 sg_offset 内，那么 <code>sg_offset[gl_SubgroupSize - 1]</code> 即为当前 work_group 的前缀和，结果存入 <code>ss_wg_offset_[gl_WorkGroupID.x]</code></li>
<li>final pass 对 ss_wg_offset_ 再做一次前缀和，由于单位已经不是 work_group 内的 invocation，subgroupInclusiveAdd 无法 group 工作，于是手动遍历累加写入<code>atomicExchange(ss_wg_offset_[gl_WorkGroupID.x], final_res);</code></li>
</ol>
<h1 id="实现细节">实现细节</h1>
<pre><code class="language-glsl">layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
//shared memory跨subgroup暂存结果
shared uint sg_offset[32];

//sub_group_id
uint sg_id = gl_LocalInvocationIndex / gl_SubgroupSize;

// 前一个块是否有活跃voxel
uint prev_inv_actives = invocationActives(gl_GlobalInvocationID.x - 1) &gt; 0 ? 1 : 0;
// sub_group 内的前缀和
uint wg_offset = subgroupInclusiveAdd(prev_inv_actives);
// sg_offset 存储32个 sub_group 最后的前缀和
if (gl_SubgroupInvocationID == gl_SubgroupSize-1) {
	sg_offset[sg_id] = wg_offset;
}

barrier();

if (sg_id == 0) {
	// 对 sg_offset 计算一次前缀和，直接更新到 sg_offset 内
	sg_offset[gl_SubgroupInvocationID] = 
	subgroupInclusiveAdd(sg_offset[gl_SubgroupInvocationID]);
	// 结果存入 ss_wg_offset_, 省略ecnode过程
	atomicExchange(ss_wg_offset_[gl_WorkGroupID.x], your_value_encode);
}

barrier();

// 简单的 final pass, 省略

barrier();

</code></pre>
<p>tips: GLSL没有提供 atomicRead，可以通过 <code>atomicCompSwap(target, 0, 0)</code> 实现</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.007494396958333333" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-07 22:06">2025-04-07 22:06</span>&nbsp;
<a href="https://www.cnblogs.com/zhxmdefj">KelvinVS</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18813692" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18813692);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18813692', targetLink: 'https://www.cnblogs.com/zhxmdefj/p/18813692', title: 'Fast Prefix Sum Implementation Using Subgroups in GLSL Compute Shaders' })">举报</a>
</div>
        