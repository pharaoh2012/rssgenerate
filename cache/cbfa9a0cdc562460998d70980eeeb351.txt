
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18784667" title="发布于 2025-03-21 10:27">
    <span role="heading" aria-level="2">【消息利器RabbitMQ】RabbitMQ常用内容浅析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>以下是一篇关于 RabbitMQ 的博客内容，涵盖了从基础到死信队列的实现，以及 RabbitMQ 其他常用知识点的补充。内容逻辑清晰，代码完整，适合直接发布。</p>
<hr>
<h1 id="使用-rabbitmq-实现消息队列与死信队列从基础到高级">使用 RabbitMQ 实现消息队列与死信队列：从基础到高级</h1>
<p>在现代分布式系统中，消息队列（如 RabbitMQ）是解耦和异步通信的重要工具。本文将基于 Spring Boot 和 RabbitMQ，从基础到高级，逐步实现以下功能：</p>
<ol>
<li><strong>发送消息到队列</strong>。</li>
<li><strong>发送消息到交换机</strong>。</li>
<li><strong>消息可靠性机制</strong>：
<ul>
<li>消息确认机制（Publisher Confirms）。</li>
<li>消息持久化（Durable Queues and Messages）。</li>
<li>消费者手动确认（Manual Acknowledgement）。</li>
</ul>
</li>
<li><strong>死信队列（Dead Letter Queue, DLQ）</strong>：处理无法被正常消费的消息。</li>
</ol>
<p>我们将使用一个简单的 <code>User</code> 对象作为消息内容，<code>User</code> 类包含 <code>name</code> 和 <code>age</code> 字段。</p>
<hr>
<h2 id="1-创建-user-类">1. 创建 <code>User</code> 类</h2>
<p>首先，在 <code>service-a</code> 和 <code>service-b</code> 中创建 <code>User</code> 类。</p>
<pre><code class="language-java">package com.example.common;

import java.io.Serializable;

public class User implements Serializable {
    private String name;
    private int age;

    // 必须有无参构造函数
    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Getter 和 Setter
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{name='" + name + "', age=" + age + "}";
    }
}
</code></pre>
<hr>
<h2 id="2-发送消息到队列">2. 发送消息到队列</h2>
<h3 id="21-配置队列">2.1 配置队列</h3>
<p>在 <code>service-a</code> 中配置一个队列。</p>
<pre><code class="language-java">package com.example.servicea.config;

import org.springframework.amqp.core.Queue;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQQueueConfig {

    @Bean
    public Queue userQueue() {
        return new Queue("userQueue", true); // 第二个参数表示持久化
    }
}
</code></pre>
<h3 id="22-发送消息">2.2 发送消息</h3>
<p>在 <code>service-a</code> 中发送 <code>User</code> 对象到队列。</p>
<pre><code class="language-java">package com.example.servicea.service;

import com.example.common.User;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class QueueMessageSender {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void sendUserToQueue(User user) {
        rabbitTemplate.convertAndSend("userQueue", user);
        System.out.println("Sent user to queue: " + user);
    }
}
</code></pre>
<h3 id="23-接收消息">2.3 接收消息</h3>
<p>在 <code>service-b</code> 中监听队列并接收 <code>User</code> 对象。</p>
<pre><code class="language-java">package com.example.serviceb.service;

import com.example.common.User;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Service;

@Service
public class QueueMessageReceiver {

    @RabbitListener(queues = "userQueue")
    public void receiveUserFromQueue(User user) {
        System.out.println("Received user from queue: " + user);
    }
}
</code></pre>
<hr>
<h2 id="3-发送消息到交换机">3. 发送消息到交换机</h2>
<h3 id="31-配置交换机和队列">3.1 配置交换机和队列</h3>
<p>在 <code>service-a</code> 中配置一个 Direct Exchange 并绑定队列。</p>
<pre><code class="language-java">package com.example.servicea.config;

import org.springframework.amqp.core.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQExchangeConfig {

    @Bean
    public DirectExchange userExchange() {
        return new DirectExchange("userExchange", true, false); // 第二个参数表示持久化
    }

    @Bean
    public Queue userExchangeQueue() {
        return new Queue("userExchangeQueue", true); // 第二个参数表示持久化
    }

    @Bean
    public Binding bindingUserExchangeQueue(DirectExchange userExchange, Queue userExchangeQueue) {
        return BindingBuilder.bind(userExchangeQueue)
                .to(userExchange)
                .with("user.routing.key");
    }
}
</code></pre>
<h3 id="32-发送消息">3.2 发送消息</h3>
<p>在 <code>service-a</code> 中发送 <code>User</code> 对象到交换机。</p>
<pre><code class="language-java">package com.example.servicea.service;

import com.example.common.User;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class ExchangeMessageSender {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void sendUserToExchange(User user) {
        rabbitTemplate.convertAndSend("userExchange", "user.routing.key", user);
        System.out.println("Sent user to exchange: " + user);
    }
}
</code></pre>
<h3 id="33-接收消息">3.3 接收消息</h3>
<p>在 <code>service-b</code> 中监听队列并接收 <code>User</code> 对象。</p>
<pre><code class="language-java">package com.example.serviceb.service;

import com.example.common.User;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Service;

@Service
public class ExchangeMessageReceiver {

    @RabbitListener(queues = "userExchangeQueue")
    public void receiveUserFromExchange(User user) {
        System.out.println("Received user from exchange: " + user);
    }
}
</code></pre>
<hr>
<h2 id="4-消息可靠性">4. 消息可靠性</h2>
<h3 id="41-消息确认机制publisher-confirms">4.1 消息确认机制（Publisher Confirms）</h3>
<p>在 <code>application.yml</code> 中启用 Publisher Confirms 和 Returns。</p>
<pre><code class="language-yaml">spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    publisher-confirm-type: correlated  # 启用 Publisher Confirms
    publisher-returns: true            # 启用 Publisher Returns
</code></pre>
<p>在 <code>service-a</code> 中配置 <code>RabbitTemplate</code> 以支持 Publisher Confirms 和 Returns。</p>
<pre><code class="language-java">package com.example.servicea.config;

import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQConfig {

    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);

        // 启用 Publisher Confirms 和 Returns
        rabbitTemplate.setMandatory(true);

        // 设置确认回调
        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; {
            if (ack) {
                System.out.println("Message confirmed with correlation data: " + correlationData);
            } else {
                System.out.println("Message failed with cause: " + cause);
            }
        });

        // 设置返回回调
        rabbitTemplate.setReturnsCallback(returned -&gt; {
            System.out.println("Returned message: " + returned.getMessage());
            System.out.println("Reply code: " + returned.getReplyCode());
            System.out.println("Reply text: " + returned.getReplyText());
            System.out.println("Exchange: " + returned.getExchange());
            System.out.println("Routing key: " + returned.getRoutingKey());
        });

        return rabbitTemplate;
    }
}
</code></pre>
<h3 id="42-消息持久化">4.2 消息持久化</h3>
<p>在配置队列和交换机时启用持久化。</p>
<pre><code class="language-java">@Bean
public Queue userQueue() {
    return new Queue("userQueue", true); // 第二个参数表示持久化
}

@Bean
public DirectExchange userExchange() {
    return new DirectExchange("userExchange", true, false); // 第二个参数表示持久化
}
</code></pre>
<p>在发送消息时设置消息为持久化。</p>
<pre><code class="language-java">import org.springframework.amqp.core.Message;
import org.springframework.amqp.core.MessageDeliveryMode;
import org.springframework.amqp.core.MessageProperties;
import com.fasterxml.jackson.databind.ObjectMapper;

@Service
public class ReliableMessageSender {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private ObjectMapper objectMapper;

    public void sendUserWithConfirmation(User user) throws IOException {
        // 生成唯一的 CorrelationData
        CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());

        // 设置消息属性
        MessageProperties properties = new MessageProperties();
        properties.setContentType("application/json"); // 明确设置 content-type
        properties.setDeliveryMode(MessageDeliveryMode.PERSISTENT); // 持久化消息
        byte[] body = objectMapper.writeValueAsBytes(user);
        Message message = new Message(body, properties);

        // 发送消息
        rabbitTemplate.send("userExchange", "user.routing.key", message, correlationData);
        System.out.println("Sent user with confirmation: " + user);
    }
}
</code></pre>
<h3 id="43-消费者手动确认">4.3 消费者手动确认</h3>
<p>在 <code>service-b</code> 的 <code>application.yml</code> 中启用手动确认。</p>
<pre><code class="language-yaml">spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: manual
</code></pre>
<p>在 <code>service-b</code> 中实现手动确认逻辑。</p>
<pre><code class="language-java">package com.example.serviceb.service;

import com.example.common.User;
import com.rabbitmq.client.Channel;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.support.AmqpHeaders;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.stereotype.Service;

import java.io.IOException;

@Service
public class ManualAckReceiver {

    @RabbitListener(queues = "userQueue")
    public void receiveUser(User user, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long tag) throws IOException {
        try {
            System.out.println("Received user from queue: " + user);
            // 手动确认消息
            channel.basicAck(tag, false);
        } catch (Exception e) {
            // 拒绝消息并重新入队
            channel.basicNack(tag, false, true);
        }
    }
}
</code></pre>
<hr>
<h2 id="5-死信队列dead-letter-queue-dlq">5. 死信队列（Dead Letter Queue, DLQ）</h2>
<h3 id="51-配置死信队列">5.1 配置死信队列</h3>
<p>在 <code>service-a</code> 中配置死信队列和普通队列。</p>
<pre><code class="language-java">package com.example.servicea.config;

import org.springframework.amqp.core.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQDLXConfig {

    // 普通交换机
    @Bean
    public DirectExchange normalExchange() {
        return new DirectExchange("normalExchange");
    }

    // 普通队列，配置死信交换机
    @Bean
    public Queue normalQueue() {
        return QueueBuilder.durable("normalQueue")
                .deadLetterExchange("dlxExchange") // 指定死信交换机
                .deadLetterRoutingKey("dlx.routing.key") // 指定死信路由键
                .build();
    }

    // 绑定普通队列到普通交换机
    @Bean
    public Binding bindingNormalQueue(DirectExchange normalExchange, Queue normalQueue) {
        return BindingBuilder.bind(normalQueue)
                .to(normalExchange)
                .with("normal.routing.key");
    }

    // 死信交换机
    @Bean
    public DirectExchange dlxExchange() {
        return new DirectExchange("dlxExchange");
    }

    // 死信队列
    @Bean
    public Queue dlqQueue() {
        return new Queue("dlqQueue");
    }

    // 绑定死信队列到死信交换机
    @Bean
    public Binding bindingDlqQueue(DirectExchange dlxExchange, Queue dlqQueue) {
        return BindingBuilder.bind(dlqQueue)
                .to(dlxExchange)
                .with("dlx.routing.key");
    }
}
</code></pre>
<h3 id="52-发送消息到普通队列">5.2 发送消息到普通队列</h3>
<p>在 <code>service-a</code> 中发送消息到普通队列。</p>
<pre><code class="language-java">package com.example.servicea.service;

import com.example.common.User;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class NormalMessageSender {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void sendUserToNormalQueue(User user) {
        rabbitTemplate.convertAndSend("normalExchange", "normal.routing.key", user);
        System.out.println("Sent user to normal queue: " + user);
    }
}
</code></pre>
<h3 id="53-消费普通队列的消息">5.3 消费普通队列的消息</h3>
<p>在 <code>service-b</code> 中消费普通队列的消息，并模拟消息处理失败。</p>
<pre><code class="language-java">package com.example.serviceb.service;

import com.example.common.User;
import com.rabbitmq.client.Channel;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.support.AmqpHeaders;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.stereotype.Service;

import java.io.IOException;

@Service
public class NormalMessageReceiver {

    @RabbitListener(queues = "normalQueue")
    public void receiveUserFromNormalQueue(User user, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long tag) throws IOException {
        try {
            System.out.println("Received user from normal queue: " + user);
            if (user.getName().equals("Bob")) {
                throw new RuntimeException("Simulated processing failure");
            }
            // 手动确认消息
            channel.basicAck(tag, false);
        } catch (Exception e) {
            // 拒绝消息并重新入队
            channel.basicNack(tag, false, false); // 不重新入队，消息会被路由到死信队列
            System.out.println("Message rejected and sent to DLQ: " + user);
        }
    }
}
</code></pre>
<h3 id="54-消费死信队列的消息">5.4 消费死信队列的消息</h3>
<p>在 <code>service-b</code> 中消费死信队列的消息。</p>
<pre><code class="language-java">package com.example.serviceb.service;

import com.example.common.User;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Service;

@Service
public class DLQMessageReceiver {

    @RabbitListener(queues = "dlqQueue")
    public void receiveUserFromDLQ(User user) {
        System.out.println("Received user from DLQ: " + user);
    }
}
</code></pre>
<hr>
<h2 id="6-测试死信队列">6. 测试死信队列</h2>
<h3 id="61-发送消息">6.1 发送消息</h3>
<p>在 <code>service-a</code> 中发送消息到普通队列：</p>
<pre><code class="language-java">normalMessageSender.sendUserToNormalQueue(new User("Alice", 25));
normalMessageSender.sendUserToNormalQueue(new User("Bob", 30));
</code></pre>
<h3 id="62-观察日志">6.2 观察日志</h3>
<ul>
<li>正常消息（<code>Alice</code>）会被消费并确认：<pre><code>Received user from normal queue: User{name='Alice', age=25}
</code></pre>
</li>
<li>失败消息（<code>Bob</code>）会被拒绝并路由到死信队列：<pre><code>Received user from normal queue: User{name='Bob', age=30}
Message rejected and sent to DLQ: User{name='Bob', age=30}
Received user from DLQ: User{name='Bob', age=30}
</code></pre>
</li>
</ul>
<hr>
<h2 id="7-总结">7. 总结</h2>
<p>通过以上步骤，我们实现了 RabbitMQ 的死信队列功能：</p>
<ol>
<li><strong>普通队列</strong>：绑定到普通交换机，配置了死信交换机和路由键。</li>
<li><strong>死信队列</strong>：绑定到死信交换机，用于存储无法被正常消费的消息。</li>
<li><strong>消息处理</strong>：
<ul>
<li>正常消息被消费并确认。</li>
<li>失败消息被拒绝并路由到死信队列。</li>
</ul>
</li>
<li><strong>死信队列消费</strong>：单独消费死信队列中的消息。</li>
</ol>
<p>这种机制非常适合处理异常情况下的消息，确保系统的可靠性和可维护性。</p>
<hr>
<h2 id="8-其他常用知识点">8. 其他常用知识点</h2>
<h3 id="81-消息过期ttl">8.1 <strong>消息过期（TTL）</strong></h3>
<p>可以为队列或消息设置过期时间（Time-To-Live, TTL）。过期后的消息会被路由到死信队列。</p>
<h4 id="设置队列-ttl">设置队列 TTL：</h4>
<pre><code class="language-java">@Bean
public Queue normalQueue() {
    return QueueBuilder.durable("normalQueue")
            .deadLetterExchange("dlxExchange")
            .deadLetterRoutingKey("dlx.routing.key")
            .ttl(60000) // 设置队列中消息的 TTL 为 60 秒
            .build();
}
</code></pre>
<h4 id="设置消息-ttl">设置消息 TTL：</h4>
<pre><code class="language-java">MessageProperties properties = new MessageProperties();
properties.setExpiration("60000"); // 设置消息的 TTL 为 60 秒
Message message = new Message(body, properties);
rabbitTemplate.send("normalExchange", "normal.routing.key", message);
</code></pre>
<h3 id="82-优先级队列">8.2 <strong>优先级队列</strong></h3>
<p>可以为队列设置优先级，优先级高的消息会被优先消费。</p>
<h4 id="设置优先级队列">设置优先级队列：</h4>
<pre><code class="language-java">@Bean
public Queue priorityQueue() {
    return QueueBuilder.durable("priorityQueue")
            .maxPriority(10) // 设置最大优先级为 10
            .build();
}
</code></pre>
<h4 id="发送优先级消息">发送优先级消息：</h4>
<pre><code class="language-java">MessageProperties properties = new MessageProperties();
properties.setPriority(5); // 设置消息优先级为 5
Message message = new Message(body, properties);
rabbitTemplate.send("priorityExchange", "priority.routing.key", message);
</code></pre>
<hr>
<p>希望这篇博客对你有所帮助！如果有任何问题或建议，欢迎在评论区留言。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.02124705439236111" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-21 10:28">2025-03-21 10:27</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">15</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18784667" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18784667);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18784667', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18784667', title: '【消息利器RabbitMQ】RabbitMQ常用内容浅析' })">举报</a>
</div>
        