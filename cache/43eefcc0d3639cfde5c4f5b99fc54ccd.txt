
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dechinphy/p/18908706/cls" title="发布于 2025-06-03 17:50">
    <span role="heading" aria-level="2">Python中的cls变量</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/2277440/202506/2277440-20250603175022379-1530401633.png" alt="Python中的cls变量" class="desc_img">
        本文介绍了在Python的classmethod装饰的类方法的cls变量的意义，通过几个不同的示例对比，凸显cls变量在Python编程中的应用场景。对于大多数的场景来说，使用普通的Python类和函数定义即可。如果需要在类的外部使用类的内部函数，但是可能有多个不同初始化的类输入，那么可以使用staticmethod进行装饰。如果只有一个类，而有多种不同的输入场景下，可以使用classmethod进行装饰。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="技术背景">技术背景</h1>
<p>在Python的类型设计中，有时候会遇到一个<code>cls</code>参数。其实<code>cls</code>参数就是一个约定俗成的名称，用其他的名字也能正常运行但不建议这么用。它的作用类似于实例方法中的<code>self</code>参数，代表的是类本身，可以用于访问类的参数和类的方法。本文通过一些具体示例，来演示<code>cls</code>参数的功能和用法。</p>
<h1 id="简单类实现">简单类实现</h1>
<p>首先我们用普通的方法做一个最基本的测试案例：</p>
<pre><code class="language-python">class Test:
    def __init__(self):
        self.prefix = "Hello\t"

    def excute(self, x):
        print (self.prefix+x)

t = Test()
x = "Bob"
t.excute(x)
x = "Alice"
t.excute(x)
</code></pre>
<p>这里<code>Test</code>类型的操作逻辑是，在初始化函数中初始化一个prefix变量，然后在excute中调用打印函数，打印prefix变量和一个外部输入变量的整合字符串，执行效果如下：</p>
<pre><code class="language-bash">Hello   Bob
Hello   Alice
</code></pre>
<p>这个方法的一个局限性在于，类Test中的函数，如excute函数，必须要新建一个实例t之后，才能够调用到它的excute方法。如果跳过初始化的步骤直接调用excute方法：</p>
<pre><code class="language-python">class Test:
    def __init__(self):
        self.prefix = "Hello\t"

    def excute(self, x):
        print (self.prefix+x)

Test.excute()
</code></pre>
<p>运行结果会告诉你，这需要两个变量的输入才能够正常的运行：</p>
<pre><code class="language-bash">Traceback (most recent call last):
  File "/home/test_cls.py", line 8, in &lt;module&gt;
    Test.excute()
TypeError: Test.excute() missing 2 required positional arguments: 'self' and 'x'
</code></pre>
<p>例如，我们先初始化一个t实例，但是方法调用我们不调用t中的excute函数，而是直接调用Test类中的函数：</p>
<pre><code class="language-python">class Test:
    def __init__(self):
        self.prefix = "Hello\t"

    def excute(self, x):
        print (self.prefix+x)

t = Test()
x = "Bob"
Test.excute(t, x)
</code></pre>
<p>这样也是可以正常运行的：</p>
<pre><code class="language-bash">Hello   Bob
</code></pre>
<h1 id="classmethod方法">classmethod方法</h1>
<p>通过classmethod方法，可以允许我们不需要在外部对类初始化，而直接访问到类的内部属性、参数和函数。也就是对于classmethod装饰的函数，约定使用<code>cls</code>变量作为开头。</p>
<pre><code class="language-python">class Test:
    prefix = "Hello\t"
    @classmethod
    def excute(cls, x):
        print (cls.prefix+x)

x = "Bob"
Test.excute(x)
</code></pre>
<p>这样就可以直接在外部调用到类的内部函数：</p>
<pre><code class="language-bash">Hello   Bob
</code></pre>
<p>当然，前面提到过，这里即使换一个变量名，也是可以正常运行的：</p>
<pre><code class="language-python">class Test:
    prefix = "Hello\t"
    @classmethod
    def excute(self, x):
        print (self.prefix+x)

x = "Bob"
Test.excute(x)
</code></pre>
<p>因为第一个参数代表的是类本身，因此可以执行成功：</p>
<pre><code class="language-bash">Hello   Bob
</code></pre>
<p>这里需要说明的是，classmethod装饰器的作用，就是把函数的第一个参数相关的内容给省去了，如果不使用classmethod进行装饰，例如：</p>
<pre><code class="language-python">class Test:
    prefix = "Hello\t"
    def excute(cls, x):
        print (cls.prefix+x)

x = "Bob"
Test.excute(x)
</code></pre>
<p>这样运行会报错：</p>
<pre><code class="language-bash">Traceback (most recent call last):
  File "/home/test_cls.py", line 7, in &lt;module&gt;
    Test.excute(x)
TypeError: Test.excute() missing 1 required positional argument: 'x'
</code></pre>
<p>提示的内容是参数缺失，其实也就是少了一个初始化的步骤。那么有一种情况是，类似于prefix这种的类属性是在__init__函数中定义的，这是比较常见的情况。在这种情况下，如果不初始化一个实例，就无法访问到初始化参数。但是前面也提到了，cls就代表类本身，那么自然可以通过cls来访问类中的函数，包括初始化的函数：</p>
<pre><code class="language-python">class Test:
    def __init__(self):
        self.prefix = "Hello\t"

    @classmethod
    def excute(cls, x):
        cls.__init__(cls)
        print (cls.prefix+x)

x = "Bob"
Test.excute(x)
</code></pre>
<p>这个代码可以被正确执行：</p>
<pre><code class="language-bash">Hello   Bob
</code></pre>
<p>同时，通过classmethod，可以修改类的属性：</p>
<pre><code class="language-python">class Test:
    prefix = "Hello\t"
    @classmethod
    def excute(cls, x):
        print (cls.prefix+x)
        cls.prefix = cls.prefix+x+"\t"

x = "Bob"
Test.excute(x)
x = "Alice"
Test.excute(x)
</code></pre>
<p>这里在excute函数中，每次打印之后，都会修改一下prefix参数，所以打印输出结果如下：</p>
<pre><code class="language-bash">Hello   Bob
Hello   Bob     Alice
</code></pre>
<p>当然，修改属性这样的操作，在普通的类实现中也是可以操作的：</p>
<pre><code class="language-python">class Test:
    def __init__(self):
        self.prefix = "Hello\t"

    def excute(self, x):
        print (self.prefix+x)
        self.prefix = self.prefix+x+"\t"

t = Test()
x = "Bob"
t.excute(x)
x = "Alice"
t.excute(x)
</code></pre>
<p>用self得到的结果是一样的：</p>
<pre><code class="language-bash">Hello   Bob
Hello   Bob     Alice
</code></pre>
<p>如果不使用classmethod，也可以通过staticmethod来实现一个类似功能：</p>
<pre><code class="language-python">class Test:
    def __init__(self):
        self.prefix = "Hello\t"
    @staticmethod
    def excute(self, x):
        print (self.prefix+x)
        self.prefix = self.prefix+x+"\t"

t = Test()
x = "Bob"
Test.excute(t, x)
x = "Alice"
Test.excute(t, x)
</code></pre>
<p>但是staticmethod不对参数进行初始化，虽然可以在外部直接调用类函数，但是需要手动初始化一个实例。输出结果是一致的：</p>
<pre><code class="language-bash">Hello   Bob
Hello   Bob     Alice
</code></pre>
<h1 id="总结概要">总结概要</h1>
<p>本文介绍了在Python的classmethod装饰的类方法的cls变量的意义，通过几个不同的示例对比，凸显cls变量在Python编程中的应用场景。对于大多数的场景来说，使用普通的Python类和函数定义即可。如果需要在类的外部使用类的内部函数，但是可能有多个不同初始化的类输入，那么可以使用staticmethod进行装饰。如果只有一个类，而有多种不同的输入场景下，可以使用classmethod进行装饰。</p>
<h1 id="版权声明">版权声明</h1>
<p>本文首发链接为：<a href="https://www.cnblogs.com/dechinphy/p/cls.html" target="_blank">https://www.cnblogs.com/dechinphy/p/cls.html</a></p>
<p>作者ID：DechinPhy</p>
<p>更多原著文章：<a href="https://www.cnblogs.com/dechinphy/" target="_blank">https://www.cnblogs.com/dechinphy/</a></p>
<p>请博主喝咖啡：<a href="https://www.cnblogs.com/dechinphy/gallery/image/379634.html" target="_blank">https://www.cnblogs.com/dechinphy/gallery/image/379634.html</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7722843286585648" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-03 17:51">2025-06-03 17:50</span>&nbsp;
<a href="https://www.cnblogs.com/dechinphy">DECHIN</a>&nbsp;
阅读(<span id="post_view_count">84</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18908706);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18908706', targetLink: 'https://www.cnblogs.com/dechinphy/p/18908706/cls', title: 'Python中的cls变量' })">举报</a>
</div>
        