
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fanliang11/p/18824796" title="发布于 2025-04-14 14:47">
    <span role="heading" aria-level="2">surging 集成SuperSocket预发布版本2.0</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1 class="postTitle">一、概述</h1>
<p>周末在家试着扩展SuperSocket，因为之前都是只支持.net framework, 后面出现支持.NET CORE 的SuperSocket 2.0 ，然后集成进来和dotnetty 做下对比，dotnetty 有多强，我压测可以支持20w/s, 然后客户提供的服务器，通过外网压测网关，把上行速度50MB带宽的网络跑满了，引擎主机CPU只是在15%左右，完全没有跑满。然后再试试国人开发的SuperSocket看下性能怎么样。</p>
<p><img src="https://img2024.cnblogs.com/blog/192878/202504/192878-20250414135845385-1270343850.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/192878/202504/192878-20250414140035023-1798780107.png" alt="" loading="lazy"></p>
<p>&nbsp;<img src="https://img2024.cnblogs.com/blog/192878/202504/192878-20250414162935917-559758637.png" alt=""></p>
<p><img src="https://img2024.cnblogs.com/blog/192878/202504/192878-20250414163024987-673036605.png" alt=""></p>
<p>木舟 (Kayak) 是什么?</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 木舟(Kayak)是基于.NET6.0软件环境下的surging微服务引擎进行开发的, 平台包含了微服务和物联网平台。支持异步和响应式编程开发，功能包含了物模型,设备,产品,网络组件的统一管理和微服务平台下的注册中心，服务路由，模块，中间服务等管理。还有多协议适配(TCP,MQTT,UDP,CoAP,HTTP,Grpc,websocket,rtmp,httpflv,webservice,等),通过灵活多样的配置适配能够接入不同厂家不同协议等设备。并且通过设备告警,消息通知,数据可视化等功能。能够让你能快速建立起微服务物联网平台系统。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; 凯亚物联网平台：<a href="http://117.72.121.2:3100" rel="noopener nofollow" target="_blank">http://117.72.121.2:3100</a>（用户名：fanly&nbsp; 密码：123456）（木舟物联网有人取了，准备改名原神凯亚，<span class="text_XlFoe" data-text="true">凡是交托于他的任务，总能得到解决</span>）</p>
<p>&nbsp; &nbsp; 链路跟踪Skywalking V8:<a href="http://117.72.121.2:8080/" rel="noopener nofollow" target="_blank">http://117.72.121.2:8080/</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; surging 微服务引擎开源地址：<a href="https://github.com/fanliang11/surging" rel="noopener nofollow" target="_blank">https://github.com/fanliang11/surging</a>（后面surging 会移动到<a href="https://github.com/microsurging/" rel="noopener nofollow" target="_blank">microsurging</a>进行维护）</p>
<p>&nbsp;</p>
<h1 class="postTitle">二、集成SuperSocket</h1>
<p>作为去中心化的微服务引擎，相关的引擎组件，中间件都可以替换，就比如核心的RPC组件dotnetty 都可以替换成其它组件，下面介绍如何进行替换</p>
<p><strong>创建服务端消息监听SuperSocketServerMessageListener，<strong>需要继承<span style="color: rgba(0, 0, 0, 1)">IMessageListener</span></strong>，代码如下：</strong></p>
<div class="cnblogs_code">
<pre>  <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> SuperSocketServerMessageListener : IMessageListener, IDisposable
  {
      </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">event</span><span style="color: rgba(0, 0, 0, 1)"> ReceivedDelegate Received;

      </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span> ILogger&lt;SuperSocketServerMessageListener&gt;<span style="color: rgba(0, 0, 0, 1)"> _logger;

      </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> ITransportMessageDecoder _transportMessageDecoder;
      </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> ITransportMessageEncoder _transportMessageEncoder;
      </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> IServiceEngineLifetime _serviceEngineLifetime;

      </span><span style="color: rgba(0, 0, 255, 1)">public</span> SuperSocketServerMessageListener(ILogger&lt;SuperSocketServerMessageListener&gt;<span style="color: rgba(0, 0, 0, 1)"> logger, ITransportMessageCodecFactory codecFactory, IServiceEngineLifetime serviceEngineLifetime)
      {
          _logger </span>=<span style="color: rgba(0, 0, 0, 1)"> logger;
          _transportMessageEncoder </span>=<span style="color: rgba(0, 0, 0, 1)"> codecFactory.GetEncoder();
          _transportMessageDecoder </span>=<span style="color: rgba(0, 0, 0, 1)"> codecFactory.GetDecoder();
          _serviceEngineLifetime </span>=<span style="color: rgba(0, 0, 0, 1)"> serviceEngineLifetime;
      }
      </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span><span style="color: rgba(0, 0, 0, 1)"> Task StartAsync(EndPoint endPoint)
      {

          _serviceEngineLifetime.ServiceEngineStarted.Register(</span><span style="color: rgba(0, 0, 255, 1)">async</span> () =&gt;<span style="color: rgba(0, 0, 0, 1)">
          {
              </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)">
              {
                  </span><span style="color: rgba(0, 0, 255, 1)">var</span> ipEndPoint = endPoint <span style="color: rgba(0, 0, 255, 1)">as</span><span style="color: rgba(0, 0, 0, 1)"> IPEndPoint;
                  </span><span style="color: rgba(0, 0, 255, 1)">var</span> host = SuperSocketHostBuilder.Create&lt;TransportMessage, TransportMessagePipelineFilter&gt;<span style="color: rgba(0, 0, 0, 1)">()
              
                  .UsePackageHandler( (s, p) </span>=&gt;<span style="color: rgba(0, 0, 0, 1)">
                  {
                      Task.Run(</span><span style="color: rgba(0, 0, 255, 1)">async</span> () =&gt;<span style="color: rgba(0, 0, 0, 1)">
                      {
                          </span><span style="color: rgba(0, 0, 255, 1)">var</span> sender = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> SuperSocketServerMessageSender(_transportMessageEncoder, s);
                          </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> OnReceived(sender, p);
                      });
                      </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> ValueTask.CompletedTask;
                  })
                  .ConfigureSuperSocket(options </span>=&gt;<span style="color: rgba(0, 0, 0, 1)">
                  {
                      options.Name </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Echo Server</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
                      options.Logger </span>=<span style="color: rgba(0, 0, 0, 1)"> _logger; 
                      options.AddListener(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ListenOptions
                      {
                          Ip </span>=<span style="color: rgba(0, 0, 0, 1)"> ipEndPoint.Address.ToString(),
                          Port </span>=<span style="color: rgba(0, 0, 0, 1)"> ipEndPoint.Port,
                        
                      }
                      );
                  })
                  .ConfigureLogging((hostCtx, loggingBuilder) </span>=&gt;<span style="color: rgba(0, 0, 0, 1)">
                  {
                      loggingBuilder.AddConsole();
                  })
                  .Build();
                  </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> host.RunAsync();
              }
              </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception ex)
              {
                  _logger.LogError($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">SuperSocket服务主机启动失败，监听地址：{endPoint}。 </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
              }
          });

      }
       
      </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span><span style="color: rgba(0, 0, 0, 1)"> Task OnReceived(IMessageSender sender, TransportMessage message)
      {
          </span><span style="color: rgba(0, 0, 255, 1)">if</span> (Received == <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">)
              </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
          </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> Received(sender, message);
      }

      </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> Dispose()
      { 
      }
  }</span></pre>
</div>
<p><strong>创建客户端消息监听SuperSocketTransportClientFactory，需要继承<span style="color: rgba(0, 0, 0, 1)">ITransportClientFactory</span>，代码如下：</strong></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre> <span style="color: rgba(0, 0, 255, 1)">internal</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> SuperSocketTransportClientFactory : ITransportClientFactory, IDisposable
 {
     </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> ITransportMessageEncoder _transportMessageEncoder;
     </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> ITransportMessageDecoder _transportMessageDecoder;
     </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span> ILogger&lt;SuperSocketTransportClientFactory&gt;<span style="color: rgba(0, 0, 0, 1)"> _logger;
     </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> IServiceExecutor _serviceExecutor;
     </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> IHealthCheckService _healthCheckService;
     </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span> ConcurrentDictionary&lt;EndPoint, Lazy&lt;Task&lt;ITransportClient&gt;&gt;&gt; _clients = <span style="color: rgba(0, 0, 255, 1)">new</span> ConcurrentDictionary&lt;EndPoint, Lazy&lt;Task&lt;ITransportClient&gt;&gt;&gt;<span style="color: rgba(0, 0, 0, 1)">();

     </span><span style="color: rgba(0, 0, 255, 1)">public</span> SuperSocketTransportClientFactory(ITransportMessageCodecFactory codecFactory, IHealthCheckService healthCheckService, ILogger&lt;SuperSocketTransportClientFactory&gt;<span style="color: rgba(0, 0, 0, 1)"> logger)
 : </span><span style="color: rgba(0, 0, 255, 1)">this</span>(codecFactory, healthCheckService, logger, <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">)
     {
     }

     </span><span style="color: rgba(0, 0, 255, 1)">public</span> SuperSocketTransportClientFactory(ITransportMessageCodecFactory codecFactory, IHealthCheckService healthCheckService, ILogger&lt;SuperSocketTransportClientFactory&gt;<span style="color: rgba(0, 0, 0, 1)"> logger, IServiceExecutor serviceExecutor)
     {
         _transportMessageEncoder </span>=<span style="color: rgba(0, 0, 0, 1)"> codecFactory.GetEncoder();
         _transportMessageDecoder </span>=<span style="color: rgba(0, 0, 0, 1)"> codecFactory.GetDecoder();
         _logger </span>=<span style="color: rgba(0, 0, 0, 1)"> logger;
         _serviceExecutor </span>=<span style="color: rgba(0, 0, 0, 1)"> serviceExecutor;
         _healthCheckService </span>=<span style="color: rgba(0, 0, 0, 1)"> healthCheckService;
     }
     </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span> Task&lt;ITransportClient&gt;<span style="color: rgba(0, 0, 0, 1)"> CreateClientAsync(EndPoint endPoint)
     {
         </span><span style="color: rgba(0, 0, 255, 1)">var</span> key =<span style="color: rgba(0, 0, 0, 1)"> endPoint;
         </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (_logger.IsEnabled(LogLevel.Debug))
             _logger.LogDebug($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">准备为服务端地址：{key}创建客户端。</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
         </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)">
         {
             </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> _clients.GetOrAdd(key
          , k </span>=&gt; <span style="color: rgba(0, 0, 255, 1)">new</span> Lazy&lt;Task&lt;ITransportClient&gt;&gt;(<span style="color: rgba(0, 0, 255, 1)">async</span> () =&gt;<span style="color: rgba(0, 0, 0, 1)">
          {
              </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">客户端对象 </span>
              <span style="color: rgba(0, 0, 255, 1)">var</span> client = <span style="color: rgba(0, 0, 255, 1)">new</span> EasyClient&lt;TransportMessage&gt;(<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> TransportMessagePipelineFilter()).AsClient();
              </span><span style="color: rgba(0, 0, 255, 1)">var</span> messageListener = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> MessageListener();
              </span><span style="color: rgba(0, 0, 255, 1)">var</span> messageSender = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> SuperSocketMessageClientSender(_transportMessageEncoder, client);
              </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> client.ConnectAsync(endPoint);
              client.PackageHandler </span>+= <span style="color: rgba(0, 0, 255, 1)">async</span> (sender, package) =&gt;<span style="color: rgba(0, 0, 0, 1)">
              {
                  </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> messageListener.OnReceived(messageSender, package);
              };
              client.StartReceive();
              </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建客户端</span>
              <span style="color: rgba(0, 0, 255, 1)">var</span> transportClient = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> TransportClient(messageSender, messageListener, _logger, _serviceExecutor);
              </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> transportClient;
          }
              )).Value;</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">返回实例</span>
<span style="color: rgba(0, 0, 0, 1)">         }
         </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)">
         {
             </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">移除</span>
             _clients.TryRemove(key, <span style="color: rgba(0, 0, 255, 1)">out</span> <span style="color: rgba(0, 0, 255, 1)">var</span><span style="color: rgba(0, 0, 0, 1)"> value);
             </span><span style="color: rgba(0, 0, 255, 1)">var</span> ipEndPoint = endPoint <span style="color: rgba(0, 0, 255, 1)">as</span><span style="color: rgba(0, 0, 0, 1)"> IPEndPoint;
             </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">标记这个地址是失败的请求</span>
             <span style="color: rgba(0, 0, 255, 1)">if</span> (ipEndPoint != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">)
                 </span><span style="color: rgba(0, 0, 255, 1)">await</span> _healthCheckService.MarkFailure(<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> IpAddressModel(ipEndPoint.Address.ToString(), ipEndPoint.Port));
             </span><span style="color: rgba(0, 0, 255, 1)">throw</span><span style="color: rgba(0, 0, 0, 1)">;
         }
     }


     </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> Dispose()
     {
         </span><span style="color: rgba(0, 0, 255, 1)">foreach</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> client <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> _clients.Values)
         {
             (client </span><span style="color: rgba(0, 0, 255, 1)">as</span> IDisposable)?<span style="color: rgba(0, 0, 0, 1)">.Dispose();
         }
     }
 }</span></pre>
</div>
<p><strong>注册初始化SuperSocket引擎模块，需要继承<span style="color: rgba(0, 0, 0, 1)">EnginePartModule，</span> 代码如下：</strong></p>
<div class="cnblogs_code">
<pre>  <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> SuperSocketModule : EnginePartModule
  {
      </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">override</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> Initialize(AppModuleContext context)
      {
          </span><span style="color: rgba(0, 0, 255, 1)">base</span><span style="color: rgba(0, 0, 0, 1)">.Initialize(context);
      }

      </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
      <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> Inject dependent third-party components
      </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
      <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="builder"&gt;&lt;/param&gt;</span>
      <span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">override</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> RegisterBuilder(ContainerBuilderWrapper builder)
      {
          </span><span style="color: rgba(0, 0, 255, 1)">base</span><span style="color: rgba(0, 0, 0, 1)">.RegisterBuilder(builder);
          builder.Register(provider </span>=&gt;<span style="color: rgba(0, 0, 0, 1)">
          {
              IServiceExecutor serviceExecutor </span>= <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
              </span><span style="color: rgba(0, 0, 255, 1)">if</span> (provider.IsRegistered(<span style="color: rgba(0, 0, 255, 1)">typeof</span><span style="color: rgba(0, 0, 0, 1)">(IServiceExecutor)))
                  serviceExecutor </span>= provider.Resolve&lt;IServiceExecutor&gt;<span style="color: rgba(0, 0, 0, 1)">();
              </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span> SuperSocketTransportClientFactory(provider.Resolve&lt;ITransportMessageCodecFactory&gt;<span style="color: rgba(0, 0, 0, 1)">(),
                    provider.Resolve</span>&lt;IHealthCheckService&gt;<span style="color: rgba(0, 0, 0, 1)">(),
                  provider.Resolve</span>&lt;ILogger&lt;SuperSocketTransportClientFactory&gt;&gt;<span style="color: rgba(0, 0, 0, 1)">(),
                  serviceExecutor);
          }).As(</span><span style="color: rgba(0, 0, 255, 1)">typeof</span><span style="color: rgba(0, 0, 0, 1)">(ITransportClientFactory)).SingleInstance();
          </span><span style="color: rgba(0, 0, 255, 1)">if</span> (AppConfig.ServerOptions.Protocol == CommunicationProtocol.Tcp ||<span style="color: rgba(0, 0, 0, 1)">
              AppConfig.ServerOptions.Protocol </span>==<span style="color: rgba(0, 0, 0, 1)"> CommunicationProtocol.None)
          {
              RegisterDefaultProtocol(builder);
          }
      }

      </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> RegisterDefaultProtocol(ContainerBuilderWrapper builder)
      {
          builder.Register(provider </span>=&gt;<span style="color: rgba(0, 0, 0, 1)">
          {
              </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span> SuperSocketServerMessageListener(provider.Resolve&lt;ILogger&lt;SuperSocketServerMessageListener&gt;&gt;<span style="color: rgba(0, 0, 0, 1)">(),
                    provider.Resolve</span>&lt;ITransportMessageCodecFactory&gt;<span style="color: rgba(0, 0, 0, 1)">(),
                       provider.Resolve</span>&lt;IServiceEngineLifetime&gt;<span style="color: rgba(0, 0, 0, 1)">());
          }).SingleInstance();
          builder.Register(provider </span>=&gt;<span style="color: rgba(0, 0, 0, 1)">
          {
              </span><span style="color: rgba(0, 0, 255, 1)">var</span> serviceExecutor = provider.ResolveKeyed&lt;IServiceExecutor&gt;<span style="color: rgba(0, 0, 0, 1)">(CommunicationProtocol.Tcp.ToString());
              </span><span style="color: rgba(0, 0, 255, 1)">var</span> messageListener = provider.Resolve&lt;SuperSocketServerMessageListener&gt;<span style="color: rgba(0, 0, 0, 1)">();
              </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span> DefaultServiceHost(<span style="color: rgba(0, 0, 255, 1)">async</span> endPoint =&gt;<span style="color: rgba(0, 0, 0, 1)">
              {
                  </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> messageListener.StartAsync(endPoint);
                  </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> messageListener;
              }, serviceExecutor);
          }).As</span>&lt;IServiceHost&gt;<span style="color: rgba(0, 0, 0, 1)">();
      }
  }</span></pre>
</div>
<p><strong>客户端服务端消息发送，需要继承<span style="color: rgba(0, 0, 0, 1)">IMessageSender， 代码如下：</span></strong></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">abstract</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> SuperSocketMessageSender
    {
        </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> ITransportMessageEncoder _transportMessageEncoder;

        </span><span style="color: rgba(0, 0, 255, 1)">protected</span><span style="color: rgba(0, 0, 0, 1)"> SuperSocketMessageSender(ITransportMessageEncoder transportMessageEncoder)
        {
            _transportMessageEncoder </span>=<span style="color: rgba(0, 0, 0, 1)"> transportMessageEncoder;
        }

        </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">[] GetByteBuffer(TransportMessage message)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">var</span> data =<span style="color: rgba(0, 0, 0, 1)"> _transportMessageEncoder.Encode(message).ToList();
            data.AddRange(Encoding.UTF8.GetBytes(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">\r\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">));
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">var buffer = PooledByteBufferAllocator.Default.Buffer();</span>
            <span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> data.ToArray();
        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> SuperSocketMessageClientSender : SuperSocketMessageSender, IMessageSender
    {
        </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span> IEasyClient&lt;TransportMessage&gt;<span style="color: rgba(0, 0, 0, 1)"> _client; 

        </span><span style="color: rgba(0, 0, 255, 1)">public</span> SuperSocketMessageClientSender(ITransportMessageEncoder transportMessageEncoder, IEasyClient&lt;TransportMessage&gt; client) : <span style="color: rgba(0, 0, 255, 1)">base</span><span style="color: rgba(0, 0, 0, 1)">(transportMessageEncoder)
        {
            _client </span>=<span style="color: rgba(0, 0, 0, 1)"> client; 
        }

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 发送消息。
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="message"&gt;</span><span style="color: rgba(0, 128, 0, 1)">消息内容。</span><span style="color: rgba(128, 128, 128, 1)">&lt;/param&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;</span><span style="color: rgba(0, 128, 0, 1)">一个任务。</span><span style="color: rgba(128, 128, 128, 1)">&lt;/returns&gt;</span> 
        <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span><span style="color: rgba(0, 0, 0, 1)"> Task SendAsync(TransportMessage message)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">var</span> buffer =<span style="color: rgba(0, 0, 0, 1)"> GetByteBuffer(message);
           </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> _client.SendAsync(buffer); 
        }

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 发送消息并清空缓冲区。
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="message"&gt;</span><span style="color: rgba(0, 128, 0, 1)">消息内容。</span><span style="color: rgba(128, 128, 128, 1)">&lt;/param&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;</span><span style="color: rgba(0, 128, 0, 1)">一个任务。</span><span style="color: rgba(128, 128, 128, 1)">&lt;/returns&gt;</span> 
        <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span><span style="color: rgba(0, 0, 0, 1)"> Task SendAndFlushAsync(TransportMessage message)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">var</span> buffer =<span style="color: rgba(0, 0, 0, 1)"> GetByteBuffer(message);
            </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> _client.SendAsync(buffer); 
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> _client.StartReceive();
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">var p=  await _client.ReceiveAsync();</span>
<span style="color: rgba(0, 0, 0, 1)">        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">#region</span> Implementation of IMessageSender
    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> SuperSocketServerMessageSender : SuperSocketMessageSender, IMessageSender
    {
        </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> IAppSession _session;

        </span><span style="color: rgba(0, 0, 255, 1)">public</span> SuperSocketServerMessageSender(ITransportMessageEncoder transportMessageEncoder, IAppSession session) : <span style="color: rgba(0, 0, 255, 1)">base</span><span style="color: rgba(0, 0, 0, 1)">(transportMessageEncoder)
        {
            _session </span>=<span style="color: rgba(0, 0, 0, 1)"> session;
        }


        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 发送消息。
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="message"&gt;</span><span style="color: rgba(0, 128, 0, 1)">消息内容。</span><span style="color: rgba(128, 128, 128, 1)">&lt;/param&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;</span><span style="color: rgba(0, 128, 0, 1)">一个任务。</span><span style="color: rgba(128, 128, 128, 1)">&lt;/returns&gt;</span> 
        <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span><span style="color: rgba(0, 0, 0, 1)"> Task SendAsync(TransportMessage message)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">var</span> buffer =<span style="color: rgba(0, 0, 0, 1)"> GetByteBuffer(message);
           </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> _session.SendAsync(buffer);
        }

        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 发送消息并清空缓冲区。
        </span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="message"&gt;</span><span style="color: rgba(0, 128, 0, 1)">消息内容。</span><span style="color: rgba(128, 128, 128, 1)">&lt;/param&gt;</span>
        <span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;</span><span style="color: rgba(0, 128, 0, 1)">一个任务。</span><span style="color: rgba(128, 128, 128, 1)">&lt;/returns&gt;</span> 
        <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">async</span><span style="color: rgba(0, 0, 0, 1)"> Task SendAndFlushAsync(TransportMessage message)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">var</span> buffer =<span style="color: rgba(0, 0, 0, 1)"> GetByteBuffer(message);
           </span><span style="color: rgba(0, 0, 255, 1)">await</span><span style="color: rgba(0, 0, 0, 1)"> _session.SendAsync(buffer);
        }

    }
    </span><span style="color: rgba(0, 0, 255, 1)">#endregion</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>SuperSocket过滤器，需要继承<span style="color: rgba(0, 0, 0, 1)">TerminatorPipelineFilter&lt;TransportMessage&gt;， 代码如下：</span></strong></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> TransportMessagePipelineFilter : TerminatorPipelineFilter&lt;TransportMessage&gt;<span style="color: rgba(0, 0, 0, 1)">
    {
        </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span><span style="color: rgba(0, 0, 0, 1)"> ITransportMessageDecoder _transportMessageDecoder;
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> TransportMessagePipelineFilter() : <span style="color: rgba(0, 0, 255, 1)">base</span>(<span style="color: rgba(0, 0, 255, 1)">new</span>[] { (<span style="color: rgba(0, 0, 255, 1)">byte</span>)<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">\r</span><span style="color: rgba(128, 0, 0, 1)">'</span>, (<span style="color: rgba(0, 0, 255, 1)">byte</span>)<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)"> })
        {
            _transportMessageDecoder </span>= ServiceLocator.GetService&lt;ITransportMessageCodecFactory&gt;<span style="color: rgba(0, 0, 0, 1)">().GetDecoder();
        }


        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">override</span> TransportMessage Filter(<span style="color: rgba(0, 0, 255, 1)">ref</span> SequenceReader&lt;<span style="color: rgba(0, 0, 255, 1)">byte</span>&gt;<span style="color: rgba(0, 0, 0, 1)"> bufferStream)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)">
            {
                </span><span style="color: rgba(0, 0, 255, 1)">var</span> bytes = bufferStream.Sequence.Slice(<span style="color: rgba(128, 0, 128, 1)">0</span>, bufferStream.Length - <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">).ToArray();
                </span><span style="color: rgba(0, 0, 255, 1)">var</span> transportMessage =<span style="color: rgba(0, 0, 0, 1)"> _transportMessageDecoder.Decode(bytes);
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> transportMessage;
            }
            </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)">
            {
                bufferStream.Advance(bufferStream.Length);
            }
        }
    }</span></pre>
</div>
<p>&nbsp;</p>
<h1 class="postTitle">三、如何加载<strong>SuperSocket引擎组件</strong></h1>
<p><strong>第一种方式：</strong></p>
<p>去掉Surging.Core.DotNetty引用，添加Surging.Core.SuperSocket</p>
<p><img src="https://img2024.cnblogs.com/blog/192878/202504/192878-20250414142704298-351849466.png" alt="" loading="lazy"></p>
<p>&nbsp;第二种方式</p>
<p>添加Surging.Core.DotNetty，Surging.Core.SuperSocket这两个应用，在surgingSettings.json配置文件中把Packages的using列表中的DotNettyModule改成SuperSocketModule</p>
<p><img src="https://img2024.cnblogs.com/blog/192878/202504/192878-20250414143111642-1908908321.png" alt="" loading="lazy"></p>
<h2>四、结果</h2>
<p>可能是预发布版本，在测试当中还是有些问题，kayka物联网平台换成SuperSocket还是会发生错误，暂时没有条件进行压测，可能是因为预发布版本，作者还需要完善，等正式版之后再压测做对比吧</p>
<p>&nbsp;</p>
<h2>五、总结</h2>
<p>因为这段时间比较忙，还需要协助客户拆分服务，缓存降级，消息队列，等忙完这段时间，线上物联网平台会开通端口给用户进行测试，我也会努力把物联网进行完善，让微服务物联网平台能走向新的高度。</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.28958806543055554" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-14 17:23">2025-04-14 14:47</span>&nbsp;
<a href="https://www.cnblogs.com/fanliang11">fanly11</a>&nbsp;
阅读(<span id="post_view_count">129</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18824796);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18824796', targetLink: 'https://www.cnblogs.com/fanliang11/p/18824796', title: 'surging 集成SuperSocket预发布版本2.0' })">举报</a>
</div>
        