
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yangtb/p/19052650" title="发布于 2025-08-22 21:01">
    <span role="heading" aria-level="2">从0.99到1实现一个Windows上的虚拟hid键盘设备</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在虚拟机、远程控制、或者诸如云电脑之类的应用中，我们经常能够看到虚拟设备的身影。对于初学者来说，从0到1实现一个虚拟设备或许非常困难，但从0.99到1改造一个虚拟设备就简单多了。本文根据微软提供的UMDF版本HID minidriver的示例代码，稍加改造，将其变成一个虚拟HID键盘设备。</p>
<h1 id="hid-minidriver-sample">HID minidriver sample</h1>
<p>微软提供的这个示例代码的仓库地址是：<a href="https://github.com/microsoft/Windows-driver-samples/tree/main/hid/vhidmini2" target="_blank" rel="noopener nofollow">https://github.com/microsoft/Windows-driver-samples/tree/main/hid/vhidmini2</a></p>
<p>这个示例代码实现了一个hid驱动程序和一个客户端，演示了客户端如何与hid驱动程序通信。我想将其改造成一个HID键盘设备，通过客户端与其通信，控制其按键。</p>
<h1 id="第一步-修改hid报告描述符">第一步 修改HID报告描述符</h1>
<p>原代码的HID报告描述符包含了一个Vender Usage的顶级集合，集合里定义了一个HID报告，用于客户端和驱动程序的通信。这个集合可以保留下来继续用来通信。</p>
<p>要实现HID键盘的功能，需要一个Keyboard的顶级集合，下面是一个常见的HID键盘的报告描述符，我把LED相关的输出报告删除了，仅保留了按键相关的输入报告。报告描述符直接添加到原来的报告描述符的尾部即可。</p>
<pre><code>HID_REPORT_DESCRIPTOR       G_DefaultReportDescriptor[] = {
    //......
    //原本的报告描述符
    //......

    0x05, 0x01,        // USAGE_PAGE (Generic Desktop)
    0x09, 0x06,        // USAGE (Keyboard)
    0xA1, 0x01,        // COLLECTION (Application)

    0x85, 0x02,        // REPORT_ID (2)

    0x05, 0x07,        //   USAGE_PAGE (Keyboard)
    0x19, 0xE0,        //   USAGE_MINIMUM (Left Control)
    0x29, 0xE7,        //   USAGE_MAXIMUM (Right GUI)
    0x15, 0x00,        //   LOGICAL_MINIMUM (0)
    0x25, 0x01,        //   LOGICAL_MAXIMUM (1)
    0x75, 0x01,        //   REPORT_SIZE (1)
    0x95, 0x08,        //   REPORT_COUNT (8)
    0x81, 0x02,        //   INPUT (Data, Var, Abs)

    0x95, 0x01,        //   REPORT_COUNT (1)
    0x75, 0x08,        //   REPORT_SIZE (8)
    0x81, 0x03,        //   INPUT (Const, Var, Abs)

    0x95, 0x06,        //   REPORT_COUNT (6) 
    0x75, 0x08,        //   REPORT_SIZE (8)
    0x15, 0x00,        //   LOGICAL_MINIMUM (0)
    0x25, 0x65,        //   LOGICAL_MAXIMUM (101)
    0x05, 0x07,        //   USAGE_PAGE (Keyboard)
    0x19, 0x00,        //   USAGE_MINIMUM (No Event)
    0x29, 0x65,        //   USAGE_MAXIMUM (Keyboard Application)
    0x81, 0x00,        //   INPUT (Data, Ary, Abs)

    0xC0,              // END_COLLECTION
};
</code></pre>
<p>添加了报告描述符后，安装一下看下效果，安装的方法是，在管理员权限的cmd中，执行以下命令</p>
<pre><code>devcon.exe install "VhidminiUm.inf" root\VhidminiUm
</code></pre>
<p>或者</p>
<pre><code>devgen.exe /add /bus root /hardwareid root\VhidminiUm
pnputil /add-driver "VhidminiUm.inf" /install
</code></pre>
<p>以上两种方式都是创建一个硬件ID为root\VhidminiUm的设备，然后将我们编译的驱动安装到设备上。devcon和devgen可以在WDK的工具目录下找到，pnputil是全局安装的内置工具。因为这是一个UMDF驱动程序，所以不要进入测试模式也可以安装。</p>
<p>安装完成后可以在设备管理器看到一个HID minidriver设备，在它下面有一个键盘设备和一个Vendor-defined设备，对应HID报告描述符中的两个顶级集合。</p>
<p><img alt="img" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2033325/202508/2033325-20250822144443601-1218356052.png" class="lazyload"></p>
<h1 id="第二步-修改ioctl_hid_read_report请求的处理函数">第二步 修改IOCTL_HID_READ_REPORT请求的处理函数</h1>
<p>现在，这个键盘设备还不会上报任何按键。要让键盘设备上报按键，需要在IOCTL_HID_READ_REPORT请求的处理函数中提供正确的HID报告。</p>
<p>根据HID报告描述符，HID报告包含报告ID在内应该有9个字节</p>
<table>
<thead>
<tr>
<th>byte(s)</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>报告ID(2)</td>
</tr>
<tr>
<td>1</td>
<td>每个bit代表一个控制键，1表示按下</td>
</tr>
<tr>
<td>2</td>
<td>保留</td>
</tr>
<tr>
<td>3~8</td>
<td>每个字节表示一个按下的按键</td>
</tr>
</tbody>
</table>
<p>例如，下面这个HID报告表示'A'键处于按下状态</p>
<pre><code>[0x02, 0, 0, 0x04, 0, 0, 0, 0, 0]
</code></pre>
<p>在接收到IOCTL_HID_READ_REPORT请求的时候，把上面的数据复制到输出缓冲区，就可以模拟'A'键按下的状态。在后续的IOCTL_HID_READ_REPORT请求中，我们再将下面的数据复制到输出缓冲区，就可以模拟'A'键抬起的状态</p>
<pre><code>[0x02, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<p>在原始的示例代码中，IOCTL_HID_READ_REPORT请求没有直接在处理函数中进行处理，而是传递给另一个请求队列，然后由一个定时器去轮询，当这个队列中有请求时就处理这个请求。这模拟的是真实设备中：</p>
<ol>
<li>请求达到时设备还没有准备好数据，请求处理未完成状态</li>
<li>一定时间后（也就是定时器到期后），数据准备好了，填充数据，完成请求</li>
</ol>
<p>改造后的虚拟HID键盘设备中，这个逻辑可以保留，也可以删除。</p>
<ol>
<li>如果保留的话，将定时器的处理函数EvtTimerFunc修改为</li>
</ol>
<pre><code>void
EvtTimerFunc(
    _In_  WDFTIMER          Timer
    )
{
    NTSTATUS                status;
    WDFQUEUE                queue;
    PMANUAL_QUEUE_CONTEXT   queueContext;
    WDFREQUEST              request;
    HIDMINI_KBD_INPUT_REPORT    readReport;

    KdPrint(("EvtTimerFunc\n"));

    queue = (WDFQUEUE)WdfTimerGetParentObject(Timer);
    queueContext = GetManualQueueContext(queue);

    //
    // see if we have a request in manual queue
    //
    status = WdfIoQueueRetrieveNextRequest(
                            queueContext-&gt;Queue,
                            &amp;request);

    if (NT_SUCCESS(status)) {

        memset(&amp;readReport, 0, sizeof(readReport));
        readReport.ReportId = 2;
        readReport.Data[2] = 0x04; //'A'键

        status = RequestCopyFromBuffer(request,
                            &amp;readReport,
                            sizeof(readReport));

        WdfRequestComplete(request, status);
    }
}
</code></pre>
<p>其中，_HIDMINI_KBD_INPUT_REPORT是在common.h中新增的结构体，用来表示键盘设备的HID输入报告，代码如下</p>
<pre><code>typedef struct _HIDMINI_KBD_INPUT_REPORT {

    UCHAR ReportId;

    UCHAR Data[8];

} HIDMINI_KBD_INPUT_REPORT, * PHIDMINI_KBD_INPUT_REPORT;
</code></pre>
<ol start="2">
<li>如果不需要这个定时器逻辑的话，就将ReadReport函数改为</li>
</ol>
<pre><code>NTSTATUS
ReadReport(
    _In_  PQUEUE_CONTEXT    QueueContext,
    _In_  WDFREQUEST        Request,
    _Always_(_Out_)
          BOOLEAN*          CompleteRequest
    )
{
    NTSTATUS                status;
    HIDMINI_KBD_INPUT_REPORT    readReport;

    UNREFERENCED_PARAMETER(CompleteRequest);
    KdPrint(("ReadReport\n"));

    memset(&amp;readReport, 0, sizeof(readReport));
    readReport.ReportId = 2;
    readReport.Data[2] = 0x4;

    status = RequestCopyFromBuffer(Request,
        &amp;readReport,
        sizeof(readReport));

    return status;
}
</code></pre>
<p>修改完代码后，再次安装，就会发现，彷佛有一个键盘一直在长按'A'键。</p>
<h1 id="第三步-使用客户端控制按键的状态">第三步 使用客户端控制按键的状态</h1>
<p>现在这个驱动一旦安装之后，就会马上按下'A'键，并且不会抬起，因此需要一个客户端来控制按哪个键，什么时候按下，什么时候抬起。</p>
<p>原来的代码定义了一个vendor defined设备，这个设备的输出报告中可以传递一个字节的数据，那么客户端就可以利用这个字节将需要按下的HID键码发送给设备。如果要控制多个按键的话，就需要修改这个输出报告，本文先讨论单个按键的情况。</p>
<p>客户端通过IOCTL_HID_WRITE_REPORT请求将输出报告发送到设备，输出报告携带了一个字节的数据，在该请求的处理函数WriteReport中，这个字节的数据被保存到了设备上下文的自定义字段中，代码如下</p>
<pre><code>QueueContext-&gt;DeviceContext-&gt;DeviceData = outputReport-&gt;Data;
</code></pre>
<p>这是原始的代码，不需要修改，需要修改的是第二步中IOCTL_HID_READ_REPORT请求的处理函数，将固定填充'A'键键码的代码，改成用DeviceData来填充</p>
<pre><code>readReport.Data[2] = QueueContext-&gt;DeviceContext-&gt;DeviceData;
</code></pre>
<p>这样一来，客户端向设备发送哪个键的HID键码，设备就会模拟哪个键的按下，客户端如果发送0，设备就会模拟按键抬起。</p>
<p>下面是一个用WPF实现的客户端的代码，这个客户端实现的功能是</p>
<ol>
<li>当按下Alt+字母键的组合键时，让虚拟设备模拟该字母键长按</li>
<li>当按下Alt+F1的组合键时，让虚拟设备模拟按键抬起</li>
</ol>
<pre><code>using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Windows;
using System.Windows.Input;
using System.Windows.Interop;
using HidSharp;

namespace VirtualHidKbdClient
{
    /// &lt;summary&gt;
    /// Interaction logic for MainWindow.xaml
    /// &lt;/summary&gt;
    public partial class MainWindow : Window
    {
        private const int AltKeyEventId = 9000;

        private bool PressedKey = false;
        private HidStream _stream;

        [DllImport("user32.dll")]
        public static extern uint MapVirtualKey(uint uCode, uint type);

        [DllImport("user32.dll")]
        public static extern bool RegisterHotKey(IntPtr hWnd, int id, uint fsModifiers, uint vk);

        [DllImport("user32.dll")]
        public static extern bool UnregisterHotKey(IntPtr hWnd, int id);

        public MainWindow()
        {
            InitializeComponent();
            SourceInitialized += MainWindow_SourceInitialized;
        }

        private void MainWindow_SourceInitialized(object? sender, EventArgs e)
        {
            var handle = new WindowInteropHelper(this).Handle;
            var source = HwndSource.FromHwnd(handle);
            source?.AddHook(HwndHook);

            //注册Alt+F1和Alt+字母键的全局快捷键
            for (int i = (int)Key.A; i &lt;= (int)Key.Z; i++)
            {
                RegisterHotKey(handle, AltKeyEventId, (uint)ModifierKeys.Alt, (uint)KeyInterop.VirtualKeyFromKey((Key)i));
            }
            RegisterHotKey(handle, AltKeyEventId, (uint)ModifierKeys.Alt, (uint)KeyInterop.VirtualKeyFromKey(Key.F1));

            //找到虚拟设备下面的vendor defined设备
            var devices = DeviceList.Local.GetHidDevices(0xDEED, 0xFEED);
            foreach (var d in devices)
            {
                Console.WriteLine(d.DevicePath);
            }

            var device = devices.FirstOrDefault(d =&gt; !d.DevicePath.EndsWith("kbd"));

            _stream = device.Open();
        }

        private IntPtr HwndHook(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled)
        {
            const int wmHotkey = 0x0312;

            switch (msg)
            {
                case wmHotkey:
                    switch (wParam.ToInt32())
                    {
                        case AltKeyEventId:
                            var lp = lParam.ToInt32();
                            var virtualKey = lp &gt;&gt; 16;
                            var key = KeyInterop.KeyFromVirtualKey(virtualKey);
                            //虚拟键码到HID键码的转换，字母键是连续的，所以可以简单写成这样
                            var hidKey = virtualKey - 61;
                            var charKey = (char)MapVirtualKey((uint)virtualKey, 2);

                            if (key == Key.F1 &amp;&amp; PressedKey)
                            {
                                _stream.Write([1, 0]);
                                MessageBox.Show($"cancel long press");
                                PressedKey = false;
                            }

                            else if(key != Key.F1 &amp;&amp; !PressedKey)
                            {
                                PressedKey = true;
                                _stream.Write([1, (byte)hidKey]);
                                MessageBox.Show($"long press {charKey}");
                            }

                            break;
                    }
                    break;
            }
            return IntPtr.Zero;
        }

        protected override void OnClosing(CancelEventArgs e)
        {
            base.OnClosing(e);

            var handle = new WindowInteropHelper(this).Handle;
            //关闭窗口时取消注册
            UnregisterHotKey(handle, AltKeyEventId);

            //关闭窗口时控制虚拟设备按键抬起
            _stream.Write([1, 0]);
            _stream.Close();
        }
    }
}
</code></pre>
<p>最后的效果如下<br>
<img alt="img" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2033325/202508/2033325-20250822171037621-979549729.gif" class="lazyload"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-22 21:02">2025-08-22 21:01</span>&nbsp;
<a href="https://www.cnblogs.com/yangtb">昏睡红猹</a>&nbsp;
阅读(<span id="post_view_count">141</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19052650);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19052650', targetLink: 'https://www.cnblogs.com/yangtb/p/19052650', title: '从0.99到1实现一个Windows上的虚拟hid键盘设备' })">举报</a>
</div>
        