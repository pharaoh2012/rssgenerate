
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18646464" title="发布于 2025-01-01 22:53">
    <span role="heading" aria-level="2">JVM实战—7.如何模拟GC场景并阅读GC日志</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="362" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="363"><strong>1.动手模拟出频繁Young GC的场景</strong></p>
<p data-track="364"><strong>2.JVM的Young GC日志应该怎么看</strong></p>
<p data-track="365"><strong>3.代码模拟动态年龄判定规则进入老年代</strong></p>
<p data-track="366"><strong>4.代码模拟S区放不下部分进入老年代</strong></p>
<p data-track="367"><strong>5.JVM的Full GC日志应该怎么看</strong></p>
<p data-track="368"><strong>6.问题汇总</strong></p>
<p data-track="369">&nbsp;</p>
<p data-track="370"><strong>1.动手模拟出频繁Young GC的场景</strong></p>
<p data-track="371"><strong>(1)程序的JVM参数示范</strong></p>
<p data-track="372"><strong>(2)如何打印出JVM GC日志</strong></p>
<p data-track="373"><strong>(3)示例程序代码</strong></p>
<p data-track="374"><strong>(4)对象是如何分配在Eden区内的</strong></p>
<p data-track="375"><strong>(5)采用指定JVM参数运行程序</strong></p>
<p data-track="376">&nbsp;</p>
<p data-track="377"><strong>(1)程序的JVM参数示范</strong></p>
<p data-track="378">平时我们系统运行创建的对象，通常都优先分配在新生代中的Eden区。除非是大对象，大对象会直接进入老年代或者大对象专属Region区域。新生代有两块S区，默认Eden区占新生代80%，每块S区占新生代10%。比如用以下JVM参数来运行代码：</p>
<pre class="highlighter-hljs"><code> -XX:NewSize=5242880 -XX:MaxNewSize=5242880 
 -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 
 -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10485760 
 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC</code></pre>
<p data-track="380">上述参数都是基于JDK 1.8来设置的，不同的JDK版本对应的参数名称不太一样，但基本意思类似。</p>
<pre class="highlighter-hljs"><code> -XX:InitialHeapSize和-XX:MaxHeapSize就是初始堆大小和最大堆大小；
 -XX:NewSize和-XX:MaxNewSize是初始新生代大小和最大新生代大小；
 -XX:PretenureSizeThreshold=10485760指定了大对象阈值是10M；</code></pre>
<p data-track="382">上面的JVM参数，相当于是给堆内存分配10M内存空间。其中新生代是5M内存空间，Eden区占4M，每个Survivor区占0.5M。大对象必须超过10M才会直接进入老年代，年轻代使用ParNew垃圾回收器，老年代使用CMS垃圾回收器。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/ef5678e5c1844864adfdf4cd098ee1ce~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=IPj%2BbxC30C0PlGOX8cSL0bjmHnQ%3D" data-ic="false" data-width="628" data-height="624" data-ic-uri=""></div>
<p data-track="383"><strong>(2)如何打印出JVM GC日志</strong></p>
<p data-track="384">接着需要在系统的JVM参数中加入GC日志的打印选型，如下所示：</p>
<pre class="highlighter-hljs"><code>-XX:+PrintGCDetils：打印详细的GC日志；
-XX:+PrintGCTimeStamps：这个参数可以打印出每次GC发生的时间；
-Xloggc:gc.log：这个参数可以设置将GC日志写入一个磁盘文件；</code></pre>
<p data-track="386">加上打印GC日志参数后，JVM参数如下所示：</p>
<pre class="highlighter-hljs"><code> -XX:NewSize=5242880 -XX:MaxNewSize=5242880 
 -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 
 -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10485760 
 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC 
 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log</code></pre>
<p data-track="388"><strong>(3)示例程序代码</strong></p>
<pre class="highlighter-hljs"><code>public class Demo1 {
    public static void main(String[] args) {
        byte[] array1 = new byte[1024 * 1024];
        array1 = new byte[1024 * 1024];
        array1 = new byte[1024 * 1024];
        array1 = null;
        byte[] array2 = new byte[2 * 1024 * 1024];
    }
}</code></pre>
<p data-track="390"><strong>(4)对象是如何分配在Eden区内的</strong></p>
<p data-track="391">上述代码先通过new byte[1024 * 1024]连续分配3个数组，每个数组1M；然后通过array1这个局部变量依次引用这三个对象；最后还把array1这个局部变量指向了null。</p>
<p data-track="392">&nbsp;</p>
<p data-track="393">那么在JVM中上述代码是如何运行的呢？</p>
<p data-track="394">一.首先来看第一行代码：byte[] array1 = new byte[1024 * 1024];</p>
<p data-track="395">这行代码一旦运行，就会在JVM的Eden区内放入一个1M的对象，同时在main线程的虚拟机栈中会压入一个main()方法的栈帧。在main()方法的栈帧内部，会有一个名为array1的局部变量。这个array1局部变量指向了堆内存Eden区的那个1M的数组，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/e20711730e414b1d9b5f1ad535790968~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=Y6SU%2FxC7kGCc3M9hDVrnAEu9ZMg%3D" data-ic="false" data-width="1080" data-height="646" data-ic-uri=""></div>
<p data-track="396">二.接着看第二行代码：array1 = new byte[1024 * 1024];</p>
<p data-track="397">这行代码会在Eden区创建第二个数组，并让array1变量指向第二个数组。然后第一个数组就没被引用了，成了垃圾对象。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/59ce7a8918924e1f8d2c9d7971698472~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=0LcFeEFlQkCHa3LQzVXFJ2CgQfo%3D" data-ic="false" data-width="1080" data-height="645" data-ic-uri=""></div>
<p data-track="398">三.然后看第三行代码：array1 = new byte[1024 * 1024];</p>
<p data-track="399">这行代码会在Eden区创建第三个数组，并让array1变量指向第三个数组。此时前面两个数组都没有被引用了，都成了垃圾对象，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/800b128998b942f0a7dc759057f46a04~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=jJSoIUyvfvzYvzYxf1EgvhFo%2FY0%3D" data-ic="false" data-width="1080" data-height="649" data-ic-uri=""></div>
<p data-track="400">四.接着看第四行代码：array1 = null;</p>
<p data-track="401">这行代码一执行，就会让array1局部变量什么都不指向了，此时会导致之前创建的3个数组全部变成垃圾对象。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/21f9d6e181f34534a8ec1cd43a6141b4~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=zdXiU1EXVcjMJr7xYqB4Qisa74Y%3D" data-ic="false" data-width="1080" data-height="648" data-ic-uri=""></div>
<p data-track="402">五.最后看第五行代码：byte[] array2 = new byte[2 * 1024 * 1024];</p>
<p data-track="403">此时会分配一个2M大小的数组，尝试放入Eden区中。这时Eden区明显已经不能放下这个数组了，因为Eden区总共4M，里面已经放入3个1M的数组，剩余空间只有1M。此时再放一个2M的数组是放不下的，所以这个时候就会触发年轻代的Young GC；</p>
<p data-track="404">&nbsp;</p>
<p data-track="405"><strong>(5)采用指定JVM参数运行程序</strong></p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/640567e62b9a4de58efe59c3ffc1fa8a~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=JR%2FrtRfq3cfE34i8o8civnU2UrU%3D" data-ic="false" data-width="1080" data-height="293" data-ic-uri=""></div>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/8542e92edf734a929df419aed43b41b4~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=Itm4SUkm28xZEtx1qBhafjIbNDw%3D" data-ic="false" data-width="1080" data-height="220" data-ic-uri=""></div>
<div class="pgc-img"><img src="https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/19a32bb45a0c4b09b00edf3b1244df18~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=0w3%2FSjpkrymmo9jtEXruk%2Fk3EIQ%3D" data-ic="false" data-width="1080" data-height="293" data-ic-uri=""></div>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/baa55e84abbf454c94aaedda25d64fa2~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=opFefhG%2Fdm4prI438UWCEEq6S%2Fc%3D" data-ic="false" data-width="1080" data-height="551" data-ic-uri=""></div>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/8adecf1531e141108ed96b83b6849304~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=xTtiQTTiBmLTvjEyqoY0cqZkwYo%3D" data-ic="false" data-width="1080" data-height="256" data-ic-uri=""></div>
<p data-track="406">然后点击运行即可。运行完毕后，会在工程目录中出现一个gc.log文件，gc.log文件里面就是本次程序运行的gc日志。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/b44ed020906c49339d01610a6df06953~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=mjz0k8HsftUzSp2Ot6Wlo6sPaJY%3D" data-ic="false" data-width="924" data-height="276" data-ic-uri=""></div>
<p data-track="407">打开gc.log文件，会看到如下所示的gc日志：</p>
<pre class="highlighter-hljs"><code>CommandLine flags: -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:MaxNewSize=5242880 
  -XX:NewSize=5242880 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC 
  -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers 
  -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 
0.268: [GC (Allocation Failure) 0.269: [ParNew: 4030K-&gt;512K(4608K), 0.0015734 secs] 4030K-&gt;574K(9728K), 0.0017518 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap
 par new generation   total 4608K, used 2601K [0x00000000ff600000, 0x00000000ffb00000, 0x00000000ffb00000)
  eden space 4096K,  51% used [0x00000000ff600000, 0x00000000ff80a558, 0x00000000ffa00000)
  from space 512K, 100% used [0x00000000ffa80000, 0x00000000ffb00000, 0x00000000ffb00000)
  to   space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)
 concurrent mark-sweep generation total 5120K, used 62K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)
 Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 300K, capacity 386K, committed 512K, reserved 1048576K</code></pre>
<p data-track="409">&nbsp;</p>
<p data-track="410"><strong>2.JVM的Young GC日志应该怎么看</strong></p>
<p data-track="411"><strong>(1)程序运行采用的默认JVM参数如何查看</strong></p>
<p data-track="412"><strong>(2)一次GC的概要说明</strong></p>
<p data-track="413"><strong>(3)图解GC执行过程</strong></p>
<p data-track="414"><strong>(4)GC过后的堆内存使用情况</strong></p>
<p data-track="415"><strong>(5)Metaspace中的capacity、committed、reserved</strong></p>
<p data-track="416">&nbsp;</p>
<p data-track="417"><strong>(1)程序运行采用的默认JVM参数如何查看</strong></p>
<p data-track="418">在GC日志中，可以看到如下内容：</p>
<pre class="highlighter-hljs"><code>CommandLine flags: -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 
  -XX:MaxNewSize=5242880 -XX:NewSize=5242880 -XX:OldPLABSize=16 
  -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails 
  -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers 
  -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code></pre>
<p data-track="420">这展示了这次运行程序采取的JVM参数，包括设置的和默认的参数。</p>
<p data-track="421">&nbsp;</p>
<p data-track="422">所以如果没有设置JVM参数，应该怎么看系统默认使用的JVM参数？</p>
<p data-track="423">&nbsp;</p>
<p data-track="424">方法就是：给JVM加一段打印GC日志的参数，这样在GC日志里就可以看到默认给JVM进程分配多大的内存空间了。</p>
<p data-track="425">&nbsp;</p>
<p data-track="426"><strong>(2)一次GC的概要说明</strong></p>
<p data-track="427">接着看GC日志中的如下一行：该行日志概要说明了本次GC的执行情况。</p>
<pre class="highlighter-hljs"><code>0.268: [GC (Allocation Failure) 0.269: [ParNew: 4030K-&gt;512K(4608K), 0.0015734 secs] 4030K-&gt;574K(9728K), 0.0017518 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</code></pre>
<p data-track="429">一.为什么会发生一次GC</p>
<p data-track="430">从上图可知，因为最后要分配一个2M的数组，结果Eden区内存不够。所以就出现了GC (Allocation Failure)，也就是对象分配失败，所以此时就要触发一次Young GC。</p>
<p data-track="431">&nbsp;</p>
<p data-track="432">二.这次GC是什么时候发生的</p>
<p data-track="433">很简单，看一个数字——0.268，这指的是系统运行后过了多少秒就发生本次GC。比如这里的日志就是系统运行后过了268毫秒就发生了本次GC。</p>
<p data-track="434">&nbsp;</p>
<p data-track="435">三.新生代GC使用的是ParNew</p>
<p data-track="436">ParNew: 4030K-&gt;512K(4608K)。ParNew的意思是：由于这次触发的是Young GC，于是用指定的ParNew垃圾回收器执行。</p>
<p data-track="437">&nbsp;</p>
<p data-track="438">四.GC前新生代使用空间、GC后存活对象、新生代可用空间</p>
<p data-track="439">ParNew: 4030K-&gt;512K(4608K)。这个代表的意思是：新生代可用空间是4608K，也就是4.5M。为什么新生代可用空间是4608K？因为Eden区是4M，两个S区只有一个可放存活对象，另一个要保持空闲。所以新生代的可用空间就是Eden区 + 1个S区的大小，即4608K = 4.5M。</p>
<p data-track="440">&nbsp;</p>
<p data-track="441">然后4030K-&gt;512K，表示的是对新生代执行了一次GC。GC前已经使用了4030K，但是GC后只有512K的对象存活下来。</p>
<p data-track="442">&nbsp;</p>
<p data-track="443">五.本次新生代GC消耗时间，单位精确到微妙</p>
<p data-track="444">0.0015734 secs。这个就是本次新生代GC耗费的时间，大概耗费1.5ms，回收3M的对象。</p>
<p data-track="445">&nbsp;</p>
<p data-track="446">六.GC前和GC后的Java堆内存使用了多少</p>
<p data-track="447">4030K-&gt;574K(9728K), 0.0017518 secs。这个代表的是整个Java堆内存的情况，整个Java堆内存的总可用空间是9728K = 新生代4.5M + 老年代5M。GC前整个Java堆内存使用了4030K，GC后Java堆内存使用了574K。</p>
<p data-track="448">&nbsp;</p>
<p data-track="449">七.本次GC消耗时间，单位到精确到10毫秒</p>
<p data-track="450">[Times: user=0.00 sys=0.00, real=0.00 secs]。这个代表的是本次GC消耗的时间，这里最小单位是小数点之后两位。这里全部是0.00 secs，也就是本次GC就耗费了几毫秒，所以是0.00s。</p>
<p data-track="451">&nbsp;</p>
<p data-track="452"><strong>(3)图解GC执行过程</strong></p>
<p data-track="453"><strong>第一：看这行日志</strong></p>
<p data-track="454">ParNew: 4030K-&gt;512K(4608K), 0.0015734 secs。在GC前，明明在Eden区只放了3个1M的数组，大小一共是3M=3072K。那么GC前新生代应该是使用了3072K，为什么显示使用了4030K内存？</p>
<p data-track="455">&nbsp;</p>
<p data-track="456">对于这个问题，需要明白两点：</p>
<p data-track="457">一.虽然创建的数组是1M，但为了存储它，JVM还会附带一些其他信息。所以每个数组实际占用的内存是大于1M的。</p>
<p data-track="458">&nbsp;</p>
<p data-track="459">二.除了自己创建的对象以外，可能还有一些看不见的对象在Eden区。至于这些看不见的未知对象是什么，可通过专门的工具分析堆内存快照。</p>
<p data-track="460">&nbsp;</p>
<p data-track="461">所以如下图示：GC前三个数组和其他一些未知对象加起来，就是占据了4030K的内存。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/2c0592b546634ba0b71f290603f806f5~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=KrB%2FzqCxFAGoDTGy71Ogt1IUWZw%3D" data-ic="false" data-width="1080" data-height="565" data-ic-uri=""></div>
<p data-track="462">接着想要在Eden区分配一个2M的数组，此时就会触发Allocation Failure。Allocation Failure表示对象分配失败，于是触发Young GC。然后使用ParNew垃圾回收器进行垃圾回收，回收掉之前创建的三个数组。因为此时这三个数组都没被引用，而成为垃圾对象了。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/783427a160b34eb187651c96e439c2ad~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=0mSv1cCvH2XqoU8pcpRQw1cGScQ%3D" data-ic="false" data-width="1080" data-height="574" data-ic-uri=""></div>
<p data-track="463"><strong>第二：看这行日志</strong></p>
<pre class="highlighter-hljs"><code>ParNew: 4030K-&gt;512K(4608K), 0.0015734 secs</code></pre>
<p data-track="465">新生代GC回收后，新生代中已使用的内存从4030K降低到了512K。也就是说这次YGC有512K的对象存活下来，从Eden区转移到了S区。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/2af727808435470593505ff42398352c~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=z1mW3ifeDBZo9P2gdev8sPb88TY%3D" data-ic="false" data-width="1080" data-height="636" data-ic-uri=""></div>
<p data-track="466">以上就是本次GC的全过程。</p>
<p data-track="467">&nbsp;</p>
<p data-track="468"><strong>(4)GC过后的堆内存使用情况</strong></p>
<p data-track="469">接着看下面的GC日志，这段日志是在JVM退出时打印出来的当前堆内存的使用情况。</p>
<pre class="highlighter-hljs"><code>Heap
 par new generation total 4608K, used 2601K [0x00000000ff600000, 0x00000000ffb00000, 0x00000000ffb00000)
  eden space 4096K,  51% used [0x00000000ff600000, 0x00000000ff80a558, 0x00000000ffa00000)
  from space 512K, 100% used [0x00000000ffa80000, 0x00000000ffb00000, 0x00000000ffb00000)
  to   space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)
 concurrent mark-sweep generation total 5120K, used 62K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)
 Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 300K, capacity 386K, committed 512K, reserved 1048576K</code></pre>
<p data-track="471">一.当前新生代总共可用内存和已经使用内存</p>
<pre class="highlighter-hljs"><code>par new generation total 4608K, used 2601K</code></pre>
<p data-track="473">这代表ParNew垃圾回收器负责的新生代总共有4608K(4.5M)可用内存，目前已经使用了的内存是2601K(2.5M)。此时在JVM退出前，为什么新生代占用了2.5M的内存？</p>
<p data-track="474">&nbsp;</p>
<p data-track="475">因为在GC后，会通过如下代码又分配一个2M的数组：byte[] array2 = new byte[2 * 1024 * 1024];</p>
<p data-track="476">&nbsp;</p>
<p data-track="477">所以此时在Eden区中一定会有一个2M的数组，也就是2048K。然后上次GC后在Survivor From区中存活了512K的对象。由于每个数组会额外占据一些内存来存放一些自己这个对象的元数据，所以可以认为多出来的41K是数组对象额外使用的内存空间。因此GC后新生代占用的大小是：2048K + 512K + 41K = 2601K。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/0ad60d2a26984eacaf511eef2f55ed4b~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=%2BH0GDxEfs31EGqaVxALqJAbw3es%3D" data-ic="false" data-width="1080" data-height="624" data-ic-uri=""></div>
<p data-track="478">二.接着看以下GC日志</p>
<pre class="highlighter-hljs"><code> eden space 4096K,  51% used [0x00000000ff600000, 0x00000000ff80a558, 0x00000000ffa00000)
 from space 512K, 100% used [0x00000000ffa80000, 0x00000000ffb00000, 0x00000000ffb00000)
 to   space 512K,   0% used [0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000)</code></pre>
<p data-track="480">其中清晰地表示，此时：Eden区4M的内存被使用了51%，因为有一个2M的数组在里面。然后Survivor From区，显示512K，100%的使用率。也就是Survivor From区被这次GC后存活下来的512K对象全占据了。</p>
<p data-track="481">&nbsp;</p>
<p data-track="482">三.接着看以下GC日志</p>
<p data-track="483">如下日志指的是CMS管理的老年代内存空间一共5M，此时已用62K。</p>
<pre class="highlighter-hljs"><code>concurrent mark-sweep generation total 5120K, used 62K，</code></pre>
<p data-track="485">而下面两段日志的意思是：Metaspace元数据空间和Class空间的总容量、使用内存等，Metaspace元数据空间会存放一些类的信息、常量池信息等。</p>
<pre class="highlighter-hljs"><code>Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K
 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K</code></pre>
<p data-track="487"><strong>(5)Metaspace中的capacity、committed、reserved</strong></p>
<p data-track="488">Java8取消了永久代PermGen，取而代之的是元数据区MetaSpace。方法区在Java8以后移至元数据区MetaSpace，JDK8开始把类的元数据放到本地内存(Native Heap)，称为MetaSpace。理论上本地内存剩余多少，MetaSpace就可以有多大。</p>
<p data-track="489">&nbsp;</p>
<p data-track="490">当然我们不可能无限制增大MetaSpace，需要用-XX:MaxMetaSpaceSize指定MetaSpace大小。</p>
<p data-track="491">&nbsp;</p>
<p data-track="492">关于used capacity commited和reserved：MetaSpace由一个或多个Virtual Space(虚拟空间)组成。虚拟空间是操作系统的连续存储空间，虚拟空间是按需分配的。分配时，虚拟空间会向OS预留(reserve)空间，但还没被提交(commit)。</p>
<p data-track="493">&nbsp;</p>
<p data-track="494">一.MetaSpace的预留空间(reserved)是全部虚拟空间的大小</p>
<p data-track="495">虚拟空间的最小分配单元是MetaChunk(也可以说是Chunk)，当新的Chunk被分配至虚拟空间时，与Chunk相关的内存空间会被提交。</p>
<p data-track="496">&nbsp;</p>
<p data-track="497">二.MetaSpace的committed指的是所有Chunk占有的空间</p>
<p data-track="498">每个Chunk占据空间不同，当一个类加载器(Class Loader)被GC时：所有与之关联的Chunk被释放(freed)，这些释放的Chunk会维护在一个全局的释放数组里。</p>
<p data-track="499">&nbsp;</p>
<p data-track="500">三.MetaSpace的capacity指的是所有未被释放的Chunk占据的空间</p>
<p data-track="501">假如从GC日志发现committed是4864K，capacity4486K。说明有一部分的Chunk已经被释放了，代表有类加载器被回收了。附上原文链接：</p>
<pre class="highlighter-hljs"><code>https://stackoverflow.com/questions/40891433/understanding-metaspace-line-in-jvm-heap-printout</code></pre>
<p data-track="503">&nbsp;</p>
<p data-track="504"><strong>3.代码模拟动态年龄判定规则进入老年代</strong></p>
<p data-track="505"><strong>(1)动态年龄判定规则</strong></p>
<p data-track="506"><strong>(2)动态年龄判定规则的示例代码</strong></p>
<p data-track="507"><strong>(3)示例代码运行后产生的GC日志</strong></p>
<p data-track="508"><strong>(4)GC日志分析</strong></p>
<p data-track="509"><strong>(5)完善示例代码</strong></p>
<p data-track="510"><strong>(6)分析最终版的GC日志</strong></p>
<p data-track="511"><strong>(7)总结</strong></p>
<p data-track="512">&nbsp;</p>
<p data-track="513"><strong>(1)动态年龄判定规则</strong></p>
<p data-track="514"><strong>对象进入老年代的四个常见时机如下：</strong></p>
<p data-track="515">一.躲过15次新生代GC后(年龄达到15岁)</p>
<p data-track="516">二.动态年龄判定规则</p>
<p data-track="517">如果在S区内，年龄1+年龄2+年龄3+年龄n的对象总和大于S区的50%。此时年龄n及以上的对象会进入老年代，不一定需要达到15岁。所以动态年龄判断规则有个推论：如果S区中的同龄对象大小超过S区内存的一半，就要直接升入老年代。</p>
<p data-track="518">三.如果一次YGC后存活对象太多无法放入S区，就会直接放入老年代</p>
<p data-track="519">四.大对象直接进入老年代</p>
<p data-track="520">&nbsp;</p>
<p data-track="521">首先通过代码模拟出最常见的一种进入老年代的情况：如果S区内年龄1 + 年龄2 + 年龄3 + 年龄n的对象总和大于S区的50%，此时年龄n及以上的对象会进入老年代，也就是动态年龄判定规则。</p>
<p data-track="522">&nbsp;</p>
<p data-track="523">示例程序的JVM参数如下：</p>
<pre class="highlighter-hljs"><code> -XX:NewSize=10485760 -XX:MaxNewSize=10485760 
 -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 
 -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 
 -XX:PretenureSizeThreshold=10485760 
 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC 
 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log</code></pre>
<p data-track="525">在这些参数里需要注意几点：</p>
<p data-track="526">Java堆的总大小通过-XX:InitialHeapSize设置为20M，新生代通过-XX:NewSize设置为10M，所以老年代是10M。然后通过-XX:SurvivorRatio参数可知，Eden区是8M，每个S区是1M。接着大对象必须超过10M才会直接进入老年代，-XX:MaxTenuringThreshold=15设置对象年龄达到15岁会进入老年代。</p>
<p data-track="527">&nbsp;</p>
<p data-track="528">一切准备就绪，先看当前的内存分配情况：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/bc1b80f760714a52bbbf8b23ff115285~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=YsQAo0lxR7n%2BfTi8j122dSz3KSc%3D" data-ic="false" data-width="1080" data-height="628" data-ic-uri=""></div>
<p data-track="529"><strong>(2)动态年龄判定规则的示例代码</strong></p>
<pre class="highlighter-hljs"><code>public class Demo {
    public static void main(String[] args) {
        byte[] array1 = new byte[2 * 1024 * 1024];
        array1 = new byte[2 * 1024 * 1024];
        array1 = new byte[2 * 1024 * 1024];
        array1 = null;
        byte[] array2 = new byte[128 * 1024];
        byte[] array3 = new byte[2 * 1024 * 1024];
    }
}</code></pre>
<p data-track="531">接下来运行示例代码，然后通过打印出的GC日志分析上述代码执行后JVM中的对象分配情况。</p>
<p data-track="532">&nbsp;</p>
<p data-track="533"><strong>(3)示例代码运行后产生的GC日志</strong></p>
<p data-track="534">把上述示例代码以及给出的JVM参数配合起来运行，此时会看到如下的GC日志。</p>
<pre class="highlighter-hljs"><code>CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 
  -XX:MaxTenuringThreshold=15 -XX:NewSize=10485760 -XX:OldPLABSize=16 
  -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails 
  -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers 
  -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 
0.297: [GC (Allocation Failure) 0.297: [ParNew: 7260K-&gt;715K(9216K), 0.0012641 secs] 7260K-&gt;715K(19456K), 0.0015046 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap
 par new generation   total 9216K, used 2845K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)
  from space 1024K,  69% used [0x00000000ff500000, 0x00000000ff5b2e10, 0x00000000ff600000)
  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 concurrent mark-sweep generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K
 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K</code></pre>
<p data-track="536"><strong>(4)GC日志分析</strong></p>
<p data-track="537">一.首先看如下几行代码</p>
<pre class="highlighter-hljs"><code>byte[] array1 = new byte[2 * 1024 * 1024];
array1 = new byte[2 * 1024 * 1024];
array1 = new byte[2 * 1024 * 1024];
array1 = null;</code></pre>
<p data-track="539">这里连续创建了3个2M的数组，最后还把局部变量array1设置为null，所以此时的内存如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/00b89485e55a4ba7bcb0ecb4edfbfe40~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=WWHP%2FjxcQbeQ4rAn1kIEUo93HUg%3D" data-ic="false" data-width="1080" data-height="635" data-ic-uri=""></div>
<p data-track="540">二.接着执行下面这行代码：</p>
<pre class="highlighter-hljs"><code>byte[] array2 = new byte[128 * 1024];</code></pre>
<p data-track="542">此时会在Eden区创建一个128K的数组同时由array2局部变量来引用，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/3c2dff8d012444b9811192a8693e56d5~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=mlrOG75LAhqxq%2B7f4Fnz8JWTSKU%3D" data-ic="false" data-width="1080" data-height="633" data-ic-uri=""></div>
<p data-track="543">三.然后会执行下面的代码：</p>
<pre class="highlighter-hljs"><code>byte[] array3 = new byte[2 * 1024 * 1024];</code></pre>
<p data-track="545">此时希望在Eden区再次分配一个2M的数组，由于此时Eden区里已有3个2M数组和1个128K数组，大小都超过6M了。Eden区总共才8M，此时是不可能在Eden区再次分配一个2M的数组的，因此一定会触发一次Young GC。</p>
<p data-track="546">&nbsp;</p>
<p data-track="547">四.接着开始看GC日志：</p>
<pre class="highlighter-hljs"><code>ParNew: 7260K-&gt;715K(9216K), 0.0012641 secs</code></pre>
<p data-track="549">这行日志清晰表明，在GC前新生代占用了7260K的内存。大概就是6M的3个数组 + 128K的1个数组 + 几百K的未知对象 = 7260K，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/2e09b0aea9e743d4b9c8979f8b16fb77~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=cAmMqS9rUsVeV%2FS2KSsJB2OGxCM%3D" data-ic="false" data-width="1080" data-height="633" data-ic-uri=""></div>
<p data-track="550">五.接着看回上述GC日志：</p>
<pre class="highlighter-hljs"><code>7260K-&gt;715K(9216K)</code></pre>
<p data-track="552">这表明，一次Young GC过后，剩余的存活对象是715K。由于新生代刚开始会有512K左右的未知对象，此时再加上128K的数组，差不多就是715K。</p>
<p data-track="553">&nbsp;</p>
<p data-track="554">六.接着看如下GC日志：</p>
<pre class="highlighter-hljs"><code>par new generation   total 9216K, used 2845K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
 eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)
 from space 1024K,  69% used [0x00000000ff500000, 0x00000000ff5b2e10, 0x00000000ff600000)
 to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
concurrent mark-sweep generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</code></pre>
<p data-track="556">从上面的日志可以清晰看出：此时From Survivor区域被占据了69%的内存，大概就是700K左右。这就是一次Young GC后存活下来的对象，它们都进入From Survivor区。</p>
<p data-track="557">&nbsp;</p>
<p data-track="558">同时Eden区域内被占据了26%的空间，大概就是2M左右。这就是执行代码"byte[] array3 = new byte[2 * 1024 * 1024]"时，在Young GC后分配在Eden区内的数组。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/34c64377f531409daeb9a2dfa3a68cf8~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=NJE7EG0FC3vRELF7N4pzVtxoJIE%3D" data-ic="false" data-width="1080" data-height="637" data-ic-uri=""></div>
<p data-track="559">现在Survivor From区里的那700K对象，是1岁。它们熬过一次GC，年龄就会增长1岁。此时S区总大小是1M，存活对象已经有700K了，已经超过了50%。</p>
<p data-track="560">&nbsp;</p>
<p data-track="561"><strong>(5)完善示例代码</strong></p>
<pre class="highlighter-hljs"><code>public class Demo {
    public static void main(String[] args) {
        byte[] array1 = new byte[2 * 1024 * 1024];
        array1 = new byte[2 * 1024 * 1024];
        array1 = new byte[2 * 1024 * 1024];
        array1 = null;
        byte[] array2 = new byte[128 * 1024];
        byte[] array3 = new byte[2 * 1024 * 1024];
        
        array3 = new byte[2 * 1024 * 1024];
        array3 = new byte[2 * 1024 * 1024];
        array3 = new byte[128 * 1024];
        array3 = null;
        
        byte[] array4 = new byte[2 * 1024 * 1024];
    }
}</code></pre>
<p data-track="563">把示例代码给完善一下变成上述的样子，接下来要触发第二次YGC，然后看S区内的动态年龄判定规则能否生效。</p>
<p data-track="564">&nbsp;</p>
<p data-track="565">一.接着前面代码执行的分析，继续看如下代码：</p>
<pre class="highlighter-hljs"><code>array3 = new byte[2 * 1024 * 1024];
array3 = new byte[2 * 1024 * 1024];
array3 = new byte[128 * 1024];
array3 = null;</code></pre>
<p data-track="567">这几行代码运行后，会接着分配2个2M的数组。然后再分配一个128K的数组，最后让array3变量指向null。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/4a3b6aaed85745df9a0eff7ec868cd22~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=HOnymk%2BnMKJJgz86NmnZpz4Ghbw%3D" data-ic="false" data-width="1080" data-height="631" data-ic-uri=""></div>
<p data-track="568">二.此时接着会运行下面的代码：</p>
<pre class="highlighter-hljs"><code>byte[] array4 = new byte[2 * 1024 * 1024];</code></pre>
<p data-track="570">这时会发现，Eden区如果要再放一个2M数组进去，是放不下的，所以此时会触发一次YGC。使用上述JVM参数运行这段程序会看到如下GC日志：</p>
<pre class="highlighter-hljs"><code>0.269: [GC (Allocation Failure) 0.269: [ParNew: 7260K-&gt;713K(9216K), 0.0013103 secs] 7260K-&gt;713K(19456K), 0.0015501 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
0.271: [GC (Allocation Failure) 0.271: [ParNew: 7017K-&gt;0K(9216K), 0.0036521 secs] 7017K-&gt;700K(19456K), 0.0037342 secs] [Times: user=0.06 sys=0.00, real=0.00 secs]
Heap
par new generation   total 9216K, used 2212K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
 eden space 8192K,  27% used [0x00000000fec00000, 0x00000000fee290e0, 0x00000000ff400000)
 from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
concurrent mark-sweep generation total 10240K, used 700K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K
 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K</code></pre>
<p data-track="572"><strong>(6)分析最终版的GC日志</strong></p>
<p data-track="573">一.首先第一次GC的日志如下：</p>
<pre class="highlighter-hljs"><code>0.269: [GC (Allocation Failure) 0.269: [ParNew: 7260K-&gt;713K(9216K), 0.0013103 secs] 7260K-&gt;713K(19456K), 0.0015501 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </code></pre>
<p data-track="575">这个过程前面已经分析过了。</p>
<p data-track="576">&nbsp;</p>
<p data-track="577">二.接着第二次GC的日志如下：</p>
<pre class="highlighter-hljs"><code>0.271: [GC (Allocation Failure) 0.271: [ParNew: 7017K-&gt;0K(9216K), 0.0036521 secs] 7017K-&gt;700K(19456K), 0.0037342 secs] [Times: user=0.06 sys=0.00, real=0.00 secs] </code></pre>
<p data-track="579">第二次触发Yuong GC，就是第一次赋值给局部变量array4的时候。此时的日志"ParNew: 7017K-&gt;0K(9216K)"表明：这次GC过后，新生代直接就没有对象了。但array2这个局部变量还一直引用一个128K的数组，它是存活对象。那么这128K的数组以及还有那500多K的未知对象，此时都去哪里了？</p>
<p data-track="580">&nbsp;</p>
<p data-track="581">首先在Eden区里的3个2M的数组和1个128K的数组，肯定会被回收掉的。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/b6e2c7c4c7a3468386bbc84a89edf7b3~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=JWiaX%2FzfVYgZ6JPX9yLN4mZMFdE%3D" data-ic="false" data-width="1080" data-height="633" data-ic-uri=""></div>
<p data-track="582">然后发现S区中的对象都是存活的，且总大小超过50%以及年龄都是1岁。于是根据动态年龄判定规则：年龄1+...年龄n的对象总大小超S区50%，年龄n及以上的对象进老年代。由于此时S区里的对象的年龄都是1，所以会全部直接进入老年代了。</p>
<p data-track="583">&nbsp;</p>
<p data-track="584">S区的对象第一次YGC进来时已超50%，但在第二次YGC还存活才升代。所以不是进入S区的时候使用动态年龄去判断，而是扫描S区时才去判断。</p>
<p data-track="585">&nbsp;</p>
<p data-track="586">如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/768dd1cfb4f34792b60731569a165c5d~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=y%2FDBekOBCa0eWQUpb49g65cQL6o%3D" data-ic="false" data-width="1080" data-height="632" data-ic-uri=""></div>
<p data-track="587">这个可以从下面的日志进行确认：</p>
<pre class="highlighter-hljs"><code>concurrent mark-sweep generation total 10240K, used 700K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</code></pre>
<p data-track="589">CMS管理的老年代，此时使用空间刚好是700K。由此证明此时Survivor的对象触发了动态年龄判定规则，虽然没达到15岁，但全部进入老年代了。</p>
<p data-track="590">&nbsp;</p>
<p data-track="591">三.然后array4变量引用的2M的数组，此时就会分配到Eden区中，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/3fe4b3e7c310476292f6417a333ee083~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=X%2Bw0eGLJFiKYmicQBh%2F6tm4HMn8%3D" data-ic="false" data-width="1080" data-height="633" data-ic-uri=""></div>
<p data-track="592">看如下日志：</p>
<pre class="highlighter-hljs"><code>eden space 8192K,  27% used [0x00000000fec00000, 0x00000000fee290e0, 0x00000000ff400000)</code></pre>
<p data-track="594">这就说明Eden区当前就是有一个2M的数组，然后再看下面的日志：</p>
<pre class="highlighter-hljs"><code>from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</code></pre>
<p data-track="596">表示两个Survivor区域都是空的，因为之前存活的700K对象都进入老年代了，所以现在Survivor区都空了。</p>
<p data-track="597">&nbsp;</p>
<p data-track="598"><strong>(7)总结</strong></p>
<p data-track="599">这里分析了对象是如何通过动态年龄判定规则进入老年代的。如果每次YGC过后存活的对象太多，特别是超过了S区50%的空间。那么下次YGC时就会触发动态年龄判定规则让一些对象进入老年代中。</p>
<p data-track="600">&nbsp;</p>
<p data-track="601">注意：不是进入S区的时候就用动态年龄去判断，而是扫描S区时才判断。</p>
<p data-track="602">&nbsp;</p>
<p data-track="603"><strong>4.代码模拟S区放不下部分进入老年代</strong></p>
<p data-track="604"><strong>(1)示例代码</strong></p>
<p data-track="605"><strong>(2)GC日志</strong></p>
<p data-track="606"><strong>(3)分析GC日志</strong></p>
<p data-track="607"><strong>(4)总结</strong></p>
<p data-track="608">&nbsp;</p>
<p data-track="609"><strong>(1)示例代码</strong></p>
<pre class="highlighter-hljs"><code>public class Demo {
    public static void main(String[] args) {
        byte[] array1 = new byte[2 * 1024 * 1024];
        array1 = new byte[2 * 1024 * 1024];
        array1 = new byte[2 * 1024 * 1024];
        
        byte[] array2 = new byte[128 * 1024];
        array2 = null;
        
        byte[] array3 = new byte[2 * 1024 * 1024];
    }
}</code></pre>
<p data-track="611"><strong>(2)GC日志</strong></p>
<p data-track="612">使用之前的JVM参数来跑一下上面的程序，可以看到下面的GC日志：</p>
<pre class="highlighter-hljs"><code>0.421: [GC (Allocation Failure) 0.421: [ParNew: 7260K-&gt;573K(9216K), 0.0024098 secs] 7260K-&gt;2623K(19456K), 0.0026802 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
Heap
 par new generation   total 9216K, used 2703K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)
  from space 1024K,  55% used [0x00000000ff500000, 0x00000000ff58f570, 0x00000000ff600000)
  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 concurrent mark-sweep generation total 10240K, used 2050K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K
 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K </code></pre>
<p data-track="614"><strong>(3)分析GC日志</strong></p>
<p data-track="615">一.首先看如下几行代码：</p>
<pre class="highlighter-hljs"><code>byte[] array1 = new byte[2 * 1024 * 1024];
array1 = new byte[2 * 1024 * 1024];
array1 = new byte[2 * 1024 * 1024];


byte[] array2 = new byte[128 * 1024];
array2 = null;</code></pre>
<p data-track="617">上面的代码中：首先分配了3个2M的数组，然后让array1变量指向第三个2M数组。接着创建了一个128K的数组，并让array2指向了null。同时我们一直都知道，Eden区里会有500K左右的未知对象，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/fd9aa01339e34a97a7748659917f2678~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=bvtadfwHG89mrmJ6hV9Tom3VkQo%3D" data-ic="false" data-width="1080" data-height="632" data-ic-uri=""></div>
<p data-track="618">二.接着会执行如下代码：</p>
<pre class="highlighter-hljs"><code>byte[] array3 = new byte[2 * 1024 * 1024];</code></pre>
<p data-track="620">此时想要在Eden区里再创建一个2M的数组，肯定是不行的，所以此时必然会触发一次Young GC。</p>
<p data-track="621">&nbsp;</p>
<p data-track="622">先看如下日志：</p>
<pre class="highlighter-hljs"><code>ParNew: 7260K-&gt;573K(9216K), 0.0024098 secs</code></pre>
<p data-track="624">这里清晰说明了，本次GC过后，新生代里就剩下了500多K的对象了。这是为什么呢，此时明明array1变量是引用了一个2M的数组的。</p>
<p data-track="625">&nbsp;</p>
<p data-track="626">因为这次GC时，会回收掉上图中的2个2M的数组和1个128K的数组，然后留下一个2M的数组和1个未知的500K的对象作为存活对象。这时存活下来的2M数组和500K未知对象是不能放入Survivor区的，因为Survivor区只有1M。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/552ffcedb59d4fbca9268270b836ccd0~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=jyzfRJGe7lQk15GXVQHDMvY4Bjc%3D" data-ic="false" data-width="1080" data-height="631" data-ic-uri=""></div>
<p data-track="627">三.根据对象进入老年代规则，此时是否要把全部存活对象都放入老年代</p>
<p data-track="628">也不是，因为首先根据如下日志：</p>
<pre class="highlighter-hljs"><code>eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)</code></pre>
<p data-track="630">可知，Eden区内一定放入了一个新的2M的数组，而且这个数组就是刚才最后想要分配的那个数组，由array3变量引用。此时会如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/dfb82514ef2e453dbede767a5eae0bd9~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=OMJ4zAyJ3V5Z98zcNq8hg8JhuGU%3D" data-ic="false" data-width="1080" data-height="632" data-ic-uri=""></div>
<p data-track="631">然后再根据如下的日志：</p>
<pre class="highlighter-hljs"><code>from space 1024K,  55% used [0x00000000ff500000, 0x00000000ff58f570, 0x00000000ff600000)</code></pre>
<p data-track="633">可知，此时Survivor From区中有500K对象，即那500K未知对象。所以新生代GC后会存活2M数组和500K未知对象，放不进Survivor区。但也不会让这2M数组和500K未知对象全部都进入老年代，而是会把500K的未知对象先放入Survivor From区中。</p>
<p data-track="634">&nbsp;</p>
<p data-track="635">所以结合GC日志，可以清晰的看到：在这种情况下，是会把部分对象放入Survivor区的，如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/9e1278d18c354478bd5795ba0ff59b11~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=G4nKLuUyZ5G02Zq8qDGJlxfonCY%3D" data-ic="false" data-width="1080" data-height="639" data-ic-uri=""></div>
<p data-track="636">接着再根据如下日志：</p>
<pre class="highlighter-hljs"><code>concurrent mark-sweep generation total 10240K, used 2050K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</code></pre>
<p data-track="638">可以发现此时老年代里会有2M的数组，因此可以认为：YGC过后，发现存活下来的对象有2M的数组和500K的未知对象。此时会把500K的未知对象放入Survivor区，把2M的数组放入老年代。如下图示：</p>
<div class="pgc-img"><img src="https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/3923c91d20e14685aff144cbbbe48b54~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=ke8WkD9G4UuzJxiKgX8GgQGPviU%3D" data-ic="false" data-width="1080" data-height="632" data-ic-uri=""></div>
<p data-track="639"><strong>(4)总结</strong></p>
<p data-track="640">这里展示了YGC后存活对象放不下S区，部分对象会进入老年代的例子。这种场景下，会有部分对象留在Survivor中，有部分对象进入老年代中。</p>
<p data-track="641">&nbsp;</p>
<p data-track="642"><strong>5.JVM的Full GC日志应该怎么看</strong></p>
<p data-track="643"><strong>(1)示例代码</strong></p>
<p data-track="644"><strong>(2)GC日志</strong></p>
<p data-track="645"><strong>(3)分析日志</strong></p>
<p data-track="646"><strong>(4)总结</strong></p>
<p data-track="647">&nbsp;</p>
<p data-track="648"><strong>(1)示例代码</strong></p>
<pre class="highlighter-hljs"><code>public class Demo {
    public static void main(String[] args) {
        byte[] array1 = new byte[4 * 1024 * 1024];
        array1 = null;
        
        byte[] array2 = new byte[2 * 1024 * 1024];
        byte[] array3 = new byte[2 * 1024 * 1024];
        byte[] array4 = new byte[2 * 1024 * 1024];
        byte[] array5 = new byte[128 * 1024];
        byte[] array6 = new byte[2 * 1024 * 1024];
    }
}</code></pre>
<p data-track="650"><strong>(2)GC日志</strong></p>
<p data-track="651">接下来需要采用如下参数来运行上述程序：</p>
<pre class="highlighter-hljs"><code> -XX:NewSize=10485760 -XX:MaxNewSize=10485760
 -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520
 -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 
 -XX:PretenureSizeThreshold=3145728 
 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC 
 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log</code></pre>
<p data-track="653">这里最关键一个参数，就是-XX:PretenureSizeThreshold=3145728。该参数设置大对象阈值为3M，即对象大小超过3M就直接进入老年代。</p>
<p data-track="654">&nbsp;</p>
<p data-track="655">运行之后会得到如下GC日志：</p>
<pre class="highlighter-hljs"><code>0.308: [GC (Allocation Failure) 0.308: [ParNew (promotion failed): 7260K-&gt;7970K(9216K), 0.0048975 secs]0.314: [CMS: 8194K-&gt;6836K(10240K), 0.0049920 secs] 11356K-&gt;6836K(19456K), [Metaspace: 2776K-&gt;2776K(1056768K)], 0.0106074 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
Heap
 par new generation   total 9216K, used 2130K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000)
  from space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
 concurrent mark-sweep generation total 10240K, used 6836K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
Metaspace       used 2782K, capacity 4486K, committed 4864K, reserved 1056768K
 class space    used 300K, capacity 386K, committed 512K, reserved 1048576K</code></pre>
<p data-track="657"><strong>(3)分析日志</strong></p>
<p data-track="658">一.首先看如下代码：</p>
<pre class="highlighter-hljs"><code>byte[] array1 = new byte[4 * 1024 * 1024];
array1 = null;</code></pre>
<p data-track="660">这行代码直接分配了一个4M的大对象，此时这个对象会直接进入老年代，接着array1不再引用这个对象。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/74148e6fff4a40de94308fa8d8d2e5c7~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=4NoRaZg4Fap6fI0CPZQsqIG%2BNxQ%3D" data-ic="false" data-width="1080" data-height="630" data-ic-uri=""></div>
<p data-track="661">二.接着看下面的代码：</p>
<pre class="highlighter-hljs"><code>byte[] array2 = new byte[2 * 1024 * 1024];
byte[] array3 = new byte[2 * 1024 * 1024];
byte[] array4 = new byte[2 * 1024 * 1024];
byte[] array5 = new byte[128 * 1024];</code></pre>
<p data-track="663">连续分配了4个数组，其中3个是2M的数组，1个是128K的数组。如下图示，全部都会进入Eden区。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d3ae919bbb33497b991207a85ad282b2~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=aneNcA5i1oxIanabbQEwtxG2%2BU4%3D" data-ic="false" data-width="1080" data-height="632" data-ic-uri=""></div>
<p data-track="664">三.接着会执行如下代码：</p>
<pre class="highlighter-hljs"><code>byte[] array6 = new byte[2 * 1024 * 1024];</code></pre>
<p data-track="666">此时新生代就放不下2M的对象了，因为Eden区已经不够空间了，所以会触发一次Young GC。可以参考下面的GC日志：</p>
<pre class="highlighter-hljs"><code>ParNew (promotion failed): 7260K-&gt;7970K(9216K), 0.0048975 secs</code></pre>
<p data-track="668">这行日志就显示了：Eden区原来是有7260K对象，但是回收后发现一个都回收不掉，因为上述几个数组都还被main()方法栈的局部变量引用。</p>
<p data-track="669">&nbsp;</p>
<p data-track="670">所以此时就会直接把这些对象都放入到老年代里，但是现在老年代里已经有一个4M的数组了，此时老年代已经放不下3个2M的数组和1个128K的数组了。参考如下GC日志：</p>
<pre class="highlighter-hljs"><code>[CMS: 8194K-&gt;6836K(10240K), 0.0049920 secs] 11356K-&gt;6836K(19456K), [Metaspace: 2776K-&gt;2776K(1056768K)], 0.0106074 secs]</code></pre>
<p data-track="672">可以清晰看到，此时执行了CMS垃圾回收器的Full GC。Full GC会对老年代进行GC，同时一般会跟一次新生代GC关联，以及触发一次元数据区(永久代)的GC。</p>
<p data-track="673">&nbsp;</p>
<p data-track="674">由于在CMS的Full GC之前，就已经触发过Young GC了。所以Young GC已经有了，接着就是执行针对老年代的Old GC。也就是如下日志：</p>
<pre class="highlighter-hljs"><code>CMS: 8194K-&gt;6836K(10240K), 0.0049920 secs</code></pre>
<p data-track="676">这里可以看到老年代从8M左右的对象占用，变成了6M左右的对象占用。这个过程具体如下：</p>
<p data-track="677">&nbsp;</p>
<p data-track="678">第一：在完成Young GC之后，先把2个2M的数组放入到老年代。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/372aa294264a45bfb39df5fabd8bda34~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=aqsPb%2BIelyrpwdW8R34Sc%2F3RXvc%3D" data-ic="false" data-width="1080" data-height="668" data-ic-uri=""></div>
<p data-track="679">第二：如果继续往老年代放入1个2M数组和1个128K数组，则一定放不下。因此这时就会触发CMS的Full GC，然后就会回收掉老年代中的一个4M的数组，因为它已经没被引用了。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/39cf11251636415d9efa923013d88938~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=9eYMXqmtnX%2FqUOMutvjDWZudZJ4%3D" data-ic="false" data-width="1080" data-height="658" data-ic-uri=""></div>
<p data-track="680">第三：接着往老年代放入1个2M的数组和1个128K的数组。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a7674252a08d4045a59b9e3f2ac17ec2~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=zF87qSTWO4SxDBEBS5at%2FkqFqVA%3D" data-ic="false" data-width="1080" data-height="635" data-ic-uri=""></div>
<p data-track="681">所以可以看到如下的CMS垃圾回收日志：</p>
<pre class="highlighter-hljs"><code>CMS: 8194K-&gt;6836K(10240K), 0.0049920 secs</code></pre>
<p data-track="683">老年代从Full GC回收前的8M变成了6M，就是上图所示。</p>
<p data-track="684">&nbsp;</p>
<p data-track="685">第四：最后当CMS执行Full GC完毕后，新生代的对象都进入了老年代。此时最后一行代码要在新生代分配2M的数组就可以成功了。如下图示：</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/dae1a256b5394854a35906a024f54d9c~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202501012231235488236301D55701100D&amp;x-expires=2147483647&amp;x-signature=hWUUKCrBUMjfTImtYk3VLr%2B4WPM%3D" data-ic="false" data-width="1080" data-height="634" data-ic-uri=""></div>
<p data-track="686"><strong>(4)总结</strong></p>
<p data-track="687">这里介绍了一个触发老年代GC的案例：就是新生代存活对象太多，老年代都放不下了，就会触发CMS的FGC。</p>
<p data-track="688">&nbsp;</p>
<p data-track="689"><strong>(5)触发老年代GC的其他场景</strong></p>
<p data-track="690">一.执行YGC后存活对象太多，老年代逐个放不下后会触发老年代GC</p>
<p data-track="691">二.执行YGC前老年代可用空间小于历次YGC升入老年代对象平均大小，于是就会在执行YGC前，提前触发老年代GC</p>
<p data-track="692">三.老年代使用率已经达到了92%的阈值，也会触发老年代GC</p>
<p data-track="693">&nbsp;</p>
<p data-track="694"><strong>6.问题汇总</strong></p>
<p data-track="695"><strong>问题一：</strong></p>
<p data-track="696"><strong>JVM优化思路总结</strong></p>
<p data-track="697">阶段一：项目上线初期</p>
<p data-track="698">一.上线前，根据预期的QPS、平均每个请求或者任务的内存需求大小等。评估出需要使用几台机器来承载，每台机器需要什么样的配置。</p>
<p data-track="699">二.根据系统的请求或者任务处理速度，评估内存使用情况。然后合理分配Eden区、Survivor区、老年代的内存大小。</p>
<p data-track="700">&nbsp;</p>
<p data-track="701">JVM调优的总体原则就是：</p>
<p data-track="702">让短命对象在YGC就被回收，不要进入老年代。让长期存活的对象尽早进入老年代，不要在新生代复制来复制去。对系统响应时间敏感且内存需求大的，建议采用G1回收器。</p>
<p data-track="703">&nbsp;</p>
<p data-track="704">如何合理分配各个区域：</p>
<p data-track="705">一.根据内存增速来评估多久进行YGC</p>
<p data-track="706">二.根据每次YGC会有多少存活对象来评估S区的大小设置是否合理</p>
<p data-track="707">三.评估多久会进行一次FGC+产生的STW是否可接受</p>
<p data-track="708">&nbsp;</p>
<p data-track="709">阶段二：项目运营出色，系统负载增加了100倍</p>
<p data-track="710">方案1：增加服务器数量</p>
<p data-track="711">根据系统负载的增比，同比增加机器数量，机器配置和JVM的配置可以保持不变。</p>
<p data-track="712">&nbsp;</p>
<p data-track="713">方案2：使用更高配置的机器</p>
<p data-track="714">更高的配置，意味着更快速的处理速度和更大的内存。响应时间敏感且内存需求大的使用G1回收器，这时候需要和项目上线初期一样，合理地使用配置和分配内存。</p>
<p data-track="715">&nbsp;</p>
<p data-track="716"><strong>问题二：</strong></p>
<p data-track="717">G1存不存在类似ParNew + CMS频繁回收导致的系统变慢问题？</p>
<p data-track="718">答：G1可能会频繁回收，但它每次回收时间可控，所以不会对系统造成太大影响。</p>
<p data-track="719">&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.05847777390856482" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-01 22:53">2025-01-01 22:53</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18646464" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18646464);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18646464', targetLink: 'https://www.cnblogs.com/mjunz/p/18646464', title: 'JVM实战—7.如何模拟GC场景并阅读GC日志' })">举报</a>
</div>
        