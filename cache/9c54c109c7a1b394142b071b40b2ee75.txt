
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/pigke/p/18652746" title="发布于 2025-01-04 23:14">
    <span role="heading" aria-level="2">某苏人社异步JS逆向加解密分析（sm2+sm3+sm4）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104231150178-1496634338.png" alt="某苏人社异步JS逆向加解密分析（sm2+sm3+sm4）" class="desc_img">
        某苏人社异步JS逆向加解密分析（sm2+sm3+sm4）
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前期准备">前期准备</h1>
<ul>
<li>网址：<code>aHR0cHM6Ly9ycy5qc2hyc3MuamlhbmdzdS5nb3YuY24vaW5kZXgv</code></li>
<li>目标：
<ol>
<li>接口请求内容加密和响应内容解密</li>
<li>请求头加密参数 <code>Web-Encrypt-Response-Encrypt-Key</code>和<code>Web-Encrypt-Sign</code></li>
</ol>
</li>
<li>涉及内容：
<ol>
<li>js <code>worker</code> 多线程通信</li>
<li><code>axios</code>网络请求库</li>
<li>国密<code>sm2</code>、<code>sm3</code>、<code>sm4</code></li>
</ol>
</li>
</ul>
<h2 id="axios">Axios</h2>
<p>网址：<a href="https://axios-http.com/" target="_blank" rel="noopener nofollow">Axios</a></p>
<p>这个网站用到了 axios，可以先了解一下 axios 这个网络请求库，主要是<code>interceptor</code>这块</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654066-1155231533.png" alt="" loading="lazy"></p>
<h2 id="拦截器"><strong>拦截器</strong></h2>
<p>在请求或响应被 then 或 catch 处理前拦截它们。</p>
<pre><code class="language-jsx">// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
return config;
  },function (error) {
    // 对请求错误做些什么
return Promise.reject(error);
  });

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
    // 2xx 范围内的状态码都会触发该函数。
    // 对响应数据做点什么
return response;
  },function (error) {
    // 超出 2xx 范围的状态码都会触发该函数。
    // 对响应错误做点什么
return Promise.reject(error);
  });

</code></pre>
<h1 id="分析流程">分析流程</h1>
<p>先来看一下要逆向的内容</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654762-32100955.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654054-880599026.png" alt="" loading="lazy"></p>
<p>如上图所示，获取考试列表（<code>getExamTaskIM</code>）这个接口的请求和返回数据都是加密的</p>
<h2 id="请求加密分析">请求加密分析</h2>
<p>老规矩直接看堆栈，进去第一个下个断点，刷新页面</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654218-619103270.png" alt="" loading="lazy"></p>
<p>成功断下后发现 xhr send 发送已经完成了加密</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654732-2049504752.png" alt="" loading="lazy"></p>
<p>往上找一下堆栈，发现一个<code>axios</code>的请求拦截器，直接下断点刷新</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654221-1051552459.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654758-1770858614.png" alt="" loading="lazy"></p>
<p>断住之后可以追进去看一下</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654158-1276342159.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654735-1842132400.png" alt="" loading="lazy"></p>
<p>有四个拦截器，分别进去下一个断点去查看，最终在最后一个拦截器发现关键数据</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654980-1252539459.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654730-1991696696.png" alt="" loading="lazy"></p>
<p>这是一个与<code>worker</code>进行通信的异步函数，我们往下看看其他逻辑</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654671-1994048761.png" alt="" loading="lazy"></p>
<p>发现有一个<code>onmessage</code>的回调方法，我猜测加密流程是这样的：</p>
<ol>
<li>主线程发送明文数据(<code>postMessage</code>)</li>
<li>work 线程接收并开始加密(<code>onMessage</code>)</li>
<li>work 线程加密完后发送加密数据给主线程(<code>postMessage</code>)</li>
<li>主线程接收加密数据(<code>onMessage</code>)</li>
</ol>
<blockquote>
<p>异步方法大都有一个回调的过程</p>
</blockquote>
<p>下图主线程为<code>postMessage</code>一方，其它线程则需要使用<code>onMessage</code>接受数据</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654770-179541512.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654160-870418352.png" alt="" loading="lazy"></p>
<p>接着分析流程，我们先在这个<code>onmessage</code>回调方法内下段，再跟堆栈就容易找到调用位置了</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654219-367973760.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654682-1553795450.png" alt="" loading="lazy"></p>
<p>找到<code>postMessage</code>后往上看看就能发现关键加密逻辑</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654725-2054489487.png" alt="" loading="lazy"></p>
<ul>
<li>源流程代码，大量的 promise</li>
</ul>
<pre><code class="language-jsx">self.onmessage = function(t) {
        var r, e, o, h, a, f, c;
        (r = t.data.prefix,
        e = t.data.data,
        o = e._s1,
        h = e._s2,
        a = e.requestData,
        f = Math.floor(Date.now() / 1e3).toString(),
        c = function() {
            return 2 === s
        }
        ,
        u.timestamp = f,
        new Promise((function(t, e) {
            new Promise((function(t, e) {
                try {
                    t({
                        key: r + i.default._s2EN(o, h, 0)
                    })
...
            }
...
            new Promise((function(t, e) {
                try {
                    var o = r + i.default._s2EN(JSON.stringify(a), h, 0)
                      , s = f + o;
                    t({
                        content: o,
                        signature: (0,
                        n.default)(s)
                    })
...
            }
...
        }
...
    }
</code></pre>
<p>进到这里了直接单步调试就是了，直接跟到_s2EN 函数里，这里就是加密函数了，加密函数用到了两次，一次加密 sign，一次加密 payload</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654675-451269944.png" alt="" loading="lazy"></p>
<p>这个其实就是<code>sm2</code>标准算法，看方法名就能猜出个大概了，就懒得写过程了，直接给出个大概的代码吧</p>
<pre><code class="language-jsx">var prefix = "04";
// 解密response的key
var _s1 = "862344dec7e0907a2b215c37a57caf95";
// 加密data的publicKey
var _s2 = "04fc439405f925df23510517e1e5a8078d19b23b24d62190c40e632f1d0bcd784fc6fcf1a8c3b5cf7f422815c6b322176e89f56f781ccd3c36aa02e5d31400090a";

// 计算key
key = prefix + sm2(_s1, _s2, 0);

// 加密payload，计算sign
payload = {
    "bge304": 202432990000309,
    "bge316": "320199"
}
var timestamp = Math.floor(Date.now() / 1000).toString();
var content = prefix + sm2(JSON.stringify(payload), _s2, 0)
var sign = sm3(timestamp + o);
headers= {
    "Web-Encrypt-Response-Encrypt-Key": key,
    "Web-Encrypt-Sign": sign ,
    "Web-Encrypt-Timestamp": timestamp
}
</code></pre>
<blockquote>
<p>sign 加密过程忘记截图了，实际上就是个<code>sm3</code>加密</p>
</blockquote>
<p>完成以上请求头和请求数据的加密后，就可以正常请求拿到返回数据了</p>
<h2 id="响应解密分析">响应解密分析</h2>
<p>跟找加密过程差不多，直接找到响应拦截器就行</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654768-2015719437.png" alt="" loading="lazy"></p>
<p>挨个下断点，发现第一个很像了</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654765-1518601920.png" alt="" loading="lazy"></p>
<p>这个<code>web-encrypt-sign</code>是响应头里的一个值，往下翻翻会发现熟悉的<code>postMessage</code>和<code>onMessage</code></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654678-985985820.png" alt="" loading="lazy"></p>
<p>这里过程跟加密差不多就不详细写过程了，直接找关键点</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654676-897643829.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654760-1888949024.png" alt="" loading="lazy"></p>
<p>看方法名能猜出个大概是<code>sm4</code>解密，解密的 key 就是之前传入的_s1</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654670-422968640.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654727-1329261857.png" alt="" loading="lazy"></p>
<p>随便抓个包解密试一下，可以看到正常解密成功，解密出来的 response 还需要 html 实体解码一下才行</p>
<h1 id="python-还原实现">Python 还原实现</h1>
<ul>
<li>代码：</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654724-216083934.png" alt="" loading="lazy"></p>
<ul>
<li>成果：</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230654669-563363772.png" alt="" loading="lazy"></p>
<p>大功告成！</p>
<h1 id="微信公众号">微信公众号</h1>
<p>公众号更新比较快，欢迎关注！<br>
<img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230616341-1563051605.png" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.20802769751273148" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-04 23:14">2025-01-04 23:14</span>&nbsp;
<a href="https://www.cnblogs.com/pigke">流星Studio</a>&nbsp;
阅读(<span id="post_view_count">3</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18652746" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18652746);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18652746', targetLink: 'https://www.cnblogs.com/pigke/p/18652746', title: '某苏人社异步JS逆向加解密分析（sm2+sm3+sm4）' })">举报</a>
</div>
        