
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SilverGo/p/19061718" title="发布于 2025-08-27 22:00">
    <span role="heading" aria-level="2">并查集提高——种类并查集（反集）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="table-of-contents">Table of Contents</h1>
<ol>
<li><a href="#orgc9e2be7" rel="noopener nofollow">前言：</a></li>
<li><a href="#org2ab51e0" rel="noopener nofollow">引子题： P1892 [BalticOI 2003] 团伙</a></li>
<li><a href="#org462eafb" rel="noopener nofollow">解法：</a>
<ol>
<li><a href="#orgbee64f6" rel="noopener nofollow">以下为题解：</a></li>
</ol>
</li>
<li><a href="#org20cfe9e" rel="noopener nofollow">具体的运作流程：</a></li>
<li><a href="#org9902ae2" rel="noopener nofollow">例题2:P2024 [NOI2001] 食物链</a>
<ol>
<li><a href="#orgbf56c85" rel="noopener nofollow">WriteUp：</a></li>
</ol>
</li>
<li><a href="#org82ca7e2" rel="noopener nofollow">补充：</a></li>
<li><a href="#org54641b0" rel="noopener nofollow">结语：</a></li>
</ol>
<p><a id="orgc9e2be7"></a></p>
<h1 id="前言">前言：</h1>
<p>本蒟蒻在今天刷题时遇到了种类并查集的问题，遂决定，花1小时学学，并写篇文章记录一下；<br>
那么如果你认真读完本文，你将自己发明<strong>种类并查集（反集）</strong>；<br>
前置知识：<strong>普通并查集</strong>；</p>
<p><a href="https://www.cnblogs.com/SilverGo/p/19055961" title="普通并查集" target="_blank">普通并查集</a></p>
<p><a id="org2ab51e0"></a></p>
<h1 id="引子题-p1892-balticoi-2003-团伙">引子题： P1892 [BalticOI 2003] 团伙</h1>
<p>## 题目描述<br>
现在有 <span class="math inline">\(n\)</span> 个人，他们之间有两种关系：朋友和敌人。我们知道：</p>
<ul>
<li>一个人的朋友的朋友是朋友</li>
<li>一个人的敌人的敌人是朋友</li>
</ul>
<p>现在要对这些人进行组团。两个人在一个团体内当且仅当这两个人是朋友。请求出这些人中最多可能有的团体数。</p>
<p>## 输入格式<br>
第一行输入一个整数 <span class="math inline">\(n\)</span> 代表人数。<br>
第二行输入一个整数 <span class="math inline">\(m\)</span> 表示接下来要列出 <span class="math inline">\(m\)</span> 个关系。<br>
接下来 <span class="math inline">\(m\)</span> 行，每行一个字符 <span class="math inline">\(opt\)</span> 和两个整数 <span class="math inline">\(p,q\)</span>，分别代表关系（朋友或敌人），有关系的两个人之中的第一个人和第二个人。其中 <span class="math inline">\(opt\)</span> 有两种可能：</p>
<ul>
<li>如果 <span class="math inline">\(opt\)</span> 为 `F`，则表明 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 是朋友。</li>
<li>如果 <span class="math inline">\(opt\)</span> 为 `E`，则表明 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 是敌人。</li>
</ul>
<p>## 输出格式<br>
一行一个整数代表最多的团体数。</p>
<p>## 说明/提示<br>
对于 <span class="math inline">\(100\%\)</span> 的数据，<span class="math inline">\(2 \le n \le 1000\)</span>，<span class="math inline">\(1 \le m \le 5000\)</span>，<span class="math inline">\(1 \le p,q \le n\)</span>。</p>
<p><a id="org462eafb"></a></p>
<h1 id="解法">解法：</h1>
<p>上面的题在洛谷，可以自己尝试；</p>
<p>如果你没学过种类并查集（反集），你应该会想到使用并查集维护朋友关系，用数组维护敌人关系，随后遍历每个人的每个敌人的每个敌人，将这个人和他敌人的敌人合并；<br>
但是，我们注意到，这样做的代价是：空间复杂度 <span class="math inline">\(O(n^2)\)</span> ，时间复杂度 <span class="math inline">\(O(n^3)\)</span> ；<br>
若是题目的数据再大一个数量级，这么做会爆；<br>
不过，这样也可以AC了这道题，毕竟还是比较水的；</p>
<p>如果你想到了维护敌人并查集，那你已经有了相当好的直觉，事实上，种类并查集也类似在维护一个新并查集；<br>
但是，对于敌人并查集，这里的设定很关键：如果你设成一个集合内部是朋友，那么会非常复杂，问题是，你如何由敌对推出朋友呢，仍然需要存储每个人的敌人，这样做依然不好；<br>
如果你设定一个集合内部是敌人，那么一个人和另一个人的关系仍然不好维护，因为如果是朋友关系，AB是朋友，BC是朋友，AC一定是朋友，但是对于敌对关系，AB是敌人，BC是敌人，AC就是朋友了；<br>
这破坏了集合<strong>传递性</strong>（即若AB共集，BC共集，那么AC共集）；</p>
<p>我们先来反思一下为什么普通并查集不行：<br>
最重要的是，敌人关系不满足集合的传递性这个数学要求，从而并查集不成立；<br>
事实上，普通并查集维护的是两个人是不是共集的信息，而对于两个人各自的相对身份（注意：相对身份，A对于B是朋友，对于C可能就是敌人了）我们一无所知；<br>
那么怎样维护这种多重身份呢；（换言之，怎样恢复传递性）</p>
<p>从传递性入手：朋友关系才具有传递性，所以我们要想办法将敌对关系换成朋友关系；<br>
“敌人关系本身不传递，但敌人的敌人是朋友——这句话其实把‘敌对’转换成了‘朋友’，于是我们又可以用并查集了。”</p>
<p>若是我们开一个长度为 <span class="math inline">\(2n\)</span> 的并查集<br>
1.当 <span class="math inline">\(1 \le i \le n\)</span> 时，i为其朋友集，所有与i是朋友关系的人会接到这个集合中（即普通的并查集）<br>
2.当 <span class="math inline">\(n+1 \le i \le 2n\)</span> 时，i(实际上是i+n)为敌对集，所有i的敌人都会接入这个集合中</p>
<p>若 <span class="math inline">\(u,v\)</span> 是朋友，我们执行 union<sub>set</sub>(u,v)，若 <span class="math inline">\(u,v\)</span> 是敌人，我们 union<sub>set</sub>(u+n,v) 、union<sub>set</sub>(u,v+n);<br>
朋友显然不需要解释，那么敌人为什么要这样合并呢，我们依据定义：所有i的敌人是i的敌对集的成员，那么谁和u的敌人共集呢，显然也是u的敌人，所以有了：union<sub>set</sub>(u+n,v)，即将v加入u的敌人集；<br>
那么谁和u共集呢，显然是v的敌人，所以有union<sub>set</sub>(u,v+n)；<br>
这样实际上利用了：敌人的敌人就是朋友这一性质，将无法维护（无法合并）的敌对关系换成了朋友关系；</p>
<p>接下来思考这样一个问题：若一个人同时是两个人的敌人，冲突吗；<br>
你可能会觉得，这会冲突，因为根据集合的定义，不允许一个人同时归属两个集合，但是注意，我们使用的是并查集，这两个集合会合并，因此并不冲突；</p>
<p><a id="orgbee64f6"></a></p>
<h2 id="以下为题解">以下为题解：</h2>
<p>WriteUp 种类并查集解<br>
我们定义，在 <span class="math inline">\(f_i\)</span> 中，当 <span class="math inline">\(1 \le i \le n\)</span> 时，为i的朋友集，当 <span class="math inline">\(n+1 \le i+n \le 2n\)</span> 时，为i的敌对集；<br>
当 <span class="math inline">\(u,v\)</span> 是朋友，我们执行 union<sub>set</sub>(u,v)，当 <span class="math inline">\(u,v\)</span> 是敌人，我们 union<sub>set</sub>(u+n,v) 、union<sub>set</sub>(u,v+n);<br>
下面给出AC代码：</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
int n, m;
char x;      // 操作符
int fa[2006]; // 并查集数组，大小设为2*n
int t1, t2;  
int ans;
bool vis[2006]; // 用于标记已统计的根节点

int findx(int x) {
    return x == fa[x] ? x : fa[x] = findx(fa[x]);
}

void union_set(int x, int y) {
    int rx = findx(x), ry = findx(y);
    if (rx != ry) {
        fa[rx] = ry;
    }
}

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= 2 * n; i++) {
        fa[i] = i;
    }
    for (int i = 1; i &lt;= m; i++) {
        cin &gt;&gt; x;
        if (x == 'F') {
            cin &gt;&gt; t1 &gt;&gt; t2;
            union_set(t1, t2);
        } else {
            cin &gt;&gt; t1 &gt;&gt; t2;
            union_set(t1 + n, t2);
            union_set(t1, t2 + n);
        }
    }
    // 路径压缩所有主要节点
    for (int i = 1; i &lt;= n; i++) {
        findx(i);
    }
    // 统计不同根节点
    for (int i = 1; i &lt;= n; i++) {
        int root = findx(i);
        if (!vis[root]) {
            vis[root] = true;  //统计所有不一样的根，因为可能有的以敌人集为根
            ans++;
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<p><a id="org20cfe9e"></a></p>
<h1 id="具体的运作流程">具体的运作流程：</h1>
<p>我们先定义这样一些关系，方便演示：<br>
1 2 是朋友，1 3 是朋友<br>
1 4 是敌人，4 5 是敌人；</p>
<p>根据我们的定义，最终，1235是一个集合<br>
接下来看图：<br>
我们先加入朋友边，不难发现，1 2 3形成了一个联通的区域，我们称为一个联通块，显然，同一个联通块是一个集合；<br>
随后，加入（1，4反集），（1反集，4）这两个敌人边，即（1，9）（6，4），这里n=5，一共五个人；<br>
现在出现了两个联通块，分别是：（1，2，3，4反），（4，1反）；<br>
我们继续加入4，5的敌人关系，就是：（4，5反）（4反，5），即（4，10）（9，5）；</p>
<p>不难发现，现在，并查集已经正确处理了所有的关系；<br>
更准确的说，4的反集是一个中间量，建立起了1和5的朋友关系（由于4的敌人和1是一个集，所以1，5共集），这就是反集的作用，它通过转换，维护了不具备传递性的敌人关系；</p>
<p>这里有个坑，不难发现，我在代码中使用了vis数组，这是由于敌人集可能是根，也需要一并统计；</p>
<p><a id="org9902ae2"></a></p>
<h1 id="例题2p2024-noi2001-食物链">例题2:P2024 [NOI2001] 食物链</h1>
<p>## 题目描述</p>
<p>动物王国中有三类动物 <span class="math inline">\(A,B,C\)</span>，这三类动物的食物链构成了有趣的环形。<span class="math inline">\(A\)</span> 吃 <span class="math inline">\(B\)</span>，<span class="math inline">\(B\)</span> 吃 <span class="math inline">\(C\)</span>，<span class="math inline">\(C\)</span> 吃 <span class="math inline">\(A\)</span>。<br>
现有 <span class="math inline">\(N\)</span> 个动物，以 <span class="math inline">\(1 \sim N\)</span> 编号。每个动物都是 <span class="math inline">\(A,B,C\)</span> 中的一种，但是我们并不知道它到底是哪一种。<br>
有人用两种说法对这 <span class="math inline">\(N\)</span> 个动物所构成的食物链关系进行描述：</p>
<ul>
<li>第一种说法是 `1 X Y`，表示 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是同类。</li>
<li>第二种说法是`2 X Y`，表示 <span class="math inline">\(X\)</span> 吃 <span class="math inline">\(Y\)</span>。</li>
</ul>
<p>此人对 <span class="math inline">\(N\)</span> 个动物，用上述两种说法，一句接一句地说出 <span class="math inline">\(K\)</span> 句话，这 <span class="math inline">\(K\)</span> 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p>
<ul>
<li>当前的话与前面的某些真的话冲突，就是假话；</li>
<li>当前的话中 <span class="math inline">\(X\)</span> 或 <span class="math inline">\(Y\)</span> 比 <span class="math inline">\(N\)</span> 大，就是假话；</li>
<li>当前的话表示 <span class="math inline">\(X\)</span> 吃 <span class="math inline">\(X\)</span>，就是假话。</li>
</ul>
<p>你的任务是根据给定的 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(K\)</span> 句话，输出假话的总数。</p>
<p>## 输入格式</p>
<p>第一行两个整数，<span class="math inline">\(N,K\)</span>，表示有 <span class="math inline">\(N\)</span> 个动物，<span class="math inline">\(K\)</span> 句话。<br>
第二行开始每行一句话（按照题目要求，见样例）</p>
<p>## 输出格式<br>
一行，一个整数，表示假话的总数。</p>
<p><a id="orgbf56c85"></a></p>
<h2 id="writeup">WriteUp：</h2>
<p>这道题我们可以通过扩展并查集（种类并查集）来做，也可以使用加权并查集；<br>
当然，由于还没讲到加权并查集，这里使用扩展并查集；<br>
补充一个点：有几种关系就要开几倍的并查集；</p>
<p>接下来分析一下这道题：<br>
一共三种动物，A吃B，B吃C，C吃A，所以我们开 <span class="math inline">\(3 \times n\)</span> 的种类并查集；<br>
那么一共两种情况（我们先假设都为真）：1. <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是同类，2. <span class="math inline">\(X\)</span> 吃 <span class="math inline">\(Y\)</span> ；<br>
细分下去，当 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是同类时，我们其实不知道 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 具体属于AA、BB还是CC，因此，我们需要合并3个集合中的XY，这代表XY是同类<br>
同样，当 <span class="math inline">\(X\)</span> 吃 <span class="math inline">\(Y\)</span> 时，我们也不知道是AB、BC还是AC，同样需要合并x的A集和y的B集、x的B集和y的C集、x的C集和y的A集；</p>
<p>上面的分类不好理解，更准确的讲，我们称A集为本体集，B集为猎物集，C集为天敌集</p>
<ul>
<li>对于同类，同类的天敌就是天敌，同类的猎物就是猎物</li>
<li>对于y是x的猎物， 将y加入x的猎物集，将x加入y的天敌集，将x的天敌加入y的猎物集<br>
（这里只有“将x的天敌加入y的猎物集”是不好理解的，我们进行一下推理：设z是x的天敌，由于y是x的猎物，x是z的猎物，那么z是y的猎物（因为C吃A））</li>
</ul>
<p>那么，怎样判断一句话是否为假呢？<br>
题目给了我们提示：</p>
<ul>
<li>当前的话与前面的某些真的话冲突，就是假话；</li>
<li>当前的话中 <span class="math inline">\(X\)</span> 或 <span class="math inline">\(Y\)</span> 比 <span class="math inline">\(N\)</span> 大，就是假话；</li>
<li>当前的话表示 <span class="math inline">\(X\)</span> 吃 <span class="math inline">\(X\)</span>，就是假话。</li>
</ul>
<p>后两个比较好判断，关键是1，什么叫冲突；</p>
<p>根据真假逆命题的关系，我们反转条件，归结为下面的几类：<br>
1.xy是同类，但是当前的话表示：x吃y或者y吃x；<br>
2.x吃y，但是当前的话表示：y吃x、xy是同类</p>
<p>下面给出AC代码：</p>
<pre><code>#include&lt;cstdio&gt;
using namespace std;
int n,k;
int op,p,q;
int ans;
int fa[150004];
int findx(int x) {
    return x==fa[x]?x:fa[x] = findx(fa[x]);
}
void union_set(int u,int v) {
    int rx = findx(u),ry = findx(v);
    if (rx!=ry) {
        fa[ry] = rx;
    }
}
void init(int x) {
    for (int  i=1;i&lt;=x;i++) {
        fa[i] = i;
    }
}
bool is_not_lie(int o,int x,int y) {
    if (x&gt;n || y&gt;n) return false; //xy比n大
    if (o==1) {
        if (findx(x)==findx(y+n)||findx(y)==findx(x+n)) {
            //x是y的猎物，或者y是x的猎物
            return false;
        }
    }else {
        if (x==y) return false;//x吃x
        if (findx(x)==findx(y+n)) return false; //x是y的猎物
        if (findx(x)==findx(y)) return false; //是同类
    }
    return true;
}
int main() {
    scanf("%d %d",&amp;n,&amp;k);
    init(3*n);
    for(int i=1;i&lt;=k;i++) {
        scanf("%d %d %d",&amp;op,&amp;p,&amp;q);
        if (!is_not_lie(op,p,q)) {
            ans++;
            continue;
        }else {
            if (op==1) {
                union_set(p,q);// 同类
                union_set(p+n,q+n);// 同类的猎物是猎物
                union_set(p+2*n,q+2*n); // 同类的敌人是敌人
            }else {
                union_set(p+n,q); //y是x的猎物
                union_set(p,q+2*n);//x是y的天敌
                union_set(p+2*n,q+n);//由 y-&gt;x-&gt;z-&gt;y 得x的天敌是y的猎物
            }
        }
    }
    printf("%d",ans);
    return 0;
}
</code></pre>
<p><a id="org82ca7e2"></a></p>
<h1 id="补充">补充：</h1>
<p>1.对于第一题，普通做法是 <span class="math inline">\(O(n^3)\)</span> 的，种类并查集做法是 <span class="math inline">\(O(n \alpha(a))\)</span> 的，近似线性；<br>
2.对于并查集的题目，可以采用先不编写函数实现，直接写main，之后依次实现需要的函数和变量的方法；<br>
3.种类并查集是加权并查集的特例，这里面的两道题都可以使用加权并查集做，但是逻辑比较复杂，空间会更小（仍为普通并查集的大小，即 <span class="math inline">\(O(n)\)</span> ）</p>
<p><a id="org54641b0"></a></p>
<h1 id="结语">结语：</h1>
<blockquote>
<p>“当你在锻炼，你觉得自己很累时，实际上你在变强；当你在学习，你觉得自己很傻时，其实你在变聪明”</p>
</blockquote>
<blockquote>
<p>所以，不要放弃尝试困难的东西，那些NOI随便就AK的人，也是这么过来的</p>
</blockquote>
<p>如有笔误，烦请诸位不吝赐教；</p>
<p>Upt 2025.8.27</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-27 22:01">2025-08-27 22:00</span>&nbsp;
<a href="https://www.cnblogs.com/SilverGo">Ghost-Face</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19061718);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19061718', targetLink: 'https://www.cnblogs.com/SilverGo/p/19061718', title: '并查集提高——种类并查集（反集）' })">举报</a>
</div>
        