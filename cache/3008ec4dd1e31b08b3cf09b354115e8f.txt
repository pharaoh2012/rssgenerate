
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wJiang/p/18895168" title="发布于 2025-05-26 09:17">
    <span role="heading" aria-level="2">【实战】Rust与前端协同开发：基于Tauri的跨平台AI阅读器实践</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0.08093325451967592" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-26 09:18">2025-05-26 09:17</span>&nbsp;
<a href="https://www.cnblogs.com/wJiang">姜 萌@cnblogs</a>&nbsp;
阅读(<span id="post_view_count">45</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18895168);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18895168', targetLink: 'https://www.cnblogs.com/wJiang/p/18895168', title: '【实战】Rust与前端协同开发：基于Tauri的跨平台AI阅读器实践' })">举报</a>
</small>
    <div class="entry">
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景与目标为什么做一个非典型的rss阅读器">一、背景与目标：为什么做一个“非典型”的RSS阅读器？</h2>
<p>在信息爆炸的时代，RSS依然是高效获取结构化内容的重要方式，但市面上主流阅读器要么功能冗余（如集成社交属性），要么技术栈陈旧（依赖Electron导致内存占用高、性能差）。我们希望打造一款<strong>简约轻量、高效率、高性能、隐私安全</strong>的RSS阅读器，核心需求包括：</p>
<ul>
<li>智库情报引擎：支持基于搜索引擎的信息抓取与RSS源订阅。</li>
<li>由AI驱动的特色能力：自动翻译、内容摘要、AI伴读。</li>
<li>隐私与安全：数据本地化存储，用户完全掌控隐私，不依赖第三方云服务；</li>
<li>跨平台与高性能：跨Windows/macOS/Linux三端，适配低配置设备，保证流畅运行。</li>
</ul>
<p>最终选择 <strong>Rust+Web</strong> 的技术组合，这一选择背后是对性能、开发效率与跨平台能力的深度权衡。</p>
<h3 id="关于saga-reader">关于Saga Reader</h3>
<p>基于Tauri开发的开源AI驱动的智库式阅读器（前端部分使用Web框架），能根据用户指定的主题和偏好关键词自动从互联网上检索信息。它使用云端或本地大型模型进行总结和提供指导，并包括一个AI驱动的互动阅读伴读功能，你可以与AI讨论和交换阅读内容的想法。</p>
<p>这个项目我5月刚放到Github上（<a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><strong>Github - Saga Reader</strong></a>），欢迎大家关注分享。🧑‍💻码农🧑‍💻开源不易，各位好人路过请给个小星星💗<strong>Star</strong>💗。</p>
<p><strong>核心技术栈</strong>：Rust + Tauri（跨平台）+ Svelte（前端）+ LLM（大语言模型集成），支持<strong>本地 / 云端双模式</strong></p>
<p><strong>关键词</strong>：端智能，边缘大模型；Tauri 2.0；桌面端安装包 &lt; 5MB，内存占用 &lt; 20MB。</p>
<p><strong>运行截图</strong><br>
<img src="https://i-blog.csdnimg.cn/direct/b5606237eca44ddf9fc1b83cf6d27601.png" alt="在这里插入图片描述" loading="lazy"></p>
<hr>
<h2 id="二技术选型rust前端如何通过tauri实现112">二、技术选型：Rust+前端如何通过Tauri实现“1+1&gt;2”？</h2>
<p><img src="https://i-blog.csdnimg.cn/direct/02b0135ae6c24a8c9db185a84a6dfce1.png" alt="Saga Reader核心模块依赖关系" loading="lazy"></p>
<h3 id="1-前端框架svelte的轻量哲学">1. 前端框架：Svelte的“轻量”哲学</h3>
<p>传统前端框架（如React/Vue）依赖运行时支持，产物体积大且存在多余的性能开销，而更现代化的Svelte框架通过编译时转换代码，生成直接操作DOM的最小化JS包。在我们的项目中：</p>
<ul>
<li><a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><code>app/src/routes</code></a> 目录下的页面组件编译后体积仅15KB（未压缩），对比同复杂度的React应用小<strong>40%</strong>；</li>
<li>Svelte的响应式状态管理（<code>$:</code> 自动追踪依赖）与Tauri的IPC（进程间通信）天然契合。前端通过 <a target="_blank"><code>tauri.invoke</code></a> 调用Rust接口后，可直接更新响应式状态（示例代码见 <a target="_blank"><code>app/src/lib/store.ts</code></a>）。</li>
</ul>
<h3 id="2-后端核心rust的安全性能双保险">2. 后端核心：Rust的“安全+性能”双保险</h3>
<p>RSS阅读器的核心瓶颈在于<strong>数据解析、网络IO与本地存储</strong>。Rust的 <code>serde</code>（序列化/反序列化）+ <code>reqwest</code>（HTTP客户端）+ <code>sqlx</code>（数据库ORM）组合完美解决了这些问题：</p>
<ul>
<li><code>serde</code> 配合自定义 <code>Deserialize</code> 实现，可兼容90%以上非标准Feed（代码见 <a target="_blank"><code>crates/feed_api_rs/src/parser.rs</code></a>）；</li>
<li><code>tokio</code> 异步运行时让100+并发请求的延迟控制在<strong>200ms</strong>内；</li>
<li>Rust的零成本抽象（如 <code>enum</code> 错误类型）让前后端接口定义更严谨（<a target="_blank"><code>crates/types/src/lib.rs</code></a> 定义了统一的 <code>FeedItem</code> 结构体）。</li>
</ul>
<h3 id="3-跨平台桥梁tauri替代electron的底层逻辑">3. 跨平台桥梁：Tauri替代Electron的底层逻辑</h3>
<p>选择Tauri而非Electron的核心原因是<strong>资源占用</strong>，我们不想让用户因为一个工具应用消耗他的硬件资源以及宝贵的用户时间：</p>
<ul>
<li>Tauri基于系统原生WebView（如Windows的WebView2），而非捆绑Chromium，安装包体积仅Electron应用的1/3（我们的Windows安装包为18MB，同功能Electron应用约60MB）；</li>
<li>Tauri的IPC通信通过 <code>tauri-plugin</code> 机制封装，前端调用Rust接口时，参数自动序列化/反序列化（示例：<a target="_blank"><code>app/src/lib/api/feed.ts</code></a> 中 <a target="_blank"><code>updateFeed</code></a> 函数调用 <a target="_blank"><code>tauri.invoke('update_feed', { url })</code></a>，对应 <a target="_blank"><code>src-tauri/src/handlers.rs</code></a> 的 <a target="_blank"><code>update_feed</code></a> 函数）；</li>
<li>构建配置更灵活：通过 <a target="_blank"><code>src-tauri/tauri.conf.json</code></a> 可定制各平台的打包参数（如Windows的图标、macOS的签名）。</li>
</ul>
<hr>
<h2 id="三关键实现从想法到可用的技术细节">三、关键实现：从“想法”到“可用”的技术细节</h2>
<h3 id="1-rust插件开发如何让前端调用rust能力">1. Rust插件开发：如何让前端“调用”Rust能力？</h3>
<p>项目中 <a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><code>crates/tauri-plugin-feed-api</code></a> 是核心插件，它通过以下步骤暴露Rust功能给前端：</p>
<ul>
<li><strong>定义接口</strong>：在 <a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><code>src/lib.rs</code></a> 中使用 <code>tauri::command</code> 宏标记可调用函数（如 <code>fetch_feed(url: &amp;str)</code>）；</li>
<li><strong>注册插件</strong>：在 <a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><code>src-tauri/src/main.rs</code></a> 中通过 <code>tauri::Builder::plugin</code> 注册插件，确保前端能通过 <code>tauri.invoke</code> 访问；</li>
<li><strong>类型对齐</strong>：前端 <a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><code>types.d.ts</code></a>（<code>app/src/app.d.ts</code>）需与Rust的 <code>crates/types/src/lib.rs</code> 结构体完全一致（如 <code>FeedItem</code> 的 <code>title</code>、<code>pub_date</code> 字段），避免通信时类型错误。</li>
</ul>
<h3 id="2-前端性能优化svelte与tailwind的减法艺术">2. 前端性能优化：Svelte与Tailwind的“减法艺术”</h3>
<ul>
<li><strong>按需加载</strong>：通过Vite的 <code>import.meta.glob</code> 实现路由懒加载（<code>app/src/routes/+page.svelte</code> 中动态导入子页面）；</li>
<li><strong>样式隔离</strong>：Tailwind的 <code>@apply</code> 指令配合Svelte的 <code>style</code> 标签，避免全局样式污染（<a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><code>app/src/app.css</code></a> 中定义基础样式，页面组件内使用局部类名）；</li>
<li><strong>状态管理</strong>：<a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><code>app/src/lib/store.ts</code></a> 中通过 <code>writable</code> 存储当前选中的Feed，组件订阅该状态自动更新（对比Redux减少了30%样板代码）。</li>
</ul>
<h3 id="3-跨平台兼容三端差异化处理的底层逻辑">3. 跨平台兼容：三端“差异化”处理的底层逻辑</h3>
<ul>
<li><strong>文件路径</strong>：Rust使用 <code>std::path::PathBuf</code> 处理不同系统的路径分隔符（<a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><code>crates/recorder/src/storage.rs</code></a> 中 <code>get_db_path</code> 函数根据 <code>std::env::consts::OS</code> 动态拼接路径）；</li>
<li><strong>权限申请</strong>：Windows下需要管理员权限写入 <code>Program Files</code> 目录，通过Tauri的 <code>before_quit</code> 钩子检查权限（<code>src-tauri/src/hooks.rs</code> 中 <code>check_permission</code> 函数）；</li>
<li><strong>通知功能</strong>：利用系统原生通知API（如macOS的 <code>NSUserNotification</code>、Windows的 <code>ToastNotification</code>），通过 <code>tauri-plugin-notification</code> 实现跨平台调用（前端 <code>app/src/lib/utils/notify.ts</code> 封装了统一接口）。</li>
</ul>
<hr>
<h2 id="四踩坑与解决方案从跑起来到稳定跑">四、踩坑与解决方案：从“跑起来”到“稳定跑”</h2>
<h3 id="1-rss解析的非标之痛">1. RSS解析的“非标”之痛</h3>
<p>早期遇到部分Feed源返回带 <code>CDATA</code> 标签的描述字段，<code>serde_xml_rs</code> 默认无法解析。解决方案：</p>
<ul>
<li>在 <a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><code>crates/feed_api_rs/src/parser.rs</code></a> 中自定义 <code>XmlDecoder</code>，使用 <code>regex</code> 库匹配 <code>CDATA</code> 标签并提取内容；</li>
<li>对解析失败的Feed，记录错误类型（如 <code>InvalidXml</code>、<code>MissingField</code>）并返回给前端提示用户（<a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><code>crates/types/src/error.rs</code></a> 定义了详细的错误枚举）。</li>
</ul>
<h3 id="2-tauri-ipc的性能陷阱">2. Tauri IPC的“性能陷阱”</h3>
<p>前端高频调用Rust接口（如滚动加载时批量获取历史记录）导致主线程阻塞。优化方案：</p>
<ul>
<li>将耗时操作（如数据库查询）放入 <code>tokio::spawn</code> 异步任务（<a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><code>src-tauri/src/handlers/history.rs</code></a> 中 <code>get_history</code> 函数使用 <code>async</code> 标记）；</li>
<li>限制单次IPC调用的参数大小（超过1MB的数据改为文件缓存，通过临时文件路径传递）。</li>
</ul>
<h3 id="3-构建配置的平台差异">3. 构建配置的“平台差异”</h3>
<p>macOS打包时签名失败，原因是 <a href="https://github.com/sopaco/saga-reader" target="_blank" rel="noopener nofollow"><code>tauri.conf.json</code></a> 中 <code>macOS.identity</code> 配置错误。解决步骤：</p>
<ul>
<li>通过 <code>security find-identity -p codesigning</code> 命令获取正确的签名证书ID；</li>
<li>在 <code>src-tauri/tauri.conf.json</code> 中设置 <code>"identity": "ABCDEF123456"</code>，并添加 <code>"entitlements": "src-tauri/entitlements.plist"</code> 指定权限；</li>
<li>参考Tauri官方文档调整 <code>build.macos</code> 字段。</li>
</ul>
<hr>
<h2 id="五总结rust前端协同开发的得与失">五、总结：Rust+前端协同开发的“得与失”</h2>
<h3 id="得">得：</h3>
<ul>
<li><strong>性能</strong>：Rust处理数据的效率是JS的5-10倍（如Feed解析耗时从500ms降至80ms）；</li>
<li><strong>体积</strong>：Tauri应用的安装包比Electron小60%以上，更符合用户对“轻量工具”的期待；</li>
<li><strong>可维护性</strong>：Rust的类型系统与前端TypeScript形成“双保险”，减少运行时错误。</li>
</ul>
<h3 id="失">失：</h3>
<ul>
<li><strong>学习成本</strong>：前端开发者需掌握Rust基础（如所有权机制），后端开发者需理解前端构建流程（如Vite的 <code>resolve.alias</code> 配置）；</li>
<li><strong>调试复杂度</strong>：跨进程调试（前端调用Rust接口）需要同时监听前端控制台和Rust日志（通过 <code>tauri dev</code> 命令同时输出两端日志）。</li>
</ul>
<h3 id="给开发者的建议">给开发者的建议：</h3>
<ul>
<li>优先用Rust处理计算密集型/IO密集型任务（如数据解析、网络请求），前端专注UI交互；</li>
<li>统一前后端数据类型（推荐用TypeScript + Rust struct双向生成）；</li>
<li>善用Tauri的 <code>beforeDevCommand</code> 和 <code>beforeBuildCommand</code> 钩子（如 <code>app/vite.config.ts</code> 中配置 <code>beforeDevCommand: 'cargo build --package tauri-plugin-feed-api'</code>，自动编译Rust插件）。</li>
</ul>
<p>希望这篇实践能为跨平台开发的同学提供参考，也欢迎在项目仓库（<code>saga-reader</code>）提Issue讨论更多细节！</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>&nbsp;</p>
<div style="filter: progid:DXImageTransform.Microsoft.Gradient(GradientType=1,StartColorStr='#6699FF',EndColorStr='#A1FBFF">
<table>
<tbody>
<tr>
<td rowspan="4"><img alt="" src="https://images.cnblogs.com/cnblogs_com/wJiang/233935/t_a.jpg"></td>
<td>
<p>网名：</p></td>
<td>
<p>无疆_炎戎<br>无疆_寒冰</p></td></tr>
<tr>
<td>
<p>实名：</p>
</td><td>
<p>姜萌</p></td></tr>
<tr>
<td colspan="2"><a href="http://www.wjiangathpc.spaces.live.com/" target="_blank">http://www.wjiangathpc.spaces.live.com/</a></td></tr>
<tr>
<td colspan="2"><a href="http://www.cnblogs.com/wJiang" target="_blank">http://www.cnblogs.com/wJiang</a></td></tr></tbody></table></div>
<p>&nbsp;</p>
<div id="license"><a href="http://creativecommons.org/licenses/by/2.5/cn/" rel="license" target="_blank"><img style="border-right-width: 0px; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" alt="Creative Commons License" src="http://i.creativecommons.org/l/by/2.5/cn/88x31.png"></a><br>本<span xmlns:dc="http://purl.org/dc/elements/1.1/" href="http://purl.org/dc/dcmitype/Text" rel="dc:type">作品</span>由<a href="http://www.cnblogs.com/" rel="cc:attributionURL" target="_blank" xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">姜萌</a>创作，采用<a href="http://creativecommons.org/licenses/by/2.5/cn/" rel="license" target="_blank">知识共享署名 2.5 中国大陆许可协议</a>进行许可。 </div>
</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="wJiang" blog-id="64968" post-id="18895168"></vc:categories-tags>
    </ul>
