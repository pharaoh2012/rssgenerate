
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18646998" title="发布于 2025-01-02 10:34">
    <span role="heading" aria-level="2">JSON解析的这6种方案，真香！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>在 Java 开发中，解析 JSON 是一个非常常见的需求。</p>
<p>不管是和前端交互、调用第三方接口，还是处理配置文件，几乎都绕不开 JSON。</p>
<p>这篇文章总结了6种主流的 JSON 解析方法，希望对你会有所帮助。</p>
<p>(我最近开源了一个基于 SpringBoot+Vue+uniapp 的商城项目，欢迎访问和star。)[<a href="https://gitee.com/dvsusan/susan_mall" target="_blank" rel="noopener nofollow">https://gitee.com/dvsusan/susan_mall</a>]</p>
<h2 id="1-使用-jackson业界标配">1. 使用 Jackson：业界标配</h2>
<h4 id="功能特点"><strong>功能特点</strong></h4>
<ul>
<li><strong>强大的序列化和反序列化</strong>：支持将 JSON 字符串转为 Java 对象，也支持将 Java 对象转换为 JSON。</li>
<li><strong>支持复杂结构</strong>：处理嵌套对象、数组、泛型等场景非常轻松。</li>
<li><strong>支持注解</strong>：如 <code>@JsonIgnore</code>、<code>@JsonProperty</code> 等，能精细控制序列化与反序列化的行为。</li>
<li><strong>性能高</strong>：Jackson 的性能非常出色，是很多企业级项目的首选。</li>
</ul>
<h4 id="代码示例"><strong>代码示例</strong></h4>
<p><strong>1. JSON 转对象（反序列化）</strong></p>
<pre><code class="language-java">import com.fasterxml.jackson.databind.ObjectMapper;

public class JacksonExample {
    public static void main(String[] args) throws Exception {
        String json = "{\"id\":1,\"name\":\"张三\"}";

        ObjectMapper objectMapper = new ObjectMapper();
        User user = objectMapper.readValue(json, User.class);
        System.out.println(user.getName()); // 输出：张三
    }
}

class User {
    private int id;
    private String name;

    // Getters 和 Setters 省略
}
</code></pre>
<p><strong>2. 对象转 JSON（序列化）</strong></p>
<pre><code class="language-java">User user = new User();
user.setId(1);
user.setName("李四");

ObjectMapper objectMapper = new ObjectMapper();
String json = objectMapper.writeValueAsString(user);
System.out.println(json); // 输出：{"id":1,"name":"李四"}
</code></pre>
<h4 id="高级功能"><strong>高级功能</strong></h4>
<ul>
<li><strong>日期格式化</strong>：<code>@JsonFormat(pattern = "yyyy-MM-dd")</code></li>
<li><strong>忽略字段</strong>：<code>@JsonIgnore</code></li>
<li><strong>重命名字段</strong>：<code>@JsonProperty("custom_name")</code></li>
</ul>
<h4 id="优缺点"><strong>优缺点</strong></h4>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能全面，支持复杂场景</td>
<td>配置较多，学习成本稍高</td>
</tr>
<tr>
<td>性能高，社区活跃，企业级项目首选</td>
<td>过于强大，部分功能用不上</td>
</tr>
<tr>
<td>丰富的注解支持，便于控制序列化行为</td>
<td>库体积较大，对于小型项目略显笨重</td>
</tr>
</tbody>
</table>
<h2 id="2-使用-gson轻量好用">2. 使用 Gson：轻量好用</h2>
<h4 id="功能特点-1"><strong>功能特点</strong></h4>
<ul>
<li><strong>轻量级</strong>：Gson 的设计非常简洁，代码量少，适合中小型项目。</li>
<li><strong>支持泛型</strong>：可以轻松解析带泛型的 JSON。</li>
<li><strong>注解控制</strong>：支持通过注解控制序列化行为，如 <code>@Expose</code>。</li>
<li><strong>易扩展</strong>：通过自定义序列化器和反序列化器，可以处理复杂的场景。</li>
</ul>
<h4 id="代码示例-1"><strong>代码示例</strong></h4>
<p><strong>1. JSON 转对象</strong></p>
<pre><code class="language-java">import com.google.gson.Gson;

public class GsonExample {
    public static void main(String[] args) {
        String json = "{\"id\":1,\"name\":\"王五\"}";

        Gson gson = new Gson();
        User user = gson.fromJson(json, User.class);
        System.out.println(user.getName()); // 输出：王五
    }
}
</code></pre>
<p><strong>2. 对象转 JSON</strong></p>
<pre><code class="language-java">User user = new User();
user.setId(2);
user.setName("赵六");

Gson gson = new Gson();
String json = gson.toJson(user);
System.out.println(json); // 输出：{"id":2,"name":"赵六"}
</code></pre>
<h4 id="高级功能-1"><strong>高级功能</strong></h4>
<ul>
<li><strong>忽略字段</strong>：<code>@Expose</code><pre><code class="language-java">@Expose
private String name;
</code></pre>
</li>
<li><strong>自定义序列化器/反序列化器</strong>：<pre><code class="language-java">Gson gson = new GsonBuilder()
        .registerTypeAdapter(CustomClass.class, new CustomSerializer())
        .create();
</code></pre>
</li>
</ul>
<h4 id="优缺点-1"><strong>优缺点</strong></h4>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>轻量级，简单易用，适合中小型项目</td>
<td>性能稍逊于 Jackson</td>
</tr>
<tr>
<td>学习曲线平滑，新手容易上手</td>
<td>功能不如 Jackson 丰富</td>
</tr>
<tr>
<td>提供良好的扩展能力</td>
<td>复杂对象处理起来较为麻烦</td>
</tr>
</tbody>
</table>
<h2 id="3-使用-fastjson高性能">3. 使用 FastJSON：高性能</h2>
<h4 id="功能特点-2"><strong>功能特点</strong></h4>
<ul>
<li><strong>性能优异</strong>：FastJSON 的解析速度非常快，适合大数据量场景。</li>
<li><strong>支持动态字段</strong>：可以轻松处理动态 JSON 数据。</li>
<li><strong>强大的类型支持</strong>：支持嵌套对象、泛型、数组等复杂结构。</li>
<li><strong>注解控制</strong>：类似 Jackson 和 Gson，支持注解控制字段的序列化和反序列化。</li>
</ul>
<h4 id="代码示例-2"><strong>代码示例</strong></h4>
<p><strong>1. JSON 转对象</strong></p>
<pre><code class="language-java">import com.alibaba.fastjson.JSON;

public class FastJsonExample {
    public static void main(String[] args) {
        String json = "{\"id\":1,\"name\":\"小明\"}";

        User user = JSON.parseObject(json, User.class);
        System.out.println(user.getName()); // 输出：小明
    }
}
</code></pre>
<p><strong>2. 对象转 JSON</strong></p>
<pre><code class="language-java">User user = new User();
user.setId(3);
user.setName("小红");

String json = JSON.toJSONString(user);
System.out.println(json); // 输出：{"id":3,"name":"小红"}
</code></pre>
<h4 id="高级功能-2"><strong>高级功能</strong></h4>
<ul>
<li><strong>自动驼峰转下划线</strong>：<pre><code class="language-java">JSON.DEFFAULT_DATE_FORMAT = "yyyy-MM-dd HH:mm:ss";
</code></pre>
</li>
<li><strong>动态字段解析</strong>：<pre><code class="language-java">Map&lt;String, Object&gt; map = JSON.parseObject(json, Map.class);
</code></pre>
</li>
</ul>
<h4 id="优缺点-2"><strong>优缺点</strong></h4>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>性能极高，解析速度快</td>
<td>曾有历史安全漏洞的争议</td>
</tr>
<tr>
<td>支持复杂的动态字段解析</td>
<td>社区活跃度稍逊于 Jackson 和 Gson</td>
</tr>
<tr>
<td>功能全面，适合大规模数据处理场景</td>
<td>配置选项和 API 比较多，稍显复杂</td>
</tr>
</tbody>
</table>
<h2 id="4-使用-jsonpath快速提取嵌套字段">4. 使用 JsonPath：快速提取嵌套字段</h2>
<h4 id="功能特点-3"><strong>功能特点</strong></h4>
<ul>
<li><strong>高效字段提取</strong>：通过路径表达式（类似 XPath）快速提取嵌套字段。</li>
<li><strong>灵活性强</strong>：支持动态字段和条件过滤。</li>
<li><strong>轻量级</strong>：专注于字段提取，功能简单明确。</li>
</ul>
<h4 id="代码示例-3"><strong>代码示例</strong></h4>
<pre><code class="language-java">import com.jayway.jsonpath.JsonPath;

public class JsonPathExample {
    public static void main(String[] args) {
        String json = """
            {
                "store": {
                    "book": [
                        {"title": "书1", "price": 10},
                        {"title": "书2", "price": 20}
                    ]
                }
            }
        """;

        // 提取第一个书籍的标题
        String title = JsonPath.read(json, "$.store.book[0].title");
        System.out.println(title); // 输出：书1

        // 提取所有书籍价格
        List&lt;Integer&gt; prices = JsonPath.read(json, "$.store.book[*].price");
        System.out.println(prices); // 输出：[10, 20]
    }
}
</code></pre>
<h4 id="优缺点-3"><strong>优缺点</strong></h4>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>字段提取简洁高效</td>
<td>不支持序列化和反序列化</td>
</tr>
<tr>
<td>动态字段处理能力强</td>
<td>依赖 JsonPath 语法</td>
</tr>
<tr>
<td>适合快速提取嵌套字段</td>
<td>不适合全量 JSON 转换</td>
</tr>
</tbody>
</table>
<h2 id="5-使用-orgjson轻量工具类">5. 使用 org.json：轻量工具类</h2>
<h4 id="功能特点-4"><strong>功能特点</strong></h4>
<ul>
<li><strong>轻量级</strong>：核心是一个工具类，适合简单场景。</li>
<li><strong>构造和解析简单</strong>：适合快速创建 JSON 或提取字段。</li>
<li><strong>灵活性一般</strong>：不支持复杂对象映射。</li>
</ul>
<h4 id="代码示例-4"><strong>代码示例</strong></h4>
<pre><code class="language-java">import org.json.JSONObject;

public class OrgJsonExample {
    public static void main(String[] args) {
        String json = "{\"id\":1,\"name\":\"张三\"}";

        // 提取字段
        JSONObject jsonObject = new JSONObject(json);
        System.out.println(jsonObject.getString("name")); // 输出：张三

        // 构造 JSON
        JSONObject newJson = new JSONObject();
        newJson.put("id", 2);
        newJson.put("name", "李四");
        System.out.println(newJson.toString()); // 输出：{"id":2,"name":"李四"}
    }
}
</code></pre>
<h4 id="优缺点-4"><strong>优缺点</strong></h4>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>轻量级，适合简单场景</td>
<td>不支持复杂嵌套对象</td>
</tr>
<tr>
<td>使用简单，学习成本低</td>
<td>功能简单，扩展性差</td>
</tr>
</tbody>
</table>
<h2 id="6-手动解析-json灵活度最高">6. 手动解析 JSON：灵活度最高</h2>
<h4 id="功能特点-5"><strong>功能特点</strong></h4>
<ul>
<li><strong>完全自由</strong>：不依赖第三方库，自己解析 JSON。</li>
<li><strong>动态处理</strong>：适合不规则字段结构的 JSON。</li>
<li><strong>代码复杂度高</strong>：适合特殊场景。</li>
</ul>
<h4 id="代码示例-5"><strong>代码示例</strong></h4>
<pre><code class="language-java">import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.Map;

public class ManualParsing {
    public static void main(String[] args) throws Exception {
        String json = "{\"id\":1,\"name\":\"动态字段\"}";

        ObjectMapper objectMapper = new ObjectMapper();
        Map&lt;String, Object&gt; map = objectMapper.readValue(json, new TypeReference&lt;Map&lt;String, Object&gt;&gt;() {});
        System.out.println(map.get("name")); // 输出：动态字段
    }
}
</code></pre>
<h4 id="优缺点-5"><strong>优缺点</strong></h4>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>灵活性高，适合动态字段</td>
<td>代码复杂度高，不易维护</td>
</tr>
<tr>
<td>不依赖第三方库</td>
<td>性能和效率低于专业 JSON 库</td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2>
<p>最后给大家对比一下文章中提到的6种方法各自的优缺点：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>适用场景</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Jackson</strong></td>
<td>企业级项目，复杂序列化和反序列化场景</td>
<td>功能强大，性能优异，支持复杂结构</td>
<td>配置复杂，学习曲线高</td>
</tr>
<tr>
<td><strong>Gson</strong></td>
<td>中小型项目，简单的 JSON 转换场景</td>
<td>轻量级，简单易用</td>
<td>功能有限，性能略逊</td>
</tr>
<tr>
<td><strong>FastJSON</strong></td>
<td>高性能需求，大数据量的动态解析</td>
<td>性能极高，功能丰富</td>
<td>曾有安全漏洞争议，社区支持稍逊 Jackson</td>
</tr>
<tr>
<td><strong>JsonPath</strong></td>
<td>嵌套结构复杂、动态字段提取场景</td>
<td>字段提取语法简单，灵活性强</td>
<td>不支持序列化和反序列化</td>
</tr>
<tr>
<td><strong>org.json</strong></td>
<td>快速解析或构造 JSON 场景</td>
<td>轻量级，适合简单场景</td>
<td>功能单一，扩展性差</td>
</tr>
<tr>
<td><strong>手动解析</strong></td>
<td>动态 JSON 或字段不固定的场景</td>
<td>自由度高，灵活性强</td>
<td>代码复杂，效率低于专业工具</td>
</tr>
</tbody>
</table>
<p>工具千千万，场景最重要！</p>
<p>选对了工具，才能省时省力，少踩坑多摸鱼。</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6568662154328704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-02 10:34">2025-01-02 10:34</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">372</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18646998" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18646998);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18646998', targetLink: 'https://www.cnblogs.com/12lisu/p/18646998', title: 'JSON解析的这6种方案，真香！' })">举报</a>
</div>
        