
        <h2>
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/milton/p/18795659" title="发布于 2025-03-27 16:54">
    <span role="heading" aria-level="2">MySQL 的 JSON 查询</span>
    

</a>

        </h2>
        <div class="postbody">
                <div id="cnblogs_post_description" style="display: none">
        
        MySQL 使用特定的 JSON 路径表达式语法来导航和提取 JSON 文档中的数据, 使用过 JSON_EXTRACT 函数都知道, 这样获取的结果不是真正的行列结构, MySQL 8.0 引入的 JSON_TABLE 函数可以将 JSON 数据转换为关系型表格格式, 将数组中的每个元素转换成表格中的一行数据.
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="mysql-的-json-路径格式">MySQL 的 JSON 路径格式</h1>
<p>MySQL 使用特定的 JSON 路径表达式语法来导航和提取 JSON 文档中的数据</p>
<h2 id="基本结构">基本结构</h2>
<p>MySQL 中的 JSON 路径遵循以下通用格式</p>
<pre><code>$[路径组件]
</code></pre>
<h2 id="路径组件详解">路径组件详解</h2>
<pre><code>| 操作符       | 描述      | 示例                  |
| ----------- | --------- | --------------------- |
| $           \| 根对象     \| $                    |
| . 或 []     | 成员访问   | $.name 或 $['name']   |
| [*]         | 数组通配符 | $.items[*]            |
| [n]         | 数组索引   | $[0]                 |
| [m to n]    | 数组范围   | $[1 to 3]            |
| **          | 递归通配符 | $**.price             |
</code></pre>
<h3 id="1-根对象-">1. 根对象 (<code>$</code>)</h3>
<ul>
<li><code>$</code> 表示整个 JSON 文档</li>
</ul>
<h3 id="2-成员访问--或-">2. 成员访问 (<code>.</code> 或 <code>[]</code>)</h3>
<ul>
<li>点号表示法：<code>$.store.book</code></li>
<li>括号表示法：<code>$['store']['book']</code></li>
<li>当键名包含特殊字符或空格时使用括号表示法</li>
</ul>
<h3 id="3-数组访问">3. 数组访问</h3>
<ul>
<li>所有元素：<code>$[*]</code> 或 <code>$.array[*]</code></li>
<li>指定索引：<code>$[0]</code> 计数是从0开始</li>
<li>范围：<code>$[1 to 3]</code>（MySQL 8.0.26+）</li>
</ul>
<h3 id="4-通配符">4. 通配符</h3>
<ul>
<li><code>*</code> 匹配当前层级所有成员/元素</li>
<li><code>**</code> 递归搜索所有路径（MySQL 8.0.26+）</li>
</ul>
<h2 id="特殊语法元素">特殊语法元素</h2>
<h3 id="1-过滤表达式-mysql-804">1. 过滤表达式 (MySQL 8.0.4+)</h3>
<pre><code class="language-sql">$.items[?(@.price &gt; 10)]
</code></pre>
<ul>
<li><code>?</code> 引入过滤表达式</li>
<li><code>@</code> 表示当前元素</li>
</ul>
<h3 id="2-路径范围-mysql-8026">2. 路径范围 (MySQL 8.0.26+)</h3>
<pre><code class="language-sql">$[1 to 3]       // 第1到第3个元素
$[last-1]       // 倒数第二个元素
$[last-2 to last] // 最后三个元素
</code></pre>
<h2 id="实际示例">实际示例</h2>
<h3 id="简单路径">简单路径</h3>
<pre><code class="language-sql">-- 提取标量值
SELECT JSON_EXTRACT('{"name": "张三", "age": 30}', '$.name');

-- 数组元素, 输出 "b", 注意是带双引号的
SELECT JSON_EXTRACT('["a", "b", "c"]', '$[1]');
</code></pre>
<h3 id="复杂路径">复杂路径</h3>
<pre><code class="language-sql">-- 嵌套对象
SELECT JSON_EXTRACT('{"store": {"book": {"title": "MySQL指南"}}}', '$.store.book.title');

-- 对象数组
SELECT JSON_EXTRACT('{"items": [{"id": 1}, {"id": 2}]}', '$.items[*].id');
</code></pre>
<h3 id="过滤表达式">过滤表达式</h3>
<pre><code class="language-sql">-- 查找高价商品
SELECT JSON_EXTRACT('{"items": [{"id": 1, "price": 5}, {"id": 2, "price": 15}]}', 
       '$..items[?(@.price &gt; 10)].id');
</code></pre>
<h2 id="简写操作符">简写操作符</h2>
<p>MySQL 提供常用操作的简写形式</p>
<ul>
<li><code>-&gt;</code> : 等同于 <code>JSON_EXTRACT()</code></li>
<li><code>-&gt;&gt;</code> : 等同于 <code>JSON_UNQUOTE(JSON_EXTRACT())</code></li>
</ul>
<pre><code class="language-sql">-- 以下两种写法等价：
SELECT json_column-&gt;'$.name';
SELECT JSON_EXTRACT(json_column, '$.name');

-- 以下两种写法等价（返回去除引号的字符串）：
SELECT json_column-&gt;&gt;'$.name';
SELECT JSON_UNQUOTE(JSON_EXTRACT(json_column, '$.name'));
</code></pre>
<h2 id="注意">注意</h2>
<ol>
<li>路径表达式区分大小写</li>
<li>不存在的路径返回 NULL（不会报错）</li>
<li><code>**</code> 递归操作符可能影响性能</li>
<li>过滤表达式支持比较运算符：<code>=</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code> 等</li>
</ol>
<h1 id="mysql-的-json_table-函数">MySQL 的 JSON_TABLE 函数</h1>
<p>使用过 JSON_EXTRACT 函数都知道, 这样获取的结果还不是真正的行列结构, MySQL 8.0 引入的 JSON_TABLE 函数可以将 JSON 数据转换为关系型表格格式, 将数组中的每个元素转换成表格中的一行数据.</p>
<p>JSON_TABLE 的功能</p>
<ol>
<li>将 JSON 数组展开为多行记录</li>
<li>提取嵌套的 JSON 对象属性</li>
<li>将半结构化数据转为结构化数据</li>
</ol>
<h2 id="json_table-用法">JSON_TABLE 用法</h2>
<pre><code class="language-sql">JSON_TABLE(
    json_doc,       -- JSON 类型的字段或值
    path_expression -- JSON 路径表达式
    COLUMNS(        -- 新表的列定义
        column_name column_type PATH json_path [on_empty] [on_error],
        ...
    )
) [AS] alias
</code></pre>
<p>参数说明</p>
<ol>
<li><strong>json_doc</strong>：可以是 JSON 字符串字面量, 或者表中的 JSON 类型列</li>
<li><strong>path_expression</strong>：指向要展开的 JSON 数组的路径</li>
<li><strong>COLUMNS</strong>：定义输出列的结构
<ul>
<li><code>column_name</code>：生成的列名</li>
<li><code>column_type</code>：数据类型（如 VARCHAR, INT, JSON 等）</li>
<li><code>PATH</code>：指定数据提取路径</li>
</ul>
</li>
<li><strong>alias</strong>：必须提供的表别名</li>
</ol>
<h2 id="实际案例">实际案例</h2>
<h3 id="将整数数组展开为一列多行">将整数数组展开为一列多行</h3>
<pre><code class="language-sql">SELECT *
FROM JSON_TABLE(
    '[1, 2, 3]',
    '$[*]' COLUMNS(
        rowid FOR ORDINALITY,
        value INT PATH '$'
    )
) AS t;
</code></pre>
<p>输出</p>
<pre><code>rowid | value
------+-------
1     | 1
2     | 2
3     | 3
</code></pre>
<h3 id="将对象数组展开为多列多行">将对象数组展开为多列多行</h3>
<pre><code class="language-sql">SELECT *
FROM JSON_TABLE(
    '[{"name":"张三","age":25},{"name":"李四","age":30}]',
    '$[*]' COLUMNS(
        name VARCHAR(20) PATH '$.name',
        age INT PATH '$.age',
        adult VARCHAR(3) PATH '$.age' DEFAULT '否' ON EMPTY
    )
) AS t;
</code></pre>
<p>输出</p>
<pre><code>name | age | adult
-----+-----+------
张三 | 25  | 否
李四 | 30  | 否
</code></pre>
<h3 id="在数据表中展开">在数据表中展开</h3>
<p>如果JSON是表中的一个字段, 可以使用 <code>table_1 CROSS JOIN JSON_TABLE(...)</code> 展开, 例如一个表 v_video 的字段 result 为 JSON 字段, 需要展开 result 中的一个成员 sequences, 写成SQL如下</p>
<pre><code class="language-sql">SELECT 
    e.id,
    e.match_id,
    e.result-&gt;&gt;'$.id' AS json_id,
    j.tag-&gt;&gt;'$.sf' AS sf_value,
    j.tag-&gt;&gt;'$.ef' AS ef_value,
    j.tag-&gt;&gt;'$.ef' - j.tag-&gt;&gt;'$.sf'AS duration
FROM 
    v_video e
        CROSS JOIN JSON_TABLE(
            e.result-&gt;'$.sequences',
            '$[*]' COLUMNS (
                tag JSON PATH '$'
            )
        ) AS j ON e.match_id = 294
</code></pre>
<p>上面的SQL, 通过 CROSS JOIN JSON_TABLE 将每一行 e.result 字段下的 sequences 数组展开, 每个数组元素成为新字段 tag, 这时候还是一个 JSON, 然后在SELECT 中通过<code>-&gt;&gt;</code>抽取其中的值, 得到完全展开的一个新表.</p>
<h2 id="高级用法">高级用法</h2>
<h3 id="for-ordinality-子句">FOR ORDINALITY 子句</h3>
<p>生成自增的行号列</p>
<pre><code class="language-sql">COLUMNS(
    id FOR ORDINALITY,
    ...
)
</code></pre>
<h3 id="嵌套路径处理">嵌套路径处理</h3>
<pre><code class="language-sql">COLUMNS(
    NESTED PATH '$.nested_obj' COLUMNS(
        sub_col1 INT PATH '$.prop1',
        sub_col2 VARCHAR(10) PATH '$.prop2'
    )
)
</code></pre>
<p>上面的例子用嵌套可以改写为</p>
<pre><code class="language-sql">SELECT 
    j.id,
    j.sf,
    j.ef,
    j.ef - j.sf AS duration
FROM 
    v_video e
CROSS JOIN 
    JSON_TABLE(
        e.result-&gt;'$.sequences',
        '$[*]' COLUMNS (
            id FOR ORDINALITY,
            NESTED PATH '$' COLUMNS(
                ef INT PATH '$.ef',
                sf INT PATH '$.sf'
            )
        )
    ) AS j ON e.match_id = 294
</code></pre>
<p>上面的SQL, 通过 <code>NESTED PATH ... COLUMNS(...)</code> 将展开后数组中的一个JSON元素进一步展开为多个字段.</p>
<h3 id="错误处理">错误处理</h3>
<pre><code class="language-sql">COLUMNS(
    ef INT PATH '$.ef' NULL ON EMPTY NULL ON ERROR,
    sf INT PATH '$.sf' DEFAULT '0' ON EMPTY NULL ON ERROR
)
</code></pre>
<p>格式是</p>
<pre><code>on_empty:
    {NULL | DEFAULT json_string | ERROR} ON EMPTY

on_error:
    {NULL | DEFAULT json_string | ERROR} ON ERROR
</code></pre>
<h2 id="注意事项">注意事项</h2>
<ol>
<li>MySQL 版本要高于8.0</li>
<li>路径表达式必须指向 JSON 数组, 注意是<strong>数组</strong></li>
<li>必须为结果集指定别名</li>
<li>在 FROM 子句和 JOIN 子句中都可以使用</li>
<li>在性能上, 对大数据集使用 JSON_TABLE 可能较慢, 可以为 JSON 列创建函数索引提高查询性能</li>
</ol>

</div>
<div class="clear"></div>

        </div>
        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0.05780334093402778" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-27 16:54">2025-03-27 16:54</span>&nbsp;
<a href="https://www.cnblogs.com/milton">Milton</a>&nbsp;
阅读(<span id="post_view_count">55</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18795659" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18795659);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18795659', targetLink: 'https://www.cnblogs.com/milton/p/18795659', title: 'MySQL 的 JSON 查询' })">举报</a>

        </p>
    