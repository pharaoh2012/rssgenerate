
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Tangtang1997/p/18629960" title="发布于 2024-12-25 11:09">
    <span role="heading" aria-level="2">.NET 中的线程安全数据结构</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-concurrentqueue" rel="noopener nofollow">1. ConcurrentQueue<t></t></a></li><li><a href="#2-concurrentstack" rel="noopener nofollow">2. ConcurrentStack<t></t></a></li><li><a href="#3-concurrentbag" rel="noopener nofollow">3. ConcurrentBag<t></t></a></li><li><a href="#4-concurrentdictionarytkey-tvalue" rel="noopener nofollow">4. ConcurrentDictionary&lt;TKey, TValue&gt;</a></li><li><a href="#5-blockingcollection" rel="noopener nofollow">5. BlockingCollection<t></t></a></li><li><a href="#6-immutablelist" rel="noopener nofollow">6. ImmutableList<t></t></a></li><li><a href="#7-synchronizedcollection" rel="noopener nofollow">7. SynchronizedCollection<t></t></a></li><li><a href="#8-synchronizedreadonlycollection" rel="noopener nofollow">8. SynchronizedReadOnlyCollection<t></t></a></li><li><a href="#9-synchronizedkeyedcollectionk-t" rel="noopener nofollow">9. SynchronizedKeyedCollection&lt;K, T&gt;</a></li></ul></div><br>
在多线程编程中，线程安全的数据结构是确保数据一致性和避免竞争条件的关键。.NET 提供了多种线程安全的数据结构，适用于不同的场景，本篇将介绍它们的简单使用以及在 .NET Core 和 .NET Framework 中的可用性。<p></p>
<h2 id="1-concurrentqueue">1. ConcurrentQueue<t></t></h2>
<p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentqueue-1?view=net-9.0" target="_blank" rel="noopener nofollow">ConcurrentQueue<t></t></a> 是一个线程安全的先进先出 (FIFO) 队列。它允许多个线程同时进行入队和出队操作，而不会导致数据不一致。</p>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>生产者-消费者模式</strong>：多个生产者线程将数据项添加到队列中，多个消费者线程从队列中取出数据项进行处理</li>
<li><strong>任务调度</strong>：将任务添加到队列中，由工作线程从队列中取出任务并执行</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>高效的并发操作</strong>：支持多个线程同时进行入队和出队操作</li>
<li><strong>无锁设计</strong>：内部使用无锁算法，避免了锁竞争，提高了性能</li>
<li><strong>易于使用</strong>：提供简单的 API，如<code>Enqueue</code>和<code>TryDequeue</code></li>
</ul>
<p><strong>可用性</strong></p>
<ul>
<li>.NET Framework 4.0 及以上</li>
<li>.NET Core 1.0 及以上</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="language-csharp">using System.Collections.Concurrent;

var queue = new ConcurrentQueue&lt;int&gt;();
var cts = new CancellationTokenSource();
var token = cts.Token;

// 生产者任务
var producer = Task.Run(() =&gt;
{
    for (int i = 0; i &lt; 10; i++)
    {
        queue.Enqueue(i);
        Console.WriteLine($"Enqueued {i}");
        Thread.Sleep(100); // 模拟生产延迟
    }
}, token);

// 消费者任务
var consumer = Task.Run(() =&gt;
{
    while (!token.IsCancellationRequested)
    {
        if (queue.TryDequeue(out int result))
        {
            Console.WriteLine($"Dequeued {result}");
        }
        Thread.Sleep(50); // 模拟消费延迟
    }
}, token);

await Task.WhenAll(producer);
cts.Cancel(); // 停止消费者任务
await consumer;
</code></pre>
<h2 id="2-concurrentstack">2. ConcurrentStack<t></t></h2>
<p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentstack-1?view=net-9.0" target="_blank" rel="noopener nofollow">ConcurrentStack<t></t></a> 是一个线程安全的后进先出 (LIFO) 堆栈。它允许多个线程同时进行入栈和出栈操作。</p>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>深度优先搜索算法</strong>：在图或树结构中进行深度优先搜索时使用</li>
<li><strong>撤销操作</strong>：实现撤销功能时，将操作记录入栈，撤销时从栈中弹出操作</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>高效的并发操作</strong>：支持多个线程同时进行入栈和出栈操作</li>
<li><strong>无锁设计</strong>：内部使用无锁算法，避免了锁竞争，提高了性能</li>
<li><strong>易于使用</strong>：提供简单的 API，如<code>Push</code>和<code>TryPop</code></li>
</ul>
<p><strong>可用性</strong></p>
<ul>
<li>.NET Framework 4.0 及以上</li>
<li>.NET Core 1.0 及以上</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="language-csharp">using System.Collections.Concurrent;

var stack = new ConcurrentStack&lt;int&gt;();
var cts = new CancellationTokenSource();
var token = cts.Token;

// 生产者任务
var producer = Task.Run(() =&gt;
{
    for (int i = 0; i &lt; 10; i++)
    {
        stack.Push(i);
        Console.WriteLine($"Pushed {i}");
        Thread.Sleep(100); // 模拟生产延迟
    }
}, token);

// 消费者任务
var consumer = Task.Run(() =&gt;
{
    while (!token.IsCancellationRequested)
    {
        if (stack.TryPop(out int result))
        {
            Console.WriteLine($"Popped {result}");
        }
        Thread.Sleep(50); // 模拟消费延迟
    }
}, token);

await Task.WhenAll(producer);
cts.Cancel(); // 停止消费者任务
await consumer;
</code></pre>
<h2 id="3-concurrentbag">3. ConcurrentBag<t></t></h2>
<p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentbag-1?view=net-9.0" target="_blank" rel="noopener nofollow">ConcurrentBag<t></t></a> 是一个线程安全的无序集合，适用于频繁添加和删除元素的场景。</p>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>任务池</strong>：将任务添加到集合中，工作线程从集合中取出任务并执行</li>
<li><strong>缓存</strong>：将临时数据存储在集合中，多个线程可以并发地添加和删除数据</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>高效的并发操作</strong>：支持多个线程同时进行添加和删除操作</li>
<li><strong>无锁设计</strong>：内部使用无锁算法，避免了锁竞争，提高了性能</li>
<li><strong>适用于无序数据</strong>：不关心元素顺序的场景非常适用</li>
</ul>
<p><strong>可用性</strong></p>
<ul>
<li>.NET Framework 4.0 及以上</li>
<li>.NET Core 1.0 及以上</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="language-csharp">using System.Collections.Concurrent;

var bag = new ConcurrentBag&lt;int&gt;();
var cts = new CancellationTokenSource();
var token = cts.Token;

// 生产者任务
var producer = Task.Run(() =&gt;
{
    for (int i = 0; i &lt; 10; i++)
    {
        bag.Add(i);
        Console.WriteLine($"Added {i}");
        Thread.Sleep(100); // 模拟生产延迟
    }
}, token);

// 消费者任务
var consumer = Task.Run(() =&gt;
{
    while (!token.IsCancellationRequested)
    {
        if (bag.TryTake(out int result))
        {
            Console.WriteLine($"Took {result}");
        }
        Thread.Sleep(50); // 模拟消费延迟
    }
}, token);

await Task.WhenAll(producer);
cts.Cancel(); // 停止消费者任务
await consumer;
</code></pre>
<h2 id="4-concurrentdictionarytkey-tvalue">4. ConcurrentDictionary&lt;TKey, TValue&gt;</h2>
<p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentdictionary-2?view=net-9.0" target="_blank" rel="noopener nofollow">ConcurrentDictionary&lt;TKey, TValue&gt;</a> 是一个线程安全的键值对集合，类似于 Dictionary&lt;TKey, TValue&gt;。</p>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>缓存</strong>：存储键值对数据，多个线程可以并发地读取和写入缓存</li>
<li><strong>计数器</strong>：存储计数器数据，多个线程可以并发地更新计数器值</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>高效的并发操作</strong>：支持多个线程同时进行读取和写入操作</li>
<li><strong>原子操作</strong>：支持原子操作，如<code>AddOrUpdate</code>和<code>GetOrAdd</code>，确保数据一致性</li>
<li><strong>灵活性</strong>：提供丰富的 API，支持多种操作</li>
</ul>
<p><strong>可用性</strong></p>
<ul>
<li>.NET Framework 4.0 及以上</li>
<li>.NET Core 1.0 及以上</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="language-csharp">using System.Collections.Concurrent;

var dictionary = new ConcurrentDictionary&lt;int, string&gt;();

// 添加元素
var addTask = Task.Run(() =&gt;
{
    for (int i = 0; i &lt; 10; i++)
    {
        dictionary.TryAdd(i, $"value{i}");
        Console.WriteLine($"Added key {i} with value value{i}");
    }
});

// 更新元素
var updateTask = Task.Run(() =&gt;
{ 
    for (int i = 0; i &lt; 10; i++)
    {
        var ii = i;
        dictionary.AddOrUpdate(i, $"new_value{i}", (key, oldValue) =&gt; $"new_value{ii}");
        Console.WriteLine($"Updated key {i} with value new_value{i}");
    } 
});

// 读取元素
var readTask = Task.Run(() =&gt;
{
    foreach (var key in dictionary.Keys)
    {
        if (dictionary.TryGetValue(key, out string? value))
        {
            Console.WriteLine($"Key {key} has value {value}");
        }
    }
});

await Task.WhenAll(addTask, updateTask, readTask);
</code></pre>
<h2 id="5-blockingcollection">5. BlockingCollection<t></t></h2>
<p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.blockingcollection-1?view=net-9.0" target="_blank" rel="noopener nofollow">BlockingCollection<t></t></a> 提供线程安全的添加和移除操作，并支持阻塞和限界功能。可以与<code>ConcurrentQueue&lt;T&gt;</code>, <code>ConcurrentStack&lt;T&gt;</code>, <code>ConcurrentBag&lt;T&gt;</code>等一起使用。</p>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>生产者-消费者模式</strong>：多个生产者线程将数据项添加到集合中，多个消费者线程从集合中取出数据项进行处理</li>
<li><strong>任务调度</strong>：将任务添加到集合中，由工作线程从集合中取出任务并执行</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>阻塞操作</strong>：支持阻塞添加和移除操作，适用于生产者-消费者模式</li>
<li><strong>限界功能</strong>：支持设置集合的最大容量，防止过度填充</li>
<li><strong>灵活性</strong>：可以与多种集合类型一起使用，如<code>ConcurrentQueue&lt;T&gt;</code></li>
</ul>
<p><strong>可用性</strong></p>
<ul>
<li>.NET Framework 4.0 及以上</li>
<li>.NET Core 1.0 及以上</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="language-csharp">using System.Collections.Concurrent;

var collection = new BlockingCollection&lt;int&gt;(boundedCapacity: 5);
var cts = new CancellationTokenSource();
var token = cts.Token;

// 生产者任务
var producer = Task.Run(() =&gt;
{
    for (int i = 0; i &lt; 10; i++)
    {
        collection.Add(i);
        Console.WriteLine($"Added {i}");
        Thread.Sleep(100); // 模拟生产延迟
    }
    collection.CompleteAdding();
}, token);

// 消费者任务
var consumer = Task.Run(() =&gt;
{
    foreach (var item in collection.GetConsumingEnumerable(token))
    {
        Console.WriteLine($"Consumed {item}");
        Thread.Sleep(50); // 模拟消费延迟
    }
}, token);

await Task.WhenAll(producer, consumer);
</code></pre>
<h2 id="6-immutablelist">6. ImmutableList<t></t></h2>
<p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.immutable.immutablelist-1?view=net-9.0" target="_blank" rel="noopener nofollow">ImmutableList<t></t></a> 是线程安全的，因为所有修改操作都会返回一个新的集合实例。</p>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>配置数据</strong>：存储配置数据，多个线程可以并发地读取配置数据，而无需担心数据被修改</li>
<li><strong>快照</strong>：在某个时间点获取数据的快照，多个线程可以并发地读取快照数据</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>天然线程安全</strong>：由于集合不可变，多个线程可以安全地并发读取</li>
<li><strong>数据一致性</strong>：所有修改操作都会返回一个新的集合实例，保证数据一致性</li>
<li><strong>易于使用</strong>：提供丰富的 API，支持多种操作</li>
</ul>
<p><strong>可用性</strong></p>
<ul>
<li>.NET Framework 4.5 及以上（需要安装 <code>System.Collections.Immutable</code> NuGet 包）</li>
<li>.NET Core 1.0 及以上（需要安装 <code>System.Collections.Immutable</code> NuGet 包）</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="language-csharp">var list = ImmutableList.Create(1, 2, 3);
var newList = list.Add(4);

Console.WriteLine(string.Join(", ", newList)); // 输出 1, 2, 3, 4
</code></pre>
<h2 id="7-synchronizedcollection">7. SynchronizedCollection<t></t></h2>
<p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.synchronizedcollection-1?view=net-8.0-pp&amp;viewFallbackFrom=net-9.0" target="_blank" rel="noopener nofollow">SynchronizedCollection<t></t></a> 是一个线程安全的集合，适用于需要同步访问的场景。</p>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>共享资源管理</strong>：管理共享资源的集合，多个线程可以并发地访问和修改集合</li>
<li><strong>事件订阅</strong>：存储事件订阅者，多个线程可以并发地添加和移除订阅者</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>内置同步机制</strong>：自动处理同步，确保线程安全</li>
<li><strong>易于使用</strong>：提供简单的 API，如<code>Add</code>和<code>Remove</code></li>
<li><strong>灵活性</strong>：支持多种集合操作</li>
</ul>
<p><strong>可用性</strong></p>
<ul>
<li>.NET Framework 3.5 及以上</li>
<li>.NET Core 1.0 及以上</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="language-csharp">var collection = new SynchronizedCollection&lt;int&gt;();
collection.Add(1);
collection.Add(2);

foreach (var item in collection)
{
    Console.WriteLine(item); // 输出 1 和 2
}
</code></pre>
<h2 id="8-synchronizedreadonlycollection">8. SynchronizedReadOnlyCollection<t></t></h2>
<p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.synchronizedreadonlycollection-1?view=netframework-4.8.1&amp;viewFallbackFrom=net-9.0" target="_blank" rel="noopener nofollow">SynchronizedReadOnlyCollection<t></t></a> 是一个线程安全的只<br>
读集合。</p>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>配置数据</strong>：存储只读的配置数据，多个线程可以并发地读取配置数据</li>
<li><strong>共享数据</strong>：存储共享数据，多个线程可以并发地读取数据，而无需担心数据被修改</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>内置同步机制</strong>：自动处理同步，确保线程安全</li>
<li><strong>易于使用</strong>：提供简单的 API，如<code>Contains</code>和<code>CopyTo</code></li>
<li><strong>数据保护</strong>：只读特性确保数据不会被修改</li>
</ul>
<p><strong>可用性</strong></p>
<ul>
<li>.NET Framework 3.0 及以上</li>
<li>.NET Core 1.0 及以上</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="language-csharp">var list = new List&lt;int&gt; { 1, 2, 3 };
var readOnlyCollection = new SynchronizedReadOnlyCollection&lt;int&gt;(list);

foreach (var item in readOnlyCollection)
{
    Console.WriteLine(item); // 输出 1, 2, 3
}
</code></pre>
<h2 id="9-synchronizedkeyedcollectionk-t">9. SynchronizedKeyedCollection&lt;K, T&gt;</h2>
<p><a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.synchronizedkeyedcollection-2?view=netframework-4.8.1&amp;viewFallbackFrom=net-9.0" target="_blank" rel="noopener nofollow">SynchronizedKeyedCollection&lt;K, T&gt;</a> 是一个线程安全的键控集合。</p>
<p><strong>使用场景</strong></p>
<ul>
<li><strong>缓存</strong>：存储键控数据，多个线程可以并发地读取和写入缓存</li>
<li><strong>资源管理</strong>：管理键控资源的集合，多个线程可以并发地访问和修改集合</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>内置同步机制</strong>：自动处理同步，确保线程安全</li>
<li><strong>键控访问</strong>：支持通过键快速访问元素</li>
<li><strong>灵活性</strong>：支持多种集合操作</li>
</ul>
<p><strong>可用性</strong></p>
<ul>
<li>.NET Framework 3.0 及以上</li>
<li>.NET Core 1.0 及以上</li>
</ul>
<p><strong>示例代码</strong></p>
<pre><code class="language-csharp">public class MyItem
{
    public int Id { get; set; }
    public string Name { get; set; }
}

var collection = new SynchronizedKeyedCollection&lt;int, MyItem&gt;(item =&gt; item.Id);
collection.Add(new MyItem { Id = 1, Name = "Item1" });
collection.Add(new MyItem { Id = 2, Name = "Item2" });

foreach (var item in collection)
{
    Console.WriteLine(item.Name); // 输出 Item1 和 Item2
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.031033610375" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-25 11:33">2024-12-25 11:09</span>&nbsp;
<a href="https://www.cnblogs.com/Tangtang1997">贾光辉</a>&nbsp;
阅读(<span id="post_view_count">77</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18629960" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18629960);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18629960', targetLink: 'https://www.cnblogs.com/Tangtang1997/p/18629960', title: '.NET 中的线程安全数据结构' })">举报</a>
</div>
        