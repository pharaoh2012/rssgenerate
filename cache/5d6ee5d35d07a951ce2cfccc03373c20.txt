
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18726387" title="发布于 2025-02-20 17:02">
    <span role="heading" aria-level="2">割以咏志：Stoer–Wagner 算法求解全局最小割</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>全局最小割问题（Global Min-Cut Problem）是图论中的一个经典问题，旨在通过切割图中的边来划分图的顶点集合。具体来说，给定一个加权无向图 $ G = (V, E) $，图中每条边 $ e \in E $ 有一个权重 $ w(e) $，全局最小割问题的目标是找到一个划分 $ (S, T) $ 使得从集合 $ S $ 到集合 $ T $ 的边的总权重最小。也就是说，我们希望将图的顶点集合 $ V $ 分割成两个子集 $ S $ 和 $ T $，使得割集 $ \text{cut}(S) $ 的总权重最小，其中割集定义为从 $ S $ 到 $ T $ 的所有边的集合。</p>
<p>形式上，最小割问题的目标是求解以下优化问题：</p>
<p></p><div class="math display">\[\min_{S \subseteq V} \sum_{u \in S, v \in V \setminus S} w(u, v)
\]</div><p></p><p>即要找到权重总和最小的一组边集，将无向图划分成两部分。</p>
<p>我们已经了解最大流最小割定理：在网络流图中，最大流等于最小割。这里的最小割和全局最小割的区别在于，最大流—最小割定理主要应用于流网络，其中有明确的源点（Source）和汇点（Sink）。在这种情况下，最小割是指将图划分成两部分，使得源点与汇点之间的流量最小，换句话说，它是指从源点到汇点的最小割集。而在全局最小割问题中，并不要求指定源点和汇点，而是要求找到任何两部分之间的最小割，不管这些部分是否包含特定的源汇结构。因此，全局最小割问题更加普适，适用于任何无向图，并且与特定的源点和汇点无关。</p>
<p><strong>暴力求解</strong></p>
<p>暴力方法的思路是，将无向边改为双向的有向边，首先在图中选取任意一个节点作为源点，然后枚举图中所有其他节点作为汇点。对于每一对源点和汇点，使用最大流算法来计算源点到汇点之间的最大流值，然后通过最大流—最小割定理来得到最小割的值。这个方法的缺点在于每次都需要执行最大流算法，非常低效。</p>
<h2 id="stoerwagner-算法">Stoer–Wagner 算法</h2>
<p>Stoer–Wagner 算法利用无向图和最小割的性质，使用最大邻接序和递归来求解全局最小割。这个算法基于这样的前提：图中任取两点 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span>，它们要么位于我们要找的全局最小割的一边，要么位于两边</p>
<p>这里，我们并不枚举 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> ，因为我们不知道最终的最小割是如何划分的，但根据图的结构，我们能够确定  <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 一定是全局最小割中的两个端点之一，然后根据上面的两种情况分治。</p>
<h3 id="最大邻接排序求解-s-t-最小割">最大邻接排序求解 s-t 最小割</h3>
<p>我们需要处理两种情况之一：要么 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 位于最小割的同一边，要么它们位于割的两边。对于后一种情况，也就是 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 位于两边的情况，我们使用一个称为 <strong>Maximum Adjacency Ordering</strong> 的方法来处理。</p>
<p><strong>Maximum Adjacency Ordering</strong> 也被称为“最大邻接排序”，它的基本思路是：</p>
<ul>
<li>从任意一个顶点出发，将其加入“已选节点”。</li>
<li>每轮选择非“已选节点”里，连接到“已选节点”的边权之和最大的节点。</li>
<li>通过这种方式，我们可以得到一个顶点的排列顺序。这个顺序确保了在每次选择时，我们总是优先选择连接当前已选择顶点的边权重最大的顶点。</li>
</ul>
<p>具体而言，假设我们从任意的起点开始，然后按照“最大邻接边”的顺序遍历图，最终得到一个顶点的排序序列。最后的两个顶点（排序序列中的最后两个节点）就成为了图的 <strong>s-t割</strong> 中的两个端点。</p>
<p>也可以视为，我们从初始节点视作“大节点”，每次选择“大节点”邻边里权重最大者并入（将其边权附加过来），直到剩下两个点，最后一条边的边权就是最后两个点构成的 <strong>s-t割</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202502/1545207-20250220150042459-1822958073.png" alt="image" loading="lazy"></p>
<p>可以用归纳法证明此贪心策略的正确。每一次合并都不改变图的最小割值，最终剩下的两个点之间的边就是这两点间的一个割，最大邻接排序可以得到正确的结果。</p>
<hr>
<h3 id="单次时间复杂度">单次时间复杂度</h3>
<p>这种贪心——取最大的策略和 prim 或 dijkstra 相同，其复杂度为<span class="math inline">\(O(V^2)\)</span>（暴力遍历节点）、<span class="math inline">\(O((V+E) \log V)\)</span>（二叉堆）或 <span class="math inline">\(O(E+V \log V)\)</span>（斐波那契堆）</p>
<h3 id="合并两个顶点并递归">合并两个顶点并递归</h3>
<p>对于 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 位于同一侧的情况，我们就可以<strong>将这两个顶点合并</strong>为一个新顶点（将其邻边合并，连接到同一点的边权被相加），并进入下一轮的算法。</p>
<p><strong>为什么合并是对的？</strong></p>
<p>在 Stoer-Wagner 算法中，每次迭代时通过合并顶点来简化问题。这是因为，在最大邻接排序中，顶点 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 已经被识别为割的两端点，接下来考虑的是 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 在同一侧的情况。合并这两个顶点不会改变这种情况下最小割的性质。换句话说，合并顶点相当于“压缩”图的结构，但不会影响最小割的最终结果。因为合并后，新的顶点将保留  <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 之间的所有连接信息，且这些连接信息在下一轮计算时依然能帮助我们找到最小割。</p>
<p>合并操作具体来说，就是将  <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span>  合并成一个新的虚拟顶点，并将与这两个顶点相连的所有边重新连接到新的虚拟顶点上。在合并后，剩下的图的规模会减少，新的图中就只剩下 <span class="math inline">\(V-1\)</span> 个顶点。</p>
<p>然后，算法进入下一轮，继续寻找下一个可能的最小割，直到剩下两个顶点为止。</p>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202502/1545207-20250220151041634-757883480.png" alt="image" loading="lazy"></p>
<pre><code class="language-cpp">// Stoer-Wagner 暴力版
// 参考题目：https://www.luogu.com.cn/problem/P5632

class Graph {
    vector&lt;vector&lt;int&gt;&gt; adj; // 邻接矩阵
    int n;
public:
    Graph(int n) : n(n), adj(n, vector&lt;int&gt;(n, 0)) {}

    void addEdge(int u, int v, int w) {
        adj[u][v] = adj[v][u] = w;
    }
    
    int stoerWagner() {
        int res = INT_MAX;
        for (int i = 0; i &lt; n - 1; ++i) {
            vector&lt;int&gt; ma(n, 0);
            ma[0] = INT_MAX;  // 选择总是从 0 开始

            int s = -1, t = -1;
            for (int j = 0; j &lt; n - i - 1; ++j) {
                int a = max_element(ma.begin(), ma.end()) - ma.begin();
                
                if (ma[a] == 0) return 0; // Graph is disconnected
                ma[a] = -1;
                
                if (j == n - i - 2) s = a;  // The second last node is s
                for (int k = 0; k &lt; n; ++k) {
                    if (ma[k] &gt;= 0) ma[k] += adj[a][k];
                }
            }
            t = max_element(ma.begin(), ma.end()) - ma.begin();
            
            res = min(res, ma[t]);

            // Merge nodes s and t
            for (int k = 0; k &lt; n; ++k) {
                if (k != s &amp;&amp; k != t) {
                    adj[s][k] += adj[t][k];
                    adj[k][s] = adj[s][k];
                    adj[t][k] = adj[k][t] = 0;
                }
            }
        } return res;
    }
};
</code></pre>
<h3 id="总复杂度">总复杂度</h3>
<p>Stoer-Wagner 算法的时间复杂度由以下几部分组成：</p>
<p>算法会执行 <span class="math inline">\(V-1\)</span> 轮迭代，因为每次迭代都会减少一个顶点，直到最终剩下两个顶点。</p>
<p>与单次时间复杂度相乘，整个算法的时间复杂度近似为 <span class="math inline">\(O(V^3)\)</span>。</p>
<hr>
<p>Stoer-Wagner 算法通过贪心策略和顶点合并大大降低了时间复杂度，用于解决无源点和汇点的无向图最小割，比暴力方法每次运行最大流算法要高效得多。当然算法是专门为最小割问题设计的，它可能不如最大流算法那样在其他流网络问题中具备广泛的适用性。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5478944032060186" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-20 17:05">2025-02-20 17:02</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">62</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18726387" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18726387);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18726387', targetLink: 'https://www.cnblogs.com/ofnoname/p/18726387', title: '割以咏志：Stoer–Wagner 算法求解全局最小割' })">举报</a>
</div>
        