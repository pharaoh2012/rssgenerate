
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tohearts/p/18821456" title="发布于 2025-04-11 22:07">
    <span role="heading" aria-level="2">【跟K8S学设计】Informer全分析-Reflector（上）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com"><p data-tool="mdnice编辑器">鉴于Informer架构及其处理逻辑蕴含了丰富的实战技术，本文将分为上下两章进行深入探讨。</p>
<p data-tool="mdnice编辑器">上篇将专注于解析Informer中的Reflector组件，而下篇则会详尽分析Indexer模块。通过这种结构化的呈现方式，提供一个全面且系统的学习路径。</p>
<h1 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">问题发现</span><span class="suffix"></span></h1>
<p data-tool="mdnice编辑器">在前一章节中，我们探讨了使用RestClient访问Kubernetes（K8S）集群资源的方法，并详细解析了其源码实现流程。值得注意的是，尽管RestClient构成了client-go与K8S交互的基础，但在实际应用中，更常见的是采用以下几种高级客户端来简化操作：</p>
<ol data-tool="mdnice编辑器">
<li><section><strong>ClientSet</strong>：<strong>基于RestClient构建，提供了对所有内置K8S资源类型的封装接口。</strong>通过ClientSet，开发者能够以更为便捷的方式直接调用这些资源而无需记忆具体的API路径、资源名称或版本信息。然而，这种便利性是以牺牲灵活性为代价的——ClientSet不支持自定义资源定义（CRD）对象的操作。</section></li><li><section><strong>DynamicClient</strong>：作为一款动态客户端工具，它允许用户针对任何Kubernetes资源执行查询操作，其中包括自定义资源定义（CRDs）。<strong>这一特性使得DynamicClient成为处理非标准或新引入资源的理想选择。</strong></section></li><li><section><strong>DiscoveryClient</strong>：主要用于<strong>发现并获取由Kubernetes API服务器提供的资源列表信息</strong>。此外，在<code>kubectl</code>命令行工具中，DiscoveryClient还会将这些信息缓存至本地目录<code>~/.kube/cache/discovery/</code>下，从而加快后续请求的速度。</section></li></ol>
<p data-tool="mdnice编辑器">以上所述的各种客户端组件各自具备独特优势，根据具体需求灵活选用可显著提升开发效率及系统管理能力。</p>
<p data-tool="mdnice编辑器">在这一过程中，<code>clientSet</code>的<code>informer</code>无疑扮演了极其重要的角色。那么，为什么需要引入<code>informer</code>？它又是如何被开发出来的呢？记住这一点至关重要：任何技术的诞生都是为了解决特定问题。为了回答这两个问题，反证法来看下面这一个问题：</p>
<p data-tool="mdnice编辑器"><strong>如果所有组件及外部程序都直接通过</strong><code>clientSet</code><strong>或</strong><code>RestClient</code><strong>来访问Kubernetes集群资源，将会遇到哪些挑战？</strong></p>
<ul data-tool="mdnice编辑器">
<li><section><strong>并发性问题</strong>：当基础设施的存储资源被视为业务逻辑的一部分时，所有请求无限制地涌向API服务器会导致其负载显著增加（尽管API服务器具备一定的限流机制）。然而，一旦触发了限流阈值，将可能导致服务不可用，从而对业务造成负面影响。</section></li><li><section><strong>缓存缺失问题</strong>：从<code>restClient</code>的实现来看，它缺乏有效的缓存策略，这意味着每次数据查询都需要经过API服务器，这不仅增加了网络延迟，也加重了API服务器的工作负担。</section></li><li><section><strong>数据时效性问题</strong>：对于API服务器上发生的任何更新，<code>restClient</code>是无法即时感知到的，因此必须定期轮询API服务器以获取最新信息。随着系统规模的增长，这种做法会进一步加剧API服务器的并发压力。虽然可以使用<code>clientSet</code>提供的<code>watch</code>功能来监听变化，但这又引出了新的挑战。</section></li><li><section><strong>版本一致性问题</strong>：采用<code>clientSet</code>进行监听操作时，若因网络不稳定等因素导致监听中断，则需手动执行全量同步(<code>Resync</code>)以确保本地缓存与远程状态的一致性。</section></li><li><section><strong>错误处理机制不足</strong>：无论是<code>restClient</code>还是<code>clientSet</code>，它们都将错误恢复的责任交给了应用层，这意味着开发者需要自行设计和实现相应的容错逻辑。</section></li><li><section><strong>在业务处理过程中，Kubernetes（k8s）依赖于事件驱动机制来管理资源状态的变化</strong>。因此，应用程序需要自行解析不同类型的事件（如添加、更新或删除），并据此维护相应的状态机，这无疑增加了代码实现的复杂度。</section></li><li><section><strong>安全方面：</strong>访问Kubernetes集群主要依靠证书和Token进行身份验证与授权，但这一过程容易遇到配置不当或证书/Token过期的问题。</section></li></ul>
<p data-tool="mdnice编辑器">综上所述，<code>informer</code>作为<code>clientSet</code>的一部分，正是为了解决上述提到的各种问题而被引入的，它提供了一种更加高效且可靠的机制来管理Kubernetes对象的状态。<br>
针对上述挑战，Informer提供了一种有效的解决方案：</p>
<ol data-tool="mdnice编辑器">
<li><section><strong>List/Watch机制</strong>：通过高效地监听Kubernetes集群内部发生的各类事件，Informer能够及时捕获资源状态变化。</section></li><li><section><strong>事件处理简化</strong>：Informer引入了<code>EventHandler</code>接口，允许开发者将自定义的回调函数封装起来以响应特定事件，从而让开发者可以更加专注于业务逻辑的实现而非底层事件处理细节。</section></li><li><section><strong>本地缓存支持</strong>：对于所有接收到的信息，Informer会在完成事件处理后将其存储至本地缓存中，并且提供了灵活多样的查询接口供应用层调用。</section></li><li><section><strong>共享连接优化</strong>：利用共享的Informer实例，多个组件可以共同使用同一个Watch连接来监听相同的资源类型，比如当有十个不同的服务都需要监听Pod事件时，使用SharedInformer只需要建立一个Watch连接即可满足需求，相比之下直接使用ClientSet则需为每个服务单独创建一个独立的Watch连接。</section></li><li><section><strong>定期同步</strong>：Informer还支持周期性地重新同步数据，确保本地缓存与实际集群状态保持一致。<br>
综上所述，这些特性共同构成了Kubernetes生态系统中极为重要的Informer功能，极大地提升了开发效率及系统的稳定性。</section></li></ol>
<p data-tool="mdnice编辑器">接下来，我们将利用<code>goanalysis</code>结合测试代码对<code>informer</code>中的<code>controller</code>和<code>Reflector</code>进行深入分析。<code>goanalysis</code>能够在执行结束前提供所有已执行函数的堆栈信息及其参数快照，这有助于克服使用<code>dlv</code>调试时频繁需要重启程序的问题。</p>
<p data-tool="mdnice编辑器">本示例基于<code>client-go</code>版本<code>v0.30.1</code>。</p>
<p data-tool="mdnice编辑器">请注意，这里假设您已经熟悉Go语言环境以及Kubernetes相关组件的工作原理。</p>
<p data-tool="mdnice编辑器">通过这种方式，我们旨在更高效地理解及调试<code>informer</code>机制内部复杂的交互过程。</p>
<h1 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">初步体验</span><span class="suffix"></span></h1>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-keyword">import</span>&nbsp;(<br>&nbsp;<span class="hljs-string">"log"</span><br>&nbsp;<span class="hljs-string">"time"</span><br><br>&nbsp;<span class="hljs-string">"github.com/toheart/functrace"</span><br>&nbsp;v1&nbsp;<span class="hljs-string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span><br>&nbsp;<span class="hljs-string">"k8s.io/client-go/informers"</span><br>&nbsp;<span class="hljs-string">"k8s.io/client-go/kubernetes"</span><br>&nbsp;<span class="hljs-string">"k8s.io/client-go/tools/cache"</span><br>&nbsp;<span class="hljs-string">"k8s.io/client-go/tools/clientcmd"</span><br>&nbsp;<span class="hljs-string">"k8s.io/klog/v2"</span><br>)<br><br>func&nbsp;main()&nbsp;{<br>&nbsp;defer&nbsp;func()&nbsp;{<br>&nbsp;&nbsp;functrace.CloseTraceInstance()&nbsp;<span class="hljs-comment">#&nbsp;透视代码函数结束,&nbsp;不用在意</span><br>&nbsp;}()<br>&nbsp;config,&nbsp;err&nbsp;:=&nbsp;clientcmd.BuildConfigFromFlags(<span class="hljs-string">""</span>,&nbsp;<span class="hljs-string">"/root/.kube/config"</span>)<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;!=&nbsp;nil&nbsp;{<br>&nbsp;&nbsp;panic(err)<br>&nbsp;}<br>&nbsp;config.Timeout&nbsp;=&nbsp;time.Second&nbsp;*&nbsp;<span class="hljs-number">5</span><br>&nbsp;clientset,&nbsp;err&nbsp;:=&nbsp;kubernetes.NewForConfig(config)<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;!=&nbsp;nil&nbsp;{<br>&nbsp;&nbsp;panic(err)<br>&nbsp;}<br>&nbsp;stopCh&nbsp;:=&nbsp;make(chan&nbsp;struct{})<br>&nbsp;defer&nbsp;close(stopCh)<br>&nbsp;log.Printf(<span class="hljs-string">"create&nbsp;new&nbsp;inforemer&nbsp;\n"</span>)<br>&nbsp;sharedInformers&nbsp;:=&nbsp;informers.NewSharedInformerFactory(clientset,&nbsp;time.Minute)<br><br>&nbsp;informer&nbsp;:=&nbsp;sharedInformers.Core().V1().Pods().Informer()<br><br>&nbsp;informer.AddEventHandler(cache.ResourceEventHandlerFuncs{<br>&nbsp;&nbsp;AddFunc:&nbsp;func(obj&nbsp;interface{})&nbsp;{<br>&nbsp;&nbsp;&nbsp;mObj&nbsp;:=&nbsp;obj.(v1.Object)<br>&nbsp;&nbsp;&nbsp;log.Printf(<span class="hljs-string">"New&nbsp;Pod&nbsp;Added&nbsp;to&nbsp;Store:&nbsp;%s"</span>,&nbsp;mObj.GetName())<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;UpdateFunc:&nbsp;func(oldObj,&nbsp;newObj&nbsp;interface{})&nbsp;{<br>&nbsp;&nbsp;&nbsp;oObj&nbsp;:=&nbsp;oldObj.(v1.Object)<br>&nbsp;&nbsp;&nbsp;nObj&nbsp;:=&nbsp;newObj.(v1.Object)<br><br>&nbsp;&nbsp;&nbsp;log.Printf(<span class="hljs-string">"%s&nbsp;Pod&nbsp;Update&nbsp;to&nbsp;%s"</span>,&nbsp;oObj.GetName(),&nbsp;nObj.GetName())<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;DeleteFunc:&nbsp;func(obj&nbsp;interface{})&nbsp;{<br>&nbsp;&nbsp;&nbsp;mObj&nbsp;:=&nbsp;obj.(v1.Object)<br>&nbsp;&nbsp;&nbsp;log.Printf(<span class="hljs-string">"Pod&nbsp;Deleted&nbsp;from&nbsp;Store:%s"</span>,&nbsp;mObj.GetName())<br>&nbsp;&nbsp;},<br>&nbsp;})<br>&nbsp;sharedInformers.Start(stopCh)<br><br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;!cache.WaitForCacheSync(stopCh,&nbsp;informer.HasSynced)&nbsp;{<br>&nbsp;&nbsp;klog.Fatal(<span class="hljs-string">"failed&nbsp;to&nbsp;synced"</span>)<br>&nbsp;}<br>&nbsp;select&nbsp;{}<br>}<br><br></code></pre>
<p data-tool="mdnice编辑器">从上述描述中可以看出，Informer功能的实现流程相对直接，主要包含以下几个关键步骤：</p>
<ol data-tool="mdnice编辑器">
<li><section>获取认证凭据；</section></li><li><section>构建<code>clientset</code>实例；</section></li><li><section>利用<code>clientset</code>来初始化<code>SharedInformerFactory</code>对象；</section></li><li><section>为需要监听的具体资源创建对应的Informer；</section></li><li><section>定义针对不同资源事件的处理逻辑；</section></li><li><section>启动<code>sharedInformers</code>以开始监听和处理资源变动。</section></li></ol>
<p data-tool="mdnice编辑器">这样的结构化方法确保了Kubernetes集群内资源变更能够被高效地捕获与响应。</p>
<h1 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">透视源码</span><span class="suffix"></span></h1>
<h2 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">初始化ClientSet</span><span class="suffix"></span></h2>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs">clientset,&nbsp;err&nbsp;:=&nbsp;kubernetes.NewForConfig(config)<br><span class="hljs-keyword">if</span>&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">panic</span>(err)<br>}<br></code></pre>
<p data-tool="mdnice编辑器">在前文所述中，我们提到<code>clientSet</code>会创建一系列内置资源对象，并将其存储于结构体之中。通过可视化界面，可以进一步观察到其中的细节。</p>
<figure data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634170-236537243.png" alt=""></figure>
<p data-tool="mdnice编辑器">抽出一个函数看：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs">cs.admissionregistrationV1,&nbsp;err&nbsp;=&nbsp;admissionregistrationv1.NewForConfigAndClient(&amp;configShallowCopy,&nbsp;httpClient)<br><span class="hljs-keyword">if</span>&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">nil</span>,&nbsp;err<br>}<br></code></pre>
<p data-tool="mdnice编辑器">其中，<code>httpClient</code> 是 <code>RestClient</code> 对象内部封装的 HTTP 客户端实例。</p>
<h2 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">初始化ShardInformer</span><span class="suffix"></span></h2>
<figure data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634157-1415733808.png" alt=""></figure>
<p data-tool="mdnice编辑器">最终在执行过程中调用的是<code>NewSharedInformerFactoryWithOptions</code>函数。该函数的实现相对简洁：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-title">NewSharedInformerFactoryWithOptions</span><span class="hljs-params">(client&nbsp;kubernetes.Interface,&nbsp;defaultResync&nbsp;time.Duration,&nbsp;options&nbsp;...SharedInformerOption)</span>&nbsp;<span class="hljs-title">SharedInformerFactory</span></span>&nbsp;{<br>&nbsp;factory&nbsp;:=&nbsp;&amp;sharedInformerFactory{<br>&nbsp;&nbsp;client:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;clientset客户端</span><br>&nbsp;&nbsp;namespace:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1.NamespaceAll,&nbsp;<span class="hljs-comment">//&nbsp;使用""</span><br>&nbsp;&nbsp;defaultResync:&nbsp;&nbsp;&nbsp;&nbsp;defaultResync,&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;默认重新同步时间</span><br>&nbsp;&nbsp;informers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[reflect.Type]cache.SharedIndexInformer),&nbsp;<span class="hljs-comment">//&nbsp;Informer</span><br>&nbsp;&nbsp;startedInformers:&nbsp;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[reflect.Type]<span class="hljs-keyword">bool</span>),&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;informer是否已经启动</span><br>&nbsp;&nbsp;customResync:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[reflect.Type]time.Duration),&nbsp;<span class="hljs-comment">//&nbsp;informer自定义同步时间</span><br>&nbsp;}<br><br>&nbsp;<span class="hljs-comment">//&nbsp;Apply&nbsp;all&nbsp;options</span><br>&nbsp;<span class="hljs-keyword">for</span>&nbsp;_,&nbsp;opt&nbsp;:=&nbsp;<span class="hljs-keyword">range</span>&nbsp;options&nbsp;{<br>&nbsp;&nbsp;factory&nbsp;=&nbsp;opt(factory)<br>&nbsp;}<br><br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;factory<br>}<br></code></pre>
<p data-tool="mdnice编辑器">根据上述内容，可以得出以下结论：</p>
<ol data-tool="mdnice编辑器">
<li><section>对于每个资源对象，<code>shardInformer</code>仅维护一个对应的<code>Informer</code>实例；</section></li><li><section>关于同步时间的设定，若在<code>customResync</code>中已定义，则优先采用该值；反之，在未指定的情况下，则使用默认的<code>defaultResync</code>配置。</section></li></ol>
<h2 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">创建podInformer</span><span class="suffix"></span></h2>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs">informer&nbsp;:=&nbsp;sharedInformers.Core().V1().Pods().Informer()<br></code></pre>
<p data-tool="mdnice编辑器">调用链如下：<br>
<img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634167-372288395.png" alt=""></p>
<p data-tool="mdnice编辑器">核心代码如下:</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(f&nbsp;*podInformer)</span>&nbsp;<span class="hljs-title">Informer</span><span class="hljs-params">()</span>&nbsp;<span class="hljs-title">cache</span>.<span class="hljs-title">SharedIndexInformer</span></span>&nbsp;{<br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;f.factory.InformerFor(&amp;corev1.Pod{},&nbsp;f.defaultInformer)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(f&nbsp;*sharedInformerFactory)</span>&nbsp;<span class="hljs-title">InformerFor</span><span class="hljs-params">(obj&nbsp;runtime.Object,&nbsp;newFunc&nbsp;internalinterfaces.NewInformerFunc)</span>&nbsp;<span class="hljs-title">cache</span>.<span class="hljs-title">SharedIndexInformer</span></span>&nbsp;{<br>&nbsp;f.lock.Lock()<br>&nbsp;<span class="hljs-keyword">defer</span>&nbsp;f.lock.Unlock()<br>&nbsp;<span class="hljs-comment">//&nbsp;如果&nbsp;&amp;corev1.Pod{}&nbsp;存在,&nbsp;则直接返回informer</span><br>&nbsp;informerType&nbsp;:=&nbsp;reflect.TypeOf(obj)<br>&nbsp;informer,&nbsp;exists&nbsp;:=&nbsp;f.informers[informerType]<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;exists&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;informer<br>&nbsp;}<br>&nbsp;resyncPeriod,&nbsp;exists&nbsp;:=&nbsp;f.customResync[informerType]<br>&nbsp;<span class="hljs-comment">//&nbsp;如果&nbsp;resync&nbsp;不存在,&nbsp;则使用默认的Resync</span><br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;!exists&nbsp;{<br>&nbsp;&nbsp;resyncPeriod&nbsp;=&nbsp;f.defaultResync<br>&nbsp;}<br>&nbsp;<span class="hljs-comment">//&nbsp;创建新的informer,&nbsp;将保存到map中。</span><br>&nbsp;informer&nbsp;=&nbsp;newFunc(f.client,&nbsp;resyncPeriod)<br>&nbsp;informer.SetTransform(f.transform)&nbsp;<span class="hljs-comment">//&nbsp;这里从goanalysis中可以看出其当前为Nil.</span><br>&nbsp;f.informers[informerType]&nbsp;=&nbsp;informer<br><br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;informer<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(s&nbsp;*sharedIndexInformer)</span>&nbsp;<span class="hljs-title">SetTransform</span><span class="hljs-params">(handler&nbsp;TransformFunc)</span>&nbsp;<span class="hljs-title">error</span></span>&nbsp;{<br>&nbsp;s.startedLock.Lock()<br>&nbsp;<span class="hljs-keyword">defer</span>&nbsp;s.startedLock.Unlock()<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;s.started&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;fmt.Errorf(<span class="hljs-string">"informer&nbsp;has&nbsp;already&nbsp;started"</span>)<br>&nbsp;<br>&nbsp;s.transform&nbsp;=&nbsp;handler<br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">nil</span><br>}<br></code></pre>
<p data-tool="mdnice编辑器">在上述过程中，用于创建Informer的函数是<code>newFunc</code>，该函数被赋值为<code>f.defaultInformer</code>。具体来说，Informer的创建流程如下：</p>
<ol data-tool="mdnice编辑器">
<li><section>定义或获取<code>newFunc</code>。</section></li><li><section>将<code>f.defaultInformer</code>赋值给<code>newFunc</code>。</section></li><li><section>通过调用<code>newFunc</code>来初始化并创建Informer实例。</section></li></ol>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(f&nbsp;*podInformer)</span>&nbsp;<span class="hljs-title">defaultInformer</span><span class="hljs-params">(client&nbsp;kubernetes.Interface,&nbsp;resyncPeriod&nbsp;time.Duration)</span>&nbsp;<span class="hljs-title">cache</span>.<span class="hljs-title">SharedIndexInformer</span></span>&nbsp;{<br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;NewFilteredPodInformer(client,&nbsp;f.namespace,&nbsp;resyncPeriod,&nbsp;cache.Indexers{cache.NamespaceIndex:&nbsp;cache.MetaNamespaceIndexFunc},&nbsp;f.tweakListOptions)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-title">NewFilteredPodInformer</span><span class="hljs-params">(client&nbsp;kubernetes.Interface,&nbsp;namespace&nbsp;<span class="hljs-keyword">string</span>,&nbsp;resyncPeriod&nbsp;time.Duration,&nbsp;indexers&nbsp;cache.Indexers,&nbsp;tweakListOptions&nbsp;internalinterfaces.TweakListOptionsFunc)</span>&nbsp;<span class="hljs-title">cache</span>.<span class="hljs-title">SharedIndexInformer</span></span>&nbsp;{<br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;cache.NewSharedIndexInformer(<br>&nbsp;&nbsp;&amp;cache.ListWatch{<br>&nbsp;&nbsp;&nbsp;ListFunc:&nbsp;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options&nbsp;metav1.ListOptions)</span>&nbsp;<span class="hljs-params">(runtime.Object,&nbsp;error)</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;tweakListOptions&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tweakListOptions(&amp;options)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;client.CoreV1().Pods(namespace).List(context.TODO(),&nbsp;options)<br>&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;WatchFunc:&nbsp;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options&nbsp;metav1.ListOptions)</span>&nbsp;<span class="hljs-params">(watch.Interface,&nbsp;error)</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;tweakListOptions&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tweakListOptions(&amp;options)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;client.CoreV1().Pods(namespace).Watch(context.TODO(),&nbsp;options)<br>&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;&amp;corev1.Pod{},<br>&nbsp;&nbsp;resyncPeriod,<br>&nbsp;&nbsp;indexers,<br>&nbsp;)<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-title">NewSharedIndexInformerWithOptions</span><span class="hljs-params">(lw&nbsp;ListerWatcher,&nbsp;exampleObject&nbsp;runtime.Object,&nbsp;options&nbsp;SharedIndexInformerOptions)</span>&nbsp;<span class="hljs-title">SharedIndexInformer</span></span>&nbsp;{<br>&nbsp;realClock&nbsp;:=&nbsp;&amp;clock.RealClock{}<br><br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;&amp;sharedIndexInformer{<br>&nbsp;&nbsp;indexer:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NewIndexer(DeletionHandlingMetaNamespaceKeyFunc,&nbsp;options.Indexers),<br>&nbsp;&nbsp;processor:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;sharedProcessor{clock:&nbsp;realClock},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;NewFilteredPodInformer&nbsp;cache.ListWatch</span><br>&nbsp;&nbsp;listerWatcher:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lw,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;v1.Pod&nbsp;结构体</span><br>&nbsp;&nbsp;objectType:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exampleObject,&nbsp;<br>&nbsp;&nbsp;objectDescription:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options.ObjectDescription,&nbsp;<span class="hljs-comment">//""</span><br>&nbsp;&nbsp;resyncCheckPeriod:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options.ResyncPeriod,&nbsp;<span class="hljs-comment">//&nbsp;60000000000</span><br>&nbsp;&nbsp;defaultEventHandlerResyncPeriod:&nbsp;options.ResyncPeriod,&nbsp;<span class="hljs-comment">//&nbsp;60000000000</span><br>&nbsp;&nbsp;clock:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;realClock,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;"*v1.Pod"</span><br>&nbsp;&nbsp;cacheMutationDetector:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NewCacheMutationDetector(fmt.Sprintf(<span class="hljs-string">"%T"</span>,&nbsp;exampleObject)),&nbsp;&nbsp;&nbsp;<br>&nbsp;}<br>}<br></code></pre>
<p data-tool="mdnice编辑器">最终通过调用<code>NewSharedIndexInformerWithOptions</code>函数来创建共享索引通知器。该过程的核心要素包括：</p>
<ol data-tool="mdnice编辑器">
<li><section><strong>List/Watch机制</strong>：此机制底层基于特定函数的初始化，旨在同步对象状态并监听这些对象的变化，从而确保数据源的实时性和准确性。</section></li><li><section><strong>Indexer对象初始化</strong>：这一步骤建立了本地缓存系统，允许用户在查询时直接访问本地存储的信息而非向API服务器发起请求，从而提高响应速度和效率。</section></li><li><section><strong>SharedProcessor对象初始化</strong>：此组件负责将从Watch接口接收到的对象变更事件转发给相应的Informer进行进一步处理，保证了信息流的有效传递与处理。</section></li></ol>
<p data-tool="mdnice编辑器">以上三个组成部分共同构成了<code>SharedIndexInformer</code>的核心架构，为其高效运作提供了坚实的基础。</p>
<h2 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">添加EventHandler</span><span class="suffix"></span></h2>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(s&nbsp;*sharedIndexInformer)</span>&nbsp;<span class="hljs-title">AddEventHandlerWithResyncPeriod</span><span class="hljs-params">(handler&nbsp;ResourceEventHandler,&nbsp;resyncPeriod&nbsp;time.Duration)</span>&nbsp;<span class="hljs-params">(ResourceEventHandlerRegistration,&nbsp;error)</span></span>&nbsp;{<br>&nbsp;s.startedLock.Lock()<br>&nbsp;<span class="hljs-keyword">defer</span>&nbsp;s.startedLock.Unlock()<br>&nbsp;<span class="hljs-comment">//&nbsp;如果informer已经stop</span><br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;s.stopped&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">nil</span>,&nbsp;fmt.Errorf(<span class="hljs-string">"handler&nbsp;%v&nbsp;was&nbsp;not&nbsp;added&nbsp;to&nbsp;shared&nbsp;informer&nbsp;because&nbsp;it&nbsp;has&nbsp;stopped&nbsp;already"</span>,&nbsp;handler)<br>&nbsp;}<br>&nbsp;.......<br>&nbsp;<span class="hljs-comment">//&nbsp;创建一个&nbsp;processorListener&nbsp;实例，用于处理事件通知。</span><br>&nbsp;<span class="hljs-comment">//&nbsp;该实例将使用给定的&nbsp;handler、resyncPeriod、</span><br>&nbsp;<span class="hljs-comment">//&nbsp;determineResyncPeriod(resyncPeriod,&nbsp;s.resyncCheckPeriod)&nbsp;计算的&nbsp;resyncPeriod、</span><br>&nbsp;<span class="hljs-comment">//&nbsp;s.clock.Now()&nbsp;获取当前时间、initialBufferSize&nbsp;初始缓冲区大小，</span><br>&nbsp;<span class="hljs-comment">//&nbsp;以及&nbsp;s.HasSynced&nbsp;方法来确定是否已同步。</span><br>&nbsp;listener&nbsp;:=&nbsp;newProcessListener(handler,&nbsp;resyncPeriod,&nbsp;determineResyncPeriod(resyncPeriod,&nbsp;s.resyncCheckPeriod),&nbsp;s.clock.Now(),&nbsp;initialBufferSize,&nbsp;s.HasSynced)<br>&nbsp;<span class="hljs-comment">//&nbsp;如果&nbsp;informer&nbsp;尚未启动，则将&nbsp;listener&nbsp;添加到&nbsp;processor&nbsp;中，并返回处理程序句柄。</span><br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;!s.started&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;s.processor.addListener(listener),&nbsp;<span class="hljs-literal">nil</span><br>&nbsp;}<br><br>&nbsp;<span class="hljs-comment">//&nbsp;为了安全地加入，我们需要</span><br>&nbsp;<span class="hljs-comment">//&nbsp;1.&nbsp;停止发送添加/更新/删除通知</span><br>&nbsp;<span class="hljs-comment">//&nbsp;2.&nbsp;对存储进行列表操作</span><br>&nbsp;<span class="hljs-comment">//&nbsp;3.&nbsp;向新的处理程序发送合成的“添加”事件</span><br>&nbsp;<span class="hljs-comment">//&nbsp;4.&nbsp;解锁</span><br>&nbsp;s.blockDeltas.Lock()<br>&nbsp;<span class="hljs-keyword">defer</span>&nbsp;s.blockDeltas.Unlock()<br>&nbsp;<br>&nbsp;handle&nbsp;:=&nbsp;s.processor.addListener(listener)<br>&nbsp;<span class="hljs-keyword">for</span>&nbsp;_,&nbsp;item&nbsp;:=&nbsp;<span class="hljs-keyword">range</span>&nbsp;s.indexer.List()&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;请注意，我们在持有锁的情况下排队这些通知</span><br>&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;并在返回句柄之前。这意味着没有机会让任何人调用句柄的&nbsp;HasSynced&nbsp;方法</span><br>&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;在一个会错误返回&nbsp;true&nbsp;的状态下（即，当</span><br>&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;共享通知者已同步但尚未观察到一个带有&nbsp;isInitialList&nbsp;为&nbsp;true&nbsp;的&nbsp;Add</span><br>&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;事件，或者当处理通知的线程以某种方式比这个</span><br>&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;添加它们的线程更快，计数器暂时为零）。</span><br>&nbsp;&nbsp;listener.add(addNotification{newObj:&nbsp;item,&nbsp;isInInitialList:&nbsp;<span class="hljs-literal">true</span>})<br>&nbsp;}<br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;handle,&nbsp;<span class="hljs-literal">nil</span><br>}<br></code></pre>
<p data-tool="mdnice编辑器">由此可见，shardInformer具备了动态管理监听器（listener）的能力，支持以线程安全的方式添加新的处理器。</p>
<h2 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">启动shardInformer</span><span class="suffix"></span></h2>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(f&nbsp;*sharedInformerFactory)</span>&nbsp;<span class="hljs-title">Start</span><span class="hljs-params">(stopCh&nbsp;&lt;-<span class="hljs-keyword">chan</span>&nbsp;<span class="hljs-keyword">struct</span>{})</span></span>&nbsp;{<br>&nbsp;f.lock.Lock()<br>&nbsp;<span class="hljs-keyword">defer</span>&nbsp;f.lock.Unlock()<br><br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;f.shuttingDown&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">return</span><br>&nbsp;}<br>&nbsp;<span class="hljs-keyword">for</span>&nbsp;informerType,&nbsp;informer&nbsp;:=&nbsp;<span class="hljs-keyword">range</span>&nbsp;f.informers&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;!f.startedInformers[informerType]&nbsp;{<br>&nbsp;&nbsp;&nbsp;f.wg.Add(<span class="hljs-number">1</span>)<br>&nbsp;&nbsp;&nbsp;informer&nbsp;:=&nbsp;informer<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">go</span>&nbsp;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">defer</span>&nbsp;f.wg.Done()<br>&nbsp;&nbsp;&nbsp;&nbsp;informer.Run(stopCh)<br>&nbsp;&nbsp;&nbsp;}()<br>&nbsp;&nbsp;&nbsp;f.startedInformers[informerType]&nbsp;=&nbsp;<span class="hljs-literal">true</span><br>&nbsp;&nbsp;}<br>&nbsp;}<br>}<br></code></pre>
<p data-tool="mdnice编辑器">步骤如下：</p>
<ol data-tool="mdnice编辑器">
<li><section>鉴于<code>sharedInformer</code>在系统中扮演了核心管理者的角色，因此在对其进行操作时需实施加锁机制。此举旨在确保在Go语言的不同goroutine（协程）间访问<code>sharedInformer</code>时的一致性和数据完整性。</section></li><li><section>容错处理：若检测到<code>sharedInformer</code>已经处于停止状态，则直接终止当前流程并返回，以避免执行无效操作。</section></li><li><section>对于尚未启动的Informer实例，通过创建新的goroutine来异步启动它们。</section></li></ol>
<p data-tool="mdnice编辑器">综上所述，<code>Start</code>方法通过上述措施进一步增强了对<code>sharedInformer</code>内部Informer集合<strong>动态管理和控制的能力。</strong></p>
<h2 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">核心逻辑-Run</span><span class="suffix"></span></h2>
<p data-tool="mdnice编辑器">从这里开始透视informer.Run具体做了什么，主逻辑如下：（内部标注当前所有的参数具体值）</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(s&nbsp;*sharedIndexInformer)</span>&nbsp;<span class="hljs-title">Run</span><span class="hljs-params">(stopCh&nbsp;&lt;-<span class="hljs-keyword">chan</span>&nbsp;<span class="hljs-keyword">struct</span>{})</span></span>&nbsp;{<br>&nbsp;<span class="hljs-keyword">defer</span>&nbsp;utilruntime.HandleCrash()<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;容错机制</span><br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;s.HasStarted()&nbsp;{<br>&nbsp;&nbsp;klog.Warningf(<span class="hljs-string">"The&nbsp;sharedIndexInformer&nbsp;has&nbsp;started,&nbsp;run&nbsp;more&nbsp;than&nbsp;once&nbsp;is&nbsp;not&nbsp;allowed"</span>)<br>&nbsp;&nbsp;<span class="hljs-keyword">return</span><br>&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;为了释放锁（美观？）</span><br>&nbsp;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&nbsp;{<br>&nbsp;&nbsp;s.startedLock.Lock()<br>&nbsp;&nbsp;<span class="hljs-keyword">defer</span>&nbsp;s.startedLock.Unlock()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;创建核心的Delta&nbsp;Queue,&nbsp;作为Informer内部的事件交流渠道</span><br>&nbsp;&nbsp;fifo&nbsp;:=&nbsp;NewDeltaFIFOWithOptions(DeltaFIFOOptions{<br>&nbsp;&nbsp;&nbsp;KnownObjects:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.indexer,&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;创建podInformer时创建的indexer</span><br>&nbsp;&nbsp;&nbsp;EmitDeltaTypeReplaced:&nbsp;<span class="hljs-literal">true</span>,<br>&nbsp;&nbsp;&nbsp;Transformer:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.transform,&nbsp;<span class="hljs-comment">//&nbsp;nil</span><br>&nbsp;&nbsp;})<br><br>&nbsp;&nbsp;cfg&nbsp;:=&nbsp;&amp;Config{<br>&nbsp;&nbsp;&nbsp;Queue:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fifo,&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;ListerWatcher:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.listerWatcher,&nbsp;<span class="hljs-comment">//&nbsp;&nbsp;创建podInformer时&nbsp;list&nbsp;watch&nbsp;函数</span><br>&nbsp;&nbsp;&nbsp;ObjectType:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.objectType,&nbsp;<span class="hljs-comment">//&nbsp;v1.Pod{}</span><br>&nbsp;&nbsp;&nbsp;ObjectDescription:&nbsp;s.objectDescription,&nbsp;<span class="hljs-comment">//&nbsp;""</span><br>&nbsp;&nbsp;&nbsp;FullResyncPeriod:&nbsp;&nbsp;s.resyncCheckPeriod,<br>&nbsp;&nbsp;&nbsp;RetryOnError:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-literal">false</span>,<br>&nbsp;&nbsp;&nbsp;ShouldResync:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.processor.shouldResync,&nbsp;<span class="hljs-comment">//&nbsp;函数</span><br>&nbsp;&nbsp;&nbsp;Process:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.HandleDeltas,&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;事件发生后核心处理函数</span><br>&nbsp;&nbsp;&nbsp;WatchErrorHandler:&nbsp;s.watchErrorHandler,&nbsp;<span class="hljs-comment">//&nbsp;错误处理函数</span><br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;s.controller&nbsp;=&nbsp;New(cfg)<br>&nbsp;&nbsp;s.controller.(*controller).clock&nbsp;=&nbsp;s.clock<br>&nbsp;&nbsp;s.started&nbsp;=&nbsp;<span class="hljs-literal">true</span><br>&nbsp;}()<br>&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;没啥用</span><br>&nbsp;wg.StartWithChannel(processorStopCh,&nbsp;s.cacheMutationDetector.Run)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;启动listen处理器</span><br>&nbsp;wg.StartWithChannel(processorStopCh,&nbsp;s.processor.run)<br><br>&nbsp;<span class="hljs-keyword">defer</span>&nbsp;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&nbsp;{<br>&nbsp;&nbsp;s.startedLock.Lock()<br>&nbsp;&nbsp;<span class="hljs-keyword">defer</span>&nbsp;s.startedLock.Unlock()<br>&nbsp;&nbsp;s.stopped&nbsp;=&nbsp;<span class="hljs-literal">true</span>&nbsp;<span class="hljs-comment">//&nbsp;Don't&nbsp;want&nbsp;any&nbsp;new&nbsp;listeners</span><br>&nbsp;}()<br>&nbsp;s.controller.Run(stopCh)<br>}<br></code></pre>
<p data-tool="mdnice编辑器">这里我们先分析主协程的Run函数：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(c&nbsp;*controller)</span>&nbsp;<span class="hljs-title">Run</span><span class="hljs-params">(stopCh&nbsp;&lt;-<span class="hljs-keyword">chan</span>&nbsp;<span class="hljs-keyword">struct</span>{})</span></span>&nbsp;{<br>&nbsp;<span class="hljs-keyword">defer</span>&nbsp;utilruntime.HandleCrash()<br>&nbsp;<span class="hljs-keyword">go</span>&nbsp;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&lt;-stopCh<br>&nbsp;&nbsp;c.config.Queue.Close()<br>&nbsp;}()<br>&nbsp;<span class="hljs-comment">//&nbsp;创建一个&nbsp;Reflector&nbsp;实例，用于从&nbsp;ListerWatcher&nbsp;拉取对象/通知，并将其推送到&nbsp;DeltaFIFO&nbsp;中。</span><br>&nbsp;r&nbsp;:=&nbsp;NewReflectorWithOptions(<br>&nbsp;&nbsp;c.config.ListerWatcher,&nbsp;<span class="hljs-comment">//&nbsp;创建podInformer时&nbsp;list&nbsp;watch&nbsp;函数</span><br>&nbsp;&nbsp;c.config.ObjectType,&nbsp;<span class="hljs-comment">//&nbsp;同controller内部</span><br>&nbsp;&nbsp;c.config.Queue,&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;Delta&nbsp;Queue</span><br>&nbsp;&nbsp;ReflectorOptions{<br>&nbsp;&nbsp;&nbsp;ResyncPeriod:&nbsp;&nbsp;&nbsp;&nbsp;c.config.FullResyncPeriod,<br>&nbsp;&nbsp;&nbsp;TypeDescription:&nbsp;c.config.ObjectDescription,<br>&nbsp;&nbsp;&nbsp;Clock:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.clock,<br>&nbsp;&nbsp;},<br>&nbsp;)<br>&nbsp;r.ShouldResync&nbsp;=&nbsp;c.config.ShouldResync<br>&nbsp;r.WatchListPageSize&nbsp;=&nbsp;c.config.WatchListPageSize<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;c.config.WatchErrorHandler&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;r.watchErrorHandler&nbsp;=&nbsp;c.config.WatchErrorHandler<br>&nbsp;}<br><br>&nbsp;c.reflectorMutex.Lock()<br>&nbsp;c.reflector&nbsp;=&nbsp;r<br>&nbsp;c.reflectorMutex.Unlock()<br><br>&nbsp;<span class="hljs-keyword">var</span>&nbsp;wg&nbsp;wait.Group<br><br>&nbsp;wg.StartWithChannel(stopCh,&nbsp;r.Run)<br><br>&nbsp;wait.Until(c.processLoop,&nbsp;time.Second,&nbsp;stopCh)<br>&nbsp;wg.Wait()<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-title">NewReflectorWithOptions</span><span class="hljs-params">(lw&nbsp;ListerWatcher,&nbsp;expectedType&nbsp;<span class="hljs-keyword">interface</span>{},&nbsp;store&nbsp;Store,&nbsp;options&nbsp;ReflectorOptions)</span>&nbsp;*<span class="hljs-title">Reflector</span></span>&nbsp;{<br>&nbsp;reflectorClock&nbsp;:=&nbsp;options.Clock<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;reflectorClock&nbsp;==&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;reflectorClock&nbsp;=&nbsp;clock.RealClock{}<br>&nbsp;}<br>&nbsp;r&nbsp;:=&nbsp;&amp;Reflector{<br>&nbsp;&nbsp;name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;options.Name,&nbsp;<span class="hljs-comment">//&nbsp;""</span><br>&nbsp;&nbsp;resyncPeriod:&nbsp;&nbsp;&nbsp;&nbsp;options.ResyncPeriod,&nbsp;<span class="hljs-comment">//&nbsp;60000000000</span><br>&nbsp;&nbsp;typeDescription:&nbsp;options.TypeDescription,&nbsp;<span class="hljs-comment">//&nbsp;""</span><br>&nbsp;&nbsp;listerWatcher:&nbsp;&nbsp;&nbsp;lw,&nbsp;<span class="hljs-comment">//controller&nbsp;listerWater&nbsp;--&gt;&nbsp;pod&nbsp;list/watch</span><br>&nbsp;&nbsp;store:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;store,&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;Delta&nbsp;Queue</span><br>&nbsp;&nbsp;backoffManager:&nbsp;&nbsp;&nbsp;&nbsp;wait.NewExponentialBackoffManager(<span class="hljs-number">800</span>*time.Millisecond,&nbsp;<span class="hljs-number">30</span>*time.Second,&nbsp;<span class="hljs-number">2</span>*time.Minute,&nbsp;<span class="hljs-number">2.0</span>,&nbsp;<span class="hljs-number">1.0</span>,&nbsp;reflectorClock),<br>&nbsp;&nbsp;clock:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflectorClock,<br>&nbsp;&nbsp;watchErrorHandler:&nbsp;WatchErrorHandler(DefaultWatchErrorHandler),<br>&nbsp;&nbsp;expectedType:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reflect.TypeOf(expectedType),&nbsp;<span class="hljs-comment">//&nbsp;v1.Pod&nbsp;{}</span><br>&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;....<br>}<br><br><br></code></pre>
<p data-tool="mdnice编辑器">在该实现中，创建了Reflect对象。实际上，Reflect对象的内部字段主要继承自其上层的Controller对象。</p>
<h3 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">架构图</span><span class="suffix"></span></h3>
<p data-tool="mdnice编辑器">基于上述分析，我们现在可以更加清晰地理解架构图：</p>
<figure data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634193-745163333.png" alt=""></figure>
<p data-tool="mdnice编辑器">在上述过程中，启动了三个协程，具体如下：</p>
<ol data-tool="mdnice编辑器">
<li><section><code>k8s.io/client-go/tools/cache/dummyMutationDetector.Run</code>：此函数当前未执行任何实质性操作。</section></li><li><section><code>k8s.io/client-go/tools/cache.(*sharedProcessor).run</code>：
<ul>
<li><section><code>k8s.io/client-go/tools/cache.(*processorListener).run</code>：该方法通过用户自定义的处理器来处理事件，与底层逻辑紧密相关。</section></li><li><section><code>k8s.io/client-go/tools/cache.(*processorListener).pop</code>：此方法负责将事件分发到工作队列（workqueue）中。</section></li></ul>
</section></li><li><section><code>k8s.io/client-go/tools/cache.(*Reflector).Run</code>：此协程负责执行列表和监视操作，从API服务器获取数据。图示中的“pop”动作由下面描述的<code>processLoop</code>函数执行。</section></li></ol>
<p data-tool="mdnice编辑器">而主协程最终进入一个循环，处理由<code>Reflector.Run</code>生成的数据，具体的处理函数为<code>k8s.io/client-go/tools/cache.(*controller).processLoop</code>。这构成了整个数据流处理的核心机制。</p>
<figure data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634159-304658146.png" alt=""></figure>
<p data-tool="mdnice编辑器">在Reflect到DeltaFifo，再到processLoop，最终至HandleDeltas的流程中蕴含了丰富的技术细节与设计考量。为便于深入理解这一过程，我们将分章节详细探讨各个环节的关键点。</p>
<h3 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">从apiserver拿数据</span><span class="suffix"></span></h3>
<p data-tool="mdnice编辑器">反射器的调用链设计得相当简洁。</p>
<figure data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634179-1952392086.png" alt=""></figure>
<h4 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">list</span><span class="suffix"></span></h4>
<figure data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634171-312771389.png" alt=""></figure>
<p data-tool="mdnice编辑器">在调用链中未发现实际的列表操作。通过源代码分析，我们注意到请求函数被封装在一个闭包协程内（对于这种设计的选择，我尚不完全理解其背后的意图）。</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-comment">//&nbsp;list&nbsp;函数简单地列出所有项，并记录在调用时从服务器获得的资源版本。</span><br><span class="hljs-comment">//&nbsp;该资源版本可用于进一步的进度通知（即观察）。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(r&nbsp;*Reflector)</span>&nbsp;<span class="hljs-title">list</span><span class="hljs-params">(stopCh&nbsp;&lt;-<span class="hljs-keyword">chan</span>&nbsp;<span class="hljs-keyword">struct</span>{})</span>&nbsp;<span class="hljs-title">error</span></span>&nbsp;{<br>&nbsp;<span class="hljs-keyword">var</span>&nbsp;resourceVersion&nbsp;<span class="hljs-keyword">string</span><br>&nbsp;options&nbsp;:=&nbsp;metav1.ListOptions{ResourceVersion:&nbsp;r.relistResourceVersion()}<br>&nbsp;...<br>&nbsp;<span class="hljs-keyword">var</span>&nbsp;list&nbsp;runtime.Object<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;<span class="hljs-keyword">go</span>&nbsp;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">defer</span>&nbsp;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;r&nbsp;:=&nbsp;<span class="hljs-built_in">recover</span>();&nbsp;r&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;panicCh&nbsp;&lt;-&nbsp;r<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}()<br><br>&nbsp;&nbsp;pager&nbsp;:=&nbsp;pager.New(pager.SimplePageFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(opts&nbsp;metav1.ListOptions)</span>&nbsp;<span class="hljs-params">(runtime.Object,&nbsp;error)</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;r.listerWatcher.List(opts)<br>&nbsp;&nbsp;}))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....<br>&nbsp;&nbsp;list,&nbsp;paginatedResult,&nbsp;err&nbsp;=&nbsp;pager.ListWithAlloc(context.Background(),&nbsp;options)<br>&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;isExpiredError(err)&nbsp;||&nbsp;isTooLargeResourceVersionError(err)&nbsp;{<br>&nbsp;&nbsp;&nbsp;r.setIsLastSyncResourceVersionUnavailable(<span class="hljs-literal">true</span>)<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;list,&nbsp;paginatedResult,&nbsp;err&nbsp;=&nbsp;pager.ListWithAlloc(context.Background(),&nbsp;metav1.ListOptions{ResourceVersion:&nbsp;r.relistResourceVersion()})<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span class="hljs-built_in">close</span>(listCh)<br>&nbsp;}()<br>&nbsp;<span class="hljs-keyword">select</span>&nbsp;{<br>&nbsp;<span class="hljs-keyword">case</span>&nbsp;&lt;-stopCh:<br>&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">nil</span><br>&nbsp;<span class="hljs-keyword">case</span>&nbsp;r&nbsp;:=&nbsp;&lt;-panicCh:<br>&nbsp;&nbsp;<span class="hljs-built_in">panic</span>(r)<br>&nbsp;<span class="hljs-keyword">case</span>&nbsp;&lt;-listCh:<br>&nbsp;}<br>&nbsp;initTrace.Step(<span class="hljs-string">"Objects&nbsp;listed"</span>,&nbsp;trace.Field{Key:&nbsp;<span class="hljs-string">"error"</span>,&nbsp;Value:&nbsp;err})<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;klog.Warningf(<span class="hljs-string">"%s:&nbsp;failed&nbsp;to&nbsp;list&nbsp;%v:&nbsp;%v"</span>,&nbsp;r.name,&nbsp;r.typeDescription,&nbsp;err)<br>&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;fmt.Errorf(<span class="hljs-string">"failed&nbsp;to&nbsp;list&nbsp;%v:&nbsp;%w"</span>,&nbsp;r.typeDescription,&nbsp;err)<br>&nbsp;}<br><br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;options.ResourceVersion&nbsp;==&nbsp;<span class="hljs-string">"0"</span>&nbsp;&amp;&amp;&nbsp;paginatedResult&nbsp;{<br>&nbsp;&nbsp;r.paginatedResult&nbsp;=&nbsp;<span class="hljs-literal">true</span><br>&nbsp;}<br><br>&nbsp;r.setIsLastSyncResourceVersionUnavailable(<span class="hljs-literal">false</span>)&nbsp;<span class="hljs-comment">//&nbsp;list&nbsp;was&nbsp;successful</span><br>&nbsp;&nbsp;&nbsp;&nbsp;.....<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;:=&nbsp;r.syncWith(items,&nbsp;resourceVersion);&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;fmt.Errorf(<span class="hljs-string">"unable&nbsp;to&nbsp;sync&nbsp;list&nbsp;result:&nbsp;%v"</span>,&nbsp;err)<br>&nbsp;}<br>&nbsp;...<br>&nbsp;r.setLastSyncResourceVersion(resourceVersion)<br><br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">nil</span><br>}<br><br></code></pre>
<p data-tool="mdnice编辑器">最终从其他协程中，可以看出其调用关系如下：<br>
<img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634224-839666835.png" alt=""></p>
<p data-tool="mdnice编辑器">而通过参数图可以看到page对象调用ListWithAlloc时的内部字段如下，采用了分页获取：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs">{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"PageSize"</span>:&nbsp;<span class="hljs-number">500</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"PageFn"</span>:&nbsp;<span class="hljs-string">"0x171bdc0"</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"FullListIfExpired"</span>:&nbsp;<span class="hljs-literal">true</span>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"PageBufferSize"</span>:&nbsp;<span class="hljs-number">10</span><br>}<br></code></pre>
<p data-tool="mdnice编辑器">在其获取成功后，最终调用syncWith 我们可以发现传入了14个结构体，为当前所有namespace中的pod总数；</p>
<figure data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634148-202302892.png" alt=""></figure>
<p data-tool="mdnice编辑器"><strong>syncwatch</strong></p>
<p data-tool="mdnice编辑器">通过分析调用链可以观察到，在<code>Replace</code>函数中，<code>KeyOf</code>与<code>QueueActionLocked</code>之间存在一个循环依赖关系。</p>
<figure data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634167-1334774457.png" alt=""></figure>
<p data-tool="mdnice编辑器">为了更好的展示我们使用生成调用图的功能：</p>
<figure data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634211-1615153343.png" alt=""></figure>
<p data-tool="mdnice编辑器">这里可以清晰的看到有14组，对应了list产生的14个对象，通过上面分析，我们继续查看Replace函数：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(f&nbsp;*DeltaFIFO)</span>&nbsp;<span class="hljs-title">Replace</span><span class="hljs-params">(list&nbsp;[]<span class="hljs-keyword">interface</span>{},&nbsp;_&nbsp;<span class="hljs-keyword">string</span>)</span>&nbsp;<span class="hljs-title">error</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;！！！！！&nbsp;关键步骤,&nbsp;加锁！！！！！</span><br>&nbsp;f.lock.Lock()<br>&nbsp;<span class="hljs-keyword">defer</span>&nbsp;f.lock.Unlock()<br>&nbsp;keys&nbsp;:=&nbsp;<span class="hljs-built_in">make</span>(sets.String,&nbsp;<span class="hljs-built_in">len</span>(list))<br><br>&nbsp;<span class="hljs-comment">//&nbsp;keep&nbsp;backwards&nbsp;compat&nbsp;for&nbsp;old&nbsp;clients</span><br>&nbsp;action&nbsp;:=&nbsp;Sync<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;f.emitDeltaTypeReplaced&nbsp;{<br>&nbsp;&nbsp;action&nbsp;=&nbsp;Replaced&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;执行</span><br>&nbsp;}<br>&nbsp;<span class="hljs-comment">//&nbsp;进入循环</span><br>&nbsp;<span class="hljs-keyword">for</span>&nbsp;_,&nbsp;item&nbsp;:=&nbsp;<span class="hljs-keyword">range</span>&nbsp;list&nbsp;{<br>&nbsp;&nbsp;key,&nbsp;err&nbsp;:=&nbsp;f.KeyOf(item)<br>&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;KeyError{item,&nbsp;err}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;keys.Insert(key)<br>&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;:=&nbsp;f.queueActionLocked(action,&nbsp;item);&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;fmt.Errorf(<span class="hljs-string">"couldn't&nbsp;enqueue&nbsp;object:&nbsp;%v"</span>,&nbsp;err)<br>&nbsp;&nbsp;}<br>&nbsp;}<br><br>&nbsp;<span class="hljs-comment">//&nbsp;Do&nbsp;deletion&nbsp;detection&nbsp;against&nbsp;objects&nbsp;in&nbsp;the&nbsp;queue</span><br>&nbsp;queuedDeletions&nbsp;:=&nbsp;<span class="hljs-number">0</span><br>&nbsp;<span class="hljs-keyword">for</span>&nbsp;k,&nbsp;oldItem&nbsp;:=&nbsp;<span class="hljs-keyword">range</span>&nbsp;f.items&nbsp;{<br>&nbsp;&nbsp;.....&nbsp;<br>&nbsp;}<br><br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;f.knownObjects&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;为空</span><br>&nbsp;&nbsp;knownKeys&nbsp;:=&nbsp;f.knownObjects.ListKeys()<br>&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;_,&nbsp;k&nbsp;:=&nbsp;<span class="hljs-keyword">range</span>&nbsp;knownKeys&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....<br>&nbsp;&nbsp;}<br>&nbsp;}<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;!f.populated&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;执行</span><br>&nbsp;&nbsp;f.populated&nbsp;=&nbsp;<span class="hljs-literal">true</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;等于&nbsp;13</span><br>&nbsp;&nbsp;f.initialPopulationCount&nbsp;=&nbsp;keys.Len()&nbsp;+&nbsp;queuedDeletions<br>&nbsp;}<br><br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">nil</span><br>}<br></code></pre>
<p data-tool="mdnice编辑器">！！！！！！最关键的函数来了！！！！！</p>
<p data-tool="mdnice编辑器"><strong>queueActionLocked</strong></p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(f&nbsp;*DeltaFIFO)</span>&nbsp;<span class="hljs-title">queueActionLocked</span><span class="hljs-params">(actionType&nbsp;DeltaType,&nbsp;obj&nbsp;<span class="hljs-keyword">interface</span>{})</span>&nbsp;<span class="hljs-title">error</span></span>&nbsp;{<br>&nbsp;id,&nbsp;err&nbsp;:=&nbsp;f.KeyOf(obj)<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;KeyError{obj,&nbsp;err}<br>&nbsp;}<br>&nbsp;.....<br>&nbsp;oldDeltas&nbsp;:=&nbsp;f.items[id]<br>&nbsp;newDeltas&nbsp;:=&nbsp;<span class="hljs-built_in">append</span>(oldDeltas,&nbsp;Delta{actionType,&nbsp;obj})<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;dedupDeltas&nbsp;判断是否最后两个事件是否都为delete，如果是则保留一份。</span><br>&nbsp;newDeltas&nbsp;=&nbsp;dedupDeltas(newDeltas)<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;<span class="hljs-built_in">len</span>(newDeltas)&nbsp;&gt;&nbsp;<span class="hljs-number">0</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;_,&nbsp;exists&nbsp;:=&nbsp;f.items[id];&nbsp;!exists&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;初始化设置,&nbsp;将当前产生事件的pod对象，加入到queue中。</span><br>&nbsp;&nbsp;&nbsp;f.queue&nbsp;=&nbsp;<span class="hljs-built_in">append</span>(f.queue,&nbsp;id)<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;将事件加1</span><br>&nbsp;&nbsp;f.items[id]&nbsp;=&nbsp;newDeltas<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;广播,告诉等待的地方&nbsp;,&nbsp;我这有数据了快来拿,</span><br>&nbsp;&nbsp;f.cond.Broadcast()<br>&nbsp;}&nbsp;<span class="hljs-keyword">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.....<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">nil</span><br>}<br></code></pre>
<p data-tool="mdnice编辑器">在这一过程中，数据在Deltas中生成，并被广播出去。</p>
<h4 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">watch</span><span class="suffix"></span></h4>
<p data-tool="mdnice编辑器">调用链如下：<br>
<img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634226-2019341082.png" alt=""></p>
<p data-tool="mdnice编辑器">最终调用的是 <code>PodInformer</code> 中的 <code>Watch</code> 方法。</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(r&nbsp;*Request)</span>&nbsp;<span class="hljs-title">Watch</span><span class="hljs-params">(ctx&nbsp;context.Context)</span>&nbsp;<span class="hljs-params">(watch.Interface,&nbsp;error)</span></span>&nbsp;{<br>&nbsp;...<br>&nbsp;client&nbsp;:=&nbsp;r.c.Client<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br><br>&nbsp;url&nbsp;:=&nbsp;r.URL().String()<br>&nbsp;<span class="hljs-keyword">for</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;req,&nbsp;err&nbsp;:=&nbsp;r.newHTTPRequest(ctx)<br>&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">nil</span>,&nbsp;err<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;resp,&nbsp;err&nbsp;:=&nbsp;client.Do(req)<br>&nbsp;&nbsp;retry.After(ctx,&nbsp;r,&nbsp;resp,&nbsp;err)<br>&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;==&nbsp;<span class="hljs-literal">nil</span>&nbsp;&amp;&amp;&nbsp;resp.StatusCode&nbsp;==&nbsp;http.StatusOK&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;r.newStreamWatcher(resp)<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;done,&nbsp;transformErr&nbsp;:=&nbsp;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span>&nbsp;<span class="hljs-params">(<span class="hljs-keyword">bool</span>,&nbsp;error)</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">defer</span>&nbsp;readAndCloseResponseBody(resp)<br><br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;retry.IsNextRetry(ctx,&nbsp;r,&nbsp;req,&nbsp;resp,&nbsp;err,&nbsp;isErrRetryableFunc)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">false</span>,&nbsp;<span class="hljs-literal">nil</span><br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;resp&nbsp;==&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;the&nbsp;server&nbsp;must&nbsp;have&nbsp;sent&nbsp;us&nbsp;an&nbsp;error&nbsp;in&nbsp;'err'</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">true</span>,&nbsp;<span class="hljs-literal">nil</span><br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;result&nbsp;:=&nbsp;r.transformResponse(resp,&nbsp;req);&nbsp;result.err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">true</span>,&nbsp;result.err<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">true</span>,&nbsp;fmt.Errorf(<span class="hljs-string">"for&nbsp;request&nbsp;%s,&nbsp;got&nbsp;status:&nbsp;%v"</span>,&nbsp;url,&nbsp;resp.StatusCode)<br>&nbsp;&nbsp;}()<br>&nbsp;<br>&nbsp;}<br>}<br></code></pre>
<p data-tool="mdnice编辑器">这里关键点有两个：</p>
<ol data-tool="mdnice编辑器">
<li><section>resp的响应，使用的是HTTP/2.0 作为返回：</section></li></ol>
<figure data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634167-91880599.png" alt=""></figure>
<ol start="2" data-tool="mdnice编辑器">
<li><section>进入newStreamWatcher, 在这个函数中，创建一个协程获取watch数据，并返回当前对象：</section></li></ol>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(r&nbsp;*Request)</span>&nbsp;<span class="hljs-title">newStreamWatcher</span><span class="hljs-params">(resp&nbsp;*http.Response)</span>&nbsp;<span class="hljs-params">(watch.Interface,&nbsp;error)</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;......<br>&nbsp;objectDecoder,&nbsp;streamingSerializer,&nbsp;framer,&nbsp;err&nbsp;:=&nbsp;r.c.content.Negotiator.StreamDecoder(mediaType,&nbsp;params)<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">nil</span>,&nbsp;err<br>&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;.....<br>&nbsp;frameReader&nbsp;:=&nbsp;framer.NewFrameReader(resp.Body)<br>&nbsp;watchEventDecoder&nbsp;:=&nbsp;streaming.NewDecoder(frameReader,&nbsp;streamingSerializer)<br><br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;watch.NewStreamWatcher(<br>&nbsp;&nbsp;restclientwatch.NewDecoder(watchEventDecoder,&nbsp;objectDecoder),<br>&nbsp;&nbsp;errors.NewClientErrorReporter(http.StatusInternalServerError,&nbsp;r.verb,&nbsp;<span class="hljs-string">"ClientWatchDecoding"</span>),<br>&nbsp;),&nbsp;<span class="hljs-literal">nil</span><br>}<br></code></pre>
<ol start="3" data-tool="mdnice编辑器">
<li><section>返回的对象会传入到<code>k8s.io/client-go/tools/cache.watchHandler</code>，接受watch的事件做进一步处置：</section></li></ol>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-title">watchHandler</span><span class="hljs-params">(....)</span>&nbsp;<span class="hljs-title">error</span></span>&nbsp;{<br>.....<br>loop:<br>&nbsp;<span class="hljs-keyword">for</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">select</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;&lt;-stopCh:<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;errorStopRequested<br>&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;err&nbsp;:=&nbsp;&lt;-errc:<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;err<br>&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;event,&nbsp;ok&nbsp;:=&nbsp;&lt;-w.ResultChan():&nbsp;&nbsp;#&lt;-&nbsp;这里就是watch接受位置<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;dosomething</span><br>&nbsp;&nbsp;&nbsp;......<br>&nbsp;&nbsp;&nbsp;resourceVersion&nbsp;:=&nbsp;meta.GetResourceVersion()<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">switch</span>&nbsp;event.Type&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;watch.Added:<br>&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;:=&nbsp;store.Add(event.Object)<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;watch.Modified:<br>&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;:=&nbsp;store.Update(event.Object)<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;watch.Deleted:<br>&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;:=&nbsp;store.Delete(event.Object)<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;watch.Bookmark:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;`Bookmark`&nbsp;表示监视已在此处同步，只需更新资源版本</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;meta.GetAnnotations()[<span class="hljs-string">"k8s.io/initial-events-end"</span>]&nbsp;==&nbsp;<span class="hljs-string">"true"</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;exitOnInitialEventsEndBookmark&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*exitOnInitialEventsEndBookmark&nbsp;=&nbsp;<span class="hljs-literal">true</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">default</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">"%s:&nbsp;unable&nbsp;to&nbsp;understand&nbsp;watch&nbsp;event&nbsp;%#v"</span>,&nbsp;name,&nbsp;event))<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;setLastSyncResourceVersion(resourceVersion)<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;rvu,&nbsp;ok&nbsp;:=&nbsp;store.(ResourceVersionUpdater);&nbsp;ok&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;rvu.UpdateResourceVersion(resourceVersion)<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;eventCount++<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;exitOnInitialEventsEndBookmark&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;&amp;&amp;&nbsp;*exitOnInitialEventsEndBookmark&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;watchDuration&nbsp;:=&nbsp;clock.Since(start)<br>&nbsp;&nbsp;&nbsp;&nbsp;klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">"exiting&nbsp;%v&nbsp;Watch&nbsp;because&nbsp;received&nbsp;the&nbsp;bookmark&nbsp;that&nbsp;marks&nbsp;the&nbsp;end&nbsp;of&nbsp;initial&nbsp;events&nbsp;stream,&nbsp;total&nbsp;%v&nbsp;items&nbsp;received&nbsp;in&nbsp;%v"</span>,&nbsp;name,&nbsp;eventCount,&nbsp;watchDuration)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">nil</span><br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;....<br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">nil</span><br>}<br></code></pre>
<p data-tool="mdnice编辑器">以上我们搞明白了数据的来源，接下来看DeltaFifo如何拿数据；</p>
<h3 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">从DeltaFifo拿数据</span><span class="suffix"></span></h3>
<p data-tool="mdnice编辑器">拿数据的地方，则是上面主协程中的 <code>wait.Until(c.processLoop, time.Second, stopCh)</code>：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(c&nbsp;*controller)</span>&nbsp;<span class="hljs-title">processLoop</span><span class="hljs-params">()</span></span>&nbsp;{<br>&nbsp;<span class="hljs-keyword">for</span>&nbsp;{<br>&nbsp;&nbsp;obj,&nbsp;err&nbsp;:=&nbsp;c.config.Queue.Pop(PopProcessFunc(c.config.Process))<br>&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;....<br>&nbsp;&nbsp;}<br>&nbsp;}<br>}<br></code></pre>
<p data-tool="mdnice编辑器">其中Pop则等于DetalFIfo中的Pop函数，PopProcessFunc对应handleDeltas，可以看下架构图，代码解析如下：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-comment">//&nbsp;Pop&nbsp;阻塞直到队列中有一些项目，然后返回一个。如果有多个项目准备好，它们将按照添加/更新的顺序返回。</span><br><span class="hljs-comment">//&nbsp;在返回之前，该项目会从队列（和存储）中移除，因此如果您没有成功处理它，</span><br><span class="hljs-comment">//&nbsp;您需要使用&nbsp;AddIfNotPresent()&nbsp;将其添加回来。</span><br><span class="hljs-comment">//&nbsp;process&nbsp;函数在锁定下调用，因此可以安全地更新需要与队列同步的数据结构（例如&nbsp;knownKeys）。</span><br><span class="hljs-comment">//&nbsp;PopProcessFunc&nbsp;可能返回一个&nbsp;ErrRequeue&nbsp;的实例，</span><br><span class="hljs-comment">//&nbsp;其中嵌套的错误指示当前项目应该被重新排队（相当于在锁下调用&nbsp;AddIfNotPresent）。</span><br><span class="hljs-comment">//&nbsp;process&nbsp;应避免昂贵的&nbsp;I/O&nbsp;操作，以便其他队列操作，即&nbsp;Add()&nbsp;和&nbsp;Get()，不会被阻塞太久。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//&nbsp;Pop&nbsp;返回一个&nbsp;'Deltas'，它包含在队列中等待时对象发生的所有事情（deltas）的完整列表。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(f&nbsp;*DeltaFIFO)</span>&nbsp;<span class="hljs-title">Pop</span><span class="hljs-params">(process&nbsp;PopProcessFunc)</span>&nbsp;<span class="hljs-params">(<span class="hljs-keyword">interface</span>{},&nbsp;error)</span></span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;这个地方也加锁了</span><br>&nbsp;f.lock.Lock()<br>&nbsp;<span class="hljs-keyword">defer</span>&nbsp;f.lock.Unlock()<br>&nbsp;<span class="hljs-keyword">for</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;<span class="hljs-built_in">len</span>(f.queue)&nbsp;==&nbsp;<span class="hljs-number">0</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;当队列为空时，调用&nbsp;Pop()&nbsp;会被阻塞，直到有新项目被入队。</span><br>&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;当调用&nbsp;Close()&nbsp;时，f.closed&nbsp;被设置并且条件被广播。</span><br>&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;这会导致这个循环继续并从&nbsp;Pop()&nbsp;返回。</span><br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;f.closed&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">nil</span>,&nbsp;ErrFIFOClosed<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;等待上面的广播后,&nbsp;才被唤起</span><br>&nbsp;&nbsp;&nbsp;f.cond.Wait()<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;isInInitialList&nbsp;:=&nbsp;!f.hasSynced_locked()<br>&nbsp;&nbsp;id&nbsp;:=&nbsp;f.queue[<span class="hljs-number">0</span>]<br>&nbsp;&nbsp;f.queue&nbsp;=&nbsp;f.queue[<span class="hljs-number">1</span>:]<br>&nbsp;&nbsp;depth&nbsp;:=&nbsp;<span class="hljs-built_in">len</span>(f.queue)<br>&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;f.initialPopulationCount&nbsp;&gt;&nbsp;<span class="hljs-number">0</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;f.initialPopulationCount--<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;item,&nbsp;ok&nbsp;:=&nbsp;f.items[id]<br>&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;!ok&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;This&nbsp;should&nbsp;never&nbsp;happen</span><br>&nbsp;&nbsp;&nbsp;klog.Errorf(<span class="hljs-string">"Inconceivable!&nbsp;%q&nbsp;was&nbsp;in&nbsp;f.queue&nbsp;but&nbsp;not&nbsp;f.items;&nbsp;ignoring."</span>,&nbsp;id)<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">continue</span><br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span class="hljs-built_in">delete</span>(f.items,&nbsp;id)<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;err&nbsp;:=&nbsp;process(item,&nbsp;isInInitialList)&nbsp;&lt;-&nbsp;处理<br>&nbsp;&nbsp;....<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;item,&nbsp;err<br>&nbsp;}<br>}<br><br></code></pre>
<p data-tool="mdnice编辑器">在上述流程中，当Board调用该函数时，将从队列(queue)中提取一个条目(item)。需要注意的是，此条目包含了特定资源在一段时间内产生的所有事件。随后，这些事件将被传递给Process (handleDeltas) 进行处理。</p>
<p data-tool="mdnice编辑器">f.queue的设计目的是确保在指定时间窗口内，所有生成的事件能够按照资源的接收顺序被有序保存。由于items是以映射（map）的形式存储，而映射本身并不保证元素间的顺序性，因此采用了队列结构来维持事件的序列完整性。</p>
<p data-tool="mdnice编辑器">在对该段代码进行分析时，我们注意到一个关键点：从apiserver获取的数据被存储到队列中时会<strong>使用锁机制</strong>，并且该锁<strong>仅在函数终止时才会被释放。</strong></p>
<p data-tool="mdnice编辑器">然而，在当前讨论的函数中同样存在加锁操作，并且这个锁也在同一函数内部被释放。值得注意的是，<code>f.cond.Wait()</code> 方法调用时会首先解锁，然后将当前协程置于阻塞状态（详情可参考先前关于条件变量Cond的工作原理分析）。</p>
<p data-tool="mdnice编辑器">基于上述观察，我推测在初始化阶段可能存在<code>lock</code>与<code>f.cond.Locker()</code>引用相同锁对象的情况，这一点可以从初始配置代码中得到验证。</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-title">NewDeltaFIFOWithOptions</span><span class="hljs-params">(opts&nbsp;DeltaFIFOOptions)</span>&nbsp;*<span class="hljs-title">DeltaFIFO</span></span>&nbsp;{<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;opts.KeyFunction&nbsp;==&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;opts.KeyFunction&nbsp;=&nbsp;MetaNamespaceKeyFunc<br>&nbsp;}<br>&nbsp;f&nbsp;:=&nbsp;&amp;DeltaFIFO{<br>&nbsp;&nbsp;items:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]Deltas{},<br>&nbsp;&nbsp;queue:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[]<span class="hljs-keyword">string</span>{},<br>&nbsp;&nbsp;keyFunc:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opts.KeyFunction,<br>&nbsp;&nbsp;knownObjects:&nbsp;opts.KnownObjects,<br><br>&nbsp;&nbsp;emitDeltaTypeReplaced:&nbsp;opts.EmitDeltaTypeReplaced,<br>&nbsp;&nbsp;transformer:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opts.Transformer,<br>&nbsp;}<br>&nbsp;f.cond.L&nbsp;=&nbsp;&amp;f.lock&nbsp;&nbsp;&nbsp;&lt;--------------------------------<br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;f<br>}<br></code></pre>
<p data-tool="mdnice编辑器">非常搞。</p>
<h3 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">处理数据-HandleDeltas</span><span class="suffix"></span></h3>
<p data-tool="mdnice编辑器">整体的调用链如下：<br>
<img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634227-135297620.png" alt=""></p>
<p data-tool="mdnice编辑器">最终核心函数：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-title">processDeltas</span><span class="hljs-params">(<br>&nbsp;//&nbsp;Object&nbsp;which&nbsp;receives&nbsp;event&nbsp;notifications&nbsp;from&nbsp;the&nbsp;given&nbsp;deltas<br>&nbsp;handler&nbsp;ResourceEventHandler,<br>&nbsp;clientState&nbsp;Store,<br>&nbsp;deltas&nbsp;Deltas,<br>&nbsp;isInInitialList&nbsp;<span class="hljs-keyword">bool</span>,<br>)</span>&nbsp;<span class="hljs-title">error</span></span>&nbsp;{<br>&nbsp;<span class="hljs-comment">//&nbsp;from&nbsp;oldest&nbsp;to&nbsp;newest</span><br>&nbsp;<span class="hljs-keyword">for</span>&nbsp;_,&nbsp;d&nbsp;:=&nbsp;<span class="hljs-keyword">range</span>&nbsp;deltas&nbsp;{<br>&nbsp;&nbsp;obj&nbsp;:=&nbsp;d.Object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;<span class="hljs-keyword">switch</span>&nbsp;d.Type&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;Sync,&nbsp;Replaced,&nbsp;Added,&nbsp;Updated:<br>&nbsp;&nbsp;&nbsp;old,&nbsp;exists,&nbsp;err&nbsp;:=&nbsp;clientState.Get(obj)<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;err<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;exists&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;:=&nbsp;clientState.Update(obj);&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;err<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;handler.OnUpdate(old,&nbsp;obj)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">continue</span><br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;:=&nbsp;clientState.Add(obj);&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;err<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;handler.OnAdd(obj,&nbsp;isInInitialList)<br>&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;Deleted:<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;err&nbsp;:=&nbsp;clientState.Delete(obj);&nbsp;err&nbsp;!=&nbsp;<span class="hljs-literal">nil</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;err<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;handler.OnDelete(obj)<br>&nbsp;&nbsp;}<br>&nbsp;}<br>&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-literal">nil</span><br>}<br></code></pre>
<p data-tool="mdnice编辑器">根据参数，展示其为Replaced，代码中<code>clientState.Add(obj)</code>主要是加indexer，下篇中说明；</p>
<p data-tool="mdnice编辑器">而OnAdd，核心逻辑如下：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-comment">//&nbsp;Conforms&nbsp;to&nbsp;ResourceEventHandler</span><br><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(s&nbsp;*sharedIndexInformer)</span>&nbsp;<span class="hljs-title">OnAdd</span><span class="hljs-params">(obj&nbsp;<span class="hljs-keyword">interface</span>{},&nbsp;isInInitialList&nbsp;<span class="hljs-keyword">bool</span>)</span></span>&nbsp;{<br>&nbsp;s.cacheMutationDetector.AddObject(obj)&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;没做啥</span><br>&nbsp;s.processor.distribute(addNotification{newObj:&nbsp;obj,&nbsp;isInInitialList:&nbsp;isInInitialList},&nbsp;<span class="hljs-literal">false</span>)<br>}<br><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(p&nbsp;*sharedProcessor)</span>&nbsp;<span class="hljs-title">distribute</span><span class="hljs-params">(obj&nbsp;<span class="hljs-keyword">interface</span>{},&nbsp;sync&nbsp;<span class="hljs-keyword">bool</span>)</span></span>&nbsp;{&nbsp;&lt;-&nbsp;当前为<span class="hljs-literal">false</span><br>&nbsp;p.listenersLock.RLock()<br>&nbsp;<span class="hljs-keyword">defer</span>&nbsp;p.listenersLock.RUnlock()<br>&nbsp;<span class="hljs-keyword">for</span>&nbsp;listener,&nbsp;isSyncing&nbsp;:=&nbsp;<span class="hljs-keyword">range</span>&nbsp;p.listeners&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">switch</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;!sync:<br>&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;非同步消息会发送给每个监听器</span><br>&nbsp;&nbsp;&nbsp;listener.add(obj)<br>&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;isSyncing:<br>&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;同步消息会发送给每个正在同步的监听器</span><br>&nbsp;&nbsp;&nbsp;listener.add(obj)<br>&nbsp;&nbsp;<span class="hljs-keyword">default</span>:<br>&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;skipping&nbsp;a&nbsp;sync&nbsp;obj&nbsp;for&nbsp;a&nbsp;non-syncing&nbsp;listener</span><br>&nbsp;&nbsp;}<br>&nbsp;}<br>}<br><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(p&nbsp;*processorListener)</span>&nbsp;<span class="hljs-title">add</span><span class="hljs-params">(notification&nbsp;<span class="hljs-keyword">interface</span>{})</span></span>&nbsp;{<br>&nbsp;<span class="hljs-keyword">if</span>&nbsp;a,&nbsp;ok&nbsp;:=&nbsp;notification.(addNotification);&nbsp;ok&nbsp;&amp;&amp;&nbsp;a.isInInitialList&nbsp;{<br>&nbsp;&nbsp;p.syncTracker.Start()<br>&nbsp;}<br>&nbsp;p.addCh&nbsp;&lt;-&nbsp;notification&nbsp;&nbsp;<br>}<br></code></pre>
<p data-tool="mdnice编辑器">走了这么多路，p.addCh我早就忘记是啥玩意儿了。其实它躲在了上述新开的三个协程的：<code>k8s.io/client-go/tools/cache.(*processorListener).pop</code>中：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><br><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(p&nbsp;*processorListener)</span>&nbsp;<span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&nbsp;{<br>&nbsp;<span class="hljs-keyword">defer</span>&nbsp;utilruntime.HandleCrash()<br>&nbsp;<span class="hljs-keyword">defer</span>&nbsp;<span class="hljs-built_in">close</span>(p.nextCh)&nbsp;<span class="hljs-comment">//&nbsp;Tell&nbsp;.run()&nbsp;to&nbsp;stop</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;<span class="hljs-keyword">var</span>&nbsp;nextCh&nbsp;<span class="hljs-keyword">chan</span>&lt;-&nbsp;<span class="hljs-keyword">interface</span>{}<br>&nbsp;<span class="hljs-keyword">var</span>&nbsp;notification&nbsp;<span class="hljs-keyword">interface</span>{}<br>&nbsp;<span class="hljs-keyword">for</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">select</span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;nextCh&nbsp;&lt;-&nbsp;notification:<br>&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;Notification&nbsp;dispatched</span><br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;ok&nbsp;<span class="hljs-keyword">bool</span><br>&nbsp;&nbsp;&nbsp;notification,&nbsp;ok&nbsp;=&nbsp;p.pendingNotifications.ReadOne()<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;!ok&nbsp;{&nbsp;<span class="hljs-comment">//&nbsp;Nothing&nbsp;to&nbsp;pop</span><br>&nbsp;&nbsp;&nbsp;&nbsp;nextCh&nbsp;=&nbsp;<span class="hljs-literal">nil</span>&nbsp;<span class="hljs-comment">//&nbsp;Disable&nbsp;this&nbsp;select&nbsp;case</span><br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;notificationToAdd,&nbsp;ok&nbsp;:=&nbsp;&lt;-p.addCh:<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;!ok&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span><br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;notification&nbsp;==&nbsp;<span class="hljs-literal">nil</span>&nbsp;{&nbsp;<span class="hljs-comment">//&nbsp;No&nbsp;notification&nbsp;to&nbsp;pop&nbsp;(and&nbsp;pendingNotifications&nbsp;is&nbsp;empty)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;Optimize&nbsp;the&nbsp;case&nbsp;-&nbsp;skip&nbsp;adding&nbsp;to&nbsp;pendingNotifications</span><br>&nbsp;&nbsp;&nbsp;&nbsp;notification&nbsp;=&nbsp;notificationToAdd<br>&nbsp;&nbsp;&nbsp;&nbsp;nextCh&nbsp;=&nbsp;p.nextCh<br>&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword">else</span>&nbsp;{&nbsp;<span class="hljs-comment">//&nbsp;There&nbsp;is&nbsp;already&nbsp;a&nbsp;notification&nbsp;waiting&nbsp;to&nbsp;be&nbsp;dispatched</span><br>&nbsp;&nbsp;&nbsp;&nbsp;p.pendingNotifications.WriteOne(notificationToAdd)<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;}<br>}<br></code></pre>
<p data-tool="mdnice编辑器">这段代码的逻辑设计颇具匠心，具体分析如下：</p>
<ol data-tool="mdnice编辑器">
<li><section>首先，我们观察到数据被添加到了<code>p.addCh</code>通道中。</section></li><li><section>接着，在执行流程进入第二个分支时，将<code>p.nextCh</code>赋值给了<code>nextCh</code>变量。这一操作确保了在下一次循环迭代中，控制流能够顺利地转移到第一个分支。</section></li><li><section>当程序控制权转回至第一个分支时，之前通过步骤2获取的数据（即存储于<code>#2</code>中的信息）会被发送至<code>nextCh</code>，实际上也就是<code>p.nextCh</code>。
<ul>
<li><section>如果此时<code>pendingNotifications</code>缓冲区中有待处理的数据，则继续沿用当前的第一个分支进行处理。</section></li><li><section>反之，如果该缓冲区为空，则程序将暂停并等待新数据的到来。<br>
这种机制有效地实现了异步通信与任务调度之间的协调。</section></li></ul>
</section></li></ol>
<p data-tool="mdnice编辑器">流程图如下：</p>
<figure data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634219-96257192.svg" alt=""></figure>
<p data-tool="mdnice编辑器">组件图如下：</p>
<figure data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634217-2094468134.svg" alt=""></figure>
<p data-tool="mdnice编辑器">走过了这么长的代码，离了个大谱，还没到处理函数；p.nextCh在哪被接受呢？就剩最后一个协程了：<code>k8s.io/client-go/tools/cache.(*processorListener).run</code>：</p>
<pre class="custom" data-tool="mdnice编辑器"><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">func</span>&nbsp;<span class="hljs-params">(p&nbsp;*processorListener)</span>&nbsp;<span class="hljs-title">run</span><span class="hljs-params">()</span></span>&nbsp;{<br>&nbsp;<span class="hljs-comment">//&nbsp;此调用会阻塞，直到通道关闭。当在通知过程中发生恐慌时，</span><br>&nbsp;<span class="hljs-comment">//&nbsp;我们会捕获它，**有问题的项将被跳过！**，并在短暂延迟（一秒钟）后</span><br>&nbsp;<span class="hljs-comment">//&nbsp;尝试下一个通知。这通常比从不再交付要好。</span><br>&nbsp;stopCh&nbsp;:=&nbsp;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span>&nbsp;<span class="hljs-keyword">struct</span>{})<br>&nbsp;wait.Until(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&nbsp;{<br>&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;next&nbsp;:=&nbsp;<span class="hljs-keyword">range</span>&nbsp;p.nextCh&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">switch</span>&nbsp;notification&nbsp;:=&nbsp;next.(<span class="hljs-keyword">type</span>)&nbsp;{<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;updateNotification:<br>&nbsp;&nbsp;&nbsp;&nbsp;p.handler.OnUpdate(notification.oldObj,&nbsp;notification.newObj)<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;addNotification:<br>&nbsp;&nbsp;&nbsp;&nbsp;p.handler.OnAdd(notification.newObj,&nbsp;notification.isInInitialList)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;notification.isInInitialList&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.syncTracker.Finished()<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;deleteNotification:<br>&nbsp;&nbsp;&nbsp;&nbsp;p.handler.OnDelete(notification.oldObj)<br>&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">default</span>:<br>&nbsp;&nbsp;&nbsp;&nbsp;utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">"unrecognized&nbsp;notification:&nbsp;%T"</span>,&nbsp;next))<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;the&nbsp;only&nbsp;way&nbsp;to&nbsp;get&nbsp;here&nbsp;is&nbsp;if&nbsp;the&nbsp;p.nextCh&nbsp;is&nbsp;empty&nbsp;and&nbsp;closed</span><br>&nbsp;&nbsp;<span class="hljs-built_in">close</span>(stopCh)<br>&nbsp;},&nbsp;<span class="hljs-number">1</span>*time.Second,&nbsp;stopCh)<br>}<br><br></code></pre>
<p data-tool="mdnice编辑器">天了个姥爷，这里终于到达了我们的自定义处理器。</p>
<p data-tool="mdnice编辑器">以上，我们走完了一个item的处理过程。我们回过头来看一下，启动一个informer时的goroutine如下：</p>
<figure data-tool="mdnice编辑器"><img src="https://img2024.cnblogs.com/blog/2051648/202504/2051648-20250411220634235-1191169738.png" alt=""></figure>
<p data-tool="mdnice编辑器">而startResync篇幅有限不在赘述，感兴趣的可以自己读一读；</p>
<h1 data-tool="mdnice编辑器"><span class="prefix"></span><span class="content">总结</span><span class="suffix"></span></h1>
<p data-tool="mdnice编辑器">以上完成了对Informer数据流图中所有关键函数的详细解析，希望能为您的理解提供帮助。在接下来的文章中，我们将进一步探讨Indexer的实现原理，并深入研究其核心结构体的设计，请持续关注。</p>
<p data-tool="mdnice编辑器">在Kubernetes（k8s）的设计中，为了追求代码的简洁性和执行效率，Informer机制广泛采用了接口抽象和多协程并发处理的方式。这种设计虽然有效提升了系统的灵活性与性能，但同时也增加了其复杂性，给初次接触该机制的学习者带来了较大的理解难度。</p>
<p data-tool="mdnice编辑器">在此背景下，使用Delve（dlv）这样的调试工具进行代码跟踪和问题排查变得相对困难，因为需要对并发编程有深入的理解以及对Informer内部结构有所掌握才能有效利用这些工具。</p>
<p data-tool="mdnice编辑器">你懂我意思，快来关注我的源码阅读神器：<a href="https://github.com/toheart/goanalysis" rel="noopener nofollow">https://github.com/toheart/goanalysis</a>。只要你能将程序跑起来，那么就你能够阅读源码！！！</p>
</section>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.591112732300926" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-11 22:07">2025-04-11 22:07</span>&nbsp;
<a href="https://www.cnblogs.com/tohearts">tohearts</a>&nbsp;
阅读(<span id="post_view_count">21</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18821456" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18821456);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18821456', targetLink: 'https://www.cnblogs.com/tohearts/p/18821456', title: '【跟K8S学设计】Informer全分析-Reflector（上）' })">举报</a>
</div>
        