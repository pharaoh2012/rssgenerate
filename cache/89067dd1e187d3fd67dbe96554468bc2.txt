
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/liyongqiang-cc/p/18648546" title="发布于 2025-01-14 10:57">
    <span role="heading" aria-level="2">.Net Core 管道底层源码实现</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>在 .NET Core 中，请求处理管道是一个中间件（Middleware）链，用于处理 HTTP 请求并生成响应。管道的底层实现基于 <code>Microsoft.AspNetCore.Http</code> 命名空间中的一些核心类和接口</p>
</blockquote>
<h3 id="1-核心组件">1. 核心组件</h3>
<h4 id="11-httpcontext">1.1 <code>HttpContext</code></h4>
<ul>
<li>• <code>HttpContext</code> 是 HTTP 请求和响应的核心抽象，封装了请求信息（如请求头、请求体、查询参数等）和响应信息（如状态码、响应头、响应体等）。</li>
<li>• 每个请求都会创建一个 <code>HttpContext</code> 实例，并在整个管道中传递。</li>
</ul>
<h4 id="12-httprequest-和-httpresponse">1.2 <code>HttpRequest</code> 和 <code>HttpResponse</code></h4>
<ul>
<li>• <code>HttpRequest</code> 和 <code>HttpResponse</code> 分别表示 HTTP 请求和响应，是 <code>HttpContext</code> 的一部分。</li>
<li>• <code>HttpRequest</code> 包含请求的详细信息，如路径、方法、头、体等。</li>
<li>• <code>HttpResponse</code> 用于设置响应的状态码、头、体等。</li>
</ul>
<h4 id="13-requestdelegate">1.3 <code>RequestDelegate</code></h4>
<ul>
<li>• <code>RequestDelegate</code> 是一个委托，表示处理 HTTP 请求的方法：</li>
</ul>
<pre><code>public&nbsp;delegate&nbsp;Task&nbsp;RequestDelegate(HttpContext&nbsp;context);
</code></pre>
<ul>
<li>• 管道中的每个中间件都是一个 <code>RequestDelegate</code>。</li>
</ul>
<h4 id="14-middleware">1.4 <code>Middleware</code></h4>
<ul>
<li>• 中间件是一个类或方法，用于处理请求并调用管道中的下一个中间件。</li>
<li>• 中间件通常通过 <code>Use</code> 或 <code>Run</code> 方法注册到管道中。</li>
</ul>
<h3 id="2-定义-applicationbuilder-接口">2. 定义 <code>ApplicationBuilder</code> 接口</h3>
<p>首先，我们定义 IApplicationBuilder 接口：</p>
<pre><code>public&nbsp;interface&nbsp;IApplicationBuilder
{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;添加中间件到管道中
&nbsp;&nbsp;&nbsp;&nbsp;IApplicationBuilder&nbsp;Use(Func&lt;RequestDelegate,&nbsp;RequestDelegate&gt;&nbsp;middleware);

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;构建最终的请求处理管道
&nbsp;&nbsp;&nbsp;&nbsp;RequestDelegate&nbsp;Build();

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取或设置应用程序服务提供者
&nbsp;&nbsp;&nbsp;&nbsp;IServiceProvider&nbsp;ApplicationServices&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取属性字典，用于存储共享数据
&nbsp;&nbsp;&nbsp;&nbsp;IDictionary&lt;string,&nbsp;object&gt;&nbsp;Properties&nbsp;{&nbsp;get;&nbsp;}
}
</code></pre>
<hr>
<h3 id="3-定义-requestdelegate-委托">3. 定义 RequestDelegate 委托</h3>
<p>管道的核心是基于委托（Delegate）和上下文（Context）的机制。</p>
<p><code>**RequestDelegate**</code>：是一个表示处理 HTTP 请求的委托。</p>
<pre><code>public&nbsp;delegate&nbsp;Task&nbsp;RequestDelegate(HttpContext&nbsp;context);
</code></pre>
<ul>
<li>• <code>**HttpContext**</code>：封装了 HTTP 请求和响应的所有信息，包括请求头、请求体、响应头、响应体等。</li>
</ul>
<p>每个中间件本质上是一个 <code>RequestDelegate</code>，它接收 <code>HttpContext</code> 并处理请求，同时可以选择调用下一个中间件。</p>
<hr>
<h3 id="4-实现-applicationbuilder-类">4. 实现 <code>ApplicationBuilder</code> 类</h3>
<p>接下来，我们实现 ApplicationBuilder 类：</p>
<pre><code>public&nbsp;class&nbsp;ApplicationBuilder&nbsp;:&nbsp;IApplicationBuilder
{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;存储中间件组件的列表
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;readonly&nbsp;IList&lt;Func&lt;RequestDelegate,&nbsp;RequestDelegate&gt;&gt;&nbsp;_components&nbsp;=&nbsp;new&nbsp;List&lt;Func&lt;RequestDelegate,&nbsp;RequestDelegate&gt;&gt;();

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取或设置应用程序服务提供者
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;IServiceProvider&nbsp;ApplicationServices&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取属性字典，用于存储共享数据
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;IDictionary&lt;string,&nbsp;object&gt;&nbsp;Properties&nbsp;{&nbsp;get;&nbsp;}&nbsp;=&nbsp;new&nbsp;Dictionary&lt;string,&nbsp;object&gt;();

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;添加中间件到管道中
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;IApplicationBuilder&nbsp;Use(Func&lt;RequestDelegate,&nbsp;RequestDelegate&gt;&nbsp;middleware)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_components.Add(middleware);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;构建最终的请求处理管道
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;RequestDelegate&nbsp;Build()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;默认的请求处理程序，返回&nbsp;404&nbsp;状态码
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RequestDelegate&nbsp;app&nbsp;=&nbsp;context&nbsp;=&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context.Response.StatusCode&nbsp;=&nbsp;404;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Task.CompletedTask;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;反向遍历中间件组件列表，构建嵌套的请求处理管道
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(var&nbsp;component&nbsp;in&nbsp;_components.Reverse())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;app&nbsp;=&nbsp;component(app);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;app;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<hr>
<h3 id="5-创建中间件">5. 创建中间件</h3>
<p>我们创建一个简单的日志收集中间件来展示如何使用 <code>**ApplicationBuilder**</code> ：</p>
<pre><code>public&nbsp;class&nbsp;CustomizeMiddleware
{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;readonly&nbsp;RequestDelegate&nbsp;_next;

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;构造函数，接受下一个中间件的委托
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;CustomizeMiddleware(RequestDelegate&nbsp;next)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_next&nbsp;=&nbsp;next;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;中间件的请求处理方法
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;async&nbsp;Task&nbsp;Invoke(HttpContext&nbsp;context)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("自定义中间件:&nbsp;Before");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;_next(context);&nbsp;//&nbsp;调用下一个中间件
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("自定义中间件:&nbsp;After");
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<hr>
<h3 id="6-使用-applicationbuilder-构建管道">6. 使用 <code>ApplicationBuilder</code> 构建管道</h3>
<pre><code>public&nbsp;class&nbsp;Program
{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;Main(string[]&nbsp;args)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;创建&nbsp;ApplicationBuilder&nbsp;实例
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;builder&nbsp;=&nbsp;new&nbsp;ApplicationBuilder();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;添加&nbsp;CustomizeMiddleware&nbsp;到管道中
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.Use(next&nbsp;=&gt;&nbsp;new&nbsp;CustomizeMiddleware(next).Invoke);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;添加内联中间件到管道中
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.Use(next&nbsp;=&gt;&nbsp;async&nbsp;context&nbsp;=&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("内联中间件:&nbsp;Before");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;next(context);&nbsp;//&nbsp;调用下一个中间件
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("内联中间件:&nbsp;After");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;构建最终的请求处理管道
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;app&nbsp;=&nbsp;builder.Build();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;创建一个&nbsp;HttpContext&nbsp;实例
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;context&nbsp;=&nbsp;new&nbsp;DefaultHttpContext();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;执行管道
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;app(context).Wait();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<p>输入结果为：</p>
<p><img src="https://fastly.jsdelivr.net/gh/bucketio/img18@main/2025/01/02/1735813739984-7368e6e3-3604-46a9-a177-67f85b5d4a68.png" alt="" title="null" loading="lazy"></p>
<hr>
<h3 id="7总结">7.总结</h3>
<p>.NET Core 管道的底层实现是基于委托链的机制，每个中间件都是一个 <code>RequestDelegate</code>，通过链式调用来处理 HTTP 请求和响应。管道的构建过程通过 <code>IApplicationBuilder</code> 接口完成，中间件的添加顺序决定了管道的执行顺序。通过理解管道的底层实现，可以更好地掌握 .NET Core 的请求处理机制，并能够灵活地配置和扩展管道。<br>
<img src="https://img2024.cnblogs.com/blog/2063798/202501/2063798-20250102183722859-1921801243.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="5.055811054537037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-14 10:57">2025-01-14 10:57</span>&nbsp;
<a href="https://www.cnblogs.com/liyongqiang-cc">代码拾光</a>&nbsp;
阅读(<span id="post_view_count">501</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18648546" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18648546);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18648546', targetLink: 'https://www.cnblogs.com/liyongqiang-cc/p/18648546', title: '.Net Core 管道底层源码实现' })">举报</a>
</div>
        