
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/longfurcat/p/18660188" title="发布于 2025-01-08 20:11">
    <span role="heading" aria-level="2">【源码】ByteToMessageDecoder对比自定义实现</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2><strong>前言</strong></h2>
<p>在上一篇随笔中，我们探讨了如何实现一套自定义通信协议，其中涉及到的粘包和拆包处理最初是完全自定义实现的，后来则改为了继承 <code>ByteToMessageDecoder</code> 来简化处理。</p>
<p>本篇将重点讨论这两种实现方式在缓存管理上的主要区别，并深入分析其中的不同之处以及值得借鉴的经验和技巧。</p>
<h2>代码回顾</h2>
<h3>1）完全自定义实现</h3>
<p>无缓存的情况</p>
<ul>
<li>反复从ByteBuf中提取完整的消息</li>
<li>剩余的残缺消息写入缓存（会进行数据拷贝）</li>
</ul>
<p>有缓存的情况</p>
<ul>
<li>将新收到的数据接入缓存</li>
<li>反复从缓存中提取完整消息</li>
<li>释放缓存内读取过的数据（会进行数据移动，导致拷贝）</li>
</ul>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> EchoServerHandler <span style="color: rgba(0, 0, 255, 1)">extends</span><span style="color: rgba(0, 0, 0, 1)"> ChannelInboundHandlerAdapter {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">final</span> <span style="color: rgba(0, 0, 255, 1)">int</span> HEADER_LENGTH = 4; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">消息头部长度</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> ByteBuf buffer = Unpooled.buffer(1024); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">缓存残缺消息</span>
<span style="color: rgba(0, 0, 0, 1)">
    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelRead(ChannelHandlerContext ctx, Object msg) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        ByteBuf income </span>=<span style="color: rgba(0, 0, 0, 1)"> (ByteBuf) msg;

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">上一次有缓存存在，则本数据包不是消息头开头，</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span>(buffer.readableBytes() &gt; 0<span style="color: rgba(0, 0, 0, 1)">) {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">进行必要的扩容，下面的readBytes不会自动扩容</span>
<span style="color: rgba(0, 0, 0, 1)">            buffer.ensureWritable(income.readableBytes()); 
            income.readBytes(buffer, income.readableBytes());

            readMsgFromBuffer(buffer);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">剩下一点残缺消息</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span>(buffer.readableBytes() &gt; 0<span style="color: rgba(0, 0, 0, 1)">) {
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">保留剩下的数据，重置读索引为0</span>
                System.out.println("缓存剩余字节："+<span style="color: rgba(0, 0, 0, 1)">buffer.readableBytes());
                buffer.discardReadBytes();
            } </span><span style="color: rgba(0, 0, 255, 1)">else</span> { <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">刚刚好，则清空数据</span>
<span style="color: rgba(0, 0, 0, 1)">                buffer.clear();
            }
        } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
            readMsgFromBuffer(income);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">剩下的数据全部写入缓存</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (income.readableBytes() &gt;0<span style="color: rgba(0, 0, 0, 1)">) {
                System.out.println(</span>"剩余字节:"+<span style="color: rgba(0, 0, 0, 1)">income.readableBytes());
                income.readBytes(buffer, income.readableBytes());
            }
        }

    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">从字节数组中读取完整的消息</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> readMsgFromBuffer(ByteBuf byteBuf) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">剩余可读消息是否包含一个消息头</span>
        <span style="color: rgba(0, 0, 255, 1)">while</span>(byteBuf.readableBytes() &gt;=<span style="color: rgba(0, 0, 0, 1)"> HEADER_LENGTH) {
            byteBuf.markReaderIndex(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">由于可能读不到完整的消息，所以读之前先标记索引位置，方便重置
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">读取消息头</span>
            <span style="color: rgba(0, 0, 255, 1)">byte</span>[] headerBytes = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[4<span style="color: rgba(0, 0, 0, 1)">];
            byteBuf.readBytes(headerBytes);
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">获取类型</span>
            <span style="color: rgba(0, 0, 255, 1)">int</span> type = headerBytes[0] &amp; 0xFF<span style="color: rgba(0, 0, 0, 1)">;
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">获取消息体长度</span>
            <span style="color: rgba(0, 0, 255, 1)">int</span> bodyLength = ((headerBytes[1] &amp; 0xFF) &lt;&lt; 16) |<span style="color: rgba(0, 0, 0, 1)">
                    ((headerBytes[</span>2] &amp; 0xFF) &lt;&lt; 8) |<span style="color: rgba(0, 0, 0, 1)">
                    (headerBytes[</span>3] &amp; 0xFF<span style="color: rgba(0, 0, 0, 1)">);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">不包含请求体</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (byteBuf.readableBytes() &lt;<span style="color: rgba(0, 0, 0, 1)"> bodyLength) {
                byteBuf.resetReaderIndex(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">重置读索引到当前消息头位置</span>
                <span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
            }

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 完整消息体已经接收，处理消息</span>
            <span style="color: rgba(0, 0, 255, 1)">byte</span>[] body = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">[bodyLength];
            byteBuf.readBytes(body);
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">System.out.println("type:"+type+"||length:"+bodyLength+"||body:"+new String(body, CharsetUtil.UTF_8));</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span>(type == 1<span style="color: rgba(0, 0, 0, 1)">) {
                </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                    HelloRequest request </span>=<span style="color: rgba(0, 0, 0, 1)"> HelloRequest.parseFrom(body);
                    System.out.println(</span>"收到消息:"+<span style="color: rgba(0, 0, 0, 1)">request.toString());
                } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e) {
                    System.out.println(</span>"解析失败："+<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> String(body, CharsetUtil.UTF_8));
                }
            } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
                System.out.println(</span>"消息类型未知："+<span style="color: rgba(0, 0, 0, 1)">type);
            }

        }
    }

    ....</span><span style="color: rgba(0, 0, 0, 1)">
}</span></pre>
</div>
<h3>2）继承ByteToMessageDecoder的实现</h3>
<p>使用ByteToMessageDecoder后，数据的解码变得更加简化。只需检查缓冲区是否有足够的数据来提取一个/多个完整的消息。</p>
<p>如果数据不足，解码过程就会结束，无需额外管理缓存。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> MessageDecoder <span style="color: rgba(0, 0, 255, 1)">extends</span><span style="color: rgba(0, 0, 0, 1)"> ByteToMessageDecoder {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">final</span> <span style="color: rgba(0, 0, 255, 1)">int</span> HEADER_LENGTH = 4; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">消息头部长度</span>
<span style="color: rgba(0, 0, 0, 1)">
    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 检查是否足够的字节来读取一个消息头</span>
        <span style="color: rgba(0, 0, 255, 1)">while</span> (in.readableBytes() &gt;=<span style="color: rgba(0, 0, 0, 1)"> HEADER_LENGTH) {
            in.markReaderIndex(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 标记当前读取位置，便于重置

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 读取消息头部</span>
            <span style="color: rgba(0, 0, 255, 1)">byte</span>[] headerBytes = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[4<span style="color: rgba(0, 0, 0, 1)">];
            in.readBytes(headerBytes);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 获取类型</span>
            <span style="color: rgba(0, 0, 255, 1)">int</span> type = headerBytes[0] &amp; 0xFF<span style="color: rgba(0, 0, 0, 1)">;
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 获取消息体长度</span>
            <span style="color: rgba(0, 0, 255, 1)">int</span> bodyLength = ((headerBytes[1] &amp; 0xFF) &lt;&lt; 16) |<span style="color: rgba(0, 0, 0, 1)">
                    ((headerBytes[</span>2] &amp; 0xFF) &lt;&lt; 8) |<span style="color: rgba(0, 0, 0, 1)">
                    (headerBytes[</span>3] &amp; 0xFF<span style="color: rgba(0, 0, 0, 1)">);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 检查缓冲区中的数据是否足够读取整个消息体</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (in.readableBytes() &lt;<span style="color: rgba(0, 0, 0, 1)"> bodyLength) {
                in.resetReaderIndex(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 重置读指针，等待更多数据</span>
                <span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
            }

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 读取消息体</span>
            <span style="color: rgba(0, 0, 255, 1)">byte</span>[] body = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">[bodyLength];
            in.readBytes(body);

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 处理消息</span>
            <span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                Object msg </span>= <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
                </span><span style="color: rgba(0, 0, 255, 1)">if</span>(type == 1<span style="color: rgba(0, 0, 0, 1)">) {
                    msg </span>=<span style="color: rgba(0, 0, 0, 1)"> HelloRequest.parseFrom(body);
                } </span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span>(type == 2<span style="color: rgba(0, 0, 0, 1)">) {
                    msg </span>=<span style="color: rgba(0, 0, 0, 1)"> HelloResponse.parseFrom(body);
                } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
                    System.out.println(</span>"未知消息："+<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> String(body, CharsetUtil.UTF_8));
                }
                </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(Objects.nonNull(msg)) {
                    out.add(msg);
                }

            } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e) {
                System.out.println(</span>"解析失败: " + <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> String(body, CharsetUtil.UTF_8));
            }
        }
    }
}</span></pre>
</div>
<h2>ByteToMessageDecoder源码</h2>
<h3>核心属性</h3>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">缓存</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> ByteBuf cumulation;
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">累加器（用于拼接缓存和新到数据）</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> Cumulator cumulator =<span style="color: rgba(0, 0, 0, 1)"> MERGE_CUMULATOR;
   
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">X次channelRead之后，释放已读数据</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">int</span> discardAfterReads = 16<span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">累计channelRead次数（每次释放完会重置）</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">int</span> numReads;</pre>
</div>
<h3>处理流程</h3>
<p>1.新到数据存放到缓冲区（使用累加器Cumulator进行数据合并）</p>
<p>2.循环调用子类的decode方法，读取消息存入List，直到数据不足</p>
<p>3.遍历List，依次传递给下一个处理器</p>
<h3>累加器</h3>
<p>提供2种累加器实现，MERGE_CUMULATOR和COMPOSITE_CUMULATOR</p>
<p><strong>1）MERGE_CUMULATOR（默认实现）</strong></p>
<p>缓存存在的时候，直接进行数据拷贝，与缓存数据进行整合。</p>
<p>下面的代码可以看到，如果缓冲区空间不够，则会进行扩容操作。</p>
<p>跟自定义实现中的"buffer.ensureWritable(income.readableBytes())"一致。</p>
<p>整体思路跟自定义实现差不多，不过它多考虑了两种情况</p>
<ul>
<li>数据被共享：共享数据会被其他使用者影响，需排除影响</li>
<li>数据只读：只读空间无法被写入，而缓冲区是需要写入新数据的</li>
</ul>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">final</span> Cumulator MERGE_CUMULATOR = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Cumulator() {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">cumulation是上一次的缓存，in是新到的数据</span>
<span style="color: rgba(0, 0, 0, 1)">        @Override
        </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {
            </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                </span><span style="color: rgba(0, 0, 255, 1)">final</span><span style="color: rgba(0, 0, 0, 1)"> ByteBuf buffer;
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> (cumulation.writerIndex() &gt; cumulation.maxCapacity() -<span style="color: rgba(0, 0, 0, 1)"> in.readableBytes()
                    </span>|| cumulation.refCnt() &gt; 1 ||<span style="color: rgba(0, 0, 0, 1)"> cumulation.isReadOnly()) {
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Expand cumulation (by replace it) when either there is not more room in the buffer
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> or if the refCnt is greater then 1 which may happen when the user use slice().retain() or
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> duplicate().retain() or if its read-only.
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span>
                    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> See:
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> - </span><span style="color: rgba(0, 128, 0, 1); text-decoration: underline">https://github.com/netty/netty/issues/2327</span>
                    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> - </span><span style="color: rgba(0, 128, 0, 1); text-decoration: underline">https://github.com/netty/netty/issues/1764</span>
                    buffer =<span style="color: rgba(0, 0, 0, 1)"> expandCumulation(alloc, cumulation, in.readableBytes());
                } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
                    buffer </span>=<span style="color: rgba(0, 0, 0, 1)"> cumulation;
                }
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">新到数据写入缓存</span>
<span style="color: rgba(0, 0, 0, 1)">                buffer.writeBytes(in);
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> buffer;
            } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> We must release in in all cases as otherwise it may produce a leak if writeBytes(...) throw
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> for whatever release (for example because of OutOfMemoryError)</span>
<span style="color: rgba(0, 0, 0, 1)">                in.release();
            }
        }
    };</span></pre>
</div>
<p><strong>2）COMPOSITE_CUMULATOR</strong></p>
<p>&nbsp;上面的处理，新到数据与缓存的合并是通过数据拷贝。而下面这种方式，则是使用组合（数据没有移动，只是提供一个整合后的视图）</p>
<div class="cnblogs_code">
<pre>  <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">final</span> Cumulator COMPOSITE_CUMULATOR = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Cumulator() {
        @Override
        </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {
            ByteBuf buffer;
            </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> (cumulation.refCnt() &gt; 1<span style="color: rgba(0, 0, 0, 1)">) {
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Expand cumulation (by replace it) when the refCnt is greater then 1 which may happen when the
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> user use slice().retain() or duplicate().retain().
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span>
                    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> See:
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> - </span><span style="color: rgba(0, 128, 0, 1); text-decoration: underline">https://github.com/netty/netty/issues/2327</span>
                    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> - </span><span style="color: rgba(0, 128, 0, 1); text-decoration: underline">https://github.com/netty/netty/issues/1764</span>
                    buffer =<span style="color: rgba(0, 0, 0, 1)"> expandCumulation(alloc, cumulation, in.readableBytes());
                    buffer.writeBytes(in);
                } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
                    CompositeByteBuf composite;
                    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (cumulation <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> CompositeByteBuf) {
                        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">上一次缓存已经是组合对象</span>
                        composite =<span style="color: rgba(0, 0, 0, 1)"> (CompositeByteBuf) cumulation;
                    } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
                        composite </span>=<span style="color: rgba(0, 0, 0, 1)"> alloc.compositeBuffer(Integer.MAX_VALUE);
                        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">缓存加入组合</span>
                        composite.addComponent(<span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">, cumulation);
                    }
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">新到数据加入组合</span>
                    composite.addComponent(<span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">, in);
                    in </span>= <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
                    buffer </span>=<span style="color: rgba(0, 0, 0, 1)"> composite;
                }
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> buffer;
            } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">由于使用组合方式，数据还在原来的地方。不能直接释放</span>
                <span style="color: rgba(0, 0, 255, 1)">if</span> (in != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> We must release if the ownership was not transferred as otherwise it may produce a leak if
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> writeBytes(...) throw for whatever release (for example because of OutOfMemoryError).</span>
<span style="color: rgba(0, 0, 0, 1)">                    in.release();
                }
            }
        }
    };</span></pre>
</div>
<h3>主要方法——channelRead</h3>
<p>在上述的自定义实现中，每次从缓冲区读取完数据，会释放掉已读数据，防止缓存数据无限增长。</p>
<p><span style="background-color: rgba(255, 255, 0, 1)">buffer.discardReadBytes();</span></p>
<p>而这里做了优化，累积16次读取后，才会进行释放。（channelReadComplete的时候也会触发）</p>
<p>这样做的好处，就是可以减少数据拷贝的次数。（discard操作会把已读数据清空，重置读索引，然后把剩余数据往前挪）</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> channelRead(ChannelHandlerContext ctx, Object msg) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">仅处理ByteBuf，其他消息直接传给下一个Handler</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> (msg <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> ByteBuf) {
            CodecOutputList out </span>=<span style="color: rgba(0, 0, 0, 1)"> CodecOutputList.newInstance();
            </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                ByteBuf data </span>=<span style="color: rgba(0, 0, 0, 1)"> (ByteBuf) msg;
               
                first </span>= cumulation == <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">缓冲区为空，直接赋值</span>
                <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (first) {
                    cumulation </span>=<span style="color: rgba(0, 0, 0, 1)"> data;
                } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">使用累加器进行数据合并</span>
                    cumulation =<span style="color: rgba(0, 0, 0, 1)"> cumulator.cumulate(ctx.alloc(), cumulation, data);
                }
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">调用子类实现，从缓冲区中解析消息</span>
<span style="color: rgba(0, 0, 0, 1)">                callDecode(ctx, cumulation, out);
            } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (DecoderException e) {
                </span><span style="color: rgba(0, 0, 255, 1)">throw</span><span style="color: rgba(0, 0, 0, 1)"> e;
            } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e) {
                </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> DecoderException(e);
            } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> (cumulation != <span style="color: rgba(0, 0, 255, 1)">null</span> &amp;&amp; !<span style="color: rgba(0, 0, 0, 1)">cumulation.isReadable()) {
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">缓冲区数据刚好读完，清空缓冲区，清空已读次数</span>
                    numReads = 0<span style="color: rgba(0, 0, 0, 1)">;
                    cumulation.release();
                    cumulation </span>= <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
                } </span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span> (++ numReads &gt;=<span style="color: rgba(0, 0, 0, 1)"> discardAfterReads) {
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> We did enough reads already try to discard some bytes so we not risk to see a OOME.
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> See </span><span style="color: rgba(0, 128, 0, 1); text-decoration: underline">https://github.com/netty/netty/issues/4275</span>
                    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">已读数达到限定次数（默认16），释放已读数据</span>
                    numReads = 0<span style="color: rgba(0, 0, 0, 1)">;
                    discardSomeReadBytes();
                }

                </span><span style="color: rgba(0, 0, 255, 1)">int</span> size =<span style="color: rgba(0, 0, 0, 1)"> out.size();
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">是不是没解析到消息</span>
                decodeWasNull = !<span style="color: rgba(0, 0, 0, 1)">out.insertSinceRecycled();
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">将解析出来的消息逐个传个下一个Handler</span>
<span style="color: rgba(0, 0, 0, 1)">                fireChannelRead(ctx, out, size);
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">清空List，下次再用</span>
<span style="color: rgba(0, 0, 0, 1)">                out.recycle();
            }
        } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">直接丢给下一个Handler</span>
<span style="color: rgba(0, 0, 0, 1)">            ctx.fireChannelRead(msg);
        }
    }</span></pre>
</div>
<h3>主要方法——callDecode</h3>
<p>这里主要通过检查List结果集和数据读取情况，来判断要不要结束解码循环。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> callDecode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt;<span style="color: rgba(0, 0, 0, 1)"> out) {
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 0, 255, 1)">while</span><span style="color: rgba(0, 0, 0, 1)"> (in.isReadable()) {
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">先读取List大小</span>
                <span style="color: rgba(0, 0, 255, 1)">int</span> outSize =<span style="color: rgba(0, 0, 0, 1)"> out.size();
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">有数据，则先传给下一个Handler</span>
                <span style="color: rgba(0, 0, 255, 1)">if</span> (outSize &gt; 0<span style="color: rgba(0, 0, 0, 1)">) {
                    fireChannelRead(ctx, out, outSize);
                    out.clear();

                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Check if this handler was removed before continuing with decoding.
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> If it was removed, it is not safe to continue to operate on the buffer.
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span>
                    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> See:
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> - </span><span style="color: rgba(0, 128, 0, 1); text-decoration: underline">https://github.com/netty/netty/issues/4635</span>
                    <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (ctx.isRemoved()) {
                        </span><span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
                    }
                    outSize </span>= 0<span style="color: rgba(0, 0, 0, 1)">;
                }

                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">开始之前，先记录可读数据量</span>
                <span style="color: rgba(0, 0, 255, 1)">int</span> oldInputLength =<span style="color: rgba(0, 0, 0, 1)"> in.readableBytes();
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">调用子类decode方法</span>
<span style="color: rgba(0, 0, 0, 1)">                decodeRemovalReentryProtection(ctx, in, out);

                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Check if this handler was removed before continuing the loop.
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> If it was removed, it is not safe to continue to operate on the buffer.
                </span><span style="color: rgba(0, 128, 0, 1)">//</span>
                <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> See </span><span style="color: rgba(0, 128, 0, 1); text-decoration: underline">https://github.com/netty/netty/issues/1664</span>
                <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (ctx.isRemoved()) {
                    </span><span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
                }

                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">查看子类是否解析出数据</span>
                <span style="color: rgba(0, 0, 255, 1)">if</span> (outSize ==<span style="color: rgba(0, 0, 0, 1)"> out.size()) {
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">数据没被动过，说明没有可解析的数据，直接break</span>
                    <span style="color: rgba(0, 0, 255, 1)">if</span> (oldInputLength ==<span style="color: rgba(0, 0, 0, 1)"> in.readableBytes()) {
                        </span><span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
                    } </span><span style="color: rgba(0, 0, 255, 1)">else</span> { <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">数据有被动过，但还没解析出数据，继续执行</span>
                        <span style="color: rgba(0, 0, 255, 1)">continue</span><span style="color: rgba(0, 0, 0, 1)">;
                    }
                }
 
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">List内有新数据，但是数据没有被读过，说明子类实现有问题，报错</span>
                <span style="color: rgba(0, 0, 255, 1)">if</span> (oldInputLength ==<span style="color: rgba(0, 0, 0, 1)"> in.readableBytes()) {
                    </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> DecoderException(
                            StringUtil.simpleClassName(getClass()) </span>+
                                    ".decode() did not read anything but decoded a message."<span style="color: rgba(0, 0, 0, 1)">);
                }
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">如果只解析一次，则直接结束</span>
                <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (isSingleDecode()) {
                    </span><span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
                }
            }
        } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (DecoderException e) {
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span><span style="color: rgba(0, 0, 0, 1)"> e;
        } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception cause) {
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> DecoderException(cause);
        }
    }</span></pre>
</div>
<h2>总结</h2>
<p>核心内容并无太大差异，但 Netty 提供的抽象类在实现上考虑了更多细节，并经过社区的不断演进，功能变得更加稳定和完善。</p>
<p>因此，推荐继承 <code>ByteToMessageDecoder</code> 来实现解码。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.15560230226388888" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-08 20:34">2025-01-08 20:11</span>&nbsp;
<a href="https://www.cnblogs.com/longfurcat">猫毛·波拿巴</a>&nbsp;
阅读(<span id="post_view_count">35</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18660188" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18660188);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18660188', targetLink: 'https://www.cnblogs.com/longfurcat/p/18660188', title: '【源码】ByteToMessageDecoder对比自定义实现' })">举报</a>
</div>
        