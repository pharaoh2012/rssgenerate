
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wenbochang/p/18895509" title="发布于 2025-05-25 21:55">
    <span role="heading" aria-level="2">Spring异常处理 bug ！！！同一份代码，结果却不一样？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1-背景">1. 背景</h1>
<p>在上周遇到一个spring bug的问题，将其记录一下。简化的代码如下：</p>
<pre><code class="language-java">public void insert() {
    try {
        Person person = new Person();
        person.setId(3581L);// 这个是主键，拥有唯一索引**
        personDao.insert(person);
    } catch (DuplicateKeyException e) {
        log.error("DuplicateKeyException e = {}", e.getMessage(), e);
        // DuplicateKeyException 其他逻辑处理
    } catch (DataIntegrityViolationException e) {
        log.error("DataIntegrityViolationException e = {}", e.getMessage(), e);
        // DataIntegrityViolationException 其他逻辑处理
    } catch (Exception e) {
        log.error("Exception e = {}", e.getMessage(), e);
    }
}
</code></pre>
<p>然而<mark>同一份代码，部署在不同机器</mark>（数据库只有一个, 不存在分库分表情况），遇到的情况不一样。</p>
<p>A机器：如果主键冲突，则抛出DuplicateKeyException异常，进入第7行的逻辑</p>
<p>B机器：如果主键冲突，则抛出DataIntegrityViolationException异常，进入第11行的逻辑</p>
<p>甚至我将B机器重启，如果主键冲突，则抛出DuplicateKeyException异常，进入第7行的逻辑</p>
<p>非常的奇怪，我们一一细说</p>
<h1 id="2-数据库异常分析">2. 数据库异常分析</h1>
<h2 id="21-spring对java标准异常的包装">2.1 spring对java标准异常的包装</h2>
<table>
<thead>
<tr>
<th><strong>异常类型/属性</strong></th>
<th>所属框架或技术栈</th>
<th>触发场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQLIntegrityConstraintViolationException</td>
<td>属于 JDBC 标准异常体系，是 <code>java.sql.SQLException</code> 的子类。</td>
<td>当数据库操作违反了完整性约束（<strong>如主键冲突、外键约束、唯一性约束等</strong>）时，JDBC 驱动会抛出此异常。</td>
</tr>
<tr>
<td>DuplicateKeyException</td>
<td>是 Spring 框架中定义的异常，属于 Spring Data 或 Spring JDBC 的封装异常。</td>
<td>通常在插入或更新数据时，违反了数据库表的<strong>主键或唯一索引约束</strong>（即尝试插入重复的主键或唯一键值）。</td>
</tr>
<tr>
<td>DataIntegrityViolationException</td>
<td>是 Spring 框架中的异常，属于 Spring 数据访问层的通用异常体系</td>
<td>是一个更通用的异常，表示任何违反数据完整性的操作，<strong>包括但不限于主键冲突、外键约束、非空约束等</strong>。</td>
</tr>
</tbody>
</table>
<p>从表格中我们可以明显看出，SQLIntegrityConstraintViolationException是属于Java体系的标准异常，当主键冲突，外键约束，非空等情况正常都会抛出这个异常</p>
<p>然后spring框架对这个异常进行了一个封装，比如违反唯一索引会抛出DuplicateKeyException异常，其他的情况会抛出DataIntegrityViolationException异常。</p>
<h2 id="22-spring代码包装">2.2 spring代码包装</h2>
<p>在spring中会有一个<strong>SQLErrorCodesFactory</strong>类，会加载下面路径下的资源。也就是说，每个数据库厂商对于不同异常返回的错误码不同，spring进行了一个包装</p>
<pre><code>public static final String SQL_ERROR_CODE_DEFAULT_PATH 
    =  "org/springframework/jdbc/support/sql-error-codes.xml";
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1335795/202505/1335795-20250525215132774-328337840.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/1335795/202505/1335795-20250525215138161-1891584829.png" alt="" loading="lazy"></p>
<h2 id="23-问题产生的原因">2.3 问题产生的原因</h2>
<p>在spring异常处理中，有一个非常核心的类 <strong>SQLErrorCodeSQLExceptionTranslator</strong>，但遇到主键冲突，非空约束等异常的时候，spring会使用这个类进行转化。</p>
<pre><code>if (Arrays.binarySearch(this.sqlErrorCodes.getBadSqlGrammarCodes(), errorCode) &gt;= 0) {
    logTranslation(task, sql, sqlEx, false);
    return new BadSqlGrammarException(task, (sql != null ? sql : ""), sqlEx);
}
else if (Arrays.binarySearch(this.sqlErrorCodes.getInvalidResultSetAccessCodes(), errorCode) &gt;= 0) {
    logTranslation(task, sql, sqlEx, false);
    return new InvalidResultSetAccessException(task, (sql != null ? sql : ""), sqlEx);
}
else if (Arrays.binarySearch( this .sqlErrorCodes.getDuplicateKeyCodes(), errorCode) &gt;= 0) {
    logTranslation(task, sql, sqlEx, false);
    return new DuplicateKeyException(buildMessage(task, sql, sqlEx), sqlEx);
}
else if (Arrays.binarySearch(this.sqlErrorCodes.getDataIntegrityViolationCodes(), errorCode) &gt;= 0) {
    logTranslation(task, sql, sqlEx, false);
    return new DataIntegrityViolationException(buildMessage(task, sql, sqlEx), sqlEx);
}
else if // xxx 省略
</code></pre>
<p>我们可以从上面代码中可以看到，他其中是从sqlErrorCodes中，进行二分查找，是否存在相应的code码，然后返回给上游不同的错误，那么sqlErrorCodes是从哪里获取的呢。</p>
<pre><code>try {
    String name = JdbcUtils.extractDatabaseMetaData(dataSource, "getDatabaseProductName");
    if (StringUtils.hasLength(name)) {
       return registerDatabase(dataSource, name);
    }
}
catch (MetaDataAccessException ex) {
    logger.warn("Error while extracting database name - falling back to empty error codes", ex);
}
// Fallback is to return an empty SQLErrorCodes instance.
return new SQLErrorCodes();
</code></pre>
<p>从上面代码我们可以看出，会通过JdbcUtils.extractDatabaseMetaData方法来获取sqlErrorCodes，是哪个厂商，并且获取到Connection进行连接，然后返回相应的sqlErrorCodes码</p>
<p>但是在第7行，<mark>如果此时Connection数据库链接有异常，则会报错，然后返回11行一个空的sqlErrorCodes</mark>，那么问题就出在这里了！！！</p>
<p>也就是说，如果在第一次获取sqlErrorCodes，如果出了问题，那么这个字段就会为空，上面代码的转化异常逻辑就会判断错误。就会走到else兜底退避的策略。</p>
<p>具体退避的策略在SQLExceptionSubclassTranslator类中，所以当走到了退避策略，所有SQLIntegrityConstraintViolationException异常都会返回DataIntegrityViolationException异常</p>
<pre><code>if (ex instanceof SQLNonTransientConnectionException) {
    return new DataAccessResourceFailureException(buildMessage(task, sql, ex), ex);
}
else if (ex instanceof SQLDataException) {
    return new DataIntegrityViolationException(buildMessage(task, sql, ex), ex);
}
else if (ex instanceof SQLIntegrityConstraintViolationException) {
    return new DataIntegrityViolationException(buildMessage(task, sql, ex), ex);
}
else if // 省略
</code></pre>
<h1 id="3-问题复现">3. 问题复现</h1>

<h2 id="31-错误复现">3.1 错误复现</h2>
<p>我们从2.3分析中，可以清楚的知道，根因是SQLErrorCodeSQLExceptionTranslator类中sqlErrorCodes字段为空导致主键冲突退避返回了DataIntegrityViolationException异常。</p>
<p>那么我们就可以模拟链接异常，比如连接被关闭了，导致首次初始化的时候导致sqlErrorCodes失败，代码如下 (<strong>注意这块代码必须在项目启动 首先第一次执行</strong>)</p>
<pre><code>@Transactional
public void testConnect() {
    try {
        Connection connection = DataSourceUtils.getConnection(dataSource);
        connection.close(); // 强制关闭连接，破坏事务一致性

        personDao.selectById(1L);
    } catch (DuplicateKeyException e) {
        log.error("DuplicateKeyException e = {}", e.getMessage(), e);
    } catch (DataIntegrityViolationException e) {
        log.error("DataIntegrityViolationException e = {}", e.getMessage(), e);
    } catch (Exception e) {
        log.error("Exception e = {}", e.getMessage(), e);
    }
}
</code></pre>
<p>在上面代码中，我们获取了链接，并且强制关闭了，那么就会导致初始化的时候走2.3那块代码就会报错，此时sqlErrorCodes就会为空。</p>
<p>如果后面sql遇到了唯一索引，返回如下：<br>
<img src="https://img2024.cnblogs.com/blog/1335795/202505/1335795-20250525215202028-551984171.png" alt="" loading="lazy"></p>
<h2 id="32-正确复现">3.2 正确复现</h2>
<p>将上面代码connection.close()去掉，那么第一次缓存就正常了。再次执行，如果遇到了唯一索引，返回如下：<br>
<img src="https://img2024.cnblogs.com/blog/1335795/202505/1335795-20250525215208816-1805725031.png" alt="" loading="lazy"></p>
<h1 id="4-解决办法">4. 解决办法</h1>
<p>在github上面已经有人提出此问题，并且标记为了bug，链接如下：<a href="https://github.com/spring-projects/spring-framework/issues/25681" target="_blank" rel="noopener nofollow">https://github.com/spring-projects/spring-framework/issues/25681</a></p>
<p>并且修复pull request如下 （此代码已合并到<a href="https://github.com/spring-projects/spring-framework/releases/tag/v5.2.9.RELEASE" target="_blank" rel="noopener nofollow">v5.2.9.RELEASE</a>分支）</p>
<p><a href="https://github.com/spring-projects/spring-framework/commit/670b9fd60b3b5ada69b060424d697270eeee01c2#diff-e2f38c7b7d44c3679cd585e5c81e76b3ca32313bf870caa6435cd36bfe4d9600" target="_blank" rel="noopener nofollow">https://github.com/spring-projects/spring-framework/commit/670b9fd60b3b5ada69b060424d697270eeee01c2#diff-e2f38c7b7d44c3679cd585e5c81e76b3ca32313bf870caa6435cd36bfe4d9600</a></p>
<p><img src="https://img2024.cnblogs.com/blog/1335795/202505/1335795-20250525215217691-1538993920.png" alt="" loading="lazy"></p>
<h2 id="41-办法1">4.1 办法1</h2>
<p>升级spring版本到<mark>5.2.9.release+</mark>，可以彻底解决此问题</p>
<h2 id="42-办法2">4.2 办法2</h2>
<p><strong>第一步</strong>在项目启动的时候，获取SQLErrorCodes，如果为空，则打印error日志并且告警。让开发同学知道有这么一个问题 (可重启也可不重启)</p>
<pre><code>public class DatabaseMetadataPreloader  {
    @PostConstruct
    public void init() {
       try {
          SQLErrorCodes errorCodes = errorCodesFactory.getErrorCodes(dataSource);
          log.info("Database metadata preloaded successfully errorCodes = {}", GsonUtils.toJson(errorCodes));

          String[] duplicateKeyCodes = errorCodes.getDuplicateKeyCodes();
          if (ArrayUtils.isEmpty(duplicateKeyCodes)) {
             log.error("No duplicate key codes found in database metadata 请重启服务");
          }
       } catch (Exception e) {
          log.error("Failed to preload database metadata", e);
       }
    }
}
</code></pre>
<p><strong>第二步</strong>重新查询一遍数据库</p>
<p>如果有数据则表明是索引冲突，如果没有数据，则可能是其他异常引起的，走原有的老逻辑</p>
<pre><code>catch (DuplicateKeyException e) {
    log.error("DuplicateKeyException e = {}", e.getMessage(), e);
}

catch (DataIntegrityViolationException e) {
    log.error("DataIntegrityViolationException e = {}", e.getMessage(), e);
    // 重新查一遍数据库，如果有数据，说明是唯一索引冲突
    Person p = select(xxxx)
    if (p != null) {
        // 唯一索引冲突
    } else {
        // 其他异常引起的
    }
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.68527162875" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-25 21:56">2025-05-25 21:55</span>&nbsp;
<a href="https://www.cnblogs.com/wenbochang">程序员博博</a>&nbsp;
阅读(<span id="post_view_count">134</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18895509);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18895509', targetLink: 'https://www.cnblogs.com/wenbochang/p/18895509', title: 'Spring异常处理 bug ！！！同一份代码，结果却不一样？' })">举报</a>
</div>
        