
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chaoguo1234/p/18907877" title="发布于 2025-06-03 02:55">
    <span role="heading" aria-level="2">NSMutableDictionary 的内存布局</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        NSMutableDictionary 的内存布局
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>有关<code>NSDictionary</code>的内存布局，可以参看<a href="https://www.cnblogs.com/chaoguo1234/p/18906738" target="_blank">《NSDictionary 的内存布局》</a>。</p>
<h1 id="1-类图">1 类图</h1>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250603024746062-1498783895.png" alt="image" loading="lazy"></p>
<p>和<a href="https://www.cnblogs.com/chaoguo1234/p/18906738" target="_blank">《NSDictionary 的内存布局》</a>中的类图相比较，本章类图多了<code>2</code>个新成员:</p>
<p><code>__NSDictionaryM</code></p>
<p><code>__NSCFDictionary</code></p>
<h1 id="2-__nsdictionarym">2 __NSDictionaryM</h1>
<p>通过下面的方式，可以创建<code>__NSDictionaryM</code>:</p>
<pre><code class="language-objectivec">NSMutableDictionary *dictM = [NSMutableDictionary dictionary];

NSMutableDictionary  *dict = [NSMutableDictionary dictionaryWithDictionary:@{"kaaa": @"aaa"}];
</code></pre>
<p>从<code>Xcode</code>的控制台输出可以看到:</p>
<pre><code class="language-c">(lldb) po [dictM class]
__NSDictionaryM
</code></pre>
<h2 id="21-初始化">2.1 初始化</h2>
<p><code>__NSDictionaryM</code>的初始化流程和<code>__NSDictionaryI</code>类似。</p>
<p>当调用<code>+[NSMutableDictionary dictionaryWithDictionary:]</code>方法时，最终会调用到<code>-[__NSPlaceholderDictionary initWithObjects:forKeys:count]</code>方法。</p>
<p><code>-[__NSPlaceholderDictionary initWithObjects:forKeys:count]</code>方法在<code>NSDictionary</code>部分已经介绍过。</p>
<p>这里重新贴出与<code>__NSDictionaryM</code>相关的伪代码:</p>
<pre><code class="language-objectivec">// -[__NSPlaceholderDictionary initWithObjects:forKeys:count]

@interface __NSPlaceholderDictionary

...

@end

@implementation __NSPlaceholderDictionary

- (instancetype)initWithObjects:(ObjectType const[])objects forKeys:(ObjectTpye const[])keys count:(NSUInteger)count {
  ...
  label:
  if (self == ___immutablePlaceholderDictionary) {
    ...
  } else if (self == ___mutablePlaceholderDictionary) {
    // 创建 __NSDictionaryM
    return __NSDictionaryM_new(keys, objecs, count, 3);
  }
  
  error "创建出错"
}
</code></pre>
<p>从伪代码可以看到，最终会调用到<code>__NSDictionaryM_new</code>方法。</p>
<p>下面就来看看<code>__NSDictionaryM_new</code>的内部实现。</p>
<p>和创建<code>__NSDictionaryI</code>对象一样，<code>__NSDictionaryM_new</code>一开始也需要遍历<code>__NSDictionaryCapacities</code>数组。</p>
<p>遍历的目的，同样是为了找到一个<code>index</code>，这个<code>index</code>对应的<code>capacity</code>大于或者等于<code>count</code>。</p>
<pre><code class="language-objectivec">BOOL found = NO;
NSInteger index = 0;
for (; index &lt; 40; index++) {
  if (__NSDictionaryCapacity[i] &gt;= count) {
    found = YES;
    break;
  }
}

if (!found) {
  error "不能创建 NSDictionary";
}
</code></pre>
<p>从上面伪代码可以看到，创建<code>__NSDictionaryI</code>最多遍历<code>64</code>项，而这里只遍历<code>40</code>项。</p>
<p>有了<code>index</code>，就可以从<code>__NSDictionarySizes</code>数组中，得到要创建的字典的<code>size</code>。</p>
<pre><code class="language-objectivec">NSUInteger size = __NSDictionarySizes[index];
</code></pre>
<p>有了要创建字典的<code>size</code>，接下来就要创建<code>__NSDictionaryM</code>对象:</p>
<pre><code class="language-objectivec">__NSDictionaryM *dictM = __CFAllocateObject(__NSDictionaryM.class, 0);
</code></pre>
<p>还记得创建<code>__NSDictionaryI</code>的代码吗?</p>
<pre><code class="language-objectivec">__NSDictionaryI *dictI = __CFAllocateObject(__NSDictionaryM.class, size * 8 * 2);
</code></pre>
<p>可以看到，在创建<code>__NSDictionaryM</code>对象时，并没有传入<code>size</code>信息。</p>
<p>这就是说，<code>key-value</code>对，不是保存在<code>__NSDictionaryM</code>本身中。</p>
<p>这个很好理解。</p>
<p>因为<code>__NSDictionaryM</code>可以动态的增加<code>key-value</code>对，而不像<code>__NSDictionaryI</code>一样，创建好之后就不能再变化了。</p>
<p>既然<code>__NSDictionaryM</code>的<code>key-value</code>对不存储在自身，那么肯定存在堆上的另外地方。</p>
<p><code>malloc_type_calloc</code>方法正是用来分配这块内存的。</p>
<p><code>malloc_type_calloc</code>的方法声明如下：</p>
<pre><code class="language-c">void *malloc_type_calloc(size_t num_items, size_t size malloc_type_id_t type_id);
</code></pre>
<p><code>__NSDictionaryM_new</code>内部调用<code>malloc_type_calloc</code>的方式为:</p>
<pre><code class="language-c">void *storage = malloc_type_calloc(1, size * 8 * 2, 0x8448092b);
</code></pre>
<p>从代码可以看到，<code>malloc_type_calloc</code>创建了<code>1</code>个<code>item</code>，这个<code>item</code>的大小是<code>size * 8 * 2</code>。</p>
<p>毫无疑问，创建出来的<code>storage</code>正是用来存储<code>key-value</code>对的。</p>
<p><code>storage</code>指针存储在<code>__NSDictionaryM</code>对象中，内存布局如下:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250603024818220-560135532.png" alt="image" loading="lazy"></p>
<p>从上面的内存布局图可以看到，创建的存储区域分位<code>2</code>个数组。</p>
<p><code>key-value</code>对中的<code>key</code>存储在第<code>1</code>个数组中。</p>
<p><code>key-value</code>对中的<code>value</code>存储在第<code>2</code>个数组中。</p>
<p>为了存储<code>key-value</code>对，会遍历<code>__NSDictionaryM_new</code>函数的<code>keys</code>数组参数。</p>
<p>针对<code>keys</code>数组中的每一个<code>key</code>，计算其<code>hash</code>值。</p>
<pre><code class="language-objectivec">for (NSInteger i = 0; i &lt; count; i++) {
  ObjectType key = keys[i];
  NSUInteger hashValue = [key hash];
}
</code></pre>
<p>计算出<code>hash</code>值之后，对其进行取余计算，取余的结果作为<code>storage.keys</code>数组中的索引:</p>
<pre><code class="language-objectivec">for (NSInteger i = 0; i &lt; count; i++) {
  ObjectType key = keys[i];
  NSUInteger hashValue = [key hash];
  NSInteger index = hashValue % size;
}
</code></pre>
<p>有了这个索引<code>index</code>，就可以读取<code>storage.keys</code>数组中的值:</p>
<pre><code class="language-objectivec">for (NSInteger i = 0; i &lt; count; i++) {
  ObjectType key = keys[i];
  NSUInteger hashValue = [key hash];
  NSInteger index = hashValue % size;
  ObjectType oldKey = storage.keys[index];
}
</code></pre>
<p><code>oldKey</code>的值会有<code>3</code>种情形。</p>
<p>第<code>1</code>种情形，是<code>oldKey</code>的值为<code>nil</code>，说明这个位置之前没有值，可以放心将<code>key-value</code>对存入:</p>
<pre><code class="language-objectivec">for (NSInteger i = 0; i &lt; count; i++) {
  ObjectType key = keys[i];
  Objecttype value = values[i];
  NSUInteger hashValue = [key hash];
  NSInteger index = hashValue % size;
  ObjectType oldKey = storage.keys[index];
  if (oldKey == nil) {
    storage.keys[index] = [key copyWithZone:nil];
    storage.values[index] = value;
  }
}
</code></pre>
<p>上面伪代码需要注意的时，存储<code>key</code>是，调用了<code>copyWithZone:</code>方法。</p>
<p>因此，要做字典的<code>Key</code>，必须遵循<code>copy</code>协议。</p>
<p>在<code>__NSDictionaryM</code>对象上，有<code>25 bit</code>记录存储的<code>key-value</code>对个数。</p>
<p>在这种情形下，这个值会加<code>1</code>。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250603024844166-1180554496.png" alt="image" loading="lazy"></p>
<p>第<code>2</code>种情形，是<code>oldKey</code>的值为<code>___NSDictionaryM_DeletedMarker</code>。</p>
<p><code>___NSDictionaryM_DeletedMarker</code>是一个特殊的对象，它是一个<code>NSObject</code>：</p>
<pre><code class="language-c"> 0x18052c7ac &lt;+280&gt;: add    x21, x21, #0x420 ; ___NSDictionaryM_DeletedMarker
0x18052c7b0 &lt;+284&gt;: ldr    x8, [sp, #0x30]
</code></pre>
<p>在<code>Xcode</code>的<code>lldb</code>控制台上输出:</p>
<pre><code class="language-c">(lldb) po $x21
&lt;NSObject: 0x1e3db2420&gt;
</code></pre>
<p>有关<code>__NSDictionaryM_DeletedMarker</code>在介绍<code>removeObjectForKey:</code>方法时会继续介绍。</p>
<p>此时，如果<code>oldKey</code>是一个<code>__NSDictionaryM_DeletedMarker</code>，那么就顺着<code>storage.keys</code>数组当前的位置往前继续查找，直到查找完<code>storage.keys</code>数组中的所有位置。</p>
<p>如果查找过程中找到了一个<code>oldKey</code>为<code>nil</code>的位置，那么就将<code>key-value</code>对放到这个位置。</p>
<p>同时，<code>__NSDictionaryM</code>对象中，记录存储<code>key-value</code>对个数的值加<code>1</code>。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250603024913699-1456981811.png" alt="image" loading="lazy"></p>
<p>如果遍历的过程中，找到了一个<code>oldKey</code>是一个普通对象，那么就是情形<code>3</code>了。</p>
<p>第<code>3</code>种情形，如果<code>oldKey</code>是一个普通的对象，那么就检测<code>key</code>和<code>oldKey</code>是否是同一个对象，或者它们的<code>isEqual</code>方法是否相等:</p>
<pre><code class="language-objectivec">key == oldKey || [oldKey isEqual:key]
</code></pre>
<p>如果它们是同一个对象，或者<code>isEqual</code>方法相等，那么将<code>value</code>直接覆盖<code>oldKey</code>对应的<code>oldValue</code>值。</p>
<p>注意，此时<code>__NSDictionaryM</code>对象中，记录存储<code>key-value</code>对个数的值不会有变化。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250603024928777-829582138.png" alt="image" loading="lazy"></p>
<p>如果<code>key</code>和<code>oldKey</code>既不是同一个对象，它们的<code>isEqual</code>方法也不相等，那么就顺着当前<code>storage.keys</code>数组的位置往前找，直到遍历所有<code>storage.keys</code>数组的位置。</p>
<p>此时的情形和遇到<code>__NSDictionaryM_DeletedMarker</code>完全一样。</p>
<h2 id="22-内存布局">2.2 内存布局</h2>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250603024941143-435106059.png" alt="image" loading="lazy"></p>
<p><code>cow</code>是<code>Copy On Write</code>的缩写，再字典拷贝操作中有用，这里先不用关心。</p>
<h2 id="23-objectforkey">2.3 objectForKey:</h2>
<p>有了上面的内存布局，<code>objectForKey:</code>方法就很容易理解了。</p>
<p>首先根据参数<code>key</code>计算其<code>hash</code>值，并对<code>hash</code>值进行取余计算:</p>
<pre><code class="language-objectivec">NSUInteger hashValue = [key hash];
NSIndex index = hashValue % size;
</code></pre>
<p>那<code>size</code>是从哪里获取的呢？</p>
<p>从上面内存布局图可以知道，<code>__NSDictionaryM</code>对象有<code>6 bit</code>记录<code>size</code>的索引。</p>
<p>有了这个索引，就可以轻松的从<code>__NSDictionarySizes</code>数组中获取到对应的<code>size</code>值了。</p>
<p>通过<code>hash</code>值计算出<code>index</code>后，将这个<code>index</code>作为<code>storage.keys</code>数组的索引，<br>
读取一个值<code>candidateKey</code>。</p>
<p>此时也有<code>3</code>种情形。</p>
<p>情形<code>1</code>，如果<code>candidateKey</code>的值是<code>nil</code>，说明这个<code>key</code>在字典中没有对应的<code>value</code>，直接返回<code>nil</code>。</p>
<p>情形<code>2</code>，如果<code>candidateKey</code>是一个<code>___NSDictionaryM_DeletedMarker</code>对象，那么就从<code>storage.keys</code>数组的当前位置顺序向前找，直到遍历完所有<code>storage.keys</code>中的位置。</p>
<p>如果遍历的过程中，找到了一个<code>candidateKey</code>是<code>nil</code>，那么就直接返回<code>nil</code>。</p>
<p>如果遍历的过程中，找到了一个普通对象，那么就是情形<code>3</code>了。</p>
<p>情形<code>3</code>，如果<code>candidateKey</code>是一个普通对象，那么就检测它们是否是同一个对象，或者<code>isEqual</code>方法是否相等:</p>
<pre><code class="language-objectivec">candidateKey == key || [candidateKey isEqual:key]
</code></pre>
<p>如果满足上面的条件，就直接将<code>candidateKey</code>对应的<code>value</code>返回。</p>
<p>如果不满足上面的条件，那么就从<code>storage.keys</code>数组的当前位置顺序向前找，直到遍历完所有<code>storage.keys</code>中的位置。</p>
<p>如果遍历完所有位置，都没有找到合适的<code>candidateKey</code>，那么就返回<code>nil</code>。</p>
<h2 id="24-setobjectforkey">2.4 setObject:forKey:</h2>
<p><code>setObject:forKey</code>方法首先根据参数<code>key</code>，计算其<code>hash</code>值。</p>
<p>根据<code>hash</code>值可以得到<code>storage.keys</code>数组中的索引，然后读取这个索引对应的值<code>oldKey</code>。</p>
<p>此时会有<code>3</code>种情形。</p>
<p>情形<code>1</code>，如果运气不错，<code>oldKey</code>为<code>nil</code>，那么说明这个位置没有被占用，直接将<code>key-value</code>对添加进去。</p>
<p>同时，<code>__NSDictionaryM</code>对象中记录存储<code>key-value</code>对个数的值会加<code>1</code>。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250603025003246-1702352445.png" alt="image" loading="lazy"></p>
<p>情形<code>2</code>，如果运气太差，<code>oldKey</code>是一个<code>___NSDictionaryM_DeletedMarker</code>，那么就从<code>storage.keys</code>数组的当前位置顺序向前找，直到遍历完所有<code>storage.keys</code>中的位置。</p>
<p>如果再查找的过程中，找到了一个没有被占用的位置，并不能直接将<code>key-value</code>对添加进去。</p>
<p>此时，需要判断查找的次数是否大于<code>16</code>次。</p>
<p>如果查找次数不大于<code>16</code>次，那么就直接添加<code>key-value</code>对:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250603025022871-1127042105.png" alt="image" loading="lazy"></p>
<p>如果大于<code>16</code>次，需要对整个<code>storage</code>数组进行重新哈希，避免频繁遇到<code>___NSDictionaryM_DeletedMarker</code>，造成频繁查找。</p>
<p>重新进行哈希，会创建新的<code>storage</code>数组，旧<code>storage</code>数组中的<code>___NSDictionaryM_DeletedMarker</code>不会存到新<code>storage</code>数组中。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250603025034493-143931050.png" alt="image" loading="lazy"></p>
<p>从图中可以看到，重新哈希之后，新<code>storage</code>数组中的<code>key-value</code>对顺序，可能和旧<code>storage</code>数组中不一样。</p>
<p>重新哈希之后，需要重新计算参数<code>key</code>的<code>hash</code>值，重复上面的步骤。</p>
<p>如果查找过程中，<code>oldKey</code>是一个普通对象，那么就会遇到情形<code>3</code>。</p>
<p>情形<code>3</code>，如果<code>oldKey</code>是一个普通对象，那么就检测<code>oldKey</code>与<code>key</code>是否是同一个对象，或者它们的<code>isEqual</code>方法是否相等:</p>
<pre><code class="language-objectivec">oldKey == key || [oldKey isEqual:key]
</code></pre>
<p>如果满足条件，直接将<code>oldKey</code>对应的的值覆盖成参数<code>value</code>。</p>
<p>此时，<code>__NSDictionaryM</code>对象中记录存储<code>key-value</code>对的值不会变化。</p>
<p>如果不满足条件，也就是<code>oldKey</code>与参数<code>key</code>既不是同一个对象，它们的<code>isEqual</code>方法也不相等。</p>
<p>那么，就从<code>storage.keys</code>数组的当前位置顺序向前找，直到遍历完所有<code>storage.keys</code>中的位置。</p>
<p>整个流程和情形<code>2</code>完全一样。</p>
<p>需要注意的是，判断是否重新哈希的查找次数，是累计情形<code>2</code>和情形<code>3</code>的。</p>
<p>比如查找过程中遇到了一个<code>___NSDictionaryM_DeletedMarker</code>对象，那么查找计数加<code>1</code>。</p>
<p>紧接着查找，遇到了一个普通对象不满足:</p>
<pre><code class="language-objectivec">oldKey == key || [oldKey isEqual:key]
</code></pre>
<p>那么查找次数也要加<code>1</code>。</p>
<p>最后，如果遍历了当前<code>storage.keys</code>的所有位置，都没有找到合适的位置，那么将当前字典的<code>size</code>索引加<code>1</code>作为新的索引，从<code>__NSDictionarySizes</code>数组中得到一个新的<code>size</code>。</p>
<p>获取到新<code>size</code>之后，使用这个新<code>size</code>创建一个新的<code>storage</code>数组，然后将旧<code>storage</code>数组中的<code>key-value</code>对重新哈希到新<code>storage</code>数组中。</p>
<p>重新哈希之后，重头计算参数<code>key</code>的哈希值以及在新<code>storage</code>数组中的索引，重复上面步骤。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250603025049739-195920484.png" alt="image" loading="lazy"></p>
<p>由于新<code>storage</code>数组发生了变化，根据参数<code>key</code>计算的索引值也可能会发生变化。</p>
<p>需要注意的是，只要<code>set</code>操作成功，就会触发根据<code>__NSDictionaryM</code>对象中的<code>KVO</code>标志，触发<code>KVO</code>:</p>
<pre><code class="language-objectivec">[self willChangeValueForKey:key];
// set key-value 对
[self didChangeValueForKey:key];
</code></pre>
<h2 id="25-removeobjectforkey">2.5 removeObjectForKey:</h2>
<p>要进行删除操作，首先要看<code>storage</code>数组中，是否存在需要被删除的目标<code>targetKey</code>。</p>
<p>要成为<code>targetKey</code>，需要满足下面的条件:</p>
<pre><code class="language-objectivec">targetKey == key || [targetKey isEqual:key]
</code></pre>
<p>也就是说，目标<code>targetKey</code>要么和参数<code>key</code>是同一个对象，要么它们的<code>isEqual</code>方法相等。</p>
<p>要找到<code>targetKey</code>，会有一个查找过程。</p>
<p>查找过程和<code>setObject:forKey:</code>方法中的一样。</p>
<p>查找过程中也会记录查找的次数。</p>
<p>如果找到了<code>targetKey</code>，那么就使用<code>___NSDictionaryM_DeletedMarker</code>对象覆盖<code>targetKey</code>的值。</p>
<p>也就是说，<code>___NSDictionaryM_DeletedMarker</code>对象是删除操作产生的。</p>
<p>同时，需要将<code>targetKey</code>对应的<code>value</code>置<code>nil</code>。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250603025103479-1615616774.png" alt="image" loading="lazy"></p>
<p>但是，事情远远还没有结束。</p>
<p>删除完之后，还得看查找次数是否大于<code>16次</code>。</p>
<p>如果查找大于<code>16</code>次，需要将删除后的<code>storage</code>数组重新进行哈希操作。</p>
<p>重新哈希会产生新的<code>storage</code>数组，并且新的<code>storage</code>数组里面不会有<code>___NSDictionaryM_DeletedMarker</code>对象。</p>
<p>如果查找次数不超过<code>16</code>次，还需要检测被覆盖的<code>targetKey</code>所处位置的前一个位置的值。</p>
<p>如果前一个位置的值既不是一个<code>___NSDictionaryM_DeletedMarker</code>，也不是一个普通对象，而是<code>nil</code>，那么就会有一个清除<code>___NSDictionaryM_DeletedMarker</code>对象的操作。</p>
<p>清除过程从当前<code>targetKey</code>所处位置开始，向后遍历<code>storage.keys</code>数组，将碰到的<code>___NSDictionaryM_DeletedMarker</code>对象全部置成<code>nil</code>，直到遇到一个非<code>___NSDictionaryM_DeletedMarker</code>对象。</p>
<p>这个对象可以是<code>nil</code>，也可以是普通对象。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202506/489427-20250603025117804-230058639.png" alt="image" loading="lazy"></p>
<p>如果删除操作发生了，就会根据<code>__NSDictionaryM</code>对象中的<code>KVO</code>标志，触发<code>KVO</code>:</p>
<pre><code class="language-objectivec">[self willChangeValueForKey:key];
// 删除操作
[self didChangeValueForKey:key];
</code></pre>
<p>为什么删除的时候，需要一个<code>___NSDictionaryM_DeletedMarker</code>对象来进行占位呢？</p>
<p>因为有可能有<code>2</code>个<code>key</code>:<code>key1</code>和<code>key2</code>。</p>
<p>这<code>2</code>个<code>key</code>的<code>hash</code>值一样，但是<code>isEqual</code>方法不相等:</p>
<pre><code class="language-objectivec">[key1 hash] == [key2 hash] &amp;&amp; ![key1 isEqual:key2]
</code></pre>
<p>那么根据前面的分析，这<code>2</code>个<code>key</code>都可以通过<code>setObject:forKey:</code>的方法添加到字典中。</p>
<p>如果此时删除<code>key1</code>，直接将它在<code>storage.keys</code>数组中的所在位置置成<code>nil</code>，那么当在<code>key2</code>上调用<code>objectForKey:</code>就会出问题。</p>
<p>因为<code>key2</code>和<code>key1</code>的<code>hash</code>值一样，计算出来的<code>storage.keys</code>数组索引也一样。</p>
<p>此时由于这个索引对应的值为<code>nil</code>，就会错误的返回<code>nil</code>给用户，而不是正确的值。</p>
<h1 id="3-__nscfdictionary">3 __NSCFDictionary</h1>
<p><code>__NSCFDictionary</code>字典是一个很奇怪的可变字典。</p>
<p>虽然它是可变的，但是如果使用不正确，就会造成崩溃。</p>
<p>通过下面的方式可以创建一个<code>__NSCFDictionary</code>字典:</p>
<pre><code class="language-objectivec">// 创建一个可变字典
    CFMutableDictionaryRef mutableDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, NULL, NULL);
</code></pre>
<p>通过<code>Xcode</code>的<code>lldb</code>控制台输出可以看到:</p>
<pre><code class="language-c">(lldb) po [mutableDict class]
__NSCFDictionary
(lldb) p (BOOL)[mutableDict isKindOfClass:NSMutableDictionary.class]
(BOOL) YES
(lldb) p (BOOL)[mutableDict respondsToSelector:@selector(setObject:forKey:)]
(BOOL) YES
</code></pre>
<p>从控制台的输出可以看到，<code>__NSCFDictionary</code>字典是一个可变字典。</p>
<p>同时，这个可变字典也有<code>setObject:forKey:</code>方法。</p>
<p>下面我们对这个字典进行<code>copy</code>操作:</p>
<pre><code class="language-objectivec">NSDictionary *dict = [(__bridge NSMutableDictionary *)mutableDict copy];
</code></pre>
<p>按照道理，调用<code>copy</code>方法之后，应该返回的是一个非可变字典，但是如果打印<code>dict</code>的类型，发现仍然是<code>__NSCFDictionary</code>:</p>
<pre><code class="language-c">(lldb) po [dict class]
__NSCFDictionary
</code></pre>
<p>如果我们使用<code>isKindOfClass:</code>方法对其进行判断，然后强转成<code>NSMutableDictionary</code>执行<code>setObject:forKey:</code>方法，就会发生崩溃:</p>
<pre><code class="language-objectivec"> if ([dict isKindOfClass:NSMutableDictionary.class]) {
      [(NSMutableDictionary *)dict setObject:@"hh" forKey:@"cc"];
}
</code></pre>
<p>崩溃信息为:</p>
<pre><code class="language-c">Thread 1: "-[__NSCFDictionary setObject:forKey:]: mutating method sent to immutable object"
</code></pre>
<p>为了搞清楚原因，我们首先得从<code>CFDictionaryCreateMutable</code>函数入手。</p>
<p><code>CFDictionaryCreateMutable</code>函数的汇编代码如下:</p>
<pre><code class="language-c">CoreFoundation`CFDictionaryCreateMutable:
    ...
    // 1. 调用 __NSCFDictionaryCreateMutable 方法
    0x1803d53c4 &lt;+36&gt;:  bl     0x180529394               ; __NSCFDictionaryCreateMutable
    0x1803d53c8 &lt;+40&gt;:  mov    x19, x0
    0x1803d53cc &lt;+44&gt;:  cbnz   x0, 0x1803d5430           ; &lt;+144&gt;
    ...
    // 2. 调用 __CFDictionaryCreateGeneric
    0x1803d53dc &lt;+60&gt;:  bl     0x1803d52e8               ; __CFDictionaryCreateGeneric
  ...
  // 3. 设置 isa 为 __NSCFDictionary
  0x1803d540c &lt;+108&gt;: bl     0x18041e80c               ; _CFRuntimeSetInstanceTypeIDAndIsa
</code></pre>
<p>从汇编代码可以知道，<code>CFDictionaryCreateMutable</code>内部会调用<code>2</code>个函数创建字典。</p>
<p>首先调用<code>__NSCFDictionaryCreateMutable</code>方法，调用的方式为:</p>
<pre><code class="language-c">__NSCFDictionaryCreateMutable(kCFAllocatorDefault, 0, NULL, NULL);
</code></pre>
<p>这个方法的汇编代码如下:</p>
<pre><code class="language-c">CoreFoundation`__NSCFDictionaryCreateMutable:
    ...
    // 1. 检测第 3 个参数
    0x180529418 &lt;+132&gt;: add    x8, x8, #0x948            ; kCFTypeDictionaryValueCallBacks
    0x18052941c &lt;+136&gt;: cmp    x21, x9
    0x180529420 &lt;+140&gt;: b.ne   0x180529434               ; &lt;+160&gt;
    ...
    // 2. 检测第 4 个参数
    0x180529434 &lt;+160&gt;: adrp   x9, 407675
    0x180529438 &lt;+164&gt;: add    x9, x9, #0x918            ; kCFCopyStringDictionaryKeyCallBacks
    ...
    // 3. 熟悉的 __NSDictionaryM_new 方法
    0x18052946c &lt;+216&gt;: b      0x18052c694               ; __NSDictionaryM_new
    // 4. 返回 nil
    0x180529470 &lt;+220&gt;: mov    x0, #0x0                  ; =0 
    0x180529474 &lt;+224&gt;: ldp    x29, x30, [sp, #0x30]
    0x180529478 &lt;+228&gt;: ldp    x20, x19, [sp, #0x20]
    0x18052947c &lt;+232&gt;: ldp    x22, x21, [sp, #0x10]
    0x180529480 &lt;+236&gt;: ldp    x24, x23, [sp], #0x40
    0x180529484 &lt;+240&gt;: ret    
   ...
</code></pre>
<p>由于调用<code>__NSCFDictionaryCreateMutable</code>时，第<code>3</code>个参数和第<code>4</code>个参数传的都是<code>NULL</code>，因此程序直接跳转到代码注释<code>4</code>处执行。</p>
<p>也就是跳过了我们熟悉的<code>__NSDictionaryM_new</code>方法，失去了创建<code>OC</code>可变字典的机会，直接返回<code>nil</code>。</p>
<p>由于<code>__NSCFDictionaryCreateMutable</code>方法返回<code>nil</code>，<code>__CFDictionaryCreateGeneric</code>方法得到执行。</p>
<p><code>__CFDictionaryGeneric</code>方法的汇编代码如下:</p>
<pre><code class="language-c">CoreFoundation`__CFDictionaryCreateGeneric:
    ...
    // 1. 调用 CFBasicHashCreate 方法
    0x1803d5374 &lt;+140&gt;: bl     0x1804ebe30               ; CFBasicHashCreate
</code></pre>
<p>可以看到<code>__CFDictionaryGeneric</code>方法直接调用了<code>CFBasicHashCreate</code>方法。</p>
<p>这个方法会创建一个<code>CFBasichash</code>对象，是一个<code>CF</code>类型:</p>
<pre><code class="language-c">(lldb) po $x0
&lt;CFBasicHash 0x60000174c680 [0x1e3b3b680]&gt;{type = mutable dict, count = 0,
entries =&gt;
}
</code></pre>
<p>创建完毕之后，<code>CFDictionaryCreateMutable</code>方法在代码注释<code>3</code>处调用了<code>_CFRuntimeSetInstanceTypeIDAndIsa</code>方法。</p>
<p><code>_CFRuntimeSetInstanceTypeIDAndIsa</code>方法将<code>CFBasicHash</code>的<code>isa</code>设置成<code>__NSCFDictionary</code>。</p>
<p>这样这个<code>CF</code>对象就能桥接成<code>OC</code>对象了，但它本质上还是一个<code>CF</code>对象。</p>
<h2 id="31-copy">3.1 copy</h2>
<p>那为什么调用<code>copy</code>方法，返回的字典还是一个可变的呢？</p>
<p>原因是<code>__NSCFDictionary</code>重写了<code>copyWithZone:</code>方法。</p>
<p><code>__NSCFDictionary</code>的<code>copyWithZone:</code>方法汇编代码如下:</p>
<pre><code class="language-c">CoreFoundation`-[__NSCFDictionary copyWithZone:]:
    // 1. 检测当前对象是不是 OC 里面的可变字典
    0x1803e3d14 &lt;+32&gt;:  bl     0x1803d5e88               ; _CFDictionaryIsMutable
    0x1803e3d18 &lt;+36&gt;:  cbz    w0, 0x1803e3d30           ; &lt;+60&gt;
    ...
    // 2. 调用 CFDictionaryCreateCopy
    0x1803e3d2c &lt;+56&gt;:  b      0x1803d5448               ; CFDictionaryCreateCopy
</code></pre>
<p>代码注释<code>1</code>，检测当前对象是否是一个<code>OC</code>的可变字典。</p>
<p>很明显，当前对象是一个<code>CF</code>对象，只是能桥接为<code>OC</code>对象，因此检测不成立。</p>
<p>代码注释<code>2</code>，调用<code>CFDictionaryCreateCopy</code>方法进行拷贝。</p>
<p>这个方法拷贝出来的仍是一个<code>__NSCFDictionary</code>对象，其汇编代码如下:</p>
<pre><code class="language-c">CoreFoundation`CFDictionaryCreateCopy:
    ...
    // 1. 拷贝当前对象
    0x1803d5484 &lt;+60&gt;:  bl     0x1804ec1b8               ; CFBasicHashCreateCopy
    ...
    0x1803d54b0 &lt;+104&gt;: mov    x0, x19
    0x1803d54b4 &lt;+108&gt;: mov    w1, #0x12                 ; =18 
    // 2. 设置拷贝出来的对象的 isa 为 __NSCFDictionary
    0x1803d54b8 &lt;+112&gt;: bl     0x18041e80c               ; _CFRuntimeSetInstanceTypeIDAndIsa
</code></pre>
<h2 id="33-setobjectforkey">3.3 setObject:forKey:</h2>
<p>那为什么强转成可变字典，调用<code>setObject:forKey:</code>方法会发生崩溃呢？</p>
<p>下面就来看下<code>setObject:forKey:</code>方法的汇编代码:</p>
<pre><code class="language-c">CoreFoundation`-[__NSCFDictionary setObject:forKey:]:
     ...
    // 1. 检测当前对象是否是 OC 的可变字典
    0x1803e3968 &lt;+44&gt;:  bl     0x1803d5e88               ; _CFDictionaryIsMutable
    0x1803e396c &lt;+48&gt;:  tbz    w0, #0x0, 0x1803e39ec     ; &lt;+176&gt;
    ...
    0x1803e39ec &lt;+176&gt;: mov    x0, x19
    0x1803e39f0 &lt;+180&gt;: mov    x1, x21
    // 2. 检测失败会执行到这里
    0x1803e39f4 &lt;+184&gt;: bl     0x18053d8ac               ; -[__NSCFDictionary setObject:forKey:].cold.1
    ...
</code></pre>
<p>代码注释<code>1</code>，检测当前对象是否是<code>OC</code>的可变字典。</p>
<p>很明显，当前对象是一个<code>CF</code>类型，不是一个<code>OC</code>对象，检测失败。</p>
<p>代码注释<code>2</code>，检测失败后，会指向到这里。</p>
<p><code>-[__NSCFDictionary setObject:forKey:].cold.1</code>看名字就知道不简单。</p>
<p>它的汇编代码如下:</p>
<pre><code class="language-c">CoreFoundation`-[__NSCFDictionary setObject:forKey:].cold.1:
    ...
    0x18053d8c0 &lt;+20&gt;: add    x8, x8, #0xeb8            ; NSInternalInconsistencyException
    ...
    0x18053d8d4 &lt;+40&gt;: add    x1, x1, #0x700            ; @"%@: mutating method sent to immutable object"
    ...
</code></pre>
<p>从代码上看，正是这个函数抛出了异常。</p>
<h2 id="34-iskindofclass">3.4 isKindOfClass:</h2>
<p><code>__NSCFDictionary</code>字典虽然是一个可变字典，通过了<code>isKindOfClass:</code>方法检测，但是确不能强转着使用。</p>
<p>苹果文档中，关于<code>isKindOfClass:</code>对类簇的讨论，到这里，才变得十分具体:</p>
<blockquote>
<p>Be careful when using this method on objects represented by a class cluster. Because of the nature of class clusters, the object you get back may not always be the type you expected. If you call a method that returns a class cluster, the exact type returned by the method is the best indicator of what you can do with that object</p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.45292737597916666" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-03 03:31">2025-06-03 02:55</span>&nbsp;
<a href="https://www.cnblogs.com/chaoguo1234">chaoguo1234</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18907877);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18907877', targetLink: 'https://www.cnblogs.com/chaoguo1234/p/18907877', title: 'NSMutableDictionary 的内存布局' })">举报</a>
</div>
        