
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lori/p/18715174" title="发布于 2025-02-14 13:31">
    <span role="heading" aria-level="2">keycloak~认证与校验使用说明</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="主要内容">主要内容</h3>
<ul>
<li>密码认证</li>
<li>授权码认证 <code>哪个client申请的code，使用哪个client获取token</code></li>
<li>客户端认证 <code>在kc开通了服务端帐号之后，可通过client_id和client_secret来获取token，与用户无关，无刷新token机制</code></li>
<li>自动触发社区认证 <code>当用户在社区网站上登录后，访问这个地址可自动登录法宝</code></li>
<li>验证token是否在线 <code>可使用任意client来验证所有token的在线性</code></li>
<li>refresh_token刷新token <code>哪个client生成的token，就用哪个client去刷新</code></li>
<li>登出/注销 <code>官方post方式和浏览器302方式</code></li>
</ul>
<h3 id="密码认证">密码认证</h3>
<ul>
<li>POST /auth/realms/your-realm/protocol/openid-connect/token</li>
<li>请求体 x-www-form-urlencoded</li>
</ul>
<pre><code>grant_type:password
username:test
password:123456
client_secret:ec0fd1c6-68b0-4c39-a9fa-c3be25c8ef01
client_id:democlient
</code></pre>
<ul>
<li>响应</li>
</ul>
<pre><code>{
    "access_token": "*.*.*",
    "expires_in": 3000,
    "refresh_expires_in": 1800,
    "refresh_token": "*.*.*",
    "token_type": "bearer",
    "not-before-policy": 1619512543,
    "session_state": "765969ec-94da-4edb-9dcb-e15ea3e0ad3b",
    "scope": "roles email profile"
}
</code></pre>
<h3 id="授权码认证">授权码认证</h3>
<h4 id="注意的几点">注意的几点</h4>
<ul>
<li>code时的redirect_uri和authorization_code的需要是一致的，不一致的错误</li>
</ul>
<pre><code>{
    "error": "invalid_grant",
    "error_description": "redirect_uri error"
}
</code></pre>
<ul>
<li>code时的client_id和client_secret和authorization_code的需要是一致的，不一致的错误，<code>这块我已经修改了源码，去掉了这个限制</code><br>
{<br>
"error": "invalid_grant",<br>
"error_description": "Auth error"<br>
}</li>
<li>code的组成<br>
它由3部分组成，中间使用.分割，第一部分是UUID，第二部分是用户会话ID【session_state】，第三部分是客户端ID，例如：</li>
</ul>
<pre><code>5c33f9a2-cbf4-4804-a8ee-e2d076eda2d6.40be5301-f41b-4f0d-97e7-d2074db2801c.ff591897-7654-460e-9c19-8e8f92117768
</code></pre>
<h4 id="请求code">请求code</h4>
<ul>
<li>GET /auth/realms/your-realm/protocol/openid-connect/auth</li>
<li>QUERY</li>
</ul>
<pre><code>client_id:democlient
scope:openid
response_type:code
client_secret:ec0fd1c6-68b0-4c39-a9fa-c3be25c8ef01
redirect_uri:http://localhost:9090/callback
</code></pre>
<ul>
<li>跳转到kc的登录页，完成用户名和密码的登录</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250214131705871-2124774294.png" alt="" loading="lazy"></p>
<ul>
<li>登录成功之后，跳回callback删除，在url参数上带上了code</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250214131722284-830953184.png" alt="" loading="lazy"></p>
<h4 id="请求token">请求token</h4>
<ul>
<li>POST /auth/realms/your-realm/protocol/openid-connect/token</li>
<li>请求体 x-www-form-urlencoded</li>
</ul>
<pre><code>grant_type:authorization_code
code:68058719-add6-4b40-ab96-8e71af03827a.7a31b1a9-c3e8-46d4-b8cc-345012fcf4a2.25e52f60-5991-43dd-9108-873f60af385d
client_id:democlient
client_secret:ec0fd1c6-68b0-4c39-a9fa-c3be25c8ef01
scope:openid
redirect_uri:http://localhost:9090/callback
</code></pre>
<ul>
<li>响应</li>
</ul>
<pre><code>{
    "access_token": "*.*.*",
    "expires_in": 3000,
    "refresh_expires_in": 1800,
    "refresh_token": "*.*.*",
    "token_type": "bearer",
    "id_token": "*.*.*",
    "not-before-policy": 1619660302,
    "session_state": "14812f50-b9f7-4cee-be56-bf9bef5c961a",
    "scope": "openid roles email profile"
}
</code></pre>
<h3 id="客户端认证">客户端认证</h3>
<p>客户端认证，与用户无关，主要保证向keycloak发起的请求，来自合法的client即可(由keycloak颁发的client)</p>
<ul>
<li>POST /auth/realms/your-realm/protocol/openid-connect/token</li>
<li>请求 <code>x-www-form-urlencoded</code></li>
<li>参数</li>
</ul>
<pre><code>grant_type:client_credentials
client_secret:912ecc47-60b1-4dd4-8f62-c7745c293cab
client_id:kce
</code></pre>
<ul>
<li>注意，需要在keycloak客户端配置开启<code>服务账号</code></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250214131757806-1874120347.png" alt="" loading="lazy"></p>
<ul>
<li>如果没有开启<code>服务账号</code>，将出现下面异常</li>
</ul>
<pre><code>{
    "error": "unauthorized_client",
    "error_description": "Client not enabled to retrieve service account"
}
</code></pre>
<h3 id="自动触发社区认证">自动触发社区认证</h3>
<blockquote>
<p>carsi中出现的东西，院校希望直接通过固定的uri实现社区登录，故开发这个功能</p>
</blockquote>
<ul>
<li>地址：GET <a href="https://kc.democlient.com/auth/realms/your-realm/protocol/openid-connect/auth?scope=openid&amp;response_type=code&amp;client_id=carsi-auto&amp;redirect_uri=https://www.baidu.com" target="_blank" rel="noopener nofollow">https://kc.democlient.com/auth/realms/your-realm/protocol/openid-connect/auth?scope=openid&amp;response_type=code&amp;client_id=carsi-auto&amp;redirect_uri=https://www.baidu.com</a></li>
<li>首先，需要在配置<code>Authentication Flows</code>中的brower中的社区登录的有限级最高，我们可以复制一个brower认证流，在新流上修改,用户密码认证步骤关闭，也可以删除</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250214131815276-2120586075.png" alt="" loading="lazy"></p>
<ul>
<li>这个里的重定向认证使用的认证流是carsi</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250214131828100-186825686.png" alt="" loading="lazy"></p>
<ul>
<li>其次，需要新添加客户端，专门用来发送社区自动认证请求的，如<code>carsi-auto</code>，或者配置客户端的自定义认证方式</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250214131847982-567373247.png" alt="" loading="lazy"></p>
<ul>
<li>最后，测试一下，你可以看到，通过这个地址，可以唤起社区登录，最后回调到我们OIDC认证上来</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250214131931554-1989944256.png" alt="" loading="lazy"></p>
<h3 id="验证token是否在线">验证token是否在线</h3>
<blockquote>
<p>是否触发了keycloak的logout接口，如果触发了，那token将被删除，在线状态active为false，如果不希望提供client_secret参数，也可以通过<code>/auth/realms/your-realm/protocol/openid-connect/userinfo</code>接口来判断token是否有效，httpcode为401表示token失效.</p>
</blockquote>
<ul>
<li>使用场景：a客户端在kc申请的token，可以在b客户端调用kc的接口去校验它的合法性</li>
<li>POST /auth/realms/your-realm/protocol/openid-connect/token/introspect</li>
<li>请求体 x-www-form-urlencoded</li>
</ul>
<pre><code>token:*.*.*
client_id:democlient
client_secret:ec0fd1c6-68b0-4c39-a9fa-c3be25c8ef01
</code></pre>
<ul>
<li>响应，状态码都是200，如果json体中active为false，表示已经离线</li>
</ul>
<pre><code>{
    "active": false
}
</code></pre>
<h3 id="refresh_token刷新token">refresh_token刷新token</h3>
<blockquote>
<p>注意，刷新token与客户端有关，自己客户端生产的access_token，只能由自己客户端去refresh_token刷新</p>
</blockquote>
<ul>
<li>POST /auth/realms/your-realm/protocol/openid-connect/token</li>
</ul>
<pre><code>grant_type:refresh_token
refresh_token:*.*.*
client_id:democlient
client_secret:ec0fd1c6-68b0-4c39-a9fa-c3be25c8ef01
</code></pre>
<ul>
<li>响应<br>
新的token对象</li>
</ul>
<pre><code>{
    "access_token": "*.*.*",
    "expires_in": 3000,
    "refresh_expires_in": 1800,
    "refresh_token": "*.*.*",
    "token_type": "bearer",
    "not-before-policy": 1621497420,
    "session_state": "405d25b0-5128-45ae-9934-953eecb79894",
    "scope": "roles profile"
}
</code></pre>
<h3 id="登出注销">登出/注销</h3>
<p>KC的登出是属于会话的登出，通过这个会话产生的所有token（一个会话可能对应多个不同client的token）都将会退出</p>
<blockquote>
<p>一般地，如果是前后不分享项目，应该还会清除自己网站的session会话，然后再去调用KC的接口</p>
</blockquote>
<ul>
<li>POST /auth/realms/your-realm/protocol/openid-connect/logout</li>
<li>请求体 x-www-form-urlencoded</li>
</ul>
<pre><code>refresh_token:*.*.*
client_id:democlient
client_secret:ec0fd1c6-68b0-4c39-a9fa-c3be25c8ef01
</code></pre>
<ul>
<li>响应</li>
</ul>
<pre><code>HttpCode为200或者204表示操作成功
</code></pre>
<ul>
<li>浏览器端可通过这个接口来实现<code>302浏览器跳转</code>方式的登出</li>
</ul>
<pre><code>GET /auth/realms/your-realm/sms/remove-sessions?redirect_uri={redirect_uri}
登出后，KC会跳转到redirectUri的页面
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p></p>
<div class="navgood">
<p>作者：仓储大叔，张占岭，<br>
荣誉：微软MVP<br>QQ：853066980</p>

<p><strong>支付宝扫一扫，为大叔打赏!</strong>
<br><img src="https://images.cnblogs.com/cnblogs_com/lori/237884/o_IMG_7144.JPG"></p>
</div>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03298049890740741" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-14 13:32">2025-02-14 13:31</span>&nbsp;
<a href="https://www.cnblogs.com/lori">张占岭</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18715174" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18715174);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18715174', targetLink: 'https://www.cnblogs.com/lori/p/18715174', title: 'keycloak~认证与校验使用说明' })">举报</a>
</div>
        