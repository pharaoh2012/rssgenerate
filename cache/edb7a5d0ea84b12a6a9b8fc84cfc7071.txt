
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiezhr/p/19049856" title="发布于 2025-08-21 08:32">
    <span role="heading" aria-level="2">别再被VO、BO、PO、DTO、DO绕晕！今天用一段代码把它们讲透</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>大家好，我是晓凡。</p>
<blockquote>
<p>前阵子晓凡的粉丝朋友面试，被问到“什么是VO？和DTO有啥区别？”</p>
<p>粉丝朋友：“VO就是Value Object，DTO就是Data Transfer Object……”</p>
<p>面试官点点头：“那你说说，一个下单接口里，到底哪个算VO，哪个算DTO？”</p>
<p>粉丝朋友有点犹豫了。</p>
</blockquote>
<p>回来后粉丝朋友痛定思痛，把项目翻了个底朝天，并且把面试情况告诉了晓凡，下定决心捋清楚了这堆 XO 的真实含义。<br>
于是乎，这篇文章就来了<br>
今天咱们就用一段“用户下单买奶茶”的故事，把 VO、BO、PO、DTO、DO 全部聊明白。看完保准你下次面试不卡壳，写代码不纠结。</p>
<hr>
<h3 id="一先放结论">一、先放结论</h3>
<blockquote>
<p>它们都是“为了隔离变化”而诞生的马甲</p>
</blockquote>
<table>
<thead>
<tr>
<th>缩写</th>
<th>英文全称</th>
<th>中文直译</th>
<th>出现位置</th>
<th>核心目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>PO</td>
<td>Persistent Object</td>
<td>持久化对象</td>
<td>数据库 ↔ 代码</td>
<td>一张表一行记录的直接映射</td>
</tr>
<tr>
<td>DO</td>
<td>Domain Object</td>
<td>领域对象</td>
<td>核心业务逻辑层</td>
<td>充血模型，封装业务行为</td>
</tr>
<tr>
<td>BO</td>
<td>Business Object</td>
<td>业务对象</td>
<td>应用/服务层</td>
<td>聚合多个DO，面向用例编排</td>
</tr>
<tr>
<td>DTO</td>
<td>Data Transfer Object</td>
<td>数据传输对象</td>
<td>进程/服务间</td>
<td>精简字段，抗网络延迟</td>
</tr>
<tr>
<td>VO</td>
<td>View Object</td>
<td>视图对象</td>
<td>控制层 ↔ 前端</td>
<td>展示友好，防敏感字段泄露</td>
</tr>
</tbody>
</table>
<p>一句话总结：<br>
<strong>PO 管存储，DO 管业务，BO 管编排，DTO 管网络，VO 管界面。</strong></p>
<p>下面上代码，咱们边喝奶茶边讲。</p>
<hr>
<h3 id="二业务场景">二、业务场景</h3>
<blockquote>
<p>用户下一单“芋泥波波奶茶”</p>
</blockquote>
<p>需求：</p>
<ol>
<li>用户选好规格（大杯、少冰、五分糖）。</li>
<li>点击“提交订单”，前端把数据发过来。</li>
<li>后端算价格、扣库存、落库，返回“订单创建成功”页面。</li>
</ol>
<p>整条链路里，我们到底需要几个对象？</p>
<hr>
<h3 id="三从数据库开始po">三、从数据库开始：PO</h3>
<blockquote>
<p>PO是<code>Persistent Object</code>的简写<br>
PO 就是“一行数据一个对象”，字段名、类型和数据库保持一一对应，不改表就不改它。</p>
</blockquote>
<pre><code class="language-java">// 表：t_order
@Data
@TableName("t_order")
public class OrderPO {
    private Long id;          // 主键
    private Long userId;      // 用户ID
    private Long productId;   // 商品ID
    private String sku;       // 规格JSON
    private BigDecimal price; // 原价
    private BigDecimal payAmount; // 实付
    private Integer status;   // 订单状态
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
}
</code></pre>
<p>注意：PO 里<strong>绝不能出现业务方法</strong>，它只是一个“数据库搬运工”。</p>
<hr>
<h3 id="四核心业务do">四、核心业务：DO</h3>
<blockquote>
<p>DO 是“有血有肉的对象”，它把业务规则写成方法，让代码自己说话。</p>
</blockquote>
<pre><code class="language-java">// 领域对象：订单
public class OrderDO {

    private Long id;
    private UserDO user;      // 聚合根
    private MilkTeaDO milkTea; // 商品
    private SpecDO spec;      // 规格
    private Money price;      // Money是值对象，防精度丢失
    private OrderStatus status;

    // 业务方法：计算最终价格
    public Money calcFinalPrice() {
        // 会员折扣
        Money discount = user.getVipDiscount();
        // 商品促销
        Money promotion = milkTea.getPromotion(spec);
        return price.minus(discount).minus(promotion);
    }

    // 业务方法：下单前置校验
    public void checkBeforeCreate() {
        if (!milkTea.hasStock(spec)) {
            throw new BizException("库存不足");
        }
    }
}
</code></pre>
<p>DO 可以引用别的 DO，形成聚合根。它不关心数据库，也不关心网络。</p>
<hr>
<h3 id="五面向用例bo">五、面向用例：BO</h3>
<blockquote>
<p>BO 是“场景大管家”，把多个 DO 攒成一个用例，常出现在 Service 层。</p>
</blockquote>
<pre><code class="language-java">@Service
public class OrderBO {

    @Resource
    private OrderRepository orderRepository; // 操作PO
    @Resource
    private InventoryService inventoryService; // RPC或本地
    @Resource
    private PaymentService paymentService;

    // 用例：下单
    @Transactional
    public OrderDTO createOrder(CreateOrderDTO cmd) {

        // 1. 构建DO
        OrderDO order = OrderAssembler.toDO(cmd);

        // 2. 执行业务校验
        order.checkBeforeCreate();

        // 3. 聚合逻辑：扣库存、算价格
        inventoryService.lock(order.getSpec());
        Money payAmount = order.calcFinalPrice();

        // 4. 落库
        OrderPO po = OrderAssembler.toPO(order, payAmount);
        orderRepository.save(po);

        // 5. 返回给前端需要的数据
        return OrderAssembler.toDTO(po);
    }
}
</code></pre>
<p>BO 的核心是<strong>编排</strong>，它把 DO、外部服务、PO 串成一个完整的业务动作。</p>
<hr>
<h3 id="六跨进程服务dto">六、跨进程/服务：DTO</h3>
<blockquote>
<p>DTO 是“网络快递员”，字段被压缩成最少，只带对方需要的数据。</p>
</blockquote>
<p>1）<strong>入口 DTO</strong>：前端 → 后端</p>
<pre><code class="language-java">@Data
public class CreateOrderDTO {
    @NotNull
    private Long userId;
    @NotNull
    private Long productId;
    @Valid
    private SpecDTO spec; // 规格
}
</code></pre>
<p>2）<strong>出口 DTO</strong>：后端 → 前端</p>
<pre><code class="language-java">@Data
public class OrderDTO {
    private Long orderId;
    private String productName;
    private BigDecimal payAmount;
    private String statusDesc;
    private LocalDateTime createTime;
}
</code></pre>
<p>DTO 的字段命名常带 UI 友好词汇（如 <code>statusDesc</code>），并且<strong>绝不暴露敏感字段</strong>（如 <code>userId</code> 在返回给前端时可直接省略）。</p>
<hr>
<h3 id="七最后一步vo">七、最后一步：VO</h3>
<blockquote>
<p>VO 是“前端专属快递”，字段可能二次加工，甚至带 HTML 片段。</p>
</blockquote>
<pre><code class="language-java">@Data
public class OrderVO {
    private String orderId; // 用字符串避免 JS long 精度丢失
    private String productImage; // 带 CDN 前缀
    private String priceText; // 已格式化为“￥18.00”
    private String statusTag; // 带颜色：green/red
}
</code></pre>
<p>VO 通常由前端同学自己写 TypeScript/Java 类，后端只负责给 DTO，再让前端 BFF 层转 VO。如果你用 Node 中间层或 Serverless，VO 就出现在那儿。</p>
<hr>
<h3 id="八一张图记住流转过程">八、一张图记住流转过程</h3>
<pre><code>前端页面
   │ JSON
   ▼
CreateOrderVO (前端 TS)
   │ 序列化
   ▼
CreateOrderDTO (后端入口)
   │ BO.createOrder()
   ▼
OrderDO (充血领域模型)
   │ 聚合、计算
   ▼
OrderPO (落库)
   │ MyBatis
   ▼
数据库
</code></pre>
<p>返回时反向走一遍：</p>
<pre><code>数据库
   │ SELECT
OrderPO
   │ 转换
OrderDTO
   │ JSON
OrderVO (前端 TS 渲染)
</code></pre>
<hr>
<h3 id="九常见疑问答疑">九、常见疑问答疑</h3>
<ol>
<li>
<p><strong>为什么 DO 和 PO 不合并？</strong><br>
数据库加索引、加字段不影响业务；业务改规则不改表结构。隔离变化。</p>
</li>
<li>
<p><strong>DTO 和 VO 能合并吗？</strong><br>
小项目可以，但一上微服务或多端（App、小程序、管理后台），立马爆炸。比如后台需要用户手机号，App 不需要，合并后前端会拿到不该看的数据。</p>
</li>
<li>
<p><strong>BO 和 Service 有什么区别？</strong><br>
BO 更贴近用例，粒度更粗。Service 可能细分读写、缓存等。命名随意，关键看团队约定。</p>
</li>
</ol>
<hr>
<h3 id="十一句话背下来">十、一句话背下来</h3>
<blockquote>
<p>数据库里叫 PO，业务里是 DO，编排靠 BO，网络走 DTO，前端看 VO。</p>
</blockquote>
<p>下次面试官再问，你就把奶茶故事讲给他听，保证他频频点头。</p>
<p>本期内容到这儿就结束了</p>
<p>我是晓凡，再小的帆也能远航</p>
<p>我们下期再见 ヾ(•ω•`)o (●'◡'●)</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/xiezhr/" target="_blank">程序员晓凡</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/xiezhr/p/19049856" target="_blank">https://www.cnblogs.com/xiezhr/p/19049856</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-21 08:32">2025-08-21 08:32</span>&nbsp;
<a href="https://www.cnblogs.com/xiezhr">程序员晓凡</a>&nbsp;
阅读(<span id="post_view_count">31</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19049856);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19049856', targetLink: 'https://www.cnblogs.com/xiezhr/p/19049856', title: '别再被VO、BO、PO、DTO、DO绕晕！今天用一段代码把它们讲透' })">举报</a>
</div>
        