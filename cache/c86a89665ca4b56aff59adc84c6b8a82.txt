<!----> <meta itemprop="headline" content="前端也要懂点k8s-上篇"> <meta itemprop="keywords" content="前端,Kubernetes"> <meta itemprop="datePublished" content="2025-05-03T11:19:44.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="去伪存真"> <meta itemprop="url" content="https://juejin.cn/user/598569647873805"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端也要懂点k8s-上篇
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/598569647873805/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    去伪存真
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-05-03T11:19:44.000Z" title="Sat May 03 2025 11:19:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-05-03
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    6,469
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><h3 data-id="heading-0">前言</h3>
<p>最近在采用Jenkins实现前端项目自动化部署功能，其中有一个步骤用到了k8s, 这一块知识令我感到比较陌生，看不懂配置文件里的语句含义，以及如何被外部的bash指令串联起来，刚好假期有时间，决定学习一下k8s。学完目标是学完之后要了解k8s常用的操作。现在我们进入今天的主题:</p>
<h2 data-id="heading-1">一、Kubernetes 简介</h2>
<p>Kubernetes（简称 K8s）是一个用于<strong>自动部署、扩展和管理容器化应用程序</strong>的开源系统。下图展示了Kubernetes集群的架构及其与外部系统的交互方式：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75697f0f9417479a8d3d1c3418f27b74~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y675Lyq5a2Y55yf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1751896988&amp;x-signature=LB66Yb6CPgRB0%2F33Mnuz1Bce6v4%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-2">1.1 外部系统（External Systems）</h3>
<ul>
<li>kubectl: 这是Kubernetes的命令行工具，用户可以通过它与Kubernetes API服务器进行交互，执行各种操作如创建、删除和更新资源。</li>
<li>CI/CD Systems: 持续集成/持续部署系统可以使用Kubernetes API来自动化应用的部署和管理。</li>
<li>Apps Use SDK to connect to API server: 应用程序可以使用SDK连接到Kubernetes API服务器，以实现更复杂的集成和自动化。</li>
</ul>
<h3 data-id="heading-3">1.2 Kubernetes 集群（Kubernetes Cluster）</h3>
<p>Kubernetes集群采用的是<strong>主从架构（Master-Slave Architecture）</strong> ，主要由两个角色组成：</p>
<ul>
<li><strong>控制平面（Control Plane）</strong> ：负责集群的整体管理和调度。</li>
<li><strong>工作节点（Worker Node）</strong> ：负责实际运行应用容器。</li>
</ul>
<h4 data-id="heading-4">1.2.1 控制平面（Control Plane）</h4>
<p>控制平面是 Kubernetes 的“大脑”，主要负责接收用户指令、调度任务、监控运行状态。它包含以下组件：</p>





























<table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td><strong>kube-apiserver</strong></td><td>Kubernetes API服务器，所有请求的统一入口，提供 HTTP REST 接口，处理认证、授权、通信等</td></tr><tr><td><strong>etcd</strong></td><td>分布式 Key-Value 数据库，用于持久化存储集群所有状态数据</td></tr><tr><td><strong>kube-scheduler</strong></td><td>调度器负责将新建 Pod 分配到合适的 Node</td></tr><tr><td><strong>kube-controller-manager</strong></td><td>控制器管理器执行各种控制逻辑，比如运行多个控制器(副本控制器（ReplicaSet）、节点控制器、Job控制器等)</td></tr><tr><td><strong>cloud-controller-manager</strong></td><td>云控制器管理器，管理与云服务平台的集成（如负载均衡、存储卷等）</td></tr></tbody></table>
<p>所有这些组件通常运行在 Master 节点上。在生产环境中，控制平面可以做高可用部署（即多个 Master 节点）：</p>
<ul>
<li>保证 apiserver 的可用性（通过负载均衡）</li>
<li>保证 etcd 的数据冗余与高一致性（通常部署 3 个及以上节点）</li>
<li>避免单点故障，增强容灾能力</li>
</ul>
<h4 data-id="heading-5">1.2.2 工作节点（Worker Node）</h4>
<p>每个 Node 是实际运行容器的机器（虚拟机或物理机），其核心组件包括：</p>





















<table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td><strong>kubelet</strong></td><td>负责与 apiserver 通信，接收任务并在本地启动 Pod</td></tr><tr><td><strong>kube-proxy</strong></td><td>维护服务与 Pod 之间的网络规则，实现负载均衡</td></tr><tr><td><strong>Container Runtime</strong></td><td>运行容器的实际引擎，如 Docker、containerd、CRI-O</td></tr></tbody></table>
<h4 data-id="heading-6">1.2.3 云提供商APIs</h4>
<p>Kubernetes可以通过云提供商APIs与云服务进行集成，例如负载均衡器、存储卷和身份认证等。这使得Kubernetes能够利用云平台提供的各种服务来增强其功能。</p>
<h3 data-id="heading-7">1.3 k8s和docker的关系?</h3>
<p>k8s和docker的用途都含有容器管理，初学者一般都搞不清楚两者之间的关系。可以理解为：<strong>Docker 负责造车，Kubernetes 负责调度车队跑起来并保持秩序</strong>。</p>

















<table><thead><tr><th>名称</th><th>定义</th></tr></thead><tbody><tr><td><strong>Docker</strong></td><td>是一个<strong>容器引擎</strong>，用于打包、分发和运行容器化应用。</td></tr><tr><td><strong>Kubernetes</strong></td><td>是一个<strong>容器编排平台</strong>，用于自动化管理大量容器的部署、调度、伸缩和维护。</td></tr></tbody></table>
<p><strong>Docker 管理单个容器，Kubernetes 管理容器的集群</strong>；它们各司其职，共同构成了现代云原生应用的基石。</p>






























<table><thead><tr><th>维度</th><th>Docker</th><th>Kubernetes</th></tr></thead><tbody><tr><td>类型</td><td>容器运行时</td><td>容器编排平台</td></tr><tr><td>是否依赖对方</td><td>不依赖</td><td>早期依赖 Docker，后期依赖 CRI 接口</td></tr><tr><td>管理粒度</td><td>单个容器</td><td>多个服务或容器组成的集群</td></tr><tr><td>适用场景</td><td>开发、测试、单机部署</td><td>企业级生产环境的集群部署</td></tr></tbody></table>
<h3 data-id="heading-8">1.4 工作流程</h3>
<ol>
<li>开发者通过 kubectl 提交 YAML 清单到 apiserver。</li>
<li>apiserver 验证请求，并将信息存储到 etcd。</li>
<li>scheduler 监听到新 Pod 创建请求，并根据调度算法分配到合适的 Node。</li>
<li>对应 Node 上的 kubelet 接收到任务，调用 Container Runtime 启动容器。</li>
<li>kube-proxy 设置好服务发现和访问规则，确保内部通信正常。</li>
</ol>
<h2 data-id="heading-9">二、搭建 Kubernetes 环境</h2>
<p>根据使用场景不同,k8s有三种搭建方式。三种搭建方式的优缺点如下：</p>





























<table><thead><tr><th>搭建方式</th><th>场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1. 使用 Minikube 或 kind</td><td>学习和开发</td><td>快速启动、资源占用少</td><td>非真实生产环境</td></tr><tr><td>2. 使用 kubeadm 自建集群</td><td>中小型生产环境或测试</td><td>可控性强、接近生产</td><td>配置复杂，需自行运维</td></tr><tr><td>3. 使用云厂商托管服务（如 ACK、GKE、EKS）</td><td>生产</td><td>简单可靠、高可用</td><td>成本较高、依赖厂商</td></tr></tbody></table>
<p>由于篇幅所限，本文只演示一下第一种搭建k8s环境的方式（以 macOS / Linux 为例）:</p>
<h3 data-id="heading-10">2.1 安装 kubectl（Kubernetes 命令行工具）</h3>
<pre><code class="hljs language-bash" lang="bash">curl -LO <span class="hljs-string">"https://dl.k8s.io/release/<span class="hljs-subst">$(curl -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl"</span>
<span class="hljs-built_in">chmod</span> +x kubectl
sudo <span class="hljs-built_in">mv</span> kubectl /usr/local/bin/
kubectl version --client
</code></pre>
<h3 data-id="heading-11">2.2 安装 Minikube</h3>
<pre><code class="hljs language-bash" lang="bash">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube
</code></pre>
<h3 data-id="heading-12">2.3 启动 Minikube 集群</h3>
<pre><code class="hljs language-bash" lang="bash">minikube start
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e4415c9ea2b4173b12876aabd40f935~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y675Lyq5a2Y55yf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1751896988&amp;x-signature=ezH4U6PnFBw1nW2wrkRyLzg0bl8%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-13">2.4 查看集群节点状态</h3>
<pre><code class="hljs language-bash" lang="bash">kubectl get nodes
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/529bbd74734f4d1f93d9896082b7f45c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y675Lyq5a2Y55yf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1751896988&amp;x-signature=7G0RraYDPaK55beL7Iw%2FlD4ACno%3D" alt="image.png" loading="lazy"></p>
<h2 data-id="heading-14">三、常用资源对象介绍</h2>
<p>Kubernetes 中资源种类很多，常见的有：</p>

































<table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Pod</td><td>最小部署单元</td></tr><tr><td>Deployment</td><td>部署与版本控制</td></tr><tr><td>Service</td><td>网络访问入口</td></tr><tr><td>ConfigMap / Secret</td><td>配置和密钥</td></tr><tr><td>PersistentVolume / Claim</td><td>存储</td></tr><tr><td>Namespace</td><td>命名空间管理</td></tr></tbody></table>
<h3 data-id="heading-15">3.1 Pod：最小部署单元</h3>
<h4 data-id="heading-16">3.1.1 什么是Pod？</h4>
<p>Pod 是 K8s 中最小的可调度单元。一个 Pod 包含一个或多个 <strong>容器（通常是 Docker 容器）</strong> ，这些容器共享：</p>
<ul>
<li>网络（IP 和端口空间）</li>
<li>存储（Volume 卷）</li>
<li>生命周期（被视为一个整体）</li>
</ul>
<p>Pod 的典型用途是运行一个应用或服务的一个实例。一个 Pod 运行一个容器（最常见场景）：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-pod</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.24</span>
      <span class="hljs-attr">ports:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>
</code></pre>
<p>这个 Pod 会启动一个 Nginx 容器，并暴露 80 端口。</p>
<h4 data-id="heading-17">3.1.2 Pod 生命周期</h4>
<p>Pod 的状态包括：</p>
<ul>
<li><code>Pending</code>: 等待调度资源</li>
<li><code>Running</code>: 正在运行</li>
<li><code>Succeeded</code>: 运行成功后退出</li>
<li><code>Failed</code>: 运行失败</li>
<li><code>Unknown</code>: 状态无法获取</li>
</ul>
<h4 data-id="heading-18">3.1.3 Pod的创建，查看与删除</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建</span>
kubectl apply -f nginx-pod.yaml
<span class="hljs-comment"># 查看所有pod</span>
kubectl get pods
<span class="hljs-comment"># 查看某个pod</span>
kubectl describe pod nginx-pod
<span class="hljs-comment"># 删除</span>
kubectl delete pod nginx-pod
</code></pre>
<p>上面给出的都是独立的pod的创建与管理方式，虽然你可以手动管理 Pod，但 <strong>更推荐使用 Deployment 控制器</strong> ，创建Pod，自动管理 Pod 的副本数量、自愈能力和升级策略。</p>
<h3 data-id="heading-19">3.2 Deployment：无状态应用的部署控制器</h3>
<p>Deployment 是 Kubernetes 中最常用的控制器之一，专门用于管理 <strong>无状态应用的生命周期</strong>。它确保你的 Pod 副本在集群中始终按预期运行，并具备以下功能：</p>
<ul>
<li>保证指定数量的 Pod 始终处于运行状态（副本控制）</li>
<li>支持应用的滚动升级和回滚</li>
<li>支持 declarative 式的配置和更新</li>
<li>自动重建失败的 Pod（具备自愈能力）</li>
</ul>
<h4 data-id="heading-20">3.2.1 典型 Deployment 示例</h4>
<p>说明：</p>
<ul>
<li><code>replicas</code>: 设置运行的 Pod 数量为 3</li>
<li><code>selector</code>: 用于匹配管理哪些 Pod</li>
<li><code>template</code>: 定义 Pod 的内容（镜像、端口等）</li>
</ul>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-nginx</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.24</span>
          <span class="hljs-attr">ports:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>
</code></pre>
<h4 data-id="heading-21">3.2.2 Deployment 的工作逻辑</h4>
<ul>
<li>寻找所有标签匹配 <code>selector.matchLabels</code> 的 Pod</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ce3bddf45c0b40818f93ef08e9726f5b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y675Lyq5a2Y55yf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1751896988&amp;x-signature=a7D9sJU6sRUNNWJ5jxOtCsdnoKs%3D" alt="image.png" loading="lazy"></p>
<ul>
<li>如果数量不足 <code>replicas</code>，则新建 Pod</li>
<li>如果数量过多，则删除多余的 Pod</li>
<li>如果标签相同但镜像等配置不同，则更新 Pod</li>
<li>Deployment 不直接控制 Pod，而是通过创建一个 ReplicaSet，再由 ReplicaSet 具体去创建 Pod，维护副本数量，做滚动更新。</li>
</ul>
<h4 data-id="heading-22">3.2.3 Deployment操作命令</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建 Deployment</span>
kubectl apply -f nginx-deploy.yaml
<span class="hljs-comment"># 查看状态</span>
kubectl get deployments
kubectl describe deployment nginx-deploy
<span class="hljs-comment"># 查看管理的 Pod</span>
kubectl get pods -l app=nginx
</code></pre>
<p>修改镜像并滚动升级，将nginx从1.24升级到1.25</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.25</span>

</code></pre>
<pre><code class="hljs language-basn" lang="basn"># 升级
kubectl apply -f nginx-deploy.yaml
# 查看历史记录
kubectl rollout history deployment nginx-deploy
# 回滚
kubectl rollout undo deployment nginx-deploy
</code></pre>
<h3 data-id="heading-23">3.3  Service：服务发现与负载均衡</h3>
<p>在 Kubernetes 中，<strong>Pod 是会变化的</strong> —— 当 Deployment 滚动更新、Pod 重启时，Pod 的 IP 会变。所以不能依赖 Pod 的 IP 地址来通信。</p>
<p>这就是 Service 出场的原因，它为一组 Pod 提供了一个 <strong>稳定的网络访问入口</strong>，实现了：</p>
<ul>
<li><strong>服务发现</strong>（Pod 动态变动也能找到）</li>
<li><strong>负载均衡</strong>（多个 Pod 间自动分流请求）</li>
</ul>
<h4 data-id="heading-24">3.3.1 Service实例</h4>
<p>实例：为 nginx Pod 暴露一个 Service</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span>  <span class="hljs-comment"># 匹配被管理的 Pod（Deployment 创建的）</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>          <span class="hljs-comment"># Service 对外暴露的端口</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span>    <span class="hljs-comment"># Pod 内部容器监听的端口</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span>       <span class="hljs-comment"># 集群内访问（默认）</span>
</code></pre>
<p>常见 Service 类型：</p>

























<table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>ClusterIP</td><td>默认类型，仅在集群内部通过虚拟 IP 访问</td></tr><tr><td>NodePort</td><td>将 Service 暴露在每个 Node 的某个端口，外部可以通过 IP:Port 访问</td></tr><tr><td>LoadBalancer</td><td>云环境下自动创建外部负载均衡器（阿里云、AWS 等）</td></tr><tr><td>ExternalName</td><td>把请求重定向到外部 DNS 域名</td></tr></tbody></table>
<h4 data-id="heading-25">3.3.2 Service 如何做服务发现？</h4>
<p>Kubernetes 内置 <strong>DNS 服务</strong>，会为每个 Service 分配一个 DNS 名称：
例如</p>
<pre><code class="hljs language-bash" lang="bash">http://nginx-service.default.svc.cluster.local
</code></pre>
<p>容器中的其他 Pod 只需用这个 DNS 名称就能访问 nginx 服务，完全不需要关心 Pod IP。</p>
<h4 data-id="heading-26">3.3.3 创建并访问 Service 示例</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建 Deployment</span>
kubectl apply -f nginx-deployment.yaml

<span class="hljs-comment"># 创建 Service</span>
kubectl apply -f nginx-service.yaml

<span class="hljs-comment"># 查看 Service IP 和端口：</span>
kubectl get svc

<span class="hljs-comment"># 在集群中访问 Service：</span>
curl http://nginx-service
</code></pre>
<h3 data-id="heading-27">3.4 Ingress</h3>
<p>在 Kubernetes 中，Ingress是一种 API 对象，用于管理外部用户如何通过 HTTP 或 HTTPS 访问集群内的服务（Service） 。简而言之，Ingress 提供了一种统一的方式，将域名或路径映射到集群中的服务上，并支持负载均衡、SSL 终端和基于路径/主机的路由。</p>
<h4 data-id="heading-28">3.4.1 为什么需要 Ingress？</h4>
<p>在没有 Ingress 的情况下，集群外部访问服务只能通过：</p>
<ul>
<li><strong>NodePort</strong>：每个 Service 暴露一个端口，访问地址为 <code>NodeIP:Port</code>，难管理。</li>
<li><strong>LoadBalancer</strong>：为每个服务申请一个云负载均衡器，成本高。</li>
<li><strong>Port-forward / kubectl proxy</strong>：临时调试用，不适合生产。</li>
</ul>
<p>而 Ingress 通过一个统一的入口，根据域名或路径来转发请求，成本低、配置灵活、可维护性强。Ingress 功能点如下:</p>

































<table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>域名路由</td><td>根据主机名将请求转发到不同服务</td></tr><tr><td>路径路由</td><td>根据路径将请求转发到不同服务</td></tr><tr><td>HTTPS 支持</td><td>可以配置证书，实现 TLS 终端</td></tr><tr><td>负载均衡</td><td>多个 Pod 间自动负载均衡</td></tr><tr><td>支持重定向与重写</td><td>可以配置 URL 重定向或路径重写</td></tr><tr><td>身份验证、限速等</td><td>借助 Ingress Controller 插件可实现更高级功能</td></tr></tbody></table>
<h4 data-id="heading-29">3.4.2 组成结构</h4>
<p>Ingress 本身不直接处理请求，它依赖 <strong>Ingress Controller</strong> 来工作。常见 Ingress Controller:</p>





























<table><thead><tr><th>Controller 类型</th><th>说明</th></tr></thead><tbody><tr><td>Nginx</td><td>最流行的开源选择，支持多数功能</td></tr><tr><td>Traefik</td><td>轻量级、高性能，支持微服务和自动发现</td></tr><tr><td>HAProxy</td><td>高性能、企业级选择</td></tr><tr><td>Istio Gateway</td><td>用于服务网格场景</td></tr><tr><td>AWS/GCP/ALB</td><td>云平台原生负载均衡集成</td></tr></tbody></table>
<p>下面这张图展示了 Ingress 在 Kubernetes 中进行流量转发的完整架构流程</p>
<ol>
<li>
<p>用户访问 <code>example.com/web</code>；</p>
</li>
<li>
<p>Ingress 中定义了 <code>/web</code> 路径指向 <code>my-web</code> Service；</p>
</li>
<li>
<p>Ingress Controller（如 nginx-ingress）读取 Ingress 规则；</p>
</li>
<li>
<p>Ingress Controller 接收到请求后，将其转发给 <code>my-web</code> Service；</p>
</li>
<li>
<p>Service 查找符合条件的 Pod（例如标签为 <code>app=web</code>）；</p>
</li>
<li>
<p>请求最终到达 Pod，得到业务响应。</p>
<pre><code class="hljs language-lua" lang="lua">   +<span class="hljs-comment">--------------+</span>
   |   Internet   |
   +<span class="hljs-comment">------+-------+</span>
          |
  +<span class="hljs-comment">-------v--------+</span>
  | Ingress        |  ← 配置路由规则的资源
  | (定义规则)     |
  +<span class="hljs-comment">-------+--------+</span>
          |
 +<span class="hljs-comment">--------v---------+</span>
 | Ingress Controller| ← 实际负责转发流量
 | (如 Nginx, Traefik)|
 +<span class="hljs-comment">--------+---------+</span>
          |
    +<span class="hljs-comment">-----v------+</span>
    | Kubernetes |
    |  Services  |
    +<span class="hljs-comment">-----+------+</span>
          |
       +<span class="hljs-comment">--v--+</span>
       | Pod |
       +<span class="hljs-comment">-----+</span>
</code></pre>
</li>
</ol>
<h4 data-id="heading-30">3.4.3 配置一个简单的 Ingress</h4>
<p>Ingress 如何连接 Service？ 假设你有一个名为 <code>my-web</code> 的 Service，监听端口为 80：</p>
<p><code>service.yaml</code></p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-web</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">web</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span>
</code></pre>
<p>service.yaml对应的my-web-deployment.yaml配置如下:</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-web</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">web</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">web</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">web</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.24</span>
          <span class="hljs-attr">ports:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>
</code></pre>
<p>这个 Service 将流量从端口 80 转发到选中 Pod 的 8080 端口。Ingress 配置如下：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">web-ingress</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">rules:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">example.com</span>
      <span class="hljs-attr">http:</span>
        <span class="hljs-attr">paths:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/web</span>
            <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
            <span class="hljs-attr">backend:</span>
              <span class="hljs-attr">service:</span>
                <span class="hljs-attr">name:</span> <span class="hljs-string">my-web</span>        <span class="hljs-comment"># 指向 Service 的名字</span>
                <span class="hljs-attr">port:</span>
                  <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>        <span class="hljs-comment"># 指向 Service 的 port 字段</span>
</code></pre>
<blockquote>
<p>当用户访问 <code>http://example.com/web</code> 时：</p>
<ol>
<li>请求被 Ingress Controller 捕获；</li>
<li>根据 <code>/web</code> 路径匹配到规则；</li>
<li>将请求转发到 <code>my-web</code> Service；</li>
<li>Service 根据 selector 找到对应的 Pod（如 <code>app=web</code>）；</li>
<li>将请求转发给这些 Pod 的 <code>targetPort: 8080</code>。</li>
</ol>
</blockquote>
<h4 data-id="heading-31">3.4.4 配置 HTTPS Ingress</h4>
<p>通过如下命令创建了一个包含 TLS 证书的 Secret：这个 Secret 包含公钥证书（CRT）和私钥（KEY），名称为 <code>tls-secret</code>，位于 <code>default</code> 命名空间中.</p>
<pre><code class="hljs language-bash" lang="bash">kubectl create secret tls tls-secret \
  --cert=example.com.crt \
  --key=example.com.key \
  -n default
</code></pre>
<p>在Ingress 配置启用 HTTPS</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">web-ingress</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="hljs-string">/</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">tls:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">example.com</span>
      <span class="hljs-attr">secretName:</span> <span class="hljs-string">tls-secret</span>  <span class="hljs-comment"># 指向我们预先创建的 TLS Secret</span>

  <span class="hljs-attr">rules:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">example.com</span>
      <span class="hljs-attr">http:</span>
        <span class="hljs-attr">paths:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span>
            <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span>
            <span class="hljs-attr">backend:</span>
              <span class="hljs-attr">service:</span>
                <span class="hljs-attr">name:</span> <span class="hljs-string">my-web</span>
                <span class="hljs-attr">port:</span>
                  <span class="hljs-attr">number:</span> <span class="hljs-number">80</span>

</code></pre>
<p>效果验证：</p>
<ul>
<li>
<p>本地配置 DNS：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"INGRESS_IP  example.com"</span> | sudo <span class="hljs-built_in">tee</span> -a /etc/hosts
</code></pre>
<p><code>INGRESS_IP</code> 是你的 Ingress Controller 的外网 IP 地址。</p>
</li>
<li>
<p>浏览器访问：</p>
<pre><code class="hljs language-bash" lang="bash">https://example.com/
</code></pre>
</li>
</ul>
<p>若配置无误，将自动跳转并看到你部署的 nginx 页面。</p>
<h3 data-id="heading-32">3.5 ConfigMap 与 Secret</h3>
<p>在 Kubernetes 中，<strong>ConfigMap 和 Secret</strong> 是用于<strong>配置管理</strong>的两种核心资源类型，它们用于将配置和敏感数据（如密码、API 密钥）与容器解耦，让你的应用部署更加灵活、安全。</p>



































<table><thead><tr><th>特性</th><th>ConfigMap</th><th>Secret</th></tr></thead><tbody><tr><td>用途</td><td>存储普通配置（不敏感）</td><td>存储敏感数据（如密码、Token）</td></tr><tr><td>数据是否加密</td><td>❌ 否（明文）</td><td>✅ 是（Base64 编码，适合加密传输）</td></tr><tr><td>可挂载到 Pod</td><td>✅ 是</td><td>✅ 是</td></tr><tr><td>使用方式</td><td>环境变量、挂载为文件、命令行参数等</td><td>环境变量、挂载为文件、命令行参数等</td></tr><tr><td>推荐用途</td><td>配置文件、环境变量、命令参数等</td><td>密码、证书、数据库密钥、Token 等</td></tr></tbody></table>
<h4 data-id="heading-33">3.5.1 ConfigMap：存储非敏感配置</h4>
<h5 data-id="heading-34">创建 ConfigMap 的方式</h5>
<p>方法 1：使用 <code>kubectl</code> 命令行创建</p>
<pre><code class="hljs language-bash" lang="bash">kubectl create configmap my-config --from-literal=color=blue --from-literal=lang=zh
</code></pre>
<p>方法 2：使用 YAML 创建</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">color:</span> <span class="hljs-string">blue</span>
  <span class="hljs-attr">lang:</span> <span class="hljs-string">zh</span>
</code></pre>
<h5 data-id="heading-35">使用 ConfigMap 的方式</h5>
<p>方法 1：作为环境变量注入容器</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">env:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">COLOR</span>
    <span class="hljs-attr">valueFrom:</span>
      <span class="hljs-attr">configMapKeyRef:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
        <span class="hljs-attr">key:</span> <span class="hljs-string">color</span>
</code></pre>
<p>方法 2：挂载为文件</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">volumeMounts:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
    <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/config</span>
<span class="hljs-attr">volumes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span>
    <span class="hljs-attr">configMap:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">my-config</span>
</code></pre>
<h4 data-id="heading-36">3.5.2 Secret：存储敏感配置</h4>
<p>Secret 的数据会以 Base64 编码存储（可以结合加密存储后端实现更高安全性）。</p>
<h5 data-id="heading-37">创建 Secret 的方式</h5>
<p>方法 1：命令行直接创建</p>
<pre><code class="hljs language-bash" lang="bash">kubectl create secret generic my-secret --from-literal=password=123456
</code></pre>
<p>方法 2：YAML 文件创建（注意 Base64 编码）</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-secret</span>
<span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span>
<span class="hljs-attr">data:</span>
  <span class="hljs-attr">password:</span> <span class="hljs-string">MTIzNDU2</span>  <span class="hljs-comment"># Base64 编码后的 "123456"</span>
</code></pre>
<p>可以用如下命令手动编码：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">"123456"</span> | <span class="hljs-built_in">base64</span>
</code></pre>
<h5 data-id="heading-38">使用 Secret 的方式</h5>
<p>方法 1：作为环境变量注入</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">env:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DB_PASSWORD</span>
    <span class="hljs-attr">valueFrom:</span>
      <span class="hljs-attr">secretKeyRef:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">my-secret</span>
        <span class="hljs-attr">key:</span> <span class="hljs-string">password</span>
</code></pre>
<p>方法 2：挂载为文件</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">volumeMounts:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">secret-volume</span>
    <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/secret</span>
<span class="hljs-attr">volumes:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">secret-volume</span>
    <span class="hljs-attr">secret:</span>
      <span class="hljs-attr">secretName:</span> <span class="hljs-string">my-secret</span>
</code></pre>
<h3 data-id="heading-39">3.6 PersistentVolumeClaim</h3>
<p>PersistentVolumeClaim（PVC） 是一种资源对象，用于申请持久化存储空间（PersistentVolume，PV） 。简单来说，它是 Pod 与底层存储之间的桥梁，用户通过 PVC 来请求磁盘，而不是直接绑定硬盘资源。</p>
<h4 data-id="heading-40">3.6.1 什么是 PersistentVolume 与 PersistentVolumeClaim？</h4>
<ul>
<li><strong>PersistentVolume（PV）</strong> ：由管理员创建或自动创建的<strong>存储资源</strong>，类似“硬盘”。</li>
<li><strong>PersistentVolumeClaim（PVC）</strong> ：用户申请使用 PV 的方式，类似“租用硬盘”。</li>
</ul>
<blockquote>
<p>🧩 类比理解：</p>
<ul>
<li><strong>PV = 房东提供的房子</strong></li>
<li><strong>PVC = 租客发出的租房申请</strong></li>
<li>Kubernetes 匹配 PVC 与 PV，实现租房动作</li>
</ul>
</blockquote>
<p>为什么需要 PVC？在容器运行时，容器内的数据是<strong>临时的（临时存储）</strong> ，容器重启或迁移后会丢失。如果需要保存数据库、文件上传等数据，就必须使用 PVC 来绑定到稳定的硬盘。</p>
<h4 data-id="heading-41">3.6.2 PVC 使用流程</h4>
<ul>
<li>管理员配置 StorageClass 或 PV</li>
<li>开发者在 Pod 中声明 PVC</li>
<li>系统自动匹配合适的 PV 给 PVC</li>
<li>Pod 使用 PVC 提供的存储挂载路径</li>
</ul>
<h4 data-id="heading-42">3.6.3 PVC 使用示例</h4>
<h5 data-id="heading-43">Step1：定义 PVC</h5>
<p>申请一个 1Gi 的存储空间</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pvc</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">accessModes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>      <span class="hljs-comment"># 只允许一个 Pod 挂载读写</span>
  <span class="hljs-attr">resources:</span>
    <span class="hljs-attr">requests:</span>
      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span>        <span class="hljs-comment"># 请求 1Gi 存储空间</span>
</code></pre>
<p>访问模式说明：</p>





















<table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>ReadWriteOnce</td><td>只能被单个 Node 上的一个 Pod 读写（最常用）</td></tr><tr><td>ReadOnlyMany</td><td>多个 Pod 可读，但不可写</td></tr><tr><td>ReadWriteMany</td><td>多个 Pod 可读写（需特定存储支持，如 NFS）</td></tr></tbody></table>
<h5 data-id="heading-44">Step 2：Pod 中使用 PVC</h5>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-with-pvc</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">containers:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>
      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>
      <span class="hljs-attr">volumeMounts:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">"/usr/share/nginx/html"</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">web-data</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">web-data</span>
      <span class="hljs-attr">persistentVolumeClaim:</span>
        <span class="hljs-attr">claimName:</span> <span class="hljs-string">my-pvc</span>
</code></pre>
<p>这样，Pod 就能把 <code>/usr/share/nginx/html</code> 目录的数据存储到持久化卷中。也可以用 PVC 搭配 StorageClass，让 K8s 自动向云厂商（如 AWS、GCP）动态创建磁盘资源，无需管理员手动创建 PV。</p>
<h3 data-id="heading-45">3.7 Namespace</h3>
<p><strong>Namespace（命名空间）</strong> 是一种用于对集群中的资源进行<strong>逻辑隔离和分组管理</strong>的机制。可以把它理解为集群中的「虚拟子集群」，用于将资源划分为多个相互独立的空间。并非所有的资源都可以用命名空间进行隔离。</p>

























<table><thead><tr><th>特性</th><th>是否作用于 Namespace</th></tr></thead><tbody><tr><td>Pod、Service</td><td>✅ 是，属于某个命名空间</td></tr><tr><td>Node、PV</td><td>❌ 否，全局资源</td></tr><tr><td>Role、Quota</td><td>✅ 是，作用于指定命名空间</td></tr><tr><td>ClusterRole</td><td>❌ 否，作用于全集群</td></tr></tbody></table>
<p>顺便说一下Node和Pod的区别：</p>



































<table><thead><tr><th>类目</th><th><strong>Node（节点）</strong></th><th><strong>Pod</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>集群中的一台工作机器（物理机或虚拟机）</td><td>Kubernetes 中可调度的最小计算单元（通常是一个或多个容器）</td></tr><tr><td><strong>层级关系</strong></td><td>Node 是运行 Pod 的宿主机</td><td>Pod 运行在 Node 上</td></tr><tr><td><strong>数量</strong></td><td>集群中通常只有少数几个 Node（如3个、5个）</td><td>可以调度成千上万个 Pod</td></tr><tr><td><strong>作用</strong></td><td>提供计算资源（CPU、内存、网络）</td><td>封装应用容器及其运行环境</td></tr><tr><td><strong>组成部分</strong></td><td>kubelet、kube-proxy、容器运行时（如 containerd）</td><td>一个或多个容器、共享网络和存储卷</td></tr></tbody></table>
<p>通俗理解<strong>Node 是宿舍楼</strong>，里面住着多个 <strong>Pod（宿舍间）</strong> 一个 Node 可以运行多个 Pod，但 Pod 不能脱离 Node 独立存在。</p>
<h4 data-id="heading-46">3.7.1 Namespace 有什么用？</h4>
<h5 data-id="heading-47">1. <strong>资源隔离</strong></h5>
<ul>
<li>每个 Namespace 里的资源彼此隔离，互不干扰。</li>
<li>比如你在 <code>dev</code> 和 <code>prod</code> 中分别部署了两个 <code>nginx</code>，它们不会冲突，因为在各自的命名空间中是唯一的。</li>
</ul>
<h5 data-id="heading-48">2. <strong>权限控制（RBAC）</strong></h5>
<p>可以基于 Namespace 分配不同的权限，比如：</p>
<ul>
<li><code>张三</code> 只能管理 <code>dev</code> 命名空间；</li>
<li><code>李四</code> 只能查看 <code>prod</code> 命名</li>
</ul>
<p>便于企业多团队协作时的权限边界管理。</p>
<h5 data-id="heading-49">3. <strong>资源配额限制（ResourceQuota）</strong></h5>
<p>可以为不同 Namespace 设置资源配额限制，比如：</p>
<ul>
<li><code>dev</code> Namespace 最多使用 4 个 CPU、8G 内存；</li>
<li><code>prod</code> Namespace 可以使用更多资源；</li>
</ul>
<p>这样可以避免某个项目“吃光”整个集群资源。</p>
<h5 data-id="heading-50">4. <strong>便于环境分离</strong></h5>
<p>常见实践：按环境划分 Namespace：</p>
<ul>
<li><code>dev</code>：开发环境</li>
<li><code>test</code>：测试环境</li>
<li><code>prod</code>：生产环境</li>
</ul>
<p>在一个集群中部署多套系统而互不干扰。此外Kubernetes 默认提供了几个内置命名空间：</p>

























<table><thead><tr><th>命名空间</th><th>用途</th></tr></thead><tbody><tr><td><code>default</code></td><td>默认命名空间，用户不指定时资源会创建在这里</td></tr><tr><td><code>kube-system</code></td><td>Kubernetes 系统组件运行的地方（如 kube-dns）</td></tr><tr><td><code>kube-public</code></td><td>所有人都可访问，主要用于公开信息</td></tr><tr><td><code>kube-node-lease</code></td><td>节点状态心跳相关</td></tr></tbody></table>
<h4 data-id="heading-51">3.7.2 创建命名空间并部署资源示例</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建命名空间</span>
kubectl create namespace dev

<span class="hljs-comment"># 在 dev 命名空间部署 nginx</span>
kubectl run nginx --image=nginx -n dev

<span class="hljs-comment"># 查看 dev 命名空间下的 Pod</span>
kubectl get pods -n dev
</code></pre>
<p>命名空间的逻辑隔离:</p>
<pre><code class="hljs language-bash" lang="bash">+------------------------+
|     Kubernetes 集群     |
|                        |
| +--------+  +--------+ |
| | dev    |  | prod   | |
| |        |  |        | |
| | nginx  |  | nginx  | |
| | redis  |  | mysql  | |
| +--------+  +--------+ |
+------------------------+

</code></pre>
<h3 data-id="heading-52">3.8 RBAC</h3>
<p><strong>RBAC（基于角色的访问控制，Role-Based Access Control）</strong> 是一种权限管理机制，用来控制<strong>谁可以对哪些资源执行哪些操作</strong>。RBAC 就像公司中的权限系统：不同的岗位（角色）有不同的权限，不同的员工（用户）只能做他们被授权的事情。</p>
<h4 data-id="heading-53">3.8.1 RBAC 的核心组件</h4>
<p>RBAC 一共由 4 个关键对象组成：</p>

























<table><thead><tr><th>对象</th><th>说明</th></tr></thead><tbody><tr><td><strong>Role</strong></td><td>定义在某个 Namespace 中能进行哪些操作（比如：可以查看 Pod）</td></tr><tr><td><strong>ClusterRole</strong></td><td>类似 Role，但作用于所有命名空间或集群级资源（如节点、存储等）</td></tr><tr><td><strong>RoleBinding</strong></td><td>将 Role 绑定到具体用户、组或 ServiceAccount（限某命名空间）</td></tr><tr><td><strong>ClusterRoleBinding</strong></td><td>将 ClusterRole 绑定到用户、组或服务账号（全局作用）</td></tr></tbody></table>
<p>常见的操作：</p>

































<table><thead><tr><th>动作</th><th>含义</th></tr></thead><tbody><tr><td><code>get</code></td><td>获取资源</td></tr><tr><td><code>list</code></td><td>列出资源列表</td></tr><tr><td><code>watch</code></td><td>监听资源变化</td></tr><tr><td><code>create</code></td><td>创建资源</td></tr><tr><td><code>update</code></td><td>更新资源</td></tr><tr><td><code>delete</code></td><td>删除资源</td></tr></tbody></table>
<h4 data-id="heading-54">3.8.2 创建一个只读角色</h4>
<p>创建 Role：只能查看 Pod 和 Service</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-reader</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span>
<span class="hljs-attr">rules:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">""</span>]
    <span class="hljs-attr">resources:</span> [<span class="hljs-string">"pods"</span>, <span class="hljs-string">"services"</span>]
    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">"get"</span>, <span class="hljs-string">"list"</span>, <span class="hljs-string">"watch"</span>]
</code></pre>
<p>创建 RoleBinding：把这个权限绑定给某个用户</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">read-pods-binding</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span>
<span class="hljs-attr">subjects:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">alice</span>
    <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
<span class="hljs-attr">roleRef:</span>
  <span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-reader</span>
  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span>
</code></pre>
<p>表示：用户 <code>alice</code> 在 <code>dev</code> 命名空间内，可以读取 Pod 和 Service，但不能创建、删除、修改。</p>
<p>常用命令:</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 查看所有 ClusterRole</span>
kubectl get clusterroles

<span class="hljs-comment"># 查看绑定关系</span>
kubectl get rolebindings -n dev

<span class="hljs-comment"># 授予某用户集群管理员权限（示例）</span>
kubectl create clusterrolebinding admin-binding \
  --clusterrole=cluster-admin \
  --user=alice@example.com
</code></pre>
<h3 data-id="heading-55">3.9 CronJob</h3>
<p><strong><code>CronJob</code></strong> 是用来按计划周期性运行任务的资源类型，类似于 Linux 中的 <code>crontab</code>。它适用于那些需要定时执行的任务，例如数据库备份、定期数据清理、定时邮件发送等。</p>
<p>配置字段说明：</p>





























<table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>CronJob</code></td><td>按时间调度，周期性运行任务</td></tr><tr><td><code>Job</code></td><td>CronJob 每次触发都会生成一个 Job，它是一次性任务</td></tr><tr><td><code>Pod</code></td><td>Job 创建的 Pod 执行任务脚本</td></tr><tr><td><code>restartPolicy</code></td><td>通常设置为 <code>OnFailure</code>，失败时重试</td></tr><tr><td><code>suspend</code></td><td>可设为 <code>true</code> 暂停 CronJob 执行</td></tr></tbody></table>
<p>示例：每天午夜运行一次任务</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">CronJob</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-cronjob</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">schedule:</span> <span class="hljs-string">"0 0 * * *"</span>  <span class="hljs-comment"># crontab 格式：每天0点</span>
  <span class="hljs-attr">jobTemplate:</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">template:</span>
        <span class="hljs-attr">spec:</span>
          <span class="hljs-attr">containers:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello</span>
              <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>
              <span class="hljs-attr">args:</span>
                <span class="hljs-bullet">-</span> <span class="hljs-string">/bin/sh</span>
                <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span>
                <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">"Hello from CronJob at $(date)"</span>
          <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>

</code></pre>
<p><code>schedule</code> 使用的是类 Unix 的 cron 表达式，格式如下：</p>
<pre><code class="hljs">分 时 日 月 星期
</code></pre>





















<table><thead><tr><th>示例</th><th>含义</th></tr></thead><tbody><tr><td><code>*/5 * * * *</code></td><td>每 5 分钟执行一次</td></tr><tr><td><code>0 0 * * *</code></td><td>每天午夜 0 点执行</td></tr><tr><td><code>0 9 * * 1</code></td><td>每周一早上 9 点执行</td></tr></tbody></table>
<p>CronJob 的执行过程：</p>
<pre><code class="hljs language-lua" lang="lua">时间触发器 (schedule)
        ↓
   +<span class="hljs-comment">-----------+</span>
   |  CronJob  | ← 负责按照 schedule 触发 Job
   +<span class="hljs-comment">-----------+</span>
        ↓
   +<span class="hljs-comment">-----------+</span>
   |   Job     | ← 一次性任务（控制器）
   +<span class="hljs-comment">-----------+</span>
        ↓
   +<span class="hljs-comment">-----------+</span>
   |   Pod     | ← 实际执行任务的容器
   +<span class="hljs-comment">-----------+</span>

</code></pre>
<p>常用命令：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 获取集群中所有CronJob资源的列表</span>
kubectl get cronjob
<span class="hljs-comment"># 查看名为 hello-cronjob 的 CronJob 资源的详细信息</span>
kubectl describe cronjob hello-cronjob
<span class="hljs-comment"># 列出所有的 Job 资源</span>
kubectl get <span class="hljs-built_in">jobs</span>
<span class="hljs-comment"># 查看与指定 Job 相关的 Pod 的日志</span>
kubectl logs &lt;job-created-pod-name&gt;

</code></pre>
<h2 data-id="heading-56">四、自动伸缩（HPA）</h2>
<p><strong>HPA（Horizontal Pod Autoscaler，水平 Pod 自动扩缩容）</strong> 是一个控制器，它会根据CPU、内存或自定义指标，自动调整 Pod 的副本数量，确保应用在不同负载情况下都能平稳运行。</p>
<h3 data-id="heading-57">4.1 HPA 的工作原理</h3>
<ul>
<li>HPA 监测目标 Pod 资源使用情况（默认监测 CPU）。</li>
<li>如果 CPU 或其他指标高于设定阈值，就自动<strong>增加</strong> Pod 副本数。</li>
<li>如果 CPU 或其他指标低于设定阈值，就自动<strong>减少</strong> Pod 副本数。</li>
</ul>
<h3 data-id="heading-58">4.2 如何使用 HPA？</h3>
<h4 data-id="heading-59">4.2.1 确保 Metrics Server 已安装</h4>
<p>HPA 需要 <code>metrics-server</code> 提供 Pod 资源使用数据。可以使用以下命令检查：</p>
<pre><code class="hljs language-bash" lang="bash">kubectl get apiservices | grep metrics
</code></pre>
<p>如果 <code>metrics.k8s.io</code> 没有运行，需要安装：</p>
<pre><code class="hljs language-bash" lang="bash">kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
</code></pre>
<h4 data-id="heading-60">4.2.2 创建一个 Deployment</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">php-apache</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">php-apache</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">php-apache</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">php-apache</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/hpa-example</span>
          <span class="hljs-attr">ports:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>
          <span class="hljs-attr">resources:</span>
            <span class="hljs-attr">requests:</span>
              <span class="hljs-attr">cpu:</span> <span class="hljs-string">200m</span>
            <span class="hljs-attr">limits:</span>
              <span class="hljs-attr">cpu:</span> <span class="hljs-string">500m</span>
</code></pre>
<p>注意：HPA 需要 <code>resources.requests.cpu</code> 进行判断，因此 Pod 必须指定 <code>cpu requests</code> 值，否则 HPA 不会生效。</p>
<h4 data-id="heading-61">4.2.3 创建 HPA 规则（基于 CPU 自动扩缩）</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">autoscaling/v2</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">HorizontalPodAutoscaler</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">php-apache-hpa</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">scaleTargetRef:</span>
    <span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
    <span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">php-apache</span>   <span class="hljs-comment"># 关联的 Deployment</span>
  <span class="hljs-attr">minReplicas:</span> <span class="hljs-number">1</span>        <span class="hljs-comment"># 最少 1 个副本</span>
  <span class="hljs-attr">maxReplicas:</span> <span class="hljs-number">10</span>       <span class="hljs-comment"># 最多 10 个副本</span>
  <span class="hljs-attr">metrics:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">Resource</span>
      <span class="hljs-attr">resource:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">cpu</span>
        <span class="hljs-attr">target:</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">Utilization</span>
          <span class="hljs-attr">averageUtilization:</span> <span class="hljs-number">50</span>  <span class="hljs-comment"># CPU 使用率超过 50% 时扩容</span>
</code></pre>
<h4 data-id="heading-62">4.2.4 应用与查看 HPA 规则</h4>
<pre><code class="hljs language-bash" lang="bash">kubectl apply -f hpa.yaml
kubectl get hpa
</code></pre>
<p>示例输出：</p>
<pre><code class="hljs language-bash" lang="bash">NAME            REFERENCE            TARGETS   MINPODS   MAXPODS   REPLICAS   AGE
php-apache-hpa  Deployment/php-apache  60%/50%  1         10        3         5m
</code></pre>
<ul>
<li><code>TARGETS 60%/50%</code>：当前 CPU 使用率 60%，HPA 目标是 50%。</li>
<li><code>REPLICAS 3</code>：HPA 自动扩展了 3 个 Pod。</li>
</ul>
<hr>
<h4 data-id="heading-63">4.2.5 模拟高负载（测试 HPA）</h4>
<p>可以使用 <code>busybox</code> 持续压测 Pod 的 CPU：</p>
<pre><code class="hljs language-bash" lang="bash">kubectl run -i --<span class="hljs-built_in">tty</span> busybox --image=busybox -- sh
<span class="hljs-comment"># 在 BusyBox 终端里执行</span>
<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span> wget -q -O- http://php-apache; <span class="hljs-keyword">done</span>
</code></pre>
<p>观察 HPA 变化：</p>
<pre><code class="hljs language-bash" lang="bash">kubectl get hpa -w
</code></pre>
<h4 data-id="heading-64">4.2.6 进阶-基于自定义指标扩缩容</h4>
<p>HPA 也可以基于<strong>内存使用量</strong>或<strong>Prometheus 自定义指标</strong>进行扩缩容，例如：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">metrics:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">Resource</span>
    <span class="hljs-attr">resource:</span>
      <span class="hljs-attr">name:</span> <span class="hljs-string">memory</span>
      <span class="hljs-attr">target:</span>
        <span class="hljs-attr">type:</span> <span class="hljs-string">Utilization</span>
        <span class="hljs-attr">averageUtilization:</span> <span class="hljs-number">70</span>  <span class="hljs-comment"># 当内存使用率超过 70% 时扩容</span>
</code></pre>
<p>或者基于 <strong>Prometheus 监控指标</strong> 进行扩容：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">metrics:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">External</span>
    <span class="hljs-attr">external:</span>
      <span class="hljs-attr">metric:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">requests_per_second</span> 
      <span class="hljs-attr">target:</span>
        <span class="hljs-attr">type:</span> <span class="hljs-string">AverageValue</span>
        <span class="hljs-attr">averageValue:</span> <span class="hljs-number">1000</span> <span class="hljs-comment"># 每秒请求超过1000次扩容</span>
</code></pre>
<h3 data-id="heading-65">4.3 怎么解决资源不足问题？</h3>
<p>HPA 扩展的 Pod 所需的硬件资源，来自集群中已有的 Node（节点）资源池。如果 Node上没有足够资源容纳新的 Pod，Pod 会<strong>处于 Pending 状态</strong>，直到有资源调度。举例说明：</p>
<ol>
<li>集群中有 3 个 Node，每个 Node 有 2 核 CPU 和 4G 内存。</li>
<li>每个 Pod 要求 <code>cpu: 500m</code>。</li>
<li>初始状态运行了 6 个 Pod，正好占满资源(理论上最多能运行 <strong>12 个 Pod</strong>，但我们说<strong>6 个 Pod 就占满资源</strong>，是因为现实中不能这么理想化计算，系统组件也占资源，再预留一些 buffer 来应对波动、调度策略等，6~8 个 Pod 就可能接近极限了)。</li>
<li>负载升高，HPA 触发扩容为 8 个 Pod。</li>
</ol>
<p>结果：新创建的 2 个 Pod 会 <strong>Pending（等待）</strong> ，因为没有 Node 有足够资源运行它们。</p>
<p>怎么解决资源不足问题？有两种方式：</p>
<h4 data-id="heading-66">4.3.1 手动添加节点（扩容集群）</h4>
<p>如果你使用的是物理机或虚拟机搭建的集群，可以手动加入更多 Node。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 添加新节点后，kubelet 会将其注册进集群</span>
kubectl get nodes
</code></pre>
<h4 data-id="heading-67">4.3.2 使用 Cluster Autoscaler（集群自动扩容）</h4>
<blockquote>
<p>Cluster Autoscaler 是 Kubernetes 官方提供的<strong>自动添加/移除 Node 的组件</strong>。</p>
</blockquote>
<ul>
<li>当 Pod 无法调度时，Cluster Autoscaler 会自动向云服务申请添加 Node。</li>
<li>当某些 Node 上没有运行任何 Pod 并维持一段时间，自动释放这些 Node。</li>
</ul>
<p>支持的云平台：</p>
<ul>
<li>GKE（Google）</li>
<li>EKS（AWS）</li>
<li>AKS（Azure）</li>
<li>阿里云、腾讯云等也有类似组件</li>
</ul>
<h4 data-id="heading-68">4.3.3 最佳方案</h4>
<p>最佳实践：HPA + Cluster Autoscaler 联用 是生产环境最常见做法：</p>
<ul>
<li>HPA 根据 CPU/内存/自定义指标自动调整 Pod 数量。</li>
<li>如果资源不足，Cluster Autoscaler 自动申请节点，保障 Pod 正常运行。</li>
</ul>






























<table><thead><tr><th>类别</th><th>HPA</th><th>Cluster Autoscaler</th></tr></thead><tbody><tr><td>控制对象</td><td>Pod 副本数量</td><td>Node 数量（硬件资源）</td></tr><tr><td>是否自动</td><td>是</td><td>是（需配置）</td></tr><tr><td>是否立即生效</td><td>快速</td><td>云平台资源申请略慢</td></tr><tr><td>解决问题</td><td>应对应用层负载变化</td><td>应对物理资源不足</td></tr></tbody></table>
<h2 data-id="heading-69">结语</h2>
<p>肚子有点饿，今天先写到这里，下篇明天再续写。</p></div></div>