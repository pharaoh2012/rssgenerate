
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/echo-sama/p/18786094" title="发布于 2025-03-21 23:46">
    <span role="heading" aria-level="2">[WPF] 在RichTextBox中输出Microsoft.Extension.Logging库的日志消息</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="背景">背景</h2>
<p>微软的日志库一般是输出到控制台的，但是在WPF中并不能直接使用控制台，需要AllocConsole。<br>
但是这种做法个人觉得不太安全(一关闭控制台整个程序就退出了?)。这时候就需要一个更加友好的方式输出日志。</p>
<h2 id="问题">问题</h2>
<p>那如何将日志的内容显示到RichTextBox中?</p>
<h2 id="实现loggerprocessor">实现LoggerProcessor</h2>
<ul>
<li>这里参照官方的ConsoleLoggerProcessor，但是需要有点区别。</li>
</ul>
<pre><code class="language-csharp">public class RichTextBoxLoggerProcessor:IDisposable
{
    ///...其他实现请参照Microsoft.Extension.Logging的源码
    private readonly RichTextBoxDocumentStorage _storage;
    private readonly Thread _outputThread;

    /// 这个构造函数传入RichTextBoxDocumentStorage，用于显示单条日志记录
    public RichTextBoxLoggerProcessor(RichTextBoxDocumentStorage storage,       LoggerQueueFullMode fullMode, int maxQueueLength)
    {
        _storage = storage;
        _messageQueue = new();
        FullMode = fullMode;
        MaxQueueLength = maxQueueLength;
        _outputThread = new Thread(ProcessMessageQueue)
        {
            IsBackground = true,
            Name = "RichTextBox logger queue processing thread"
        };
        _outputThread.Start();
    }

    ///改写WriteMessage方法，熟悉FlowDocument的兄弟应该都知道Paragraph是什么吧
    public void WriteMessage(Paragraph message)
    {
        try
        {
            //发送回FlowDocument所在的线程后添加Paragraph
            _storage.Document?.Dispatcher.BeginInvoke(() =&gt;
            {
                _storage.Document.Blocks.Add(message);
            });
        }
        catch
        {
            CompleteAdding();
        }
    }

    //同理改写EnqueMessage方法和Enqueue等方法
    public void EnqueMessage(Paragraph message)
    {
        //...具体逻辑请参阅github源码
    }

    public bool Enqueue(Paragraph message)
    {
        //...
    }

     public bool TryDequeue(out Paragraph entry)
     {
        //...
     }
}

public class RichTextBoxDocumentStorage
{
    ///因为要使用到DI，所以创建一个类来存放FlowDocument;
    public FlowDocument? Document{ get; set; }
}
</code></pre>
<h2 id="实现richtextboxlogger">实现RichTextBoxLogger</h2>
<ul>
<li>这里继承ILogger接口</li>
</ul>
<pre><code class="language-csharp">public class RichTextBoxLogger:ILogger
{
    private string _category;
    private RichTextBoxLoggerProcessor _processor;

    public RichTextBoxLogger(string category, RichTextBoxLoggerProcessor processor, RichTextBoxFormatter formatter)
    {
        _category = category;
        _processor = processor;
        Formatter = formatter;
    }

    //LogEntry格式化器
    public RichTextBoxFormatter Formatter { get; set; }

    public void Log&lt;TState&gt;(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func&lt;TState, Exception?, string&gt; formatter)
    {
        var logEntry = new LogEntry&lt;TState&gt;(logLevel, _category, eventId, state, exception, formatter);

        //paragraph 需要在主线程创建
        App.Current.Dispatcher.BeginInvoke(() =&gt;
        {
            var message = Formatter.Write(in logEntry);
            if (message is null)
            {
              return;
            }
            _processor.EnqueMessage(message);
      });
  }
}

public abstract class RichTextBoxFormatter
{
    protected RichTextBoxFormatter(string name)
    {
        Name = name;
    }

    public string Name { get; }

    public abstract Paragraph? Write&lt;TState&gt;(in LogEntry&lt;TState&gt; logEntry);
}
</code></pre>
<h2 id="创建loggerprovider">创建LoggerProvider</h2>
<pre><code class="language-csharp">public class RichTextBoxLoggerProvider: ILoggerProvider
{
    private readonly RichTextBoxFormatter _formatter;
    private readonly ConcurrentDictionary&lt;string,RichTextBoxLogger&gt; _loggers = [];
    private readonly RichTextBoxLoggerProcessor _processor;
    public RichTextBoxLoggerProvider(RichTextBoxDocumentStorage storage, RichTextBoxFormatter formatter)
    {
        _formatter = formatter;
        _processor = new RichTextBoxLoggerProcessor(storage, LoggerQueueFullMode.Wait, 2500);
        _formatter = formatter;
    }

    public ILogger CreateLogger(string categoryName)
    {
        return _loggers.GetOrAdd(categoryName, new RichTextBoxLogger(categoryName, _processor, _formatter));
    }
}
</code></pre>
<h2 id="创建真正的logviewer">创建真正的LogViewer</h2>
<ul>
<li>这里使用的是Window来展现日志</li>
</ul>
<pre><code class="language-csharp">public class LogViewer : Window
{
    public LogViewer(RichTextBoxDocumentStorage storage)
    {
        InitializeComponent();
        if(storage.Document is null)
        {
            //确保FlowDocument是在主线程上创建的
            App.Current.Dispatcher.Invoke(()=&gt;{
                _storage.Document =  new FlowDocument() { TextAlignment = System.Windows.TextAlignment.Left }; 
            });
        }
        logPresenter.Document = storage.Document;
    }
}
</code></pre>
<h2 id="注册服务">注册服务</h2>
<pre><code class="language-csharp">public static class RichTextBoxLoggingExtension 
{
    public static ILoggingBuilder AddRichTextBoxLogger(this ILoggingBuilder builder)
    {
        builder.Services.AddSingleton&lt;RichTextBoxDocumentStorage&gt;();
        //格式化的实现就不写了，按自己的喜好来写写格式化器；这里是参照的SimpleConsoleFormatter实现的
        builder.Services.AddSingleton&lt;RichTextBoxFormatter, SimpleRichTextBoxFormatter&gt;();
        builder.Services.AddSingleton&lt;ILoggerProvider,RichTextBoxLoggerProvider&gt;();
        return builder;
    }
}
</code></pre>
<h2 id="具体使用">具体使用</h2>
<ul>
<li>任意位置使用ServiceProvider唤起LogViewer即可</li>
</ul>
<pre><code class="language-csharp">public class SomeClass
{
    public void OpenLogViewer()
    {
        App.Current.Services.GetRequiredService&lt;LogViewer&gt;().Show();
    }
}
</code></pre>
<h2 id="结尾">结尾</h2>
<p>这里只是实现了个简单的输出，还有好多好多功能没有实现。<br>
不喜欢写太长的解释说明，感觉好麻烦。代码就是最好的说明（<br>
看哪天心血来潮了，做个nuget包吧。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="3.3855342032627314" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-21 23:52">2025-03-21 23:46</span>&nbsp;
<a href="https://www.cnblogs.com/echo-sama">Echo_HR910</a>&nbsp;
阅读(<span id="post_view_count">278</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18786094" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18786094);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18786094', targetLink: 'https://www.cnblogs.com/echo-sama/p/18786094', title: '[WPF] 在RichTextBox中输出Microsoft.Extension.Logging库的日志消息' })">举报</a>
</div>
        