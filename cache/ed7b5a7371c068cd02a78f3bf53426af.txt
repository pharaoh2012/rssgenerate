
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/renzhesuanfa/p/18710817" title="发布于 2025-02-12 01:13">
    <span role="heading" aria-level="2">【忍者算法】从图书馆找书到矩阵搜索：探索二维矩阵中的高效搜索｜LeetCode第240题 搜索二维矩阵 II</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="从图书馆找书到矩阵搜索探索二维矩阵中的高效搜索">从图书馆找书到矩阵搜索：探索二维矩阵中的高效搜索</h1>
<h2 id="生活中的搜索策略">生活中的搜索策略</h2>
<p>想象你在一个大型图书馆里找书。这个图书馆的书架是按照两个维度排列的：每个书架从左到右按书名字母顺序排列，从上到下的书架则按照出版年份排序。如果你要找一本特定的书，你会怎么做？显然，从第一个书架第一本书开始一本本查找是最笨的方法。聪明的做法是：先找到可能的书架（年份范围），再在书架上快速定位（利用字母顺序）。</p>
<h2 id="问题描述">问题描述</h2>
<p>LeetCode第240题"搜索二维矩阵 II"是这样描述的：编写一个程序，在一个 m x n 的矩阵中查找一个值 target。这个矩阵有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列</li>
<li>每列的元素从上到下升序排列</li>
</ul>
<p>例如：</p>
<pre><code>输入：matrix = [[1, 4, 7, 11, 15],
                [2, 5, 8, 12, 19],
                [3, 6, 9, 16, 22],
                [10,13,14,17, 24],
                [18,21,23,26, 30]], 
target = 5

输出：true
</code></pre>
<h2 id="最直观的解法暴力搜索">最直观的解法：暴力搜索</h2>
<p>就像在图书馆里一本本翻找，最简单的方法是遍历矩阵中的每个元素。虽然这种方法保证能找到答案，但效率很低。</p>
<h3 id="暴力搜索的实现">暴力搜索的实现</h3>
<pre><code class="language-java">public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }
    
    int m = matrix.length;
    int n = matrix[0].length;
    
    // 遍历每个元素
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (matrix[i][j] == target) {
                return true;
            }
        }
    }
    
    return false;
}
</code></pre>
<h2 id="优化解法从右上角开始搜索">优化解法：从右上角开始搜索</h2>
<p>仔细观察矩阵的特性，我们可以采用更聪明的方法。就像在图书馆找书时，我们可以站在一个特殊的位置 —— 右上角，这个位置很神奇：</p>
<ul>
<li>向左看，数字会变小</li>
<li>向下看，数字会变大</li>
</ul>
<p>这就给了我们一个明确的搜索方向！</p>
<h3 id="右上角搜索的原理">右上角搜索的原理</h3>
<p>想象你在玩一个猜数字的游戏：</p>
<ol>
<li>站在右上角</li>
<li>如果当前数字大于目标值，就向左移动（因为下面的数字更大，没必要看）</li>
<li>如果当前数字小于目标值，就向下移动（因为左边的数字更小，没必要看）</li>
<li>如果相等，就找到了答案</li>
</ol>
<h3 id="示例运行">示例运行</h3>
<p>以查找target = 9为例：</p>
<pre><code>1  4  7  11 [15] → 比9大，左移
1  4  7 [11] 15  → 比9大，左移
1  4 [7]  11 15  → 比9小，下移
1  4  7   11 15
2  5  8   12 19
3  6 [9]  16 22  → 找到目标值！
10 13 14  17 24
18 21 23  26 30
</code></pre>
<h3 id="java代码实现">Java代码实现</h3>
<pre><code class="language-java">public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }
    
    // 从右上角开始搜索
    int row = 0;
    int col = matrix[0].length - 1;
    
    while (row &lt; matrix.length &amp;&amp; col &gt;= 0) {
        if (matrix[row][col] == target) {
            return true;
        } else if (matrix[row][col] &gt; target) {
            // 当前值太大，向左移动
            col--;
        } else {
            // 当前值太小，向下移动
            row++;
        }
    }
    
    return false;
}
</code></pre>
<h2 id="解法比较">解法比较</h2>
<p>让我们比较这两种方法：</p>
<p>暴力搜索：</p>
<ul>
<li>时间复杂度：O(m×n)</li>
<li>空间复杂度：O(1)</li>
<li>优点：简单直观，容易实现</li>
<li>缺点：没有利用矩阵的特性，效率低</li>
</ul>
<p>右上角搜索：</p>
<ul>
<li>时间复杂度：O(m+n)</li>
<li>空间复杂度：O(1)</li>
<li>优点：充分利用矩阵特性，高效快速</li>
<li>缺点：需要理解矩阵的排序特性</li>
</ul>
<h2 id="实用技巧总结">实用技巧总结</h2>
<p>解决矩阵搜索问题的关键点：</p>
<ol>
<li>观察矩阵的特性（如排序规律）</li>
<li>寻找特殊位置（如右上角）作为起点</li>
<li>利用排序特性确定搜索方向</li>
<li>正确处理边界条件</li>
</ol>
<p>相关的矩阵搜索问题：</p>
<ul>
<li>搜索二维矩阵 I</li>
<li>有序矩阵中的第k小元素</li>
<li>矩阵中的最小路径和</li>
</ul>
<h2 id="小结">小结</h2>
<p>通过搜索二维矩阵这道题，我们学会了如何在有序矩阵中高效搜索。这种思维方式不仅能解决算法题，在数据库索引设计、图像处理等领域都有应用。记住，当遇到需要在有序数据结构中搜索的问题时，可以考虑利用数据的有序性来优化搜索过程，通常能获得比暴力搜索更好的性能！</p>
<hr>
<p>作者：忍者算法<br>
公众号：忍者算法</p>
<p>我准备了一份刷题清单，以及这些题目的详细题解，覆盖了绝大部分常见面试题。我可以很负责任地说，只要你把这些题真正掌握了，80%的算法面试都能遇到相似题目。公众号回复【刷题清单】获取～</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.044675789077546296" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-12 01:13">2025-02-12 01:13</span>&nbsp;
<a href="https://www.cnblogs.com/renzhesuanfa">忍者算法</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18710817" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18710817);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18710817', targetLink: 'https://www.cnblogs.com/renzhesuanfa/p/18710817', title: '【忍者算法】从图书馆找书到矩阵搜索：探索二维矩阵中的高效搜索｜LeetCode第240题 搜索二维矩阵 II' })">举报</a>
</div>
        