
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cikiss/p/18695321" title="发布于 2025-01-30 20:02">
    <span role="heading" aria-level="2">「全网最细 + 实战源码案例」设计模式——装饰者模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>​</p>
<h1 id="核心思想">核心思想</h1>
<ul>
<li>装饰者模式（Decorator Pattern）是一种结构型设计模式，通过“包装”现有对象来为其添加额外的功能，而无需改变原有对象的代码。装饰者模式通过创建一个装饰类来扩展对象的功能而不是继承。这样可以灵活地在运行时动态地组合功能。</li>
</ul>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/185d611b58a84b90beb75692880bb5d0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1738324914&amp;x-orig-sign=u4ZHLraw%2BpG%2FpYLjyTKwOf8QQWA%3D" alt="" loading="lazy">​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy">编辑</p>
<hr>
<h1 id="结构">结构</h1>
<h2 id="1-component抽象构件">1. Component（抽象构件）</h2>
<ul>
<li>定义一个抽象接口以规范准备接受附加责任的对象。</li>
</ul>
<h2 id="2-concretcomponent具体构件">2. ConcretComponent（具体构件）</h2>
<ul>
<li>实现 <code>Component</code>，定义了要被装饰的具体对象。</li>
</ul>
<h2 id="3-decorator抽象装饰者">3. Decorator（抽象装饰者）</h2>
<ul>
<li>实现了 <code>Component</code> 接口，并持有一个 <code>Component</code> 的引用，代表被装饰对象。装饰者类可以在调用原方法的基础上添加额外的功能。</li>
</ul>
<h2 id="4-concretedecorator具体装饰者">4. ConcreteDecorator（具体装饰者）</h2>
<ul>
<li>实现抽象装饰者的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
<h2 id="5-为什么要先继承再组合">5. 为什么要先继承再组合：</h2>
<ol>
<li><strong>继承用于“类型化”</strong> ：</li>
</ol>
<ul>
<li>继承使得装饰器类能够实现与被装饰类相同的接口（或者父类），这确保了装饰器能够在原有的接口上添加功能时，依然能保持原有对象的一致性和可替换性。</li>
<li>通过继承，装饰器可以被用作原类的替代品，不会影响客户端代码对对象的使用和期望。</li>
</ul>
<ol>
<li><strong>组合用于“功能增强”</strong> ：</li>
</ol>
<ul>
<li>组合使得装饰器对象可以持有原始对象，并通过委托的方式来增强其行为。通过组合，装饰器可以在不修改原始类的情况下，动态地为其增加额外的功能或行为。</li>
<li>这种方式比继承更灵活，因为你可以在运行时选择不同的装饰器进行组合，动态增强对象的功能，而不需要提前在类的设计中固定哪些功能是装饰类的一部分。</li>
</ul>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/eb214bb403804e018d9fe3fca6d5ebdc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1738324913&amp;x-orig-sign=lUakgtLrb3zISjQ7FdCCZA762Gw%3D" alt="" loading="lazy">​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy">编辑</p>
<hr>
<h1 id="现实世界类比">现实世界类比</h1>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/bd69086772cb4a9fad10a22d8cb84f13~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1738324913&amp;x-orig-sign=VDQ5rO2hwm4qUKZbBsYNuPR1imY%3D" alt="" loading="lazy">​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy">编辑</p>
<p>穿衣服是使用装饰的一个例子。 觉得冷时， 你可以穿一件毛衣。 如果穿毛衣还觉得冷， 你可以再套上一件夹克。 如果遇到下雨， 你还可以再穿一件雨衣。 所有这些衣物都 “扩展” 了你的基本行为， 但它们并不是你的一部分， 如果你不再需要某件衣物， 可以方便地随时脱掉。</p>
<hr>
<h1 id="适用场景">适用场景</h1>
<ol>
<li><strong>如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。</strong></li>
</ol>

<ol>
<li>
<ol>
<li>装饰能将业务逻辑组织为层次结构， 你可为各层创建一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象。</li>
</ol>
</li>
</ol>

<ol>
<li><strong>如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。</strong></li>
</ol>

<ol>
<li>
<ol>
<li>许多编程语言使用 <code>final</code>最终关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。</li>
</ol>
</li>
</ol>
<hr>
<h1 id="优缺点">优缺点</h1>
<h2 id="优点">优点：</h2>
<ol>
<li><strong>灵活性</strong>：可以通过组合多个装饰器动态地增强对象的功能，避免了继承层次的问题。</li>
<li><strong>避免子类爆炸</strong>：避免了大量的子类继承，尤其是当有多种功能组合时。</li>
<li><strong>符合开闭原则</strong>：通过装饰器来扩展功能，不需要修改原有代码。</li>
</ol>
<h2 id="缺点">缺点：</h2>
<ol>
<li><strong>增加复杂性</strong>：当多个装饰者一起使用时，代码结构可能会变得复杂。</li>
<li><strong>不容易理解</strong>：对于不熟悉设计模式的人，装饰者模式让代码更难理解。</li>
</ol>
<hr>
<h1 id="实现步骤">实现步骤</h1>
<ol>
<li>确保业务逻辑可用一个基本组件及多个额外可选层次表示。</li>
<li>找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。</li>
<li>创建一个具体组件类， 并定义其基础行为。</li>
<li>创建装饰基类， 使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。</li>
<li>确保所有类实现组件接口。</li>
<li>将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。</li>
<li>客户端代码负责创建装饰并将其组合成客户端所需的形式。</li>
</ol>
<hr>
<h1 id="示例">示例</h1>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/6a31b8802c944197a2df0bd0e1a6537c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1738324914&amp;x-orig-sign=guUlb4Z4Af4sMvpaGFWyYFiGfKg%3D" alt="" loading="lazy">​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy">编辑</p>
<pre><code>// 抽象构建者
public abstract class FastFood {

    private float price;
    private String desc;

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public FastFood(float price, String desc) {
        this.price = price;
        this.desc = desc;
    }

    public FastFood() {}

    public abstract float cost();
}

// 具体构建者
public class FriedRice extends FastFood{

    public FriedRice() {
        super(10, "fried rice");
    }

    @Override
    public float cost() {
        return getPrice();
    }
}

// 具体构建者
public class FriedNoodles extends FastFood{

    public FriedNoodles() {
        super(12, "fried noodles");
    }

    @Override
    public float cost() {
        return getPrice();
    }
}

// 抽象装饰者
public abstract class Garnish extends FastFood{

    // 持有一个快餐的引用
    private FastFood fastFood;

    public Garnish(FastFood fastFood, float price, String desc) {
        super(price, desc);
        this.fastFood = fastFood;
    }

    public FastFood getFastFood() {
        return fastFood;
    }

    public void setFastFood(FastFood fastFood) {
        this.fastFood = fastFood;
    }
}

// 具体装饰者
public class Egg extends Garnish{

    public Egg(FastFood fastFood) {
        super(fastFood, 1, "egg");
    }

    @Override
    public float cost() {
        return getPrice() + getFastFood().cost();
    }

    @Override
    public String getDesc() {
        return super.getDesc() + " " + getFastFood().getDesc();
    }
}

// 具体装饰者
public class Bacon extends Garnish{

    public Bacon(FastFood fastFood) {
        super(fastFood, 2, "bacon");
    }

    @Override
    public float cost() {
        return getPrice() + getFastFood().cost();
    }

    @Override
    public String getDesc() {
        return super.getDesc() + " " + getFastFood().getDesc();
    }
}

// 客户端
public class Client {
    public static void main(String[] args) {

        // 点一份炒饭
        FastFood friedRice = new FriedRice();
        System.out.println(friedRice.getDesc() + ":" + friedRice.cost());

        System.out.println("-----------------------------------------");

        // 加一个鸡蛋
        friedRice = new Egg(friedRice);
        System.out.println(friedRice.getDesc() + ":" + friedRice.cost());

        // 加一个培根
        friedRice = new Bacon(friedRice);
        System.out.println(friedRice.getDesc() + ":" + friedRice.cost());

        System.out.println("-----------------------------------------");

        // 再加一个鸡蛋
        friedRice = new Egg(friedRice);
        System.out.println(friedRice.getDesc() + ":" + friedRice.cost());
    }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"></p>
<hr>
<h1 id="在源码中的应用">在源码中的应用</h1>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/fda41c5c0c1c4b12a6e2a58b405aab39~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1738324913&amp;x-orig-sign=CkhnaDH2msDEDtEjJQV4d6W7Lw4%3D" alt="" loading="lazy">​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy">编辑</p>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/b3231c12e9d64decb0bce47e52bd2620~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1738324913&amp;x-orig-sign=tOemdcf3IhHGofn8AfbzQuL%2B0TQ%3D" alt="" loading="lazy">​</p>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy">编辑</p>
<hr>
<h1 id="与其他模式的关系">与其他模式的关系</h1>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/adapter" title="适配器模式" target="_blank" rel="noopener nofollow">适配器模式</a>可以对已有对象的接口进行修改， <a href="https://refactoringguru.cn/design-patterns/decorator" title="装饰模式" target="_blank" rel="noopener nofollow">装饰模式</a>则能在不改变对象接口的前提下强化对象功能。 此外， <em>装</em> <em>饰</em>还支持递归组合， <em>适</em> <em>配</em> <em>器</em>则无法实现。</li>
<li><a href="https://refactoringguru.cn/design-patterns/adapter" title="适配器" target="_blank" rel="noopener nofollow">适配器</a>能为被封装对象提供不同的接口， <a href="https://refactoringguru.cn/design-patterns/proxy" title="代理模式" target="_blank" rel="noopener nofollow">代理模式</a>能为对象提供相同的接口， <a href="https://refactoringguru.cn/design-patterns/decorator" title="装饰" target="_blank" rel="noopener nofollow">装饰</a>则能为对象提供加强的接口。</li>
<li><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility" title="责任链模式" target="_blank" rel="noopener nofollow">责任链模式</a>和<a href="https://refactoringguru.cn/design-patterns/decorator" title="装饰模式" target="_blank" rel="noopener nofollow">装饰模式</a>的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。</li>
<li><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility" title="责任链" target="_blank" rel="noopener nofollow">责任链</a>的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种<em>装饰</em>可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</li>
<li><a href="https://refactoringguru.cn/design-patterns/composite" title="组合模式" target="_blank" rel="noopener nofollow">组合模式</a>和<a href="https://refactoringguru.cn/design-patterns/decorator" title="装饰" target="_blank" rel="noopener nofollow">装饰</a>的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</li>
<li><em>装饰</em>类似于<em>组合</em>， 但其只有一个子组件。 此外还有一个明显不同： <em>装饰</em>为被封装对象添加了额外的职责， <em>组合</em>仅对其子节点的结果进行了 “求和”。但是， 模式也可以相互合作： 你可以使用<em>装饰</em>来扩展<em>组合</em>树中特定对象的行为。</li>
<li>大量使用<a href="https://refactoringguru.cn/design-patterns/composite" title="组合" target="_blank" rel="noopener nofollow">组合</a>和<a href="https://refactoringguru.cn/design-patterns/decorator" title="装饰" target="_blank" rel="noopener nofollow">装饰</a>的设计通常可从对于<a href="https://refactoringguru.cn/design-patterns/prototype" title="原型模式" target="_blank" rel="noopener nofollow">原型模式</a>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</li>
<li><a href="https://refactoringguru.cn/design-patterns/decorator" title="装饰" target="_blank" rel="noopener nofollow">装饰</a>可让你更改对象的外表， <a href="https://refactoringguru.cn/design-patterns/strategy" title="策略模式" target="_blank" rel="noopener nofollow">策略模式</a>则让你能够改变其本质。</li>
<li><a href="https://refactoringguru.cn/design-patterns/decorator" title="装饰" target="_blank" rel="noopener nofollow">装饰</a>和<a href="https://refactoringguru.cn/design-patterns/proxy" title="代理" target="_blank" rel="noopener nofollow">代理</a>有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于<em>代理</em>通常自行管理其服务对象的生命周期， 而<em>装饰</em>的生成则总是由客户端进行控制。</li>
</ul>
<p>​</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.01650732016435185" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-30 20:02">2025-01-30 20:02</span>&nbsp;
<a href="https://www.cnblogs.com/cikiss">SlackClimb</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18695321" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18695321);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18695321', targetLink: 'https://www.cnblogs.com/cikiss/p/18695321', title: '「全网最细 + 实战源码案例」设计模式——装饰者模式' })">举报</a>
</div>
        