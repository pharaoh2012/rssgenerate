
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wxb8/p/18653418" title="发布于 2025-01-05 15:53">
    <span role="heading" aria-level="2">为什么要把数据模型分为：Entity,DTO,Response,Request呢？具体有什么作用呢</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>开发中，我们通常把数据模型分为几个部分，探讨下他们具体都有那些作用。</p>
<h2 id="1-entity实体">1. Entity（实体）</h2>
<p>实体类代表数据库表结构，与数据库表一一对应。</p>
<pre><code class="language-csharp">// 例如 User.cs
public class User : BaseEntity 
{
    public string Username { get; set; }
    public string Password { get; set; }
    // ...
}
</code></pre>
<h3 id="主要特点">主要特点：</h3>
<ul>
<li>代表数据库表的实体类，与数据库表结构一一对应</li>
<li>包含数据库字段的完整定义，如主键、外键、索引等</li>
<li>通常带有 ORM 相关的特性标注（Table、Column 等）</li>
<li>可以包含实体间的导航属性，表示表之间的关系</li>
<li>不应该直接暴露给外部接口，因为可能包含敏感信息（如密码）</li>
</ul>
<h2 id="2-dto数据传输对象">2. DTO（数据传输对象）</h2>
<p>用于在不同层之间传输数据的对象。</p>
<pre><code class="language-csharp">// 例如 UserDto.cs
public class UserDto
{
    public long Id { get; set; }
    public string Username { get; set; }
    // 不包含密码等敏感字段
}
</code></pre>
<h3 id="主要特点-1">主要特点：</h3>
<ul>
<li>用于在不同层之间传输数据的对象</li>
<li>通常是实体类的精简版，只包含需要传输的字段</li>
<li>可以组合多个实体的数据</li>
<li>去除了敏感信息，更安全</li>
<li>可以添加额外的展示字段，更适合业务需求</li>
</ul>
<h2 id="3-request请求模型">3. Request（请求模型）</h2>
<p>专门用于接收 API 请求的数据模型。</p>
<pre><code class="language-csharp">// 例如 CreateUserRequest.cs
public class CreateUserRequest
{
    [Required]
    public string Username { get; set; }
    [Required]
    public string Password { get; set; }
}
</code></pre>
<h3 id="主要特点-2">主要特点：</h3>
<ul>
<li>专门用于接收 API 请求的数据模型</li>
<li>包含数据验证特性（如 Required、StringLength 等）</li>
<li>只包含客户端需要提交的字段</li>
<li>可以根据不同的操作（增、删、改）定义不同的请求模型</li>
<li>更好地控制客户端可以提交的数据范围</li>
</ul>
<h2 id="4-response响应模型">4. Response（响应模型）</h2>
<p>统一的 API 响应格式。</p>
<pre><code class="language-csharp">// 例如 ApiResponse.cs
public class ApiResponse&lt;T&gt;
{
    public int Code { get; set; }
    public string Message { get; set; }
    public T? Data { get; set; }
}
</code></pre>
<h3 id="主要特点-3">主要特点：</h3>
<ul>
<li>统一的 API 响应格式</li>
<li>包含状态码、消息等通用字段</li>
<li>可以包装任意类型的响应数据</li>
<li>便于统一处理成功/失败的响应</li>
<li>有利于前端统一处理响应结果</li>
</ul>
<h2 id="分层的主要好处">分层的主要好处</h2>
<h3 id="1-关注点分离">1. 关注点分离</h3>
<ul>
<li>每种模型都有其特定的职责</li>
<li>不同层级使用不同的模型，避免耦合</li>
</ul>
<h3 id="2-安全性">2. 安全性</h3>
<ul>
<li>实体类中的敏感信息不会直接暴露</li>
<li>可以控制客户端能够访问的数据范围</li>
</ul>
<h3 id="3-灵活性">3. 灵活性</h3>
<ul>
<li>可以根据不同场景使用不同的模型</li>
<li>数据库结构变化时，只需修改实体类</li>
</ul>
<h3 id="4-可维护性">4. 可维护性</h3>
<ul>
<li>代码结构清晰，易于理解和维护</li>
<li>便于进行单元测试</li>
<li>便于处理版本升级和 API 变更</li>
</ul>
<h3 id="5-验证和转换">5. 验证和转换</h3>
<ul>
<li>请求模型可以进行数据验证</li>
<li>DTO 可以进行数据转换和组合</li>
</ul>
<h2 id="实际开发中的数据流向">实际开发中的数据流向</h2>
<div class="mermaid">graph LR
    A[客户端请求] --&gt; B[Request模型]
    B --&gt; C[业务处理]
    C --&gt; D[Entity实体]
    D --&gt; E[数据库]
    E --&gt; F[Entity实体]
    F --&gt; G[DTO转换]
    G --&gt; H[Response模型]
    H --&gt; I[客户端响应]
</div><p>这种模式虽然看起来代码量增加了，但是带来的好处远大于维护成本，特别是在大型项目中更为明显。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.016823540005787035" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-05 15:53">2025-01-05 15:53</span>&nbsp;
<a href="https://www.cnblogs.com/wxb8">Monns</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18653418" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18653418);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18653418', targetLink: 'https://www.cnblogs.com/wxb8/p/18653418', title: '为什么要把数据模型分为：Entity,DTO,Response,Request呢？具体有什么作用呢' })">举报</a>
</div>
        