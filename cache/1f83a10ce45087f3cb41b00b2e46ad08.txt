
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/gmmy/p/19064599" title="发布于 2025-08-29 15:23">
    <span role="heading" aria-level="2">使用c#强大的SourceGenerator现对象的深克隆</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>去年的时候写了一篇用<a href="https://www.cnblogs.com/gmmy/p/18186750" target="_blank">使用c#强大的表达式树实现对象的深克隆</a>. 最近又看到园子里的另外一篇吐槽automapper性能的文章。正好闲来无事，就想着看如果用Source Generator来实现深克隆，性能上会不会比表达式树更强劲呢，于是有了这篇文章。</p>
<p>之前使用表达式树深克隆的的代码可以实现类型相同/不同之间的克隆（UserEntity-&gt;UserDto/UserEntity-&gt;UserEntity），支持环状引用（即A的属性引用自身或者A的属性是类型B，类型B中有属性引用A）和可空-&gt;不可空转换(public int? id-&gt;public int id)。支持枚举转换(public enumXXX type-&gt;public int type/public int type-&gt;public enumXXX&nbsp;type)，在实际生产环境中一直稳定使用，一直没有遇到过问题，但是对于性能上到底能够比手写深拷贝快多少，一直没有闲心去测，这一次正好干脆弄一个Source Generator的版本，再以手写深克隆为基准来实现。</p>
<p>测试环境为windows10、.net版本是9.0.8、引用的BenchmarkDotNet版本是0.15.2。</p>
<p>测试的Dto结构如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> DtoTest
{
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">int</span>? Id { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">string</span> Name { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> List&lt;ChildDto&lt;DtoTest&gt;&gt; Items { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> List&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>&gt; Tags { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> Dictionary&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>, <span style="color: rgba(0, 0, 255, 1)">int</span>?&gt; Dict { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> TestEnum TestEnum { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">int</span>? TestEnum2 { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> DtoTest This { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
}
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> DtoTest2
{
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">int</span> Id { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">string</span> Name { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> List&lt;ChildDto&lt;DtoTest2&gt;?&gt;? Items { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> List&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>&gt; Tags { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> Dictionary&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>, <span style="color: rgba(0, 0, 255, 1)">int</span>&gt; Dict { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">int</span>? TestEnum { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> TestEnum TestEnum2 { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> DtoTest2 This { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
}
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> ChildDto&lt;T&gt;<span style="color: rgba(0, 0, 0, 1)">
{
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">string</span> Key { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }    
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">int</span> Value { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> T Mother { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">; }
}
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">enum</span><span style="color: rgba(0, 0, 0, 1)"> TestEnum
{
    Take </span>= <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">,
    Sale </span>= <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">,
    Pull </span>= <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">
}</span></pre>
</div>
<p>可以看到这份代码基本还是覆盖了大部分常见的情况，包含泛型、字典、可空转换、枚举等等。</p>
<p>测试时我的类型实例构造如下：</p>
<div class="cnblogs_code">
<pre>_src = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> DtoTest
{
    Id </span>= <span style="color: rgba(128, 0, 128, 1)">123</span><span style="color: rgba(0, 0, 0, 1)">,
    Name </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">hello world</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
    Tags </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> List&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>&gt; { <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">a</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">b</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">c</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)"> },
    Items </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> List&lt;ChildDto&lt;DtoTest&gt;&gt;<span style="color: rgba(0, 0, 0, 1)">
            {
                </span><span style="color: rgba(0, 0, 255, 1)">new</span> ChildDto&lt;DtoTest&gt; { Key = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">k1</span><span style="color: rgba(128, 0, 0, 1)">"</span>, Value = <span style="color: rgba(128, 0, 128, 1)">42</span><span style="color: rgba(0, 0, 0, 1)"> },
                </span><span style="color: rgba(0, 0, 255, 1)">new</span> ChildDto&lt;DtoTest&gt; { Key = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">k2</span><span style="color: rgba(128, 0, 0, 1)">"</span>, Value = <span style="color: rgba(128, 0, 128, 1)">100</span><span style="color: rgba(0, 0, 0, 1)"> }
            },
    Dict </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> Dictionary&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>, <span style="color: rgba(0, 0, 255, 1)">int</span>?&gt; { [<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">x</span><span style="color: rgba(128, 0, 0, 1)">"</span>] = <span style="color: rgba(128, 0, 128, 1)">1</span>, [<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">y</span><span style="color: rgba(128, 0, 0, 1)">"</span>] = <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)"> },
    TestEnum </span>=<span style="color: rgba(0, 0, 0, 1)"> TestEnum.Sale,
    TestEnum2 </span>= <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">
};
_src.This </span>=<span style="color: rgba(0, 0, 0, 1)"> _src;
_src.Items.Add(_src.Items[</span><span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">]);
</span><span style="color: rgba(0, 0, 255, 1)">foreach</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> item <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> _src.Items)
{
    item.Mother </span>=<span style="color: rgba(0, 0, 0, 1)"> _src;
}</span></pre>
</div>
<p>增加了循环引用和多次拷贝（items有三个子对象但是有两个指向同一个引用），基本上能够覆盖大部分深拷贝场景了。接下来就是运行后的截图</p>
<p>接下来是增加了一部分测试，确保深拷贝确实是递归到所有属性及其子属性的，而不是简单的浅拷贝（即修改原始对象属性会导致克隆的新对象的属性变化（比如属性的集合内容和属性自身的子属性随着变化））：</p>
<p>测试代码如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">var</span> _src = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> DtoTest
{
    Id </span>= <span style="color: rgba(128, 0, 128, 1)">123</span><span style="color: rgba(0, 0, 0, 1)">,
    Name </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">hello world</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
    Tags </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> List&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>&gt; { <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">a</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">b</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">c</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)"> },
    Items </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> List&lt;ChildDto&lt;DtoTest&gt;&gt;<span style="color: rgba(0, 0, 0, 1)">
            {
                </span><span style="color: rgba(0, 0, 255, 1)">new</span> ChildDto&lt;DtoTest&gt; { Key = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">k1</span><span style="color: rgba(128, 0, 0, 1)">"</span>, Value = <span style="color: rgba(128, 0, 128, 1)">42</span><span style="color: rgba(0, 0, 0, 1)"> },
                </span><span style="color: rgba(0, 0, 255, 1)">new</span> ChildDto&lt;DtoTest&gt; { Key = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">k2</span><span style="color: rgba(128, 0, 0, 1)">"</span>, Value = <span style="color: rgba(128, 0, 128, 1)">100</span><span style="color: rgba(0, 0, 0, 1)"> }
            },
    Dict </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> Dictionary&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>, <span style="color: rgba(0, 0, 255, 1)">int</span>?&gt; { [<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">x</span><span style="color: rgba(128, 0, 0, 1)">"</span>] = <span style="color: rgba(128, 0, 128, 1)">1</span>, [<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">y</span><span style="color: rgba(128, 0, 0, 1)">"</span>] = <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)"> },
    TestEnum </span>=<span style="color: rgba(0, 0, 0, 1)"> TestEnum.Sale,
    TestEnum2 </span>= <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">
};
_src.This </span>=<span style="color: rgba(0, 0, 0, 1)"> _src;
_src.Items.Add(_src.Items[</span><span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">]);
</span><span style="color: rgba(0, 0, 255, 1)">foreach</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> item <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> _src.Items)
{
    item.Mother </span>=<span style="color: rgba(0, 0, 0, 1)"> _src;
}</span>
<span style="color: rgba(0, 0, 255, 1)">var</span> aaa = DeepClone.DeepCloneHelper.CopyTo&lt;DtoTest, DtoTest2&gt;<span style="color: rgba(0, 0, 0, 1)">(_src);
</span><span style="color: rgba(0, 0, 255, 1)">var</span> bbb = InfrastructureBase.Object.ExtensionMapper&lt;DtoTest, DtoTest2&gt;<span style="color: rgba(0, 0, 0, 1)">.Map(_src);
</span><span style="color: rgba(0, 0, 255, 1)">var</span> jsonOpts = <span style="color: rgba(0, 0, 255, 1)">new</span> JsonSerializerOptions { ReferenceHandler =<span style="color: rgba(0, 0, 0, 1)"> ReferenceHandler.Preserve };
_src.Id </span>= <span style="color: rgba(128, 0, 128, 1)">222</span><span style="color: rgba(0, 0, 0, 1)">;
_src.Name </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">bbb</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
_src.Tags[</span><span style="color: rgba(128, 0, 128, 1)">0</span>] = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">d</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
_src.Items.First().Key </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">k0</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;
_src.Dict[</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">x</span><span style="color: rgba(128, 0, 0, 1)">"</span>] = -<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
Console.WriteLine(JsonSerializer.Serialize(_src, jsonOpts));
Console.WriteLine(JsonSerializer.Serialize(aaa, jsonOpts));
Console.WriteLine(JsonSerializer.Serialize(bbb, jsonOpts));</span></pre>
</div>
<p>打印的json结果：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/198579/202508/198579-20250829151821231-1692051461.png" class="lazyload"></p>
<p>&nbsp;可以看到对src的属性修改并没有影响到SG和EXP生成的新对象。</p>
<p>最后是benchmark的情况如下：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/198579/202508/198579-20250829150142009-436120826.png" class="lazyload"></p>
<p>&nbsp;从结果来看，Ratio这一行中以手写深拷贝（new dto2(){xxx= dto1.xxx...}）作为基准值1的情况下，Source Generator大概是其2倍成本，而表达式树的版本大概在其5倍+左右的成本。cong&nbsp;Gen0 垃圾回收代以及Allocated每次执行方法分配的内存大小来看三者的成本差异不大，都在同一个区间。Alloc Ratio内存分配比来看SG和EXP的分配版本也落在X1~X2之间，属于基本可以接受的范畴。</p>
<p>具体的技术细节就不聊了，大家有兴趣可以到github上下载对应的代码测试，上面包含了完整的两种深克隆的实现：https://github.com/sd797994/SG_Extension_DeepClone</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-29 15:24">2025-08-29 15:23</span>&nbsp;
<a href="https://www.cnblogs.com/gmmy">a1010</a>&nbsp;
阅读(<span id="post_view_count">67</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19064599);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19064599', targetLink: 'https://www.cnblogs.com/gmmy/p/19064599', title: '使用c#强大的SourceGenerator现对象的深克隆' })">举报</a>
</div>
        