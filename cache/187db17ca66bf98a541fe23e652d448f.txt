
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ThinkerQAQ/p/18953367" title="发布于 2025-06-28 10:41">
    <span role="heading" aria-level="2">Java源码分析系列笔记-18.Semaphore</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-是什么" rel="noopener nofollow">1. 是什么</a></li><li><a href="#2-原理分析" rel="noopener nofollow">2. 原理分析</a><ul><li><a href="#21-uml" rel="noopener nofollow">2.1. uml</a></li></ul></li><li><a href="#3-公平信号量" rel="noopener nofollow">3. 公平信号量</a><ul><li><a href="#31-是什么" rel="noopener nofollow">3.1. 是什么</a></li><li><a href="#32-使用" rel="noopener nofollow">3.2. 使用</a></li><li><a href="#33-原理分析" rel="noopener nofollow">3.3. 原理分析</a><ul><li><a href="#331-构造方法" rel="noopener nofollow">3.3.1. 构造方法</a><ul><li><a href="#3311-公平sync" rel="noopener nofollow">3.3.1.1. 公平Sync</a></li></ul></li><li><a href="#332-acquire" rel="noopener nofollow">3.3.2. acquire</a><ul><li><a href="#3321-调用aqs加共享锁" rel="noopener nofollow">3.3.2.1. 调用AQS加共享锁</a><ul><li><a href="#33211-尝试加锁公平队列前面有人排队那么直接返回失败" rel="noopener nofollow">3.3.2.1.1. 尝试加锁【公平：队列前面有人排队那么直接返回失败】</a></li></ul></li></ul></li><li><a href="#333-release" rel="noopener nofollow">3.3.3. release</a><ul><li><a href="#3331-调用aqs释放共享锁" rel="noopener nofollow">3.3.3.1. 调用AQS释放共享锁</a><ul><li><a href="#33311-尝试释放共享锁" rel="noopener nofollow">3.3.3.1.1. 尝试释放共享锁</a></li></ul></li></ul></li></ul></li></ul></li><li><a href="#4-非公平信号量" rel="noopener nofollow">4. 非公平信号量</a><ul><li><a href="#41-是什么" rel="noopener nofollow">4.1. 是什么</a></li><li><a href="#42-使用" rel="noopener nofollow">4.2. 使用</a></li><li><a href="#43-原理分析" rel="noopener nofollow">4.3. 原理分析</a><ul><li><a href="#431-构造方法" rel="noopener nofollow">4.3.1. 构造方法</a><ul><li><a href="#4311-非公平sync" rel="noopener nofollow">4.3.1.1. 非公平Sync</a></li></ul></li><li><a href="#432-acquire" rel="noopener nofollow">4.3.2. acquire</a><ul><li><a href="#4321-调用aqs加共享锁" rel="noopener nofollow">4.3.2.1. 调用AQS加共享锁</a><ul><li><a href="#43211-尝试加共享锁非公平不管队列前面是否有人我直接尝试加锁" rel="noopener nofollow">4.3.2.1.1. 尝试加共享锁【非公平：不管队列前面是否有人我直接尝试加锁】</a></li></ul></li></ul></li><li><a href="#433-release" rel="noopener nofollow">4.3.3. release</a><ul><li><a href="#4331-调用aqs释放共享锁" rel="noopener nofollow">4.3.3.1. 调用AQS释放共享锁</a><ul><li><a href="#43311-尝试释放锁" rel="noopener nofollow">4.3.3.1.1. 尝试释放锁</a></li></ul></li></ul></li></ul></li></ul></li></ul></div><p></p>
<h1 id="1-是什么">1. 是什么</h1>
<p>限流工具类，同一时间只允许n个线程访问某资源</p>
<h1 id="2-原理分析">2. 原理分析</h1>
<h2 id="21-uml">2.1. uml</h2>
<pre><code class="language-puml">@startuml
skinparam classAttributeIconSize 0

class Semaphore{
}

class AbstractQueuedSynchronizer{
}

class Sync{
}

class FairSync{
}

class NonfairSync{

}

Sync &lt;|-- FairSync

Sync &lt;|-- NonfairSync

AbstractQueuedSynchronizer &lt;|-- Sync

Semaphore --&gt; Sync
@enduml
</code></pre>
<p>可以看出Semaphore也有公平的和非公平之分</p>
<h1 id="3-公平信号量">3. 公平信号量</h1>
<h2 id="31-是什么">3.1. 是什么</h2>
<p>限流，使用的公平策略</p>
<h2 id="32-使用">3.2. 使用</h2>
<pre><code class="language-java">public class SemaphoreTest
{
    private final static int THREAD_COUNT = 100;
    private final static CountDownLatch countDownLatch = new CountDownLatch(THREAD_COUNT);

    public static void main(String[] args) throws InterruptedException
    {
        Semaphore semaphore = new Semaphore(10, true);//true代表公平

        for (int i = 0; i &lt; THREAD_COUNT; i++)
        {
            new Thread(()-&gt;{
                try
                {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + "正在访问资源。。。");
                    TimeUnit.SECONDS.sleep(3);

                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
                finally
                {
                    semaphore.release();
                    countDownLatch.countDown();
                }
            }).start();
        }

        countDownLatch.await();
    }
}
</code></pre>
<h2 id="33-原理分析">3.3. 原理分析</h2>
<h3 id="331-构造方法">3.3.1. 构造方法</h3>
<pre><code class="language-java">public Semaphore(int permits, boolean fair) {
    //公平用的是FairSync
    sync = fair ? new FairSync(permits) : new NonfairSync(permits);
}
</code></pre>
<h4 id="3311-公平sync">3.3.1.1. 公平Sync</h4>
<ul>
<li>FairSync</li>
</ul>
<pre><code class="language-java">static final class FairSync extends Sync {
    private static final long serialVersionUID = 2014338818796000944L;

    FairSync(int permits) {
        //Semaphore.Sync#Sync
        super(permits);
    }

    protected int tryAcquireShared(int acquires) {
        for (;;) {
            if (hasQueuedPredecessors())
                return -1;
            int available = getState();
            int remaining = available - acquires;
            if (remaining &lt; 0 ||
                compareAndSetState(available, remaining))
                return remaining;
        }
    }
}
</code></pre>
<ul>
<li>Sync</li>
</ul>
<pre><code class="language-java">abstract static class Sync extends AbstractQueuedSynchronizer {
    private static final long serialVersionUID = 1192457210091910933L;

    Sync(int permits) {
        //最终就是设置了permits个信号量
        setState(permits);
    }
}
</code></pre>
<h3 id="332-acquire">3.3.2. acquire</h3>
<pre><code class="language-java">public void acquire() throws InterruptedException {
    //AQS的acquireSharedInterruptibly
    sync.acquireSharedInterruptibly(1);
}
</code></pre>
<h4 id="3321-调用aqs加共享锁">3.3.2.1. 调用AQS加共享锁</h4>
<ul>
<li>AQS acquireSharedInterruptibly</li>
</ul>
<pre><code class="language-java">public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    //Semaphore.FairSync重写了tryAcquireShared
    //如果信号量不够那么返回负数，这里执行doAcquireSharedInterruptibly入AQS队,并且阻塞等待唤醒
    //如果信号量够的话返回&gt;=0的数，那么调用此acquire方法的代码就可以继续执行业务代码
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireSharedInterruptibly(arg);
}
</code></pre>
<h5 id="33211-尝试加锁公平队列前面有人排队那么直接返回失败">3.3.2.1.1. 尝试加锁【公平：队列前面有人排队那么直接返回失败】</h5>
<ul>
<li>Semaphore.FairSync#tryAcquireShared</li>
</ul>
<pre><code class="language-java">protected int tryAcquireShared(int acquires) {
    for (;;) {
        //如果队列中我的前面有人排队，那么返回-1
        if (hasQueuedPredecessors())
            return -1;
        //当前的信号量
        int available = getState();
        //当前的信号量够不够我获取？
        int remaining = available - acquires;
        //&lt;0表示不够的话返回这个数
        if (remaining &lt; 0 ||
             //&gt;=0说明够了，那么CAS修改剩余信号量
            compareAndSetState(available, remaining))
            return remaining;
    }
}
</code></pre>
<h3 id="333-release">3.3.3. release</h3>
<ul>
<li>Semaphore#release()</li>
</ul>
<pre><code class="language-java">public void release() {
    //AQS的releaseShared
    sync.releaseShared(1);
}
</code></pre>
<h4 id="3331-调用aqs释放共享锁">3.3.3.1. 调用AQS释放共享锁</h4>
<ul>
<li>AQS#releaseShared</li>
</ul>
<pre><code class="language-java">public final boolean releaseShared(int arg) {
    //Semaphore.Sync重写了tryReleaseShared
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
</code></pre>
<h5 id="33311-尝试释放共享锁">3.3.3.1.1. 尝试释放共享锁</h5>
<ul>
<li>Semaphore.Sync#tryReleaseShared</li>
</ul>
<pre><code class="language-java">protected final boolean tryReleaseShared(int releases) {
    for (;;) {
        //获取当前信号量
        int current = getState();
        //加回去
        int next = current + releases;
        //溢出则抛异常
        if (next &lt; current) // overflow
            throw new Error("Maximum permit count exceeded");
        //CAS修改信号量
        if (compareAndSetState(current, next))
            return true;
    }
}
</code></pre>
<h1 id="4-非公平信号量">4. 非公平信号量</h1>
<h2 id="41-是什么">4.1. 是什么</h2>
<p>限流，使用的非公平策略</p>
<h2 id="42-使用">4.2. 使用</h2>
<pre><code class="language-java">public class SemaphoreTest
{
    private final static int THREAD_COUNT = 100;
    private final static CountDownLatch countDownLatch = new CountDownLatch(THREAD_COUNT);

    public static void main(String[] args) throws InterruptedException
    {
        Semaphore semaphore = new Semaphore(10);

        for (int i = 0; i &lt; THREAD_COUNT; i++)
        {
            new Thread(()-&gt;{
                try
                {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + "正在访问资源。。。");
                    TimeUnit.SECONDS.sleep(3);

                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
                finally
                {
                    semaphore.release();
                    countDownLatch.countDown();
                }
            }).start();
        }

        countDownLatch.await();
    }
}
</code></pre>
<h2 id="43-原理分析">4.3. 原理分析</h2>
<h3 id="431-构造方法">4.3.1. 构造方法</h3>
<pre><code class="language-java">public Semaphore(int permits) {
    //创建的是非公平的Sync
    sync = new NonfairSync(permits);
}
</code></pre>
<h4 id="4311-非公平sync">4.3.1.1. 非公平Sync</h4>
<ul>
<li>NonfairSync</li>
</ul>
<pre><code class="language-java">static final class NonfairSync extends Sync {
    private static final long serialVersionUID = -2694183684443567898L;

    NonfairSync(int permits) {
        //调用Sync
        super(permits);
    }

    protected int tryAcquireShared(int acquires) {
        return nonfairTryAcquireShared(acquires);
    }
}
</code></pre>
<ul>
<li>Sync</li>
</ul>
<pre><code class="language-java">abstract static class Sync extends AbstractQueuedSynchronizer {
    private static final long serialVersionUID = 1192457210091910933L;

    Sync(int permits) {
        //最终就是设置了permits个信号量
        setState(permits);
    }
}
</code></pre>
<h3 id="432-acquire">4.3.2. acquire</h3>
<pre><code class="language-java">public void acquire() throws InterruptedException {
    //AQS的acquireSharedInterruptibly
    sync.acquireSharedInterruptibly(1);
}
</code></pre>
<h4 id="4321-调用aqs加共享锁">4.3.2.1. 调用AQS加共享锁</h4>
<ul>
<li>AQS acquireSharedInterruptibly</li>
</ul>
<pre><code class="language-java">public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    //Semaphore.NonfairSync重写了tryAcquireShared
    //如果信号量不够那么返回负数，这里执行doAcquireSharedInterruptibly入AQS队,并且阻塞等待唤醒
    //如果信号量够的话返回&gt;=0的数，那么调用此acquire方法的代码就可以继续执行业务代码
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireSharedInterruptibly(arg);
}
</code></pre>
<h5 id="43211-尝试加共享锁非公平不管队列前面是否有人我直接尝试加锁">4.3.2.1.1. 尝试加共享锁【非公平：不管队列前面是否有人我直接尝试加锁】</h5>
<ul>
<li>Semaphore.NonfairSync#tryAcquireShared</li>
</ul>
<pre><code class="language-java">protected int tryAcquireShared(int acquires) {
    return nonfairTryAcquireShared(acquires);
}
</code></pre>
<ul>
<li>Semaphore.Sync#nonfairTryAcquireShared</li>
</ul>
<pre><code class="language-java">final int nonfairTryAcquireShared(int acquires) {
    for (;;) {
        //当前的信号量
        int available = getState();
        //当前的信号量够不够我获取？
        int remaining = available - acquires;
        //&lt;0表示不够的话返回这个数
        if (remaining &lt; 0 ||
        //&gt;=0说明够了，那么CAS修改剩余信号量
            compareAndSetState(available, remaining))
            return remaining;
    }
}
</code></pre>
<h3 id="433-release">4.3.3. release</h3>
<ul>
<li>Semaphore#release()</li>
</ul>
<pre><code class="language-java">public void release() {
    //AQS的releaseShared
    sync.releaseShared(1);
}
</code></pre>
<h4 id="4331-调用aqs释放共享锁">4.3.3.1. 调用AQS释放共享锁</h4>
<ul>
<li>AQS#releaseShared</li>
</ul>
<pre><code class="language-java">public final boolean releaseShared(int arg) {
    //Semaphore.Sync重写了tryReleaseShared
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
</code></pre>
<h5 id="43311-尝试释放锁">4.3.3.1.1. 尝试释放锁</h5>
<ul>
<li>Semaphore.Sync#tryReleaseShared</li>
</ul>
<pre><code class="language-java">protected final boolean tryReleaseShared(int releases) {
    for (;;) {
        //获取当前信号量
        int current = getState();
        //加回去
        int next = current + releases;
        //溢出则抛异常
        if (next &lt; current) // overflow
            throw new Error("Maximum permit count exceeded");
        //CAS修改信号量
        if (compareAndSetState(current, next))
            return true;
    }
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-28 10:42">2025-06-28 10:41</span>&nbsp;
<a href="https://www.cnblogs.com/ThinkerQAQ">ThinkerQAQ</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18953367);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18953367', targetLink: 'https://www.cnblogs.com/ThinkerQAQ/p/18953367', title: 'Java源码分析系列笔记-18.Semaphore' })">举报</a>
</div>
        