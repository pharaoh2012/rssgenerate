
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjwblog/p/18677208" title="发布于 2025-01-18 08:10">
    <span role="heading" aria-level="2">threejs 实现镜面反射，只反射指定物体，背景透明</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div>一、背景</div>
<div>最近在做数字孪生项目，使用threejs渲染模型，UI要求地面反射建筑物，也就是模型要有倒影。</div>
<div>二、调研</div>
<div>在官网找到一个镜面反射的例子（<a href="https://threejs.org/examples/?q=refle#webgl_mirror" rel="noopener nofollow">https://threejs.org/examples/?q=refle#webgl_mirror</a>）</div>
<div>如图：</div>
<div><img src="https://img2024.cnblogs.com/blog/1459279/202501/1459279-20250117160109715-2141193577.png" alt="0" width="1012" height="597" data-media-type="image"></div>
<div>和UI要的功能类似，但有缺陷</div>
<div>1、反射出了地面上所有的元素，连天空盒都反射出来了，我只想反射建筑物</div>
<div>2、没反射的地方，有颜色，盖住了镜面平面下的内容</div>
<div>如图：</div>
<div><img src="https://img2024.cnblogs.com/blog/1459279/202501/1459279-20250117160109843-1978357182.png" alt="0" width="931" height="550" data-media-type="image"></div>
<div>三、如何只反射指定物体</div>
<div>通过阅读源码，我们发现在 Three.js 中，Reflector 类有一个 onBeforeRender 方法，我们可以称它为“渲染前回调”或“预渲染处理函数”。</div>
<div>如果能拿到这个钩子，在这个钩子里做过滤，问题就迎刃而解了。</div>
<div>但是，最怕有但是，但是这个方法没放出来，不能直接调，怎么办呢？</div>
<div>那就只能曲线救国，改它的方法！</div>
<div>如图：</div>
<div>&nbsp;</div>
<div><img src="https://img2024.cnblogs.com/blog/1459279/202501/1459279-20250117160109615-1114298113.png" alt="0" width="811" height="731" data-media-type="image"></div>
<div>解决方法，就是重写reflector对象的onBeforeRender方法</div>
<div>onBeforeRender方法传入一个 scene 对象，代表视图，也就是反射的内容，过滤scene，不需要的模型对象，隐藏掉（visible = false）</div>
<div>&nbsp;</div>
<div>效果如下：</div>
<div><img src="https://img2024.cnblogs.com/blog/1459279/202501/1459279-20250117160109734-1498722694.png" alt="0" width="921" height="533" data-media-type="image"></div>
<div>现在已经不反射天空盒了，只反射我想要的模型</div>
<div>但是，最怕有但是，但是不反射的地方变成黑色的了，修改镜面平面的材质透明度（opacity）不起效果，怎么办呢？</div>
<div>修改片元着色器。</div>
<div>四、修改片元着色器，使不反射的地方透明</div>
<div>reflector有shander属性，用于传入自定义着色器，着色器（Shader）是图形编程中的一个术语，指的是在图形处理单元（GPU）上运行的程序。这块涉及WebGL的知识，我不懂，不多言。</div>
<div data-theme="default" data-language="">
<div class="cnblogs_code">
<pre>Reflector.ReflectorShader =<span style="color: rgba(0, 0, 0, 1)"> {

    uniforms: {

        </span>'color'<span style="color: rgba(0, 0, 0, 1)">: {
            value: </span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">
        },

        </span>'tDiffuse'<span style="color: rgba(0, 0, 0, 1)">: {
            value: </span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">
        },

        </span>'textureMatrix'<span style="color: rgba(0, 0, 0, 1)">: {
            value: </span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">
        }

    },

    vertexShader: </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> glsl </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">`
        uniform mat4 textureMatrix;
        varying vec4 vUv;

        #include </span>&lt;common&gt;<span style="color: rgba(0, 0, 0, 1)">
        #include </span>&lt;logdepthbuf_pars_vertex&gt;

        <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> main() {

            vUv </span>= textureMatrix * vec4( position, 1.0<span style="color: rgba(0, 0, 0, 1)"> );

            gl_Position </span>= projectionMatrix * modelViewMatrix * vec4( position, 1.0<span style="color: rgba(0, 0, 0, 1)"> );

            #include </span>&lt;logdepthbuf_vertex&gt;<span style="color: rgba(0, 0, 0, 1)">

        }`,

    fragmentShader: </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> glsl </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">`
        uniform vec3 color;
        uniform sampler2D tDiffuse;
        varying vec4 vUv;

        #include </span>&lt;logdepthbuf_pars_fragment&gt;

        <span style="color: rgba(0, 0, 255, 1)">float</span> blendOverlay( <span style="color: rgba(0, 0, 255, 1)">float</span> base, <span style="color: rgba(0, 0, 255, 1)">float</span><span style="color: rgba(0, 0, 0, 1)"> blend ) {

            </span><span style="color: rgba(0, 0, 255, 1)">return</span>( base &lt; 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 -<span style="color: rgba(0, 0, 0, 1)"> blend ) ) );

        }

        vec3 blendOverlay( vec3 base, vec3 blend ) {

            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

        }

        </span><span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> main() {

            #include </span>&lt;logdepthbuf_fragment&gt;<span style="color: rgba(0, 0, 0, 1)">

            vec4 base </span>=<span style="color: rgba(0, 0, 0, 1)"> texture2DProj( tDiffuse, vUv );
            gl_FragColor </span>= vec4( blendOverlay( base.rgb, color ), 1.0<span style="color: rgba(0, 0, 0, 1)"> );

            #include </span>&lt;tonemapping_fragment&gt;<span style="color: rgba(0, 0, 0, 1)">
            #include </span>&lt;encodings_fragment&gt;<span style="color: rgba(0, 0, 0, 1)">

        }`
};</span></pre>
</div>
<p>&nbsp;</p>
</div>
<div>这是threejs源码，reflector类里定义的默认着色器，拷出来，改一下，再通过shader属性传进去。</div>
<div><img src="https://img2024.cnblogs.com/blog/1459279/202501/1459279-20250117160109602-599714205.png" alt="0" width="818" height="680" data-media-type="image"></div>
<div>&nbsp;</div>
<div>加上这三行代码即可</div>
<div>效果如图</div>
<div><img src="https://img2024.cnblogs.com/blog/1459279/202501/1459279-20250117160109798-1249412603.png" alt="0" width="915" height="607" data-media-type="image"></div>
<div>镜面平面透明了</div>
<div>五、如何调整镜面平面的透明度</div>
<div>刚才说了，调整镜面的透明度（opacity）已经不起效果了，我也不想细查为啥了</div>
<div>透明度也可以直接通过片元着色器修改</div>
<div><img src="https://img2024.cnblogs.com/blog/1459279/202501/1459279-20250117160109588-1453647710.png" alt="0" width="821" height="685" data-media-type="image"></div>
<div>把红框内值改了就行了，数值范围是0~1</div>
<div>改为0.4后，效果如图：</div>
<div><img src="https://img2024.cnblogs.com/blog/1459279/202501/1459279-20250117160109790-1378556002.png" alt="0" width="847" height="634" data-media-type="image"></div>
<div>&nbsp;</div>
<div>注意：要想让镜面平面透明，一定要把镜面材质的是否支持透明度属性改为true，也就是支持透明</div>
<div><img src="https://img2024.cnblogs.com/blog/1459279/202501/1459279-20250117160109555-1592630048.png" alt="0" width="288" height="44" data-media-type="image"></div>
<div><img src="https://img2024.cnblogs.com/blog/1459279/202501/1459279-20250117160109622-1948655335.png" alt="0" width="814" height="746" data-media-type="image"></div>
<div>完整代码如下</div>
<div data-theme="default" data-language="">
<div class="cnblogs_code">
<pre>import { Reflector } from 'three/examples/jsm/objects/Reflector.js'<span style="color: rgba(0, 0, 0, 1)">;
import { transparentMirrorShader } from </span>'../xxxx.js'

<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 创建镜面反射平面</span>
<span style="color: rgba(0, 0, 0, 1)">createMirrorPlane() {
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 创建一个圆形几何体</span>
    const radius = 640; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 圆的半径</span>
    const segments = 256; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 圆的细分数，细分越多圆形越平滑</span>
    const geometry = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> THREE.CircleGeometry(radius, segments);

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 创建 Reflector</span>
    const reflector = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Reflector(geometry, {
        color: </span>0x000000, <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置反射颜色</span>
        textureWidth: window.innerWidth * window.devicePixelRatio, <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 反射纹理宽度</span>
        textureHeight: window.innerHeight * window.devicePixelRatio, <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 反射纹理高度</span>
<span style="color: rgba(0, 0, 0, 1)">        shader: transparentMirrorShader,
        clipBias: </span>0.000 <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 裁剪偏移量</span>
<span style="color: rgba(0, 0, 0, 1)">    });

    const subModelNameList </span>= ['wall', '天空盒'<span style="color: rgba(0, 0, 0, 1)">]
    reflector.originOnBeforeRender </span>=<span style="color: rgba(0, 0, 0, 1)"> reflector.onBeforeRender;
    reflector.onBeforeRender </span>= <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> (renderer, scene, camera) {
        const scene1 </span>=<span style="color: rgba(0, 0, 0, 1)"> scene.clone();
        scene1.traverse(child </span>=&gt;<span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!child.isScene &amp;&amp; !child.isLight &amp;&amp; child.name &amp;&amp; subModelNameList.some(ele =&gt;<span style="color: rgba(0, 0, 0, 1)"> child.name.includes(ele))) {
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> (['wall'].some(ele =&gt;<span style="color: rgba(0, 0, 0, 1)"> child.name.includes(ele))) {
                    child.visible </span>= <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
                } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
                    child.visible </span>= <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
                }
            }
        });
        
        reflector.originOnBeforeRender(renderer, scene1, camera);
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置位置和旋转</span>
    reflector.position.set(0, -0.01, 0<span style="color: rgba(0, 0, 0, 1)">);
    reflector.rotation.x </span>= -Math.PI / 2<span style="color: rgba(0, 0, 0, 1)">;

    reflector.name </span>= '镜面反射平面'<span style="color: rgba(0, 0, 0, 1)">;

    reflector.material.transparent </span>= <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 添加到场景</span>
    <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.scene.add(reflector);
},</span></pre>
</div>
<div class="cnblogs_code">
<pre>export const transparentMirrorShader =<span style="color: rgba(0, 0, 0, 1)"> {
    uniforms: {
        </span>'color'<span style="color: rgba(0, 0, 0, 1)">: {
            value: </span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">
        },

        </span>'tDiffuse'<span style="color: rgba(0, 0, 0, 1)">: {
            value: </span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">
        },

        </span>'textureMatrix'<span style="color: rgba(0, 0, 0, 1)">: {
            value: </span><span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">
        }

    },

    vertexShader: </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> glsl </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">`
        uniform mat4 textureMatrix;
        varying vec4 vUv;

        #include </span>&lt;common&gt;<span style="color: rgba(0, 0, 0, 1)">
        #include </span>&lt;logdepthbuf_pars_vertex&gt;

        <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> main() {

            vUv </span>= textureMatrix * vec4( position, 1.0<span style="color: rgba(0, 0, 0, 1)"> );

            gl_Position </span>= projectionMatrix * modelViewMatrix * vec4( position, 1.0<span style="color: rgba(0, 0, 0, 1)"> );

            #include </span>&lt;logdepthbuf_vertex&gt;<span style="color: rgba(0, 0, 0, 1)">

        }`,

    fragmentShader: </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> glsl </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">`
        uniform vec3 color;
        uniform sampler2D tDiffuse;
        varying vec4 vUv;

        #include </span>&lt;logdepthbuf_pars_fragment&gt;

        <span style="color: rgba(0, 0, 255, 1)">float</span> blendOverlay( <span style="color: rgba(0, 0, 255, 1)">float</span> base, <span style="color: rgba(0, 0, 255, 1)">float</span><span style="color: rgba(0, 0, 0, 1)"> blend ) {

            </span><span style="color: rgba(0, 0, 255, 1)">return</span>( base &lt; 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 -<span style="color: rgba(0, 0, 0, 1)"> blend ) ) );

        }

        vec3 blendOverlay( vec3 base, vec3 blend ) {

            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

        }

        </span><span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> main() {

            #include </span>&lt;logdepthbuf_fragment&gt;<span style="color: rgba(0, 0, 0, 1)">

            vec4 base </span>=<span style="color: rgba(0, 0, 0, 1)"> texture2DProj( tDiffuse, vUv );

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 检查是否有有效的反射纹理，如果没有则透明</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (base.a &lt; 0.1<span style="color: rgba(0, 0, 0, 1)">) {
                discard;
            }

            gl_FragColor </span>= vec4( blendOverlay( base.rgb, color ), 1<span style="color: rgba(0, 0, 0, 1)"> );

            #include </span>&lt;tonemapping_fragment&gt;<span style="color: rgba(0, 0, 0, 1)">
            #include </span>&lt;encodings_fragment&gt;<span style="color: rgba(0, 0, 0, 1)">

        }`
}</span></pre>
</div>
</div>
<div>我是用立方体做例子，如果有实际模型，效果会更好一些。</div>
<div>欢迎指正。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
</div>
<div id="MySignature" role="contentinfo">
    云在青天水在瓶。
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5073340131203704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-18 08:13">2025-01-18 08:10</span>&nbsp;
<a href="https://www.cnblogs.com/mjwblog">不系舟178</a>&nbsp;
阅读(<span id="post_view_count">141</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18677208" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18677208);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18677208', targetLink: 'https://www.cnblogs.com/mjwblog/p/18677208', title: 'threejs 实现镜面反射，只反射指定物体，背景透明' })">举报</a>
</div>
        