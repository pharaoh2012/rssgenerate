
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhaoweiwei/p/18919130/cuda_vs2019" title="发布于 2025-06-16 17:21">
    <span role="heading" aria-level="2">VS2019+CUDA12.5入门</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        文章给出了在VS2019环境下cuda12.5的配置，并在文章最后给出了一个详细的例子
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>通常先装vs后装cuda，cuda会自动集成到vs中。而如果先装cuda，后装vs则需要进行额外的配置。</p>
<h1>1&nbsp;VS新建项目中增加CUDA选项</h1>
<p>1.1 关闭vs2019（如果已经打开）<br>1.2 检查CUDA安装路径C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.5\extras\visual_studio_integration\CudaProjectVsWizards下，是否存在VS集成扩展支持</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250608094614842-2102544462.png" alt="" width="727" height="156" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"><br>这里15对应Visual Studio 2017，16对应Visual Studio 2019，17对应Visual Studio 2022，如果不存在相应扩展，请参照1.3获取<br>1.3 运行cuda_12.5.0_555.85_windows.exewindows安装包，它首先会解压cuda，在解压路径cuda12.5\visual_studio_integration\CUDAVisualStudioIntegration\extras\visual_studio_integration\CudaProjectVsWizards下有3个文件夹，就是1.2需要的VS扩展支持<br>1.4 将对应VS2019的16文件夹下内容拷贝到C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\Common7\IDE\Extensions下的NVIDIA\CUDA 12.5 Wizards\12.5中</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250608095500180-618879282.png" alt="" width="786" height="207" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"><br>注意：上述三级文件夹NVIDIA\CUDA 12.5 Wizards\12.5可能需要手动创建，另外相依文件也可以不直接拷贝，而是通过创建链接的方式来进行<br>mklink /d "C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\Common7\IDE\Extensions\NVIDIA\CUDA 12.5 Wizards\12.5" "C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.5\extras\visual_studio_integration\CudaProjectVsWizards\16"</p>
<p>这个命令的作用是，对C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.5\extras\visual_studio_integration\CudaProjectVsWizards下的16文件夹创建一个符号链接（类似创建快捷方式），创建的符号链接位于第一步中新建的CUDA 112.5 Wizards文件夹，该符号链接名为12.5：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250608213507162-660505558.png" alt="" width="904" height="140" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"><br>1.5&nbsp;<code>Ctrl+S</code>打开搜索框，输入<code>command</code>，找到<code>Developer Command Prompt for VS 2019</code>，右键，选择<code>以管理员方式运行，运行以下命令：devenv.com /setup /nosetupvstemplates<br></code></p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250608213718084-52755433.png" alt="" width="581" height="323" loading="lazy"><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250608214038987-172492954.png" alt="" width="642" height="179" loading="lazy"><br>1.6 将C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.5\extras\visual_studio_integration\MSBuildExtensions中文件拷贝到C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\MSBuild\Microsoft\VC\v160\BuildCustomizations中<br>1.7&nbsp;重启Visual Studio 2019，这样在新建工程的时候就可以看到CUDA工程模板出现了。</p>
<p><em id="__mceDel"><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250608214202569-1826493820.png" alt="" width="747" height="496" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></em></p>
<p>1.8&nbsp;点击创建后就会进入如下界面。此时会生成一个模板<span class="words-blog hl-git-1" data-tit="kernel" data-pretit="kernel">kernel.cu文件。可以通过运行该文件来测试是否可以成功进行CUDA编程，如果编译通过，在命令行窗口中生成如下结果，说明编译成功。<br></span></p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250608220318180-1467456389.png" alt="" width="898" height="296" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<h1>2 关键概念</h1>
<h2>2.1&nbsp;global、device和host</h2>
<p>用host指代CPU及其内存，而用device指代GPU及其内存。<br>•	global：在device上执行，从host中调用（一些特定的GPU也可以从device上调用），返回类型必须是void，不支持可变参数，不能成为类成员函数。注意用__global__定义的kernel是异步的，这意味着host不会等待kernel执行完就执行下一步。<br>•	device：在device上执行，仅可以从device中调用，不可以和__global__同时用。<br>•	host：在host上执行，仅可以从host上调用，一般省略不写，不可以和__global__同时用，但可和__device__同时用，此时函数会在device和host都编译。</p>
<h2>2.2&nbsp;CUDA的整体结构</h2>
<p>kernel是在device上线程中并行执行的函数，核函数用__global__符号声明，在调用时需要用&lt;&lt;&lt;grid, block&gt;&gt;&gt;来指定kernel要运行的线程，在CUDA中，每一个线程都要执行核函数。kernel在device上执行时实际上是启动很多线程，一个kernel所启动的所有线程称为一个网格（grid），同一个网格上的线程共享相同的全局内存空间。每一个grid由多个block组成，每一个block由多个线程组成。<br><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250616172025072-1753586177.png" alt="" style="display: block; margin-left: auto; margin-right: auto">从上图可以看出每一个block可以组织成三维的，但其实block可以1维、2维或3维组织。Grid可以1维、2维组织。</p>
<h2>2.3&nbsp;CUDA内存模型</h2>
<p>如下图所示。可以看到，每个线程有自己的私有本地内存（Local Memory），而每个线程块有包含共享内存（Shared Memory），可以被线程块中所有线程共享，其生命周期与线程块一致。此外，所有的线程都可以访问全局内存（Global Memory）。还可以访问一些只读内存块：常量内存（Constant Memory）和纹理内存（Texture Memory）。<img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250616172025100-147150777.png" alt="" style="display: block; margin-left: auto; margin-right: auto">2.4&nbsp;Streaming Multiprocessor，SM</p>
<p>SM是GPU的处理器，SM可以并发地执行数百个线程。<br>•	当一个kernel被执行时，它的gird中的线程块被分配到SM上，一个线程块只能在一个SM上被调度。<br>•	SM一般可以调度多个线程块，一个kernel的各个线程块可能被分配多个SM。<br>•	当线程块被划分到某个SM上时，它将被进一步划分为多个线程束（一个线程束包含32个线程），因为这才是SM的基本执行单元，但是一个SM同时并发的线程束数是有限的。<br>•	由于SM的基本执行单元是包含32个线程的线程束，所以block大小一般要设置为32的倍数。<br>SM中包含多个SP，一个GPU可以有多个SM（比如16个），最终一个GPU可能包含有上千个SP。<br>每个线程由每个线程处理器（SP）执行，线程块由多核处理器（SM）执行，一个kernel其实由一个grid来执行，一个kernel一次只能在一个GPU上执行。<br><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250616172025069-1546795591.png" alt="" style="display: block; margin-left: auto; margin-right: auto">block是软件概念，一个block只会由一个sm调度，程序员在开发时，通过设定block的属性，告诉GPU硬件，我有多少个线程，线程怎么组织。而具体怎么调度由sm的warps scheduler负责，block一旦被分配好SM，该block就会一直驻留在该SM中，直到执行结束。一个SM可以同时拥有多个blocks，但需要序列执行。</p>
<h1>3 自己进行CUDA编程验证</h1>
<p><span class="words-blog hl-git-1" data-tit="kernel" data-pretit="kernel">&nbsp;以下程序给出了一个矩阵乘法的例子<br></span></p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_53058de0-ee33-457d-af57-d1b1a4eb111a" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_53058de0-ee33-457d-af57-d1b1a4eb111a" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_53058de0-ee33-457d-af57-d1b1a4eb111a" class="cnblogs_code_hide">
<pre><span style="color: rgba(0, 128, 128, 1)">  1</span> #include <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">cuda_runtime.h</span><span style="color: rgba(128, 0, 0, 1)">"</span>
<span style="color: rgba(0, 128, 128, 1)">  2</span> #include <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">device_launch_parameters.h</span><span style="color: rgba(128, 0, 0, 1)">"</span>
<span style="color: rgba(0, 128, 128, 1)">  3</span> 
<span style="color: rgba(0, 128, 128, 1)">  4</span> #include &lt;stdio.h&gt;
<span style="color: rgba(0, 128, 128, 1)">  5</span> #include &lt;iostream&gt;
<span style="color: rgba(0, 128, 128, 1)">  6</span> 
<span style="color: rgba(0, 128, 128, 1)">  7</span> <span style="color: rgba(0, 0, 255, 1)">#define</span> KB 1024
<span style="color: rgba(0, 128, 128, 1)">  8</span> <span style="color: rgba(0, 0, 255, 1)">#define</span> MB (1024*1024)
<span style="color: rgba(0, 128, 128, 1)">  9</span> 
<span style="color: rgba(0, 128, 128, 1)"> 10</span> <span style="color: rgba(0, 0, 255, 1)">using</span> <span style="color: rgba(0, 0, 255, 1)">namespace</span><span style="color: rgba(0, 0, 0, 1)"> std;
</span><span style="color: rgba(0, 128, 128, 1)"> 11</span> 
<span style="color: rgba(0, 128, 128, 1)"> 12</span> <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">int</span> Row = <span style="color: rgba(128, 0, 128, 1)">512</span>; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 行数</span>
<span style="color: rgba(0, 128, 128, 1)"> 13</span> <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">int</span> Col = <span style="color: rgba(128, 0, 128, 1)">512</span>; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 列数</span>
<span style="color: rgba(0, 128, 128, 1)"> 14</span> 
<span style="color: rgba(0, 128, 128, 1)"> 15</span> <span style="color: rgba(0, 0, 0, 1)">__global__
</span><span style="color: rgba(0, 128, 128, 1)"> 16</span> <span style="color: rgba(0, 0, 255, 1)">void</span> matrix_mul_gpu(<span style="color: rgba(0, 0, 255, 1)">int</span>* M, <span style="color: rgba(0, 0, 255, 1)">int</span>* N, <span style="color: rgba(0, 0, 255, 1)">int</span>* P, <span style="color: rgba(0, 0, 255, 1)">int</span> width) <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> width代表列数</span>
<span style="color: rgba(0, 128, 128, 1)"> 17</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 18</span>     <span style="color: rgba(0, 0, 255, 1)">int</span> i = threadIdx.x + blockDim.x * blockIdx.x; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 第i列的线程</span>
<span style="color: rgba(0, 128, 128, 1)"> 19</span>     <span style="color: rgba(0, 0, 255, 1)">int</span> j = threadIdx.y + blockDim.y * blockIdx.y; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 第j行的线程</span>
<span style="color: rgba(0, 128, 128, 1)"> 20</span> 
<span style="color: rgba(0, 128, 128, 1)"> 21</span>     <span style="color: rgba(0, 0, 255, 1)">int</span> sum = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 22</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> k = <span style="color: rgba(128, 0, 128, 1)">0</span>; k &lt; width; k++<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)"> 23</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)"> 24</span>         <span style="color: rgba(0, 0, 255, 1)">int</span> a = M[j * width + k]; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 第j行的某一个值</span>
<span style="color: rgba(0, 128, 128, 1)"> 25</span>         <span style="color: rgba(0, 0, 255, 1)">int</span> b = N[k * width + i]; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 第i列的某一个值</span>
<span style="color: rgba(0, 128, 128, 1)"> 26</span>         sum += a *<span style="color: rgba(0, 0, 0, 1)"> b;
</span><span style="color: rgba(0, 128, 128, 1)"> 27</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 28</span>     P[j * width + i] =<span style="color: rgba(0, 0, 0, 1)"> sum;
</span><span style="color: rgba(0, 128, 128, 1)"> 29</span> <span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 128, 128, 1)"> 30</span> 
<span style="color: rgba(0, 128, 128, 1)"> 31</span> <span style="color: rgba(0, 0, 255, 1)">void</span> matrix_mul_cpu(<span style="color: rgba(0, 0, 255, 1)">int</span>* M, <span style="color: rgba(0, 0, 255, 1)">int</span>* N, <span style="color: rgba(0, 0, 255, 1)">int</span>* P, <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> width)
</span><span style="color: rgba(0, 128, 128, 1)"> 32</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 33</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; width; i++<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)"> 34</span>         <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> j = <span style="color: rgba(128, 0, 128, 1)">0</span>; j &lt; width; j++<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)"> 35</span> <span style="color: rgba(0, 0, 0, 1)">        {
</span><span style="color: rgba(0, 128, 128, 1)"> 36</span>             <span style="color: rgba(0, 0, 255, 1)">int</span> sum = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 37</span>             <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> k = <span style="color: rgba(128, 0, 128, 1)">0</span>; k &lt; width; k++<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)"> 38</span> <span style="color: rgba(0, 0, 0, 1)">            {
</span><span style="color: rgba(0, 128, 128, 1)"> 39</span>                 <span style="color: rgba(0, 0, 255, 1)">int</span> a = M[i * width +<span style="color: rgba(0, 0, 0, 1)"> k];
</span><span style="color: rgba(0, 128, 128, 1)"> 40</span>                 <span style="color: rgba(0, 0, 255, 1)">int</span> b = N[k * width +<span style="color: rgba(0, 0, 0, 1)"> j];
</span><span style="color: rgba(0, 128, 128, 1)"> 41</span>                 sum += a *<span style="color: rgba(0, 0, 0, 1)"> b;
</span><span style="color: rgba(0, 128, 128, 1)"> 42</span> <span style="color: rgba(0, 0, 0, 1)">            }
</span><span style="color: rgba(0, 128, 128, 1)"> 43</span>             P[i * width + j] =<span style="color: rgba(0, 0, 0, 1)"> sum;
</span><span style="color: rgba(0, 128, 128, 1)"> 44</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)"> 45</span> <span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 128, 128, 1)"> 46</span> 
<span style="color: rgba(0, 128, 128, 1)"> 47</span> __host__ <span style="color: rgba(0, 0, 255, 1)">int</span> main(<span style="color: rgba(0, 0, 255, 1)">int</span> argc, <span style="color: rgba(0, 0, 255, 1)">char</span>*<span style="color: rgba(0, 0, 0, 1)"> argv[])
</span><span style="color: rgba(0, 128, 128, 1)"> 48</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 49</span>     <span style="color: rgba(0, 0, 255, 1)">int</span> devCount = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 50</span>     cudaError_t err = cudaGetDeviceCount(&amp;<span style="color: rgba(0, 0, 0, 1)">devCount);
</span><span style="color: rgba(0, 128, 128, 1)"> 51</span>     <span style="color: rgba(0, 0, 255, 1)">if</span> (err !=<span style="color: rgba(0, 0, 0, 1)"> cudaSuccess)
</span><span style="color: rgba(0, 128, 128, 1)"> 52</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)"> 53</span>         printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">CUDA error: '%s'.  You probably don't have Nvidia CUDA drivers installed or don't have any cards.\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, cudaGetErrorName(err));
</span><span style="color: rgba(0, 128, 128, 1)"> 54</span>         <span style="color: rgba(0, 0, 255, 1)">return</span> -<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 55</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 56</span>     printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">%d CUDA Devices found:\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, devCount);
</span><span style="color: rgba(0, 128, 128, 1)"> 57</span> 
<span style="color: rgba(0, 128, 128, 1)"> 58</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; devCount; ++<span style="color: rgba(0, 0, 0, 1)">i)
</span><span style="color: rgba(0, 128, 128, 1)"> 59</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)"> 60</span> <span style="color: rgba(0, 0, 0, 1)">        cudaDeviceProp props;
</span><span style="color: rgba(0, 128, 128, 1)"> 61</span>         cudaGetDeviceProperties(&amp;<span style="color: rgba(0, 0, 0, 1)">props, i);
</span><span style="color: rgba(0, 128, 128, 1)"> 62</span>         printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">%d: %s\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, i, props.name);
</span><span style="color: rgba(0, 128, 128, 1)"> 63</span>         printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">  Compute Capability: %d.%d\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, props.major, props.minor);
</span><span style="color: rgba(0, 128, 128, 1)"> 64</span>         cout &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">  Global memory:   </span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; props.totalGlobalMem / MB &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">mb</span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt;<span style="color: rgba(0, 0, 0, 1)"> endl;
</span><span style="color: rgba(0, 128, 128, 1)"> 65</span>         cout &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">  Shared memory:   </span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; props.sharedMemPerBlock / KB &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">kb</span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt;<span style="color: rgba(0, 0, 0, 1)"> endl;
</span><span style="color: rgba(0, 128, 128, 1)"> 66</span>         cout &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">  Constant memory: </span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; props.totalConstMem / KB &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">kb</span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt;<span style="color: rgba(0, 0, 0, 1)"> endl;
</span><span style="color: rgba(0, 128, 128, 1)"> 67</span>         cout &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">  Block registers: </span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; props.regsPerBlock &lt;&lt; endl &lt;&lt;<span style="color: rgba(0, 0, 0, 1)"> endl;
</span><span style="color: rgba(0, 128, 128, 1)"> 68</span> 
<span style="color: rgba(0, 128, 128, 1)"> 69</span>         cout &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">  Warp size:         </span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; props.warpSize &lt;&lt;<span style="color: rgba(0, 0, 0, 1)"> endl;
</span><span style="color: rgba(0, 128, 128, 1)"> 70</span>         cout &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">  Threads per block: </span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; props.maxThreadsPerBlock &lt;&lt;<span style="color: rgba(0, 0, 0, 1)"> endl;
</span><span style="color: rgba(0, 128, 128, 1)"> 71</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> I think this is a virtual result, not the real hardware
</span><span style="color: rgba(0, 128, 128, 1)"> 72</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> printf("  Max blocks per multiprocessor: %lu\n",props.maxBlocksPerMultiProcessor);</span>
<span style="color: rgba(0, 128, 128, 1)"> 73</span>         cout &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">  Num multiprocessors: </span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; props.multiProcessorCount &lt;&lt;<span style="color: rgba(0, 0, 0, 1)"> endl;
</span><span style="color: rgba(0, 128, 128, 1)"> 74</span>         cout &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">  maxThreadsPerMultiProcessor: </span><span style="color: rgba(128, 0, 0, 1)">"</span> &lt;&lt; props.maxThreadsPerMultiProcessor &lt;&lt;<span style="color: rgba(0, 0, 0, 1)"> endl;
</span><span style="color: rgba(0, 128, 128, 1)"> 75</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> I think these are virtual dimensions
</span><span style="color: rgba(0, 128, 128, 1)"> 76</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> cout &lt;&lt; "  Max block dimensions: [ " &lt;&lt; props.maxThreadsDim[0] &lt;&lt; ", " &lt;&lt; props.maxThreadsDim[1]  &lt;&lt; ", " &lt;&lt; props.maxThreadsDim[2] &lt;&lt; " ]" &lt;&lt; endl;
</span><span style="color: rgba(0, 128, 128, 1)"> 77</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> cout &lt;&lt; "  Max grid dimensions:  [ " &lt;&lt; props.maxGridSize[0] &lt;&lt; ", " &lt;&lt; props.maxGridSize[1]  &lt;&lt; ", " &lt;&lt; props.maxGridSize[2] &lt;&lt; " ]" &lt;&lt; endl;</span>
<span style="color: rgba(0, 128, 128, 1)"> 78</span>         cout &lt;&lt;<span style="color: rgba(0, 0, 0, 1)"> endl;
</span><span style="color: rgba(0, 128, 128, 1)"> 79</span> 
<span style="color: rgba(0, 128, 128, 1)"> 80</span>         printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Max threads per block: %d\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, props.maxThreadsPerBlock);
</span><span style="color: rgba(0, 128, 128, 1)"> 81</span>         printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Max threads in x dimension: %d\n</span><span style="color: rgba(128, 0, 0, 1)">"</span>, props.maxThreadsDim[<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">]);
</span><span style="color: rgba(0, 128, 128, 1)"> 82</span>         printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Max threads in y dimension: %d\n</span><span style="color: rgba(128, 0, 0, 1)">"</span>, props.maxThreadsDim[<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">]);
</span><span style="color: rgba(0, 128, 128, 1)"> 83</span>         printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Max threads in z dimension: %d\n</span><span style="color: rgba(128, 0, 0, 1)">"</span>, props.maxThreadsDim[<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">]);
</span><span style="color: rgba(0, 128, 128, 1)"> 84</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 85</span> 
<span style="color: rgba(0, 128, 128, 1)"> 86</span> <span style="color: rgba(0, 0, 0, 1)">    clock_t GPUstart, GPUend;
</span><span style="color: rgba(0, 128, 128, 1)"> 87</span> 
<span style="color: rgba(0, 128, 128, 1)"> 88</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 选择第一个GPU为默认</span>
<span style="color: rgba(0, 128, 128, 1)"> 89</span>     err = cudaSetDevice(<span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 90</span>     <span style="color: rgba(0, 0, 255, 1)">if</span> (err !=<span style="color: rgba(0, 0, 0, 1)"> cudaSuccess) {
</span><span style="color: rgba(0, 128, 128, 1)"> 91</span>         printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">cudaSetDevice failed please check\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)"> 92</span>         <span style="color: rgba(0, 0, 255, 1)">return</span> -<span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)"> 93</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)"> 94</span>     <span style="color: rgba(0, 0, 255, 1)">int</span>* A = (<span style="color: rgba(0, 0, 255, 1)">int</span>*)<span style="color: rgba(0, 0, 255, 1)">malloc</span>(<span style="color: rgba(0, 0, 255, 1)">sizeof</span>(<span style="color: rgba(0, 0, 255, 1)">int</span>) * Row *<span style="color: rgba(0, 0, 0, 1)"> Col);
</span><span style="color: rgba(0, 128, 128, 1)"> 95</span>     <span style="color: rgba(0, 0, 255, 1)">int</span>* B = (<span style="color: rgba(0, 0, 255, 1)">int</span>*)<span style="color: rgba(0, 0, 255, 1)">malloc</span>(<span style="color: rgba(0, 0, 255, 1)">sizeof</span>(<span style="color: rgba(0, 0, 255, 1)">int</span>) * Row *<span style="color: rgba(0, 0, 0, 1)"> Col);
</span><span style="color: rgba(0, 128, 128, 1)"> 96</span>     <span style="color: rgba(0, 0, 255, 1)">int</span>* C = (<span style="color: rgba(0, 0, 255, 1)">int</span>*)<span style="color: rgba(0, 0, 255, 1)">malloc</span>(<span style="color: rgba(0, 0, 255, 1)">sizeof</span>(<span style="color: rgba(0, 0, 255, 1)">int</span>) * Row *<span style="color: rgba(0, 0, 0, 1)"> Col);
</span><span style="color: rgba(0, 128, 128, 1)"> 97</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">malloc device memory</span>
<span style="color: rgba(0, 128, 128, 1)"> 98</span>     <span style="color: rgba(0, 0, 255, 1)">int</span>* d_dataA, * d_dataB, *<span style="color: rgba(0, 0, 0, 1)"> d_dataC;
</span><span style="color: rgba(0, 128, 128, 1)"> 99</span>     cudaMalloc((<span style="color: rgba(0, 0, 255, 1)">void</span>**)&amp;d_dataA, <span style="color: rgba(0, 0, 255, 1)">sizeof</span>(<span style="color: rgba(0, 0, 255, 1)">int</span>) * Row *<span style="color: rgba(0, 0, 0, 1)"> Col);
</span><span style="color: rgba(0, 128, 128, 1)">100</span>     cudaMalloc((<span style="color: rgba(0, 0, 255, 1)">void</span>**)&amp;d_dataB, <span style="color: rgba(0, 0, 255, 1)">sizeof</span>(<span style="color: rgba(0, 0, 255, 1)">int</span>) * Row *<span style="color: rgba(0, 0, 0, 1)"> Col);
</span><span style="color: rgba(0, 128, 128, 1)">101</span>     cudaMalloc((<span style="color: rgba(0, 0, 255, 1)">void</span>**)&amp;d_dataC, <span style="color: rgba(0, 0, 255, 1)">sizeof</span>(<span style="color: rgba(0, 0, 255, 1)">int</span>) * Row *<span style="color: rgba(0, 0, 0, 1)"> Col);
</span><span style="color: rgba(0, 128, 128, 1)">102</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">set value</span>
<span style="color: rgba(0, 128, 128, 1)">103</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; Row * Col; i++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">104</span>         A[i] = <span style="color: rgba(128, 0, 128, 1)">90</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">105</span>         B[i] = <span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">106</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">107</span> 
<span style="color: rgba(0, 128, 128, 1)">108</span>     GPUstart =<span style="color: rgba(0, 0, 0, 1)"> clock();
</span><span style="color: rgba(0, 128, 128, 1)">109</span>     cudaMemcpy(d_dataA, A, <span style="color: rgba(0, 0, 255, 1)">sizeof</span>(<span style="color: rgba(0, 0, 255, 1)">int</span>) * Row *<span style="color: rgba(0, 0, 0, 1)"> Col, cudaMemcpyHostToDevice);
</span><span style="color: rgba(0, 128, 128, 1)">110</span>     cudaMemcpy(d_dataB, B, <span style="color: rgba(0, 0, 255, 1)">sizeof</span>(<span style="color: rgba(0, 0, 255, 1)">int</span>) * Row *<span style="color: rgba(0, 0, 0, 1)"> Col, cudaMemcpyHostToDevice);
</span><span style="color: rgba(0, 128, 128, 1)">111</span>     dim3 threadPerBlock(<span style="color: rgba(128, 0, 128, 1)">16</span>, <span style="color: rgba(128, 0, 128, 1)">16</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">112</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> (Col + threadPerBlock.x - 1)/threadPerBlock.x=Col/threadPerBlock.x+1，即多拿一个block来装不能整除的部分</span>
<span style="color: rgba(0, 128, 128, 1)">113</span>     dim3 blockNumber((Col + threadPerBlock.x - <span style="color: rgba(128, 0, 128, 1)">1</span>) / threadPerBlock.x, (Row + threadPerBlock.y - <span style="color: rgba(128, 0, 128, 1)">1</span>) /<span style="color: rgba(0, 0, 0, 1)"> threadPerBlock.y);
</span><span style="color: rgba(0, 128, 128, 1)">114</span>     printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Block(%d,%d)   Grid(%d,%d).\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, threadPerBlock.x, threadPerBlock.y, blockNumber.x, blockNumber.y);
</span><span style="color: rgba(0, 128, 128, 1)">115</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 每一个线程进行某行乘某列的计算，得到结果中的一个元素。也就是d_dataC中的每一个计算结果都和GPU中线程的布局&lt;blockNumber, threadPerBlock &gt;一致</span>
<span style="color: rgba(0, 128, 128, 1)">116</span>     matrix_mul_gpu &lt;&lt; &lt;blockNumber, threadPerBlock &gt;&gt; &gt;<span style="color: rgba(0, 0, 0, 1)"> (d_dataA, d_dataB, d_dataC, Col);
</span><span style="color: rgba(0, 128, 128, 1)">117</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">拷贝计算数据-一级数据指针</span>
<span style="color: rgba(0, 128, 128, 1)">118</span>     cudaMemcpy(C, d_dataC, <span style="color: rgba(0, 0, 255, 1)">sizeof</span>(<span style="color: rgba(0, 0, 255, 1)">int</span>) * Row *<span style="color: rgba(0, 0, 0, 1)"> Col, cudaMemcpyDeviceToHost);
</span><span style="color: rgba(0, 128, 128, 1)">119</span> 
<span style="color: rgba(0, 128, 128, 1)">120</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">释放内存</span>
<span style="color: rgba(0, 128, 128, 1)">121</span>     <span style="color: rgba(0, 0, 255, 1)">free</span><span style="color: rgba(0, 0, 0, 1)">(A);
</span><span style="color: rgba(0, 128, 128, 1)">122</span>     <span style="color: rgba(0, 0, 255, 1)">free</span><span style="color: rgba(0, 0, 0, 1)">(B);
</span><span style="color: rgba(0, 128, 128, 1)">123</span>     <span style="color: rgba(0, 0, 255, 1)">free</span><span style="color: rgba(0, 0, 0, 1)">(C);
</span><span style="color: rgba(0, 128, 128, 1)">124</span> <span style="color: rgba(0, 0, 0, 1)">    cudaFree(d_dataA);
</span><span style="color: rgba(0, 128, 128, 1)">125</span> <span style="color: rgba(0, 0, 0, 1)">    cudaFree(d_dataB);
</span><span style="color: rgba(0, 128, 128, 1)">126</span> <span style="color: rgba(0, 0, 0, 1)">    cudaFree(d_dataC);
</span><span style="color: rgba(0, 128, 128, 1)">127</span> 
<span style="color: rgba(0, 128, 128, 1)">128</span>     GPUend =<span style="color: rgba(0, 0, 0, 1)"> clock();
</span><span style="color: rgba(0, 128, 128, 1)">129</span>     <span style="color: rgba(0, 0, 255, 1)">int</span> GPUtime = GPUend -<span style="color: rgba(0, 0, 0, 1)"> GPUstart;
</span><span style="color: rgba(0, 128, 128, 1)">130</span>     printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">GPU运行时间：%d\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, GPUtime);
</span><span style="color: rgba(0, 128, 128, 1)">131</span> 
<span style="color: rgba(0, 128, 128, 1)">132</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> CPU计算</span>
<span style="color: rgba(0, 128, 128, 1)">133</span> <span style="color: rgba(0, 0, 0, 1)">    clock_t CPUstart, CPUend;
</span><span style="color: rgba(0, 128, 128, 1)">134</span> 
<span style="color: rgba(0, 128, 128, 1)">135</span>     <span style="color: rgba(0, 0, 255, 1)">int</span>* A2 = (<span style="color: rgba(0, 0, 255, 1)">int</span>*)<span style="color: rgba(0, 0, 255, 1)">malloc</span>(<span style="color: rgba(0, 0, 255, 1)">sizeof</span>(<span style="color: rgba(0, 0, 255, 1)">int</span>) * Row *<span style="color: rgba(0, 0, 0, 1)"> Col);
</span><span style="color: rgba(0, 128, 128, 1)">136</span>     <span style="color: rgba(0, 0, 255, 1)">int</span>* B2 = (<span style="color: rgba(0, 0, 255, 1)">int</span>*)<span style="color: rgba(0, 0, 255, 1)">malloc</span>(<span style="color: rgba(0, 0, 255, 1)">sizeof</span>(<span style="color: rgba(0, 0, 255, 1)">int</span>) * Row *<span style="color: rgba(0, 0, 0, 1)"> Col);
</span><span style="color: rgba(0, 128, 128, 1)">137</span>     <span style="color: rgba(0, 0, 255, 1)">int</span>* C2 = (<span style="color: rgba(0, 0, 255, 1)">int</span>*)<span style="color: rgba(0, 0, 255, 1)">malloc</span>(<span style="color: rgba(0, 0, 255, 1)">sizeof</span>(<span style="color: rgba(0, 0, 255, 1)">int</span>) * Row *<span style="color: rgba(0, 0, 0, 1)"> Col);
</span><span style="color: rgba(0, 128, 128, 1)">138</span> 
<span style="color: rgba(0, 128, 128, 1)">139</span>     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">set value</span>
<span style="color: rgba(0, 128, 128, 1)">140</span>     <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; Row * Col; i++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">141</span>         A2[i] = <span style="color: rgba(128, 0, 128, 1)">90</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">142</span>         B2[i] = <span style="color: rgba(128, 0, 128, 1)">10</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">143</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">144</span> 
<span style="color: rgba(0, 128, 128, 1)">145</span>     CPUstart =<span style="color: rgba(0, 0, 0, 1)"> clock();
</span><span style="color: rgba(0, 128, 128, 1)">146</span> <span style="color: rgba(0, 0, 0, 1)">    matrix_mul_cpu(A2, B2, C2, Col);
</span><span style="color: rgba(0, 128, 128, 1)">147</span>     CPUend =<span style="color: rgba(0, 0, 0, 1)"> clock();
</span><span style="color: rgba(0, 128, 128, 1)">148</span>     <span style="color: rgba(0, 0, 255, 1)">int</span> CPUtime = CPUend -<span style="color: rgba(0, 0, 0, 1)"> CPUstart;
</span><span style="color: rgba(0, 128, 128, 1)">149</span>     printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">CPU运行时间：%d\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, CPUtime);
</span><span style="color: rgba(0, 128, 128, 1)">150</span>     printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">加速比为：%lf\n</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(0, 0, 255, 1)">double</span>(CPUtime) /<span style="color: rgba(0, 0, 0, 1)"> GPUtime);
</span><span style="color: rgba(0, 128, 128, 1)">151</span> 
<span style="color: rgba(0, 128, 128, 1)">152</span>     <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">153</span> }</pre>
</div>
<span class="cnblogs_code_collapse">cuda sample</span></div>
<p>程序运行结果如下，可见GPU可以大大加速矩阵乘法运算过程。</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250616171559136-802471459.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<p>参考：<br><a href="https://blog.csdn.net/Sakuya__/article/details/140867143" target="_blank" rel="noopener nofollow">https://blog.csdn.net/Sakuya__/article/details/140867143<br>https://blog.csdn.net/weixin_39591031/article/details/124462430<br>https://blog.csdn.net/weixin_43610114/article/details/129905558<br>https://www.cnblogs.com/codingbigdog/p/16522384.html<br></a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-16 17:21">2025-06-16 17:21</span>&nbsp;
<a href="https://www.cnblogs.com/zhaoweiwei">weiwei22844</a>&nbsp;
阅读(<span id="post_view_count">91</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18919130);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18919130', targetLink: 'https://www.cnblogs.com/zhaoweiwei/p/18919130/cuda_vs2019', title: 'VS2019+CUDA12.5入门' })">举报</a>
</div>
        