
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/smileZAZ/p/18584897" title="发布于 2024-12-03 19:22">
    <span role="heading" aria-level="2">获取剪切板的图片 -&gt; File -&gt; Base64 -&gt; Blob -&gt; url -&gt; Image，以及它们之间的各种相互转换</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1 data-id="heading-0">🧑‍💻 写在开头</h1>
<p>点赞 + 收藏 === 学会🤣🤣🤣</p>
<h4 data-id="heading-0">一、获取剪切板的图片（拿到 File 对象）</h4>
<p><a title="https://cloud.tencent.com/developer/article/1093605?from=information.detail.clipboarddata%E5%AF%B9%E8%B1%A1" href="https://link.juejin.cn/?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1093605%3Ffrom%3Dinformation.detail.clipboarddata%25E5%25AF%25B9%25E8%25B1%25A1" target="_blank" rel="noopener nofollow">js粘贴事件paste简单解析及遇到的坑 - 云+社区 - 腾讯云 (tencent.com)</a></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">document.addEventListener('paste', function(event) {
    let items = event.clipboardData &amp;&amp; event.clipboardData.items;
    let file: any = null;
    if (items &amp;&amp; items.length) {
        // 检索剪切板items
        for (var i = 0; i &lt; items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                file = items[i].getAsFile();
                break;
            }
        }
    }
    fileByBase64(file, (base64) =&gt; {
        shotCallback(base64);
    });
    console.log('file', file);
    // 此时file就是剪切板中的图片文件
});</pre>
</div>
<div>
<div>
<p>本来想直接获取这个对象的，然鹅这个 clipboardData 对象只存在于 ClipboardEvent 事件中，只能在事件（这里是 parse 事件）触发的时候才能拿到。</p>
<p><a title="https://developer.mozilla.org/zh-CN/docs/Web/API/ClipboardEvent/clipboardData" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FClipboardEvent%2FclipboardData" target="_blank" rel="noopener nofollow">ClipboardEvent.clipboardData - Web API 接口参考 | MDN (mozilla.org)</a></p>
<h4 data-id="heading-1">题外话：可以直接用 navigator.clipboard 获取到剪切板内容（拿到 Blob 对象）</h4>
<p><a title="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/clipboard" href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FNavigator%2Fclipboard" target="_blank" rel="noopener nofollow">Navigator.clipboard - Web API 接口参考 | MDN (mozilla.org)</a></p>
<p><a title="http://www.ruanyifeng.com/blog/2021/01/clipboard-api.html" href="https://link.juejin.cn?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2021%2F01%2Fclipboard-api.html" target="_blank" rel="noopener nofollow">剪贴板操作 Clipboard API 教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
</div>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">const getClipboard = async () =&gt; {
    const clipboardItems = await navigator.clipboard.read();
    for (const clipboardItem of clipboardItems) {
        for (const type of clipboardItem.types) {
            const blob = await clipboardItem.getType(type);
            console.log(URL.createObjectURL(blob));
        }
    }
};</pre>
</div>
<h4 data-id="heading-2">二、File 对象转 Base64（利用 FileReader）</h4>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">const fileByBase64 = (file, callback) =&gt; {
    const reader = new FileReader();
    // 传入一个参数对象即可得到基于该参数对象的文本内容
    reader.readAsDataURL(file);
    reader.onload = function(e: any) {
        // target.result 该属性表示目标对象的 DataURL
        console.log(e.target.result);
        callback(e.target.result);
    };
};</pre>
</div>
<h4 data-id="heading-3">题外话 canvas -&gt; dataUrl(Base64)</h4>
<p>才发现 Base64 是 DataUrl 的编码，可以理解为一种东西吧。</p>
<p>canvas 对象可以直接转变成 base64，有一个很常用的 api：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">const dataURL = canvas.toDataURL();</pre>
</div>
<h4 data-id="heading-4">三、Base64 转 Blob</h4>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">const base64ByBlob = (base64, callback) =&gt; {
    let arr = base64.split(','),
        mime = arr[0].match(/:(.*?);/)[1],
        bstr = atob(arr[1]),
        n = bstr.length,
        u8arr = new Uint8Array(n);
    while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
    }
    console.log(new Blob([u8arr], { type: mime }));
    callback(new Blob([u8arr], { type: mime }));
};</pre>
</div>
<h4 data-id="heading-5">题外话：Blob -&gt; Base64（利用 FileReader）</h4>
<p>由于 File 是特殊类型的 Blob，所以跟 File -&gt; Base64 是一样的。</p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">function blobToDataURI(blob, callback) {
    var reader = new FileReader();
    reader.onload = function (e) {
        callback(e.target?.result);
    };
    reader.readAsDataURL(blob);
}</pre>
</div>
<h4 data-id="heading-6">题外话：File &lt;--&gt; Blob</h4>
<p>它俩可以用构造函数直接相互转换，没有中间商 Base64。不过 file -&gt; blob 会丢失 filename。</p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">const blob = new Blob([file], {
	type: file.type
}</pre>
</div>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">const file = new File([blob], filename, {
	type: blob.type
});</pre>
</div>
<h4 data-id="heading-7">四、blob 转 url、file 转 url</h4>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">const url1 = window.URL.createObjectURL(blob);
const url2 = window.URL.createObjectURL(file);</pre>
</div>
<p>这里的 file 会被当做 blob 对象来使用，毕竟 file 是特殊的 blob，所以输出结果都是：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">blob:http://localhost:3000/1df14e9d-b9d3-43d5-87ff-2f7c0ae44a9d</pre>
</div>
<p>这种由 blob:http:// 开头的路径。</p>
<h4 data-id="heading-8">题外话：url -&gt; blob</h4>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">const urlToBlob = () =&gt; {
	fetch(url)
		.then((res) =&gt; res.blob())
		.then((blob) =&gt; console.log(blob));
};</pre>
</div>
<h4 data-id="heading-9">五、url 变 Image</h4>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">const img = new Image();
img.src = url;</pre>
</div>
<h3 data-id="heading-10">综合应用：获取剪切板图片并转成 Base64，然后 Base64 转成 Blob，然后 Blob 转成 url，然后转成图片 append 到 body 上</h3>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">document.addEventListener('paste', function(event) {
    let items = event.clipboardData &amp;&amp; event.clipboardData.items;
    console.log('items', items);
    let file: any = null;
    if (items &amp;&amp; items.length) {
        // 检索剪切板 items
        for (var i = 0; i &lt; items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                // 此时file就是剪切板中的图片文件
                file = items[i].getAsFile();
                break;
            }
        }
    }
    fileByBase64(file, base64 =&gt; {
        base64ByBlob(base64, (blob) =&gt; {
            const url = window.URL.createObjectURL(blob);
            console.log('url', url);
            const img = new Image();
            img.src = url;
            img.onload = () =&gt; {
                document.body.appendChild(img);
            };
        });
    });
});</pre>
</div>
<p>如果不需要额外使用 Base64 的话，直接用 file 对象替代 blob 也是可以的，因为 file 只是特殊的 blob，大家都是二进制文件：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">document.addEventListener('paste', function(event) {
    let items = event.clipboardData &amp;&amp; event.clipboardData.items;
    console.log('items', items);
    let file: any = null;
    if (items &amp;&amp; items.length) {
        // 检索剪切板 items
        for (var i = 0; i &lt; items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                // 此时file就是剪切板中的图片文件
                file = items[i].getAsFile();
                break;
            }
        }
    }
    const url = window.URL.createObjectURL(file);
    console.log('url', url);
    const img = new Image();
    img.src = url;
    img.onload = () =&gt; {
        document.body.appendChild(img);
    };
});</pre>
</div>
<h3 id="tid-D8HBxE">如果对您有所帮助，欢迎您点个关注，我会定时更新技术文档，大家一起讨论学习，一起进步。</h3>
<p>&nbsp;<a href="https://img2020.cnblogs.com/blog/2149129/202107/2149129-20210719144042684-15122820.jpg" data-fancybox="gallery"><img src="https://img2020.cnblogs.com/blog/2149129/202107/2149129-20210719144042684-15122820.jpg" width="212" height="209"></a></p>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="40.87775872998264" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-03 19:22">2024-12-03 19:22</span>&nbsp;
<a href="https://www.cnblogs.com/smileZAZ">林恒</a>&nbsp;
阅读(<span id="post_view_count">110</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18584897" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18584897);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18584897', targetLink: 'https://www.cnblogs.com/smileZAZ/p/18584897', title: '获取剪切板的图片 -&amp;gt; File -&amp;gt; Base64 -&amp;gt; Blob -&amp;gt; url -&amp;gt; Image，以及它们之间的各种相互转换' })">举报</a>
</div>
        