
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aemmprty/p/19007615" title="发布于 2025-07-27 17:41">
    <span role="heading" aria-level="2">[ROI 2023] 峰值 (Day 1)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="_"><span class="math inline">\(\mathbf{Part. -1}\)</span></h3>
<p>翻译自 <a href="https://neerc.ifmo.ru/school/archive/2022-2023/ru-olymp-roi-2023-day1.pdf" target="_blank" rel="noopener nofollow">ROI 2023 D1T3</a>。</p>
<p>如果对于所有 <span class="math inline">\(1 \le j &lt; i\)</span>，都有 <span class="math inline">\(a_j &lt; a_i\)</span>，则称 <span class="math inline">\(a_i\)</span> 为峰值。</p>
<p>如果对于所有 <span class="math inline">\(1 \le j &lt; i\)</span>，都有 <span class="math inline">\(a_j &gt; a_i\)</span>，则称 <span class="math inline">\(a_i\)</span> 为反峰值。</p>
<p>给定大小为 <span class="math inline">\(n\)</span> 的排列 <span class="math inline">\(p_1,p_2,\dots,p_n\)</span>。需要将其分为两个非空子序列 <span class="math inline">\(q\)</span> 和 <span class="math inline">\(r\)</span>。每个元素 <span class="math inline">\(p\)</span> 必须恰好被分到一个子序列中。你需要最大化 <span class="math inline">\(q\)</span> 中的峰值数量和 <span class="math inline">\(r\)</span> 中的反峰值数量之和。</p>
<p><span class="math inline">\(1 \leq n \leq 2 \times 10^5\)</span>。</p>
<h3 id="_-1"><span class="math inline">\(\mathbf{Part. 1}\)</span></h3>
<p>我们按顺序考虑每一个 <span class="math inline">\(a_i\)</span>。由于我们要把序列划分成两个子序列，分别是递增和递减，所以我们定义 <span class="math inline">\(mx\)</span> 表示当前考虑到第 <span class="math inline">\(i\)</span> 个数的递增序列中最后一个值，<span class="math inline">\(mn\)</span> 表示当前考虑到第 <span class="math inline">\(i\)</span> 个数的递减序列中最后一个值。显然，我们可以通过储存这两个值来进行 DP。设 <span class="math inline">\(f_{i, mx, mn}\)</span> 表示当前考虑到第 <span class="math inline">\(i\)</span> 个数的 <span class="math inline">\(mx\)</span> 和 <span class="math inline">\(mn\)</span> 值，则转移是朴素的。</p>
<p>我们想要更快的算法，于是我们考虑研究 DP 转移的过程（也是按顺序对 <span class="math inline">\(a_i\)</span> 分配的过程）。对于每一个数 <span class="math inline">\(a_i\)</span>，当前的 <span class="math inline">\(mx,mn\)</span> 我们已经知道了：</p>
<ul>
<li>对于 <span class="math inline">\(mx &lt; mn\)</span> 来说：
<ul>
<li>如果 <span class="math inline">\(mx &lt; mn &lt; a_i\)</span>，则我们将 <span class="math inline">\(a_i\)</span> 加到 <span class="math inline">\(mx\)</span> 数列里会更新，加到 <span class="math inline">\(mn\)</span> 数列里没影响。</li>
<li>如果 <span class="math inline">\(a_i &lt; mx &lt; mn\)</span>，则我们将 <span class="math inline">\(a_i\)</span> 加到 <span class="math inline">\(mx\)</span> 数列里没影响，加到 <span class="math inline">\(mn\)</span> 数列里会更新。</li>
<li>如果 <span class="math inline">\(mx &lt; a_i &lt; mn\)</span>，则加到任何一个数列都会更新。<span class="math inline">\(^{{\color{red}(1)}}\)</span></li>
</ul>
</li>
<li>对于 <span class="math inline">\(mn &lt; mx\)</span> 来说：
<ul>
<li>如果 <span class="math inline">\(mn &lt; mx &lt; a_i\)</span>，则我们将 <span class="math inline">\(a_i\)</span> 加到 <span class="math inline">\(mx\)</span> 数列里会更新，加到 <span class="math inline">\(mn\)</span> 数列里没影响。</li>
<li>如果 <span class="math inline">\(a_i &lt; mn &lt; mx\)</span>，则我们将 <span class="math inline">\(a_i\)</span> 加到 <span class="math inline">\(mx\)</span> 数列里没影响，加到 <span class="math inline">\(mn\)</span> 数列里会更新。</li>
<li>如果 <span class="math inline">\(mn &lt; a_i &lt; mx\)</span>，则加到任何一个数列都没有影响。</li>
</ul>
</li>
</ul>
<p>对于两种情况，显然只有 <span class="math inline">\(a_i\)</span> 在中间的时候情况不同。似乎如果更新少一点更简单，所以我们考虑 <span class="math inline">\(mn &lt; mx\)</span>。</p>
<h3 id="_-2"><span class="math inline">\(\mathbf{Part. 2}\)</span></h3>
<p>我们考虑 <span class="math inline">\(mn &lt; mx\)</span>。对于这种情况，我们发现，对于每个数，如果它可以但是不用在 <span class="math inline">\(mx\)</span> 或者 <span class="math inline">\(mn\)</span> 数列中的话，它可以选择不影响答案。因此，对于所有后面 <span class="math inline">\(&gt; mx\)</span> 的数，我可以选择一些来构成最长上升子序列，其他的划分到 <span class="math inline">\(mn\)</span> 去，不对答案造成影响。<span class="math inline">\(&lt; mn\)</span> 的数同理<span class="math inline">\(^{\color{red}(2)}\)</span>。容易发现，这其实是 <span class="math inline">\(\mathbf{LIS}\)</span> 和 <span class="math inline">\(\mathbf{LCS}\)</span> 问题，而这个问题我们可以用 <span class="math inline">\(\mathbf{BIT}\)</span> 轻松计算出每个 <span class="math inline">\(a_i\)</span> 开头的 <span class="math inline">\(\mathbf{LIS,LCS}\)</span> 值。</p>
<p>但是对于 <span class="math inline">\(mx &lt; mn\)</span>，由于 <span class="math inline">\(\color{red}(1)\)</span> 的存在，并不是每个数都能选择不影响序列。如果我们直接考虑研究 <span class="math inline">\(mx &lt; mn\)</span> 的转移过程，那是没有任何性质的<span class="math inline">\(^{\color{red}(3)}\)</span>。但是，如果我们观察答案整体的结构，我们发现 <span class="math inline">\(mx &gt; mn\)</span> 和 <span class="math inline">\(mn &gt; mx\)</span> 分别是这个序列中的前缀和后缀部分，所以不难想到<strong>枚举分界点</strong>。</p>
<p>（为了方便区分，我们后文将 <span class="math inline">\(mx &lt; mn\)</span> 的部分称为前面的部分，<span class="math inline">\(mx &lt; mx\)</span> 的部分称为后面的部分）</p>
<p>我们考虑枚举分界点 <span class="math inline">\(x\)</span>。如果我们要求后面的部分，它的答案，那么由 <span class="math inline">\(\color{red}(2)\)</span>，我们需要知道 <span class="math inline">\(mn\)</span> 和 <span class="math inline">\(mx\)</span> 的值来划分后面的数分别可以分到哪一个数列。因此，我们考虑枚举在分界点 <span class="math inline">\(x\)</span> 选择完之后，<span class="math inline">\(mn,mx\)</span> 的值的。（此时，<span class="math inline">\(mn &lt; mx\)</span>）</p>
<p>接着，我们考虑前面的部分怎么求。首先，由 <span class="math inline">\(\color{red}(3)\)</span>，前面的操作过程没什么救，但是我们知道前面 <span class="math inline">\(mx &lt; mn\)</span> 啊！由于所有 <span class="math inline">\(mx\)</span> 序列的所有数都 <span class="math inline">\(\leq mx\)</span>，<span class="math inline">\(mn\)</span> 序列的所有数都 <span class="math inline">\(\geq mn\)</span>，而 <span class="math inline">\(mx  &lt;mn\)</span>，所以 <span class="math inline">\(mx\)</span> 序列的所有值都小于 <span class="math inline">\(mn\)</span> 序列的所有值！因此，我们再考虑枚举分界点 <span class="math inline">\(x\)</span> 还没选择前，<span class="math inline">\(mn,mx\)</span> 的值。这样，我们可以预处理出前面所有 <span class="math inline">\(\leq mx\)</span> 的数的前缀最大值个数，和所有 <span class="math inline">\(\geq mn\)</span> 的前缀最小值的个数。</p>
<p>当然，实际上你在枚举 <span class="math inline">\(mn,mx\)</span> 的时候，有可能存在 <span class="math inline">\(a_i\)</span>，使得 <span class="math inline">\(mx &lt; a_i &lt; mn\)</span>。这种情况显然不合法！因此，我们枚举的 <span class="math inline">\(mx\)</span> 和 <span class="math inline">\(mn\)</span> 需要保证不存在 <span class="math inline">\(a_i\)</span> 使得 <span class="math inline">\(mx &lt; a_i &lt; mn\)</span><span class="math inline">\(^{\color{red}{(4)}}\)</span>。</p>
<p>但这样复杂度直接起飞，非常不好。考虑我们都枚举了什么东西。</p>
<ul>
<li>分界点 <span class="math inline">\(x\)</span></li>
<li>分界点选择之前 <span class="math inline">\(mx,mn\)</span> 值</li>
<li>分界点选择之后 <span class="math inline">\(mx,mn\)</span> 值</li>
</ul>
<p>我们发现，分界点选择之前的 <span class="math inline">\(mx,mn\)</span> 和之后的 <span class="math inline">\(mx,mn\)</span> 肯定有很多重复啊！假设 <span class="math inline">\(x\)</span> 选择之前是 <span class="math inline">\(mx,mn\)</span>，那 <span class="math inline">\(x\)</span> 选择，肯定要么更新 <span class="math inline">\(mx\)</span>，要么更新 <span class="math inline">\(mn\)</span>，然后都是变成 <span class="math inline">\(a_x\)</span>，所以实际上我们只需要枚举 <span class="math inline">\(mx,mn\)</span>，然后分类讨论一下即可。</p>
<p>我们明明已经找到了这么多性质，时间复杂度还是 <span class="math inline">\(\mathcal{O}(n^3)\)</span>。怎么回事呢？但其实不然。由 <span class="math inline">\(\color{red}(4)\)</span>，我们知道 <span class="math inline">\(mx,mn\)</span> 肯定是前面的 <span class="math inline">\(a_i\)</span> 的值，而我们不能存在 <span class="math inline">\(a_i\)</span> 在 <span class="math inline">\(mx,mn\)</span> 之间，所以实际上 <span class="math inline">\(mx\)</span> 是 <span class="math inline">\(mn\)</span> 的后继。因此，你只需要枚举 <span class="math inline">\(mx,x\)</span> 两个值即可，复杂度为 <span class="math inline">\(\mathcal{O}(n^2)\)</span>。</p>
<p>我们考虑这个算法的细节。首先，枚举 <span class="math inline">\(x,mx\)</span>，则 <span class="math inline">\(mn\)</span> 是很容易通过维护 <span class="math inline">\(\mathbf{set}\)</span> 算出来的。然后，我们发现对于一个 <span class="math inline">\(mx\)</span>，肯定在前面出现过，而且这个 <span class="math inline">\(mx\)</span> 后面的数是没用的，所以我们可以对于每个 <span class="math inline">\(a_i \leq mx\)</span>，预处理出所有 <span class="math inline">\(\leq mx\)</span> 的数的前缀最大值个数，<span class="math inline">\(mn\)</span> 同理。对于后面的部分，我们可以通过 <span class="math inline">\(\mathbf{BIT}\)</span>，求出以每个 <span class="math inline">\(a_i\)</span> 为开头的 <span class="math inline">\(\mathbf{LIS,LCS}\)</span>。然后，由于我们要求以 <span class="math inline">\(x\)</span> 为开头的最长子序列，和以 <span class="math inline">\(i &gt; x,a_i &lt; mn\)</span> 或者 <span class="math inline">\(i &gt; x, a_i &gt; mx\)</span> 开头的最长子序列，因此我们按顺序扫一下 <span class="math inline">\(mx\)</span> 就可以快速求出。</p>
<h3 id="_-3"><span class="math inline">\(\mathbf{Part. 3}\)</span></h3>
<p>我们考虑优化这个算法。</p>
<p>我们大概的思路是：枚举一个值，另一个值数据结构维护，所以我们可以枚举 <span class="math inline">\(x\)</span>。结果我们发现，枚举 <span class="math inline">\(x\)</span> 完全不可做！！！？？？这怎么办？</p>
<p>这时候最重要的一点：抛弃前面的所有思想，我们考虑枚举什么更优秀！但此处的抛弃并不是真正的抛弃，因为你已经发现了很多性质，赛场上你是不会忘掉的。</p>
<p>我们考虑枚举 <span class="math inline">\(x\)</span> 为什么不优秀。枚举 <span class="math inline">\(x\)</span>，给我们提供了 <span class="math inline">\(mx &lt; mn &lt; a_x\)</span> 或 <span class="math inline">\(a_x &lt; mx &lt; mn\)</span> 的信息，让我们知道从 <span class="math inline">\(i\)</span> 开始进入后面的部分，但是我们不知道 <span class="math inline">\(mx,mn\)</span>；不知道 <span class="math inline">\(mn\)</span> 后面应该找什么数（这里就很离谱了：我们不知道 <span class="math inline">\(mn\)</span>，还要对于 <span class="math inline">\(x &gt; i,a_x &lt; mn\)</span> 来二位数点！），但是知道 <span class="math inline">\(mx\)</span> 后面一定是 <span class="math inline">\(i\)</span>。如果枚举 <span class="math inline">\(mx\)</span> 的话，如果 <span class="math inline">\(mn\)</span> 在 <span class="math inline">\(mx\)</span> 的右边，那我们不能知道 <span class="math inline">\(mn\)</span> 是什么。</p>
<p>我们对于 <span class="math inline">\(mx,mn\)</span> 维护的信息是不平衡的，但是我们又要通过 <span class="math inline">\(mx\)</span> 求出来 <span class="math inline">\(mn\)</span>。于是，我们应该要枚举一个点，这个点左边涵盖了 <span class="math inline">\(mn,mx\)</span>，右边是我们要找的转折点 <span class="math inline">\(x\)</span>。如果 <span class="math inline">\(mx\)</span> 在 <span class="math inline">\(mn\)</span> 左边，这个 <span class="math inline">\(x\)</span> 可以是 <span class="math inline">\(mx\)</span>，否则可以是 <span class="math inline">\(mn\)</span>……对！我们可以枚举 <span class="math inline">\(mn\)</span> 和 <span class="math inline">\(mx\)</span> 最靠右的那个点！</p>
<p>假设我们枚举了 <span class="math inline">\(x\)</span>，其中 <span class="math inline">\(mn,mx\)</span> 都在 <span class="math inline">\(x\)</span> 左边，且其中有一个是 <span class="math inline">\(a_x\)</span>。由 <span class="math inline">\(\color{red}(4)\)</span>，这两个值在 <span class="math inline">\(x\)</span> 左边的值域上肯定是相邻的，所以我们可以通过 <span class="math inline">\(mx\)</span> 求出来另一个 <span class="math inline">\(mn\)</span>。那么，我们分类讨论 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(mx\)</span> 还是 <span class="math inline">\(mn\)</span>，对于每种情况，我们还要考虑是 <span class="math inline">\(mn\)</span> 还是 <span class="math inline">\(mx\)</span> 的更新造成了 <span class="math inline">\(mn,mx\)</span> 的大小关系变化。因此，我们枚举 <span class="math inline">\(x\)</span>，然后分类讨论四种情况。不妨设 <span class="math inline">\(a_x\)</span> 是 <span class="math inline">\(mx\)</span>，我们算出来了 <span class="math inline">\(mn\)</span>，<span class="math inline">\(mx\)</span> 跳完后超过了 <span class="math inline">\(mn\)</span>，则跳的下标 <span class="math inline">\(p\)</span> 要满足 <span class="math inline">\(p &gt; x, a_p &gt; mn\)</span>，然后求 <span class="math inline">\(\mathbf{LIS}(p)\)</span> 的最大值，这是经典的二位数点。</p>
<h3 id="_-4"><span class="math inline">\(\mathbf{Part. +\infin}\)</span></h3>
<p>这份代码是 @Albert_Wei 写的，本人还没写，写了 update。</p>
<pre><code class="language-cpp">int n, p[N], res[N][2], l[N], r[N];

struct BIT {
    int tr[N];
    void init() { F(i, 1, n + 1) tr[i] = 0; }
    void modify(int x, int y) { for (; x &lt;= n + 1; x += (x &amp; -x)) tr[x] += y; }
    int query(int x) { int ans = 0; for (; x; x -= (x &amp; -x)) ans += tr[x]; return ans; }
} S;
struct BIT2 {
    int tr[N];
    void init() { F(i, 1, n) tr[i] = 0; }
    void modify(int x, int y) { for (; x &lt;= n; x += (x &amp; -x)) Fmax(tr[x], y); }
    int query(int x) { int ans = 0; for (; x; x -= (x &amp; -x)) Fmax(ans, tr[x]); return ans; }
} U, V;

void solve() {
    n = read();
    F(i, 1, n) p[i] = read();
    S.init();
    set&lt;int&gt; st;
    st.insert(0), st.insert(n + 1);
    F(i, 1, n) {
        l[i] = *(-- st.lower_bound(p[i])), r[i] = *st.upper_bound(p[i]);
        S.modify(l[i] + 1, 1), S.modify(r[i] + 1, -1);
        res[i][0] = S.query(p[i] + 1), res[i][1] = S.query(p[i]), st.insert(p[i]);
    }
    int ans = 0;
    U.init(), V.init();
    G(i, n, 1) {
        if (r[i] != n + 1) Fmax(ans, res[i][0] + U.query(n - r[i]) + V.query(r[i]));
        Fmax(ans, res[i][0] + U.query(n - p[i]) + V.query(p[i]));
        Fmax(ans, res[i][1] + U.query(n - p[i]) + V.query(p[i]));
        if (l[i]) Fmax(ans, res[i][1] + U.query(n - l[i]) + V.query(l[i]));
        U.modify(n - p[i] + 1, U.query(n - p[i]) + 1);
        V.modify(p[i], V.query(p[i]) + 1);
    }
    F(i, 0, n) Fmax(ans, U.query(n - i) + V.query(i));
    cout &lt;&lt; ans &lt;&lt; '\n';
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-27 17:41">2025-07-27 17:41</span>&nbsp;
<a href="https://www.cnblogs.com/aemmprty">DE_aemmprty</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19007615);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19007615', targetLink: 'https://www.cnblogs.com/aemmprty/p/19007615', title: '[ROI 2023] 峰值 (Day 1)' })">举报</a>
</div>
        