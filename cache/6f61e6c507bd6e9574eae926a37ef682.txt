
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/leadingcode/p/18851970" title="发布于 2025-04-28 16:40">
    <span role="heading" aria-level="2">Promise 这个新 API 真香！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<ul>
<li>Hey, 我是 沉浸式趣谈</li>
<li>本文首发于【沉浸式趣谈】，我的个人博客 <strong><a href="https://yaolifeng.com" target="_blank" rel="noopener nofollow">https://yaolifeng.com</a></strong> 也同步更新。</li>
<li>转载请在文章开头注明出处和版权信息。</li>
<li>如果本文对您有所帮助，请 <strong>点赞</strong>、<strong>评论</strong>、<strong>转发</strong>，支持一下，谢谢！</li>
</ul>
<p>聊到异步，<code>Promise</code> 大家肯定都不陌生，是咱们处理异步操作的神器</p>
<p>不过呢，就算有 <code>Promise</code>，有时候处理一些既可能是同步又可能是异步的函数，或者那种随时可能在启动时就给你扔个同步错误的函数，还是有点小别扭。</p>
<p>你懂的，就是那种“我想用 <code>.then().catch()</code> 一把梭，但又怕它在 <code>Promise</code> 链开始前就崩了”的尴尬。</p>
<p>好消息来了！</p>
<p>ES2025 憋了个大招 —— <code>Promise.try()</code>。</p>
<h3 id="promisetry-到底是何方神圣"><strong><code>Promise.try()</code> 到底是何方神圣？</strong></h3>
<p>说白了，它就是 <code>Promise</code> 上的一个静态方法，像个万能启动器。</p>
<p>你扔给它一个函数（管它是同步的、异步的，会返回值还是会抛错），它都能稳稳地给你包成一个 Promise。</p>
<p>代码大概长这样：</p>
<pre><code class="language-javascript">Promise.try(你要运行的函数, ...可能需要的参数);
</code></pre>
<p>简单粗暴，对吧？</p>
<p>关键在于，它特别擅长处理那些“不确定性”。</p>
<p>比如：</p>
<ul>
<li>如果你的函数是<strong>同步</strong>的，执行完直接返回值 <code>X</code>？那 <code>Promise.try()</code> 就给你一个 <code>resolved</code> 状态、值为 <code>X</code> 的 Promise。</li>
<li>要是函数<strong>同步</strong>执行时直接 <code>throw new Error()</code> 了呢？（这种最头疼了，以前可能直接崩掉后续代码）<code>Promise.try()</code> 会捕获这个错误，然后给你一个 <code>rejected</code> 状态的 Promise，错误就在里面，你可以用 <code>.catch()</code> 接住。简直完美！</li>
<li>那如果函数本身就返回一个<strong>异步</strong>的 Promise 呢？没问题，<code>Promise.try()</code> 就直接用那个 Promise 的状态。</li>
</ul>
<p><strong>为啥我们需要这玩意儿？以前不也活得好好的？</strong></p>
<p>嗯... 活得好是好，但可能不够优雅，或者说，不够省心。</p>
<p>记得以前咱们想统一处理同步/异步函数时，可能会用 <code>Promise.resolve().then(func)</code> 这招吗？</p>
<pre><code class="language-javascript">const f = () =&gt; console.log('我应该立刻执行！');
Promise.resolve().then(f); // 但它被塞到微任务队列里去了
console.log('我先执行了...');
// 输出:
// 我先执行了...
// 我应该立刻执行！
</code></pre>
<p>明明 <code>f</code> 是个同步函数，结果被 <code>then</code> 这么一搞，硬生生变成了异步执行。</p>
<p>有时候我们并不想要这种延迟。而且，如果 <code>f</code> 本身在执行前就抛错，<code>Promise.resolve()</code> 可管不了。</p>
<p><code>Promise.try()</code> 就是来解决这个痛点的。</p>
<p>它能让你的函数（如果是同步的）基本上是立即尝试执行，同时还保证了无论如何你都能拿到一个 Promise，并且同步错误也能被链式捕获。</p>
<p>...呃，或者更准确地说，它提供了一个统一的、更安全的 Promise 启动方式。</p>
<h3 id="来上代码感受下"><strong>来，上代码感受下</strong></h3>
<ul>
<li><strong>搞定同步函数：</strong></li>
</ul>
<pre><code class="language-javascript">const syncTask = () =&gt; {
    console.log('同步任务跑起来～');
    return '同步搞定';
};

Promise.try(syncTask)
    .then(res =&gt; console.log('结果:', res)) // 立刻输出 "同步搞定"
    .catch(err =&gt; console.error('出错了?', err));
// 控制台会先打印 "同步任务跑起来～"，然后是 "结果: 同步搞定"
</code></pre>
<ul>
<li><strong>处理异步函数（这个没啥特别，就是正常用）：</strong></li>
</ul>
<pre><code class="language-javascript">const asyncTask = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve('异步也 OK'), 500));

Promise.try(asyncTask)
    .then(res =&gt; console.log('结果:', res)) // 大约 500ms 后输出 "异步也 OK"
    .catch(err =&gt; console.error('出错了?', err));
</code></pre>
<ul>
<li><strong>最妙的地方：捕获同步错误</strong></li>
</ul>
<pre><code class="language-javascript">const potentiallyExplodingTask = () =&gt; {
    if (Math.random() &lt; 0.5) {
        // 假设这里有 50% 概率直接炸
        throw new Error('Boom! 同步错误');
    }
    return '安全通过';
};

// 多试几次你就能看到效果
Promise.try(potentiallyExplodingTask)
    .then(res =&gt; console.log('这次运气不错:', res))
    .catch(err =&gt; console.error('捕获到错误:', err.message)); // 能抓住那个 "Boom!"
</code></pre>
<p>就算 <code>potentiallyExplodingTask</code> 在 <code>Promise</code> 链条“正式”开始前就同步抛错了，<code>Promise.try()</code> 也能稳稳接住，交给你后面的 <code>.catch()</code> 处理。</p>
<p>这在以前，可能就直接导致程序崩溃或者需要写额外的 <code>try...catch</code> 块了。(这点我个人觉得超级实用！)</p>
<h3 id="这东西有啥好的总结一下哈"><strong>这东西有啥好的？总结一下哈：</strong></h3>
<ol>
<li><strong>入口统一：</strong> 不管三七二十一，同步异步函数塞进去，出来的都是 Promise，后续处理逻辑可以写得非常一致。代码看着就清爽多了。</li>
<li><strong>同步错误保险：</strong> 这是重点！能捕获启动函数时的同步错误，塞到 Promise 链里，让你用 <code>.catch()</code> 一勺烩了。避免了裸露的 <code>try...catch</code> 或者漏抓错误的风险。</li>
<li><strong>可读性提升：</strong> 意图更明显，一看 <code>Promise.try()</code> 就知道这里是安全启动一个可能同步也可能异步的操作。</li>
</ol>
<h3 id="实战中能怎么玩"><strong>实战中能怎么玩？</strong></h3>
<ul>
<li>
<p><strong>调 API：</strong> <code>fetch</code> 本身返回 Promise，但之前的 URL 处理、参数构造啥的可能是同步的，万一出错呢？</p>
<ul>
<li>用 <code>Promise.try(() =&gt; fetch(buildUrl(params)))</code> 就很稳。</li>
</ul>
<pre><code class="language-javascript">// 以前的写法
function fetchUserData(userId) {
    try {
        // 这里的 buildApiUrl 可能会同步抛出错误
        const url = buildApiUrl(`/users/${userId}`);
        return fetch(url).then(res =&gt; res.json());
    } catch (err) {
        return Promise.reject(err); // 手动转换成 Promise 错误
    }
}

// 使用 Promise.try 的写法
function fetchUserData(userId) {
    return Promise.try(() =&gt; {
        const url = buildApiUrl(`/users/${userId}`);
        return fetch(url).then(res =&gt; res.json());
    });
}

// 调用示例
fetchUserData('123')
    .then(data =&gt; console.log('用户数据:', data))
    .catch(err =&gt; console.error('获取用户数据失败:', err));
</code></pre>
</li>
<li>
<p><strong>混合任务链：</strong> 比如先跑个同步任务，再根据结果跑个异步任务，用 <code>Promise.try(syncTask).then(res =&gt; Promise.try(() =&gt; asyncTask(res)))</code> 串起来就很自然。</p>
<pre><code class="language-javascript">// 假设我们有个处理用户输入的场景
function validateInput(input) {
    // 同步验证，可能会抛出错误
    if (!input || input.length &lt; 3) {
        throw new Error('输入太短了！');
    }
    return input.trim().toLowerCase();
}

function saveToDatabase(processedInput) {
    // 异步保存，返回 Promise
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            if (processedInput === 'admin') {
                reject(new Error('不能使用保留关键字'));
            } else {
                resolve({ success: true, id: Date.now() });
            }
        }, 500);
    });
}

// 使用 Promise.try 组合这两个任务
function processUserInput(rawInput) {
    return Promise.try(() =&gt; validateInput(rawInput)).then(validInput =&gt;
        Promise.try(() =&gt; saveToDatabase(validInput))
    );
}

// 测试不同情况
processUserInput('') // 同步错误
    .then(result =&gt; console.log('保存成功:', result))
    .catch(err =&gt; console.error('处理失败:', err.message));

processUserInput('admin') // 异步错误
    .then(result =&gt; console.log('保存成功:', result))
    .catch(err =&gt; console.error('处理失败:', err.message));

processUserInput('user123') // 成功情况
    .then(result =&gt; console.log('保存成功:', result))
    .catch(err =&gt; console.error('处理失败:', err.message));
</code></pre>
</li>
<li>
<p><strong>数据库/文件操作：</strong> 很多库的 API 设计可能五花八门，有的同步出错有的异步出错，用 <code>Promise.try</code> 包裹一下，可以简化错误处理逻辑。(当然，具体库可能有自己的最佳实践，这只是个思路)</p>
<pre><code class="language-javascript">// 假设我们有个文件操作库，它的 API 设计有点混乱
const fileOps = {
    readConfig(path) {
        // 这个方法可能同步抛错（比如路径格式不对）
        // 也可能返回 Promise（实际读取文件时）
        if (!path.endsWith('.json')) {
            throw new Error('配置文件必须是 JSON 格式');
        }

        return new Promise((resolve, reject) =&gt; {
            setTimeout(() =&gt; {
                if (path.includes('nonexistent')) {
                    reject(new Error('文件不存在'));
                } else {
                    resolve({ version: '1.0', settings: { theme: 'dark' } });
                }
            }, 100);
        });
    },
};

// 不使用 Promise.try 的话，调用方需要自己处理同步错误
function loadAppConfig_old(configPath) {
    try {
        return fileOps.readConfig(configPath).then(config =&gt; {
            console.log('配置加载成功');
            return config;
        });
    } catch (err) {
        console.error('同步错误:', err);
        return Promise.reject(err);
    }
}

// 使用 Promise.try，代码更简洁，错误处理更统一
function loadAppConfig(configPath) {
    return Promise.try(() =&gt; fileOps.readConfig(configPath)).then(config =&gt; {
        console.log('配置加载成功');
        return config;
    });
}

// 测试各种情况
loadAppConfig('settings.txt') // 同步错误 - 非 JSON 文件
    .catch(err =&gt; console.error('加载失败:', err.message));

loadAppConfig('nonexistent.json') // 异步错误 - 文件不存在
    .catch(err =&gt; console.error('加载失败:', err.message));

loadAppConfig('settings.json') // 成功情况
    .then(config =&gt; console.log('配置内容:', config))
    .catch(err =&gt; console.error('加载失败:', err.message));
</code></pre>
</li>
</ul>
<p><strong>聊了这么多，总而言之...</strong></p>
<p><code>Promise.try()</code> 这哥们儿，虽然看起来只是个小补充，但它解决的痛点可是实实在在的。</p>
<p>它让 Promise 的使用，尤其是在链条的起点上，变得更健壮、更统一。</p>
<p>我个人感觉，一旦大家习惯了它带来的便利（特别是那个同步错误捕获！），估计很快就会成为咱们工具箱里的常客了。</p>
<p>有机会的话，真得试试看！</p>
<h3 id="其他好文推荐">其他好文推荐</h3>
<p><a href="https://mp.weixin.qq.com/s/6GdfVnmu30Ki1XeadzuuRg" target="_blank" rel="noopener nofollow">搞定 XLSX 预览？别瞎找了，这几个库（尤其最后一个）真香！</a></p>
<p><a href="https://mp.weixin.qq.com/s/Nf1K_8KHLJH_aegL74NXFA" target="_blank" rel="noopener nofollow">实战分享】10 大支付平台全方面分析，独立开发必备！</a></p>
<p><a href="https://mp.weixin.qq.com/s/pR76UwvsJQyRE__LVx6Whg" target="_blank" rel="noopener nofollow">关于 MCP，这几个网站你一定要知道！</a></p>
<p><a href="https://mp.weixin.qq.com/s/gwTbX3hM_GPdDVg3W1ftAQ" target="_blank" rel="noopener nofollow">做 Docx 预览，一定要做这个神库！！</a></p>
<p><a href="https://mp.weixin.qq.com/s/f5pIdyY8grx9t6qYxMgR1w" target="_blank" rel="noopener nofollow">【完整汇总】近 5 年 JavaScript 新特性完整总览</a></p>
<p><a href="https://mp.weixin.qq.com/s/RGFQbqzmrY1NVkdUsQcMBw" target="_blank" rel="noopener nofollow">关于 Node，一定要学这个 10+万 Star 项目！</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6867792197928241" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-28 16:41">2025-04-28 16:40</span>&nbsp;
<a href="https://www.cnblogs.com/leadingcode">沉浸式趣谈</a>&nbsp;
阅读(<span id="post_view_count">239</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18851970);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18851970', targetLink: 'https://www.cnblogs.com/leadingcode/p/18851970', title: 'Promise 这个新 API 真香！' })">举报</a>
</div>
        