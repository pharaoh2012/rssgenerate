
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sharpeye/p/18767415" title="发布于 2025-03-13 01:05">
    <span role="heading" aria-level="2">如何调用CMD实现多个同类文件合并的研究 · 二进制 · 依次 · 文本图像视频音频</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>引言</h1>
<p>视频网站内，使用视频下载嗅探器下载了视频，打开资源管理器一看，是几千个.ts文件，见下图：</p>
<p><img src="https://img2024.cnblogs.com/blog/944545/202503/944545-20250312140828746-900335915.png" width="500"> &nbsp;<img src="https://img2024.cnblogs.com/blog/944545/202503/944545-20250312140905939-1423621076.png" width="500"></p>
<p>通过播放部分视频，发现其实内容是完整的，只是自动切割了多份，倘若无缝拼接为一个完整视频单元，就可以正常播放观赏了。</p>
<p>经过考虑，</p>
<ul>
<li>可以使用视频编辑软件，比如PR，导入素材然后重新编排输出，缺点是耗时，而且二次编码损画面质量；</li>
<li>可以考虑使用无损拼接视频的工具，可参考笔者另一篇博文：<a title="【视频分割工具】无损快速分割视频软件分享[切分][分P神器]" href="https://www.bilibili.com/opus/561236128335705734?spm_id_from=333.1387.0.0" target="_blank" rel="noopener nofollow">【视频分割工具】无损快速分割视频软件分享[切分][分P神器]</a></li>
<li>或者直接使用命令提示符 / 终端，调用<strong>FFmpeg</strong>等工具。或者不借助任何工具或插件，就用原生的MS-Dos。</li>
</ul>
<p>相信原生dos可以实现。那么如果素材是文本、图像和音频呢，我们一同尝试一下。</p>
<hr>
<h1>首先</h1>
<p>简单尝试copy命令：</p>
<pre class="language-powershell highlighter-hljs"><code>copy /b 1.ts+2.ts+3.ts combine.ts</code></pre>
<p>&nbsp;可以得到理想结果，三个片段结合至一个且正常播放。<code>copy</code>命令是cmd中常用的操作文件指令，它可以进行拷贝文件、修改命名、移动文件等，这里使用了合并文件的功能，使用操作符<span style="font-size: 16px"><strong><code>+</code></strong></span>。<code>/b</code>代表二进制式操作。</p>
<p>如果暴力得写下命令如：</p>
<pre class="language-powershell highlighter-hljs"><code>copy /b 0.ts+1.ts+2.ts+...+2368.ts combine.ts</code></pre>
<p>咱们是可以理解的，但是dos理解不了。需要详细定义什么是<span style="font-size: 18px"><strong>“...”</strong></span></p>
<p>因此需要把所有的文件清单列出来，即每个文件的文件名加后缀的清单，每个文件名间加“+”。如：</p>
<p><img src="https://img2024.cnblogs.com/blog/944545/202503/944545-20250313003531666-1388539913.png" width="400"></p>
<p id="1741765277490">新建一个批处理程序.<strong>bat</strong>,使用<code>for</code>循环，把字符整理好一并存入一变量里，如下脚本：</p>
<pre class="language-powershell highlighter-hljs"><code>set "fileList="   REM 变量 用于存放字符

for /L %%i in (0, 1, 2368) do (
    set "fileList=!fileList!%%i.ts+"  REM 依次拼接字符
)

set "fileList=!fileList:~0,-1!"  REM 移除最后一个 +</code></pre>
<p>执行后发现，只有连接到1160.ts。后面的并没有执行：</p>
<p><img src="https://img2024.cnblogs.com/blog/944545/202503/944545-20250312155321782-1206737693.png" width="500"></p>
<p id="1741766006866">什么原因呢，最可疑的是变量的缓冲容量限制，存不下那么多字符。最直接的解决方法是可以<strong>分批次</strong>进行处理：</p>
<ol style="list-style-type: lower-roman">
<li>第一批次&nbsp; 0.ts+1.ts+2.ts+...+999.ts ，合并为combine1.ts</li>
<li>第二批次&nbsp; 1000.ts+1001.ts+1002.ts+...+1999.ts ，合并为combine2.ts</li>
<li>第三批次&nbsp; 2000.ts+2001.ts+2002.ts+...+2348.ts ，合并为combine3.ts</li>
<li>最后&nbsp; combine1.ts+combine2.ts+combine3.ts ,&nbsp; 合并为combine.ts</li>
</ol>
<pre class="language-powershell highlighter-hljs"><code>REM @echo off
setlocal enabledelayedexpansion


::--------第一批次---------------
set "outputFile=combine1.ts"
set "fileList="

for /L %%i in (0, 1, 999) do (
    set "fileList=!fileList!%%i.ts+"
)


set "fileList=!fileList:~0,-1!"  REM 移除最后一个+

echo !fileList! &gt; ./fileList.txt REM 方便调试

copy /b !fileList! "%outputFile%"

::-----------------------------

pause

::--------第二批次---------------
set "outputFile=combine2.ts"
set "fileList="

for /L %%i in (1000, 1, 1999) do (
    set "fileList=!fileList!%%i.ts+"
)


set "fileList=!fileList:~0,-1!"  REM 移除最后一个+

echo !fileList! &gt; ./fileList.txt 

copy /b !fileList! "%outputFile%"

::-----------------------------

pause

::--------第三批次---------------
set "outputFile=combine3.ts"
set "fileList="

for /L %%i in (1999, 1, 2348) do (
    set "fileList=!fileList!%%i.ts+"
)


set "fileList=!fileList:~0,-1!"  REM 移除最后一个+

echo !fileList! &gt; ./fileList.txt 

copy /b !fileList! "%outputFile%"

::-----------------------------

pause

::--------最后-----------------
copy /b combine1.ts+combine2.ts+combine3.ts combine.ts

pause</code></pre>
<p>放在 .ts 文件所在文件夹下，运行脚本，得到最后的视频文件combine.ts。经测验，正常播放，没有问题！</p>
<hr>
<h1>接着</h1>
<p>有同学可能要提议，说cmd中最有魅力的莫过于通配符的使用，例如可以使用 <strong>*.ts</strong> 代指文件夹下所有的ts文件，那么可以这样做<span style="color: rgba(224, 62, 45, 1)"><strong>【注意，以下是错误结果】：</strong></span></p>
<pre class="language-powershell highlighter-hljs"><code>copy /b *.ts combine.ts</code></pre>
<p>可是经测试，这样操作是可行，但是结果不理想，把所有的文件合并为一个，但是打开之后发现视频全部打乱，无法正常欣赏。因此暴力式合并是不可取的。</p>
<p>如果想要更随心得管理命令，应该将有待合并的文件名导出成数个数据文件，比如.<strong>txt</strong>，然后读取这些文件的文本，作为<code>copy</code>命令的参数，随后执行！</p>
<p>对了，笔者在<strong><span style="text-decoration: underline"><em>引言</em></span></strong>中说到，对于其他格式的文件也想试试合并操作，那么下面给出几个<span style="font-size: 18px"><strong>示例</strong></span>：</p>
<hr>
<h2>文本合并</h2>
<p>设有四个<strong>txt</strong>文档，有序合并为一个：</p>
<pre class="language-powershell highlighter-hljs"><code>copy /a 1.txt+2.txt+3.txt+4.txt final.txt</code></pre>
<p>或者逐一把每一个文档先读出来放变量中，然后合并：</p>
<p>四个文档对应四个字符串变量&nbsp; &nbsp;var1&nbsp; var2&nbsp; &nbsp;var3&nbsp; &nbsp;var4&nbsp; &nbsp;, 最后字符合并，输出给新变量，然后<strong>echo &gt; </strong>重定向给.txt保存下来。见代码：</p>
<pre class="language-powershell highlighter-hljs"><code>@echo off
setlocal enabledelayedexpansion

rem 定义要读取的四个文件
set "file1=1.txt"
set "file2=2.txt"
set "file3=3.txt"
set "file4=4.txt"

rem 定义合并后的文件
set "mergedFile=merged.txt"

rem 读取第一个文件内容到变量 var1
set "var1="
for /f "usebackq delims=" %%a in ("%file1%") do (
    set "var1=!var1!%%a"
    set "var1=!var1!"
)

rem 读取第二个文件内容到变量 var2
set "var2="
for /f "usebackq delims=" %%a in ("%file2%") do (
    set "var2=!var2!%%a"
    set "var2=!var2!"
)

rem 读取第三个文件内容到变量 var3
set "var3="
for /f "usebackq delims=" %%a in ("%file3%") do (
    set "var3=!var3!%%a"
    set "var3=!var3!"
)

rem 读取第四个文件内容到变量 var4
set "var4="
for /f "usebackq delims=" %%a in ("%file4%") do (
    set "var4=!var4!%%a"
    set "var4=!var4!"
)

rem 合并四个变量的内容
set "mergedContent=!var1!!var2!!var3!!var4!"

rem 将合并后的内容写入新文件
echo !mergedContent! &gt; "%mergedFile%"

echo 文件合并完成，合并后的文件为 %mergedFile%

endlocal</code></pre>
<p>不过这番操作，仅仅是字符操作，并没有换行，因此合成了一行。另外还有<code><strong>type</strong></code>命令也可以实现类似操作。</p>
<hr>
<h2>图像合并</h2>
<p>对于图像操作，纯粹靠dos原生系统是几乎不可能的，图像操作需要很复杂的运算，需要其他工具。</p>
<p>可以尝试使用<strong>PowerShell</strong>，调用程序集，如 <strong>System.Drawing</strong>。</p>
<pre class="language-powershell highlighter-hljs"><code># 添加 System.Drawing 程序集以便使用图像处理类
Add-Type -AssemblyName System.Drawing

# 从文件加载第一张图片
$img1 = [System.Drawing.Image]::FromFile("image1.jpg")

# 从文件加载第二张图片
$img2 = [System.Drawing.Image]::FromFile("image2.jpg")

# 计算新图像的宽度：两张图片的宽度之和
$width = $img1.Width + $img2.Width

# 计算新图像的高度：取两张图片中较高的高度
$height = [Math]::Max($img1.Height, $img2.Height)

# 创建一个新的位图对象，用于存储合并后的图片
$newImage = New-Object System.Drawing.Bitmap $width, $height

# 从新创建的位图中获取图形对象，以便进行绘制
$graphics = [System.Drawing.Graphics]::FromImage($newImage)

# 在新图像的 (0, 0) 位置绘制第一张图片
$graphics.DrawImage($img1, 0, 0)

# 在新图像的 (img1.Width, 0) 位置绘制第二张图片，确保它紧挨着第一张
$graphics.DrawImage($img2, $img1.Width, 0)

# 将合并后的图像保存为一个新的 JPG 文件
$newImage.Save("merged_image.jpg")

# 释放图形对象和图像对象的资源
$graphics.Dispose()
$img1.Dispose()
$img2.Dispose()
$newImage.Dispose()

# 输出合并完成的提示
Write-Host "合并完成，输出文件为: merged_image.jpg"</code></pre>
<p>&nbsp;这样两张图片便可简单的“粘合在一起”。还有其他细节可以参考笔者另一篇文章：<a title="PowerShell开发小工具 · 四张照片拼成一张 " href="https://www.cnblogs.com/sharpeye/p/18744376" target="_blank" rel="noopener">PowerShell开发小工具 · 四张照片拼成一张 </a></p>
<p>如果执意要用dos，可以找图像处理库，比如 <strong>ImageMagicK</strong>。下面是合并2张图片的示例代码：</p>
<pre class="language-powershell highlighter-hljs"><code>@echo off
rem 配置图片地址以及名称，还有要合并的图片文件名
set img1=1.jpg
set img2=2.jpg
set output=merged_image.jpg

rem 检查 ImageMagick 是否安装
where magick &gt;nul 2&gt;nul
if errorlevel 1 (
    echo ImageMagick 未安装，请先安装 ImageMagick。
    exit /b
)

rem 合并图片，使用 +append 水平合并
magick "%img1%" "%img2%" +append "%output%"

echo 合并完成，输出文件为: %output%
pause</code></pre>
<p><strong>PS</strong>: 在安装过程中，确保选中“Install legacy utilities (e.g., convert)”选项，以便使用命令行工具。</p>
<p>以下给一个5张照片水平拼接的例子：</p>
<p><img src="https://img2024.cnblogs.com/blog/944545/202503/944545-20250312232426690-1543492322.jpg" width="150"> &nbsp;<img src="https://img2024.cnblogs.com/blog/944545/202503/944545-20250312232721209-1820367952.jpg" width="150"> &nbsp;<img src="https://img2024.cnblogs.com/blog/944545/202503/944545-20250312232449723-165920938.jpg" width="120"> &nbsp;<img src="https://img2024.cnblogs.com/blog/944545/202503/944545-20250312232510249-1764447223.jpg" width="150"> &nbsp;<img src="https://img2024.cnblogs.com/blog/944545/202503/944545-20250312232519902-748001439.jpg" width="150"></p>
<p>上面5张图片，水平合并：</p>
<pre class="language-powershell highlighter-hljs"><code>magick 1.jpg 2.jpg 3.jpg 4.jpg 5.jpg +append combine_5.jpg</code></pre>
<p>得：</p>
<p><img src="https://img2024.cnblogs.com/blog/944545/202503/944545-20250312233255702-484280712.jpg" width="500"></p>
<p>照片大小都不一致，因此会得到很奇怪的效果。</p>
<hr>
<h2 id="1741793294847">音频合并</h2>
<p>最后还有音频文件的合并尝试。准备3段音频：1.wav&nbsp; &nbsp;2.wav&nbsp; 3.wav&nbsp; （不同格式的还是不要自找苦吃了，先转换格式吧）</p>
<p>对于音频文件，cmd不好处理的，还是用<strong>FFmpeg</strong>吧！不过千万别以为笔者没试过，强制执行<code>copy /b</code>，要么打不开，要么音频播放软件识别错误，即使能播放，时间线也是<span style="color: rgba(224, 62, 45, 1)"><strong>错乱</strong></span>的！</p>
<p>下面是使用<strong>FFmpeg</strong>工具集的例子：</p>
<pre class="language-powershell highlighter-hljs"><code>rem @echo off
rem 设置要合并的 WAV 文件名
set wav1=1.wav
set wav2=2.wav
set wav3=3.wav
set output=merged_output.wav

rem 检查 FFmpeg 是否安装
where ffmpeg &gt;nul 2&gt;nul
if errorlevel 1 (
    echo FFmpeg 未安装，请先安装 FFmpeg。
    pause
    exit /b
)

rem 创建一个临时文件，列出要合并的 WAV 文件
(
    echo file '%wav1%'
    echo file '%wav2%'
    echo file '%wav3%'
) &gt; file_list.txt

rem 使用 FFmpeg 合并 WAV 文件
ffmpeg -f concat -safe 0 -i file_list.txt -c copy "%output%"

rem 删除临时文件
del file_list.txt

echo 合并完成，输出文件为: %output%
pause</code></pre>
<p><strong>PS: </strong>使用&nbsp;<code>ffmpeg</code>&nbsp;命令进行合并。选项&nbsp;<code>-f concat</code>&nbsp;指定格式为拼接，<code>-safe 0</code>&nbsp;允许使用绝对路径，<code>-c copy</code>&nbsp;表示直接复制音频流。</p>
<hr>
<h1 id="1741793115028">结尾</h1>
<p>合并文件，如果不是像笔者闲得蛋疼，还是别去使用cmd做，交给专业软件或工具吧。此篇文章也就是试验一下，不过针对学习cmd命令行脚本而言是很有参考价值。</p>
<p>而对于文本而言，其实cmd来合并操作，有时候还有用武之地，以后碰到了再细聊。视频的话，遇到像本文一开始的情景，很多同格式同规格的视频文件，使用copy /b 还挺方便的。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p id="1741793099398"></p>
<p id="1741793093820"></p>
<p id="1741793083460"></p>
<p id="1741793071118"></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.21407675706828705" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-13 01:06">2025-03-13 01:05</span>&nbsp;
<a href="https://www.cnblogs.com/sharpeye">SHARP-EYE</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18767415" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18767415);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18767415', targetLink: 'https://www.cnblogs.com/sharpeye/p/18767415', title: '如何调用CMD实现多个同类文件合并的研究 &amp;#183; 二进制 &amp;#183; 依次 &amp;#183; 文本图像视频音频' })">举报</a>
</div>
        