
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18947436" title="发布于 2025-06-25 09:33">
    <span role="heading" aria-level="2">商品中心—13.商品卖家系统的高并发文档</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="4" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="5"><strong>1.阿里云Tair接入与Jedis连接池使用</strong></p>
<p data-track="6"><strong>2.Redis集群连接池与通用对象连接池源码</strong></p>
<p data-track="7"><strong>3.商品卖家系统高并发场景与缓存预热逻辑</strong></p>
<p data-track="8"><strong>4.商品卖家系统缓存预热架构设计</strong></p>
<p data-track="9"><strong>5.商品卖家系统单机下的缓存预热的实现</strong></p>
<p data-track="10"><strong>6.商品卖家系统分布式下的缓存预热的实现</strong></p>
<p data-track="11"><strong>7.商品卖家系统定时查询DB最新数据更新缓存</strong></p>
<p data-track="12"><strong>8.商品中心高并发架构总结</strong></p>
<p data-track="13">&nbsp;</p>
<p data-track="14"><strong>1.阿里云Tair接入与Jedis连接池使用</strong></p>
<p data-track="15"><strong>(1)引入依赖</strong></p>
<p data-track="16"><strong>(2)添加配置文件</strong></p>
<p data-track="17"><strong>(3)配置Tair相关Bean</strong></p>
<p data-track="18"><strong>(4)使用Tair相关命令</strong></p>
<p data-track="19">&nbsp;</p>
<p data-track="20"><strong>(1)引入依赖</strong></p>
<p data-track="21">Tair是多线程的，Redis是单线程的。TairJedis是阿⾥云基于Jedis开发的Redis企业版专⽤客户端。TairJedis除了Jedis原有功能，还⽀持Redis企业版包含的命令。</p>
<p data-track="22">&nbsp;</p>
<p data-track="23"><strong>(1)引入依赖</strong></p>
<pre class="highlighter-hljs"><code>&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.aliyun.tair&lt;/groupId&gt;
    &lt;artifactId&gt;alibabacloud-tairjedis-sdk&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p data-track="25"><strong>(2)添加配置文件</strong></p>
<pre class="highlighter-hljs"><code>spring:
    tair:
        host: r-xxxxxxxxxxxxxxx.redis.rds.aliyuncs.com
        port: 6379
        password: password
        timeout: 3000
        maxIdle: 10000
        maxTotal: 10000</code></pre>
<p data-track="27"><strong>(3)配置Tair相关Bean</strong></p>
<pre class="highlighter-hljs"><code>@Data
@Configuration
public class TairConfig {
    @Value("${spring.tair.maxIdle:200}")
    private int maxIdle;
    @Value("${spring.tair.maxTotal:300}")
    private int maxTotal;
    @Value("${spring.tair.host}")
    private String host;
    @Value("${spring.tair.port:6379}")
    private int port;
    @Value("${spring.tair.password}")
    private String password;
    @Value("${spring.tair.timeout:3000}")
    private int timeout;

    @Bean
    @ConditionalOnClass(JedisPool.class)
    public JedisPool jedisPool() {
        JedisPoolConfig config = new JedisPoolConfig();
        //最大空闲连接数，需自行评估，不超过Redis实例的最大连接数
        config.setMaxIdle(maxIdle);
        //最大连接数，需自行评估，不超过Redis实例的最大连接数
        config.setMaxTotal(maxTotal);
        config.setTestOnBorrow(false);  
        config.setTestOnReturn(false);
        return new JedisPool(config, host, port, timeout, password);
    }

    @Bean
    @ConditionalOnClass(TairCache.class)
    public TairCache tairCache(JedisPool jedisPool) {
        return new TairCache(jedisPool);
    }
}</code></pre>
<p data-track="29"><strong>(4)使用Tair相关命令</strong></p>
<pre class="highlighter-hljs"><code>@Component
public class TairCache {
    private JedisPool jedisPool;

    public TairCache(JedisPool jedisPool) {
        this.jedisPool = jedisPool;
    }

    public Jedis getJedis() {
        return jedisPool.getResource();
    }

    public TairString createTairString(Jedis jedis) {
        return new TairString(jedis);
    }

    private TairHash createTairHash(Jedis jedis) {
        return new TairHash(jedis);
    }

    //缓存存储
    public void set(String key, String value, int seconds) {
        log.info("tairString set key:{}, value:{}, seconds:{}", key, value, seconds);
        try (Jedis jedis = getJedis()) {
            TairString tairString = createTairString(jedis);
            String result;
            if (seconds &gt; 0) {
                result = tairString.exset(key, value, new ExsetParams().ex(seconds));
            } else {
                result = tairString.exset(key, value);
            }
            log.info("tairString set key:{}, value:{}, seconds:{}", key, value, seconds);
        }
    }

    //tairString存储
    public boolean exset(String key, String value, int seconds) {
        try (Jedis jedis = getJedis()) {
            TairString tairString = createTairString(jedis);
            String result;
            if (seconds &gt; 0) {
                result = tairString.exset(key, value, new ExsetParams().ex(seconds));
            } else {
                result = tairString.exset(key, value);
            }
            return "OK".equals(result);
        }
    }

    //缓存获取
    public String get(String key) {
        try (Jedis jedis = getJedis()) {
            ExgetResult&lt;String&gt; exget = createTairString(jedis).exget(key);
            if (exget == null) {
                return null;
            }
            return exget.getValue();
        } catch (Exception e) {
            log.error("tairString get error,key{}", key, e);
        }
        return null;
    }

    //缓存自增
    public Integer incr(String key) {
        return this.exincrby(key, 1);
    }

    //缓存自增
    public Integer incr(String key, Integer incrNum) {
        return this.exincrby(key, incrNum);
    }

    //缓存自减
    public Integer decr(String key, Integer decrNum) {
        return this.exincrby(key, -Math.abs(decrNum));
    }

    //删除缓存
    public Integer delete(String key) {
        try (Jedis jedis = getJedis()) {
            return jedis.del(key).intValue();
        }
    }

    //删除缓存
    public Integer mdelete(List&lt;String&gt; keyList) {
        try (Jedis jedis = getJedis()) {
            return jedis.del(keyList.toArray(new String[keyList.size()])).intValue();
        }
    }

    //缓存批量获取
    public List mget(List&lt;String&gt; keyList) {
        try (Jedis jedis = getJedis()) {
            TairString tairString = createTairString(jedis);
            return keyList.stream().map(key -&gt; {
                ExgetResult&lt;String&gt; exget = tairString.exget(key);
                if (exget != null) {
                    return exget.getValue();
                }
                return null;
            }).collect(Collectors.toList());
        }
    }

    //对TairString的value进行自增自减操作
    public Integer exincrby(String key, Integer incrNum) {
        try (Jedis jedis = getJedis()) {
            int value = createTairString(jedis).exincrBy(key, incrNum, ExincrbyParams.ExincrbyParams().min(0)).intValue();
            return value;
        } catch (Exception e) {
            //出现自增或者自减数据溢出等异常，直接返回操作失败
            return -1;
        }
    }

    //存储hash对象
    public Integer exhset(String key, String value) {
        try (Jedis jedis = getJedis()) {
            Map&lt;String, Object&gt; innerMap = JSON.parseObject(value).getInnerMap();
            Map&lt;String, String&gt; map = Maps.transformEntries(innerMap, (k, v) -&gt; String.valueOf(v));
            String exhmset = createTairHash(jedis).exhmset(key, map);
            //成功返回 OK
            return 0;
        }
    }

    //存储hash对象
    public Integer exhset(String key, String field, String value) {
        try (Jedis jedis = getJedis()) {
            return createTairHash(jedis).exhset(key, field, value, ExhsetParams.ExhsetParams().nx()).intValue();
        }
    }

    //获取hash对象
    public String exhget(String key, String field) {
        try (Jedis jedis = getJedis()) {
            String exhget = createTairHash(jedis).exhget(key, field);
            log.info("exhget key:{}, field:{}, value:{}", key, field, exhget);
            return exhget;
        }
    }
}</code></pre>
<p data-track="31">&nbsp;</p>
<p data-track="32"><strong>2.Redis集群连接池与通用对象连接池源码</strong></p>
<p data-track="33"><strong>(1)Spring的RedisConnectionFactory和实现JedisConnectionFactory</strong></p>
<p data-track="34"><strong>(2)Jedis的Pool对象是基于Apache Commons的通用对象池的</strong></p>
<p data-track="35"><strong>(3)Apache Commons的通用对象池的borrowObject()方法</strong></p>
<p data-track="36"><strong>(4)ShardedJedisFactory中创建Jedis连接对象的具体方法</strong></p>
<p data-track="37"><strong>(5)Redis分片对象ShardedJedis的创建</strong></p>
<p data-track="38"><strong>(6)ShardedJedisPool的初始化</strong></p>
<p data-track="39">&nbsp;</p>
<p data-track="40">这里的Redis集群在客户端使用一致性Hash进行分片，与Redis Cluster这种服务端集群是不同的。</p>
<p data-track="41">&nbsp;</p>
<p data-track="42"><strong>(1)Spring的RedisConnectionFactory和实现JedisConnectionFactory</strong></p>
<pre class="highlighter-hljs"><code>@Data
@Configuration
@ConditionalOnClass(RedisConnectionFactory.class)
public class RedisConfig {
    ...
    @Bean
    @ConditionalOnClass(RedisConnectionFactory.class)
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
    RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.setDefaultSerializer(new StringRedisSerializer());
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }
    ...
}

public interface RedisConnectionFactory extends PersistenceExceptionTranslator {
    //Provides a suitable connection for interacting with Redis.
    RedisConnection getConnection();

    //Provides a suitable connection for interacting with Redis Cluster.
    RedisClusterConnection getClusterConnection();

    //Provides a suitable connection for interacting with Redis Sentinel.
    RedisSentinelConnection getSentinelConnection();
}

public class JedisConnectionFactory implements InitializingBean, DisposableBean, RedisConnectionFactory {
    private @Nullable Pool&lt;Jedis&gt; pool;
    ...

    public RedisConnection getConnection() {
        if (isRedisClusterAware()) {
            return getClusterConnection();
        }

        Jedis jedis = fetchJedisConnector();
        JedisConnection connection = (getUsePool() ? 
            new JedisConnection(jedis, pool, getDatabase(), getClientName())
            : new JedisConnection(jedis, null, getDatabase(), getClientName()));
        connection.setConvertPipelineAndTxResults(convertPipelineAndTxResults);
        return postProcessConnection(connection);
    }

    protected Jedis fetchJedisConnector() {
        try {
            if (getUsePool() &amp;&amp; pool != null) {
                return pool.getResource();
            }
            Jedis jedis = createJedis();
            jedis.connect();
            potentiallySetClientName(jedis);
            return jedis;
        } catch (Exception ex) {
            throw new RedisConnectionFailureException("Cannot get Jedis connection", ex);
        }
    }
    ...
}</code></pre>
<p data-track="44"><strong>(2)Jedis的Pool对象是基于Apache Commons的通用对象池的</strong></p>
<pre class="highlighter-hljs"><code>public abstract class Pool&lt;T&gt; implements Closeable {
    //internalPool就是Apache Commons的通用对象池
    protected GenericObjectPool&lt;T&gt; internalPool;

    public T getResource() {
        try {
            return internalPool.borrowObject();
        } catch (NoSuchElementException nse) {
            ...
        }
    }
}

//假设使用ShardedJedisPool去连接多个Redis节点组成的集群，去通过getResource()方法获取连接对象
public class ShardedJedisPool extends Pool&lt;ShardedJedis&gt; {
    ...
    @Override
    public ShardedJedis getResource() {
        ShardedJedis jedis = super.getResource();
        jedis.setDataSource(this);
        return jedis;
    }

    //激活方法为空
    @Override
    public void activateObject(PooledObject&lt;ShardedJedis&gt; p) throws Exception {
    
    }
    ...
}</code></pre>
<p data-track="46"><strong>(3)Apache Commons的通用对象池的borrowObject()方法</strong></p>
<pre class="highlighter-hljs"><code>public class GenericObjectPool&lt;T&gt; extends BaseGenericObjectPool&lt;T&gt; implements ObjectPool&lt;T&gt;, GenericObjectPoolMXBean, UsageTracking&lt;T&gt; {
    //存放空闲对象的队列
    private final LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt; idleObjects;
    ...

    @Override
    public T borrowObject() throws Exception {
        return borrowObject(getMaxWaitMillis());
    }

    public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
        assertOpen();
        final AbandonedConfig ac = this.abandonedConfig;
        if (ac != null &amp;&amp; ac.getRemoveAbandonedOnBorrow() &amp;&amp; (getNumIdle() &lt; 2) &amp;&amp; (getNumActive() &gt; getMaxTotal() - 3) ) {
            removeAbandoned(ac);
        }
        PooledObject&lt;T&gt; p = null;

        //如果连接耗尽是否需要阻塞
        final boolean blockWhenExhausted = getBlockWhenExhausted();

        boolean create;
        final long waitTime = System.currentTimeMillis();

        while (p == null) {
            create = false;
            //从队列中获取对象
            p = idleObjects.pollFirst();
            if (p == null) {
                //创建对象
                p = create();
                if (p != null) {
                    create = true;
                }
            }
            ...
        }
        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
        return p.getObject();
    }

    //创建对象
    private PooledObject&lt;T&gt; create() throws Exception {
        ...
        final PooledObject&lt;T&gt; p;
        try {
            //调用Factory的makeObject()方法创建对象
            p = factory.makeObject();
            if (getTestOnCreate() &amp;&amp; !factory.validateObject(p)) {
                createCount.decrementAndGet();
                return null;
            }
        } catch (final Throwable e) {
            createCount.decrementAndGet();
            throw e;
        } finally {
            synchronized (makeObjectCountLock) {
                makeObjectCount--;
                makeObjectCountLock.notifyAll();
            }
        }
        ...
        return p;
    }

    @Override
    public void addObject() throws Exception {
        assertOpen();
        if (factory == null) {
            throw new IllegalStateException("Cannot add objects without a factory.");
        }
        final PooledObject&lt;T&gt; p = create();
        addIdleObject(p);
    }

    private void addIdleObject(final PooledObject&lt;T&gt; p) throws Exception {
        if (p != null) {
            factory.passivateObject(p);
            if (getLifo()) {
                idleObjects.addFirst(p);
            } else {
                idleObjects.addLast(p);
            }
        }
    }
    ...
}</code></pre>
<p data-track="48"><strong>(4)ShardedJedisFactory中创建Jedis连接对象的具体方法</strong></p>
<p data-track="49">一个连接会封装成一个DefaultPooledObject对象。</p>
<pre class="highlighter-hljs"><code>public class ShardedJedisPool extends Pool&lt;ShardedJedis&gt; {
    ...
    private static class ShardedJedisFactory implements PooledObjectFactory&lt;ShardedJedis&gt; {
        private List&lt;JedisShardInfo&gt; shards;
        ...

        //创建Jedis连接对象的具体方法
        @Override
        public PooledObject&lt;ShardedJedis&gt; makeObject() throws Exception {
            //创建ShardedJedis对象
            ShardedJedis jedis = new ShardedJedis(shards, algo, keyTagPattern);
            return new DefaultPooledObject&lt;ShardedJedis&gt;(jedis);
        }
        ...
    }
    ...
}</code></pre>
<p data-track="51"><strong>(5)Redis分片对象ShardedJedis的创建</strong></p>
<p data-track="52">一个ShardedJedis分片可以理解成对应一个集群，一个ShardedJedis中会有各个Redis节点的连接。即一个ShardedJedis中，会连接Redis的各个节点，每个ShardedJedis分片都有多个虚拟节点。</p>
<pre class="highlighter-hljs"><code>public class ShardedJedis extends BinaryShardedJedis implements JedisCommands, Closeable {
    ...
    public ShardedJedis(List&lt;JedisShardInfo&gt; shards, Hashing algo, Pattern keyTagPattern) {
        super(shards, algo, keyTagPattern);
    }
    ...
}

public class BinaryShardedJedis extends Sharded&lt;Jedis, JedisShardInfo&gt; implements BinaryJedisCommands {
    ...
    public BinaryShardedJedis(List&lt;JedisShardInfo&gt; shards, Hashing algo, Pattern keyTagPattern) {
        super(shards, algo, keyTagPattern);
    }
    ...
}

public class Sharded&lt;R, S extends ShardInfo&lt;R&gt;&gt; {
    public static final int DEFAULT_WEIGHT = 1;
    private TreeMap&lt;Long, S&gt; nodes;
    private final Hashing algo;
    private final Map&lt;ShardInfo&lt;R&gt;, R&gt; resources = new LinkedHashMap&lt;ShardInfo&lt;R&gt;, R&gt;();
    ...

    public Sharded(List&lt;S&gt; shards, Hashing algo, Pattern tagPattern) {
        this.algo = algo;
        this.tagPattern = tagPattern;
        initialize(shards);
    }

    private void initialize(List&lt;S&gt; shards) {
        nodes = new TreeMap&lt;Long, S&gt;();
        //每个分片都有多个虚拟节点，存放在nodes中
        for (int i = 0; i != shards.size(); ++i) {
            final S shardInfo = shards.get(i);
            int N =  160 * shardInfo.getWeight();
            if (shardInfo.getName() == null) {
                for (int n = 0; n &lt; N; n++) {
                    nodes.put(this.algo.hash("SHARD-" + i + "-NODE-" + n), shardInfo);
                }
            } else {
                for (int n = 0; n &lt; N; n++) {
                    nodes.put(this.algo.hash(shardInfo.getName() + "*" + n), shardInfo);
                }
            }
            resources.put(shardInfo, shardInfo.createResource());
        }
    }
    ...
}

public class JedisShardInfo extends ShardInfo&lt;Jedis&gt; {
    ...
    @Override
    public Jedis createResource() {
        //封装一个Jedis对象
        return new Jedis(this);
    }
    ...
}</code></pre>
<p data-track="54"><strong>(6)ShardedJedisPool的初始化</strong></p>
<pre class="highlighter-hljs"><code>public class ShardedJedisPool extends Pool&lt;ShardedJedis&gt; {
    ...
    public ShardedJedisPool(final GenericObjectPoolConfig poolConfig, List&lt;JedisShardInfo&gt; shards, Hashing algo, Pattern keyTagPattern) {
        super(poolConfig, new ShardedJedisFactory(shards, algo, keyTagPattern));
    }
    ...
}

public abstract class Pool&lt;T&gt; implements Closeable {
    protected GenericObjectPool&lt;T&gt; internalPool;
    ...

    public Pool(final GenericObjectPoolConfig poolConfig, PooledObjectFactory&lt;T&gt; factory) {
        initPool(poolConfig, factory);
    }

    public void initPool(final GenericObjectPoolConfig poolConfig, PooledObjectFactory&lt;T&gt; factory) {
        if (this.internalPool != null) {
            try {
                closeInternalPool();
            } catch (Exception e) {
            }
        }
        this.internalPool = new GenericObjectPool&lt;&gt;(factory, poolConfig);
    }
    ...
}

public class GenericObjectPool&lt;T&gt; extends BaseGenericObjectPool&lt;T&gt; implements ObjectPool&lt;T&gt;, GenericObjectPoolMXBean, UsageTracking&lt;T&gt; {
    //存放空闲对象的队列
    private final LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt; idleObjects;
    ...

    public GenericObjectPool(final PooledObjectFactory&lt;T&gt; factory, final GenericObjectPoolConfig&lt;T&gt; config) {
        super(config, ONAME_BASE, config.getJmxNamePrefix());
        if (factory == null) {
            jmxUnregister();//tidy up
            throw new IllegalArgumentException("factory may not be null");
        }
        this.factory = factory;
        //空闲对象
        idleObjects = new LinkedBlockingDeque&lt;&gt;(config.getFairness());
        setConfig(config);
    }

    public void setConfig(final GenericObjectPoolConfig&lt;T&gt; conf) {
        super.setConfig(conf);
        setMaxIdle(conf.getMaxIdle());//设置最大空闲数
        setMinIdle(conf.getMinIdle());//设置最小空闲数
        setMaxTotal(conf.getMaxTotal());
    }
    ...
}</code></pre>
<p data-track="56"><strong>(7)ShardedJedisPool的一致性Hash算法</strong></p>
<p data-track="57">下面使用ShardedJedis的set()方法为例进行说明，这里的Redis集群在客户端使用一致性Hash进行分片，与Redis Cluster这种服务端集群是不同的。</p>
<pre class="highlighter-hljs"><code>//假设使用ShardedJedisPool去连接多个Redis节点组成的集群，去通过getResource()方法获取连接对象
public class ShardedJedisPool extends Pool&lt;ShardedJedis&gt; {
    ...
    @Override
    public ShardedJedis getResource() {
        ShardedJedis jedis = super.getResource();
        jedis.setDataSource(this);
        return jedis;
    }
    ...
}

public class ShardedJedisPool extends Pool&lt;ShardedJedis&gt; {
    ...
    @Override
    public ShardedJedis getResource() {
        ShardedJedis jedis = super.getResource();
        jedis.setDataSource(this);
        return jedis;
    }
    ...
}

public class ShardedJedis extends BinaryShardedJedis implements JedisCommands, Closeable {
    ...
    protected ShardedJedisPool dataSource = null;

    @Override
    public String set(final String key, final String value) {
        Jedis j = getShard(key);//根据key获取分片
        return j.set(key, value);
    }
    ...
}

public class Sharded&lt;R, S extends ShardInfo&lt;R&gt;&gt; {
    private TreeMap&lt;Long, S&gt; nodes;
    private final Map&lt;ShardInfo&lt;R&gt;, R&gt; resources = new LinkedHashMap&lt;ShardInfo&lt;R&gt;, R&gt;();
    ...

    //根据key获取连接对象
    public R getShard(String key) {
        return resources.get(getShardInfo(key));
    }

    public S getShardInfo(String key) {
        return getShardInfo(SafeEncoder.encode(getKeyTag(key)));
    }

    public S getShardInfo(byte[] key) {
        SortedMap&lt;Long, S&gt; tail = nodes.tailMap(algo.hash(key));
        if (tail.isEmpty()) {
            return nodes.get(nodes.firstKey());
        }
        return tail.get(tail.firstKey());
    }
    ...
}</code></pre>
<p data-track="59">&nbsp;</p>
<p data-track="60"><strong>3.商品卖家系统高并发场景与缓存预热逻辑</strong></p>
<p data-track="61"><strong>(1)缓存预热的必要性</strong></p>
<p data-track="62"><strong>(2)缓存预热方式之单机和分布式的区别</strong></p>
<p data-track="63"><strong>(3)缓存预热的逻辑</strong></p>
<p data-track="64">&nbsp;</p>
<p data-track="65"><strong>(1)缓存预热的必要性</strong></p>
<p data-track="66">查询卖家信息的接口会被C端⽤户频繁请求。因为C端⽤户在使⽤商品系统时，会产⽣⼤量的卖家数据请求。如果这些请求直接查询卖家数据库，则会对卖家数据库产⽣⾮常⼤的压⼒。所以查询卖家信息的接口，需要针对卖家数据进行缓存。同时由于请求量⽐较⼤，所以不能通过⽤户发起请求来进行惰性缓存，因此需要进行卖家数据的缓存预热。</p>
<p data-track="67">&nbsp;</p>
<p data-track="68">因为卖家数据是⼀组相对固定、变化⼩的数据，所以在对外提供服务前，可先批量从DB获取数据，再设置到Redis缓存中。</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="497" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/b25f8fbb522f44d793d51c93ddec9ff6~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025062509250938234E1B3AA5CA9F4409&amp;x-expires=2147483647&amp;x-signature=Yfd4kXVtePECaCWBDcVEim8GDFU%3D" class="lazyload"></div>
<p data-track="69">查询卖家信息的接口如下：</p>
<pre class="highlighter-hljs"><code>@DubboService(version = "1.0.0", interfaceClass = SellerAbilityApi.class, retries = 0)
public class SellerAbilityApiImpl implements SellerAbilityApi {
    @Autowired
    private SellerInfoService sellerInfoService;
    ...

    //提供给商品C端调用，根据卖家ID和卖家类型获取卖家信息
    @Override
    public JsonResult&lt;List&lt;SellerInfoResponse&gt;&gt; getSellerInfo(SellerInfoRequest sellerInfoRequest) {
        try {
            List&lt;SellerInfoResponse&gt; sellerInfoResponseList = sellerInfoService.querySellerInfoForRPC(sellerInfoRequest);
            return JsonResult.buildSuccess(sellerInfoResponseList);
        } catch (ProductBizException e) {
            log.error("biz error: request={}", JSON.toJSONString(sellerInfoRequest), e);
            return JsonResult.buildError(e.getErrorCode(), e.getErrorMsg());
        } catch (Exception e) {
            log.error("system error: request={}", JSON.toJSONString(sellerInfoRequest), e);
            return JsonResult.buildError(e.getMessage());
        }
    }
    ...
}

@Service
public class SellerInfoServiceImpl implements SellerInfoService {
    @Autowired
    private SellerInfoCache sellerInfoCache;
    ...

    //不同系统间调用RPC接口，查询卖家
    //卖家系统提供给外部系统调用的卖家查询接口，只允许通过sellerIdList或者sellerType两个参数进行查询
    @Override
    public List&lt;SellerInfoResponse&gt; querySellerInfoForRPC(SellerInfoRequest request) {
        //参数校验，RPC接口根据sellerIdList和sellerType查询
        checkQuerySellerInfoRequestByRPC(request);
        //如果未传入sellerIdList
        if (CollectionUtils.isEmpty(request.getSellerIdList())) {
            //根据sellerType获取该类型下的sellerId集合
            Optional&lt;List&lt;Long&gt;&gt; sellerIdListOps = getSellerIdListBySellerType(request);
            //如果类型下没有sellerId数据，直接返回空卖家集合
            if (!sellerIdListOps.isPresent()) {
                return Collections.emptyList();
            }
            //将根据sellerType查询到的sellerIdList数据set到request中
            request.setSellerIdList(sellerIdListOps.get());
        }

        //根据sellerIdList从缓存或者数据库中查询卖家信息
        Optional&lt;List&lt;SellerInfoResponse&gt;&gt; sellerInfoListOps = 
            sellerInfoCache.listRedisStringDataByCache(
                request.getSellerIdList(),
                SellerInfoResponse.class,
                sellerId -&gt; SellerRedisKeyConstants.SELLER_INFO_LIST + sellerId,
                //根据sellerId从DB中获取SellerInfo数据
                sellerId -&gt; sellerRepository.querySellerInfoBySellerId(sellerId)
            );
        if (!sellerInfoListOps.isPresent()) {
            return Collections.emptyList();
        }
        //过滤类型不一致的卖家信息
        return filterAccordantSellerInfo(sellerInfoListOps.get(), request);
    }
    ...
}</code></pre>
<p data-track="71"><strong>(2)缓存预热方式之单机和分布式的区别</strong></p>
<p data-track="72">卖家系统提供了两个接口可手动触发单机的缓存预热 + 分布式的缓存预热。无论是单机还是分布式的缓存预热，都会查出全量的卖家数据来进行预热。</p>
<p data-track="73">&nbsp;</p>
<p data-track="74">如果已预热过，可通过设置force=true来强制再进行全量卖家数据的预热。由于预热完成后，卖家系统可能还会对卖家数据进行变更，所以每隔5分钟执行一个定时任务查询DB里的数据，diff缓存数据并刷新。</p>
<p data-track="75">&nbsp;</p>
<p data-track="76">第一次预热可使用单机的缓存预热接口、也可使用分布式的缓存预热接口。</p>
<p data-track="77">&nbsp;</p>
<p data-track="78">一.单机的意思，就是由卖家系统的一台机器进行全量卖家数据的预热操作。</p>
<p data-track="79">&nbsp;</p>
<p data-track="80">二.分布式的意思，就是收到分布式预热请求的一台机器，会先去DB查询出一批批的卖家数据，然后发送到MQ。接着由卖家系统的多台机器去消费这些卖家数据，从而实现分布式预热。</p>
<p data-track="81">&nbsp;</p>
<p data-track="82"><strong>(3)缓存预热的逻辑</strong></p>
<p data-track="83">预热逻辑，在业务上并不复杂。主要是在尚未对外提供服务前，把所有的卖家数据，设置到Redis缓存。在对外提供服务后，能做到绝大部分的卖家信息请求，都能直接通过缓存来提供数据服务，避免对MySQL造成⽐较⼤的压⼒。</p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="669" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/ebddeb984a0a4e7f9c5da73d32f1aa53~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025062509250938234E1B3AA5CA9F4409&amp;x-expires=2147483647&amp;x-signature=Jkb%2FdKPTI2wBugTHUx4rG%2BkxxMM%3D" class="lazyload"></div>
<p data-track="84">&nbsp;</p>
<p data-track="85"><strong>4.商品卖家系统缓存预热架构设计</strong></p>
<p data-track="86"><strong>(1)Redis缓存结构设计</strong></p>
<p data-track="87"><strong>(2)单机的缓存预热方案设计</strong></p>
<p data-track="88"><strong>(3)分布式的缓存预热⽅案设计</strong></p>
<p data-track="89">&nbsp;</p>
<p data-track="90"><strong>(1)Redis缓存结构设计</strong></p>
<div class="pgc-img"><img data-ic="false" data-width="1080" data-height="433" data-ic-uri="" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/be92c96af82f4b74a63e64d77863cccc~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025062509250938234E1B3AA5CA9F4409&amp;x-expires=2147483647&amp;x-signature=YzJazvHk6xqVNtyOwsqSZEPI4kA%3D" class="lazyload"></div>
<p data-track="91"><strong>(2)单机的缓存预热方案设计</strong></p>
<p data-track="92"><strong>步骤一：</strong>执⾏预热操作前，先添加分布式锁，保证执行的原⼦性。</p>
<p data-track="93">&nbsp;</p>
<p data-track="94"><strong>步骤二：</strong>判断forceFlush是否强制刷新参数是否为1。如果为1，则代表强制刷新。如果为0，则代表不强制刷新缓存。</p>
<p data-track="95">&nbsp;</p>
<p data-track="96"><strong>步骤三：</strong>forceFlush如果为0，则从Redis中获取缓存的预热状态。如果预热状态为成功，则不预热。</p>
<p data-track="97">&nbsp;</p>
<p data-track="98"><strong>步骤四：</strong>通过sellerType卖家类型参数判断指定需要预热缓存的卖家类型。如果传⼊为0，代表预热所有卖家数据，否则代表预热的是sellerType卖家。根据sellerType，一页一页去DB查询出卖家数据，直到查出的数据为空。</p>
<p data-track="99">&nbsp;</p>
<p data-track="100"><strong>步骤五：</strong>将每一页查出的100条卖家数据，构建成写入缓存的数据Map。接着将数据Map通过mset写入缓存，以任务的形式，提交给线程池处理。其中的线程池会通过Semaphore进行阻塞最多提交20个写入缓存的任务。</p>
<p data-track="101">&nbsp;</p>
<p data-track="102"><strong>步骤六：</strong>数据处理完后，在Redis中设置卖家信息的缓存预热状态为成功。</p>
<p data-track="103">&nbsp;</p>
<p data-track="104"><strong>步骤七：</strong>如果以上步骤出现异常，则在catch中设置缓存预热状态为失败。</p>
<p data-track="105">&nbsp;</p>
<p data-track="106"><strong>步骤八：</strong>最后在finally块中释放分布式锁。</p>
<p data-track="107">&nbsp;</p>
<p data-track="108"><strong>(3)分布式的缓存预热⽅案设计</strong></p>
<p data-track="109"><strong>一.⽣产者</strong></p>
<p data-track="110"><strong>步骤一：</strong>执⾏预热操作前，先添加分布式锁，保证执行的原⼦性。</p>
<p data-track="111">&nbsp;</p>
<p data-track="112"><strong>步骤二：</strong>判断forceFlush是否强制刷新参数是否为1。如果为1，则代表强制刷新。如果为0，则代表不强制刷新缓存。</p>
<p data-track="113">&nbsp;</p>
<p data-track="114"><strong>步骤三：</strong>forceFlush如果为0，则从Redis中获取缓存的预热状态。如果预热状态为成功，则不预热。</p>
<p data-track="115">&nbsp;</p>
<p data-track="116"><strong>步骤四：</strong>通过sellerType卖家类型参数判断指定需要预热缓存的卖家类型。如果传⼊为0，代表预热所有卖家数据；否则代表预热的是sellerType卖家。然后通过分批次，查询出满⾜sellerType类型的所有卖家数据。每批查100个卖家，会将这100个卖家数据转换为JSON字符串。接着将JSON字符串添加到集合中，将最终的查询结果组装为List。</p>
<p data-track="117">&nbsp;</p>
<p data-track="118"><strong>步骤五：</strong>将查询出的卖家数据集合List批量或分批次发送给MQ，对应的MQ的topic为：preheat_seller_cache_bucket_topic。</p>
<p data-track="119">&nbsp;</p>
<p data-track="120"><strong>步骤六：</strong>消息发送成功后，在Redis中设置卖家信息的缓存预热状态为成功。</p>
<p data-track="121">&nbsp;</p>
<p data-track="122"><strong>步骤七：</strong>如果以上步骤出现异常，则在catch中设置缓存预热状态为失败。</p>
<p data-track="123">&nbsp;</p>
<p data-track="124"><strong>步骤八：</strong>最后在finally块中释放分布式锁。</p>
<p data-track="125">&nbsp;</p>
<p data-track="126"><strong>二.消费者</strong></p>
<p data-track="127"><strong>步骤一：</strong>每个消费者每次消费⼀条消息。</p>
<p data-track="128">&nbsp;</p>
<p data-track="129"><strong>步骤二：</strong>拿到消息后，解析出需要预热的缓存数据，即构造出100个元素的sellerInfoResultMap。其中key为Redis卖家信息缓存的key，value为卖家信息JSON字符串，然后通过执行mset将数据设置到Redis缓存。</p>
<p data-track="130">&nbsp;</p>
<p data-track="131"><strong>步骤三：</strong>接着提取出sellerIdList集合，并根据消息中卖家信息的sellerType，构造出Redis卖家类型的⻚缓存的key，然后通过set命令设置到Redis。</p>
<p data-track="132">&nbsp;</p>
<p data-track="133"><strong>5.商品卖家系统单机下的缓存预热的实现</strong></p>
<p data-track="134"><strong>(1)实现细节</strong></p>
<p data-track="135"><strong>(2)实现代码</strong></p>
<p data-track="136">&nbsp;</p>
<p data-track="137"><strong>(1)实现细节</strong></p>
<p data-track="138">一.一页一页地查询数据，然后构建写入缓存的数据的Map，最后生成任务提交给线程池进行处理。</p>
<p data-track="139">&nbsp;</p>
<p data-track="140">二.如果在ThreadPoolExecutor中设置一个无限队列的Queue，那么可能会让该Queue不断增长从而撑满内存。如果提交的任务不需排队，而是提交一个任务就创建一个线程来执行，那么又可能会耗尽线程。</p>
<p data-track="141">&nbsp;</p>
<p data-track="142">所以为了线程池安全，可以使用Semaphore信号量进行阻塞。如果超过了20个任务同时要运行，会通过Semaphore信号量阻塞提交任务，从而实现安全的线程池。</p>
<p data-track="143">&nbsp;</p>
<p data-track="144"><strong>(2)实现代码</strong></p>
<p data-track="145"><strong>步骤一：</strong>执⾏预热操作前，先添加分布式锁，保证执行的原⼦性。</p>
<p data-track="146">&nbsp;</p>
<p data-track="147"><strong>步骤二：</strong>判断forceFlush是否强制刷新参数是否为1。如果为1，则代表强制刷新。如果为0，则代表不强制刷新缓存。</p>
<p data-track="148">&nbsp;</p>
<p data-track="149"><strong>步骤三：</strong>forceFlush如果为0，则从Redis中获取缓存的预热状态。如果预热状态为成功，则不预热。</p>
<p data-track="150">&nbsp;</p>
<p data-track="151"><strong>步骤四：</strong>通过sellerType卖家类型参数判断指定需要预热缓存的卖家类型。如果传⼊为0，代表预热所有卖家数据；否则代表预热的是sellerType卖家。根据sellerType，一页一页去DB查询出卖家数据，直到查出的数据为空。</p>
<p data-track="152">&nbsp;</p>
<p data-track="153"><strong>步骤五：</strong>将每一页查出的100条卖家数据，构建成写入缓存的数据Map。接着将数据Map通过mset写入缓存，以任务的形式，提交给线程池处理。其中的线程池会通过Semaphore进行阻塞最多提交20个写入缓存的任务。</p>
<p data-track="154">&nbsp;</p>
<p data-track="155"><strong>步骤六：</strong>数据处理完后，在Redis中设置卖家信息的缓存预热状态为成功。</p>
<p data-track="156">&nbsp;</p>
<p data-track="157"><strong>步骤七：</strong>如果以上步骤出现异常，则在catch中设置缓存预热状态为失败。</p>
<p data-track="158">&nbsp;</p>
<p data-track="159"><strong>步骤八：</strong>最后在finally块中释放分布式锁。</p>
<pre class="highlighter-hljs"><code>@RestController
@RequestMapping("/sellerCache")
public class SellerCacheController {
    @Autowired
    private SellerInfoCache sellerInfoCache;

    @PostMapping("/preheat")
    public JsonResult&lt;Boolean&gt; preheatSellerCache(@RequestBody SellerInfoCacheRequest request) {
        try {
            Boolean result = sellerInfoCache.preheatSellerCache(request);
            return JsonResult.buildSuccess(result);
        } catch (BaseBizException baseBizException) {
            log.error("biz error: request={}", JSON.toJSONString(request), baseBizException);
            return JsonResult.buildError(baseBizException.getMessage());
        } catch (Exception e) {
            log.error("system error: request={}", JSON.toJSONString(request), e);
            return JsonResult.buildError(e.getMessage());
        }
    }
    ...
}

@Service("sellerInfoCache")
public class SellerInfoCache {
    @Resource
    private SellerRepository sellerRepository;

    @Resource
    private RedisCache redisCache;

    @Resource
    private RedisLock redisLock;

    //缓存预热的线程池
    @Autowired
    @Qualifier("preheatCacheThreadPool")
    private PreheatCacheThreadPool preheatCacheThreadPool;
    ...

    //根据卖家类型预热卖家缓存
    public Boolean preheatSellerCache(SellerInfoCacheRequest cacheRequest) {
        try {
            //1.先获取一把分布式锁
            redisLock.lock(SELLER_INFO_CACHE_PREHEAT_LOCK);

            //2.判断是否需要强制刷新缓存，如果不需要强制刷新，则判断是否预热过
            //如果需要强制刷新缓存，则不用判断是否预热过
            if (!NumberUtils.INTEGER_ONE.equals(cacheRequest.getForceFlush())) {
                //如果已经预热过，则直接返回true
                if (isPreheated()) {
                    return true;
                }
            }
            //3.根据卖家类型刷新缓存，如果没有选择类型，则默认两种都进行预热
            if (NumberUtils.INTEGER_ZERO.equals(cacheRequest.getSellerType())) {
                //预热卖家信息
                preheatSellerInfoToCache(SellerTypeEnum.SELF.getCode());
                //预热卖家id列表信息
                preheatSellerIdCache(SellerTypeEnum.SELF.getCode());
                preheatSellerInfoToCache(SellerTypeEnum.POP.getCode());
                preheatSellerIdCache(SellerTypeEnum.POP.getCode());
            } else {
                //4.如果选择了类型，就按照类型来预热
                preheatSellerInfoToCache(cacheRequest.getSellerType());
                preheatSellerIdCache(cacheRequest.getSellerType());
            }
            redisCache.set(SELLER_INFO_CACHE_PREHEAT_SUCCESS, SellerCacheStatusEnum.SUCCESS.getCode().toString(), -1);
            return true;
        } catch (Exception e) {
            redisCache.set(SELLER_INFO_CACHE_PREHEAT_SUCCESS, SellerCacheStatusEnum.FAIL.getCode().toString(), -1);
            throw new BaseBizException("缓存预热失败，error:{}", JSON.toJSONString(e));
        } finally {
            //释放锁
            redisLock.unlock(SELLER_INFO_CACHE_PREHEAT_LOCK);
        }
    }

    //判断缓存是否预热成功
    private Boolean isPreheated() {
        //如果预热key不存在，则说明没有预热过
        Boolean isExist = redisCache.hasKey(SELLER_INFO_CACHE_PREHEAT_SUCCESS);
        if (!isExist) {
            return false;
        }
        //如果预热key存在，且值为1，则代表预热成功
        Integer success = Integer.parseInt(redisCache.get(SELLER_INFO_CACHE_PREHEAT_SUCCESS));
        if (!SellerCacheStatusEnum.SUCCESS.getCode().equals(success)) {
            return false;
        }
        return true;
    }

    //根据用户类型预热缓存
    public Boolean preheatSellerInfoToCache(Integer type) {
        SellerInfoRequest request = new SellerInfoRequest();
        request.setSellerType(type);
        Integer pageNum = request.getPageNo();
        //设置每页数据量
        request.setPageSize(CollectionSize.DEFAULT);

        //一页一页地去查询数据并交给线程池进行处理
        while (true) {
            Optional&lt;List&lt;SellerInfoResponse&gt;&gt; sellerInfoResponses = sellerRepository.querySellerInfo(request);
            if (!sellerInfoResponses.isPresent()) {
                break;
            }
            List&lt;SellerInfoResponse&gt; sellerInfoResponseList = sellerInfoResponses.get();
            //查到的数据为空时跳出循环
            if (CollectionUtils.isEmpty(sellerInfoResponseList)) {
                break;
            }

            Map&lt;String, String&gt; result = new HashMap&lt;&gt;(sellerInfoResponseList.size());
            //构建写入缓存的数据的map
            for (SellerInfoResponse sellerInfoResponse : sellerInfoResponseList) {
                Long sellerId = sellerInfoResponse.getSellerId();
                result.put(SellerRedisKeyConstants.SELLER_INFO_LIST + sellerId, JSON.toJSONString(sellerInfoConverter.responseToDTO(sellerInfoResponse)));
            }
            log.info("本批次缓存map:{}", JSON.toJSONString(result));
            //把本批次的缓存预热任务提交给线程池处理
            preheatCacheThreadPool.execute(() -&gt; redisCache.mset(result));

            //继续取下一页的用户数据
            request.setPageNo(++pageNum);
            log.info("第" + pageNum + "页数据预热完成");
        }
        return true;
    }

    //根据类型预热用户id缓存
    Boolean preheatSellerIdCache(Integer type) {
        //根据类型全量查卖家ID
        SellerInfoRequest request = new SellerInfoRequest();
        Integer pageNo = request.getPageNo();
        request.setSellerType(type);
        request.setPageSize(CollectionSize.DEFAULT);
        String key = SellerRedisKeyConstants.SELF_TYPE_LIST;
        if (SellerTypeEnum.POP.getCode().equals(type)) {
            key = SellerRedisKeyConstants.POP_TYPE_LIST;
        }
        while (true) {
            Optional&lt;List&lt;Long&gt;&gt; optionalList = sellerRepository.pageSellerIdListByType(request);
            if (!optionalList.isPresent()) {
                break;
            }
            List&lt;Long&gt; sellerIdList = optionalList.get();
            //查到的数据为空时跳出循环
            if (CollectionUtils.isEmpty(sellerIdList)) {
                break;
            }
            log.info("本批次缓存list:{}", JSON.toJSONString(sellerIdList));
            //存Redis
            String finalKey = key + pageNo;
            preheatCacheThreadPool.execute(() -&gt; redisCache.set(finalKey, JSON.toJSONString(sellerIdList), -1));
            //继续取下一页的用户数据
            request.setPageNo(++pageNo);
        }
        return true;
    }
    ...
}

@Repository
public class SellerRepository {
    ...
    //根据条件分页查询出卖家列表
    public Optional&lt;List&lt;SellerInfoResponse&gt;&gt; querySellerInfo(SellerInfoRequest request) {
        LambdaQueryWrapper&lt;SellerInfoDO&gt; queryWrapper = Wrappers.lambdaQuery();
        //类型
        queryWrapper.eq(Objects.nonNull(request.getSellerType()), SellerInfoDO::getSellerType, request.getSellerType());
        //卖家位置(层级)
        queryWrapper.eq(Objects.nonNull(request.getSellerPosition()), SellerInfoDO::getSellerPosition, request.getSellerPosition());
        //状态
        queryWrapper.eq(Objects.nonNull(request.getSellerStatus()), SellerInfoDO::getSellerStatus, request.getSellerStatus());
        //卖家ID
        queryWrapper.eq(Objects.nonNull(request.getSellerId()), SellerInfoDO::getSellerId, request.getSellerId());
        //卖家编码
        queryWrapper.eq(StringUtils.isNotEmpty(request.getSellerCode()), SellerInfoDO::getSellerCode, request.getSellerCode());
        //卖家名称
        queryWrapper.like(StringUtils.isNotEmpty(request.getSellerName()), SellerInfoDO::getSellerName, request.getSellerName());
        //父卖家ID
        queryWrapper.eq(Objects.nonNull(request.getParentId()), SellerInfoDO::getParentId, request.getParentId());
        //卖家ID集合
        queryWrapper.in(CollectionUtils.isNotEmpty(request.getSellerIdList()), SellerInfoDO::getSellerId, request.getSellerIdList());

        Page&lt;SellerInfoDO&gt; page = new Page&lt;&gt;(request.getPageNo(), request.getPageSize());
        Page&lt;SellerInfoDO&gt; pageResult = sellerInfoMapper.selectPage(page, queryWrapper);
        if (Objects.isNull(pageResult)) {
            return Optional.of(Collections.emptyList());
        }
        return Optional.of(sellerInfoConverter.listEntityToResponse(pageResult.getRecords()));
    }
    ...
}

public class PreheatCacheThreadPool {
    private final Semaphore semaphore;
    private final ThreadPoolExecutor threadPoolExecutor;

    public PreheatCacheThreadPool(int permits) {
        //如果超过了20个任务同时要运行，会通过Semaphore信号量阻塞，从而实现安全的线程池
        semaphore = new Semaphore(permits);

        //这里设置核心线程数为0，是因为缓存预热的任务是一次性执行
        //所以没有比要保留核心线程，等线程工作完毕，线程就全部退出即可

        //如果不使用Semaphore，而在ThreadPoolExecutor中设置一个无限队列的Queue，
        //那么可能会让该Queue不断增长从而撑满内存；
        //如果提交的任务不需排队，而是提交一个任务就创建一个线程来执行，
        //那么又可能会耗尽线程；
        threadPoolExecutor = new ThreadPoolExecutor(
            0,
            permits * 2,//乘以2是因为semaphore的释放要比线程的完成早一点点
            60,
            TimeUnit.SECONDS,
            new SynchronousQueue&lt;&gt;()
        );
    }

    public void execute(Runnable task) {
        //超过了20个同步任务就阻塞住，不让它执行太多，从而实现安全的线程池
        semaphore.acquireUninterruptibly();

        threadPoolExecutor.submit(() -&gt; {
            try {
                task.run();
            } finally {
                //semaphore的释放要比当前线程任务的结束要早一点点
                //导致Semaphore放行很多任务进来了，但是线程池的线程还没释放
                semaphore.release();
            }
        });
    }
}</code></pre>
<p data-track="161">&nbsp;</p>
<p data-track="162"><strong>6.商品卖家系统分布式下的缓存预热的实现</strong></p>
<p data-track="163"><strong>(1)发送消息</strong></p>
<p data-track="164"><strong>(2)消费消息</strong></p>
<p data-track="165">&nbsp;</p>
<p data-track="166"><strong>(1)发送消息</strong></p>
<p data-track="167"><strong>步骤一：</strong>执⾏预热操作前，先添加分布式锁，保证执行的原⼦性。</p>
<p data-track="168">&nbsp;</p>
<p data-track="169"><strong>步骤二：</strong>判断forceFlush是否强制刷新参数是否为1。如果为1，则代表强制刷新；如果为0，则代表不强制刷新缓存。</p>
<p data-track="170">&nbsp;</p>
<p data-track="171"><strong>步骤三：</strong>forceFlush如果为0，则从Redis中获取缓存的预热状态。如果预热状态为成功，则不预热。</p>
<p data-track="172">&nbsp;</p>
<p data-track="173"><strong>步骤四：</strong>通过sellerType卖家类型参数判断指定需要预热缓存的卖家类型。如果传⼊为0，代表预热所有卖家数据，否则代表预热的是sellerType卖家。然后通过分批次，查询出满⾜sellerType类型的所有卖家数据。每批查100个卖家，会将这100个卖家数据转换为JSON字符串。接着将JSON字符串添加到集合中，将最终的查询结果组装为List。</p>
<p data-track="174">&nbsp;</p>
<p data-track="175"><strong>步骤五：</strong>将查询出的卖家数据集合List批量或分批次发送给MQ，对应的MQ的topic为：preheat_seller_cache_bucket_topic。</p>
<p data-track="176">&nbsp;</p>
<p data-track="177"><strong>步骤六：</strong>消息发送成功后，在Redis中设置卖家信息的缓存预热状态为成功。</p>
<p data-track="178">&nbsp;</p>
<p data-track="179"><strong>步骤七：</strong>如果以上步骤出现异常，则在catch中设置缓存预热状态为失败。</p>
<p data-track="180">&nbsp;</p>
<p data-track="181"><strong>步骤八：</strong>最后在finally块中释放分布式锁。</p>
<pre class="highlighter-hljs"><code>@RestController
@RequestMapping("/sellerCache")
public class SellerCacheController {
    @Autowired
    private SellerInfoCache sellerInfoCache;
    
    @PostMapping("shardingPreheat")
    public JsonResult&lt;Boolean&gt; shardingPreheatSellerCache(@RequestBody SellerInfoCacheRequest request) {
        try {
            Boolean result = sellerInfoCache.shardingPreheatSellerCache(request);
            return JsonResult.buildSuccess(result);
        } catch (BaseBizException baseBizException) {
            log.error("biz error: request={}", JSON.toJSONString(request), baseBizException);
            return JsonResult.buildError(baseBizException.getMessage());
        } catch (Exception e) {
            log.error("system error: request={}", JSON.toJSONString(request), e);
            return JsonResult.buildError(e.getMessage());
        }
    }
}

@Service("sellerInfoCache")
public class SellerInfoCache {
    @Resource
    private SellerRepository sellerRepository;

    @Resource
    private RedisCache redisCache;

    @Resource
    private RedisLock redisLock;

    @Autowired
    private DefaultProducer defaultProducer;
    ...

    //卖家缓存预热，分布式
    public Boolean shardingPreheatSellerCache(SellerInfoCacheRequest request) {
        try {
            //检查参数
            checkPreheatParam(request);
            //获取一把分布式锁
            redisLock.lock(SELLER_INFO_CACHE_PREHEAT_LOCK);
            //如果需要强制刷新缓存，则不用判断是否预热过
            if (!NumberUtils.INTEGER_ONE.equals(request.getForceFlush())) {
                //如果已经预热过，则直接返回true
                if (isPreheated()) {
                    return true;
                }
            }
            //分批次查询出卖家数据
            //sellerInfoList中的每个String都是100个卖家数据组册的一个batch对应的json数组
            List&lt;String&gt; sellerInfoList = sellerRepository.querySellerInfoByPage(request.getSellerType());
            //发送到MQ
            //这些json数组对应的一条String消息会被defaultProducer.sendMessages()方法批量发送
            //TODO 将sellerInfoList拆分成每10个为一批次进行分批发送
            defaultProducer.sendMessages(PREHEAT_SELLER_CACHE_BUCKET_TOPIC, sellerInfoList, "卖家缓存预热消息");
            redisCache.set(SELLER_INFO_CACHE_PREHEAT_SUCCESS, SellerCacheStatusEnum.SUCCESS.getCode().toString(), -1);
            return true;
        } catch (Exception e) {
            redisCache.set(SELLER_INFO_CACHE_PREHEAT_SUCCESS, SellerCacheStatusEnum.FAIL.getCode().toString(), -1);
            throw new BaseBizException("缓存预热失败，error:{}", JSON.toJSONString(e));
        } finally {
            //释放锁
            redisLock.unlock(SELLER_INFO_CACHE_PREHEAT_LOCK);
            return false;
        }
    }
    ...
}

@Component
public class DefaultProducer {
    private final TransactionMQProducer producer;
    ...
    //批量发送消息
    public void sendMessages(String topic, List&lt;String&gt; messages, String type) {
        sendMessages(topic, messages, -1, type);
    }

    //批量发送消息
    public void sendMessages(String topic, List&lt;String&gt; messages, Integer delayTimeLevel, String type) {
        List&lt;Message&gt; list = new ArrayList&lt;&gt;();
        for (String message : messages) {
            Message msg = new Message(topic, message.getBytes(StandardCharsets.UTF_8));
            if (delayTimeLevel &gt; 0) {
                msg.setDelayTimeLevel(delayTimeLevel);
            }
            list.add(msg);
        }
        try {
            SendResult send = producer.send(list);
            if (SendStatus.SEND_OK == send.getSendStatus()) {
                log.info("发送MQ消息成功, type:{}", type);
            } else {
                throw new BaseBizException(send.getSendStatus().toString());
            }
        } catch (Exception e) {
            log.error("发送MQ消息失败：", e);
            throw new BaseBizException("消息发送失败");
        }
    }
    ...
}

@Repository
public class SellerRepository {
    ...
    //分批次查询出卖家数据
    //List中的每一个元素，是每一页的卖家数据集合JSON字符串
    public List&lt;String&gt; querySellerInfoByPage(Integer sellerType) {
        LambdaQueryWrapper&lt;SellerInfoDO&gt; queryWrapper = Wrappers.lambdaQuery();
        queryWrapper.eq(SellerInfoDO::getDelFlag, YesOrNoEnum.YES.getCode());
        queryWrapper.eq(SellerInfoDO::getSellerStatus, SellerInfoStatusEnum.OPEN_STATUS.getCode());
        //如果指定预热全部卖家，则查询所有卖家数据
        if (sellerType.equals(SellerTypeEnum.ALL.getCode())) {
            return queryTotalSellerInfoByPage();
        }
        //查询匹配类型的卖家
        return queryBatchSellerInfoByPage(sellerType);
    }

    //分批次查询出所有类型的卖家信息
    private List&lt;String&gt; queryTotalSellerInfoByPage() {
        List&lt;String&gt; selfSellerInfoList = queryBatchSellerInfoByPage(SellerTypeEnum.SELF.getCode());
        List&lt;String&gt; popSellerInfoList = queryBatchSellerInfoByPage(SellerTypeEnum.POP.getCode());
        List&lt;String&gt; resultList = new ArrayList&lt;&gt;(selfSellerInfoList);
        resultList.addAll(popSellerInfoList);
        return resultList;
    }

    //分批次查询出指定类型的卖家信息
    private List&lt;String&gt; queryBatchSellerInfoByPage(Integer sellerType) {
        List&lt;String&gt; batchList = new ArrayList&lt;&gt;();
        SellerInfoRequest request = new SellerInfoRequest();
        request.setSellerType(sellerType);
        Integer pageNum = request.getPageNo();
        //设置每页数据量
        request.setPageSize(SkuSellerRelationConstants.QUERY_MAX_PAGE_SIZE);
        while (true) {
            //根据条件分页查询出卖家列表
            Optional&lt;List&lt;SellerInfoResponse&gt;&gt; sellerInfoResponses = querySellerInfo(request);
            if (!sellerInfoResponses.isPresent()) {
                break;
            }
            List&lt;SellerInfoResponse&gt; sellerInfoResponseList = sellerInfoResponses.get();
            if (CollectionUtils.isEmpty(sellerInfoResponseList)) {
                break;
            }
            String batchResult = getBatchResult(sellerInfoResponseList, pageNum);
            batchList.add(batchResult);
            //继续取下一页的用户数据
            request.setPageNo(++pageNum);
        }
        return batchList;
    }

    //根据条件分页查询出卖家列表
    public Optional&lt;List&lt;SellerInfoResponse&gt;&gt; querySellerInfo(SellerInfoRequest request) {
        LambdaQueryWrapper&lt;SellerInfoDO&gt; queryWrapper = Wrappers.lambdaQuery();
        //类型
        queryWrapper.eq(Objects.nonNull(request.getSellerType()), SellerInfoDO::getSellerType, request.getSellerType());
        //卖家位置(层级)
        queryWrapper.eq(Objects.nonNull(request.getSellerPosition()), SellerInfoDO::getSellerPosition, request.getSellerPosition());
        //状态
        queryWrapper.eq(Objects.nonNull(request.getSellerStatus()), SellerInfoDO::getSellerStatus, request.getSellerStatus());
        //卖家ID
        queryWrapper.eq(Objects.nonNull(request.getSellerId()), SellerInfoDO::getSellerId, request.getSellerId());
        //卖家编码
        queryWrapper.eq(StringUtils.isNotEmpty(request.getSellerCode()), SellerInfoDO::getSellerCode, request.getSellerCode());
        //卖家名称
        queryWrapper.like(StringUtils.isNotEmpty(request.getSellerName()), SellerInfoDO::getSellerName, request.getSellerName());
        //父卖家ID
        queryWrapper.eq(Objects.nonNull(request.getParentId()), SellerInfoDO::getParentId, request.getParentId());
        //卖家ID集合
        queryWrapper.in(CollectionUtils.isNotEmpty(request.getSellerIdList()), SellerInfoDO::getSellerId, request.getSellerIdList());

        Page&lt;SellerInfoDO&gt; page = new Page&lt;&gt;(request.getPageNo(), request.getPageSize());
        Page&lt;SellerInfoDO&gt; pageResult = sellerInfoMapper.selectPage(page, queryWrapper);
        if (Objects.isNull(pageResult)) {
            return Optional.of(Collections.emptyList());
        }

        return Optional.of(sellerInfoConverter.listEntityToResponse(pageResult.getRecords()));
    }

    //将每页的卖家数据转换成JSON
    private String getBatchResult(List&lt;SellerInfoResponse&gt; sellerInfoResponseList, Integer pageNum) {
        List&lt;String&gt; batchResult = new ArrayList&lt;&gt;(sellerInfoResponseList.size());
        for (SellerInfoResponse sellerInfoResponse : sellerInfoResponseList) {
            PreheatSellerMessage message = new PreheatSellerMessage();
            message.setCachePageNo(pageNum);
            message.setSellerInfo(sellerInfoResponse);
            batchResult.add(JsonUtil.object2Json(message));
        }
        return JsonUtil.object2Json(batchResult);
    }
    ...
}</code></pre>
<p data-track="183"><strong>(2)消费消息</strong></p>
<p data-track="184">通过多机器分布式消费MQ来实现分布式预热缓存。</p>
<p data-track="185">&nbsp;</p>
<p data-track="186"><strong>步骤一：</strong>每个消费者每次消费⼀条消息。</p>
<p data-track="187">&nbsp;</p>
<p data-track="188"><strong>步骤二：</strong>拿到消息后，解析出需要预热的缓存数据，即构造出100个元素的sellerInfoResultMap，其中key为Redis卖家信息缓存的key，value为卖家信息JSON字符串。然后通过执行mset将数据设置到Redis缓存。</p>
<p data-track="189">&nbsp;</p>
<p data-track="190"><strong>步骤三：</strong>接着提取出sellerIdList集合，并根据消息中卖家信息的sellerType，构造出Redis卖家类型的⻚缓存的key，然后通过执行set设置到Redis缓存。</p>
<pre class="highlighter-hljs"><code>//缓存预热消费者
@Component
public class SellerPreheatCacheListener implements MessageListenerConcurrently {
    @Autowired
    private RedisCache redisCache;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        //每个消费者每次消费分批次的多页数据，也就是List&lt;String&gt;，每个String对应了一页的数据
        //每个String包含页码和该页下的100个SellerInfo集合
        try {
            for (MessageExt messageExt : list) {
                //获取到分批次的多页数据List
                String msg = new String(messageExt.getBody());
                List messageList = JsonUtil.json2Object(msg, List.class);
                if (CollectionUtils.isEmpty(messageList)) {
                    throw new BaseBizException(ProductErrorCodeEnum.PARAM_CHECK_ERROR, ProductErrorCodeEnum.PARAM_CHECK_ERROR.getErrorCode());
                }

                Map&lt;String, String&gt; sellerInfoResultMap = new HashMap&lt;&gt;(messageList.size());
                List&lt;Long&gt; sellerIdList = new ArrayList&lt;&gt;(messageList.size());
                //List&lt;String&gt;中的每个String，都包含了100个卖家数据，这些卖家类型都是一样的
                for (Object message : messageList) {
                    PreheatSellerMessage preheatSellerMessage = JsonUtil.json2Object(message.toString(), PreheatSellerMessage.class);
                    if (Objects.isNull(preheatSellerMessage)) {
                        throw new BaseBizException(ProductErrorCodeEnum.PARAM_CHECK_ERROR, ProductErrorCodeEnum.PARAM_CHECK_ERROR.getErrorCode());
                    }
                    //卖家信息
                    SellerInfoResponse sellerInfo = preheatSellerMessage.getSellerInfo();
                    //卖家信息的Key
                    String sellerInfoKey = SellerRedisKeyConstants.SELLER_INFO_LIST + sellerInfo.getSellerId();
                    //卖家信息集合
                    sellerInfoResultMap.put(sellerInfoKey, JsonUtil.object2Json(sellerInfo));
                    //卖家ID集合
                    sellerIdList.add(sellerInfo.getSellerId());
                }

                PreheatSellerMessage preheatSellerMessage = JsonUtil.json2Object(messageList.get(0).toString(), PreheatSellerMessage.class);
                if (Objects.isNull(preheatSellerMessage)) {
                    throw new BaseBizException(ProductErrorCodeEnum.PARAM_CHECK_ERROR, ProductErrorCodeEnum.PARAM_CHECK_ERROR.getErrorCode());
                }

                //卖家类型
                Integer sellerType = preheatSellerMessage.getSellerInfo().getSellerType();
                //卖家类型的key
                String sellerTypeKey = "";
                if (sellerType.equals(SellerTypeEnum.SELF.getCode())) {
                    sellerTypeKey = SellerRedisKeyConstants.SELF_TYPE_LIST + preheatSellerMessage.getCachePageNo();
                } else {
                    sellerTypeKey = SellerRedisKeyConstants.POP_TYPE_LIST + preheatSellerMessage.getCachePageNo();
                }

                //将卖家信息set到缓存
                redisCache.mset(sellerInfoResultMap);
                //将卖家类型ID集合set到缓存
                redisCache.set(sellerTypeKey, JsonUtil.object2Json(sellerIdList), -1);
            }
        } catch (Exception e) {
            log.error("consume error, 缓存预热消息消费失败", e);
            //本次消费失败，下次重新消费
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
}</code></pre>
<p data-track="192">&nbsp;</p>
<p data-track="193"><strong>7.商品卖家系统定时查询DB最新数据更新缓存</strong></p>
<pre class="highlighter-hljs"><code>//卖家缓存数据同步
@Component
public class SellerCacheSyncSchedule {
    @Autowired
    private RedisCache redisCache;

    @Autowired
    private SellerRepository sellerRepository;

    //卖家缓存数据同步定时任务
    //5分钟执行一次，每次查询出数据库最近5分钟的更新和新增数据，然后同步差异数据到缓存
    @XxlJob("cacheSync")
    public void cacheSync() {
        //计算出前五分钟的时间
        Date beforeTIme = getBeforeTime();
        //从数据库中查询出最近5分钟内的数据
        List&lt;SellerInfoDO&gt; sellerInfoList = sellerRepository.querySellerInfoFiveMinute(beforeTIme);
        //过滤出数据库和缓存中的差异数据，并将差异数据保存到缓存
        saveDiffSellerInfo(sellerInfoList);
    }

    //比较数据库和缓存中的差异数据，过滤出差异数据，并将差异数据保存到缓存
    private void saveDiffSellerInfo(List&lt;SellerInfoDO&gt; sellerInfoList) {
        sellerInfoList.stream().peek(sellerInfo -&gt; {
            Long sellerId = sellerInfo.getSellerId();
            String redisKey = SellerRedisKeyConstants.SELLER_INFO_LIST + sellerId;
            //不存在说明是差异数据
            if (!redisCache.hasKey(redisKey)) {
                redisCache.set(redisKey, JsonUtil.object2Json(sellerInfo), -1);
            }
            //TODO 存在比较差异
        }).count();
    }

    //获取5分钟之前的时间
    private Date getBeforeTime() {
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.MINUTE, -5);
        return calendar.getTime();
    }
}

@Repository
public class SellerRepository {
    ...
    //查询出前5分钟之内的数据
    public List&lt;SellerInfoDO&gt; querySellerInfoFiveMinute(Date beforeTIme) {
        List&lt;SellerInfoDO&gt; batchList = new ArrayList&lt;&gt;();
        int pageNum = 1;
        //设置每页数据量
        int pageSize = ProductConstants.QUERY_ITEM_MAX_COUNT;
        while (true) {
            LambdaQueryWrapper&lt;SellerInfoDO&gt; queryWrapper = Wrappers.lambdaQuery();
            queryWrapper.ge(SellerInfoDO::getCreateTime, beforeTIme);
            queryWrapper.ge(SellerInfoDO::getUpdateTime, beforeTIme);

            Page&lt;SellerInfoDO&gt; page = new Page&lt;&gt;(pageNum, pageSize);
            Page&lt;SellerInfoDO&gt; pageResult = sellerInfoMapper.selectPage(page, queryWrapper);
            if (Objects.isNull(pageResult) || pageResult.getRecords().size() &lt;= 0) {
                break;
            }

            batchList.addAll(pageResult.getRecords());
            //进入下一页
            pageNum++;
        }
        return batchList;
    }
    ...
}</code></pre>
<p data-track="195">&nbsp;</p>
<p data-track="196"><strong>8.商品中心高并发架构总结</strong></p>
<p data-track="197"><strong>一.高并发C端系统(限流 + 过滤 + 实时缓存同步)</strong></p>
<p data-track="198"><strong>二.高并发卖家系统(缓存预热 + 定时缓存同步)</strong></p>
<p data-track="199"><strong>三.高并发库存系统(缓存分桶)</strong></p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-25 09:33">2025-06-25 09:33</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">57</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18947436);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18947436', targetLink: 'https://www.cnblogs.com/mjunz/p/18947436', title: '商品中心—13.商品卖家系统的高并发文档' })">举报</a>
</div>
        