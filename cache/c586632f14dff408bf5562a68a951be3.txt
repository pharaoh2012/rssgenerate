
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zengzuo613/p/18995048" title="发布于 2025-07-28 08:45">
    <span role="heading" aria-level="2">Redis 部署模式详解</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-28 08:45">2025-07-28 08:45</span>&nbsp;
<a href="https://www.cnblogs.com/zengzuo613">曾左</a>&nbsp;
阅读(<span id="post_view_count">28</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18995048);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18995048', targetLink: 'https://www.cnblogs.com/zengzuo613/p/18995048', title: 'Redis 部署模式详解' })">举报</a>
</small>
    <div class="entry">
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="redis-部署模式详解">Redis 部署模式详解</h1>
<p>Redis 支持多种部署模式，主要包括单机模式（Single）、哨兵模式（Sentinel）、集群模式（Cluster）及增强代理集群，分别适用于不同场景，以下是它们的详细介绍。以下说明仅适用于 Redis 7.0+。</p>
<h2 id="一单机模式single">一、单机模式（Single）</h2>
<h3 id="1-简介">1. 简介</h3>
<p>（1）最简单的部署方式，仅运行单个 Redis 实例。</p>
<p>（2）无高可用性，如果实例崩溃，服务不可用。</p>
<p>（3）适用场景：开发环境。</p>
<h3 id="2-配置方法">2. 配置方法</h3>
<p>（1）修改 redis.conf</p>
<pre><code class="language-ini"># 绑定 IP（默认仅本地访问）
bind 0.0.0.0  # 允许远程访问

# 设置密码（可选）
requirepass yourpassword

# 持久化配置（默认启用 RDB）
save 900 1      # 15 分钟内至少 1 次修改则保存
save 300 10     # 5 分钟内至少 10 次修改则保存
save 60 10000   # 1 分钟内至少 10000 次修改则保存

# 启用 AOF（可选）
appendonly yes
appendfilename "appendonly.aof"
</code></pre>
<p>（2）启动 Redis</p>
<pre><code class="language-bash">redis-server /path/to/redis.conf
</code></pre>
<p>（3）客户端连接</p>
<pre><code class="language-bash">redis-cli -h 127.0.0.1 -p 6379 -a yourpassword
</code></pre>
<h2 id="二哨兵模式sentinel">二、哨兵模式（Sentinel）</h2>
<h3 id="1-简介-1">1. 简介</h3>
<p>（1）整体设计：主从架构 + 自动故障转移，提供高可用性（HA）。</p>
<p>（2）部署方式：1 个主节点（Master） + N 个从节点（Replica）+ M 个 Sentinel 节点。</p>
<p>（3）适用场景：需要高可用但不需要数据分片（水平扩展）的场景。</p>
<h3 id="2-整体架构">2. 整体架构</h3>
<p><img alt="20250708_d6255e" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2292062/202507/2292062-20250721072653894-116377425.png" class="lazyload"></p>
<p><strong>组成部分：</strong></p>
<p>（1）1 个主节点（Master）：负责写入和数据存储。</p>
<p>（2）N 个从节点（Replica）：复制主节点数据，提供读能力。</p>
<p>（3）M 个哨兵节点（Sentinel）：监控主从状态，触发故障转移。</p>
<p><strong>执行流程：</strong></p>
<p>（1）监控（Monitoring）</p>
<ul>
<li>每个 Sentinel 定期检查 Master 和 Replica 是否存活（默认每秒 1 次）。</li>
<li>若 Master 未响应超过 down-after-milliseconds（如 30 秒），Sentinel 标记其为 <strong>主观下线（SDOWN）</strong>。</li>
</ul>
<p>（2）选举（Leader Election）</p>
<ul>
<li>当多数 Sentinel（&gt;= <code>quorum</code> 配置值）确认 Master 下线，标记为 <strong>客观下线（ODOWN）</strong>。</li>
<li>Sentinel 集群通过 Raft 协议选举一个 <strong>Leader Sentinel</strong> 来执行故障转移。</li>
</ul>
<p>（3）故障转移（Failover）</p>
<ul>
<li>Leader Sentinel 选择一个最优的 Replica 提升为新的 Master。</li>
<li>通知其他 Replica 复制新 Master。</li>
<li>更新客户端连接信息（通过 <code>+switch-master</code> 事件通知）。</li>
</ul>
<p>（4）客户端重定向</p>
<ul>
<li>客户端通过 Sentinel 获取最新的 Master 地址（如 <code>SENTINEL get-master-addr-by-name mymaster</code>）。</li>
</ul>
<p><strong>交互流程：</strong></p>
<p><img alt="20250708_6143eb" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2292062/202507/2292062-20250721073606518-963893691.png" class="lazyload"></p>
<h3 id="3-配置方法">3. 配置方法</h3>
<p>（1）主节点配置（<code>redis-master.conf</code>）</p>
<pre><code class="language-ini">bind 0.0.0.0
requirepass yourpassword
masterauth yourpassword  # 从节点访问主节点的密码
</code></pre>
<p>（2）从节点配置（<code>redis-replica.conf</code>）</p>
<pre><code class="language-ini">bind 0.0.0.0
requirepass yourpassword
replicaof 127.0.0.1 6379  # 指向主节点
masterauth yourpassword   # 主节点密码
</code></pre>
<p>（3）哨兵配置（<code>sentinel.conf</code>）</p>
<pre><code class="language-ini">sentinel monitor mymaster 127.0.0.1 6379 2  # 监控主节点，2 表示至少 2 个 Sentinel 同意才触发故障转移
sentinel auth-pass mymaster yourpassword    # 主节点密码
sentinel down-after-milliseconds mymaster 5000  # 5 秒无响应视为下线
sentinel failover-timeout mymaster 60000   # 故障转移超时时间（60 秒）
</code></pre>
<p>（4）启动服务</p>
<pre><code class="language-bash"># 启动主节点
redis-server redis-master.conf

# 启动从节点
redis-server redis-replica.conf

# 启动 Sentinel
redis-sentinel sentinel.conf
</code></pre>
<p>（5）验证故障转移</p>
<pre><code class="language-bash"># 查看主从信息
redis-cli -p 6379 INFO replication

# 手动关闭主节点，观察 Sentinel 日志
tail -f /var/log/redis/sentinel.log
</code></pre>
<p>（6）客户端配置示例</p>
<p>无需配置全部 Sentinel 地址：客户端只需连接任意一个正常工作的 Sentinel 即可获取集群状态（Sentinel 之间通过 Gossip 协议自动同步信息）。</p>
<p>推荐配置多个 Sentinel 地址：仅用于容灾，避免某个 Sentinel 不可用时客户端无法初始化。</p>
<pre><code class="language-java">Set&lt;String&gt; sentinels = new HashSet&lt;&gt;();
sentinels.add("sentinel1:26379"); // 只需 1 个 Sentinel 即可工作
sentinels.add("sentinel2:26379"); // 额外添加用于容灾
sentinels.add("sentinel3:26379"); // 非必须，但建议

JedisSentinelPool pool = new JedisSentinelPool("mymaster", sentinels);
</code></pre>
<h3 id="4-特点">4. 特点</h3>
<p>（1）高可用：Sentinel 确保主节点故障时自动切换。</p>
<p>（2）无分片：仅解决 HA 问题，不扩展写性能。</p>
<p>（3）最少 3 节点：建议部署 3 个 Sentinel 以避免脑裂问题。</p>
<h2 id="三集群模式cluster">三、集群模式（Cluster）</h2>
<h3 id="1-简介-2">1. 简介</h3>
<p>（1）整体设计：支持主从实现高可用，将数据分片到 16384 个槽（Slot），每个节点负责部分槽，已实现水平扩展。</p>
<p>（2）适用场景：大数据量、高并发、需要横向扩展的场景。</p>
<h3 id="2-整体架构-1">2. 整体架构</h3>
<p><img alt="20250708_676ba3" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2292062/202507/2292062-20250721073411886-1188685163.png" class="lazyload"></p>
<p><strong>组成部分：</strong></p>
<p>（1）Master 节点（主节点）</p>
<ul>
<li>负责处理客户端读写请求。</li>
<li>管理分配的哈希槽（Slot）范围（如 <code>Slots 0-5460</code>）。</li>
<li>通过 <strong>Gossip 协议</strong> 与其他节点交换集群状态信息。</li>
</ul>
<p>（2）Slave 节点（从节点）</p>
<ul>
<li>异步复制对应 Master 的数据（通过 <code>--&gt;|Replication|</code> 箭头表示）。</li>
<li>当 Master 故障时，Slave 可自动晋升为新的 Master（故障转移）。</li>
<li>可处理读请求（需客户端配置 <code>READONLY</code>）。</li>
</ul>
<p>（3）通信协议</p>
<ul>
<li>节点间通过 Gossip 协议（PING/PONG 消息）交换集群拓扑、槽分配、节点状态等信息。</li>
</ul>
<p><strong>数据机制：</strong></p>
<p>（1）哈希槽（Slots）分布</p>
<ul>
<li>Redis Cluster 将所有数据划分为 <strong>16384 个槽位</strong>，每个 Master 负责一部分槽范围（如 <code>0-5460</code>）。</li>
<li>客户端通过 <code>CRC16(key) mod 16384</code> 计算键所属的槽位。</li>
</ul>
<p>（2）Move 重定向</p>
<ul>
<li>若客户端访问的键不属于当前连接的节点，节点会返回 <code>MOVED</code> 错误并指引正确节点。</li>
</ul>
<h3 id="3-配置方法-1">3. 配置方法</h3>
<p>（1）修改 <code>redis.conf</code>（每个节点）</p>
<pre><code class="language-ini">bind 0.0.0.0
cluster-enabled yes               # 启用集群模式
cluster-config-file nodes-6379.conf  # 集群节点配置文件
cluster-node-timeout 15000        # 节点超时时间（15 秒）
requirepass yourpassword          # 集群密码
masterauth yourpassword           # 主节点间认证密码
</code></pre>
<p>（2）启动所有节点</p>
<pre><code class="language-bash">redis-server /path/to/redis-6379.conf
redis-server /path/to/redis-6380.conf
</code></pre>
<p>（3）创建集群</p>
<pre><code class="language-bash"># 6 个节点（3 主 3 从）
redis-cli --cluster create \
  127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 \
  127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 \
  # --cluster-replicas 1 表示每个主节点有 1 个从节点
  --cluster-replicas 1 -a yourpassword 
  
</code></pre>
<p>（4）验证集群状态</p>
<pre><code class="language-bash">redis-cli -c -p 6379 -a yourpassword
127.0.0.1:6379&gt; CLUSTER INFO
127.0.0.1:6379&gt; CLUSTER NODES
</code></pre>
<p>（5）客户端配置示例</p>
<p>支持集群协议：客户端需实现 Redis Cluster 的 MOVED/ASK 重定向逻辑（主流客户端库已内置支持）。</p>
<p>种子节点配置：只需配置集群中任意 1-2 个节点地址（客户端会自动发现其他节点）。</p>
<p>认证信息：若集群启用密码，需统一所有节点的密码。</p>
<pre><code class="language-java">public class RedisClusterExample {
    public static void main(String[] args) {
        // 1. 配置至少一个集群节点地址（多个更容错）
        Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();
        nodes.add(new HostAndPort("127.0.0.1", 6379));
        nodes.add(new HostAndPort("127.0.0.1", 6380));

        // 2. 创建集群连接（带密码）
        JedisCluster jedisCluster = new JedisCluster(nodes, 2000, 2000, 5, "yourpassword");

        // 3. 执行命令（自动处理重定向）
        jedisCluster.set("foo", "bar");
        String value = jedisCluster.get("foo");
        System.out.println(value); // 输出 "bar"

        // 4. 关闭连接
        jedisCluster.close();
    }
}
</code></pre>
<h3 id="4-特点-1">4. 特点</h3>
<p>（1）在 Redis Cluster 中，扩充主节点时，必须重新分配槽（Slots），这是由集群的分布式数据分片机制决定的。</p>
<p>（2）节点故障时，槽是否要重新分配，具体场景如下：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>槽是否重新分配</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>主节点故障，有从节点</strong></td>
<td>否（从节点继承槽）</td>
<td>自动故障转移</td>
</tr>
<tr>
<td><strong>主节点及所有从节点故障</strong></td>
<td>是（槽处于 <code>FAIL</code> 状态）</td>
<td>手动恢复或重新分配槽</td>
</tr>
<tr>
<td><strong>网络分区导致脑裂</strong></td>
<td>可能部分槽不可用</td>
<td>等待恢复或强制修复</td>
</tr>
</tbody>
</table>
<h2 id="四增强代理集群模式">四、增强代理集群模式</h2>
<p>上述三种部署模式特点如下：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>数据分片</th>
<th>高可用</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>单机</td>
<td>❌</td>
<td>❌</td>
<td>开发测试、低流量生产</td>
</tr>
<tr>
<td>哨兵</td>
<td>❌</td>
<td>✅</td>
<td>高可用但不需分片（横向扩展）</td>
</tr>
<tr>
<td>集群</td>
<td>✅</td>
<td>✅</td>
<td>大数据量、高并发、横向扩展</td>
</tr>
</tbody>
</table>
<p>在实际生产环境中，推荐采用 Redis 集群模式（Cluster）部署，以确保集群高可用（主从）与水平扩展（数据分片），但该模式存在客户端配置繁琐、无法兼容历史配置等问题，所以官方推出了 Redis Cluster Proxy，旨在简化客户端与 Redis Cluster 的交互，它允许客户端像连接单节点 Redis 一样访问 Redis Cluster，无需处理 MOVED/ASK 重定向和集群拓扑变更。</p>
<h3 id="1-redis-cluster-proxy-核心功能">1. Redis Cluster Proxy 核心功能</h3>
<p>（1）透明集群访问</p>
<ul>
<li>客户端无需感知集群拓扑，Proxy 自动处理请求路由和重定向。</li>
<li>兼容标准 Redis 协议，支持所有单节点命令（除部分集群管理命令如 <code>CLUSTER</code>）。</li>
</ul>
<p>（2）连接池管理</p>
<ul>
<li>复用后端连接，减少客户端与多个节点直接建连的开销。</li>
</ul>
<p>（3）协议兼容性</p>
<ul>
<li>支持旧版 Redis 客户端（如仅支持单节点模式的 SDK）。</li>
</ul>
<p>（4）性能较好</p>
<ul>
<li>基于 C 开发，性能损耗低（官方测试延迟增加约 10%）。</li>
</ul>
<h3 id="2-redis-cluster-proxy-配置方法">2. Redis Cluster Proxy 配置方法</h3>
<p>(1) 安装 Redis Cluster Proxy</p>
<pre><code class="language-bash"># 从官方仓库编译安装
git clone https://github.com/RedisLabs/redis-cluster-proxy.git
cd redis-cluster-proxy
make
./src/redis-cluster-proxy -c proxy.conf
</code></pre>
<p>(2) 配置文件 <code>proxy.conf</code></p>
<pre><code class="language-ini"># 绑定端口
bind 0.0.0.0
port 7777

# 后端 Redis Cluster 节点
cluster-node-timeout 5000
cluster 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003
</code></pre>
<p>(3) 启动 Proxy</p>
<pre><code class="language-bash">./src/redis-cluster-proxy -c proxy.conf
</code></pre>
<h3 id="3-redis-cluster-proxy-部署增强">3. Redis Cluster Proxy 部署增强</h3>
<p>实际部署 Proxy 时，为确保整个系统高可用，应部署多个 Proxy 实例，通过 HAProxy（或 LVS、Envoy）实现 Proxy 的高可用与水平扩展，整体架构如下：</p>
<p><img alt="20250709_e99ed5" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2292062/202507/2292062-20250721073452081-2138399049.png" class="lazyload"></p>
<p><strong>负载均衡层：</strong></p>
<p>（1）作用：</p>
<ul>
<li>将请求分发到多个 Proxy 实例（轮询/最小连接数）。</li>
<li>健康检查自动剔除故障 Proxy。</li>
</ul>
<p>（2）配置示例（以 HAProxy 为例）：</p>
<pre><code class="language-ini">frontend redis-proxy
    bind *:6379
    mode tcp
    default_backend proxy_servers

backend proxy_servers
    mode tcp
    balance roundrobin
    server proxy1 192.168.1.100:7777 check inter 2s
    server proxy2 192.168.1.101:7777 check inter 2s
</code></pre>
<p>为保证 HAProxy 的高可用，我们一般会部署两套 HAProxy，通过 Keepalived 互为主备，即<strong>增强代理集群</strong>，整体架构如下：</p>
<p><img alt="20250708_d6255e" loading="lazy" data-src="https://img2024.cnblogs.com/blog/2292062/202507/2292062-20250721072653894-116377425.png" class="lazyload"></p>
<p>该集群具备 Redis Cluster 的高可用与水平扩展能力，以及 Redis Cluster Proxy 的透明访问特性（兼容历史配置，简化客户端调用）。此外，借助 Keepalived 和 HAProxy（或 LVS、Envoy），实现 Redis Cluster Proxy 节点及集群的高可用，同时简化了集群调用代码的配置复杂度。</p>
<h2 id="五总结与建议">五、总结与建议</h2>
<p>哨兵模式不支持水平扩展，且与集群模式一样，存在与客户端配置代码强耦合，难以兼容历史配置，无法实现透明访问等问题。因此在实际使用中，推荐采用 Keepalived + HAProxy（LVS 或 Envoy） + Redis Cluster Proxy + Redis Cluster 增强代理集群模式部署，以实现集群高可用、水平扩展、透明访问及兼容历史配置等必要功能。</p>

</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="zengzuo613" blog-id="714768" post-id="18995048"></vc:categories-tags>
    </ul>
