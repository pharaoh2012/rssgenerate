
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/emanjusaka/p/18712605" title="发布于 2025-02-13 10:30">
    <span role="heading" aria-level="2">一文详解 MySQL 中的间隙锁</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3230488/202502/3230488-20250213102908271-773766796.png" alt="一文详解 MySQL 中的间隙锁" class="desc_img">
        深入剖析 MySQL 间隙锁。涵盖触发条件、加锁规则、锁定区间及作用等内容，并通过多个案例演示不同场景下间隙锁的行为。希望可以帮助到读者深入理解 MySQL 锁机制，提升和数据库相关代码的可靠性。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>博客：<a href="https://www.emanjusaka.com" target="_blank" rel="noopener nofollow">https://www.emanjusaka.com</a><br>
博客园：<a href="https://www.cnblogs.com/emanjusaka" target="_blank">https://www.cnblogs.com/emanjusaka</a><br>
公众号：emanjusaka的编程栈</p>
<blockquote>
<p>by <a href="https://www.emanjusaka.com" target="_blank" rel="noopener nofollow">emanjusaka</a> from <a href="https://www.emanjusaka.com/archives/mysql-gap-lock" target="_blank" rel="noopener nofollow">https://www.emanjusaka.com/archives/mysql-gap-lock</a> 彼岸花开可奈何<br>
本文为原创文章，可能会更新知识点以及修正文中的一些错误，全文转载请保留原文地址，避免产生因未即时修正导致的误导。</p>
</blockquote>
<p>间隙锁（Gap Lock）是（RR 级别下）一个在索引记录之间的间隙上的锁，可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。</p>
<p>间隙锁是 MySQL 行锁的一种，与行锁不同的是间隙锁可能锁定的是一行数据，也可能锁住一个间隙。</p>
<h2 id="触发条件">触发条件</h2>
<ul>
<li>
<p>事务隔离级别为 REPEATABLE-READ（可重复读），间隙锁是为了防止幻读。</p>
</li>
<li>
<p>使用范围查询条件</p>
</li>
<li>
<p>使用等值查询但未命中记录时，如果查询的条件列上有索引</p>
</li>
<li>
<p>索引不唯一的情况</p>
</li>
</ul>
<h2 id="锁定区间">锁定区间</h2>
<p>间隙锁会向左找第一个比当前索引值小的值，向右找第一个比当前索引值大的值（没有则为正无穷），将此区间锁住，从而阻止其他事务在此区间插入数据</p>
<p>间隙锁（Gap Lock），左右都是开区间，间隙锁 + 行锁组合成 Next-key lock，左开右闭区间。</p>
<h2 id="加锁规则">加锁规则</h2>
<ol>
<li>
<p>加锁的基本单位是 next-key lock，它是左开右闭区间</p>
</li>
<li>
<p>查找过程中访问到的对象才会加锁</p>
</li>
<li>
<p>唯一索引上的等值查询，并且记录存在，next-key lock 退化为行锁</p>
</li>
<li>
<p>唯一索引上的范围查询会访问到不满足条件的第一个值为止</p>
</li>
<li>
<p>索引上的等值查询，会将距离最近的左边界和右边界作为锁定范围，如果索引不是唯一索引还会继续向右匹配，直到遇见第一个不满足条件的值，如果最后一个值不等于查询条件，Next-Key Lock 退化为间隙锁。</p>
</li>
</ol>
<p>注意，delete 语句加锁的逻辑，其实跟 select ... for update 是类似的。</p>
<p><strong>这些加锁规则并不全部适应 MySQL 的全部版本，在新版本的 MySQL 中可能会有一些变动，大体上是符合这些规则的。</strong></p>
<p>我们也可以执行<code>select * FROM performance_schema.data_locks;</code>来查看具体加了什么锁。</p>
<ul>
<li>
<p>LOCK_TYPE</p>
<ul>
<li>
<p>TABLE：表锁</p>
</li>
<li>
<p>RECORD：行级锁</p>
</li>
</ul>
</li>
<li>
<p>LOCK_MODE</p>
<ul>
<li>
<p>X：next-key 锁</p>
</li>
<li>
<p>X,REC_NOT_GAP：记录锁</p>
</li>
<li>
<p>X,GAP：间隙锁</p>
</li>
</ul>
</li>
</ul>
<h2 id="间隙锁的作用">间隙锁的作用</h2>
<p>与行锁（例如乐观锁高级实现，MVCC）组合成 Next-key lock，在可重复读这种隔离级别下一起工作避免幻读。</p>
<h2 id="案例演示">案例演示</h2>
<p>环境：MySQL8.3.0，InnoDB引擎， RR 隔离级别</p>
<p>表结构：</p>
<p>CREATE TABLE <code>t</code> (<br>
&nbsp; &nbsp;<code>id</code> int(11) NOT NULL,<br>
&nbsp; &nbsp;<code>c</code> int(11) DEFAULT NULL,<br>
&nbsp; &nbsp;<code>d</code> int(11) DEFAULT NULL,<br>
&nbsp; &nbsp;PRIMARY KEY (<code>id</code>),<br>
&nbsp; &nbsp;KEY <code>c</code> (<code>c</code>)<br>
&nbsp;) ENGINE=InnoDB;<br>
&nbsp;​<br>
&nbsp;insert into t values(0,0,0),(5,5,5),<br>
&nbsp;(10,10,10),(15,15,15),(20,20,20);</p>
<table>
<thead>
<tr>
<th>id</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>10</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>20</td>
<td>20</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>存在的间隙：</p>
<ul>
<li>
<p>(-∞,0]</p>
</li>
<li>
<p>(0,5]</p>
</li>
<li>
<p>(5,10]</p>
</li>
<li>
<p>(10,15]</p>
</li>
<li>
<p>(15,20]</p>
</li>
<li>
<p>(20,+supremum]</p>
</li>
</ul>
<p>InnoDB 给每个索引加了一个不存在的最大值 supremum，这样才符合“左开右闭区间”。</p>
<h3 id="唯一索引等值锁定存在的数据">唯一索引等值锁定存在的数据</h3>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务 1</th>
<th>事务 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1</td>
<td>begin; select * from t where id = 5 for update;</td>
<td></td>
</tr>
<tr>
<td>t2</td>
<td></td>
<td>begin; insert into t value(4,4,4); --- success</td>
</tr>
<tr>
<td></td>
<td></td>
<td>insert into t value(6,6,6); --- success</td>
</tr>
</tbody>
</table>
<p>根据规则 3，事务 1 中执行的 select 语句,会退化成行锁，只会锁定 5 这一行记录</p>
<p><img src="https://file.emanjusaka.top/emanjusaka/31-1.png" alt="image-20241022140038373" loading="lazy"></p>
<h3 id="索引等值锁定">索引等值锁定</h3>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务 1</th>
<th>事务 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1</td>
<td>begin; select * from t where id = 3 for update; --- 不存在的数据</td>
<td></td>
</tr>
<tr>
<td>t2</td>
<td></td>
<td>begin; insert into t value(6,6,6); --- success</td>
</tr>
<tr>
<td>t3</td>
<td></td>
<td>insert into t value(4,4,4); --- block</td>
</tr>
</tbody>
</table>
<p>根据规则 1加锁范围是（0,5],再根据规则 5由于向右遍历最后一个值 5 不满足等值条件退化为间隙锁(0,5)</p>
<p>插入 数据6 不在间隙锁的范围内可以插入成功，而数据 4 是间隙锁锁定范围进入阻塞状态</p>
<p><img src="https://file.emanjusaka.top/emanjusaka/31-2.png" alt="image-20241022140204033" loading="lazy"></p>
<h3 id="唯一索引范围锁定">唯一索引范围锁定</h3>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务 1</th>
<th>事务 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1</td>
<td>begin; select * from t where id &gt;= 5 and id &lt; 6 for update;</td>
<td></td>
</tr>
<tr>
<td>t2</td>
<td></td>
<td>begin; insert into t value(7,7,7); --- block</td>
</tr>
</tbody>
</table>
<p>这个可以分为两部分看</p>
<p>首先看 id &gt; = 5，锁定区间(0,5]根据规则 1 和规则 3 会退化成行锁</p>
<p>再看 id &lt; 6 根据规则 4 锁定区间为(5,10]</p>
<p>综合两部分最终锁定区间[5,10]</p>
<p>注意：这个锁定区间在不同版本的 MySQL 中可能表现不同，在 8.3.0 版本中第二部分会退化成间隙锁，锁定区间变成了[5,10)</p>
<p><img src="https://file.emanjusaka.top/emanjusaka/31-3.png" alt="image-20241022140350011" loading="lazy"></p>
<h3 id="非唯一索引范围锁定">非唯一索引范围锁定</h3>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务 1</th>
<th>事务 2</th>
<th>事务 3</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1</td>
<td>begin; select * from t where c &gt;= 10 and c &lt; 11 for update;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t2</td>
<td></td>
<td>begin; insert into t values(7,7,7); --block</td>
<td></td>
</tr>
<tr>
<td>t3</td>
<td></td>
<td></td>
<td>begin; update t set d = d + 1 where c = 15; --block</td>
</tr>
</tbody>
</table>
<p>用 c =10 定位记录，给索引 c 加上了 next-key lock (5,10],它不会退化成行锁，索引 c 不是唯一索引。因此最终索引 c 上加的(5,10] 和 (10,15]这两个 next-key lock</p>
<p><img src="https://file.emanjusaka.top/emanjusaka/31-4.png" alt="image-20241022140643699" loading="lazy"></p>
<h3 id="limit语句加锁">limit语句加锁</h3>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务 1</th>
<th>事务 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1</td>
<td>begin; select * from t where c = 10 limit 1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>begin; insert into t values(12,12,12); ---success</td>
</tr>
</tbody>
</table>
<p>如果没有 limit 语句的话在索引 c 上加锁范围是从（c=5,id=5）到 （c =15,id=15）。</p>
<p>但是因为加了 limit 1 的限制，因此在访问（c=10,id=10）这一行时，满足条件的语句已经有1 条了循环结束。</p>
<p>因此索引 c 上的加锁范围就变成了从（c=5，id=5）到（c=10，id=10）。</p>
<p><img src="https://file.emanjusaka.top/emanjusaka/31-idx-c.png" alt="image-20241022141232972" loading="lazy"></p>
<p><img src="https://file.emanjusaka.top/emanjusaka/31-5.png" alt="image-20241022140835952" loading="lazy"></p>
<h2 id="参考资料">参考资料</h2>
<ol start="6">
<li>
<p><a href="https://time.geekbang.org/column/article/75659" target="_blank" rel="noopener nofollow">为什么我只改一行的语句，锁这么多？</a></p>
</li>
<li>
<p><a href="https://xiaolincoding.com/mysql/lock/lock_phantom.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BB%E8%AF%BB" target="_blank" rel="noopener nofollow">MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</a></p>
</li>
</ol>
<blockquote>
<p>谦学于心，谷纳万物，静思致远，共筑收获之旅！<br>
原文地址： <a href="https://www.emanjusaka.com/archives/mysql-gap-lock" target="_blank" rel="noopener nofollow">https://www.emanjusaka.com/archives/mysql-gap-lock</a></p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.48952731637962965" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-13 10:30">2025-02-13 10:30</span>&nbsp;
<a href="https://www.cnblogs.com/emanjusaka">emanjusaka</a>&nbsp;
阅读(<span id="post_view_count">233</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18712605" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18712605);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18712605', targetLink: 'https://www.cnblogs.com/emanjusaka/p/18712605', title: '一文详解 MySQL 中的间隙锁' })">举报</a>
</div>
        