
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/liyongqiang-cc/p/18655619" title="发布于 2025-01-18 10:34">
    <span role="heading" aria-level="2">在 .NET Core中如何使用 Redis 创建分布式锁</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在 .NET Core WebApi 中使用 Redis 创建分布式锁可以通过 <code>StackExchange.Redis</code> 库来实现。分布式锁用于确保在分布式系统中，同一时间只有一个进程可以执行某段代码。</p>
<h3 id="1-场景描述">1. <strong>场景描述</strong></h3>
<p>在支付系统中，可能会出现以下并发问题：</p>
<ul>
<li>用户同时发起多次支付请求，导致重复扣款。</li>
<li>多个请求同时处理同一个订单，导致数据不一致。</li>
</ul>
<p>通过分布式锁，可以确保同一时间只有一个请求能够执行关键操作（如扣款）。</p>
<hr>
<h3 id="2-实现步骤">2. <strong>实现步骤</strong></h3>
<h4 id="21-安装-stackexchangeredis-包">2.1 安装 <code>StackExchange.Redis</code> 包</h4>
<p>首先，安装 Redis 客户端库：</p>
<pre><code>dotnet&nbsp;add&nbsp;package&nbsp;StackExchange.Redis
</code></pre>
<h4 id="22-配置-redis-连接">2.2 配置 Redis 连接</h4>
<p>在 <code>appsettings.json</code> 中添加 Redis 连接字符串：</p>
<pre><code>{
&nbsp;&nbsp;"ConnectionStrings":&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;"Redis":&nbsp;"localhost:6379"
&nbsp;&nbsp;}
}
</code></pre>
<h4 id="23-创建分布式锁工具类">2.3 创建分布式锁工具类</h4>
<p>创建一个工具类来封装 Redis 分布式锁的逻辑：</p>
<pre><code>using&nbsp;StackExchange.Redis;
using&nbsp;System;
using&nbsp;System.Threading.Tasks;

public&nbsp;class&nbsp;RedisDistributedLock
{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;readonly&nbsp;IDatabase&nbsp;_redisDatabase;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;readonly&nbsp;string&nbsp;_lockKey;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;readonly&nbsp;string&nbsp;_lockValue;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;readonly&nbsp;TimeSpan&nbsp;_expiry;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;RedisDistributedLock(IDatabase&nbsp;redisDatabase,&nbsp;string&nbsp;lockKey,&nbsp;string&nbsp;lockValue,&nbsp;TimeSpan&nbsp;expiry)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_redisDatabase&nbsp;=&nbsp;redisDatabase;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_lockKey&nbsp;=&nbsp;lockKey;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_lockValue&nbsp;=&nbsp;lockValue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_expiry&nbsp;=&nbsp;expiry;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;async&nbsp;Task&lt;bool&gt;&nbsp;AcquireLockAsync()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;尝试设置锁，仅当键不存在时才成功
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;await&nbsp;_redisDatabase.StringSetAsync(_lockKey,&nbsp;_lockValue,&nbsp;_expiry,&nbsp;When.NotExists);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;async&nbsp;Task&nbsp;ReleaseLockAsync()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;使用&nbsp;Lua&nbsp;脚本确保只有锁的持有者才能释放锁
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;luaScript&nbsp;=&nbsp;@"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;redis.call('GET',&nbsp;KEYS[1])&nbsp;==&nbsp;ARGV[1]&nbsp;then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;redis.call('DEL',&nbsp;KEYS[1])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end";

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;_redisDatabase.ScriptEvaluateAsync(luaScript,&nbsp;new&nbsp;RedisKey[]&nbsp;{&nbsp;_lockKey&nbsp;},&nbsp;new&nbsp;RedisValue[]&nbsp;{&nbsp;_lockValue&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h4 id="24-在-web-api-中使用分布式锁">2.4 在 Web API 中使用分布式锁</h4>
<p>在 Web API 的控制器中使用分布式锁来确保支付操作的原子性。</p>
<h5 id="241-注册-redis-服务">2.4.1 注册 Redis 服务</h5>
<p>在 <code>Startup.cs</code> 或 <code>Program.cs</code> 中注册 Redis 服务：</p>
<pre><code>//&nbsp;添加&nbsp;Redis&nbsp;服务
builder.Services.AddSingleton&lt;IConnectionMultiplexer&gt;(sp&nbsp;=&gt;
ConnectionMultiplexer.Connect(builder.Configuration.GetConnectionString("Redis")));
</code></pre>
<h5 id="242-创建支付控制器">2.4.2 创建支付控制器</h5>
<p>在 <code>Controllers</code> 文件夹中创建一个 <code>PaymentController</code>，并在其中使用分布式锁：</p>
<pre><code>using&nbsp;Microsoft.AspNetCore.Mvc;
using&nbsp;StackExchange.Redis;
using&nbsp;System;
using&nbsp;System.Threading.Tasks;

&nbsp;&nbsp;&nbsp;&nbsp;[ApiController]
&nbsp;&nbsp;&nbsp;&nbsp;[Route("api/[controller]")]
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;PaymentController&nbsp;:&nbsp;ControllerBase
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;readonly&nbsp;IDatabase&nbsp;_redisDatabase;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;PaymentController(IConnectionMultiplexer&nbsp;redis)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_redisDatabase&nbsp;=&nbsp;redis.GetDatabase();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[HttpPost("pay")]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;async&nbsp;Task&lt;IActionResult&gt;&nbsp;ProcessPayment([FromBody]&nbsp;PaymentRequest&nbsp;request)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;创建分布式锁
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;lockKey&nbsp;=&nbsp;$"PaymentLock:{request.OrderId}";&nbsp;//&nbsp;锁的键，基于订单&nbsp;ID
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;lockValue&nbsp;=&nbsp;Guid.NewGuid().ToString();&nbsp;//&nbsp;锁的值，确保唯一性
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;expiry&nbsp;=&nbsp;TimeSpan.FromSeconds(10);&nbsp;//&nbsp;锁的过期时间

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;distributedLock&nbsp;=&nbsp;new&nbsp;RedisDistributedLock(_redisDatabase,&nbsp;lockKey,&nbsp;lockValue,&nbsp;expiry);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;尝试获取锁
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(await&nbsp;distributedLock.AcquireLockAsync())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("已获取锁，正在处理付款...");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;模拟支付处理
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;paymentSuccess&nbsp;=&nbsp;await&nbsp;ProcessPaymentAsync(request.UserId,&nbsp;request.OrderId,&nbsp;request.Amount);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(paymentSuccess)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Ok(new&nbsp;{&nbsp;Message&nbsp;=&nbsp;"付款成功!"&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;BadRequest(new&nbsp;{&nbsp;Message&nbsp;=&nbsp;"付款失败!"&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Conflict(new&nbsp;{&nbsp;Message&nbsp;=&nbsp;"正在处理此订单的另一个付款请求..."&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;释放锁
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;distributedLock.ReleaseLockAsync();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}
</code></pre>
<hr>
<h3 id="3-代码说明">3. <strong>代码说明</strong></h3>
<h4 id="31-分布式锁的实现">3.1 分布式锁的实现</h4>
<ul>
<li><code>AcquireLockAsync</code>: 使用 <code>Redis</code> 的 <code>SET key value NX EX</code> 命令尝试获取锁。<code>NX</code> 表示仅在键不存在时设置，`EX 设置键的过期时间。</li>
<li><code>ReleaseLockAsync</code>: 使用 <code>Lua</code> 脚本确保只有锁的持有者才能释放锁，避免误删其他请求的锁。</li>
</ul>
<h4 id="32-支付控制器的使用">3.2 支付控制器的使用</h4>
<ul>
<li><strong>锁的键</strong>: 使用订单 ID 作为锁的键（如 <code>PaymentLock:202501061410455506968463210</code>），确保同一订单的支付请求串行化。</li>
<li><strong>锁的值</strong>: 使用 GUID 作为锁的值，确保锁的唯一性。</li>
<li><strong>锁的过期时间</strong>: 设置合理的过期时间（如 10 秒），防止锁被长时间占用。</li>
</ul>
<h4 id="33-支付处理逻辑">3.3 支付处理逻辑</h4>
<ul>
<li><code>ProcessPaymentAsync</code>: 模拟支付处理逻辑，包括调用支付网关、扣减余额等操作。</li>
</ul>
<hr>
<h3 id="4-测试-api">4. <strong>测试 API</strong></h3>
<h4 id="41-启动-web-api">4.1 启动 Web API</h4>
<p>运行项目，启动 Web API。</p>
<h4 id="42-发送支付请求">4.2 发送支付请求</h4>
<p>使用工具（如 Postman 或 curl）发送支付请求：</p>
<pre><code>POST&nbsp;/api/payment/pay
Content-Type:&nbsp;application/json

{
&nbsp;&nbsp;&nbsp;&nbsp;"userId":&nbsp;"9527",
&nbsp;&nbsp;&nbsp;&nbsp;"orderId":&nbsp;"202501061410455506968463210"
&nbsp;&nbsp;&nbsp;&nbsp;}
</code></pre>
<h4 id="43-测试并发场景">4.3 测试并发场景</h4>
<p>同时发送多个相同的支付请求，观察是否只有一个请求能够成功获取锁并处理支付。</p>
<p><img src="https://fastly.jsdelivr.net/gh/bucketio/img8@main/2025/01/06/1736151135187-a284b34f-0f15-4bdc-b414-abda3455fb36.png" alt="" title="null" loading="lazy"></p>
<hr>
<h3 id="5-注意事项">5. <strong>注意事项</strong></h3>
<ol>
<li>
<p><strong>锁的粒度</strong>:</p>
<ul>
<li>锁的粒度要适中。如果锁的粒度过大（如全局锁），可能导致性能问题；如果粒度过小，可能增加复杂性。</li>
<li>在支付系统中，通常以订单 ID 或用户 ID 作为锁的粒度。</li>
</ul>
</li>
<li>
<p><strong>锁的过期时间</strong>:</p>
<ul>
<li>设置合理的过期时间，避免锁被长时间占用导致死锁。</li>
<li>如果业务逻辑执行时间较长，可以动态延长锁的过期时间。</li>
</ul>
</li>
<li>
<p><strong>锁的可靠性</strong>:</p>
<ul>
<li>Redis 需要高可用，否则可能导致锁失效。可以使用 Redis 集群或 Redlock 算法提高可靠性。</li>
</ul>
</li>
<li>
<p><strong>异常处理</strong>:</p>
<ul>
<li>确保锁的释放操作放在 <code>finally</code> 块中，避免因异常导致锁无法释放。</li>
</ul>
</li>
<li>
<p><strong>幂等性</strong>:</p>
<ul>
<li>支付系统需要支持幂等性，即使多次请求，也只会产生一次扣款。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-总结">6. <strong>总结</strong></h3>
<p>在 .NET Core Web API 中使用 Redis 创建分布式锁，可以带来以下好处：</p>
<ul>
<li>解决并发问题，确保数据一致性。</li>
<li>提高系统的可靠性和性能。</li>
<li>简化代码逻辑，降低开发复杂度。</li>
<li>支持高并发、分布式环境和高可用需求。</li>
</ul>
<p>通过合理使用 Redis 分布式锁，可以构建高可靠、高性能的分布式系统，满足复杂的业务需求。<br>
<img src="https://img2024.cnblogs.com/blog/2063798/202501/2063798-20250106164557255-1461688841.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.0715448122893518" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-18 10:34">2025-01-18 10:34</span>&nbsp;
<a href="https://www.cnblogs.com/liyongqiang-cc">代码拾光</a>&nbsp;
阅读(<span id="post_view_count">199</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18655619" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18655619);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18655619', targetLink: 'https://www.cnblogs.com/liyongqiang-cc/p/18655619', title: '在 .NET Core中如何使用 Redis 创建分布式锁' })">举报</a>
</div>
        