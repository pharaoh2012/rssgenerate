<!----> <meta itemprop="headline" content="🚀 前端无感刷新token机制（一文说明白）"> <meta itemprop="keywords" content="前端,JavaScript,axios"> <meta itemprop="datePublished" content="2024-10-08T01:47:52.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Lsx_"> <meta itemprop="url" content="https://juejin.cn/user/1442981392682829"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7cdd11fb="">
            🚀 前端无感刷新token机制（一文说明白）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7cdd11fb=""><div class="author-info-box" data-v-7cdd11fb=""><div class="author-name" data-v-7cdd11fb=""><a href="/user/1442981392682829/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-7cdd11fb=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    Lsx_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-7cdd11fb=""><time datetime="2024-10-08T01:47:52.000Z" title="Tue Oct 08 2024 01:47:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7cdd11fb="">
                    2024-10-08
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7cdd11fb=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7cdd11fb=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7cdd11fb=""></circle></svg> <span class="views-count" data-v-7cdd11fb="">
                    10,480
                  </span> <span class="read-time" data-v-7cdd11fb=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7cdd11fb=""><rect width="16" height="16" fill="none" data-v-7cdd11fb=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7cdd11fb=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7cdd11fb=""></path></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7cdd11fb=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7cdd11fb=""><div class="article-viewer markdown-body result"><h2 data-id="heading-0">前言</h2>
<p>用户登录之后，会返回一个用户的标识，之后带上这个标识请求别的接口，就能识别出该用户。</p>
<p>标识登录状态的方案有两种： session 和 jwt。这两种方案一个服务端存储，通过 cookie 携带标识，一个在客户端存储，通过 header 携带标识。</p>
<p>session 是通过 cookie 返回一个 id，关联服务端内存里保存的 session 对象，请求时服务端取出 cookie 里 id 对应的 session 对象，就可以拿到用户信息。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dac5f629d5004c088db67a72f4dd9bb1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTHN4Xw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1735634851&amp;x-signature=lCMibsEVJNtoX5ixFzTLandNFYA%3D" alt="image.png" loading="lazy"></p>
<p>jwt 不在服务端存储，会直接把用户信息放到 token 里返回，每次请求带上这个 token，服务端就能从中取出用户信息。</p>
<p><strong>session 的方案默认不支持分布式，因为是保存在一台服务器的内存的，另一台服务器没有。jwt 的方案天然支持分布式，因为信息保存在 token 里，只要从中取出来就行。</strong></p>
<h2 data-id="heading-1">为什么需要无感刷新token机制</h2>
<p>服务端把用户信息放入 token 里，设置一个过期时间，客户端请求的时候通过 authorization 的 header 携带 token，服务端验证通过，就可以从中取到用户信息。</p>
<p>但是token 是有过期时间的，比如 3 天，那过期后再访问就需要重新登录了。这样体验并不好。
想想你在用某个 app 的时候，用着用着突然跳到登录页了，告诉你需要重新登录了。是不是体验很差？</p>
<p>所以要加上续签机制，也就是延长 token 过期时间。</p>
<p>主流的方案是通过双 token，一个 access_token、一个 refresh_token（一个短token，一个长token）。</p>
<h2 data-id="heading-2">无感刷新token机制</h2>
<p>用户登录成功之后，两个 token（一个 access_token、一个 refresh_token），访问接口时携带 access_token 访问，当 access_token 过期时，通过 refresh_token 来刷新，拿到新的 access_token 和 refresh_token。</p>
<p>而 access_token 一般过期时间设置的比较短，比如 30 分钟，refresh_token 设置的过期时间比较长，比如 7 天。这样，只要你 7 天内访问一次，就能刷新 token，再续 7 天，一直不需要登录。</p>
<p>但如果你超过 7 天没访问，那 refresh_token 也过期了，就需要重新登录了。想想你常用的 APP，是不是没再重新登录过？而不常用的 APP，再次打开是不是就又要重新登录了？这种一般都是双 token 做的。</p>
<h2 data-id="heading-3">实现</h2>
<p>在axios的响应拦截器中刷新token。</p>
<p>这里还需要排除下 /refresh 接口，也就是刷新失败不继续刷新，不然会进入死循环。</p>
<p>刷新 token 成功，就重发之前的请求，否则，提示重新登录。其他错误直接返回。</p>
<p>在刷新 token 的接口里，拿到新的 access_token 和 refresh_token 后，更新本地存储的 token。</p>
<pre><code class="hljs language-js" lang="js">axiosInstance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
    <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> response;
    },
    <span class="hljs-keyword">async</span> (error) =&gt; {
        <span class="hljs-keyword">let</span> { data, config } = error.<span class="hljs-property">response</span>;

        <span class="hljs-keyword">if</span> (data.<span class="hljs-property">statusCode</span> === <span class="hljs-number">401</span> &amp;&amp; !config.<span class="hljs-property">url</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'/refresh'</span>)) {
            
            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">refreshToken</span>();

            <span class="hljs-keyword">if</span>(res.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-title function_">axiosInstance</span>(config);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-title function_">alert</span>(data || <span class="hljs-string">'登录过期，请重新登录'</span>);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> error.<span class="hljs-property">response</span>;
        }
    }
)

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">refreshToken</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> axiosInstance.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/refresh'</span>, {
        <span class="hljs-attr">params</span>: {
          <span class="hljs-attr">token</span>: <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'refresh_token'</span>)
        }
    });
    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'access_token'</span>, res.<span class="hljs-property">data</span>.<span class="hljs-property">accessToken</span>);
    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'refresh_token'</span>, res.<span class="hljs-property">data</span>.<span class="hljs-property">refreshToken</span>);
    
    <span class="hljs-keyword">return</span> res;
}

</code></pre>
<p>但是还有一些问题，如果并发请求，多次调用后端接口，会刷新token多次，解决方案如下：</p>
<p>加一个 refreshing 的标记，记录是否正在刷新token，如果在刷新，那就返回一个 promise，并且把它的 resolve 方法还有 config 加入到一个队列里。</p>
<p>当 token刷新 成功之后，重新发送队列中的请求（即在刷新期间积压的请求），并且把结果通过 resolve 返回（即重新发起请求）。</p>
<pre><code class="hljs language-js" lang="js">interface <span class="hljs-title class_">PendingTask</span> {
    <span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>
    <span class="hljs-attr">resolve</span>: <span class="hljs-title class_">Function</span>
}

<span class="hljs-keyword">let</span> refreshing = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">queue</span>: <span class="hljs-title class_">PendingTask</span>[] = [];

axiosInstance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
    <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> response;
    },
    <span class="hljs-keyword">async</span> (error) =&gt; {
        <span class="hljs-keyword">let</span> { data, config } = error.<span class="hljs-property">response</span>;

        <span class="hljs-keyword">if</span>(refreshing) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
                queue.<span class="hljs-title function_">push</span>({
                    config,
                    resolve
                });
            });
        }

        <span class="hljs-keyword">if</span> (data.<span class="hljs-property">statusCode</span> === <span class="hljs-number">401</span> &amp;&amp; !config.<span class="hljs-property">url</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'/refresh'</span>)) {
            refreshing = <span class="hljs-literal">true</span>;
            
            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">refreshToken</span>();

            refreshing = <span class="hljs-literal">false</span>;

            <span class="hljs-keyword">if</span>(res.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) {

                queue.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{config, resolve}</span>) =&gt;</span> {
                    <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">axiosInstance</span>(config))
                })

                <span class="hljs-keyword">return</span> <span class="hljs-title function_">axiosInstance</span>(config);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-title function_">alert</span>(data || <span class="hljs-string">'登录过期，请重新登录'</span>);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> error.<span class="hljs-property">response</span>;
        }
    }
)

axiosInstance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) {
    <span class="hljs-keyword">const</span> accessToken = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'access_token'</span>);

    <span class="hljs-keyword">if</span>(accessToken) {
        config.<span class="hljs-property">headers</span>.<span class="hljs-property">authorization</span> = <span class="hljs-string">'Bearer '</span> + accessToken;
    }
    <span class="hljs-keyword">return</span> config;
})

</code></pre></div></div>