
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xjjsk/p/18954892" title="发布于 2025-06-28 18:36">
    <span role="heading" aria-level="2">C++服务开发环境-万事开头难</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="c服务开发环境-万事开头难">C++服务开发环境-万事开头难</h1>
<p>对于开发人员来说，仅仅学习编程语言的语法是不够的，还需要学习这门编程语言对应的构建流程，不然写出来的代码怎么变成程序运行起来呢？</p>
<p>出生较晚的编程语言，如golang、python等，都有对开发者友好的构建工具链，golang开发者仅仅需要花少量时间就能学会go mod和go build，很方便的将源码打包成程序拿去运行。</p>
<p>而出身于40多年前的C/C++语言，构建工具的学习成本并不低，而且一直在更新换代。</p>
<p>今天主要介绍一套适合C++服务端开发者在自己个人电脑上愉快开发和测试的方法。如果你需要创建一个伟大的C++服务端项目，也可以参考这个方法。</p>
<h2 id="cc编译和构建原理">C/C++编译和构建原理</h2>
<p>当你创建了一个cpp源码文件时，这个文件在构建过程中，处于什么位置呢？<br>
<img alt="image-20250628140340839" loading="lazy" data-src="https://img2024.cnblogs.com/blog/823852/202506/823852-20250628183148686-1651582739.png" class="lazyload"></p>
<p>每个源代码文件都会被编译成一个.o结尾的目标文件，如果这个文件有main函数，则可以链接成可执行程序；没有main函数的话可以打包成静态库或者动态库，供别人的可执行程序使用。</p>
<p>1个.cpp文件对应1个.o文件，.h文件的内容会被include到.cpp中，所以.h可以看作不在编译过程中</p>
<p>多个没有main函数的.o文件，可以打包成一个静态库，也可以打包成一个动态库。</p>
<p>一个有main函数的.o文件，可以拿一些.o、.a、.so文件过来一起打包成一个可执行程序。</p>
<p>相关工具参考：</p>
<table>
<thead>
<tr>
<th>工具/概念</th>
<th>作用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>g++</code> / <code>clang++</code></td>
<td>编译器，负责从 <code>.cpp</code> 编译成 <code>.o</code> 或链接为可执行文件</td>
</tr>
<tr>
<td><code>ld</code></td>
<td>链接器，负责将多个 <code>.o</code> 文件链接为可执行文件或库</td>
</tr>
<tr>
<td><code>as</code></td>
<td>汇编器，把 <code>.s</code> 文件转为 <code>.o</code>（有时作为中间步骤）</td>
</tr>
<tr>
<td><code>nm</code></td>
<td>查看 <code>.o</code>、<code>.a</code>、<code>.so</code> 文件中的符号（函数/变量名）</td>
</tr>
<tr>
<td><code>objdump</code></td>
<td>反汇编/查看二进制结构</td>
</tr>
<tr>
<td><code>readelf</code></td>
<td>查看 ELF 文件结构（更偏底层）</td>
</tr>
<tr>
<td><code>strip</code></td>
<td>去除调试符号，减小体积</td>
</tr>
<tr>
<td><code>ar</code></td>
<td>构建 <code>.a</code> 静态库（archive）</td>
</tr>
<tr>
<td><code>ldd</code></td>
<td>查看 ELF 的动态依赖库</td>
</tr>
<tr>
<td><code>file</code></td>
<td>查看文件类型，比如是不是 ELF</td>
</tr>
<tr>
<td><code>elfutils</code></td>
<td>一套处理 ELF 和 DWARF 调试信息的工具集</td>
</tr>
</tbody>
</table>
<h2 id="传统c开发环境和依赖安装">传统C++开发环境和依赖安装</h2>
<p>假设你的项目中有2个cpp文件，其中一个有main函数，则构建打包时是这样的流程。如果你使用系统库/第三方库选择的是release静态链接，则会把.a文件里相关的.o全都拷贝到app中，这样编译出来的app文件占用硬盘空间较大一点。</p>
<p><img alt="image-20250628143146321" loading="lazy" data-src="https://img2024.cnblogs.com/blog/823852/202506/823852-20250628183250848-1158447875.png" class="lazyload"></p>
<p>而如果libcaaa你选择的是.so链接方式，则.so中的.o文件不会拷贝到app中，而是app启动时系统才去指定的目录加载.so文件一起运行，如果运行app时找不到.so文件，app就无法启动。这样打包的app，由于没有拷贝.so的内容进来，所以没有用.a链接的app占硬盘空间。</p>
<p><img alt="image-20250628143458237" loading="lazy" data-src="https://img2024.cnblogs.com/blog/823852/202506/823852-20250628183304518-1022841907.png" class="lazyload"></p>
<p>共享链接的好处是如果有10个不同的app使用了同一个.so，那同时运行这10个app就仅需要在内存里加载1份.so文件。现代计算机的内存、硬盘空间便宜、性能好，所以大多数时候会选择静态链接，而很少使用共享链接。</p>
<p>当然，如果你的项目中没有main函数，而是写一些库给别人用。那就不会去链接系统库，而是直接将.o文件打包成.a和.so，供别的项目使用。</p>
<p>系统库/第三方库的来源：</p>
<ol>
<li>apt/yum安装</li>
<li>自动手动编译源码并拷贝到系统库目录</li>
</ol>
<h2 id="docker和wsl2介绍">docker和WSL2介绍</h2>
<p>在个人学习C++或者在自己电脑上开发C++服务端程序时，经常遇到一些问题：</p>
<p>自己的电脑是windows系统，没法编译和运行linux系统的程序，我尝试过的解决办法有：</p>
<ol>
<li>额外购买一台二手电脑装linux开发用；</li>
<li>租用linux云服务器，远程开发，最低配置的50元左右一个月；</li>
<li>自己的电脑装双系统，玩游戏时启windows，开发时启动linux；</li>
<li>在windows上安装vmware虚拟化软件，通过虚拟机运行Linux；</li>
<li>使用windows WSL1的ubuntu做开发；</li>
</ol>
<p>上述方法都不是很灵活，但的确是我以前使用过的一些方法。</p>
<p>而现在有了一个更好的方案，就是docker，启动一个docker容器，在容器里面安装ubuntu环境，然后在这个ubuntu环境中进行开发。一般为每个C++项目创建一个docker环境。互不干扰，不同担心不同项目使用了不同版本的系统库。</p>
<p>但是docker是共享宿主机内核的，在windows系统上怎么能跑Linux的容器呢？答案是windows提供了WSL2机制，该机制相当于在windows内核中运行了一个linux内核。windows系统打开WSL2功能后，你的电脑就同时在运行windows和linux内核。有了这个linux内核，自然可以基于它来运行ubuntu环境的容器。</p>
<p>现在，当你在windows上安装docker desktop时，docker desktop默认就使用WSL2的linux内核来运行容器。</p>
<p><img alt="image-20250628153950826" loading="lazy" data-src="https://img2024.cnblogs.com/blog/823852/202506/823852-20250628183351646-739737861.png" class="lazyload"></p>
<p>WSL2提供的linux内核对比vmware提供的linux内核有什么区别呢？</p>
<p><img alt="image-20250628154547572" loading="lazy" data-src="https://img2024.cnblogs.com/blog/823852/202506/823852-20250628183410108-505668711.png" class="lazyload"></p>
<p>WSL提供的linux内核跟宿主机windows又更高的融合和共享能力，有更低的性能损耗。方便、高效的共享CPU/GPU/网络/硬盘等资源。并成为了docker和vscode的默认选择。不得不说微软考虑的还是很全面的。</p>
<p>而开发者需要做的，就是在自己电脑上打开WSL2功能（打开就会自动运行linux子系统了）；在自己电脑上安装docker desktop，然后使用docker创建容器，容器默认就会运行在WSL的linux内核上。</p>
<p><img alt="image-20250628155647374" loading="lazy" data-src="https://img2024.cnblogs.com/blog/823852/202506/823852-20250628183430789-1700484621.png" class="lazyload"></p>
<p>这样，开发者即可通过vscode等IDE连接到容器中进行linux服务开发。同理，也可以在docker中运行mysql服务、redis服务、nginx服务、大语言模型等镜像，把部署中间件的工作也省了。</p>
<h2 id="现代c项目构建流程的栗子">现代C++项目构建流程的栗子</h2>
<p>接下来以一个C++开源项目举个实际的栗子，</p>
<p>这是一个linux上的高性能C++网络框架：<a href="https://github.com/scylladb/seastar%EF%BC%8C%E9%A1%B9%E7%9B%AE%E7%9A%84README.md%E6%98%AF%E8%BF%99%E6%A0%B7%E5%86%99%E7%9A%84%EF%BC%9A" target="_blank" rel="noopener nofollow">https://github.com/scylladb/seastar，项目的README.md是这样写的：</a></p>
<p><img alt="image-20250628143131117" loading="lazy" data-src="https://img2024.cnblogs.com/blog/823852/202506/823852-20250628183504807-1753949215.png" class="lazyload"></p>
<p>第一步，运行install-dependencies.sh安装第三方依赖库，也就是前面说的那些.a和.so文件；</p>
<p>第二步，运行configure.py来生成build.ninja(类似makefile)；</p>
<p>第三步，运行ninja(类似make，会调用gcc和ld等工具)进行编译；</p>
<p>如何在我的windows电脑编译运行它呢？</p>
<p>1.首先下载安装docker desktop：<a href="https://www.docker.com/products/docker-desktop/" target="_blank" rel="noopener nofollow">https://www.docker.com/products/docker-desktop/</a></p>
<p>安装docker-desktop过程中会打开windows的WSL2，当然你也可以手动打开WSL2：wsl.exe --update （注意，这一步可能出现各种网络失败，需要梯子）</p>
<p>2.下载seastar项目源码：git clone <a href="https://github.com/scylladb/seastar.git" target="_blank" rel="noopener nofollow">https://github.com/scylladb/seastar.git</a></p>
<p>3.可以看到，seastar项目提供了一个docker镜像用来进行编译，将seastar提供的dockerfile拷贝到根目录，并在根目录运行"docker build -t seastar-dev ."来构建docker镜像</p>
<p><img alt="image-20250628164352955" loading="lazy" data-src="https://img2024.cnblogs.com/blog/823852/202506/823852-20250628183532081-2103420961.png" class="lazyload"></p>
<p>4.镜像生成后，运行容器：</p>
<pre><code class="language-shell">docker run -it seastar-dev /bin/bash
</code></pre>
<p>5.可以通过vscode或者docker-desktop界面，attach到该容器的shell中，在容器里下载seastar项目源码。</p>
<pre><code class="language-shell">apt update
apt install git
git clone https://github.com/scylladb/seastar.git # 在容器中下载seastar项目代码
cd seastar # 进入项目
# ./install-dependencies.sh # 由于docker build时运行过安装依赖脚本了，这里不用再运行了
./configure.py --mode=release # 生成build.ninja文件
ninja -C build/release -j 4 # 4线程并发编译，产物生成到./build/release目录
</code></pre>
<p>6.debug: 运行configure.py时报错：seastar里面一个小工具程序依赖的libc-ares-dev版本不对，镜像中安装的是1.33版本，seastar要求不能用这个版本，解决办法：apt卸载已经安装的libc-ares-dev v1.33，手工下载v1.34或其他版本的源码，编译并安装：</p>
<pre><code>apt remove libc-ares-dev
apt autoremove

apt install -y wget

wget https://github.com/c-ares/c-ares/releases/download/v1.34.5/c-ares-1.34.5.tar.gz # 下载该库的源码包

tar -xzf c-ares-1.34.5.tar.gz # 解压

cd c-ares-1.34.5
./configure --prefix=/usr # 生成Makefile文件，设置安装路径
make -j 4 # 4并发编译
make install # 安装到系统目录
ld /usr/lib/libcares.so /usr/lib/x86_64-linux-gnu/libcares.so # 为libcares.so文件建立软连接
ldconfig # 重新加载系统.so文件列表
</code></pre>
<h1 id="结束">结束</h1>
<p>docker这种为每个程序、每个次编译环境都创建一个镜像环境的做法，极大的降低了环境准备的复杂性，虽然对硬件资源来说变得更浪费，但随着硬件性能提升、价格降低，这点浪费能带来开发效率的提升也是很划算的。特别是对于个人开发者来说。</p>
<p>windows也干脆直接选择集成了linux内核作为子系统，这样只要linux内核有的特性，在windows上同样能利用WSL享受到。</p>
<p>把这套能力直接套用在C++开发中，C++开发者也能专注代码开发，而不是把大部分研发时间用在研究环境搭建上。</p>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-28 18:36">2025-06-28 18:36</span>&nbsp;
<a href="https://www.cnblogs.com/xjjsk">心渐渐失空</a>&nbsp;
阅读(<span id="post_view_count">62</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18954892);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18954892', targetLink: 'https://www.cnblogs.com/xjjsk/p/18954892', title: 'C++服务开发环境-万事开头难' })">举报</a>

		</p>
	