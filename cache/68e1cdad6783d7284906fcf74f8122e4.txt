
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/io-T-T/p/18865007" title="发布于 2025-05-08 12:02">
    <span role="heading" aria-level="2">(dify)如何使用dify自定义知识库【dify外部链接知识库】</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        dify构建自定义知识库
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="尝试dify自定义知识库">尝试dify自定义知识库</h2>
<p>根据官网教程，可以从知识库的右上角外部知识库进行添加外部知识库</p>
<p>前往 <strong>“知识库”</strong> 页，点击右上角的 <strong>“外部知识库 API”</strong>，轻点 <strong>“添加外部知识库 API”</strong>。</p>
<p>按照页面提示，依次填写以下内容：</p>
<ul>
<li>
<p>知识库的名称，允许自定义名称，用于区分所连接的不同外部知识 API；</p>
</li>
<li>
<p>API 接口地址，外部知识库的连接地址，示例 <code>api-endpoint/retrieval</code>；详细说明请参考<a href="https://docs.dify.ai/zh-hans/guides/knowledge-base/external-knowledge-api-documentation" target="_blank" rel="noopener nofollow">外部知识库 API</a>；</p>
</li>
<li>
<p>API Key，外部知识库连接密钥，详细说明请参考<a href="https://docs.dify.ai/zh-hans/guides/knowledge-base/external-knowledge-api-documentation" target="_blank" rel="noopener nofollow">外部知识库 API</a>；</p>
<p><img src="https://img2024.cnblogs.com/blog/3244923/202505/3244923-20250507201304543-889741016.png" alt="image-20250326204900832" loading="lazy"></p>
</li>
</ul>
<p>因为<code>APIEndpoint</code><a href="https://blog.csdn.net/wo541075754/article/details/134433128" target="_blank" rel="noopener nofollow">需要</a>网络<code>url</code>地址，这里使用本地当作服务器进行尝试</p>
<h3 id="1-使用pythonflask框架构建本地后端">1 使用python+flask框架构建本地后端</h3>
<p>教程：<a href="https://www.cnblogs.com/feng0815/p/14488963.html" target="_blank">python flask框架详解</a></p>
<h4 id="11简单上手">1.1简单上手</h4>
<pre><code class="language-python">from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
   return 'Hello World'

if __name__ == '__main__':
   app.run()
</code></pre>
<p>在简单上手中，我们使用到了装饰器：<code>@app.route('/')</code>，要先了解<a href="https://www.bilibili.com/video/BV1Ah8jeQEeV" target="_blank" rel="noopener nofollow">装饰器</a>，然后了解<code>falsk</code>这个装饰器以及其他类似的装饰器的用法。</p>
<h4 id="12falsk的其他装饰器以及用法">1.2falsk的其他装饰器以及用法：</h4>
<p>【扩展阅读，可跳过】</p>
<h5 id="approute"><strong><code>@app.route()</code></strong></h5>
<ul>
<li>
<p><strong>作用</strong>：将视图函数与指定的 URL 路径进行绑定。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
</li>
</ul>
<pre><code class="language-python">@app.route('/') # 路由装饰器，绑定URL路径
def home():
    return 'Hello, World!'
</code></pre>
<h5 id="appbefore_request"><code>@app.before_request()</code></h5>
<ul>
<li>
<p><strong>作用</strong>：注册一个函数，在每个请求执行之前调用。适用于一些请求前的预处理，比如认证检查、日志记录等。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
</li>
</ul>
<pre><code class="language-python">@app.before_request
def before_request():
    print("This runs before every request.")
</code></pre>
<h5 id="appafter_request"><code>@app.after_request()</code></h5>
<ul>
<li>
<p><strong>作用</strong>：注册一个函数，在每个请求执行之后调用。适用于请求处理后的操作，如修改响应数据、日志记录等。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
</li>
</ul>
<pre><code class="language-python">@app.after_request
def after_request(response):
    print("This runs after each request.")
    return response  # 必须返回响应对象
</code></pre>
<h5 id="apperrorhandler"><strong><code>@app.errorhandler()</code></strong></h5>
<ul>
<li>
<p><strong>作用</strong>：注册一个函数，用于处理指定 HTTP 错误码的错误。例如，处理 404 页面未找到或 500 服务器错误等。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="language-python">@app.errorhandler(404)
def page_not_found(error):
    return "Page not found", 404
</code></pre>
</li>
</ul>
<h5 id="appbefore_first_request"><strong><code>@app.before_first_request()</code></strong></h5>
<ul>
<li>
<p><strong>作用</strong>：在应用处理第一个请求之前执行一次。适用于一些应用初始化的操作，例如数据库连接或缓存初始化等。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="language-python">@app.before_first_request
def before_first_request():
    print("This runs once before the first request.")
</code></pre>
</li>
</ul>
<h5 id="approute-支持-http-方法的装饰器"><strong><code>@app.route()</code> 支持 HTTP 方法的装饰器</strong></h5>
<ul>
<li>
<p><strong>作用</strong>：<code>@app.route()</code> 装饰器可以通过 <code>methods</code> 参数指定哪些 HTTP 方法（如 GET、POST、PUT、DELETE 等）可以触发该路由。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<pre><code class="language-python">@app.route('/submit', methods=['POST'])
def submit():
    return 'Form Submitted'
</code></pre>
</li>
</ul>
<h3 id="2-修改路由以及服务器设置">2 修改路由以及服务器设置</h3>
<h4 id="21-基础设置">2.1 基础设置</h4>
<p>由于<code>dify</code>启动时会占用本地默认的 <code>127.0.0.1:5000</code>，为了避免冲突，我们就需要通过修改端口的形式来规避这个问题，用到的接口是：</p>
<blockquote>
<pre><code class="language-python">app.run(debug=True, host='127.0.0.1', port=5001)
</code></pre>
</blockquote>
<p><code>app.run</code> 中提供了修改基本信息的接口：</p>
<ol>
<li><code>host</code>：服务器的地址，window默认为 <code>127.0.0.1</code></li>
<li><code>debug</code>：调试模式是否启动</li>
<li><code>port</code>：端口号。这里使用不同的端口号来分辨dify以及知识库服务器。</li>
</ol>
<h4 id="22test-code">2.2test code</h4>
<ul>
<li>
<p>根据需求会post一个<code>json</code>的请求体</p>
<p><img src="https://img2024.cnblogs.com/blog/3244923/202505/3244923-20250507201307612-106602162.png" alt="image-20250328161849930" loading="lazy"></p>
<p>因此我们假设他传来的是<code>json</code>、调用<code>get</code>方法</p>
</li>
</ul>
<pre><code class="language-python">from flask import Flask , request, jsonify


app = Flask(__name__)

@app.route('/retrieval',methods=['POST'])
def get_data():
    data = request.get_json()
    print(data)
    return jsonify(data)

@app.route('/')
def default():
    return 'hello'

if __name__ == '__main__':
    app.run(debug=True, host='127.0.0.1', port=5001)
    get_data()
</code></pre>
<h5 id="221-本地测试">2.2.1 本地测试</h5>
<p>先进行本地测试一下：</p>
<p><img src="https://img2024.cnblogs.com/blog/3244923/202505/3244923-20250507201303199-1330489865.png" alt="image-20250328162114712" loading="lazy"></p>
<p>主页成功，测试 <code>/retrieval</code>页面：</p>
<p><img src="https://img2024.cnblogs.com/blog/3244923/202505/3244923-20250507201304234-570297828.png" alt="image-20250328162159024" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3244923/202505/3244923-20250507201306807-1071657936.png" alt="image-20250328162215346" loading="lazy"></p>
<p>问题不大，因为我们没有上传<code>json</code>文件，启动<code>dify</code>尝试一下</p>
<h3 id="3--dify添加api测试">3 <code> dify</code>添加<code>api</code>测试</h3>
<p>发现会报错，没办法访问：</p>
<p><img src="https://cdn.jsdelivr.net/gh/idk0v0/pic25@main/image-20250328163025929.png" alt="image-20250328163025929" loading="lazy"></p>
<h4 id="31-问题解决">3.1 问题解决：</h4>
<ul>
<li>问题思考</li>
</ul>
<p>从计算机网络的角度来说，dify在<code>WSL</code>中运行，由于虚拟化，容器本地环境与windows的本地环境并不一致，即：当使用<code>127.0.0.1</code>进行访问时，访问的是容器内的主机，但我们的<code>window</code>环境并不在容器内部署，因此无法访问到window环境的<code>127.0.0.1</code>。中间需要一些NAT【单纯指网络地址转换】才能访问到主机</p>
<ul>
<li>
<p>问题解决：找到了网上的一篇博主的推文：【docker知识】<a href="https://blog.csdn.net/gongdiwudu/article/details/128888497" target="_blank" rel="noopener nofollow">从容器中如何访问到宿主机</a> 里面提及了如何在容器内访问解释为主机的<code>url</code></p>
<blockquote>
<p>将API ENDPOINT改为：<strong><code>host.docker.internal</code></strong></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/idk0v0/pic25@main/image-20250328170817389.png" alt="image-20250328170817389" loading="lazy"></p>
</li>
<li>
<p>结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/idk0v0/pic25@main/image-20250328170628821.png" alt="image-20250328170628821" loading="lazy"></p>
<p>更换为<code>docker</code>能转换的<code>url</code>就能访问成功。</p>
</li>
</ul>
<h3 id="4-完善post类">4 完善post类</h3>
<p>根据<code>api</code>规范进行构造：</p>
<p><img src="https://cdn.jsdelivr.net/gh/idk0v0/pic25@main/image-20250328173748099.png" alt="image-20250328173748099" loading="lazy"></p>
<p>理论上是从 <code>Dify_class</code>-&gt; <code>Records</code>开始构建的，但是依赖类需要写在前面，不用担心，这些都是基本功，不难的，就是复杂了一点，理清楚逻辑之后慢慢写就好：</p>
<p><strong>PS： 所有<code>__repr__</code>不要求写，我写着方便调试罢了</strong></p>
<h4 id="41-dify_class-传入dify数据类">4.1 <code>Dify_class</code> 传入dify数据类</h4>
<pre><code class="language-python">class Dify_class:
    def __init__(self,posted_data:dict):
        """
        dify有4个属性。
        三个必填：知识库id、输入筛选器、检索设置（类）
        一个选填：元数据信息（类）
        :param posted_data: 收到的post，从json转换为字典形式
        """
        self.knowledge_id:str = posted_data.get('knowledge_id')
        self.query:str = posted_data.get('query')
        self.retrieval_setting = Retrieval_setting(
            posted_data.get('retrieval_setting')
        )
        self.metadata_condition = Metadata_condition(
            posted_data.get('metadata_condition')
        )
    def __repr__(self):
        res = f"knowledge_id:{self.knowledge_id} \nquery:{self.query} \n"f"{self.retrieval_setting.__repr__()}"
        if self.metadata_condition != None:
            res.join(self.metadata_condition.__repr__())
        return res

</code></pre>
<h4 id="411-dify_class-两个依赖类">4.1.1 dify_class 两个依赖类</h4>
<pre><code class="language-python">class Retrieval_setting:
    def __init__(self, posted_data:dict):
        self.top_k:int = posted_data.get('top_k')
        self.score_threshold:float = posted_data.get('score_threshold')
    def __repr__(self):
        return f"\nretrieval_setting: \ntop_k:{self.top_k} \nscore_threshold:{self.score_threshold}"

class Metadata_condition:

    def __init__(self, posted_data:dict):
        if posted_data == None:
            self.logical_operator = None
            self.conditions = None
            self.status = -1 # 用于查看有多少参数，用于repr， -1则为空，2则为都有（未完善）
        else:
            self.conditions = posted_data.get('conditions')
            logical_operator_:str = posted_data.get('logical_operator')
            if logical_operator_ != None:
                self.logical_operator = logical_operator_
                self.status = 2
            else:
                self.logical_operator = None
                self.status = 1
    def __repr__(self):
        if self.status == -1:
            return "None"
        else:
            return f'logical_operator:{self.logical_operator}\nconditions：{self.conditions}'
</code></pre>
<h4 id="42-record类">4.2 record类</h4>
<pre><code class="language-python">class Records:
    def __init__(self,_content:str, _score:float, _title:str, _metadata:dict=None):
        self.content = _content
        self.score = _score
        self.title = _title
        self.metadata = Metadata(_metadata)
    def to_dict(self):
        """
        将record类转换为字典
        :return: 返回单个字典类型的records
        """

        res_dict =  dict(
            {
                "metadata":{
                    "path":self.metadata.path,
                    "description":self.metadata.description
                },
                "score":self.score,
                "title":self.title,
                "content":self.content
            }
        )
        return res_dict

    def __repr__(self):
        #没写metadata的
        return f'*************\nscore:{self.score} \ncontent:{self.content} \ntitle:{self.title} \n*************\n'
</code></pre>
<h4 id="421-record-依赖类">4.2.1 record 依赖类</h4>
<pre><code class="language-python">class Metadata:
    def __init__(self, record_dict:dict=None):
        if record_dict != None:
            self.path = record_dict.get("path")
            self.description = record_dict.get("description")
        else:
            self.path = None
            self.description = None
</code></pre>
<h4 id="43-测试dify类">4.3 测试dify类</h4>
<p>类main函数【用于测试】</p>
<blockquote>
<p><code>test.json</code>文件：</p>
</blockquote>
<pre><code class="language-json">{
    "knowledge_id": "your-knowledge-id",
    "query": "你的问题",
    "retrieval_setting":{
        "top_k": 2,
        "score_threshold": 0.5
    }
}
</code></pre>
<p>main：</p>
<pre><code class="language-python">if __name__ == '__main__':
    import json
    with open('test.json', mode='r',encoding='utf8') as fp:
        data = json.load(fp)
        dify_t = Dify_class(data)
        print(dify_t)
    test_record = Records("test_content", 1.0, "dify_test")
    print(test_record)
</code></pre>
<h3 id="5-接入服务器连接">5 接入服务器连接</h3>
<h4 id="51-导入相关包">5.1 导入相关包</h4>
<pre><code class="language-python">from flask import Flask , request, jsonify
import dify_class ,json
#dify_class是4中的文件名称
</code></pre>
<h4 id="52-设置服务器">5.2 设置服务器</h4>
<pre><code class="language-python">app = Flask(__name__)

@app.route('/retrieval',methods=['POST'])
def get_data():
    data = request.get_json()       #获取请求的json数据
    dify_t = dify_class.Dify_class(data)    #初始化dify请求类
    print(dify_t)                           #调试输出

    res = []
    for i in range(dify_t.retrieval_setting.top_k): #模拟 topk
        res.append(
            dify_class.Records("test_content", 1.0, "dify_test").to_dict()  #测试回复类，构造一个请求类-&gt;返回他的字典形式-&gt;放入res列表中
        )
    res_dict = {
        "records": res
    }

    json_res = json.dumps(res_dict)
    return json_res, 200
</code></pre>
<h4 id="53-主函数">5.3 主函数</h4>
<pre><code class="language-python">#outside knowledge id_0001
if __name__ == '__main__':
    app.run(debug=True, host='127.0.0.1', port=5001)
    get_data()
</code></pre>
<h4 id="54-测试">5.4 测试</h4>
<ol>
<li>
<p>启动服务器</p>
<p><img src="https://cdn.jsdelivr.net/gh/idk0v0/pic25@main/image-20250329173751319.png" alt="image-20250329173751319" loading="lazy"></p>
</li>
<li>
<p>进行召回测试</p>
<p><img src="https://img2024.cnblogs.com/blog/3244923/202505/3244923-20250507201303703-40397109.png" alt="image-20250329173820464" loading="lazy"></p>
<p>终于是显示测试效果出来了。能够返回你测试的样例就<em><strong>说明成功了</strong></em> 😭 😭，后续就是根据他<code>post</code>的东西来进行检索了。</p>
</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.352616901525463" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-08 12:03">2025-05-08 12:02</span>&nbsp;
<a href="https://www.cnblogs.com/io-T-T">io_T_T</a>&nbsp;
阅读(<span id="post_view_count">28</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18865007);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18865007', targetLink: 'https://www.cnblogs.com/io-T-T/p/18865007', title: '(dify)如何使用dify自定义知识库【dify外部链接知识库】' })">举报</a>
</div>
        