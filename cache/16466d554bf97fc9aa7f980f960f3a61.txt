
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dalgleish/p/18978564" title="发布于 2025-07-11 12:31">
    <span role="heading" aria-level="2">C# Avalonia 03 - LayoutPanels - SimpleInkCanvas</span>
    

</a>

	</div>
	<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><strong>这次继承C# Avalonia官方自带的Canvas，扩展一个InkCanvas，兼容Canvas的所有功能。为了简化自定义命名控件，建议把自定义控件加入到默认空间。</strong></p>
<p><strong>AssemblyInfo.cs代码如下</strong></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">using System.Runtime.CompilerServices;
using System.Resources;
using Avalonia.Metadata;

[assembly: NeutralResourcesLanguage("zh-CN")]
[assembly: XmlnsDefinition("https://github.com/avaloniaui", "Shares.Avalonia")]</span></pre>
</div>
<p><strong>Canvas类有几点需要注意。</strong></p>
<p><strong>1. 自定义内容区域，是通过[Content]属性来描述Controls类。</strong></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">        [Content]
        public Controls Children { get; } = new Controls();
</pre>
</div>
<p><strong>2.　Render是sealed，所以不支持重写Render。</strong></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">        public sealed override void Render(DrawingContext context)</pre>
</div>
<p><strong>现在，我们在Shares.Avalonia共享项目中，创建一个ControlExtensions.cs，实现InkCanvas类。代码如下</strong></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Media;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Shares.Avalonia
{
    public enum InkEditingMode
    {
        Ink,
        Erase,
        Select
    }

    public class InkStroke
    {
        public List&lt;Point&gt; Points { get; set; } = new();
        public Color Color { get; set; } = Colors.Black;
        public double Thickness { get; set; } = 1.0;
    }

    public class InkCanvasLayer : Control
    {
        public List&lt;InkStroke&gt; Strokes { get; set; } = new();
        public InkStroke? CurrentStroke { get; set; }
        public List&lt;InkStroke&gt; SelectedStrokes { get; set; } = new();
        public Rect? SelectionRect { get; set; }
        public Rect? SelectionBox { get; set; }

        public override void Render(DrawingContext context)
        {
            base.Render(context);

            foreach (var stroke in Strokes)
            {
                var isSelected = SelectedStrokes.Contains(stroke);
                DrawStroke(context, stroke, isSelected);
            }

            if (CurrentStroke != null)
                DrawStroke(context, CurrentStroke);

            if (SelectionRect.HasValue)
            {
                context.DrawRectangle(null,
                    new Pen(Brushes.DarkOliveGreen, 1, dashStyle: DashStyle.Dash),
                    SelectionRect.Value);
            }

            if (SelectionBox.HasValue)
            {
                var pen = new Pen(Brushes.DarkGray, 1, dashStyle: DashStyle.Dash);
                context.DrawRectangle(null, pen, SelectionBox.Value);
            }
        }

        private void DrawStroke(DrawingContext context, InkStroke stroke, bool isSelected = false)
        {
            if (stroke.Points.Count &lt; 2) return;

            var color = isSelected ? Colors.Black : stroke.Color;
            var thickness = isSelected ? stroke.Thickness * 2 : stroke.Thickness;
            var pen = new Pen(new SolidColorBrush(color), thickness);
            for (int i = 1; i &lt; stroke.Points.Count; i++)
            {
                context.DrawLine(pen, stroke.Points[i - 1], stroke.Points[i]);
            }
        }
    }

    public class InkCanvas : Canvas
    {
        private readonly InkCanvasLayer layer;
        private List&lt;InkStroke&gt; strokes = new();
        private InkStroke? currentStroke;
        private Stack&lt;List&lt;InkStroke&gt;&gt; undoStack = new();
        private Stack&lt;List&lt;InkStroke&gt;&gt; redoStack = new();

        private bool isSelecting = false;
        private Rect selectionRect;
        private List&lt;InkStroke&gt; selectedStrokes = new();
        private Point selectionStart;

        private bool isDraggingSelection = false;
        private Point lastDragPoint;

        public static readonly StyledProperty&lt;Color&gt; StrokeColorProperty =
            AvaloniaProperty.Register&lt;InkCanvas, Color&gt;(nameof(StrokeColor), Colors.Black);
        public Color StrokeColor
        {
            get =&gt; GetValue(StrokeColorProperty);
            set =&gt; SetValue(StrokeColorProperty, value);
        }

        public static readonly StyledProperty&lt;double&gt; StrokeThicknessProperty =
            AvaloniaProperty.Register&lt;InkCanvas, double&gt;(nameof(StrokeThickness), 2.0);
        public double StrokeThickness
        {
            get =&gt; GetValue(StrokeThicknessProperty);
            set =&gt; SetValue(StrokeThicknessProperty, value);
        }

        public static readonly StyledProperty&lt;InkEditingMode&gt; EditingModeProperty =
            AvaloniaProperty.Register&lt;InkCanvas, InkEditingMode&gt;(nameof(EditingMode), InkEditingMode.Ink);
        public InkEditingMode EditingMode
        {
            get =&gt; GetValue(EditingModeProperty);
            set =&gt; SetValue(EditingModeProperty, value);
        }

        public InkCanvas()
        {
            layer = new InkCanvasLayer();
            Children.Add(layer);

            PointerPressed += OnPointerPressed;
            PointerMoved += OnPointerMoved;
            PointerReleased += OnPointerReleased;

            this.GetObservable(EditingModeProperty).Subscribe(mode =&gt;
            {
                selectedStrokes.Clear();
                layer.SelectedStrokes = selectedStrokes;
                layer.SelectionBox = null;
                layer.InvalidateVisual();
            });

            Background = Brushes.White;
        }

        protected override Size ArrangeOverride(Size finalSize)
        {
            layer.Arrange(new Rect(finalSize));
            return base.ArrangeOverride(finalSize);
        }

        private void OnPointerPressed(object? sender, PointerPressedEventArgs e)
        {
            var point = e.GetPosition(this);

            if (EditingMode == InkEditingMode.Erase)
            {
                EraseAtPoint(point);
                return;
            }

            if (EditingMode == InkEditingMode.Select)
            {
                selectionStart = point;
                selectionRect = new Rect(point, point);

                if (selectedStrokes.Any(s =&gt; s.Points.Any(p =&gt; Distance(p, point) &lt; 5)))
                {
                    isDraggingSelection = true;
                    lastDragPoint = point;
                    return;
                }

                isSelecting = true;
                return;
            }

            currentStroke = new InkStroke
            {
                Color = StrokeColor,
                Thickness = StrokeThickness
            };
            currentStroke.Points.Add(point);
            layer.CurrentStroke = currentStroke;
            e.Pointer.Capture(this);
        }

        private void OnPointerMoved(object? sender, PointerEventArgs e)
        {
            var point = e.GetPosition(this);

            if (currentStroke != null &amp;&amp; e.GetCurrentPoint(this).Properties.IsLeftButtonPressed)
            {
                currentStroke.Points.Add(point);
                layer.InvalidateVisual();
            }

            if (isDraggingSelection &amp;&amp; e.GetCurrentPoint(this).Properties.IsLeftButtonPressed)
            {
                var delta = point - lastDragPoint;
                MoveSelected(delta);
                lastDragPoint = point;
                UpdateSelectionBox();
            }

            if (isSelecting &amp;&amp; e.GetCurrentPoint(this).Properties.IsLeftButtonPressed)
            {
                selectionRect = new Rect(selectionStart, point).Normalize();
                layer.SelectionRect = selectionRect;
                layer.InvalidateVisual();
            }
        }

        private void OnPointerReleased(object? sender, PointerReleasedEventArgs e)
        {
            if (currentStroke != null)
            {
                SaveUndoState();
                strokes.Add(currentStroke);
                currentStroke = null;
                layer.CurrentStroke = null;
            }

            if (isDraggingSelection)
            {
                isDraggingSelection = false;
            }

            if (isSelecting)
            {
                isSelecting = false;
                layer.SelectionRect = null;
                SelectStrokesInRect(selectionRect);
            }

            layer.InvalidateVisual();
            e.Pointer.Capture(null);
        }

        private void SelectStrokesInRect(Rect rect)
        {
            selectedStrokes.Clear();
            foreach (var stroke in strokes)
            {
                if (stroke.Points.Any(p =&gt; rect.Contains(p)))
                {
                    selectedStrokes.Add(stroke);
                }
            }
            layer.SelectedStrokes = selectedStrokes;
            UpdateSelectionBox();
        }

        private void UpdateSelectionBox()
        {
            if (selectedStrokes.Count == 0)
            {
                layer.SelectionBox = null;
                return;
            }

            double minX = double.MaxValue, minY = double.MaxValue;
            double maxX = double.MinValue, maxY = double.MinValue;

            foreach (var stroke in selectedStrokes)
            {
                foreach (var p in stroke.Points)
                {
                    minX = Math.Min(minX, p.X);
                    minY = Math.Min(minY, p.Y);
                    maxX = Math.Max(maxX, p.X);
                    maxY = Math.Max(maxY, p.Y);
                }
            }

            layer.SelectionBox = new Rect(minX, minY, maxX - minX, maxY - minY);
        }

        private void EraseAtPoint(Point point)
        {
            const double hitRadius = 5;
            SaveUndoState();
            strokes.RemoveAll(s =&gt; s.Points.Exists(p =&gt; Distance(p, point) &lt; hitRadius));
            layer.Strokes = strokes;
            layer.InvalidateVisual();
        }

        private double Distance(Point a, Point b)
        {
            var dx = a.X - b.X;
            var dy = a.Y - b.Y;
            return Math.Sqrt(dx * dx + dy * dy);
        }

        public void MoveSelected(Vector delta)
        {
            foreach (var stroke in selectedStrokes)
            {
                for (int i = 0; i &lt; stroke.Points.Count; i++)
                    stroke.Points[i] += delta;
            }
            UpdateSelectionBox();
            layer.InvalidateVisual();
        }

        private void SaveUndoState()
        {
            undoStack.Push(strokes.Select(s =&gt; new InkStroke
            {
                Points = new List&lt;Point&gt;(s.Points),
                Color = s.Color,
                Thickness = s.Thickness
            }).ToList());
            redoStack.Clear();
            layer.Strokes = strokes;
        }

        public void Undo()
        {
            if (undoStack.Count == 0) return;
            redoStack.Push(strokes);
            strokes = undoStack.Pop();
            layer.Strokes = strokes;
            layer.InvalidateVisual();
        }

        public void Redo()
        {
            if (redoStack.Count == 0) return;
            undoStack.Push(strokes);
            strokes = redoStack.Pop();
            layer.Strokes = strokes;
            layer.InvalidateVisual();
        }

        public IReadOnlyList&lt;InkStroke&gt; Strokes =&gt; strokes.AsReadOnly();
    }
}
</pre>
</div>
<p><strong>SimpleInkCanvas.axaml代码，其中office.jpg要把属性设置为AvaloniaResource。目前AvaloniaResource除了对axaml有bug外，其他资源是没问题。</strong></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">Window </span><span style="color: rgba(255, 0, 0, 1)">xmlns</span><span style="color: rgba(0, 0, 255, 1)">="https://github.com/avaloniaui"</span><span style="color: rgba(255, 0, 0, 1)">
        xmlns:x</span><span style="color: rgba(0, 0, 255, 1)">="http://schemas.microsoft.com/winfx/2006/xaml"</span><span style="color: rgba(255, 0, 0, 1)">
        xmlns:d</span><span style="color: rgba(0, 0, 255, 1)">="http://schemas.microsoft.com/expression/blend/2008"</span><span style="color: rgba(255, 0, 0, 1)">
        xmlns:mc</span><span style="color: rgba(0, 0, 255, 1)">="http://schemas.openxmlformats.org/markup-compatibility/2006"</span><span style="color: rgba(255, 0, 0, 1)">
        Height</span><span style="color: rgba(0, 0, 255, 1)">="300"</span><span style="color: rgba(255, 0, 0, 1)"> Width</span><span style="color: rgba(0, 0, 255, 1)">="300"</span><span style="color: rgba(255, 0, 0, 1)">
        x:Class</span><span style="color: rgba(0, 0, 255, 1)">="AvaloniaUI.SimpleInkCanvas"</span><span style="color: rgba(255, 0, 0, 1)">
        Title</span><span style="color: rgba(0, 0, 255, 1)">="SimpleInkCanvas"</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>
    <span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">Grid </span><span style="color: rgba(255, 0, 0, 1)">RowDefinitions</span><span style="color: rgba(0, 0, 255, 1)">="auto,*"</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>
        <span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">StackPanel </span><span style="color: rgba(255, 0, 0, 1)">Margin</span><span style="color: rgba(0, 0, 255, 1)">="5"</span><span style="color: rgba(255, 0, 0, 1)"> Orientation</span><span style="color: rgba(0, 0, 255, 1)">="Horizontal"</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>
            <span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">TextBlock </span><span style="color: rgba(255, 0, 0, 1)">Margin</span><span style="color: rgba(0, 0, 255, 1)">="5"</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>EditingMode: <span style="color: rgba(0, 0, 255, 1)">&lt;/</span><span style="color: rgba(128, 0, 0, 1)">TextBlock</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>
            <span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">ComboBox </span><span style="color: rgba(255, 0, 0, 1)">Name</span><span style="color: rgba(0, 0, 255, 1)">="lstEditingMode"</span><span style="color: rgba(255, 0, 0, 1)">  VerticalAlignment</span><span style="color: rgba(0, 0, 255, 1)">="Center"</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>
            <span style="color: rgba(0, 0, 255, 1)">&lt;/</span><span style="color: rgba(128, 0, 0, 1)">ComboBox</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>
        <span style="color: rgba(0, 0, 255, 1)">&lt;/</span><span style="color: rgba(128, 0, 0, 1)">StackPanel</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>

        <span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">InkCanvas </span><span style="color: rgba(255, 0, 0, 1)">Name</span><span style="color: rgba(0, 0, 255, 1)">="inkCanvas"</span><span style="color: rgba(255, 0, 0, 1)"> Grid.Row</span><span style="color: rgba(0, 0, 255, 1)">="1"</span><span style="color: rgba(255, 0, 0, 1)"> Background</span><span style="color: rgba(0, 0, 255, 1)">="LightYellow"</span><span style="color: rgba(255, 0, 0, 1)"> EditingMode</span><span style="color: rgba(0, 0, 255, 1)">="</span><span style="color: rgba(128, 128, 0, 1)">{Binding ElementName=lstEditingMode,Path=SelectedItem}</span><span style="color: rgba(0, 0, 255, 1)">"</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>
            <span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">Button </span><span style="color: rgba(255, 0, 0, 1)">Canvas.Top</span><span style="color: rgba(0, 0, 255, 1)">="10"</span><span style="color: rgba(255, 0, 0, 1)"> Canvas.Left</span><span style="color: rgba(0, 0, 255, 1)">="10"</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>Hello<span style="color: rgba(0, 0, 255, 1)">&lt;/</span><span style="color: rgba(128, 0, 0, 1)">Button</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>
            <span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">Image </span><span style="color: rgba(255, 0, 0, 1)">Source</span><span style="color: rgba(0, 0, 255, 1)">="avares://AvaloniaUI/Resources/Images/office.jpg"</span><span style="color: rgba(255, 0, 0, 1)"> Canvas.Top</span><span style="color: rgba(0, 0, 255, 1)">="10"</span><span style="color: rgba(255, 0, 0, 1)"> Canvas.Left</span><span style="color: rgba(0, 0, 255, 1)">="50"</span><span style="color: rgba(255, 0, 0, 1)">
               Width</span><span style="color: rgba(0, 0, 255, 1)">="100"</span><span style="color: rgba(255, 0, 0, 1)"> Height</span><span style="color: rgba(0, 0, 255, 1)">="100"</span><span style="color: rgba(0, 0, 255, 1)">/&gt;</span>
        <span style="color: rgba(0, 0, 255, 1)">&lt;/</span><span style="color: rgba(128, 0, 0, 1)">InkCanvas</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>
    <span style="color: rgba(0, 0, 255, 1)">&lt;/</span><span style="color: rgba(128, 0, 0, 1)">Grid</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>
<span style="color: rgba(0, 0, 255, 1)">&lt;/</span><span style="color: rgba(128, 0, 0, 1)">Window</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span></pre>
</div>
<p><strong>SimpleInkCanvas.axaml.cs代码</strong></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using Shares.Avalonia;
using System;

namespace AvaloniaUI;

public partial class SimpleInkCanvas : Window
{
    public SimpleInkCanvas()
    {
        InitializeComponent();

        foreach (InkEditingMode mode in Enum.GetValues(typeof(InkEditingMode)))
        {
            lstEditingMode.Items.Add(mode);
            lstEditingMode.SelectedItem = inkCanvas.EditingMode;
        }
    }
}
</pre>
</div>
<p>运行效果</p>
<p><img alt="" loading="lazy" data-src="https://img2024.cnblogs.com/blog/702851/202507/702851-20250711124739331-220667735.png" class="lazyload"></p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.011805555555555555" data-date-updated="2025-07-11 12:48">2025-07-11 12:31</span>&nbsp;
<a href="https://www.cnblogs.com/dalgleish">dalgleish</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18978564);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18978564', targetLink: 'https://www.cnblogs.com/dalgleish/p/18978564', title: 'C# Avalonia 03 - LayoutPanels - SimpleInkCanvas' })">举报</a>
</div>
