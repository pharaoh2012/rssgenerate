
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/nianzhilian/p/18892950" title="发布于 2025-05-23 14:03">
    <span role="heading" aria-level="2">迭代、迭代器、生成器的前世今生</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<blockquote>
<h3>什么是迭代</h3>
<p><code>类似于遍历 遍历：有多个数据组成的集合数据结构（map、set、array等其他类数组），需要从该结构中依次取出数据进行某种处理。 迭代：按照某种逻辑，依次取出下一个数据进行处理。</code></p>
</blockquote>
<blockquote>
<h3>什么是迭代器 iterator</h3>
<p><code>JS语言规定，如果一个对象具有next方法，并且next方法满足一定的约束，则该对象是一个迭代器（iterator）。 next方法的约束：该方法必须返回一个对象，该对象至少具有两个属性：</code></p>
<ul>
<li>value：any类型，下一个数据的值，如果done属性为true，通常，会将value设置为undefined</li>
<li>done：bool类型，是否已经迭代完成</li>
<li>通过迭代器的next方法，可以依次取出数据，并可以根据返回的done属性，判定是否迭代结束。</li>
</ul>
</blockquote>
<h2>案例如下：</h2>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">*
       * 迭代器
       * 必须有个next函数
       * 该函数必须返回一个对象 包括 value 属性 和 done属性
       * value:本次迭代的返回值
       * done:true 或者 false 本次迭代是否结束
       * </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">
      const iterator </span>=<span style="color: rgba(0, 0, 0, 1)"> {
        total:</span>3<span style="color: rgba(0, 0, 0, 1)">,
        index:</span>1<span style="color: rgba(0, 0, 0, 1)">,
        next(){
          const obj </span>=<span style="color: rgba(0, 0, 0, 1)"> {
            value:</span><span style="color: rgba(0, 0, 255, 1)">this</span>.index &gt; <span style="color: rgba(0, 0, 255, 1)">this</span>.total?<span style="color: rgba(0, 0, 0, 1)">undefined:Math.random(),
            done:</span><span style="color: rgba(0, 0, 255, 1)">this</span>.index &gt; <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.total
          }
          </span><span style="color: rgba(0, 0, 255, 1)">this</span>.index++<span style="color: rgba(0, 0, 0, 1)">;
          </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> obj;
        }
      }

      </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">一个一个迭代直到不能迭代为止</span>
<span style="color: rgba(0, 0, 0, 1)">
      let result </span>=<span style="color: rgba(0, 0, 0, 1)"> iterator.next();
      </span><span style="color: rgba(0, 0, 255, 1)">while</span>(!<span style="color: rgba(0, 0, 0, 1)">result.done){
        console.log(result);
        result </span>=<span style="color: rgba(0, 0, 0, 1)"> iterator.next();
      }

      </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">输出斐波拉数列的数据</span>
      <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">1 1 2 3 5 8 13 21</span>
      const sequenceItereator =<span style="color: rgba(0, 0, 0, 1)"> {
        a:</span>1<span style="color: rgba(0, 0, 0, 1)">,
        b:</span>1<span style="color: rgba(0, 0, 0, 1)">,
        curIndex:</span>1, <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">当前从1开始算</span>
<span style="color: rgba(0, 0, 0, 1)">        next(){
          </span><span style="color: rgba(0, 0, 255, 1)">if</span>(<span style="color: rgba(0, 0, 255, 1)">this</span>.curIndex == 1 || <span style="color: rgba(0, 0, 255, 1)">this</span>.curIndex == 2<span style="color: rgba(0, 0, 0, 1)">){
            </span><span style="color: rgba(0, 0, 255, 1)">this</span>.curIndex++<span style="color: rgba(0, 0, 0, 1)">;
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> {
              value:</span>1<span style="color: rgba(0, 0, 0, 1)">,
              done:</span><span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">
            }
          }
          </span><span style="color: rgba(0, 0, 255, 1)">var</span> c = <span style="color: rgba(0, 0, 255, 1)">this</span>.a + <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.b;
          </span><span style="color: rgba(0, 0, 255, 1)">this</span>.curIndex++<span style="color: rgba(0, 0, 0, 1)">;
          </span><span style="color: rgba(0, 0, 255, 1)">this</span>.a = <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.b;
          </span><span style="color: rgba(0, 0, 255, 1)">this</span>.b =<span style="color: rgba(0, 0, 0, 1)"> c;
          </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> {
            value:c,
            done:</span><span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">
          }
        }
      }

      </span><span style="color: rgba(0, 0, 255, 1)">for</span>(<span style="color: rgba(0, 0, 255, 1)">var</span> i = 0;i&lt;50;i++<span style="color: rgba(0, 0, 0, 1)">){
        console.log(sequenceItereator.next());
      }</span></pre>
</div>
<p>&nbsp;</p>
<blockquote>
<h3>什么是迭代器创建函数</h3>
<p><code>它是指一个函数，调用该函数后，返回一个迭代器，则该函数称之为迭代器创建函数，可以简称位迭代器函数。</code></p>
</blockquote>
<h2>案例如下：</h2>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">迭代器创建函数</span>
      <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> createIterator(arr){
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> i = 0<span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> {
          next(){
            </span><span style="color: rgba(0, 0, 255, 1)">var</span> obj =<span style="color: rgba(0, 0, 0, 1)"> {
              value:arr[i],
              done:i</span>&gt;arr.length - 1<span style="color: rgba(0, 0, 0, 1)">
            }
            i</span>++<span style="color: rgba(0, 0, 0, 1)">;
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> obj;
          }
        }
      }
      </span><span style="color: rgba(0, 0, 255, 1)">var</span> iterator = createIterator([1,3,5,7,9<span style="color: rgba(0, 0, 0, 1)">]);
      console.log(iterator);</span></pre>
</div>
<p>&nbsp;</p>
<h3>什么是可迭代协议</h3>
<p><code>ES6中出现了for-of循环，该循环就是用于迭代某个对象的，因此，for-of循环要求对象必须是可迭代的（对象必须满足可迭代协议） 可迭代协议是用于约束一个对象的，如果一个对象满足下面的规范，则该对象满足可迭代协议，也称之为该对象是可以被迭代的。 可迭代协议的约束如下：</code></p>
<ul>
<li>对象必须有一个知名符号属性（Symbol.iterator）</li>
<li>done：bool类型，是否已经迭代完成</li>
<li>该属性必须是一个无参的迭代器创建函数</li>
</ul>
<h2>案例如下：</h2>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">可迭代协议</span>
      <span style="color: rgba(0, 0, 255, 1)">var</span> robj =<span style="color: rgba(0, 0, 0, 1)"> {
        [Symbol.iterator]:</span><span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)">(){
          </span><span style="color: rgba(0, 0, 255, 1)">var</span> total = 3<span style="color: rgba(0, 0, 0, 1)">;
          </span><span style="color: rgba(0, 0, 255, 1)">var</span> i = 1<span style="color: rgba(0, 0, 0, 1)">;
          </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> {
            next(){
              </span><span style="color: rgba(0, 0, 255, 1)">var</span> oop =<span style="color: rgba(0, 0, 0, 1)"> {
                value:i</span>&gt;total?<span style="color: rgba(0, 0, 0, 1)">undefined:Math.random(),
                done:i</span>&gt;<span style="color: rgba(0, 0, 0, 1)">total
              }
              i</span>++<span style="color: rgba(0, 0, 0, 1)">;
              </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> oop;
            }
          }
        }
      };
      </span><span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> (const element of robj) {
        console.log(element);
      }</span></pre>
</div>
<p>&nbsp;</p>
<h3>什么是生成器</h3>
<p><code>生成器：由构造函数Generator创建的对象，该对象既是一个迭代器，同时，又是一个可迭代对象（满足可迭代协议的对象）</code></p>
<p><code>**注意：Generator构造函数，不提供给开发者使用，仅作为JS引擎内部使用**</code></p>
<p><code>生成器函数（生成器创建函数）：该函数用于创建一个生成器。</code></p>
<p><code>ES6新增了一个特殊的函数，叫做生成器函数，只要在函数名与function关键字之间加上一个*号，则该函数会自动返回一个生成器</code></p>
<p><code>生成器函数的特点：</code></p>
<ul>
<li>调用生成器函数，会返回一个生成器，而不是执行函数体（因为，生成器函数的函数体执行，收到生成器控制）</li>
<li>每当调用了生成器的next方法，生成器的函数体会从上一次yield的位置（或开始位置）运行到下一个yield
<ul>
<li>yield关键字只能在生成器内部使用，不可以在普通函数内部使用</li>
<li>它表示暂停，并返回一个当前迭代的数据</li>
<li>如果没有下一个yield，到了函数结束，则生成器的next方法得到的结果中的done为true</li>
</ul>
</li>
<li>yield关键字后面的表达式返回的数据，会作为当前迭代的数据</li>
<li>生成器函数的返回值会作最终的value的值 但是当在进行next时 value是undefined</li>
<li>生成器在调用next的时候可以传递参数，该参数会作为上一次yield整个表达式的返回结果</li>
</ul>
<h2>案列如下：</h2>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">生成器函数  调用该函数返回一个生成器  该生成器即使是一个迭代器 又是一个可迭代对象（满足可迭代协议）</span>
      <span style="color: rgba(0, 0, 255, 1)">function</span>*<span style="color: rgba(0, 0, 0, 1)"> createGenerator(){
        console.log(</span>'函数体执行 - 开始'<span style="color: rgba(0, 0, 0, 1)">);
        yield </span>1; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">会作为本次迭代的value值 {value:1,done:false}</span>
        console.log("函数体执行 - 1"<span style="color: rgba(0, 0, 0, 1)">)
        yield </span>2;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">会作为本次迭代的value值 {value:2,done:false}</span>
        console.log('函数体执行 - 2'<span style="color: rgba(0, 0, 0, 1)">);
        yield </span>3;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">会作为本次迭代的value值 {value:3,done:false}</span>
        console.log("函数体执行 - 3"<span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> "结束"<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">会作为本次迭代的value值 {value:"结束",done:true}</span>
<span style="color: rgba(0, 0, 0, 1)">      }
      </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">掉用只会返回一个生成器 不会执行函数体</span>
      <span style="color: rgba(0, 0, 255, 1)">var</span> generator =<span style="color: rgba(0, 0, 0, 1)"> createGenerator();
      </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">当调用next的时候会从开始位置到第一个yield处执行  执行到yield位置就会卡住（不会继续执行）， 等到下一次next的时候</span>
      <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">生成器的函数体会从上一次yield的位置（或开始位置）运行到下一个yield</span>
<span style="color: rgba(0, 0, 0, 1)">      console.log(generator.next);
      const iterator </span>=<span style="color: rgba(0, 0, 0, 1)"> generator[Symbol.iterator]();


      </span><span style="color: rgba(0, 0, 255, 1)">function</span>*<span style="color: rgba(0, 0, 0, 1)"> createArrayIterator(array){
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (let index = 0; index &lt; array.length; index++<span style="color: rgba(0, 0, 0, 1)">) {
          const item </span>=<span style="color: rgba(0, 0, 0, 1)"> array[index];
          console.log(`第${index}次迭代`);
          yield item;
        }
      }
      const arrayIterator </span>= createArrayIterator([1,2,3,4,5,6]);</pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">生成器函数  调用该函数返回一个生成器  该生成器即使是一个迭代器 又是一个可迭代对象（满足可迭代协议）</span>
      <span style="color: rgba(0, 0, 255, 1)">function</span>*<span style="color: rgba(0, 0, 0, 1)"> createGenerator(){
        console.log(</span>'函数体执行 - 开始'<span style="color: rgba(0, 0, 0, 1)">);
        let result </span>= yield 1; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">会作为本次迭代的value值 {value:1,done:false}</span>
        console.log("函数体执行 - 1"<span style="color: rgba(0, 0, 0, 1)">,result)
        result </span>= yield 2;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">会作为本次迭代的value值 {value:2,done:false}</span>
        console.log('函数体执行 - 2'<span style="color: rgba(0, 0, 0, 1)">,result);
        result </span>= yield 3;<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">会作为本次迭代的value值 {value:3,done:false}</span>
        console.log("函数体执行 - 3"<span style="color: rgba(0, 0, 0, 1)">,result);
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> "结束"<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">会作为本次迭代的value值 {value:"结束",done:true}</span>
<span style="color: rgba(0, 0, 0, 1)">      }
      let itereator </span>=<span style="color: rgba(0, 0, 0, 1)"> createGenerator();
      let res </span>=<span style="color: rgba(0, 0, 0, 1)"> itereator.next();
      </span><span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> run(){
        </span><span style="color: rgba(0, 0, 255, 1)">if</span>(!<span style="color: rgba(0, 0, 0, 1)">res.done){
          </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">如果在调用next的时候 给 next传递参数  该参数会作为 yield 整个表达式的值返回</span>
          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">执行步骤</span>
          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">第一次调用就不care了  第一次调用碰到yield 1; 就会卡住不会往下执行  这个时候还不执行赋值操作</span>
          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">第二次调用next 传递上一次迭代的值作为参数传递  这个时候 就会从上一次 yield的位置 运行到下一个yield （这个时候就会进行赋值操作）</span>
          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">整个yield 表达式的返回值 就是给next函数传递的参数</span>
          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">依次类推</span>
<span style="color: rgba(0, 0, 0, 1)">          console.log(res);
          res </span>= itereator.next("张三:"+<span style="color: rgba(0, 0, 0, 1)">Math.random());
          run();
        }
      }
      run();</span></pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">var</span> i = 0<span style="color: rgba(0, 0, 0, 1)">;
      </span><span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> asyncData(){
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span> Promise((resolve,reject)=&gt;<span style="color: rgba(0, 0, 0, 1)">{
          setTimeout(() </span>=&gt;<span style="color: rgba(0, 0, 0, 1)"> {
            i</span>++<span style="color: rgba(0, 0, 0, 1)">;
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">3秒后完成 完成的数据</span>
            resolve('完成'+<span style="color: rgba(0, 0, 0, 1)">i);
          }, </span>10000<span style="color: rgba(0, 0, 0, 1)">);
        })
      }
      </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">调用next()方法时传入的值会作为上一个yield表达式的返回值</span>
      <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">创建一个生成器函数 调用时返回一个生成器</span>
      <span style="color: rgba(0, 0, 255, 1)">function</span>*<span style="color: rgba(0, 0, 0, 1)"> task(){
        console.log(</span>"开始获取数据"<span style="color: rgba(0, 0, 0, 1)">);
        let data </span>=<span style="color: rgba(0, 0, 0, 1)"> yield asyncData();
        console.log(</span>'获取到的数据'<span style="color: rgba(0, 0, 0, 1)">,data);
        data </span>=<span style="color: rgba(0, 0, 0, 1)"> yield asyncData();
        console.log(</span>"又获取到了数据"<span style="color: rgba(0, 0, 0, 1)">,data);
        data </span>= yield 1<span style="color: rgba(0, 0, 0, 1)">;
        console.log(</span>'又获取到了数据'<span style="color: rgba(0, 0, 0, 1)">,data);
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> '结束'<span style="color: rgba(0, 0, 0, 1)">;
      }
      </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">没封装之前的写法</span>
      <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">function run(createGenerator){
        const generator = createGenerator();
        let res = generator.next();
        function next(){
          if(!res.done){
            console.log(res);
            const value = res.value;
            if(typeof value.then === 'function'){
              value.then((data)=&gt;{
                res = generator.next(data);
                next();
              });
            }else{
              res = generator.next(value);
              next();
            }
          }
        }
        next();
      }</span><span style="color: rgba(0, 128, 0, 1)">*/</span>

      <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">封装后的写法</span>
      <span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> run(createGenerator){
        const generator </span>=<span style="color: rgba(0, 0, 0, 1)"> createGenerator();
        console.log(generator);
        next();

        </span><span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> next(nextValue){
          const res </span>=<span style="color: rgba(0, 0, 0, 1)"> generator.next(nextValue);
          </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)">(res.done){
            console.log(</span>'生成器迭代结束'<span style="color: rgba(0, 0, 0, 1)">);
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
          }
          const value </span>=<span style="color: rgba(0, 0, 0, 1)"> res.value;
          </span><span style="color: rgba(0, 0, 255, 1)">if</span>(<span style="color: rgba(0, 0, 255, 1)">typeof</span> value.then === 'function'<span style="color: rgba(0, 0, 0, 1)">){
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">如果返回的是promise  将promise完成时的数据作为参数</span>
            <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">作为上一次yield表达式的返回值</span>
            value.then((data)=&gt;<span style="color: rgba(0, 0, 0, 1)">{
              </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> next(data)
            })
          }</span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">{
            console.log(</span>'走这里了'<span style="color: rgba(0, 0, 0, 1)">)
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">将上一次迭代获取到的value的值作为参数 传递给上一次yield表达式的返回值</span>
<span style="color: rgba(0, 0, 0, 1)">            next(res.value);
          }
        }
      }

      run(task);</span></pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">function</span>*<span style="color: rgba(0, 0, 0, 1)"> g2(){
        console.log(</span>'g2函数体-运行'<span style="color: rgba(0, 0, 0, 1)">);
        let res </span>= yield 'g1'<span style="color: rgba(0, 0, 0, 1)">;
        console.log(</span>'g1运行'<span style="color: rgba(0, 0, 0, 1)">);
        res </span>= yield 'g2'<span style="color: rgba(0, 0, 0, 1)">;
        console.log(</span>'g2运行'<span style="color: rgba(0, 0, 0, 1)">)
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> 123<span style="color: rgba(0, 0, 0, 1)">;
      }

      </span><span style="color: rgba(0, 0, 255, 1)">function</span>*<span style="color: rgba(0, 0, 0, 1)"> createGenerator(){
          console.log(</span>'函数体-开始'<span style="color: rgba(0, 0, 0, 1)">)
          let res </span>= yield 1; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">1作为 本次迭代的值 {value:1,done:false}</span>
          console.log('函数体-运行1'<span style="color: rgba(0, 0, 0, 1)">,res);
          res </span>= yield*<span style="color: rgba(0, 0, 0, 1)"> g2();
          console.log(</span>'函数体-g2'<span style="color: rgba(0, 0, 0, 1)">,res);
          res </span>= yield 2<span style="color: rgba(0, 0, 0, 1)">;
          console.log(</span>'函数体-运行2'<span style="color: rgba(0, 0, 0, 1)">,res);
          res </span>= yield 3<span style="color: rgba(0, 0, 0, 1)">;
          console.log(</span>'函数体-运行3'<span style="color: rgba(0, 0, 0, 1)">,res);
          </span><span style="color: rgba(0, 0, 255, 1)">return</span> '结束'<span style="color: rgba(0, 0, 0, 1)">
      }
      </span><span style="color: rgba(0, 0, 255, 1)">var</span> generator = createGenerator();</pre>
</div>
<p><img src="https://img2024.cnblogs.com/blog/795484/202505/795484-20250523135738484-1988320041.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<blockquote>
<h3>总结：</h3>
<p><code>生成器的核心价值在于其‌延迟执行与状态保持能力‌，适用于：</code></p>
<ul>
<li>需要按需生成数据的迭代场景（如分页、树遍历）</li>
<li>资源敏感型任务（如大文件处理、流式传输）</li>
<li>复杂流程控制（如多步骤交互、状态机）</li>
<li>尽管 async/await 更常用于异步编程，但生成器在定制化迭代器协议、性能优化框架中仍不可替代</li>
</ul>
</blockquote>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.874457434349537" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-23 14:04">2025-05-23 14:03</span>&nbsp;
<a href="https://www.cnblogs.com/nianzhilian">飞奔的龟龟</a>&nbsp;
阅读(<span id="post_view_count">153</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18892950);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18892950', targetLink: 'https://www.cnblogs.com/nianzhilian/p/18892950', title: '迭代、迭代器、生成器的前世今生' })">举报</a>
</div>
        