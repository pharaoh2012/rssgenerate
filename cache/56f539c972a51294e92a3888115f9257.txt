
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zengzuo613/p/18931527" title="发布于 2025-06-22 18:14">
    <span role="heading" aria-level="2">MCP 通信消息格式之 JSON-RPC 2.0 协议</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-22 18:14">2025-06-22 18:14</span>&nbsp;
<a href="https://www.cnblogs.com/zengzuo613">曾左</a>&nbsp;
阅读(<span id="post_view_count">38</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18931527);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18931527', targetLink: 'https://www.cnblogs.com/zengzuo613/p/18931527', title: 'MCP 通信消息格式之 JSON-RPC 2.0 协议' })">举报</a>
</small>
    <div class="entry">
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景介绍">一、背景介绍</h2>
<p>MCP 中 Client 与  Server 间使用 JSON-RPC 2.0 作为通信消息格式。JSON-RPC 是 RPC（远程过程调用）的一种具体实现，RPC 是一种通信范式，其核心目标是屏蔽网络细节，使远程调用如同本地调用般简单，并可基于多种底层网络协议（如 TCP/HTTP）实现。常见的 RPC 框架有 gRPC、Dubbo 和 Thrift。</p>
<p>JSON-RPC 2.0 是一种使用 JSON 格式的轻量级远程过程调用 (RPC) 协议，与 RPC 有以下区别：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>RPC（通用）</th>
<th>JSON-RPC</th>
</tr>
</thead>
<tbody>
<tr>
<td>协议类型</td>
<td>抽象概念，有多种实现</td>
<td>RPC 的一种具体实现</td>
</tr>
<tr>
<td>数据格式</td>
<td>二进制（如 Protobuf）、文本等</td>
<td>默认使用 JSON</td>
</tr>
<tr>
<td>传输协议</td>
<td>任意（TCP/HTTP/UDP 等）</td>
<td>通常基于 HTTP/HTTPS 或 WebSocket</td>
</tr>
<tr>
<td>跨语言兼容性</td>
<td>依赖具体实现（如 gRPC）</td>
<td>天然支持（JSON 是通用标准）</td>
</tr>
<tr>
<td>性能</td>
<td>二进制协议通常更高</td>
<td>文本协议，性能较低</td>
</tr>
<tr>
<td>使用场景</td>
<td>高性能内部服务（如 gRPC）</td>
<td>Web API、前后端交互、脚本语言</td>
</tr>
</tbody>
</table>
<h2 id="二消息类型">二、消息类型</h2>
<h3 id="1-请求request">1. 请求（Request）</h3>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "方法名",
  "params": {"参数名": "值"} | ["值 1", "值 2"],  // 对象或数组
  "id": "唯一ID"                             // 可选（通知请求可省略）
}
</code></pre>
<p><code>jsonrpc</code> : 必须为 <code>"2.0"</code>。</p>
<p><code>method</code>: 调用的方法名（字符串）。</p>
<p><code>params</code>: 参数（可省略），支持对象（命名参数）或数组（位置参数）。</p>
<p><code>id</code>: 请求标识符。</p>
<h3 id="2-响应response">2. 响应（Response）</h3>
<p>成功响应：</p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "返回值",
  "id": "对应请求 ID"
}
</code></pre>
<p>错误响应：</p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "error": {
    "code": -32601,
    "message": "Method not found",
    "data": "额外错误信息"  // 可选
  },
  "id": "对应请求 ID"      // 若请求无 ID，则为 null
}
</code></pre>
<p>标准错误码：</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-32700</td>
<td>Parse error</td>
<td>JSON 解析失败</td>
</tr>
<tr>
<td>-32600</td>
<td>Invalid Request</td>
<td>请求格式不符合规范</td>
</tr>
<tr>
<td>-32601</td>
<td>Method not found</td>
<td>方法不存在</td>
</tr>
<tr>
<td>-32602</td>
<td>Invalid params</td>
<td>参数无效</td>
</tr>
<tr>
<td>-32603</td>
<td>Internal error</td>
<td>服务端内部错误</td>
</tr>
<tr>
<td>-32000</td>
<td>Server error（自定义）</td>
<td>业务级错误（范围：-32000 至 -32099）</td>
</tr>
</tbody>
</table>
<h3 id="3-通知notification">3. 通知（Notification）</h3>
<p>无 id 的请求，客户端不返回响应：</p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "log_event",
  "params": {"event": "user_login"}
}
</code></pre>
<h2 id="三主要特点">三、主要特点</h2>
<p>（1）简单轻量：协议设计简洁，消息格式简单。</p>
<p>（2）语言无关：基于 JSON，几乎所有编程语言都支持。</p>
<p>（3）传输层无关：可在 HTTP、WebSocket、TCP 等多种传输协议上使用。</p>
<p>（4）支持通知（不需要响应的请求）。</p>
<p>（5）支持批量请求。</p>
<h2 id="四使用建议">四、使用建议</h2>
<h3 id="1-请求与响应设计">1. 请求与响应设计</h3>
<p>（1）严格校验 jsonrpc 字段：确保值为 "2.0"，避免版本混淆。</p>
<p>（2）明确参数类型：在文档中声明 params 是对象还是数组。</p>
<p>（3）处理通知请求：无 id 的请求不返回响应，节省带宽。</p>
<h3 id="2-错误处理">2. 错误处理</h3>
<p>（1）标准化错误信息：错误响应中，data 字段可酌情附加调试详情（如堆栈跟踪），但要注意信息安全。</p>
<p>（2）自定义错误码：业务错误使用 -32000 到 -32099 范围。</p>
<h3 id="3-安全性">3. 安全性</h3>
<p>（1）字段过滤：避免在响应中返回敏感数据（如密码）。</p>
<p>（2）传输加密：使用 HTTPS 防止中间人攻击。</p>
<p>（3）限流与鉴权：通过 HTTP Headers（如 Authorization）实现身份验证。</p>
<h3 id="4-性能优化">4. 性能优化</h3>
<p>（1）批量请求（Batch）：支持单次传输多个请求（减少 HTTP 开销）：</p>
<pre><code class="language-json">[
  {"jsonrpc": "2.0", "method": "sum", "params": [1, 2], "id": "1"},
  {"jsonrpc": "2.0", "method": "notify", "params": ["event"]}
]
</code></pre>
<p>（2）压缩数据：启用 Gzip 压缩 JSON 内容。</p>
<h2 id="五常见问题">五、常见问题</h2>
<h3 id="1-批量请求是否必须按顺序返回响应">1. 批量请求是否必须按顺序返回响应？</h3>
<p>规范未强制要求顺序，但建议保持请求与响应顺序一致。</p>
<h3 id="2-json-rpc-是否可以作为-restful-通信消息格式">2. JSON-RPC 是否可以作为 RESTful 通信消息格式？</h3>
<p>JSON-RPC 和 RESTful 是两种不同的 API 设计风格，虽都可基于 HTTP，但设计理念与适用场景差异显著，具体如下：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>JSON-RPC</th>
<th>RESTful</th>
</tr>
</thead>
<tbody>
<tr>
<td>设计哲学</td>
<td>基于动作（Action）的远程调用</td>
<td>基于资源（Resource）的状态操作</td>
</tr>
<tr>
<td>HTTP 方法使用</td>
<td>通常只用 <code>POST</code>（所有请求发到同一端点）</td>
<td>使用 <code>GET/POST/PUT/DELETE</code> 等</td>
</tr>
<tr>
<td>URL 设计</td>
<td>单一端点（如 <code>/api/jsonrpc</code>）</td>
<td>资源路径（如 <code>/users/{id}</code>）</td>
</tr>
<tr>
<td>数据格式</td>
<td>固定 JSON 结构（含 <code>method</code> 和 <code>params</code>）</td>
<td>灵活（JSON/XML，通常无固定结构约束）</td>
</tr>
<tr>
<td>典型用例</td>
<td>复杂业务逻辑（如计算、事务）</td>
<td>CRUD 操作（如用户管理）</td>
</tr>
</tbody>
</table>
<p>以删除一个用户为例：</p>
<p>JSON-RPC 需向统一端点（URL）发送如下消息格式：</p>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "deleteUser",
  "params": {"id": 123},
  "id": 1
}
</code></pre>
<p>RESTful 则只需发起一个 DELETE /users/123 请求。</p>
<p>综上所述，笔者认为 JSON-RPC 不适合作为 RESTful 的通信消息格式，原因有二：其一，调用方式不同，JSON-RPC 通过 method 参数调用指定方法，RESTful API 则依赖 HTTP 方法（如 GET/POST）和 URL 路径标识调用方法；其二，支持的协议范围不同，REST API 仅适配 HTTP 协议，JSON-RPC 支持常见网络协议，如 HTTP、TCP 等。</p>

</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="zengzuo613" blog-id="714768" post-id="18931527"></vc:categories-tags>
    </ul>
