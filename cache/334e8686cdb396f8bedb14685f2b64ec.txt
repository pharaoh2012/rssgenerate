<!----> <meta itemprop="headline" content="前端表格1000w行数据流畅渲染的秘密"> <meta itemprop="keywords" content="前端,面试,React.js"> <meta itemprop="datePublished" content="2025-01-03T01:26:58.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小小续"> <meta itemprop="url" content="https://juejin.cn/user/1922414068118973"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-0faec0bc="">
            前端表格1000w行数据流畅渲染的秘密
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-0faec0bc=""><div class="author-info-box" data-v-0faec0bc=""><div class="author-name" data-v-0faec0bc=""><a href="/user/1922414068118973/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-0faec0bc=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    小小续
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-0faec0bc=""><time datetime="2025-01-03T01:26:58.000Z" title="Fri Jan 03 2025 01:26:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-0faec0bc="">
                    2025-01-03
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-0faec0bc=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-0faec0bc=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-0faec0bc=""></circle></svg> <span class="views-count" data-v-0faec0bc="">
                    5,424
                  </span> <span class="read-time" data-v-0faec0bc=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-0faec0bc=""><rect width="16" height="16" fill="none" data-v-0faec0bc=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-0faec0bc=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-0faec0bc=""></path></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-0faec0bc=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-0faec0bc=""><div class="article-viewer markdown-body cache result"><p>canvas 优化细节白板方案，大部分同学第一反应，那肯定是 canvas 啊，没错，但是，可以很直接地告诉大家，canvas方案在大家平常小数据量的可视化场景，没太大问题。</p>
<p>不过如果是大量数据的渲染，canvas 瓶颈也会凸显，为了进一步优化白板性能，还需要进行深入底层优化
表格开发，可能是大家平常开发过程中最常见的场景，表格的优化我们可以给出以下历程:</p>
<ol>
<li>用库</li>
<li>初级:table dom</li>
<li>中级:虚拟表格</li>
<li>高级:canvas table</li>
<li>专家:canvas + tile 技术</li>
<li>高级专家:skia + Webassembly</li>
<li>结合给定的五个不同层级的实现方案，以下是详细说明如何在不同层次上实现高效的表格渲染方案:</li>
</ol>
<h2 data-id="heading-0">一、初级: table Dom</h2>
<p>这是最基础的实现方式，直接使用 HTML 的table元素来渲染表格。</p>
<p><strong>实现方案</strong></p>
<ul>
<li>简单实现:直接使用 HTML 和 JavaScript 渲染表格,</li>
<li>适用场景:适用于数据量较小的场景，当行数和列数有限时，直接使用 DOM 元素处理方便目直观。</li>
</ul>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Basic Table<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-tag">table</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
            <span class="hljs-attribute">border-collapse</span>: collapse;
        }
        <span class="hljs-selector-tag">th</span>, <span class="hljs-selector-tag">td</span> {
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span>;
            <span class="hljs-attribute">text-align</span>: left;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"data-table"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>ID<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Age<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- Rows will be inserted here by JavaScript --&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">const</span> tableBody = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#data-table tbody'</span>);
        <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">100</span> }, <span class="hljs-function">(<span class="hljs-params">_, id</span>) =&gt;</span> ({
            id,
            <span class="hljs-attr">name</span>: <span class="hljs-string">`Name <span class="hljs-subst">${id}</span>`</span>,
            <span class="hljs-attr">age</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>)
        }));

        data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">row</span> =&gt;</span> {
            <span class="hljs-keyword">const</span> tr = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'tr'</span>);
            tr.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`&lt;td&gt;<span class="hljs-subst">${row.id}</span>&lt;/td&gt;&lt;td&gt;<span class="hljs-subst">${row.name}</span>&lt;/td&gt;&lt;td&gt;<span class="hljs-subst">${row.age}</span>&lt;/td&gt;`</span>;
            tableBody.<span class="hljs-title function_">appendChild</span>(tr);
        });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>

</code></pre>
<h2 data-id="heading-1">二、中级: 虚拟表格</h2>
<p>使用虚拟化技术来渲染表格，只有视口中的行和列才会被染。</p>
<p><strong>实现方案</strong></p>
<ul>
<li>库选择:使用 react-window或react-virtualized 来实现虚拟化表格。</li>
<li>适用场景:适用于数据量较大但需要浏览的行数有限的情况，通过虚拟化技术减少染的 DOM 数量。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">FixedSizeList</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">List</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-window'</span>;

<span class="hljs-keyword">const</span> data = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">10000</span> }, <span class="hljs-function">(<span class="hljs-params">_, id</span>) =&gt;</span> ({
   id,
   <span class="hljs-attr">name</span>: <span class="hljs-string">`Name <span class="hljs-subst">${id}</span>`</span>,
   <span class="hljs-attr">age</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>)
}));

<span class="hljs-keyword">const</span> <span class="hljs-title function_">Row</span> = (<span class="hljs-params">{ index, style }</span>) =&gt; (
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>&gt;</span>
       {data[index].id} - {data[index].name} - {data[index].age}
   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">VirtualizedTable</span> = (<span class="hljs-params"></span>) =&gt; (
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List</span>
       <span class="hljs-attr">height</span>=<span class="hljs-string">{600}</span>
       <span class="hljs-attr">itemCount</span>=<span class="hljs-string">{data.length}</span>
       <span class="hljs-attr">itemSize</span>=<span class="hljs-string">{35}</span>
       <span class="hljs-attr">width</span>=<span class="hljs-string">{300}</span>
   &gt;</span>
       {Row}
   <span class="hljs-tag">&lt;/<span class="hljs-name">List</span>&gt;</span></span>
);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">VirtualizedTable</span>;
</code></pre>
<h2 data-id="heading-2">三、高级: canvas table</h2>
<p>使用 HTML5 Canvas 来绘制表格内容，選免大量 DOM 操作，提高渲染性能</p>
<p><strong>实现方案</strong></p>
<ul>
<li>使用 Canvas API: 通过 Canvas API 手动绘制表格的每个单元格。</li>
<li>适用场景:适用于需要更高效渲染和更灵活绘制能力的场景。</li>
</ul>
<pre><code class="hljs language-ini" lang="ini">import React, { useRef, useEffect } from 'react'<span class="hljs-comment">;</span>

const <span class="hljs-attr">CanvasTable</span> = ({ data }) =&gt; {
 const <span class="hljs-attr">canvasRef</span> = useRef(null)<span class="hljs-comment">;</span>

 useEffect(() =&gt; {
   const <span class="hljs-attr">canvas</span> = canvasRef.current<span class="hljs-comment">;</span>
   const <span class="hljs-attr">ctx</span> = canvas.getContext(<span class="hljs-string">'2d'</span>)<span class="hljs-comment">;</span>
   const <span class="hljs-attr">rowHeight</span> = <span class="hljs-number">20</span><span class="hljs-comment">;</span>
   const <span class="hljs-attr">columnWidths</span> = [<span class="hljs-number">50</span>, <span class="hljs-number">150</span>, <span class="hljs-number">50</span>]<span class="hljs-comment">;</span>

   <span class="hljs-attr">canvas.height</span> = data.length * rowHeight<span class="hljs-comment">;</span>
   <span class="hljs-attr">canvas.width</span> = columnWidths.reduce((a, b) =&gt; a + b, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>

   data.forEach((row, rowIndex) =&gt; {
     const <span class="hljs-attr">y</span> = rowIndex * rowHeight<span class="hljs-comment">;</span>

     ctx.fillText(row.id, 0, y + rowHeight / 2)<span class="hljs-comment">;</span>
     ctx.fillText(row.name, columnWidths<span class="hljs-section">[0]</span>, y + rowHeight / 2)<span class="hljs-comment">;</span>
     ctx.fillText(row.age, columnWidths<span class="hljs-section">[0]</span> + columnWidths<span class="hljs-section">[1]</span>, y + rowHeight / 2)<span class="hljs-comment">;</span>
     ctx.strokeRect(0, y, canvas.width, rowHeight)<span class="hljs-comment">;</span>
   })<span class="hljs-comment">;</span>
 }, <span class="hljs-section">[data]</span>)<span class="hljs-comment">;</span>

 return &lt;canvas <span class="hljs-attr">ref</span>={canvasRef} /&gt;<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">data</span> = Array.from({ length: <span class="hljs-number">10000</span> }, (_, id) =&gt; ({
 id,
 name: `Name ${id}`,
 age: Math.floor(Math.random() * 100),
}))<span class="hljs-comment">;</span>

export default function App() {
 return &lt;CanvasTable <span class="hljs-attr">data</span>={data} /&gt;<span class="hljs-comment">;</span>
}

</code></pre>
<h2 data-id="heading-3">四、专家: canvas + title</h2>
<p>通过将表格划分为多个 tile(瓷砖)区域，只染当前视口及其周围的 tile，提高渲染性能和内存使用效率。</p>
<p><strong>实现方案</strong></p>
<ul>
<li>Tile 分区:将表格划分为多个 tie 区域，每个 tie 只包含一定数量的单元格。</li>
<li>懒加载和预加载:仅在需要时加载和渲染特定的 tile，同时预加载用户视口附近的 tile。</li>
</ul>
<pre><code class="hljs language-ini" lang="ini">import React, { useRef, useEffect, useState } from 'react'<span class="hljs-comment">;</span>

const <span class="hljs-attr">tileSize</span> = <span class="hljs-number">100</span><span class="hljs-comment">; // 每个 tile 的宽度和高度</span>

const <span class="hljs-attr">CanvasTileTable</span> = ({ data }) =&gt; {
 const <span class="hljs-attr">canvasRef</span> = useRef(null)<span class="hljs-comment">;</span>
 const <span class="hljs-section">[visibleTiles, setVisibleTiles]</span> = useState(<span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>

 useEffect(() =&gt; {
   const <span class="hljs-attr">canvas</span> = canvasRef.current<span class="hljs-comment">;</span>
   const <span class="hljs-attr">ctx</span> = canvas.getContext(<span class="hljs-string">'2d'</span>)<span class="hljs-comment">;</span>
   const <span class="hljs-attr">rowHeight</span> = <span class="hljs-number">20</span><span class="hljs-comment">;</span>
   const <span class="hljs-attr">columnWidths</span> = [<span class="hljs-number">50</span>, <span class="hljs-number">150</span>, <span class="hljs-number">50</span>]<span class="hljs-comment">;</span>

   <span class="hljs-attr">canvas.height</span> = window.innerHeight<span class="hljs-comment">;</span>
   <span class="hljs-attr">canvas.width</span> = columnWidths.reduce((a, b) =&gt; a + b, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>

   const <span class="hljs-attr">updateVisibleTiles</span> = () =&gt; {
     const <span class="hljs-attr">scrollTop</span> = window.scrollY<span class="hljs-comment">;</span>
     const <span class="hljs-attr">visibleStart</span> = Math.floor(scrollTop / (tileSize + rowHeight))<span class="hljs-comment">;</span>
     const <span class="hljs-attr">visibleEnd</span> = visibleStart + Math.ceil(canvas.height / (tileSize + rowHeight))<span class="hljs-comment">;</span>
     const <span class="hljs-attr">tiles</span> = []<span class="hljs-comment">;</span>

     for (let <span class="hljs-attr">i</span> = visibleStart<span class="hljs-comment">; i &lt;= visibleEnd; i++) {</span>
       tiles.push(i)<span class="hljs-comment">;</span>
     }

     setVisibleTiles(tiles)<span class="hljs-comment">;</span>
   }<span class="hljs-comment">;</span>

   window.addEventListener('scroll', updateVisibleTiles)<span class="hljs-comment">;</span>
   updateVisibleTiles()<span class="hljs-comment">;</span>

   return () =&gt; {
     window.removeEventListener('scroll', updateVisibleTiles)<span class="hljs-comment">;</span>
   }<span class="hljs-comment">;</span>
 }, <span class="hljs-section">[]</span>)<span class="hljs-comment">;</span>

 useEffect(() =&gt; {
   const <span class="hljs-attr">canvas</span> = canvasRef.current<span class="hljs-comment">;</span>
   const <span class="hljs-attr">ctx</span> = canvas.getContext(<span class="hljs-string">'2d'</span>)<span class="hljs-comment">;</span>
   const <span class="hljs-attr">rowHeight</span> = <span class="hljs-number">20</span><span class="hljs-comment">;</span>
   const <span class="hljs-attr">columnWidths</span> = [<span class="hljs-number">50</span>, <span class="hljs-number">150</span>, <span class="hljs-number">50</span>]<span class="hljs-comment">;</span>

   ctx.clearRect(0, 0, canvas.width, canvas.height)<span class="hljs-comment">;</span>

   visibleTiles.forEach((tileIndex) =&gt; {
     const <span class="hljs-attr">startRow</span> = tileIndex * tileSize<span class="hljs-comment">;</span>
     const <span class="hljs-attr">endRow</span> = Math.min(data.length, startRow + tileSize)<span class="hljs-comment">;</span>

     for (let <span class="hljs-attr">rowIndex</span> = startRow<span class="hljs-comment">; rowIndex &lt; endRow; rowIndex++) {</span>
       const <span class="hljs-attr">row</span> = data[rowIndex]<span class="hljs-comment">;</span>
       const <span class="hljs-attr">y</span> = (rowIndex % tileSize) * rowHeight<span class="hljs-comment">;</span>

       ctx.fillText(row.id, 0, y + rowHeight / 2)<span class="hljs-comment">;</span>
       ctx.fillText(row.name, columnWidths<span class="hljs-section">[0]</span>, y + rowHeight / 2)<span class="hljs-comment">;</span>
       ctx.fillText(row.age, columnWidths<span class="hljs-section">[0]</span> + columnWidths<span class="hljs-section">[1]</span>, y + rowHeight / 2)<span class="hljs-comment">;</span>
       ctx.strokeRect(0, y, canvas.width, rowHeight)<span class="hljs-comment">;</span>
     }
   })<span class="hljs-comment">;</span>
 }, <span class="hljs-section">[visibleTiles, data]</span>)<span class="hljs-comment">;</span>

 return &lt;canvas <span class="hljs-attr">ref</span>={canvasRef} /&gt;<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">data</span> = Array.from({ length: <span class="hljs-number">100000</span> }, (_, id) =&gt; ({
 id,
 name: `Name ${id}`,
 age: Math.floor(Math.random() * 100),
}))<span class="hljs-comment">;</span>

export default function App() {
 return &lt;CanvasTileTable <span class="hljs-attr">data</span>={data} /&gt;<span class="hljs-comment">;</span>
}

</code></pre>
<h2 data-id="heading-4">五、高级专家: skia + WebAssembly</h2>
<p>使用 skia 图形库结合 WebAssembly，实现高性能、跨平台的表格渲染。</p>
<p><strong>实现方案</strong></p>
<ul>
<li>skia 图形库:skia 是一个跨平台的 2D 图形库，可以高效地绘制复杂图形。</li>
<li>WebAssembly:通过 webAssembly 将 skia 集成到 Web 应用中，提升图形渲染性能.</li>
</ul>
<p><strong>示例代码</strong></p>
<p>由于 skia 和 WebAssembly 的集成涉及较为复杂的编译和绑定过程，以下提供的是一种基本思路:</p>
<p>1.准备 Skia 和 WebAssembly 环境：需要编译 skia 库为 WebAssembly 模块，可以使用 emscripten 工具链。</p>
<p>2.编译 Skia:</p>
<ul>
<li>下载并编译 Skia 库，生成 WebAssembly 模块,</li>
<li>详细步骤可以参考 skia 和 Emscripten 官方文档。</li>
</ul>
<p>3.在 React 中使用 Skia:</p>
<ul>
<li>引入编译好的 Skia WebAssembly 模块,</li>
<li>使用 skia 的 API 绘制表格内容。</li>
</ul>
<pre><code class="hljs language-ini" lang="ini">import React, { useRef, useEffect } from "react"<span class="hljs-comment">;</span>
import SkiaCanvas from "@shopify/react-native-skia-web"<span class="hljs-comment">; // 假设使用 Shopify Skia 的 JS 包（需要先安装）</span>

const <span class="hljs-attr">Table</span> = ({ data }) =&gt; {
  const <span class="hljs-attr">canvasRef</span> = useRef(null)<span class="hljs-comment">;</span>

  useEffect(() =&gt; {
    // 加载 Skia 模块
    (async () =&gt; {
      const <span class="hljs-attr">skia</span> = await import(<span class="hljs-string">"canvaskit-wasm"</span>)<span class="hljs-comment">; // 假设 Skia WASM 文件</span>
      const <span class="hljs-attr">CanvasKit</span> = await skia.default()<span class="hljs-comment">;</span>

      const <span class="hljs-attr">canvasElement</span> = canvasRef.current<span class="hljs-comment">;</span>
      const <span class="hljs-attr">surface</span> = CanvasKit.MakeCanvasSurface(canvasElement)<span class="hljs-comment">;</span>

      if (!surface) {
        console.error("Failed to create Skia surface.")<span class="hljs-comment">;</span>
        return<span class="hljs-comment">;</span>
      }

      const <span class="hljs-attr">canvas</span> = surface.getCanvas()<span class="hljs-comment">;</span>

      const <span class="hljs-attr">paint</span> = new CanvasKit.Paint()<span class="hljs-comment">;</span>
      paint.setAntiAlias(true)<span class="hljs-comment">;</span>
      paint.setColor(CanvasKit.Color(0, 0, 0, 1))<span class="hljs-comment">; // 黑色文本</span>

      const <span class="hljs-attr">font</span> = new CanvasKit.Font(
        new CanvasKit.Typeface("Roboto"),
        14 // 字体大小
      )<span class="hljs-comment">;</span>

      // 清除画布
      canvas.clear(CanvasKit.WHITE)<span class="hljs-comment">;</span>

      // 行高
      const <span class="hljs-attr">rowHeight</span> = <span class="hljs-number">30</span><span class="hljs-comment">;</span>

      // 绘制表头
      const <span class="hljs-attr">columnWidths</span> = [<span class="hljs-number">50</span>, <span class="hljs-number">200</span>, <span class="hljs-number">100</span>]<span class="hljs-comment">; // 每列的宽度</span>
      const <span class="hljs-attr">headerTitles</span> = [<span class="hljs-string">"ID"</span>, <span class="hljs-string">"Name"</span>, <span class="hljs-string">"Age"</span>]<span class="hljs-comment">;</span>
      headerTitles.forEach((title, index) =&gt; {
        canvas.drawText(
          title,
          columnWidths.slice(0, index).reduce((a, b) =&gt; a + b, 10), // X 坐标
          rowHeight / 2,
          paint,
          font
        )<span class="hljs-comment">;</span>
      })<span class="hljs-comment">;</span>

      // 绘制表格数据
      data.forEach((row, rowIndex) =&gt; {
        const <span class="hljs-attr">y</span> = rowHeight * (rowIndex + <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
        canvas.drawText(`${row.id}`, 10, y, paint, font)<span class="hljs-comment">;</span>
        canvas.drawText(`${row.name}`, 60, y, paint, font)<span class="hljs-comment">;</span>
        canvas.drawText(`${row.age}`, 260, y, paint, font)<span class="hljs-comment">;</span>
      })<span class="hljs-comment">;</span>

      surface.flush()<span class="hljs-comment">;</span>
    })()<span class="hljs-comment">;</span>
  }, <span class="hljs-section">[data]</span>)<span class="hljs-comment">;</span>

  return (
    &lt;canvas
      <span class="hljs-attr">ref</span>={canvasRef}
      <span class="hljs-attr">width</span>=<span class="hljs-string">"400"</span>
      <span class="hljs-attr">height</span>={data.length * <span class="hljs-number">30</span> + <span class="hljs-number">30</span>} // 根据行数动态调整高度
      <span class="hljs-attr">style</span>={{ border: <span class="hljs-string">"1px solid #ccc"</span> }}
    /&gt;
  )<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

const <span class="hljs-attr">App</span> = () =&gt; {
  const <span class="hljs-attr">data</span> = Array.from({ length: <span class="hljs-number">100</span> }, (_, id) =&gt; ({
    id,
    name: `Name ${id}`,
    age: Math.floor(Math.random() * 100),
  }))<span class="hljs-comment">;</span>

  return (
    &lt;div&gt;
      &lt;h1&gt;Skia Table Renderer&lt;/h1&gt;
      &lt;Table <span class="hljs-attr">data</span>={data} /&gt;
    &lt;/div&gt;
  )<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>

export default App<span class="hljs-comment">;</span>

</code></pre>
<p>另外 skia 这个技术可能很多同学都比较陌生，这个库是 C++ 编写的图形处理库，目前由 Google 公司维护。
其实，浏览器 canvas 底层就是 skia:
<a href="https://link.juejin.cn?target=https%3A%2F%2Fchromium.googlesource.com%2Fchromium%2Fblink%2F%2B%2Frefs%2Fheads%2Fmain%2FSource%2Fcore%2Fhtml%2FHTMLCanvasElement.cpp" target="_blank" title="https://chromium.googlesource.com/chromium/blink/+/refs/heads/main/Source/core/html/HTMLCanvasElement.cpp" ref="nofollow noopener noreferrer">chromium.googlesource.com/chromium/bl…</a></p>
<h2 data-id="heading-5"><strong>六、各种级别数据的性能对比</strong></h2>















































<table><thead><tr><th>方案</th><th>适用数据量</th><th>主要优势</th><th>主要劣势</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Table DOM</strong></td><td>&lt; 1000</td><td>代码简单</td><td>超 1W 数据会卡顿</td><td>小规模静态表格</td></tr><tr><td><strong>虚拟表格</strong></td><td>&lt; 10W</td><td>DOM 负担小，性能提升</td><td>100W 以上仍有性能瓶颈</td><td>中小型数据表</td></tr><tr><td><strong>Canvas Table</strong></td><td>&lt; 100W</td><td>无 DOM 负担，渲染更快</td><td>无法选中文本，交互复杂</td><td>财务、BI 报表</td></tr><tr><td><strong>Canvas + Tile</strong></td><td>&lt; 1000W</td><td>局部渲染，性能极高</td><td>开发成本高</td><td>大型数据系统</td></tr><tr><td><strong>Skia + WASM</strong></td><td>&gt; 1000W</td><td>硬件加速，极致性能</td><td>适用场景少，技术门槛高</td><td>工业级 BI、云计算大数据</td></tr></tbody></table>
<hr>
<h2 data-id="heading-6"><strong>总结</strong></h2>
<ol>
<li><strong>小数据（&lt;10W）</strong> 👉 <code>虚拟表格</code> 是最优解。</li>
<li><strong>中等数据（10W - 100W）</strong> 👉 <code>Canvas Table</code> 方案更适合。</li>
<li><strong>大数据（100W - 1000W）</strong> 👉 <code>Canvas + Tile</code> 技术，提升渲染效率。</li>
<li><strong>超大数据（&gt;1000W）</strong> 👉 <code>Skia + WASM</code> + <code>WebGPU</code>，实现极致优化。</li>
</ol>
<p>如果你的需求是 <strong>1000W 级别的表格</strong>，推荐 <strong>Canvas + Tile 方案</strong>，并结合 <strong>Web Worker</strong> 进行数据处理，确保流畅渲染！</p></div></div>