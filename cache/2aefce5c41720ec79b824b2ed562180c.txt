
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ggtc/p/19052348" title="发布于 2025-08-22 11:24">
    <span role="heading" aria-level="2">为workflow-core扩展外抛事件</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="workflow-core自带事件的局限性">workflow-core自带事件的局限性</h1>
<p>众所周知，workflow-core只能从外向内抛事件<br>
比如在api接口中引发事件，在工作流中等待事件完成</p>
<pre><code class="language-Csharp">//第一步，开启流程
public async Task&lt;IActionResult&gt; Add([FromBody] Dto parm)
{
    //启动一个新的工作流
    //由 Workflow-Core 自动生成（默认是 GUID 格式,唯一标识一个正在运行的工作流实例
    //通过该ID可以控制工作流生命周期
    var workflowId = await _workflowHost.StartWorkflow("xxxFlow", 1, parm);
    return SUCCESS(1);
}

//第二步，审批,引发事件
public async Task&lt;IActionResult&gt; Audit([FromBody] Dto parm)
{
    var modal = parm.Adapt&lt;Dto&gt;().ToUpdate(HttpContext);
    //通知工作流继续执行
    await _workflowHost.PublishEvent(
        "audit",  // 必须与WaitForEvent的事件名称匹配
        parm.WorkflowId,  // 必须与WaitForEvent的事件Key匹配
        parm//提供的数据
    );
    return SUCCESS(1);
}
</code></pre>
<p>但是通常来说，我们在前端调用一个接口，要获得返回数据。比如<code>Add</code>后要刷新界面，看到表格中新添加的一行记录。<br>
然而由于我们缺乏这种手段来从流程中获得反馈，而且是等待式<code>await</code>的反馈。所以<code>Add</code>就直接俄返回了，界面上刷新时，流程可能还没跑到插入数据库那一步，于是界面上也看不到新数据。</p>
<h1 id="事件扩展">事件扩展</h1>
<p>我研究了一天后，利用<code>C#</code>的扩展方法语法，给<code>workflow-core</code>扩展了外抛事件，这样可以在接口中等待流程中某个步骤完成。</p>
<h2 id="设想">设想</h2>
<p>设想调用方法应该这样</p>
<pre><code class="language-Csharp">//第一步，开启流程
public async Task&lt;IActionResult&gt; Add([FromBody] Dto parm)
{
    //启动一个新的工作流
    //由 Workflow-Core 自动生成（默认是 GUID 格式,唯一标识一个正在运行的工作流实例
    //通过该ID可以控制工作流生命周期
    var workflowId = await _workflowHost.StartWorkflow("xxxFlow", 1, parm);
    //等待瞬时事件，SubmitProblemStep步骤执行完成
    var response = await _workflowHost.WaitEvent&lt;Dto&gt;("SubmitStep", workflowId);
    return SUCCESS(response);
}
</code></pre>
<p>而流程中这样引发事件比较优雅</p>
<pre><code class="language-csharp">Action&lt;WaitFor, Dto&gt; outputAction = (edata, data) =&gt; {
    (edata.EventData as Dto).Adapt(data);//保证引用对象data不丢失的情况下更新对象data
};
//这样引发事件
builder
    // 提交记录
    .StartWith&lt;SubmitStep&gt;()
        .Input(step=&gt;step.Entity, data=&gt;data)
        .Output((step,data)=&gt; data=step.Entity)//将WorkflowId赋值给流程，便于WaitFor监听事件
    //RaiseEvent扩展的向外抛事件，嵌入原来fluentApi中引发事件
    //执行到这里，表示记录已在SubmitStep中插入到数据库了
    .RaiseEvent("SubmitStep", data=&gt;data.WorkflowId)
    //workflow-core自带的向内抛事件
    .WaitFor("AuditStep", data =&gt; data.WorkflowId, date =&gt; DateTime.Now)
</code></pre>
<h2 id="实现">实现</h2>
<p>我观察了已有的<code>.Then</code>,<code>.Input</code>这些方法，终于搞清楚实现哪个接口，扩展我们的方法。按照设想，需要暴露两个方法</p>
<ul>
<li><strong><code>RaiseEvent</code> 给内部流程用</strong></li>
<li><strong><code>WaitEvent</code> 给外部接口用</strong></li>
</ul>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// 工作流从内-&gt;外抛出事件扩展
/// &lt;/summary&gt;
public static class WorkFlowEventExtensions
{

    /// &lt;summary&gt;
    /// 瞬时事件集合
    /// &lt;/summary&gt;
    public static List&lt;EventSource&gt; events = new List&lt;EventSource&gt;();

    /// &lt;summary&gt;
    /// 抛出事件扩展
    /// &lt;/summary&gt;
    /// &lt;typeparam name="TData"&gt;&lt;/typeparam&gt;
    /// &lt;typeparam name="TStepBody"&gt;&lt;/typeparam&gt;
    /// &lt;param name="builder"&gt;&lt;/param&gt;
    /// &lt;param name="eventName"&gt;&lt;/param&gt;
    /// &lt;param name="eventKey"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static IStepBuilder&lt;TData, ActionStepBody&gt; RaiseEvent&lt;TData, TStepBody&gt;(this IWorkflowModifier&lt;TData, TStepBody&gt; builder,
        string eventName, Func&lt;TData, string&gt; eventKey) where TStepBody : IStepBody
    {
        return builder
            .Delay(d =&gt; TimeSpan.FromMilliseconds(100))//延迟流程小会儿，等待事件events先添加成功
            .Then(ctx =&gt;
            {
                var key = eventKey.Invoke((TData)ctx.Workflow.Data);
                //释放互斥锁，让WaitEvent继续执行下去
                var mu = events.FirstOrDefault(x =&gt; x.EventName == eventName &amp;&amp; x.EventKey == key);
                if (mu != null)
                {
                    mu.Data = ctx.Workflow.Data;
                    //完成任务
                    mu.Cts.TrySetResult(true);
                }
            });
    }

    /// &lt;summary&gt;
    /// 等待内部事件扩展
    /// &lt;/summary&gt;
    /// &lt;typeparam name="TData"&gt;可以是workflow的实体类，比如IWorkflow&amp;lt;TData&amp;gt;中的TData类&lt;/typeparam&gt;
    /// &lt;param name="host"&gt;&lt;/param&gt;
    /// &lt;param name="eventName"&gt;事件名&lt;/param&gt;
    /// &lt;param name="eventKey"&gt;事件key，一般是WorkflowId,流程实例Id&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static async Task&lt;TData&gt; WaitEvent&lt;TData&gt;(this IWorkflowHost host, string eventName, string eventKey)
    {
        TData data = default(TData);
        //等待任务完成，说明步骤已执行，可以得到需要的数据
        await Task.Run(async () =&gt;
        {
            //向任务集合添加一个任务
            EventSource eventCts = new EventSource
            {
                EventName = eventName,
                EventKey = eventKey,
                Cts = new TaskCompletionSource&lt;bool&gt;(),
            };
            events.Add(eventCts);
            //等待任务完成
            await eventCts.Cts.Task;
            //退出等待
            if (eventCts.Data != null &amp;&amp; eventCts.Data is TData)
            {
                //取得数据
                data = (TData)eventCts.Data;
            }
            events.Remove(eventCts);
        });
        return data;
    }
}

/// &lt;summary&gt;
/// 事件源
/// &lt;/summary&gt;
public class EventSource
{
    public string EventName { get; set; }
    public string EventKey { get; set; }

    /// &lt;summary&gt;
    /// 任务完成源
    /// &lt;/summary&gt;
    public TaskCompletionSource&lt;bool&gt; Cts { get; set; }

    public object Data { get; set; }
}
</code></pre>
<h2 id="结果">结果</h2>
<p>curd了一下，发现当然是达到了想要的结果😁。<br>
其中的关键断点命中如下</p>
<ul>
<li>第一步<br>
<img src="https://img2024.cnblogs.com/blog/1494271/202508/1494271-20250822111952988-593993786.png" alt="image" loading="lazy"></li>
<li>第二步<br>
<img src="https://img2024.cnblogs.com/blog/1494271/202508/1494271-20250822112043336-894782252.png" alt="image" loading="lazy"></li>
<li>第三步<br>
<img src="https://img2024.cnblogs.com/blog/1494271/202508/1494271-20250822112103047-1638813539.png" alt="image" loading="lazy"></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0020833333333333333" data-date-updated="2025-08-22 11:27">2025-08-22 11:24</span>&nbsp;
<a href="https://www.cnblogs.com/ggtc">ggtc</a>&nbsp;
阅读(<span id="post_view_count">47</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19052348);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19052348', targetLink: 'https://www.cnblogs.com/ggtc/p/19052348', title: '为workflow-core扩展外抛事件' })">举报</a>
</div>
        