
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cuzzz/p/18851917" title="发布于 2025-04-28 16:20">
    <span role="heading" aria-level="2">Spring Ioc源码引入：什么是IoC，IoC解决了什么问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="什么是ioc">什么是IoC</h1>
<h2 id="用一个故事举例">用一个故事举例🌰：</h2>
<p>小陈想开一家咖啡店，于是独自创业。找咖啡豆供应商、买咖啡机、招员工，样样都要自己来。开店成本很高。后来，小陈选择加盟连锁咖啡店。总部帮他对接供应商、提供咖啡机，还负责员工培训。小陈只需按流程做好咖啡服务顾客，经营轻松许多。</p>
<p>独立开店时，小陈事事操心，就像没有 IOC，系统耦合度高，难以维护与扩展。加盟后，总部统一管理资源，小陈专注核心业务，如同引入 IOC，降低耦合度，经营变得高效。<br>
<img src="https://img2024.cnblogs.com/blog/2605549/202504/2605549-20250428162026194-785440749.png" alt="" loading="lazy"></p>
<p>上面的故事你可能还无法对应到程序开发场景中，下面我们进行Java代码模拟</p>
<h2 id="用java代码模拟">用Java代码模拟：</h2>
<ol>
<li>没有IOC</li>
</ol>
<p>如下可以看到构造一个咖啡店，需要依赖服务员、清洁工、咖啡豆供应商、以及咖啡机</p>
<p>所以，当我们需要开一个咖啡店的时候，需要自己处理好这些依赖，对应到下面代码，我们自己找到合适的服务员、清洁工、咖啡豆供应商、以及咖啡机，然后开店：</p>
<pre><code class="language-Java">public class CoffeeShop {
    // 服务员
    private Waiter waiter;
    // 清洁工
    private Cleaner cleaner;
    // 咖啡豆供应商
    private CoffeeBeansSupplier coffeeBeansSupplier;
    // 咖啡机
    private CoffeeMachine coffeeMachine;
    public CoffeeShop(Waiter waiter,
                      Cleaner cleaner,
                      CoffeeBeansSupplier coffeeBeansSupplier,
                      CoffeeMachine coffeeMachine) {
        this.waiter = waiter;
        this.cleaner = cleaner;
        this.coffeeBeansSupplier = coffeeBeansSupplier;
        this.coffeeMachine = coffeeMachine;
    }
    public void saleCoffee() {

    }
}
</code></pre>
<pre><code class="language-Java">public class BootStrap {

    public static void main(String[] args) {

        // 我们自己找到合适的服务员
        Waiter waiter = null;
        // 我们自己找到合适的清洁工
        Cleaner cleaner = null;
        // 我们自己找到合适的咖啡供应商
        CoffeeBeansSupplier coffeeBeansSupplier = null;
        // 我们自己找到合适的咖啡机
        CoffeeMachine coffeeMachine = null;
        // 开店，构造自己的咖啡店
        CoffeeShop cacheShop = new CoffeeShop(waiter, cleaner, coffeeBeansSupplier, coffeeMachine);

        // 开始售卖咖啡
        cacheShop.saleCoffee();
    }
}
</code></pre>
<ol>
<li>具备IOC（以SpringBoot 为例）</li>
</ol>
<p>首先我们使用Autowired注解来描述CoffeeShop依赖服务员、清洁工、咖啡豆供应商、以及咖啡机</p>
<pre><code class="language-Java">public class CoffeeShop {

    // 表明我们需要服务员
    @Autowired
    private Waiter waiter;
    // 表明我们需要清洁工
    @Autowired
    private Cleaner cleaner;
    // 表明我们需要咖啡供应
    @Autowired
    private CoffeeBeansSupplier coffeeBeansSupplier;
    // 表明我们需要咖啡机器
    @Autowired
    private CoffeeMachine coffeeMachine;

    public void saleCoffee() {

    }
}
</code></pre>
<pre><code class="language-Java">@SpringBootApplication
public class BootStrap {

    public static void main(String[] args) {
        // ctx就如同总部
        ConfigurableApplicationContext ctx = SpringApplication.run(BootStrap.class, args);
        
        // ctx.getBean就如同总部处理好各种依赖（服务员、清洁工、咖啡豆供应商、以及咖啡机）
       
        CoffeeShop shop = ctx.getBean(CoffeeShop.class);
        
         // 我们可以直接进行开店
        shop.saleCoffee();
    }
}
</code></pre>
<h2 id="再理解ioc">再理解IoC：</h2>
<p>IOC的全称是Inversion of Control，即控制反转。控制反转，从字面理解，就是控制权的反转。</p>
<ul>
<li>
<p>没有IOC：传统的程序流程是由开发者自己控制的，比如对象A需要对象B，那么A会直接创建B或者通过工厂类获取B的实例。这种情况下，控制权在A手里</p>
</li>
<li>
<p>有了IOC：而IoC则是将这种控制权交给外部容器或框架，由外部来管理对象的创建和依赖关系。比如，通过依赖注入，对象A不需要自己创建B，而是由外部容器将B注入到A中。这样，控制权就从A转移到了容器，这就是所谓的反转。</p>
</li>
</ul>
<p>不同的理解：有的人也认为是从程序员手里，转移到IOC容器</p>
<p>结合上面的例子：</p>
<ul>
<li>
<p>没有IOC：咖啡店需要的各种依赖，需要小陈自己处理，自己找咖啡豆供应商等等，然后开店</p>
</li>
<li>
<p>有了IOC：咖啡店的所有配置，由总部这个容器来统一安排</p>
</li>
</ul>
<h1 id="ioc解决了什么问题">IoC解决了什么问题</h1>
<p>IOC（控制反转）主要解决对象间耦合度过高的问题。在传统编程中，对象直接通过new关键字创建依赖对象，导致代码高度耦合，难以维护和扩展。IOC将对象的创建、依赖管理和生命周期交给外部容器，从而解耦组件。</p>
<p>在上面场景中，总部就是我们的IOC容器，它管理了众多不同的咖啡供应商，咖啡机，可以根据你开店的需求，为你的咖啡店进行装配。</p>
<ol>
<li>那么现在思考一下如何实现IOC呢？</li>
</ol>
<p>IOC容器需要给CoffeeShop自动的填充依赖——依赖注入（Dependency Injection, DI）</p>
<ol>
<li>
<p>何为依赖：</p>
<p>如果一个对象A缺少另外一个对象B那么将无法工作（方法不可用）那么我们可以说，A依赖B</p>
</li>
</ol>
<p>那么如何实现依赖注入呢？</p>
<h1 id="如何实现ioc--or--di">如何实现IoC  or  DI</h1>
<h2 id="31-如何描述依赖">3.1 如何描述依赖</h2>
<p>首先需要清楚如何描述依赖</p>
<p>在Java中一般有三种方式：</p>
<ol>
<li>
<p>字段+注解<br>
如下面代码中的waiter，标注@Autowired说明这个字段需要进行依赖注入</p>
</li>
<li>
<p>构造器<br>
如下面的构造方法，每一个方法参数都可以视为CoffeeShop在描述自己依赖哪些外部组件</p>
</li>
<li>
<p>setter方法</p>
</li>
</ol>
<p>如下面的setCleaner，同样是实验@Autowired来说明自己依赖Cleaner</p>
<pre><code class="language-Java">public class CoffeeShop {
    @Autowired //字段+注解
    private Waiter waiter;

    private Cleaner cleaner;
    private CoffeeBeansSupplier coffeeBeansSupplier;
    private CoffeeMachine coffeeMachine;
    
    // 构造器
    public CoffeeShop(Waiter waiter,
                      Cleaner cleaner,
                      CoffeeBeansSupplier coffeeBeansSupplier,
                      CoffeeMachine coffeeMachine) {
        this.waiter = waiter;
        this.cleaner = cleaner;
        this.coffeeBeansSupplier = coffeeBeansSupplier;
        this.coffeeMachine = coffeeMachine;
    }

    @Autowired // setter方法
    public void setCleaner(Cleaner cleaner) {
        this.cleaner = cleaner;
    }
}
</code></pre>
<p>当然Spring还可以使用注解和工厂方法，这里为了方便粉丝理解，不做过多扩展。</p>
<h2 id="32-如何进行依赖注入">3.2 如何进行依赖注入</h2>
<p>如上，我们完成了描述依赖的过程，那么如何进行依赖注入呢？</p>
<p>在java一般来说有两种方式：反射和生成代码</p>
<ol>
<li>
<p>反射：<br>
java提供的反射，允许程序在 运行时 动态地获取类的信息（如类名、方法、字段、注解等），并能直接操作类或对象（如创建实例、调用方法、访问私有字段）</p>
</li>
<li>
<p>反射调用方法：可以用于实现基于构造器和setter方法的依赖注入，将依赖项作为参数进行传入，然后反射调用方法即可</p>
</li>
<li>
<p>反射访问字段：可以用于实现基于字段的依赖注入，找到匹配要求的对象，反射为字段赋值即可</p>
</li>
<li>
<p>生成代码：</p>
<p>例如 Google 维护Dagger 2 ，会在编译时依赖注入框架，直接通过代码生成实现依赖注入，无需反射或动态代理，启动性能更佳。生成代码的方式在Go语言中运用广泛，主要是Go提供的反射能力没有java那么强大，加上Go强调云原生，对部署速度有较高要求</p>
</li>
</ol>
<p>其中Spring Ioc使用的是反射</p>
<h1 id="spring-ioc源码学习引入">Spring Ioc源码学习引入</h1>
<h2 id="每个-spring-开发者都踩过的坑">每个 Spring 开发者都踩过的「坑」</h2>
<hr>
<h2 id="为什么要啃-spring-ioc-源码">为什么要啃 Spring IoC 源码？</h2>
<ol>
<li>面试「灵魂拷问」高频区</li>
</ol>
<ul>
<li>“Spring 如何解决循环依赖？”</li>
<li>“BeanFactory 和 ApplicationContext 的区别？”</li>
<li>“@Autowired 和 @Resource 注入原理有何不同？”<br>
绝大部分 Java 高级岗位面试会深挖 Spring 源码实现。 仅靠八股文背诵，难以应对灵活追问。</li>
</ul>
<ol>
<li>日常开发中的「未解之谜」</li>
</ol>
<ul>
<li>为什么 @Transactional 注解有时失效？</li>
<li>如何定制 Bean 的生命周期回调？</li>
<li>配置文件加载的优先级到底怎么定？<br>
源码能让你从「玄学调试」进阶到「精准打击」。</li>
</ul>
<ol>
<li>架构思维跃迁的关键阶梯<br>
Spring 的设计融合了工厂模式、模板方法、策略模式等经典设计模式，其代码是「教科书级」的架构范本。<br>
读源码 = 站在巨人肩上，学习如何设计高扩展、低耦合的系统。</li>
</ol>
<hr>
<h2 id="点击去关注"><strong><a href="https://space.bilibili.com/519702781" target="_blank" rel="noopener nofollow">&gt;&gt;&gt;点击去关注&lt;&lt;&lt;</a></strong></h2>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.33169917683796296" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-28 16:22">2025-04-28 16:20</span>&nbsp;
<a href="https://www.cnblogs.com/cuzzz">Cuzzz</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18851917);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18851917', targetLink: 'https://www.cnblogs.com/cuzzz/p/18851917', title: 'Spring Ioc源码引入：什么是IoC，IoC解决了什么问题' })">举报</a>
</div>
        