
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/WoodJim/p/18804801" title="发布于 2025-04-01 19:52">
    <span role="heading" aria-level="2">白话kotlin协程</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文主要介绍了Kotlin协程及其相关概念，包括协程的定义、使用、底层实现原理，以及基于协程的Flow和Channel的特性、应用场景以及底层原理
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>文章同步发布于公众号：移动开发那些事<a href="https://mp.weixin.qq.com/s/gWnPR67z-hITHqkGu9h0xA" target="_blank" rel="noopener nofollow">白话kotlin协程</a></p>
<h2 id="1-什么是协程">1 什么是协程</h2>
<p>Kotlin协程(<code>Coroutine</code>)是一种轻量级的线程管理框架，允许开发者以更简洁，更高效的方式处理异步操作，避免回调地狱和线程阻塞，它有几个核心特性：</p>
<ul>
<li>挂起与恢复<code>suspend</code>：可在耗时操作时挂起，释放线程资源，完成后自动恢复；</li>
<li>非阻塞式并发：通过协作式调度实现任务的切换；</li>
<li>结构化并发：通过作用域自动管理协程生命周期；</li>
</ul>
<h2 id="2-协程的使用">2 协程的使用</h2>
<h3 id="21-协程的启动和调度">2.1 协程的启动和调度</h3>
<p>一般需要一个协程的作用域来启动和管理协程，然后在作用域里<br>
使用<code>launch</code>或者<code>async</code>函数启动协程，使用<code>suspend</code>来挂起协程：</p>
<ul>
<li><code>launch</code> : 用于非阻塞的异步任务；</li>
<li><code>async</code> : 用于可能返回结果的异步任务</li>
</ul>
<pre><code>fun main() = runBlocking {
	// 在默认的环境里启动协程
    val scope = CoroutineScope(Dispatchers.Default)
    scope.launch {
        // 在这里执行异步任务
        val result = requestData();
    }
    val result = scope.async {
    	// 执行可返回结果的异步任务

    }
    // result.await() 拿到具体的结果

}
// suspend关键字，表示这个方法在协程域内调用，不会阻塞线程
suspend fun requestData():Map {
	//实际的执行
}
</code></pre>
<p>并且在协程的使用过程中，可通过<code>Dispatchers</code>来指定协程运行在哪个环境(这里的环境主要是指运行在哪个线程池下，不同的线程池有不同的处理策略)：</p>
<ul>
<li><code>Main</code>： 主线程</li>
<li><code>IO</code> : 网络/文件操作</li>
<li><code>Default</code> : CPU密集型计算<br>
例：</li>
</ul>
<pre><code>// 在IO环境下启动协程
val result = async(Dispatchers.IO) {
	执行异步操作
}
</code></pre>
<h3 id="22-协程的取消">2.2 协程的取消</h3>
<p>协程的取消可使用<code>cancle</code>的关键字来处理。在启动协程时，会返回一个<code>Job</code>对象，在需要取消时，可调用<code>job.cancel</code>来达到这个目的；</p>
<pre><code>val job: Job = GlobalScope.launch {
    // 执行异步操作
}
// 取消
job.cancel()
</code></pre>
<h3 id="23-协程的异常处理">2.3 协程的异常处理</h3>
<p>异常的处理可使用自定义的<code>CoroutineExceptionHandler</code> 或者<code>try-catch</code>块来实现；</p>
<pre><code>val task1 = launch(CoroutineExceptionHandler { _, e -&gt; 
        logError(e) 
    }) { /* ... */ }
    
    try {
        task1.join()
    } catch (e: CancellationException) {
        // 处理取消异常
    }
</code></pre>
<h2 id="3-协程底层实现原理">3 协程底层实现原理</h2>
<p>协程底层是基于协程的生命周期状态来处理的，协程的生命周期包括：</p>
<ul>
<li><code>New</code> : 创建但未启动时的初始态；</li>
<li><code>Active</code>
<ul>
<li><code>Running</code>: 正在执行代码，会占用线程资源</li>
<li><code>Suspended</code> : 执行<code>suspend</code>函数时，释放线程，等待恢复；</li>
</ul>
</li>
<li><code>Completed</code> :完成状态（正常完成或者异常完成）</li>
<li><code>Cancelling</code> ： 取消状态，进入资源清理阶段，但可执行<code>finally</code>代码块；</li>
</ul>
<h3 id="31-核心原理">3.1 核心原理</h3>
<p>其核心原理是基于状态机。当遇到一个挂起函数时，就会将协程的代码置换为一个状态机，如代码里，有一个挂起函数：</p>
<pre><code>suspend fun doSomething() {
    delay(1000) // 挂起函数
    println("Something done")
}

fun main() = runBlocking {
    launch {
        doSomething()
    }
    println("Main function continues")
}
</code></pre>
<p>编译器会将上面的代码编译成:</p>
<pre><code>// 简化的状态机代码示意
class DoSomethingCoroutine : Continuation&lt;Unit&gt; {
	// 当前状态
    var state = 0
    override fun resumeWith(result: Result&lt;Unit&gt;) {
        when (state) {
            0 -&gt; {
                state = 1
                // 调用 delay 函数并传入当前协程作为 continuation
                // delay函数执行完成后，会调用resumeWith方法
                delay(1000, this)
            }
            1 -&gt; {
                println("Something done")
            }
        }
    }
}
</code></pre>
<p>在挂起的异步操作完成后，会调用协程的<code>resumeWith</code>方法，将结果传递给协程，协程会从暂停的位置恢复执行，并根据状态机的状态继续执行后续的代码；</p>
<h3 id="32-调度器coroutinedispatcher原理">3.2 调度器（<code>CoroutineDispatcher</code>）原理</h3>
<p>协程调度器负责决定协程在哪个线程或者线程池上使用；</p>
<ul>
<li>Default:用于CPU密集型，默认使用一个线程池</li>
<li>IO: 专门的线程池</li>
<li>Main: 用于在主线程上执行协程，通常用于更新UI;</li>
</ul>
<h4 id="321-default">3.2.1 Default</h4>
<p><code>Dispatchers.Default</code> 使用了一个基于<code>ForkJoinPool</code> 的线程池。<code>ForkJoinPool</code> 是 Java 7 引入的一种特殊线程池，它采用工作窃取算法（Work-Stealing Algorithm），可以高效地处理大量的小任务。<br>
当一个协程通过 <code>Dispatchers.Default</code> 调度执行时，<code>dispatch</code> 方法会将协程任务封装成一个 <code>Runnable</code> 对象，并将其提交到 <code>ForkJoinPool</code> 中。ForkJoinPool 会从线程池中选择一个空闲的线程来执行该任务。</p>
<h4 id="322-io">3.2.2 IO</h4>
<p><code>Dispatchers.IO</code> 也使用了一个线程池，不过这个线程池的大小可以根据系统资源动态调整。它的目的是为了处理大量的 I/O 阻塞操作，避免阻塞其他协程的执行。<br>
当一个协程通过 <code>Dispatchers.IO</code> 调度执行时，<code>dispatch </code>方法会将协程任务封装成一个 <code>Runnable</code> 对象，并将其提交到 IO 线程池中。由于 I/O 操作通常会阻塞线程，IO 线程池会有足够的线程来处理这些阻塞操作，从而保证其他协程可以继续执行。</p>
<h4 id="323-main">3.2.3 Main</h4>
<p>当一个协程通过 <code>Dispatchers.Main</code> 调度执行时，<code>dispatch </code>方法会将协程任务封装成一个<code>Runnable</code> 对象，并通过<code>Handler</code> 将其发送到主线程的消息队列中。主线程的消息循环会依次取出消息队列中的任务并执行。</p>
<h2 id="4-flow">4 Flow</h2>
<p><code>Flow</code> 是 kotlin协程中的响应式编程，基于协程构建，主要用于处理异步数据流，并且是冷流，只在被收集时才会开始发送元素（同时，<code>Flow</code>具有背压机制用于处理生产者和消费者的速度不匹配的问题），其有几个关键的组件：</p>
<ul>
<li>Flow 接口： 表示一个冷流，只有在被收集时才会开始发射元素，并且提供了一系列的操作符用于数据流的转换和处理；</li>
<li>FlowCollector:用于收集<code>Flow</code>发射的元素；</li>
<li>FlowBuilder：用于构建Flow对象，常见的构建方式有：<code>flow</code>,<code>flowOf</code>, <code>asFlow</code></li>
</ul>
<h3 id="41-常见的应用场景">4.1 常见的应用场景</h3>
<ul>
<li>异步数据流</li>
<li>UI数据更新（数据以Flow的形式暴露给UI,数据发生变化时，UI可以自动更新）</li>
<li>事件处理（将各种事件转换为Flow进行处理）</li>
</ul>
<pre><code>val dataFlow:Flow&lt;String&gt; = flow {
	emit("data")
}
// 默认不使用背压机制，当速度不匹配时，生产者会先暂停等前面的数据处理完再继续生产数据
dataFlow.collect{data -&gt;
	.....
}
</code></pre>
<h3 id="42-背压机制">4.2 背压机制</h3>
<p>背压（Backpressure）是一种反馈机制，用于处理生产者产生数据的速度快于消费者处理数据的速度的情况。当消费者处理数据的能力有限时，如果生产者持续快速地产生数据，可能会导致消费者内存溢出或者系统资源耗尽。背压机制允许消费者向生产者反馈自身的处理能力，从而使生产者调整数据的产生速度，以达到生产者和消费者之间的平衡。<br>
常见的几个背压操作符：</p>
<ul>
<li><code>buffer</code> : 创建一个缓冲区，来不及消息的内容会放到缓冲区里；</li>
<li><code>conflate</code>: 会丢弃缓冲区中未处理的数据，只保留最新的数据</li>
<li><code>collectLatest</code>: 当有新数据时，会取消当前正在处理的数据，只处理最新的数据</li>
</ul>
<pre><code>val dataFlow:Flow&lt;String&gt; = flow {
	emit("data")
}

// 指定使用buffer的背压策略
dataFlow.buffer()
	.collect{data -&gt;
	.....
}

</code></pre>
<h2 id="5-channel">5 Channel</h2>
<p><code>Channel</code> 是 Kotlin 协程库中用于在协程之间进行通信的工具，类似于队列，支持一个或多个协程向其发送元素，也支持一个或多个协程从其中接收元素，可用于实现生产者 - 消费者模式,它有不同的创建方式：</p>
<ul>
<li>Channel&lt;类型&gt;(10) : 创建固定大小的有缓冲的channel</li>
<li>Channel&lt;类型&gt;(Channel.RENDEZVOUS) ：创建无缓冲的channel，发送和接收要同步</li>
<li>Channel&lt;类型&gt;(Channel.UNLIMITED) ：创建无限缓冲的channel,</li>
</ul>
<p>一个简单的使用<code>Channel</code>的示例：</p>
<pre><code>fun main() = runBlocking {
	// 初始化一个默认大小的channel;
    val channel = Channel&lt;Int&gt;()

    // 生产者协程
    launch {
        for (i in 1..5) {
            
            // 通过send发送元素，如果缓冲区已满，该操作会挂起，直到有空间可用
            channel.send(i)
            println("Sent $i")
        }
        // 关闭 Channel，关闭后不能再发送数据，但可以继续接收数据
        channel.close() 
    }

    // 消费者协程
    launch {
    	// 当channel关闭，并且没有更多元素时，这个循环会自动结束
        for (element in channel) {
        	// 会通过receive()方法接收元素
            println("Received $element")
        }
        println("Channel closed")
    }
}
</code></pre>
<h3 id="51-channel的类型">5.1 Channel的类型</h3>
<h4 id="513-带容量限制的缓冲-channel">5.1.3 带容量限制的缓冲 Channel</h4>
<p>指定一个固定的容量，当缓冲区满时，发送操作会挂起。</p>
<pre><code>// 创建一个容量为10的Channel
val channel = Channel&lt;Int&gt;(10)
</code></pre>
<h4 id="513-无缓冲的-channelchannelrendezvous">5.1.3 无缓冲的 Channel（Channel.RENDEZVOUS）</h4>
<p>发送者和接收者必须同时准备好，发送操作会挂起，直到有接收者接收元素；接收操作也会挂起，直到有发送者发送元素。这种类型适用于需要严格同步的场景。</p>
<pre><code>// 创建一个无缓冲的Channel
val channel = Channel&lt;Int&gt;(Channel.RENDEZVOUS)
</code></pre>
<h4 id="513-无限缓冲的-channelchannelunlimited">5.1.3 无限缓冲的 Channel（Channel.UNLIMITED）</h4>
<p>（默认创建）缓冲区可以容纳任意数量的元素，发送操作不会挂起。但需要注意，如果生产者速度远大于消费者速度，可能会导致内存占用过高。</p>
<pre><code>// 创建一个不限制容量的Channel ,下面两个方法是等价的
val channel = Channel&lt;Int&gt;()
// val channel = Channel&lt;Int&gt;(Channel.UNLIMITED）)
</code></pre>
<h3 id="52-channel底层原理">5.2 Channel底层原理</h3>
<p><code>Channel</code>底层的核心是队列：</p>
<ul>
<li>无缓冲的 Channel： 使用特殊队列，本身不存储元素，而是协调发送者和接收者的同步；</li>
<li>有缓冲的 Channel（指定容量）：使用普通的<code>ArrayDeque</code></li>
<li>无限缓冲的 Channel（Channel.UNLIMITED） : 使用无界队列，如<code>LinkedList</code>;</li>
</ul>
<h2 id="6-参考">6 参考</h2>
<ul>
<li><a href="https://developer.android.com/kotlin/coroutines?hl=zh-cn" target="_blank" rel="noopener nofollow">kotlin 协程</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.02626592652314815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-01 19:53">2025-04-01 19:52</span>&nbsp;
<a href="https://www.cnblogs.com/WoodJim">woodWu</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18804801" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18804801);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18804801', targetLink: 'https://www.cnblogs.com/WoodJim/p/18804801', title: '白话kotlin协程' })">举报</a>
</div>
        