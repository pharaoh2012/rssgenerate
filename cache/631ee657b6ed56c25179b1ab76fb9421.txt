
        <div class="postTitle">
            <h1><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chenyishi/p/18703949" title="发布于 2025-02-08 11:56">
    <span role="heading" aria-level="2">.NET最佳实践：webapi返回IAsyncEnumerable提升性能</span>
    

</a>
</h1>
        </div>
        <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h4><span style="font-size: 1em">什么是IAsyncEnumerable</span></h4>
<p><code>IAsyncEnumerable&lt;T&gt;</code> 是 .NET 中用于表示异步数据流的接口。</p>
<p>它允许你逐个异步地获取数据项，而不是将所有数据一次性加载到内存中。这样可以减少内存占用，尤其在处理大量数据时更加高效。</p>
<p>与 <code>IEnumerable&lt;T&gt;</code> 不同，<code>IEnumerable&lt;T&gt;</code> 是同步的，要求所有数据在返回之前就加载完成。</p>
<p>而 <code>IAsyncEnumerable&lt;T&gt;</code> 是异步的，支持在数据流被请求时逐步加载，适合处理从数据库或网络等源异步获取的数据。</p>
<p><strong>示例：</strong></p>
<pre><code class="language-csharp">public async IAsyncEnumerable&lt;int&gt; GetNumbersAsync()
{
    for (int i = 0; i &lt; 10; i++)
    {
        await Task.Delay(100);  // 模拟异步操作
        yield return i;
    }
}
</code></pre>
<h4>好处</h4>
<p><strong>减少内存占用</strong>：<code>IAsyncEnumerable&lt;T&gt;</code> 逐步加载数据，避免了需要将所有数据一次性加载到内存中。对于大数据量的查询，能显著减少内存压力。</p>
<p><strong>提升响应性能</strong>：在 WebAPI 中，返回 <code>IAsyncEnumerable&lt;T&gt;</code> 可以让客户端在获取部分数据时立即开始处理，而无需等待所有数据都加载完成。这使得响应时间更短，提升用户体验。</p>
<p><strong>避免阻塞操作</strong>：使用 <code>async/await</code> 使得 WebAPI 不会被同步阻塞操作所拖慢，能够更好地处理并发请求。</p>
<h4>以 WebAPI + EFCore 举例</h4>
<p>假设我们需要通过 Entity Framework Core 从数据库中查询大量记录。</p>
<p>如果我们一次性加载所有数据，可能会导致内存占用过高，甚至影响性能。使用 <code>IAsyncEnumerable&lt;T&gt;</code>，我们可以逐个获取数据。</p>
<p><strong>示例代码：</strong></p>
<pre><code class="language-csharp">public class ProductController : ControllerBase
{
    private readonly ApplicationDbContext _context;

    public ProductController(ApplicationDbContext context)
    {
        _context = context;
    }

    [HttpGet("products")]
    public async IAsyncEnumerable&lt;Product&gt; GetProductsAsync()
    {
        await foreach (var product in _context.Products.AsAsyncEnumerable())
        {
            yield return product;
        }
    }
}
</code></pre>
<p>在这个例子中，<code>AsAsyncEnumerable()</code> 方法将 <code>DbSet&lt;Product&gt;</code> 转换成一个异步数据流，<code>await foreach</code> 循环逐个从数据库中异步获取数据并返回，避免了内存占用过多。</p>
<h4>以 WebAPI + HTTPClient 举例</h4>
<p>在 WebAPI 中，你可能需要调用其他服务或外部 API 来获取数据。使用 <code>IAsyncEnumerable&lt;T&gt;</code> 可以使得调用返回的数据逐步加载，避免等待整个请求完成后再返回。</p>
<p><strong>示例代码：</strong></p>
<pre><code class="language-csharp">public class ExternalApiController : ControllerBase
{
    private readonly HttpClient _httpClient;

    public ExternalApiController(HttpClient httpClient)
    {
        _httpClient = httpClient;
    }

    [HttpGet("external-data")]
    public async IAsyncEnumerable&lt;string&gt; GetExternalDataAsync()
    {
        var response = await _httpClient.GetAsync("https://api.example.com/data");
        response.EnsureSuccessStatusCode();

        var stream = await response.Content.ReadAsStreamAsync();
        using (var reader = new StreamReader(stream))
        {
            string? line;
            while ((line = await reader.ReadLineAsync()) != null)
            {
                yield return line;
            }
        }
    }
}
</code></pre>
<p>在这个例子中，我们通过 HTTPClient 请求外部 API 数据，并使用 <code>IAsyncEnumerable&lt;string&gt;</code> 返回每一行数据，允许客户端逐步处理数据，而无需等待所有数据都加载完毕。</p>
<p>需使用System.Text.Json格式化程序。 使用Newtonsoft.Json或XML-based格式化程序时，会缓冲结果，造成最后一次返回。</p>
<h4>客户端怎么处理 <code>IAsyncEnumerable&lt;T&gt;</code></h4>
<p>客户端接收到 <code>IAsyncEnumerable&lt;T&gt;</code> 数据流后，可以使用异步迭代器 <code>await foreach</code> 来逐步处理数据。</p>
<p>这样可以在数据流逐步传输过程中及时处理和显示数据，而不必等待全部数据加载完成。</p>
<h5>C# 客户端代码：</h5>
<pre><code class="language-csharp">public class ProductClient
{
    private readonly HttpClient _httpClient;

    public ProductClient(HttpClient httpClient)
    {
        _httpClient = httpClient;
    }

    public async Task GetProductsAsync()
    {
         var products = _httpClient.GetFromJsonAsAsyncEnumerable("https://api.example.com/data");
         await foreach (var p in products)
         {
            Console.WriteLine(DateTime.Now.ToString() + "  " + p.Id);
         }
    }
}
</code></pre>
<h5>JavaScript 客户端处理：</h5>
<p>在 JavaScript 中，客户端可以使用 <code>fetch</code> API 和流（Streams）来逐步处理数据。WebAPI 返回的数据流可以通过 <code>Response.body.getReader()</code> 来读取并逐步消费。</p>
<pre><code class="language-javascript">async function fetchProducts() {
    const response = await fetch('https://example.com/products');
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let done = false;
    let value = '';

    while (!done) {
        const { done: chunkDone, value: chunk } = await reader.read();
        done = chunkDone;
        value += decoder.decode(chunk, { stream: true });
        console.log(value);  // 逐步输出数据
    }
}
</code></pre>
<p>通过上述方式，JavaScript 客户端可以逐步处理 WebAPI 返回的异步流，提升用户体验和响应速度。</p>
</div>
<div class="clear"></div>

        <div class="postDesc">posted on 
<span id="post-date" data-last-update-days="2.6320647343483796" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-11 19:35">2025-02-08 11:56</span>&nbsp;
<a href="https://www.cnblogs.com/chenyishi">chester·chen</a>&nbsp;
阅读(<span id="post_view_count">642</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18703949" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18703949);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18703949', targetLink: 'https://www.cnblogs.com/chenyishi/p/18703949', title: '.NET最佳实践：webapi返回IAsyncEnumerable提升性能' })">举报</a>
</div>
    