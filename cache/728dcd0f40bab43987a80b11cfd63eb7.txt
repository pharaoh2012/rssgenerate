
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/WoodJim/p/18834505" title="发布于 2025-04-18 19:46">
    <span role="heading" aria-level="2">Android编译时动态插入代码原理与实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        说明如何应用这几种插入方式；
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>本文同步发布于公众号：移动开发那些事:<a href="https://mp.weixin.qq.com/s/mWMATf610rQ7N-GiCQh_Cw" target="_blank" rel="noopener nofollow">Android编译时动态插入代码原理与实践</a></p>
<p>Android开发中，编译时动态插入代码是一种高效，并且对业务逻辑是低侵入性的方案，常用于增加通用的埋点能力，或者插入关键日志，本文以编译时动态插入日志为例来说明如何在Android实现编译时动态插入代码。</p>
<h2 id="1-常见的编译时插入代码方案">1 常见的编译时插入代码方案</h2>
<ul>
<li>APT</li>
<li>Transform + ASM</li>
<li>AspectJ(AOP)</li>
</ul>
<h3 id="11-aptannotation-processing-tool">1.1 APT(Annotation Processing Tool)</h3>
<p>通过自定义注解标记目标方法/类，然后利用APT在编译期解析注解并生成包含代码逻辑的代码,其核心原理为：</p>
<ul>
<li>注解标记与解析：
<ul>
<li>开发者通过自定义注解（如 @DebugLog）标记需要插入日志的方法或类；</li>
<li>编译时，APT 的注解处理器（如继承 <code>AbstractProcessor</code> 的类）会扫描所有被标记的代码元素（如方法、字段)；</li>
</ul>
</li>
<li>代码生成与织入
<ul>
<li>生成辅助类：注解处理器使用代码生成工具（如 <code>JavaPoet</code>）创建新的 Java 类，这些类包含日志逻辑;</li>
<li>逻辑注入：生成的代码会通过静态方法调用或代理模式，在目标方法的前后插入日志语句</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>代码解耦;</li>
<li>灵活性强：支持复杂的逻辑，如参数获取，耗时统计</li>
</ul>
<p>更适用于需要生成新类的场景，如<code>ButterKnife</code>,<code>Dagger2</code>,<code>Arouter</code> ，</p>
<h3 id="12-transform--asm">1.2 Transform + ASM</h3>
<p>基于<code>Gradle Transform</code> ,在编译流程的<code>.class -&gt; dex</code>的阶段，通过<code>ASM</code>或<code>javassit</code>直接修改字节码，插入日志指令；其实现的核心原理为</p>
<ul>
<li>编译流程拦截：通过<code>Transform API</code> 拦截编译流程
<ul>
<li>每个<code>Transform</code>是独立的<code>Task</code>,多个Task按注册顺序形成链式的处理</li>
<li>通过<code>getScopes</code> 控制处理范围</li>
<li>通过<code>getInputTypes</code> 指定数据类型，如只处理类文件；</li>
</ul>
</li>
<li>ASM字节码操作
<ul>
<li><code>ClassReader</code>：读取 <code>.class</code> 文件并触发访问事件;</li>
<li><code>ClassWriter</code>：生成修改后的字节码。</li>
<li><code>ClassVisitor/MethodVisitor</code>：在访问类或方法时插入自定义逻辑</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>兼容性强，支持第三方库和系统类修改；</li>
<li>灵活性高，要可针对特定包，类或方法进行过滤；</li>
</ul>
<p>适用于需要修改现有代码逻辑（如插入埋点），典型应用场景为：</p>
<ul>
<li>实现全局埋点</li>
<li>性能监控</li>
<li>权限校验</li>
</ul>
<h3 id="13-aspectjaop">1.3 AspectJ(AOP)</h3>
<p>通过切点<code>Pointcut</code>定义目标方法，在编译期加入（<code>Weaving</code>）日志逻辑，其核心原理为：</p>
<ul>
<li><strong>编译时织入</strong>：在 Java 源码编译为字节码阶段，解析开发者定义的切面（<code>Aspect</code>）和切点（<code>Pointcut</code>），将通知（<code>Advice</code>）代码直接插入目标方法的前后或内部。这种织入方式无需运行时反射，性能损耗低；</li>
<li><strong>切点表达式</strong>： 切点表达式决定了哪些方法会被注入代码，通过语法（如 execution(* android.app.Activity.onCreate(..))）定义需要拦截的连接点（<code>Join Point</code>）</li>
<li><strong>通知类型（Advice Types）</strong>
<ul>
<li><code>@Before</code>: 在目标方法执行前插入日志（如记录方法调用时间）</li>
<li><code>@After</code> : 在方法正常返回或抛出异常后插入日志</li>
<li><code>@Around</code> : 完全控制方法执行，可自定义前后逻辑</li>
</ul>
</li>
</ul>
<p><strong>优点与适用场景</strong></p>
<ul>
<li>无侵入性：无需修改业务代码，通过声明式切面实现日志逻辑与业务解耦，适用于埋点、性能监控等场景；</li>
<li>灵活性与高覆盖率：支持通过复杂表达式匹配任意方法（包括第三方库）</li>
<li>性能高效：编译期静态织入避免运行时反射或动态代理开销<br>
适用于简单的应用场景，如方法级的日志插入，如果有更复杂的场景，需要使用<code>Transform + ASM</code>来实现更细粒度的控制</li>
</ul>
<h2 id="2-实战">2 实战</h2>
<h3 id="21-aptannotation-processing-tool">2.1 APT(Annotation Processing Tool)</h3>
<p>使用<code>APT</code>的步骤：</p>
<ul>
<li>定义注解，用于标记需要插入日志的方法，如<code>DebugLog</code></li>
<li>自定义注解处理器：继承于<code>AbstractProcessor</code>,并使用<code>JavaPoet</code>生成新类或增加现有类；</li>
<li>注入代码，在生成类中播入日志调用，例如在方法前后添加<code>Log.e</code>语句</li>
</ul>
<h4 id="211-定义注解">2.1.1 定义注解</h4>
<pre><code>package com.example.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// 模块名：annotation
@Retention(RetentionPolicy.CLASS)  // 保留到编译期
@Target(ElementType.METHOD)        // 标记在方法上
public @interface DebugLog {
}
</code></pre>
<h4 id="212-自定义注解处理器">2.1.2 自定义注解处理器</h4>
<p>有使用到两个依赖库,需要在项目的<code>build.gradle</code>文件中添加这两个依赖</p>
<pre><code> implementation 'com.google.auto.service:auto-service:1.0.1'
 implementation 'com.squareup:javapoet:1.13.0'
}
</code></pre>
<p><strong>注解处理器</strong></p>
<pre><code>// 模块名：compiler
@AutoService(Processor.class)  // 自动注册处理器
public class DebugLogProcessor extends AbstractProcessor {
    private Filer filer;       // 文件生成器
    private Messager messager; // 日志输出工具

    @Override
    public synchronized void init(ProcessingEnvironment env) {
        super.init(env);
        filer = env.getFiler();
        messager = env.getMessager();
    }

    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {
        // 遍历所有被 @DebugLog 标记的方法
        for (Element element : env.getElementsAnnotatedWith(DebugLog.class)) {
            if (element.getKind() != ElementKind.METHOD) {
                continue;
            }
            ExecutableElement method = (ExecutableElement) element;
            // 获取方法所在类信息
            TypeElement classElement = (TypeElement) method.getEnclosingElement();
            String className = classElement.getSimpleName().toString();
            String packageName = elements.getPackageOf(classElement).toString();

            // 生成代码
            generateLogCode(className, packageName, method);
        }
        return true;
    }

    private void generateLogCode(String className, String packageName, ExecutableElement method) {
        // 生成类名：原类名 + "$$Logger"
        String generatedClassName = className + "$$Logger";
        
        // 使用 JavaPoet 构建代码（生成新类）
        MethodSpec logMethod = MethodSpec.methodBuilder(method.getSimpleName().toString())
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(void.class)
                .addStatement("$T.d(\"APT\", \"Method called: $L\")", 
                    ClassName.get("android.util", "Log"), method.getSimpleName())
                .build();

        TypeSpec loggerClass = TypeSpec.classBuilder(generatedClassName)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addMethod(logMethod)
                .build();

        // 写入文件
        try {
            JavaFile.builder(packageName, loggerClass)
                    .build()
                    .writeTo(filer);
        } catch (IOException e) {
            messager.printMessage(Diagnostic.Kind.ERROR, "代码生成失败: " + e);
        }
    }
}


</code></pre>
<h4 id="213-使用">2.1.3 使用</h4>
<p>在某个需要插入日志的方法中使用<code>DebugLog</code>的注解标记</p>
<pre><code>public final class MainActivity {
@DebugLog
public void loadData(){
	// 其他业务逻辑
}}

// 编译后，会在build/generated/source/apt 目录下，看到对应的代码
public final class MainActivity$$Logger {
    public static void loadData() {
        Log.d("APT", "Method called: loadData");
    }
}
</code></pre>
<h3 id="22-transform--asm">2.2 Transform + ASM</h3>
<p>使用<code>Transform</code>的步骤：</p>
<ul>
<li>添加依赖；</li>
<li>注册<code>Transform</code>: 创建<code>gradle</code>插件，注册自定义的<code>Transform</code>实现</li>
<li>使用<code>ASM</code>;通过<code>ClassVisitor</code>和<code>MethodVisitor</code>在目标方法中插入日志调用；</li>
<li>优化：可通过<code>isIncremental</code> 方法减少重复处理(是否启动增量编译)；</li>
</ul>
<h4 id="221-添加依赖">2.2.1 添加依赖</h4>
<p>这里需要新建一个<code>Gradle</code>插件项目，在项目的<code>build.gradle</code>文件里添加必要的依赖</p>
<pre><code>plugins {
    id 'groovy'
    id 'maven-publish'
}

group 'com.example'
version '1.0.0'

repositories {
    google()
    mavenCentral()
    // 如果要发布到自定义的仓库，需要增加自定义仓库地址
}

dependencies {
	// 与gradle构建系统交互
    implementation gradleApi()
    // 本地的groovy库
    implementation localGroovy()
    implementation 'org.ow2.asm:asm:9.3'
    implementation 'com.android.tools.build:gradle:7.4.2'
}

publishing {
    // 这里涉及到如何将插件发布于maven仓库的逻辑，可参考公众号的另一篇文章
    // 这里只是发布的本地的配置介绍
   &lt;!--  publications {
        // 定义 Maven 发布的配置
        maven(MavenPublication) {
            // 发布的组 ID
            groupId 'com.example'
            // 发布的工件 ID
            artifactId 'log-insert-plugin'
            // 发布的版本号
            version '1.0.0'

            // 从 Java 组件获取要发布的内容
            from components.java
        }
    }
    repositories {
        // 配置本地 Maven 仓库的路径，用于发布插件
        maven {
            url "$buildDir/repo"
        }
    } --&gt;
}

</code></pre>
<p>关于如何将插件发布于<code>maven</code>仓库的介绍，可参考前面的文章<a href="https://mp.weixin.qq.com/s/ZFVTCwzKk97aVKFtDsizNQ" target="_blank" rel="noopener nofollow">如何高效发布Android AAR包到远程Maven仓库</a></p>
<h4 id="222-创建插件">2.2.2 创建插件</h4>
<p>首先在工程在工程<code>src/main/groovy</code>目录下创建一个<code>LogInsertPlugin.groovy </code></p>
<pre><code>package com.example

import org.gradle.api.Plugin
import org.gradle.api.Project

class LogInsertPlugin implements Plugin&lt;Project&gt; {
    @Override
    void apply(Project project) {
        def android = project.extensions.getByName('android')
        // 注册自定义的Transform类（后面会说明这个类的实现）
        android.registerTransform(new LogInsertTransform())
    }
}
</code></pre>
<p>在工程<code>src/main/groovy</code>目录下创建一个<code>LogInsertTransform.groovy</code></p>
<pre><code>package com.example

import com.android.build.api.transform.*
import com.android.build.gradle.internal.pipeline.TransformManager
import org.apache.commons.io.FileUtils
import org.objectweb.asm.*

import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.jar.JarOutputStream
import java.util.zip.ZipEntry

class LogInsertTransform extends Transform {

    @Override
    String getName() {
    	// 标识这个transform
        return "LogInsertTransform"
    }

    @Override
    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() {
    	// 指定Transform处理的输入类型，这里是类文件
        return TransformManager.CONTENT_CLASS
    }

    @Override
    Set&lt;? super QualifiedContent.Scope&gt; getScopes() {
    	// 指定Transform处理的范围，这里是整个项目
        return TransformManager.SCOPE_FULL_PROJECT
    }

    @Override
    boolean isIncremental() {
    	// 是否支持增量编译
        return true
    }

    // 处理输入文件并进行转换
    @Override
    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
        // 遍历 所有的输入文件
        transformInvocation.inputs.each { TransformInput input -&gt;
            // 目录
            input.directoryInputs.each { DirectoryInput directoryInput -&gt;
                // 拿到输出的目录
                def dest = transformInvocation.outputProvider.getContentLocation(
                        directoryInput.name,
                        directoryInput.contentTypes,
                        directoryInput.scopes,
                        Format.DIRECTORY
                )
                FileUtils.copyDirectory(directoryInput.file, dest)
                // 处理输出目录中的类文件
                processDirectory(dest)
            }
            // 处理jar
            input.jarInputs.each { JarInput jarInput -&gt;
                def jarName = jarInput.name
                if (jarName.endsWith(".jar")) {
                    jarName = jarName.substring(0, jarName.length() - 4)
                }
                def dest = transformInvocation.outputProvider.getContentLocation(
                        jarName,
                        jarInput.contentTypes,
                        jarInput.scopes,
                        Format.JAR
                )
                processJar(jarInput.file, dest)
            }
        }
    }

    private void processDirectory(File directory) {
        if (directory.isDirectory()) {
            directory.eachFileRecurse { File file -&gt;
                if (file.name.endsWith('.class')) {
                	// 处理类文件
                    processClassFile(file)
                }
            }
        }
    }

    // 处理jar 文件
    private void processJar(File inputJar, File outputJar) {
        def jarFile = new JarFile(inputJar)
        def enumeration = jarFile.entries()
        def tempFile = File.createTempFile("temp", ".jar")
        def jarOutputStream = new JarOutputStream(new FileOutputStream(tempFile))
        while (enumeration.hasMoreElements()) {
            def jarEntry = enumeration.nextElement()
            def inputStream = jarFile.getInputStream(jarEntry)
            def zipEntry = new ZipEntry(jarEntry.name)
            jarOutputStream.putNextEntry(zipEntry)
            // 处理类文件
            if (jarEntry.name.endsWith('.class')) {
                def classBytes = processClass(inputStream)
                // 写到输出流
                jarOutputStream.write(classBytes)
            } else {
                jarOutputStream.write(inputStream.bytes)
            }
            jarOutputStream.closeEntry()
        }
        jarOutputStream.close()
        jarFile.close()
        FileUtils.copyFile(tempFile, outputJar)
        tempFile.delete()
    }

    // 处理类文件的输入流
    private byte[] processClass(InputStream inputStream) {
    	// 类读取器
        def classReader = new ClassReader(inputStream)
        // 类写入器
        def classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS)
        // 创建自定义的类访问器
        def logClassVisitor = new LogClassVisitor(Opcodes.ASM9, classWriter)
        // 让类读取器接受访问器的处理
        classReader.accept(logClassVisitor, ClassReader.EXPAND_FRAMES)
        // 返回处理后的字节码
        return classWriter.toByteArray()
    }

    // 处理类文件
    private void processClassFile(File classFile) {
        def fis = new FileInputStream(classFile)
        def classBytes = processClass(fis)
        fis.close()
        def fos = new FileOutputStream(classFile)
        fos.write(classBytes)
        fos.close()
    }
}

// 自定义类访问器，用于访问类的各个部分
class LogClassVisitor extends ClassVisitor {

    LogClassVisitor(int api, ClassVisitor classVisitor) {
        super(api, classVisitor)
    }

    // 访问方法时调用
    @Override
    MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
        def methodVisitor = super.visitMethod(access, name, descriptor, signature, exceptions)
        // 创建自定义的方法访问器
        return new LogMethodVisitor(Opcodes.ASM9, methodVisitor, name)
    }
}
// 自定义方法访问器，有两种方式：
// 1 是继承于MethodVisitor
// 2 继承于AdviceAdapter(更简单)

// 方法1 ：自定义方法访问器，用于访问方法的各个部分
class LogMethodVisitor extends MethodVisitor {

    private String methodName

    LogMethodVisitor(int api, MethodVisitor methodVisitor, String methodName) {
        super(api, methodVisitor)
        this.methodName = methodName
    }

    // 访问方法代码开始时调用，
    @Override
    void visitCode() {
        super.visitCode()
        // 将日志标签压入栈（TAG）
        mv.visitLdcInsn("LogInsertPlugin")
        // 将日志信息压入栈 (Info)
        mv.visitLdcInsn("Entering method: $methodName")
        // 调用Log.d 方法
        mv.visitMethodInsn(Opcodes.INVOKESTATIC, "android/util/Log", "d", "(Ljava/lang/String;Ljava/lang/String;)I", false)
        // 弹出栈项元素
        mv.visitInsn(Opcodes.POP)
    }

    // 访问指令时调用
    @Override
    void visitInsn(int opcode) {
        // 判断是否是返回指令或异常指令
        if ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {
            mv.visitLdcInsn("LogInsertPlugin")
            mv.visitLdcInsn("Exiting method: $methodName")
            mv.visitMethodInsn(Opcodes.INVOKESTATIC, "android/util/Log", "d", "(Ljava/lang/String;Ljava/lang/String;)I", false)
            mv.visitInsn(Opcodes.POP)
        }
        super.visitInsn(opcode)
    }
}

// 方法2 ：继承自AdviceAdapter，更简洁
public class LogMethodVisitor extends AdviceAdapter {
    private String methodName;

    protected LogMethodVisitor(int api, MethodVisitor mv, int access, String name, String desc) {
        super(api, mv, access, name, desc);
        this.methodName = name;
    }

    @Override
    protected void onMethodEnter() {
        // 在方法入口插入日志：Log.d("LogInsertPlugin", "Enter method: " + methodName)
        visitLdcInsn("LogInsertPlugin");
        visitLdcInsn("Enter method: " + methodName);
        visitMethodInsn(INVOKESTATIC, "android/util/Log", "d", "(Ljava/lang/String;Ljava/lang/String;)I", false);
        visitInsn(POP); // 丢弃返回值（Log.d返回int）
        super.onMethodEnter();
    }

    @Override
    protected void onMethodExit(int opcode) {
        // 在方法出口插入日志：Log.d("LogInsertPlugin", "Exit method: " + methodName)
        visitLdcInsn("LogInsertPlugin");
        visitLdcInsn("Exit method: " + methodName);
        visitMethodInsn(INVOKESTATIC, "android/util/Log", "d", "(Ljava/lang/String;Ljava/lang/String;)I", false);
        visitInsn(POP);
        super.onMethodExit(opcode);
    }
</code></pre>
<p>然后就可以把这个插件发布到远程仓库了</p>
<h4 id="223-使用插件">2.2.3 使用插件</h4>
<p>在需要使用的工程的<code>build.gradle</code>目录下，添加对应的依赖</p>
<pre><code>buildscript {
    repositories {
        maven {
            //前面插件的发布地址
        }
    }
    dependencies {
    	// 
        classpath 'com.example:log-insert-plugin:1.0.0'
    }
}

// 应用前面做好的插件
apply plugin: 'com.example.LogInsertPlugin'
</code></pre>
<h3 id="23-aspectjaop">2.3 AspectJ(AOP)</h3>
<p>使用<code>Transform</code>的步骤：</p>
<ul>
<li>添加依赖</li>
<li>定义切面：使用<code>Aspect</code>注解标记切面类，通过<code>Pointcut</code> 指定目标方法</li>
<li>织入逻辑：在<code>Before</code>或<code>Around</code> 通知中插入日志代码</li>
<li>集成：通过<code>AspectJ</code>插件实现编译期织入；</li>
</ul>
<h4 id="231-添加依赖">2.3.1 添加依赖</h4>
<p>在工程的<code>build.gradle</code>添加<code>AspectJ</code>插件和依赖</p>
<pre><code>buildscript {
    dependencies {
        classpath 'org.aspectj:aspectjtools:1.9.7'
    }
}
// 插件
apply plugin: 'aspectj'

dependencies {
    implementation 'org.aspectj:aspectjrt:1.9.7'
    aspectpath 'org.aspectj:aspectjweaver:1.9.7'
}
</code></pre>
<h4 id="232-定义切面">2.3.2 定义切面</h4>
<p>创建一个<code>Aspect</code>类，用于拦截方法调用并插入日志</p>
<pre><code>import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.JoinPoint;

@Aspect
public class LogAspect {
	private static final String TAG = "LogAspect";
	// ("execution(* com.demo..*(..))" ,匹配在com.demo包下的所有类的所有方法
    // 定义一个切入点，这里表示匹配所有方法
    @Pointcut("execution(* *.*(..))")
    public void logMethods() {}

   // 在方法执行前插入日志
    @Before("logMethods()")
    public void beforeMethod(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        Log.d(TAG, "Before method: " + methodName);
    }

    // 在方法执行后插入日志
    @After("logMethods()")
    public void afterMethod(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        Log.d(TAG, "After method: " + methodName);
    }
}
</code></pre>
<h2 id="3-参考">3 参考</h2>
<ul>
<li><a href="https://juejin.cn/post/7472306990158594075" target="_blank" rel="noopener nofollow">Android里面的编译器注解APT的使用及其原理</a></li>
<li><a href="https://segmentfault.com/a/1190000041722223?sort=newest" target="_blank" rel="noopener nofollow">Transform+ASM牛刀小试</a></li>
<li><a href="https://blog.csdn.net/eclipsexys/article/details/54425414" target="_blank" rel="noopener nofollow">看AspectJ在Android中的强势插入</a></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/532703/202504/532703-20250418194617669-2027263178.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.0269216688125" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-18 19:47">2025-04-18 19:46</span>&nbsp;
<a href="https://www.cnblogs.com/WoodJim">woodWu</a>&nbsp;
阅读(<span id="post_view_count">94</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18834505);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18834505', targetLink: 'https://www.cnblogs.com/WoodJim/p/18834505', title: 'Android编译时动态插入代码原理与实践' })">举报</a>
</div>
        