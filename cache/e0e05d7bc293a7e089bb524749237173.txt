
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ac-wyr/p/19030244" title="发布于 2025-08-09 21:54">
    <span role="heading" aria-level="2">重链剖分</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="重链剖分"><strong>重链剖分</strong></h1>
<hr>
<h2 id="定义">定义</h2>
<p>重链剖分是树链剖分的一种解决方式，通过树链剖分将树划分为多个连续部分方便执行操作</p>
<p>我们进行如下定义：</p>
<ul>
<li><code>son[u]</code> 表示 <code>u</code> 结点的重儿子。对于重儿子， 我们定义在 <code>u</code> 的所有子树中最大的子节点，且重儿子只有一个</li>
<li><code>sz[u]</code> 表示 <code>u</code> 结点的子树大小， 包括结点 <code>u</code> 本身</li>
<li><code>dep[u]</code> 表示 <code>u</code>  结点的深度</li>
<li><code>dfn[u]</code> 表示 <code>u</code> 结点所表示的 <code>dfs</code> 序</li>
<li><code>top[u]</code> 表示 <code>u</code> 结点所在链的顶点</li>
<li><code>fa[u]</code> 表示 <code>u</code> 结点的父节点</li>
</ul>
<p>我们对一棵树进行如下划分，对于每个结点 <code>u</code> ，将其重儿子称为重子结点，而由重儿子所组成的一条链成为重链，其余节点成为轻儿子，特别的，重子节点一定会组成一条链，因为一个节点只存在一个重儿子，所以任何重子结点不存在两个及以上的重子节点。</p>
<p>通过以上分化后，我们可以通过 <code>dfs</code> 对每个结点定义其 <code>dfs</code> 序，对于这个遍历过程，我们采用重儿子优先的策略，优先向重儿子进行递归，可以保证重链的 <code>dfs</code> 序是连续的，并且对于任意一结点 <code>u</code> ，保证其子树内的 <code>dfs</code> 序大于 <code>u</code>  ，并且不超过 <code>dfn[u] + sz[u] - 1</code></p>
<p>总结就是：</p>
<ul>
<li>
<p>重儿子所组成的一定是一条链</p>
</li>
<li>
<p>每个节点至多有一个重儿子，满足每个结点均在一条重链上</p>
</li>
<li>
<p>重链的 <code>dfs</code> 序是连续的</p>
</li>
<li>
<p>子树 <code>u</code> 的 <code>dfs</code> 序范围是 <code>[dfn[u], dfn[u] + sz[u] - 1]</code></p>
</li>
</ul>
<hr>
<h2 id="应用">应用</h2>
<p>通过以上定义，我们可以通过线段树快速对一个子树内的所有元素进行统一修改，因为一个子树内的所有节点的 <code>dfs</code> 序一定连续</p>
<p>同时，我们还可以快速查询树上最近公共祖先 <code>LCA</code> ，我们可以知道，树上任意一个点 <code>u</code> 都必然存在于一个重链之上，所以两个点只要不断跳到其所在链的顶点，再不断上跳，就能快速找到最近公共祖先；还可以对树上的一条路径进行操作</p>
<h2 id="示例">示例</h2>
<p>以洛谷题目 <a href="https://www.luogu.com.cn/problem/P3384" target="_blank" rel="noopener nofollow">P3384 【模板】重链剖分 </a> 为例</p>
<h3 id="初始化">初始化</h3>
<p><code>dfs1</code> ：计算每个子树的大小，以及每个节点的深度，父亲，以及重儿子</p>
<pre><code class="language-cpp">void dfs1(ll u, ll father) {
	fa[u] = father;
	dep[u] = dep[father] + 1;
	sz[u] = 1;
	for (auto v : g[u]) {
		if (v == father) continue;
		dfs1(v, u);
		sz[u] += sz[v];
		if (sz[v] &gt; sz[son[u]]) son[u] = v;
	}
}
</code></pre>
<p><code>dfs2</code>：计算每个节点的 <code>dfs</code> 序，以及每个链的链顶</p>
<pre><code class="language-cpp">void dfs2(ll u, ll topf) {
	top[u] = topf;
	dfn[u] = ++timer;
	rk[timer] = u;//rk在这里是一个逆数组，用于标记每个dfn所对应的结点，用于后续操作
	if (son[u]) dfs2(son[u], topf);
	for (auto v : g[u]) {
		if (v != fa[u] &amp;&amp; v != son[u])
			dfs2(v, v);
	}
}
</code></pre>
<h3 id="线段树模板">线段树模板：</h3>
<pre><code class="language-cpp">//线段树维护的是dfs序对应的数组 a[rk[i]]，因此树上的子树或路径问题可以转化为数组的区间问题。
struct SegmentTree {
	void push_up(ll p) {
		tree[p] = (tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1]) % mod;
	}
	void push_down(ll p, ll l, ll r) {
		if (lz[p]) {
			lz[p &lt;&lt; 1] = (lz[p &lt;&lt; 1] + lz[p]) % mod;
			lz[p &lt;&lt; 1 | 1] = (lz[p &lt;&lt; 1 | 1] + lz[p]) % mod;
			ll mid = (l + r) &gt;&gt; 1;
			tree[p &lt;&lt; 1] = (tree[p &lt;&lt; 1] + lz[p] * (mid - l + 1) % mod) % mod;
			tree[p &lt;&lt; 1 | 1] = (tree[p &lt;&lt; 1 | 1] + lz[p] * (r - mid) % mod) % mod;
			lz[p] = 0;
		}
	}

	void build(ll p, ll l, ll r) {
		if (l == r) {
			tree[p] = a[rk[l]] % mod;
			return;
		}
		ll mid = (l + r) &gt;&gt; 1;
		build(p &lt;&lt; 1, l, mid);
		build(p &lt;&lt; 1 | 1, mid + 1, r);
		push_up(p);
	}

	void add(ll p, ll l, ll r, ll L, ll R, ll k) {
		if (L &lt;= l &amp;&amp; r &lt;= R) {
			tree[p] = (tree[p] + k*(r - l + 1) % mod) % mod;
			lz[p] = (lz[p] + k) % mod;
			return;
		}
		push_down(p, l, r);
		ll mid = (l + r) &gt;&gt; 1;
		if (L &lt;= mid)add(p &lt;&lt; 1, l, mid, L, R, k);
		if (R &gt; mid)add(p &lt;&lt; 1 | 1, mid + 1, r, L, R, k);
		push_up(p);
	}

	ll search(ll p, ll l, ll r, ll L, ll R) {
		if (L &lt;= l &amp;&amp; r &lt;= R) {
			return tree[p];
		}
		push_down(p, l, r);
		ll mid = (l + r) &gt;&gt; 1;
		ll res = 0;
		if (L &lt;= mid)res = (res + search(p &lt;&lt; 1, l, mid, L, R)) % mod;
		if (R &gt; mid)res = (res + search(p &lt;&lt; 1 | 1, mid + 1, r, L, R)) % mod;
		return res % mod;
	}
} st;
</code></pre>
<h3 id="修改路径">修改路径</h3>
<pre><code class="language-cpp">void update(ll u, ll v, ll k) {
	while (top[u] != top[v]) {//不断向上跳链，跳到链顶就修改一次，直到两个节点在同一个链上
		if (dep[top[u]] &lt; dep[top[v]])swap(u, v);
		st.add(1, 1, n, dfn[top[u]], dfn[u], k);
		u = fa[top[u]];
	}
	if (dep[u] &gt; dep[v])swap(u, v);
	st.add(1, 1, n, dfn[u], dfn[v], k);
}
</code></pre>
<h3 id="查询路径">查询路径</h3>
<pre><code class="language-cpp">ll query(ll u, ll v) {//与修改一样，不断向上跳即可
	ll res = 0;
	while (top[u] != top[v]) {
		if (dep[top[u]] &lt; dep[top[v]])swap(u, v);
		res = (res + st.search(1, 1, n, dfn[top[u]], dfn[u])) % mod;
		u = fa[top[u]];
	}
	if (dep[u] &gt; dep[v])swap(u, v);
	res = (res + st.search(1, 1, n, dfn[u], dfn[v])) % mod;
	return res % mod;
}
</code></pre>
<h4 id="完整代码">完整代码：</h4>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int N = 2e5+10;

ll n, m, R, mod, deep, timer;
ll a[N], dfn[N], sz[N], son[N], dep[N], fa[N], rk[N], top[N], tree[N &lt;&lt; 2], lz[N &lt;&lt; 2];

vector&lt;ll&gt; g[N];

void dfs1(ll u, ll father) {
	fa[u] = father;
	dep[u] = dep[father] + 1;
	sz[u] = 1;
	for (auto v : g[u]) {
		if (v == father) continue;
		dfs1(v, u);
		sz[u] += sz[v];
		if (sz[v] &gt; sz[son[u]]) son[u] = v;
	}
}

void dfs2(ll u, ll topf) {
	top[u] = topf;
	dfn[u] = ++timer;
	rk[timer] = u;
	if (son[u]) dfs2(son[u], topf);
	for (auto v : g[u]) {
		if (v != fa[u] &amp;&amp; v != son[u])
			dfs2(v, v);
	}
}


struct SegmentTree {
	void push_up(ll p) {
		tree[p] = (tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1]) % mod;
	}
	void push_down(ll p, ll l, ll r) {
		if (lz[p]) {
			lz[p &lt;&lt; 1] = (lz[p &lt;&lt; 1] + lz[p]) % mod;
			lz[p &lt;&lt; 1 | 1] = (lz[p &lt;&lt; 1 | 1] + lz[p]) % mod;
			ll mid = (l + r) &gt;&gt; 1;
			tree[p &lt;&lt; 1] = (tree[p &lt;&lt; 1] + lz[p] * (mid - l + 1) % mod) % mod;
			tree[p &lt;&lt; 1 | 1] = (tree[p &lt;&lt; 1 | 1] + lz[p] * (r - mid) % mod) % mod;
			lz[p] = 0;
		}
	}

	void build(ll p, ll l, ll r) {
		if (l == r) {
			tree[p] = a[rk[l]] % mod;
			return;
		}
		ll mid = (l + r) &gt;&gt; 1;
		build(p &lt;&lt; 1, l, mid);
		build(p &lt;&lt; 1 | 1, mid + 1, r);
		push_up(p);
	}

	void add(ll p, ll l, ll r, ll L, ll R, ll k) {
		if (L &lt;= l &amp;&amp; r &lt;= R) {
			tree[p] = (tree[p] + k*(r - l + 1) % mod) % mod;
			lz[p] = (lz[p] + k) % mod;
			return;
		}
		push_down(p, l, r);
		ll mid = (l + r) &gt;&gt; 1;
		if (L &lt;= mid)add(p &lt;&lt; 1, l, mid, L, R, k);
		if (R &gt; mid)add(p &lt;&lt; 1 | 1, mid + 1, r, L, R, k);
		push_up(p);
	}

	ll search(ll p, ll l, ll r, ll L, ll R) {
		if (L &lt;= l &amp;&amp; r &lt;= R) {
			return tree[p];
		}
		push_down(p, l, r);
		ll mid = (l + r) &gt;&gt; 1;
		ll res = 0;
		if (L &lt;= mid)res = (res + search(p &lt;&lt; 1, l, mid, L, R)) % mod;
		if (R &gt; mid)res = (res + search(p &lt;&lt; 1 | 1, mid + 1, r, L, R)) % mod;
		return res % mod;
	}
} st;

void update(ll u, ll v, ll k) {
	while (top[u] != top[v]) {
		if (dep[top[u]] &lt; dep[top[v]])swap(u, v);
		st.add(1, 1, n, dfn[top[u]], dfn[u], k);
		u = fa[top[u]];
	}
	if (dep[u] &gt; dep[v])swap(u, v);
	st.add(1, 1, n, dfn[u], dfn[v], k);
}

ll query(ll u, ll v) {
	ll res = 0;
	while (top[u] != top[v]) {
		if (dep[top[u]] &lt; dep[top[v]])swap(u, v);
		res = (res + st.search(1, 1, n, dfn[top[u]], dfn[u])) % mod;
		u = fa[top[u]];
	}
	if (dep[u] &gt; dep[v])swap(u, v);
	res = (res + st.search(1, 1, n, dfn[u], dfn[v])) % mod;
	return res % mod;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; R &gt;&gt; mod;
	for (int i = 1; i &lt;= n; i++) {
		cin &gt;&gt; a[i];
		a[i] %= mod;
	}
	for (int i = 1; i &lt; n; i++) {
		ll u, v;
		cin &gt;&gt; u &gt;&gt; v;
		g[u].push_back(v);
		g[v].push_back(u);
	}

	dfs1(R, 0);
	dfs2(R, R);
	st.build(1, 1, n);

	for (int i = 1; i &lt;= m; i++) {
		ll op, x, y, z;
		cin &gt;&gt; op;
		if (op == 1) {
			cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
			update(x, y, z);
		}
		if (op == 2) {
			cin &gt;&gt; x &gt;&gt; y;
			cout &lt;&lt; query(x, y) &lt;&lt; '\n';
		}
		if (op == 3) {
			cin &gt;&gt; x &gt;&gt; y;
			st.add(1, 1, n, dfn[x], dfn[x] + sz[x] - 1, y);
		}
		if (op == 4) {
			cin &gt;&gt; x;
			cout &lt;&lt; st.search(1, 1, n, dfn[x], dfn[x] + sz[x] - 1) &lt;&lt; '\n';
		}
	}
	return 0;
}
</code></pre>
<hr>
<h2 id="时间复杂度的简单证明">时间复杂度的简单证明</h2>
<p>树链剖分整体时间复杂度为 $ O(N log_2 N) $</p>
<p>其中 <code>dfs</code> 时间复杂度为 <span class="math inline">\(O(N)\)</span> ，其余查询操作均为 <span class="math inline">\(O(log_2 N)\)</span></p>
<p>其中简单讲一下为什么树上路径的查询与修改是 <span class="math inline">\(O(log_2 N)\)</span></p>
<p>我们考虑树剖每次的跳跃可以理解为从链底直接跳到链顶，而为了使其跳跃次数尽可能地多，只能让其子树尽可能的多，最极限的状态是就是这是一颗满二叉树，但未什么不在某一个位置深度更高一点呢？因为如果某一个地方的深度过深，那么这里一定是一条重链，那么跳越次数就又会锐减，所以很明显的，树剖的查询与修改操作最极限的时间复杂度为 <span class="math inline">\(O(log_2 N)\)</span> 并且常数极小，效率极高</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-09 21:55">2025-08-09 21:54</span>&nbsp;
<a href="https://www.cnblogs.com/ac-wyr">AC-wyr</a>&nbsp;
阅读(<span id="post_view_count">45</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19030244);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19030244', targetLink: 'https://www.cnblogs.com/ac-wyr/p/19030244', title: '重链剖分' })">举报</a>
</div>
        