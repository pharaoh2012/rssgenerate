
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18763193" title="发布于 2025-03-11 13:30">
    <span role="heading" aria-level="2">重生之数据结构与算法----图的遍历</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="简介">简介</h1>
<p>上文讲到，图的本质是<code>多叉树</code>。因此主要遍历方式还是DFS与BFS。<br>
唯一的区别在于，树结构中不存在环，而图中可能回<code>成环</code>。因此我们需要记录一下已经访问过的节点，避免死循环。</p>
<h1 id="深度优先遍历dfs">深度优先遍历(DFS)</h1>
<h2 id="遍历所有节点">遍历所有节点</h2>
<pre><code>        /// &lt;summary&gt;
        /// 邻接表实现DFS
        /// &lt;/summary&gt;
        /// &lt;param name="startIndex"&gt;&lt;/param&gt;
        public void DFSTraverse(int startIndex)
        {

            if (startIndex &lt; 0 || startIndex &gt;= _graph.Count)
                return;

            //记录一下已经访问过的，避免死循环
            if (_visited[startIndex])
                return;
            _visited[startIndex] = true;


            //前序遍历
            Console.WriteLine($"index={startIndex}");

            if (_graph[startIndex]?.Count &gt; 0)
            {
                foreach (var item in _graph[startIndex])
                {
                    DFSTraverse(item.Indegree);
                }
            }

            //后序遍历
            //Console.WriteLine($"index={index}");
        }
		/// &lt;summary&gt;
        /// 邻接矩阵实现DFS
        /// &lt;/summary&gt;
        /// &lt;param name="startIndex"&gt;&lt;/param&gt;
        public void DFSTraverse(int startIndex)
        {
            //记录一下已经访问过的，避免死循环
            if (_visited[startIndex])
                return;

            _visited[startIndex] = true;

            //前序遍历
            Console.WriteLine($"index={startIndex}");

            for (int i = 0; i &lt; _visited.Length; i++)
            {
                //为0代表未使用
                if (_matrix[startIndex, i] == 0)
                    continue;

                DFSTraverse(i);
            }

            //后序遍历
            //Console.WriteLine($"index={index}"); 
        }
</code></pre>
<blockquote>
<p>可以看到，与多叉树的深度优先并无区别，就多了一个数组。</p>
</blockquote>
<h2 id="遍历所有路径">遍历所有路径</h2>
<p>在树结构中，遍历所有路径和遍历所有节点，<code>是没区别的</code>。因为根节点到叶节点的过程是单向，所以他们之间的路径是唯一的。<br>
但在图中，因为<code>环</code>的存在。所以从根节点到叶节点的过程路径会有很多种。因此在图的遍历中，图的路径需要穷举。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202503/1084317-20250307125837466-810819671.png" alt="image" loading="lazy"></p>
<blockquote>
<p>以此图为例，0节点到4节点，就有5种路径。<br>
find path:0=&gt;1=&gt;2=&gt;3=&gt;4<br>
find path:0=&gt;1=&gt;3=&gt;4<br>
find path:0=&gt;1=&gt;4<br>
find path:0=&gt;3=&gt;4<br>
find path:0=&gt;4</p>
</blockquote>
<p>对于图来说，由起点stc到目标节点dest的路径很多，我们需要一个onPath数组，<code>在进入节点</code>时标记正在访问，<code>退出节点时</code>撤销标记。这样就能形成一个完整的遍历路径。</p>
<pre><code>        public void Traverse(int src,int dest) 
        {
            if (src &lt; 0 || src &gt;= _graph.Count)
                return;

            //防止形成死循环
            if (_visited[src])
                return;

            
            _visited[src] = true;
            //在前序位置加入遍历路径
            _path.AddLast(src);
            if (src == dest)
            {
                Console.WriteLine($"find path:{string.Join("=&gt;", _path)}");
            }


            foreach (var item in _graph[src])
            {
                Traverse(item.Indegree, dest);
            }

           
            _path.RemoveLast();
            //在后序位置撤销标记
            _visited[src] = false;
        }
</code></pre>
<p>为什么要在后序位置撤销标记？如果不撤销。就类似遍历所有节点一样。遇到了重复节点就退出了，而漏掉了其它可能的路径。因此当节点退出时<code>撤销标记</code>。再往右探测可能的路径。直到遍历完整个图。</p>
<h1 id="广度遍历优先bfs">广度遍历优先(BFS)</h1>
<p>同理可得，对于图的BFS算法。也只要加入一个visited数组来避免死循环即可。</p>
<blockquote>
<p>理论上BFS遍历也需要遍历完<code>所有节点</code>与<code>所有路径</code>，但一般情况下，BFS只用来寻找最短路径。因为BFS算法是以层位维度，一层一层的搜索。第一次遇到的目标节点，那必然是最短路径。</p>
</blockquote>
<pre><code>        public void BFSTraverse(int startIndex)
        {
            Queue&lt;int&gt; queue=new Queue&lt;int&gt;();
            queue.Enqueue(startIndex);
            //标记节点已被访问，避免死循环。
            _visited[startIndex]=true;

            while (queue.Count &gt; 0)
            {
                var cur=queue.Dequeue();
                Console.WriteLine($"cur:{cur}");

                foreach (var e in _graph[cur])
                {
                    //已经访问过了就不再访问
                    if (!_visited[e.Indegree])
                    {
                        queue.Enqueue(e.Indegree);
                        _visited[e.Indegree] = true;
                    }
                }
            }
        }
</code></pre>
<blockquote>
<p>剩下的两种，记录所在层与记录权重。不在赘述，可以参考多叉树的BFS三种遍历代码。</p>
</blockquote>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.36569324775578704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-11 13:30">2025-03-11 13:30</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">31</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18763193" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18763193);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18763193', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18763193', title: '重生之数据结构与算法----图的遍历' })">举报</a>

		</p>
	