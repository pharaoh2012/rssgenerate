
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/qsmm/p/18961809" title="发布于 2025-07-02 17:16">
    <span role="heading" aria-level="2">Mybatis - 精巧的持久层框架-缓存机制的深刻理解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="mybatis缓存机制">Mybatis缓存机制</h1>
<p>Mybatis的缓存机制是其性能优化的核心，也是面试中的高频考点。理解它不仅能写出更高性能的代码，还能明白框架设计中对<strong>性能与数据一致性</strong>权衡的智慧。</p>
<p>此教程从概念到实战，从基础到企业应用，确保不仅能看懂，更能跟着动手实践，彻底掌握它。</p>
<hr>
<h3 id="mybatis缓存机制深度解析与实战"><strong>Mybatis缓存机制深度解析与实战</strong></h3>
<h4 id="引子为什么需要缓存"><strong>引子：为什么需要缓存？</strong></h4>
<p>想象一下，你每次去图书馆借同一本《Java编程思想》，都得重新在前台办理一遍完整的借书手续。这显然效率低下。如果前台有个小架子，放着最近常被借阅的书，你来了直接拿走，效率是不是就高多了？</p>
<p>在数据库交互中，<strong>缓存（Cache）</strong> 就是这个“小架子”。它是一块内存区域，用于存储那些已经被查询过的数据。当下次再需要同样的数据时，程序可以直接从缓存中获取，而<strong>不必再次访问慢速的数据库</strong>，从而大幅提升应用性能。</p>
<p>Mybatis内置了两种缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong>。</p>
<hr>
<h3 id="第一部分一级缓存-sqlsession级别"><strong>第一部分：一级缓存 (SqlSession级别)</strong></h3>
<h4 id="1-概念解析"><strong>1. 概念解析</strong></h4>
<ul>
<li>
<p><strong>别名</strong>：本地缓存 (Local Cache)。</p>
</li>
<li>
<p><strong>作用域 (Scope)</strong>：它的生命周期与 <code>SqlSession</code> 完全绑定。也就是说，<strong>每个<code>SqlSession</code>对象都有自己独立的一级缓存</strong>。当<code>SqlSession</code>被创建时，它的一级缓存就诞生了；当<code>SqlSession</code>被关闭时，它的一级缓存也随之销毁。</p>
</li>
<li>
<p><strong>工作状态</strong>：<strong>默认开启，无法关闭</strong>。这是Mybatis的内置特性。</p>
</li>
<li>
<p><strong>工作原理（核心）</strong>：</p>
<ol>
<li>在一个<code>SqlSession</code>中，当你第一次执行某个查询时，Mybatis会从数据库获取数据，并将这份数据存入当前<code>SqlSession</code>的一级缓存中。</li>
<li>在该<code>SqlSession</code><strong>未关闭</strong>且<strong>未执行任何增删改操作</strong>的情况下，你再次执行<strong>完全相同</strong>的查询（SQL语句、参数都一样），Mybatis会直接从一级缓存中返回数据，而不会再次访问数据库。</li>
</ol>
</li>
<li>
<p><strong>缓存失效的场景</strong>：</p>
<ol>
<li><code>SqlSession</code>被关闭 (<code>session.close()</code>)。</li>
<li>在当前<code>SqlSession</code>中执行了任何<strong>增、删、改（DML）操作</strong> (<code>insert</code>, <code>update</code>, <code>delete</code>)。因为这可能导致缓存中的数据与数据库不一致（“脏数据”），所以Mybatis会清空缓存以保证数据准确性。</li>
<li>手动调用<code>session.clearCache()</code>方法。</li>
</ol>
</li>
</ul>
<h4 id="2-动手实践验证一级缓存"><strong>2. 动手实践：验证一级缓存</strong></h4>
<p><strong>项目结构准备</strong>：我们将使用一个标准的Maven项目结构。</p>
<pre><code>mybatis-cache-demo/
├── pom.xml
└── src/
    ├── main/
    │   ├── java/
    │   │   └── com/
    │   │       └── example/
    │   │           ├── entity/
    │   │           │   └── User.java      // 用户实体类
    │   │           ├── mapper/
    │   │           │   └── UserMapper.java  // Mapper接口
    │   │           └── test/
    │   │               └── L1CacheTest.java // 我们的一级缓存测试类
    │   └── resources/
    │       ├── mappers/
    │       │   └── UserMapper.xml     // SQL映射文件
    │       └── mybatis-config.xml         // Mybatis全局配置
    └── test/
        └── ... (我们这里为了方便，测试类也放在main下)
</code></pre>
<p><strong>准备代码</strong></p>
<ol>
<li>
<p><strong><code>pom.xml</code> (依赖)</strong></p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.9&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.28&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.24&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
</li>
<li>
<p><strong><code>mybatis-config.xml</code> (全局配置)</strong></p>
<pre><code class="language-xml">&lt;!-- src/main/resources/mybatis-config.xml --&gt;
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
    &lt;environments default="development"&gt;
        &lt;environment id="development"&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;
                &lt;property name="url" value="jdbc:mysql://localhost:3306/your_db?useSSL=false&amp;amp;serverTimezone=UTC"/&gt;
                &lt;property name="username" value="root"/&gt;
                &lt;property name="password" value="your_password"/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource="mappers/UserMapper.xml"/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
</li>
<li>
<p><strong><code>User.java</code> (实体类)</strong></p>
<pre><code class="language-java">// src/main/java/com/example/entity/User.java
package com.example.entity;

import lombok.Data;
import lombok.ToString;

@Data // 使用Lombok简化代码
public class User {
    private Integer id;
    private String username;
    private String password;

    // 我们特意添加一个构造函数，方便观察对象是否被重新创建
    public User() {
        System.out.println("User对象被创建了！(A new User object was created!)");
    }
}
</code></pre>
</li>
<li>
<p><strong><code>UserMapper.java</code> 和 <code>UserMapper.xml</code></strong></p>
<pre><code class="language-java">// src/main/java/com/example/mapper/UserMapper.java
package com.example.mapper;
import com.example.entity.User;
public interface UserMapper {
    User findById(Integer id);
    int updateUsername(User user);
}
</code></pre>
<pre><code class="language-xml">&lt;!-- src/main/resources/mappers/UserMapper.xml --&gt;
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace="com.example.mapper.UserMapper"&gt;
    &lt;select id="findById" resultType="com.example.entity.User"&gt;
        SELECT * FROM user WHERE id = #{id}
    &lt;/select&gt;
    &lt;update id="updateUsername"&gt;
        UPDATE user SET username = #{username} WHERE id = #{id}
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
</li>
<li>
<p><strong><code>L1CacheTest.java</code> (核心测试代码)</strong></p>
<pre><code class="language-java">// src/main/java/com/example/test/L1CacheTest.java
package com.example.test;

import com.example.entity.User;
import com.example.mapper.UserMapper;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

public class L1CacheTest {
    public static void main(String[] args) throws IOException {
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

        // 使用同一个SqlSession
        try (SqlSession session = sqlSessionFactory.openSession(true)) {
            UserMapper mapper = session.getMapper(UserMapper.class);

            System.out.println("--- 场景1：验证一级缓存的存在 ---");
            System.out.println("第一次查询ID为1的用户...");
            User user1 = mapper.findById(1);
            System.out.println(user1);

            System.out.println("\n第二次查询ID为1的用户 (在同一个session中)...");
            User user2 = mapper.findById(1);
            System.out.println(user2);
            System.out.println("user1 == user2 ? " + (user1 == user2)); // 验证是否是同一个对象

            System.out.println("\n--- 场景2：验证DML操作会清空一级缓存 ---");
            System.out.println("执行更新操作...");
            user1.setUsername("admin_updated");
            mapper.updateUsername(user1);

            System.out.println("\n更新后，再次查询ID为1的用户...");
            User user3 = mapper.findById(1);
            System.out.println(user3);
            System.out.println("user1 == user3 ? " + (user1 == user3));
        }
    }
}
</code></pre>
</li>
</ol>
<p><strong>预期输出与分析：</strong></p>
<pre><code>--- 场景1：验证一级缓存的存在 ---
第一次查询ID为1的用户...
User对象被创建了！(A new User object was created!)  &lt;-- 第一次查询，创建了对象
User(id=1, username=admin, password=...)

第二次查询ID为1的用户 (在同一个session中)...
User(id=1, username=admin, password=...)  &lt;-- 第二次查询，没有打印“User对象被创建了”
user1 == user2 ? true  &lt;-- 证明了第二次是从缓存中拿的同一个对象！

--- 场景2：验证DML操作会清空一级缓存 ---
执行更新操作...

更新后，再次查询ID为1的用户...
User对象被创建了！(A new User object was created!) &lt;-- DML后，缓存失效，重新查询数据库，创建了新对象
User(id=1, username=admin_updated, password=...)
user1 == user3 ? false &lt;-- 证明了缓存被清空，拿到了新的对象
</code></pre>
<h4 id="3-企业级思考"><strong>3. 企业级思考</strong></h4>
<p>一级缓存非常有用，它能有效减少单个业务逻辑单元（例如一个Service方法内部）的数据库查询次数。但在典型的Web应用中，每个用户请求通常会创建一个新的<code>SqlSession</code>，执行完后就关闭。这意味着<strong>一级缓存无法跨请求共享数据</strong>。为了解决这个问题，二级缓存应运而生。</p>
<hr>
<h3 id="第二部分二级缓存-sqlsessionfactory级别"><strong>第二部分：二级缓存 (SqlSessionFactory级别)</strong></h3>
<h4 id="1-概念解析-1"><strong>1. 概念解析</strong></h4>
<ul>
<li><strong>别名</strong>：全局缓存 (Global Cache)。</li>
<li><strong>作用域 (Scope)</strong>：它的生命周期与 <code>SqlSessionFactory</code> 绑定，或者说它是在<strong>Mapper的命名空间Namespace</strong>级别共享的。这意味着，<strong>所有<code>SqlSession</code>都可以共享同一个Mapper的二级缓存</strong>。</li>
<li><strong>工作状态</strong>：<strong>默认关闭，需要手动开启</strong>。</li>
<li><strong>工作原理（核心）</strong>：
<ol>
<li>当一个<code>SqlSession</code>执行完查询并<strong>提交/关闭 (<code>commit</code>/<code>close</code></strong>)后，它的一级缓存中的数据会被转移到对应Mapper的二级缓存中。</li>
<li>另一个新的<code>SqlSession</code>来执行相同的查询时，它会先去二级缓存中查找数据。</li>
<li>如果找到了，就直接返回数据；如果没找到，再走“查询数据库 -&gt; 放入自己的一级缓存”的老路。</li>
</ol>
</li>
<li><strong>开启二级缓存的三个步骤（缺一不可）</strong>：
<ol>
<li>在<code>mybatis-config.xml</code>中开启全局缓存开关。</li>
<li>在需要缓存的<code>Mapper.xml</code>文件中添加<code>&lt;cache/&gt;</code>标签。</li>
<li>需要被缓存的实体类（POJO）<strong>必须实现 <code>java.io.Serializable</code> 接口</strong>。因为二级缓存可能将对象存储在硬盘或通过网络传输，这需要序列化。</li>
</ol>
</li>
</ul>
<h4 id="2-动手实践开启并验证二级缓存"><strong>2. 动手实践：开启并验证二级缓存</strong></h4>
<p><strong>修改代码 (在之前的基础上)</strong></p>
<ol>
<li>
<p><strong>修改 <code>mybatis-config.xml</code></strong>：</p>
<pre><code class="language-xml">&lt;configuration&gt;
    &lt;!-- 开启全局缓存开关 --&gt;
    &lt;settings&gt;
        &lt;setting name="cacheEnabled" value="true"/&gt;
    &lt;/settings&gt;
    &lt;!-- 其他配置... --&gt;
&lt;/configuration&gt;
</code></pre>
</li>
<li>
<p><strong>修改 <code>UserMapper.xml</code></strong>：</p>
<pre><code class="language-xml">&lt;mapper namespace="com.example.mapper.UserMapper"&gt;
    &lt;!-- 开启当前Mapper的二级缓存 --&gt;
    &lt;cache&gt;&lt;/cache&gt;
    &lt;!-- 其他SQL... --&gt;
&lt;/mapper&gt;
</code></pre>
</li>
<li>
<p><strong>修改 <code>User.java</code></strong>：</p>
<pre><code class="language-java">// src/main/java/com/example/entity/User.java
import java.io.Serializable; // 引入接口

@Data
public class User implements Serializable { // 实现Serializable接口
    // ... 内容不变
}
</code></pre>
</li>
<li>
<p><strong>创建 <code>L2CacheTest.java</code> (新的测试类)</strong>：</p>
<pre><code class="language-java">// src/main/java/com/example/test/L2CacheTest.java
package com.example.test;

import com.example.entity.User;
import com.example.mapper.UserMapper;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import java.io.IOException;
import java.io.InputStream;

public class L2CacheTest {
    public static void main(String[] args) throws IOException {
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

        System.out.println("--- 验证二级缓存 ---");

        User user1 = null;
        // 第一个 session
        try (SqlSession session1 = sqlSessionFactory.openSession(true)) {
            UserMapper mapper1 = session1.getMapper(UserMapper.class);
            System.out.println("Session 1: 第一次查询...");
            user1 = mapper1.findById(1);
            System.out.println(user1);
        } // session1关闭时，数据会从它的一级缓存刷新到二级缓存

        System.out.println("\nSession 1 已关闭。\n");

        User user2 = null;
        // 第二个 session
        try (SqlSession session2 = sqlSessionFactory.openSession(true)) {
            UserMapper mapper2 = session2.getMapper(UserMapper.class);
            System.out.println("Session 2: 再次查询相同数据...");
            user2 = mapper2.findById(1);
            System.out.println(user2);
        }

        System.out.println("\nuser1.equals(user2) ? " + user1.equals(user2));
        System.out.println("user1 == user2 ? " + (user1 == user2));
    }
}
</code></pre>
</li>
</ol>
<p><strong>预期输出与分析：</strong></p>
<pre><code>--- 验证二级缓存 ---
Session 1: 第一次查询...
User对象被创建了！(A new User object was created!) &lt;-- 第一个session查询，创建对象
User(id=1, username=admin_updated, password=...)

Session 1 已关闭。

Session 2: 再次查询相同数据...
User(id=1, username=admin_updated, password=...) &lt;-- 第二个session查询，没有打印“User对象被创建了”
                                                &lt;-- 这证明了数据来自缓存，而不是数据库！

user1.equals(user2) ? true   &lt;-- 内容相同
user1 == user2 ? false  &lt;-- 但对象不同！因为二级缓存返回的是序列化后再反序列化的副本，不是原对象。
</code></pre>
<p>这个<code>false</code>的结果是理解二级缓存的关键，它与一级缓存的<code>true</code>形成鲜明对比。</p>
<h4 id="3-企业级应用与思考"><strong>3. 企业级应用与思考</strong></h4>
<ul>
<li>
<p><strong>适用场景</strong>：二级缓存非常适合<strong>读多写少</strong>、<strong>数据不常变化</strong>的场景。</p>
<ul>
<li><strong>绝佳例子</strong>：系统配置表、国家/地区/省份代码表、商品分类信息、用户角色权限。这些数据被频繁读取，但很少修改。为它们开启二级缓存能极大地提升性能。</li>
<li><strong>不适用例子</strong>：商品库存、用户余额、订单状态。这些数据变化频繁，如果使用缓存，很容易出现数据不一致的问题。</li>
</ul>
</li>
<li>
<p><strong>缓存击穿与第三方缓存</strong>：Mybatis自带的二级缓存功能相对基础。在大型分布式系统中，为了解决缓存击穿、雪崩等问题，以及实现更精细的缓存控制（如设置过期时间），企业通常会整合专业的第三方缓存框架，如 <strong>Redis</strong> 或 <strong>Ehcache</strong>。</p>
<ul>
<li><strong>企业实践</strong>：在<code>Mapper.xml</code>的<code>&lt;cache&gt;</code>标签中，可以通过<code>type</code>属性指定使用Redis作为二级缓存的实现。这样做的好处是，缓存由独立的Redis服务管理，可以被多个应用实例共享，并且应用重启后缓存依然存在。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结与对比"><strong>总结与对比</strong></h3>
<table>
<thead>
<tr>
<th style="text-align: left">特性</th>
<th style="text-align: left">一级缓存 (L1)</th>
<th style="text-align: left">二级缓存 (L2)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left"><strong>作用域</strong></td>
<td style="text-align: left"><code>SqlSession</code></td>
<td style="text-align: left"><code>SqlSessionFactory</code> (或Mapper Namespace)</td>
</tr>
<tr>
<td style="text-align: left"><strong>生命周期</strong></td>
<td style="text-align: left">与<code>SqlSession</code>共存亡</td>
<td style="text-align: left">与应用共存亡</td>
</tr>
<tr>
<td style="text-align: left"><strong>默认状态</strong></td>
<td style="text-align: left"><strong>默认开启</strong>，无法关闭</td>
<td style="text-align: left"><strong>默认关闭</strong>，需手动开启</td>
</tr>
<tr>
<td style="text-align: left"><strong>共享性</strong></td>
<td style="text-align: left">不共享，<code>SqlSession</code>之间隔离</td>
<td style="text-align: left"><strong>所有<code>SqlSession</code>共享</strong></td>
</tr>
<tr>
<td style="text-align: left"><strong>数据一致性</strong></td>
<td style="text-align: left">强，DML操作自动清空</td>
<td style="text-align: left">弱，依赖于配置和DML刷新</td>
</tr>
<tr>
<td style="text-align: left"><strong>对象引用</strong></td>
<td style="text-align: left">返回<strong>同一个对象</strong> (<code>==</code>为<code>true</code>)</td>
<td style="text-align: left">返回<strong>对象的副本</strong> (反序列化，<code>==</code>为<code>false</code>)</td>
</tr>
<tr>
<td style="text-align: left"><strong>核心用途</strong></td>
<td style="text-align: left">优化单个业务流程内的重复查询</td>
<td style="text-align: left">优化跨业务、跨请求的全局热点数据查询</td>
</tr>
</tbody>
</table>
<p><strong>核心记忆点</strong>：<strong>缓存是性能和数据一致性之间的一种权衡。</strong> 一级缓存牺牲了小部分内存，换取了单个会话内的性能提升，且能保证强一致性。二级缓存牺牲了更强的实时一致性，换取了全局范围的巨大性能提升。理解这个核心思想，你就真正掌握了Mybatis的缓存机制。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.002777777777777778" data-date-updated="2025-07-02 17:20">2025-07-02 17:16</span>&nbsp;
<a href="https://www.cnblogs.com/qsmm">清明雨上~</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18961809);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18961809', targetLink: 'https://www.cnblogs.com/qsmm/p/18961809', title: 'Mybatis - 精巧的持久层框架-缓存机制的深刻理解' })">举报</a>
</div>
        