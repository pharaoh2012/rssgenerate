
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/many-bucket/p/18968134" title="å‘å¸ƒäº 2025-07-06 01:03">
    <span role="heading" aria-level="2">å¤©å¤©ç”¨lockï¼Œä¸å¥½å¥‡ä»–åˆ°åº•æ€ä¹ˆå·¥ä½œçš„å— â€”ä»ReentrantLock åˆ°AQS</span>
    

</a>

	</div>
	<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>æ–°æ‰‹å­¦ä¹ ï¼Œè‹¥æœ‰ä¸å¯¹ï¼Œæ¬¢è¿å¤§ä½¬ <s>è°ƒæ•™ğŸ¥°ğŸ¥°ğŸ¥°</s></p>
<h3 id="reentrantlock">ReentrantLock</h3>
<p>æˆ‘ä»¬ç»å¸¸ç”¨çš„ <code>*ReentrantLock*</code>æ˜¯å¹²ä»€ä¹ˆçš„å‘¢ æˆ‘è®¤ä¸ºè¿™æ˜¯ä¸€ä¸ªå‰å°/é—¨é¢ï¼ˆç±»ä¼¼è®¾è®¡æ¨¡å¼ä¸­çš„é—¨é¢æ¨¡å¼ï¼‰æ ¹æ®æˆ‘ä»¬çš„å…¥å‚åˆ›å»ºä¸€ä¸ª<code>FairSync</code> OR <code>NonfairSync</code> ã€‚<code>sync</code> æ‹…ä»»é”çš„lock()å’Œrelease()ã€‚</p>
<pre><code class="language-java">    private final Sync sync;
   
    public ReentrantLock() {
        sync = new NonfairSync();
    }

    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }

</code></pre>
<p>é‚£æœ‰äººå¯èƒ½å°±é—®äº†å•¥æ˜¯å…¬å¹³é”(<code>FairSync</code>)? å•¥æ˜¯éå…¬å¹³é”(<code>NonfairSync</code>)?</p>
<p>å°±æ‹¿å•†åœºè¯•åƒä¸¾ä¾‹å­ï¼Œå‰è€…å°±æ˜¯å¤§å®¶éƒ½å¥½å¥½æ’é˜Ÿï¼Œåè€…æ˜¯æ–°æ¥çš„çœ‹è¯•åƒå°æ ·è¿˜æœ‰ï¼Œç›´æ¥æ‹¿èµ°<strong>ä¸å‚ä¸æ’é˜Ÿ</strong>ï¼Œé‚£æ˜¾ç„¶åé¢çš„äººå°±ä¼š<em>é¥¥é¥¿</em> å•Šã€‚é‚£éå…¬å¹³é”æœ‰ä»€ä¹ˆæ„ä¹‰å‘¢ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œå½“å•†åœºäººæ»¡ä¸ºæ‚£äº†ï¼Œä½ å»æ’åˆ°è¯•åƒçš„åé¢éƒ½è¦æŒ¤è¿‡æ¥ï¼ŒæŒ¤è¿‡å»ã€‚æ˜¾ç„¶ä½ åœ¨å…¨å±€ä¸Šå½±å“äº†å•†åœºçš„å®¢æµåŠ¨ï¼Œå¦‚æœä½ ç›´æ¥å» <em>å·è¢­ï¼<s>(é©¬ä¿å›½éŸ³)</s></em> æ˜¾ç„¶åœ¨å•†åœºå…¨å±€ä¸Šæ¥è¯´æ˜¯æœ€ä¼˜çš„ã€‚</p>
<h2 id="åŠ é”">åŠ é”</h2>
<h3 id="aqså…¥é˜Ÿ">AQSå…¥é˜Ÿ</h3>
<p>å› ä¸º<code>FairSync</code> å’Œ<code>NonfairSync</code> å·®çš„ä¸æ˜¯å¾ˆå¤§ï¼Œ æˆ‘ä»¬å°±ç€é‡è®²<code>NonfairSync</code></p>
<p>é‚£ä½ è¯´é‚£æˆ‘ç¼ºçš„è¿™å—<code>FairSync</code>è°ç»™æˆ‘è¡¥å•Šï¼Œ<em>æƒ³è¦å°±è‡ªå·±æ¥æ‹¿( æŒ‡è‡ªå·±çœ‹æºç )  <s>ç»´å‰å°”éŸ³</s></em></p>
<pre><code class="language-java">    
//java.util.concurrent.locks.ReentrantLock
    static final class NonfairSync extends Sync {
        private static final long serialVersionUID = 7316153563782823691L;

        final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
</code></pre>
<p>å¯è§å¦‚æœCASæˆåŠŸçº¿ç¨‹å°±ç›´æ¥è·å¾—é”äº†ï¼Œä¸æˆåŠŸå°±èµ°äº† <code>acquire()</code> å› ä¸º<code>Sync extends AbstractQueuedSynchronizer</code>è®©æˆ‘ä»¬æ¥çœ‹çœ‹<code>acquire()</code></p>
<pre><code class="language-java">// java.util.concurrent.locks.AbstractQueuedSynchronizer
     public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
</code></pre>
<p><code>tryAcquire()</code> è·å–é”å¤±è´¥è¿›å…¥AQSç­‰å¾…é˜Ÿåˆ—</p>
<p>AQSç»ˆäºæ˜¯éœ²å‡ºé¸¡è„šäº†<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code></p>
<p>AQSï¼ˆAbstractQueuedSynchronizerï¼‰æŠ½è±¡é˜Ÿåˆ—åŒæ­¥å™¨ï¼Œåå­—æ˜¯ä¸æ˜¯å¾ˆé«˜å¤§ä¸Šï¼Œæˆ‘ä»¬åˆ«ç®¡</p>
<p>å°±æ˜¯å•†åœºè€å¤§çˆ·ã€è€å¤§å¦ˆæ’é˜Ÿè´­ç‰©ï¼ˆå…ˆè¿›å…ˆå‡ºçš„åŒå‘é“¾è¡¨ï¼‰ã€‚</p>
<p>è®©æˆ‘ä»¬çœ‹çœ‹nodeå…·æœ‰çš„å±æ€§</p>
<pre><code class="language-java">    static final class Node {
        // å…±æœ‰é”ï¼Ÿ
        static final Node SHARED = new Node();
        // ç‹¬å é”ï¼Ÿ
        static final Node EXCLUSIVE = null;

        // çº¿ç¨‹è¢«å–æ¶ˆ
        static final int CANCELLED =  1;
        // çº¿ç¨‹å¤„äºæ¿€æ´»æ€
        static final int SIGNAL    = -1;
        // çº¿ç¨‹åœ¨ç­‰å¾…ä¸­
        static final int CONDITION = -2;
        /**
         * waitStatus value to indicate the next acquireShared should
         * unconditionally propagate
         */
        static final int PROPAGATE = -3;

</code></pre>
<p>è®©æˆ‘ä»¬å†çœ‹çœ‹<code>addWaiter()</code> é€šè¿‡CASç¡®ä¿æˆåŠŸåŠ å…¥æœ€åä¸€ä¸ªèŠ‚ç‚¹ã€‚</p>
<pre><code class="language-java">    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);   //  å¯¹AQSè¿›è¡Œåˆå§‹åŒ–å†åŠ å…¥
        return node;
    }
</code></pre>
<p><code>enq()</code> å¯¹é˜Ÿåˆ—è¿›è¡Œåˆå§‹åŒ–ï¼Œæ·»åŠ ä¸€ä¸ªè™šæ‹ŸèŠ‚ç‚¹ï¼ˆé¿å…ç©ºæŒ‡é’ˆï¼‰</p>
<pre><code class="language-java">    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
</code></pre>
<h3 id="aqså‡ºé˜Ÿ">AQSå‡ºé˜Ÿ</h3>
<p>è®©æˆ‘ä»¬å›åˆ° <code>acquire()</code></p>
<pre><code class="language-java">    public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
</code></pre>
<p>ä¹°èœå¤§å¦ˆä¹ŸæŒºæ€¥çš„ï¼Œè¦æ’é˜Ÿå°±ä¼šå‚¬å‰é¢å¿«ç‚¹ï¼Œäºæ˜¯æ‹æ‹å‰é¢çš„äººï¼Œè¯´å¾€å‰å‚¬ä¸€ä¸‹ã€‚ï¼ˆå°‘æ•°æƒ…å†µï¼‰å‰é¢çš„äººä¹Ÿå¾ˆæ€¥ï¼Œçœ‹ç€æ—¶é—´æ¥ä¸åŠçƒ§èœäº†ï¼Œå°±è‡ªæš´è‡ªå¼ƒï¼Œç›´æ¥ç¦»å¼€äº†ï¼Œç©ºå‡ºäº†ä½ç½®ã€‚</p>
<pre><code class="language-java">    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
            
        // å¤–éƒ¨ä¸­æ–­ï¼Œæˆ–çº¿ç¨‹å–æ¶ˆç­‰å¾…
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
</code></pre>
<p>åé¢çš„äººçœ‹åˆ°å‰é¢æœ‰ç©ºä½ï¼Œå°±å¾€å‰èµ°å†å‚¬å‰é¢çš„äººã€‚çœ‹åˆ°å‰é¢çš„äººå·²ç»åœ¨å‚¬å‰é¢çš„äººï¼Œä»–å°±ä¸å‚¬äº†ï¼Œå‚¬ç©ä¹‹åè‡ªå·±å°±èƒ½å¾…æœºäº†ï¼ˆå¹²ç€æ€¥ä¹Ÿæ²¡ç”¨ï¼‰ã€‚</p>
<p>ä¸ºä»€ä¹ˆä¼š  <em>çœ‹åˆ°å‰é¢çš„äººå·²ç»åœ¨å‚¬å‰é¢çš„äºº</em> å¯èƒ½æœ‰ä¸¤ä¸ªèŠ‚ç‚¹è¢«åŒæ—¶åŠ å…¥</p>
<pre><code class="language-java">    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)// å‰é¢çš„äººå·²ç»åœ¨é—®äº†
            return true;
        if (ws &gt; 0) {        // å–æ¶ˆèŠ‚ç‚¹ï¼Œç©ºå‡ºä½ç½®ï¼Œå¾€å‰æŒª
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &gt; 0);
            pred.next = node;
        } else {
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
</code></pre>
<h2 id="è§£é”">è§£é”</h2>
<p>æˆ‘ä»¬æ¥çœ‹çœ‹é”çš„é‡Šæ”¾é˜Ÿåˆ—é˜Ÿåˆ—ä¸ºç©ºåˆ™è°ƒç”¨<code>unparkSuccessor(h)</code> ï¼Œä¸ºä»€ä¹ˆ waitStateä»¥ç­‰äº0åšæ ‡è®°ï¼Œä¸”çœ‹ä¸‹æ–‡</p>
<pre><code class="language-java">    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null &amp;&amp; h.waitStatus != 0) // æ£€æŸ¥AQSæ˜¯å¦åˆå§‹åŒ–ï¼Œæˆ–é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
</code></pre>
<p>waitStateç­‰äº0å¯ç®€å•çœ‹åšï¼Œå·²ç»å®Œæˆäº†ä»–ä½œä¸ºè§£é”ä¿¡å·çš„èŒè´£ï¼ŒåŒæ—¶è¿™å’Œ -1æ˜¯ä¸ä¸€æ ·çš„ï¼Œ</p>
<p>-1 æ˜¯æœªçŸ¥çš„å¾€å‰å‚¬ï¼ˆä¸çŸ¥é“å‰é¢å¥½æ²¡å¥½ï¼‰ï¼Œ0æ˜¯è‚¯å®šçš„è¯´å‰é¢æœ‰ä¸€ä¸ªç©ºä½ï¼Œå¹¶ä¸”æ˜¯headæŒ‡é’ˆè‡ªå‘çš„ï¼Œä¸ä¼šä¼ é€’ã€‚</p>
<pre><code class="language-java">private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws &lt; 0)
        compareAndSetWaitStatus(node, ws, 0); // é‡ç½® waitStatusä¸º 0
    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) // å¦‚æœä½ è§‚å¯Ÿåˆ°äº†è¿™æ®µçš„å¥‡æ€ªä¹‹å¤„ï¼Œæˆ‘ä¹Ÿæ²¡åŠæ³•è§£é‡Šï¼Œçœ‹äº†æ–‡ç« ä¹Ÿçœ‹åˆ°ä¸æ˜¯å¾ˆæ˜ç™½ï¼Œå°±ä¸è¯¯å¯¼äººäº†ã€‚ç›¸å…³å†…å®¹åœ¨ java.util.concurrent.locks.AbstractQueuedSynchronizer#cancelAcquire 
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread); // å”¤é†’ä¸‹ä¸€ä¸ªçº¿ç¨‹
}
</code></pre>
<p>é˜Ÿåˆ—è¢« <code>unpark()</code> å”¤é†’ï¼Œé˜Ÿä¼å¯ä»¥å‘å‰ç§»åŠ¨äº†</p>
<p>å¦‚æœè§‰å¾—æœ‰å¸®åˆ°ä½ </p>
<p>ç‚¹ä¸ªèµå†èµ°å‘—baby ğŸ¥°ğŸ¥°ğŸ¥°</p>
<hr>
<p><em>å‚è€ƒæ–‡ç« ï¼š</em></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651749434&amp;idx=3&amp;sn=5ffa63ad47fe166f2f1a9f604ed10091&amp;chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&amp;scene=38#wechat_redirect" target="_blank" rel="noopener nofollow">ä¸å¯ä¸è¯´çš„Javaâ€œé”â€äº‹</a><br>
<a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener nofollow">ä»ReentrantLockçš„å®ç°çœ‹AQSçš„åŸç†åŠåº”ç”¨</a></p>

</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.5833333333333334" data-date-updated="2025-07-06 15:03">2025-07-06 01:03</span>&nbsp;
<a href="https://www.cnblogs.com/many-bucket">crhl-yy</a>&nbsp;
é˜…è¯»(<span id="post_view_count">46</span>)&nbsp;
è¯„è®º(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18968134);return false;">æ”¶è—</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18968134', targetLink: 'https://www.cnblogs.com/many-bucket/p/18968134', title: 'å¤©å¤©ç”¨lockï¼Œä¸å¥½å¥‡ä»–åˆ°åº•æ€ä¹ˆå·¥ä½œçš„å— â€”ä»ReentrantLock åˆ°AQS' })">ä¸¾æŠ¥</a>
</div>
