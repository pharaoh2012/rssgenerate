
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18855272" title="发布于 2025-04-30 13:12">
    <span role="heading" aria-level="2">【深入解析AQS】从设计模式到ReentrantLock实现再到自定义锁</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="深入解析aqs设计模式reentrantlock实现与自定义锁开发">深入解析AQS：设计模式、ReentrantLock实现与自定义锁开发</h1>
<h2 id="一模板方法模式aqs的架构基石">一、模板方法模式：AQS的架构基石</h2>
<h3 id="11-模式核心思想">1.1 模式核心思想</h3>
<p>模板方法模式通过<strong>固定算法骨架+可变实现细节</strong>的设计，实现了代码复用与扩展性的平衡。AQS采用这种模式，将同步器的核心流程（如线程排队、阻塞唤醒）固化在父类，仅将资源获取/释放的逻辑通过抽象方法交给子类实现。</p>
<p><strong>设计优势：</strong></p>
<ul>
<li><strong>保证正确性</strong>：关键同步流程不可修改</li>
<li><strong>提高复用</strong>：通用逻辑只需实现一次</li>
<li><strong>便于扩展</strong>：子类只需关注业务逻辑</li>
</ul>
<h3 id="12-完整代码示例">1.2 完整代码示例</h3>
<pre><code class="language-java">// 模板类定义
abstract class BeverageMaker {
    // 模板方法（final防止重写）
    public final void makeBeverage() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) {
            addCondiments();
        }
    }
    
    // 具体方法（通用步骤）
    private void boilWater() {
        System.out.println("煮沸水");
    }
    
    private void pourInCup() {
        System.out.println("倒入杯中");
    }
    
    // 抽象方法（子类必须实现）
    protected abstract void brew();
    protected abstract void addCondiments();
    
    // 钩子方法（子类可选覆盖）
    protected boolean customerWantsCondiments() {
        return true;
    }
}

// 具体实现类
class TeaMaker extends BeverageMaker {
    @Override
    protected void brew() {
        System.out.println("浸泡茶叶5分钟");
    }

    @Override
    protected void addCondiments() {
        System.out.println("加入柠檬片");
    }
    
    @Override
    protected boolean customerWantsCondiments() {
        return false; // 茶不需要调料
    }
}
</code></pre>
<p><strong>关键点说明：</strong></p>
<ol>
<li><code>makeBeverage()</code>定义了不可变的制作流程</li>
<li><code>brew()</code>和<code>addCondiments()</code>是可变部分，由子类实现</li>
<li><code>customerWantsCondiments()</code>是钩子方法，提供策略扩展点</li>
</ol>
<h3 id="13-aqs中的模板模式实现">1.3 AQS中的模板模式实现</h3>
<p>AQS将同步操作抽象为模板方法：</p>
<pre><code class="language-java">public abstract class AbstractQueuedSynchronizer {
    // 获取资源的模板方法
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;  // 尝试获取（子类实现）
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    
    // 由子类实现的获取逻辑
    protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
    
    // 已实现的通用方法
    private Node addWaiter(Node mode) {
        // 实现节点入队逻辑...
    }
    
    final boolean acquireQueued(Node node, int arg) {
        // 实现队列中获取资源的逻辑...
    }
}
</code></pre>
<p><strong>设计精妙之处：</strong></p>
<ul>
<li><code>acquire()</code>封装了完整的获取资源流程</li>
<li>子类只需关注<code>tryAcquire</code>的核心逻辑</li>
<li>线程排队、阻塞唤醒等复杂操作由AQS统一处理</li>
</ul>
<h2 id="二reentrantlock与aqs的深度整合">二、ReentrantLock与AQS的深度整合</h2>
<h3 id="21-整体架构设计">2.1 整体架构设计</h3>
<p>ReentrantLock通过内部类继承AQS，实现锁的核心功能：</p>
<div class="mermaid">classDiagram
    class ReentrantLock {
        -Sync sync
        +lock()
        +unlock()
    }
    
    class Sync {
        &lt;&lt;abstract&gt;&gt;
        +nonfairTryAcquire()
        +tryRelease()
    }
    
    class NonfairSync {
        +lock()
        +tryAcquire()
    }
    
    class FairSync {
        +tryAcquire()
    }
    
    ReentrantLock --&gt; Sync
    Sync &lt;|-- NonfairSync
    Sync &lt;|-- FairSync
    Sync --&gt; AQS
</div><h3 id="22-关键源码解析">2.2 关键源码解析</h3>
<h4 id="非公平锁实现">非公平锁实现：</h4>
<pre><code class="language-java">static final class NonfairSync extends Sync {
    // 非公平获取锁
    final void lock() {
        if (compareAndSetState(0, 1))  // 先尝试快速获取
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);  // 进入AQS排队流程
    }
    
    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}

// Sync中的通用非公平尝试
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {  // 锁未被持有
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {  // 重入逻辑
        int nextc = c + acquires;
        if (nextc &lt; 0) throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
</code></pre>
<p><strong>实现特点：</strong></p>
<ol>
<li><strong>快速路径</strong>：先直接尝试CAS获取锁，避免排队开销</li>
<li><strong>重入支持</strong>：通过检查当前线程和状态计数实现</li>
<li><strong>非公平性</strong>：新请求线程可能插队获取锁</li>
</ol>
<h4 id="公平锁实现差异">公平锁实现差异：</h4>
<pre><code class="language-java">static final class FairSync extends Sync {
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (!hasQueuedPredecessors() &amp;&amp;  // 关键区别：检查队列
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        // 重入逻辑与非公平锁相同...
    }
}
</code></pre>
<p><strong>公平性保证：</strong></p>
<ul>
<li><code>hasQueuedPredecessors()</code>检查是否有更早等待的线程</li>
<li>严格按照CLH队列顺序获取锁</li>
<li>吞吐量通常低于非公平锁，但避免线程饥饿</li>
</ul>
<h3 id="23-状态管理机制">2.3 状态管理机制</h3>
<p>AQS使用<code>volatile int state</code>字段记录同步状态，ReentrantLock中表示：</p>
<ul>
<li><strong>0</strong>：锁未被任何线程持有</li>
<li><strong>&gt;0</strong>：锁被持有，数值表示重入次数</li>
</ul>
<p>配套原子操作方法：</p>
<pre><code class="language-java">protected final int getState() {
    return state;
}

protected final void setState(int newState) {
    state = newState;
}

protected final boolean compareAndSetState(int expect, int update) {
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
</code></pre>
<h2 id="三基于aqs实现自定义锁">三、基于AQS实现自定义锁</h2>
<h3 id="31-完整自定义锁实现">3.1 完整自定义锁实现</h3>
<pre><code class="language-java">import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

/**
 * 基于AQS的简单互斥锁（不可重入）
 */
public class SimpleMutexLock implements Lock {
    private final Sync sync = new Sync();

    // 内部同步器
    private static class Sync extends AbstractQueuedSynchronizer {
        // 尝试获取锁
        @Override
        protected boolean tryAcquire(int acquires) {
            if (acquires != 1) throw new IllegalArgumentException();
            if (compareAndSetState(0, 1)) {  // CAS保证原子性
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        // 尝试释放锁
        @Override
        protected boolean tryRelease(int releases) {
            if (releases != 1) throw new IllegalArgumentException();
            if (getState() == 0) throw new IllegalMonitorStateException();
            setExclusiveOwnerThread(null);
            setState(0);  // 不需要CAS，只有持有线程能调用
            return true;
        }

        // 是否被当前线程独占
        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        // 创建条件变量
        Condition newCondition() {
            return new ConditionObject();
        }
    }

    // ========== Lock接口实现 ==========
    @Override
    public void lock() {
        sync.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    @Override
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        sync.release(1);
    }

    @Override
    public Condition newCondition() {
        return sync.newCondition();
    }

    // ========== 扩展方法 ==========
    public boolean isLocked() {
        return sync.isHeldExclusively();
    }
    
    public boolean hasQueuedThreads() {
        return sync.hasQueuedThreads();
    }
}
</code></pre>
<p><strong>实现要点：</strong></p>
<ol>
<li><strong>状态定义</strong>：0表示未锁定，1表示锁定</li>
<li><strong>不可重入</strong>：不检查当前线程是否已持有锁</li>
<li><strong>条件变量</strong>：直接复用AQS的ConditionObject</li>
<li><strong>线程安全</strong>：CAS操作保证<code>tryAcquire</code>的原子性</li>
</ol>
<h3 id="32-可重入锁改造">3.2 可重入锁改造</h3>
<p>修改Sync内部类即可实现可重入：</p>
<pre><code class="language-java">private static class Sync extends AbstractQueuedSynchronizer {
    @Override
    protected boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {  // 重入判断
            int nextc = c + acquires;
            if (nextc &lt; 0) throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }

    @Override
    protected boolean tryRelease(int releases) {
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {  // 完全释放
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }
}
</code></pre>
<p><strong>关键修改点：</strong></p>
<ol>
<li>增加当前线程检查实现重入</li>
<li>通过状态计数记录重入次数</li>
<li>只有计数归零时才完全释放锁</li>
</ol>
<h3 id="33-完整测试用例">3.3 完整测试用例</h3>
<pre><code class="language-java">public class SimpleMutexLockTest {
    public static void main(String[] args) throws InterruptedException {
        // 基础功能测试
        testBasicOperation();
        
        // 并发安全测试
        testConcurrentAccess();
        
        // 不可重入性测试
        testNonReentrant();
    }

    private static void testBasicOperation() {
        SimpleMutexLock lock = new SimpleMutexLock();
        assert !lock.isLocked() : "初始状态应该未锁定";
        
        lock.lock();
        try {
            assert lock.isLocked() : "锁定后状态应该为true";
            assert !lock.tryLock() : "不可重入锁应获取失败";
        } finally {
            lock.unlock();
        }
    }

    private static void testConcurrentAccess() throws InterruptedException {
        final int THREADS = 5;
        final SimpleMutexLock lock = new SimpleMutexLock();
        final AtomicInteger counter = new AtomicInteger();
        final CountDownLatch startLatch = new CountDownLatch(1);
        final CountDownLatch endLatch = new CountDownLatch(THREADS);

        ExecutorService executor = Executors.newFixedThreadPool(THREADS);
        for (int i = 0; i &lt; THREADS; i++) {
            executor.execute(() -&gt; {
                try {
                    startLatch.await();
                    lock.lock();
                    try {
                        counter.incrementAndGet();
                        Thread.sleep(100);  // 模拟操作
                    } finally {
                        lock.unlock();
                        endLatch.countDown();
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        startLatch.countDown();
        endLatch.await();
        assert counter.get() == THREADS : "所有线程应该都执行了";
        executor.shutdown();
    }

    private static void testNonReentrant() {
        SimpleMutexLock lock = new SimpleMutexLock();
        lock.lock();
        try {
            // 会阻塞在这里，因为是不可重入锁
            boolean acquired = lock.tryLock(); 
            assert !acquired : "不可重入锁不应再次获取成功";
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<h2 id="四核心知识总结">四、核心知识总结</h2>
<h3 id="41-模板方法模式在aqs中的应用">4.1 模板方法模式在AQS中的应用</h3>
<ol>
<li>
<p><strong>固定流程</strong>：</p>
<ul>
<li><code>acquire()</code>/<code>release()</code>定义了标准的获取/释放资源流程</li>
<li>包含线程排队、阻塞唤醒等通用逻辑</li>
</ul>
</li>
<li>
<p><strong>可变部分</strong>：</p>
<ul>
<li><code>tryAcquire()</code>/<code>tryRelease()</code>由子类实现</li>
<li>决定如何获取和释放资源</li>
</ul>
</li>
<li>
<p><strong>设计优势</strong>：</p>
<ul>
<li>保证同步行为的正确性</li>
<li>提高代码复用率</li>
<li>支持多种同步策略</li>
</ul>
</li>
</ol>
<h3 id="42-reentrantlock实现要点">4.2 ReentrantLock实现要点</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>非公平锁</th>
<th>公平锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取顺序</td>
<td>允许插队</td>
<td>严格FIFO</td>
</tr>
<tr>
<td>吞吐量</td>
<td>高</td>
<td>较低</td>
</tr>
<tr>
<td>实现关键</td>
<td>直接尝试CAS</td>
<td>先检查队列</td>
</tr>
<tr>
<td>适用场景</td>
<td>大多数情况</td>
<td>避免饥饿</td>
</tr>
</tbody>
</table>
<h3 id="43-自定义锁开发原则">4.3 自定义锁开发原则</h3>
<ol>
<li><strong>明确状态语义</strong>：定义state字段的含义</li>
<li><strong>保证线程安全</strong>：CAS操作保护关键状态</li>
<li><strong>合理选择特性</strong>：根据需求决定是否支持重入、公平性等</li>
<li><strong>充分测试</strong>：验证并发场景下的正确性</li>
</ol>
<h2 id="结语">结语</h2>
<p>通过本文的系统讲解，我们完成了从设计模式理论到AQS框架分析，再到具体锁实现的完整学习路径。理解这些内容后，开发者可以：</p>
<ol>
<li>更深入地理解Java并发包的设计思想</li>
<li>根据特殊需求实现自定义同步器</li>
<li>更好地选择和使用Java提供的并发工具</li>
</ol>
<p>建议读者结合文中的代码示例进行实践，通过修改和调试加深对AQS工作机制的理解。对于生产环境，除非有特殊需求，否则应优先使用Java标准库提供的并发工具。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.38471654185648146" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-30 13:12">2025-04-30 13:12</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18855272);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18855272', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18855272', title: '【深入解析AQS】从设计模式到ReentrantLock实现再到自定义锁' })">举报</a>
</div>
        