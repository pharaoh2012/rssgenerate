<!----> <meta itemprop="headline" content="在线人数实时推送？WebSocket 太重，SSE 正合适 🎯🎯🎯"> <meta itemprop="keywords" content="前端,JavaScript,面试"> <meta itemprop="datePublished" content="2025-04-14T06:23:02.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Moment"> <meta itemprop="url" content="https://juejin.cn/user/3782764966460398"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            在线人数实时推送？WebSocket 太重，SSE 正合适 🎯🎯🎯
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3782764966460398/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Moment
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-04-14T06:23:02.000Z" title="Mon Apr 14 2025 06:23:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-04-14
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    8,864
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><blockquote>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.codecrack.cn%2Fzh" target="_blank" title="https://www.codecrack.cn/zh" ref="nofollow noopener noreferrer">面试导航</a> 是一个专注于前、后端技术学习和面试准备的 <strong>免费</strong> 学习平台，提供系统化的技术栈学习，深入讲解每个知识点的核心原理，帮助开发者构建全面的技术体系。平台还收录了大量真实的校招与社招面经，帮助你快速掌握面试技巧，提升求职竞争力。如果你想加入我们的交流群，欢迎通过微信联系：<code>yunmz777</code>。</p>
</blockquote>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5522900b291a4882a6030709227b4267~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9tZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1752440549&amp;x-signature=x2MEopKT4GsWI%2FhdCBdCKn6v8Bw%3D" alt="20250310220634" loading="lazy"></p>
<p>有些项目要统计在线人数，其实更多是为了“营造热闹气氛”。比如你进个聊天室，看到“有 120 人在看”，是不是感觉这个地方挺活跃的？这就是一种“社交证明”，让用户觉得：哇，这个地方挺火，值得留下来。而且对产品来说，这也能提高用户的参与感和粘性。</p>
<h2 data-id="heading-0">有哪些实现方式？为啥我最后选了 SSE？</h2>
<p>在考虑怎么实现“统计在线人数并实时显示”这个功能时，其实我一开始也没直接想到要用 SSE。毕竟实现方式有好几种，咱们不妨一步步分析一下常见的几种做法，看看它们各自的优缺点，这样最后为啥选 SSE，自然就水落石出了。</p>
<h3 data-id="heading-1">❌ 第一种想法：轮询（Polling）</h3>
<p>最容易想到的方式就是：<strong>我定时去问服务器，“现在有多少人在线？”</strong><br>
比如用 <code>setInterval</code> 每隔 3 秒发一次 AJAX 请求，服务器返回一个数字，前端拿到之后更新页面。</p>
<p>听起来没毛病，对吧？确实简单，写几行代码就能跑起来。</p>
<p>但问题也很快暴露了：</p>
<ul>
<li>
<p>就算在线人数 10 分钟都没变，客户端也在一直请求，完全没必要，<strong>非常低效</strong></p>
</li>
<li>
<p>这种方式根本做不到真正的“实时”，除非你每秒钟请求一次（但那样服务器压力就爆炸了）</p>
</li>
<li>
<p>每个用户都发请求，这压力不是乘以用户数么？人一多，服务器直接“变卡”</p>
</li>
</ul>
<p>所以轮询虽然简单，但在“实时在线人数”这种场景下，<strong>不管性能、实时性还是用户体验，都不够理想</strong>。</p>
<h3 data-id="heading-2">❌ 第二种方案：WebSocket</h3>
<p>再往上一个层级，很多人就会想到 <strong>WebSocket</strong>，这是一个可以实现双向通信的技术，听起来非常高级。</p>
<p>确实，WebSocket 特别适合<strong>聊天室、游戏、协同编辑器</strong>这种实时互动场景——客户端和服务端随时可以互相发消息，效率高、延迟低。</p>
<p>但问题也来了：<strong>我们真的需要那么重的武器吗？</strong></p>
<ul>
<li>
<p>我只是要服务器把“当前在线人数”这个数字发给页面，<strong>不需要客户端发什么消息回去</strong></p>
</li>
<li>
<p>WebSocket 的连接、心跳、断线重连、资源管理……这套机制确实强大，但同时也让开发复杂度和服务器资源占用都提高了不少</p>
</li>
<li>
<p>而且你要部署 WebSocket 服务的话，很多时候还得考虑反向代理支持、跨域、协议升级等问题</p>
</li>
</ul>
<p>总结一句话：<strong>WebSocket 能干的活太多，反而不适合干这么简单的一件事</strong>。</p>
<h3 data-id="heading-3">✅ 最后选择：SSE（Server-Sent Events）</h3>
<p>然后我就想到了 SSE。</p>
<p>SSE 是 HTML5 提供的一个非常适合“服务端单向推送消息”的方案，浏览器用 <code>EventSource</code> 这个对象就能轻松建立连接，服务端只需要按照特定格式往客户端写数据就能实时推送，非常简单、非常轻量。</p>
<p>对于“统计在线人数”这种场景来说，它刚好满足所有需求：</p>
<ul>
<li>
<p>客户端不需要发消息，只要能“听消息”就够了 —— SSE 就是只读的推送流，正合适</p>
</li>
<li>
<p>我只需要服务端一有变化（比如某个用户断开连接），就通知所有人当前在线人数是多少 —— SSE 的广播机制就很好实现这一点</p>
</li>
<li>
<p>而且浏览器断线后会自动重连，<strong>你不需要写额外的心跳或者重连逻辑，直接爽用</strong></p>
</li>
<li>
<p>它用的是普通的 HTTP 协议，部署和 Nginx 配合也没啥问题</p>
</li>
</ul>
<p>当然它也不是没有缺点，比如 IE 不支持（但现在谁还用 IE 啊），以及它是单向通信（不过我们压根也不需要双向）。</p>
<p>所以综合来看，<strong>SSE 就是这个功能的“刚刚好”方案：轻量、简单、稳定、足够用。</strong></p>
<h2 data-id="heading-4">项目实战</h2>
<p>首先我们先贴上后端的代码，后端我们使用的是 NextJs 提供的 API 来实现的后端接口，首先我们先来看看我们的辅助方法：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 单例模式实现的在线用户计数器</span>
<span class="hljs-comment">// 使用Symbol确保私有属性</span>
<span class="hljs-keyword">const</span> _connections = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">"connections"</span>);
<span class="hljs-keyword">const</span> _clients = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">"clients"</span>);
<span class="hljs-keyword">const</span> _lastCleanup = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">"lastCleanup"</span>);
<span class="hljs-keyword">const</span> _maxInactiveTime = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">"maxInactiveTime"</span>);
<span class="hljs-keyword">const</span> _connectionTimes = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">"connectionTimes"</span>);

<span class="hljs-comment">// 创建一个单例计数器</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionCounter</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">ConnectionCounter</span>;
  <span class="hljs-keyword">private</span> [_connections]: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">private</span> [_clients]: <span class="hljs-title class_">Set</span>&lt;<span class="hljs-function">(<span class="hljs-params">count: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  <span class="hljs-keyword">private</span> [_lastCleanup]: <span class="hljs-built_in">number</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
  <span class="hljs-comment">// 默认10分钟未活动的连接将被清理</span>
  <span class="hljs-keyword">private</span> [_maxInactiveTime]: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
  <span class="hljs-comment">// 跟踪连接ID和它们的最后活动时间</span>
  <span class="hljs-keyword">private</span> [_connectionTimes]: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 防止外部直接实例化</span>
  }

  <span class="hljs-comment">// 获取单例实例</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(): <span class="hljs-title class_">ConnectionCounter</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">ConnectionCounter</span>.<span class="hljs-property">instance</span>) {
      <span class="hljs-title class_">ConnectionCounter</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionCounter</span>();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ConnectionCounter</span>.<span class="hljs-property">instance</span>;
  }

  <span class="hljs-comment">// 生成唯一连接ID</span>
  <span class="hljs-title function_">generateConnectionId</span>(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>().<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>) + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>).<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);
  }

  <span class="hljs-comment">// 添加新连接</span>
  <span class="hljs-title function_">addConnection</span>(<span class="hljs-attr">connectionId</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">number</span> {
    <span class="hljs-variable language_">this</span>[_connectionTimes].<span class="hljs-title function_">set</span>(connectionId, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());
    <span class="hljs-variable language_">this</span>[_connections]++;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">broadcastCount</span>();

    <span class="hljs-comment">// 如果活跃连接超过100或上次清理已经超过5分钟，执行清理</span>
    <span class="hljs-keyword">if</span> (
      <span class="hljs-variable language_">this</span>[_connectionTimes].<span class="hljs-property">size</span> &gt; <span class="hljs-number">100</span> ||
      <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - <span class="hljs-variable language_">this</span>[_lastCleanup] &gt; <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>
    ) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cleanupStaleConnections</span>();
    }

    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[_connections];
  }

  <span class="hljs-comment">// 移除连接</span>
  <span class="hljs-title function_">removeConnection</span>(<span class="hljs-attr">connectionId</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">number</span> {
    <span class="hljs-comment">// 如果连接ID存在则移除</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>[_connectionTimes].<span class="hljs-title function_">has</span>(connectionId)) {
      <span class="hljs-variable language_">this</span>[_connectionTimes].<span class="hljs-title function_">delete</span>(connectionId);
      <span class="hljs-variable language_">this</span>[_connections] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>[_connections] - <span class="hljs-number">1</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">broadcastCount</span>();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[_connections];
  }

  <span class="hljs-comment">// 更新连接的活动时间</span>
  <span class="hljs-title function_">updateConnectionActivity</span>(<span class="hljs-attr">connectionId</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>[_connectionTimes].<span class="hljs-title function_">has</span>(connectionId)) {
      <span class="hljs-variable language_">this</span>[_connectionTimes].<span class="hljs-title function_">set</span>(connectionId, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());
    }
  }

  <span class="hljs-comment">// 清理长时间不活跃的连接</span>
  <span class="hljs-title function_">cleanupStaleConnections</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    <span class="hljs-variable language_">this</span>[_lastCleanup] = now;

    <span class="hljs-keyword">let</span> removedCount = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>[_connectionTimes].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">lastActive, connectionId</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (now - lastActive &gt; <span class="hljs-variable language_">this</span>[_maxInactiveTime]) {
        <span class="hljs-variable language_">this</span>[_connectionTimes].<span class="hljs-title function_">delete</span>(connectionId);
        removedCount++;
      }
    });

    <span class="hljs-keyword">if</span> (removedCount &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-variable language_">this</span>[_connections] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>[_connections] - removedCount);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">broadcastCount</span>();
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Cleaned up <span class="hljs-subst">${removedCount}</span> stale connections`</span>);
    }
  }

  <span class="hljs-comment">// 获取当前连接数</span>
  <span class="hljs-title function_">getConnectionCount</span>(): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[_connections];
  }

  <span class="hljs-comment">// 订阅计数更新</span>
  <span class="hljs-title function_">subscribeToUpdates</span>(<span class="hljs-attr">callback</span>: <span class="hljs-function">(<span class="hljs-params">count: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>[_clients].<span class="hljs-title function_">add</span>(callback);
    <span class="hljs-comment">// 立即返回当前计数</span>
    <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>[_connections]);

    <span class="hljs-comment">// 返回取消订阅函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>[_clients].<span class="hljs-title function_">delete</span>(callback);
    };
  }

  <span class="hljs-comment">// 广播计数更新到所有客户端</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">broadcastCount</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>[_clients].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>[_connections]);
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-comment">// 如果回调失败，从集合中移除</span>
        <span class="hljs-variable language_">this</span>[_clients].<span class="hljs-title function_">delete</span>(callback);
      }
    });
  }
}

<span class="hljs-comment">// 导出便捷函数</span>
<span class="hljs-keyword">const</span> counter = <span class="hljs-title class_">ConnectionCounter</span>.<span class="hljs-title function_">getInstance</span>();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createConnection</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">const</span> connectionId = counter.<span class="hljs-title function_">generateConnectionId</span>();
  counter.<span class="hljs-title function_">addConnection</span>(connectionId);
  <span class="hljs-keyword">return</span> connectionId;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">closeConnection</span>(<span class="hljs-params">connectionId: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">return</span> counter.<span class="hljs-title function_">removeConnection</span>(connectionId);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pingConnection</span>(<span class="hljs-params">connectionId: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> {
  counter.<span class="hljs-title function_">updateConnectionActivity</span>(connectionId);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getConnectionCount</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">number</span> {
  <span class="hljs-keyword">return</span> counter.<span class="hljs-title function_">getConnectionCount</span>();
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">subscribeToCountUpdates</span>(<span class="hljs-params">
  callback: (count: <span class="hljs-built_in">number</span>) =&gt; <span class="hljs-built_in">void</span>
</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">return</span> counter.<span class="hljs-title function_">subscribeToUpdates</span>(callback);
}

<span class="hljs-comment">// 导出实例供直接使用</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> connectionCounter = counter;
</code></pre>
<p>这段代码其实就是做了一件事：<strong>统计当前有多少个用户在线</strong>，而且可以<strong>实时推送到前端</strong>。我们用了一个“单例”模式，也就是整个服务里只有一个 <code>ConnectionCounter</code> 实例，避免多人连接时出现数据错乱。每当有新用户连上 SSE 的时候，就会生成一个唯一的连接 ID，然后调用 <code>createConnection()</code> 把它加进来，在线人数就 +1。</p>
<p>这些连接 ID 都会被记录下来，还会记住“最后活跃时间”。如果用户一直在线，我们就可以通过前端发个心跳（<code>pingConnection()</code>）来告诉后端“我还在哦”。断开连接的时候（比如用户关闭了页面），我们就通过 <code>closeConnection()</code> 把它移除，人数就 -1。</p>
<p>为了防止有些用户没正常断开（比如突然关机了），代码里还有一个“自动清理机制”，默认 10 分钟没动静的连接就会被清理掉。每次人数变化的时候，这个计数器会“广播”一下，通知所有订阅它的人说：“嘿，在线人数变啦！”</p>
<p>而这个订阅机制（<code>subscribeToCountUpdates()</code>）特别关键——它可以让我们在 SSE 里实时推送人数更新，前端只要监听着，就能第一时间看到最新的在线人数。我们还把常用的操作都封装好了，比如 <code>createConnection()</code>、<code>getConnectionCount()</code> 等，让整个流程特别容易集成。</p>
<p>总结一下：这段逻辑就是 <strong>自动统计在线人数 + 自动清理无效连接 + 实时推送更新</strong></p>
<p>接下来我们编写后端 SSE 接口，如下代码所示：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> {
  createConnection,
  closeConnection,
  pingConnection,
  subscribeToCountUpdates,
} <span class="hljs-keyword">from</span> <span class="hljs-string">"./counter"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 标记连接是否仍然有效</span>
  <span class="hljs-keyword">let</span> connectionClosed = <span class="hljs-literal">false</span>;

  <span class="hljs-comment">// 为此连接生成唯一ID</span>
  <span class="hljs-keyword">const</span> connectionId = <span class="hljs-title function_">createConnection</span>();

  <span class="hljs-comment">// 当前连接的计数更新回调</span>
  <span class="hljs-keyword">let</span> <span class="hljs-attr">countUpdateUnsubscribe</span>: (<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>) | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-comment">// 使用Next.js的流式响应处理</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadableStream</span>({
      <span class="hljs-title function_">start</span>(<span class="hljs-params">controller</span>) {
        <span class="hljs-keyword">const</span> encoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>();

        <span class="hljs-comment">// 安全发送数据函数</span>
        <span class="hljs-keyword">const</span> <span class="hljs-title function_">safeEnqueue</span> = (<span class="hljs-params">data: <span class="hljs-built_in">string</span></span>) =&gt; {
          <span class="hljs-keyword">if</span> (connectionClosed) <span class="hljs-keyword">return</span>;
          <span class="hljs-keyword">try</span> {
            controller.<span class="hljs-title function_">enqueue</span>(encoder.<span class="hljs-title function_">encode</span>(data));
          } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"SSE发送错误:"</span>, error);
            connectionClosed = <span class="hljs-literal">true</span>;
            <span class="hljs-title function_">cleanup</span>();
          }
        };

        <span class="hljs-comment">// 定义interval引用</span>
        <span class="hljs-keyword">let</span> <span class="hljs-attr">heartbeatInterval</span>: <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timeout</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">let</span> <span class="hljs-attr">activityPingInterval</span>: <span class="hljs-title class_">NodeJS</span>.<span class="hljs-property">Timeout</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

        <span class="hljs-comment">// 订阅在线用户计数更新</span>
        countUpdateUnsubscribe = <span class="hljs-title function_">subscribeToCountUpdates</span>(<span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (!connectionClosed) {
            <span class="hljs-keyword">try</span> {
              <span class="hljs-title function_">safeEnqueue</span>(
                <span class="hljs-string">`data: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify({ onlineUsers: count })}</span>\n\n`</span>
              );
            } <span class="hljs-keyword">catch</span> (error) {
              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"发送在线用户数据错误:"</span>, error);
            }
          }
        });

        <span class="hljs-comment">// 清理所有资源</span>
        <span class="hljs-keyword">const</span> <span class="hljs-title function_">cleanup</span> = (<span class="hljs-params"></span>) =&gt; {
          <span class="hljs-keyword">if</span> (heartbeatInterval) <span class="hljs-built_in">clearInterval</span>(heartbeatInterval);
          <span class="hljs-keyword">if</span> (activityPingInterval) <span class="hljs-built_in">clearInterval</span>(activityPingInterval);

          <span class="hljs-comment">// 取消订阅计数更新</span>
          <span class="hljs-keyword">if</span> (countUpdateUnsubscribe) {
            <span class="hljs-title function_">countUpdateUnsubscribe</span>();
            countUpdateUnsubscribe = <span class="hljs-literal">null</span>;
          }

          <span class="hljs-comment">// 如果连接尚未计数为关闭，则减少连接计数</span>
          <span class="hljs-keyword">if</span> (!connectionClosed) {
            <span class="hljs-title function_">closeConnection</span>(connectionId);
            connectionClosed = <span class="hljs-literal">true</span>;
          }

          <span class="hljs-comment">// 尝试安全关闭控制器</span>
          <span class="hljs-keyword">try</span> {
            controller.<span class="hljs-title function_">close</span>();
          } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-comment">// 忽略关闭时的错误</span>
          }
        };

        <span class="hljs-comment">// 设置15秒的心跳间隔，避免连接超时</span>
        heartbeatInterval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">if</span> (connectionClosed) {
            <span class="hljs-title function_">cleanup</span>();
            <span class="hljs-keyword">return</span>;
          }
          <span class="hljs-title function_">safeEnqueue</span>(<span class="hljs-string">": heartbeat\n\n"</span>);
        }, <span class="hljs-number">15000</span>);

        <span class="hljs-comment">// 每分钟更新一次连接活动时间</span>
        activityPingInterval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">if</span> (connectionClosed) {
            <span class="hljs-title function_">cleanup</span>();
            <span class="hljs-keyword">return</span>;
          }
          <span class="hljs-title function_">pingConnection</span>(connectionId);
        }, <span class="hljs-number">60000</span>);
      },
      <span class="hljs-title function_">cancel</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// 当流被取消时调用（客户端断开连接）</span>
        <span class="hljs-keyword">if</span> (!connectionClosed) {
          <span class="hljs-title function_">closeConnection</span>(connectionId);
          connectionClosed = <span class="hljs-literal">true</span>;

          <span class="hljs-keyword">if</span> (countUpdateUnsubscribe) {
            <span class="hljs-title function_">countUpdateUnsubscribe</span>();
          }
        }
      },
    }),
    {
      <span class="hljs-attr">headers</span>: {
        <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"text/event-stream"</span>,
        <span class="hljs-string">"Cache-Control"</span>: <span class="hljs-string">"no-cache, no-transform"</span>,
        <span class="hljs-title class_">Connection</span>: <span class="hljs-string">"keep-alive"</span>,
        <span class="hljs-string">"Access-Control-Allow-Origin"</span>: <span class="hljs-string">"*"</span>,
        <span class="hljs-string">"X-Accel-Buffering"</span>: <span class="hljs-string">"no"</span>, <span class="hljs-comment">// 适用于某些代理服务器如Nginx</span>
      },
    }
  );
}
</code></pre>
<p>这段代码是一个 Next.js 的 API 路由，用来建立一个 <strong>SSE 长连接</strong>，并把“当前在线人数”<strong>实时推送给客户端</strong>。</p>
<p>第一步就是建立连接并注册计数当客户端发起请求时，后端会：</p>
<ul>
<li>调用 <code>createConnection()</code> 生成一个唯一的连接 ID；</li>
<li>把这次连接计入在线用户总数里；</li>
<li>并返回一个 <code>ReadableStream</code>，让服务端能不断往客户端“推送消息”。</li>
</ul>
<p>第二步就是订阅在线人数变化，一旦连接建立，服务端就调用 <code>subscribeToCountUpdates()</code>，订阅在线人数的变化。一旦总人数发生变化，它就会通过 SSE 推送这样的数据给前端：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-attr">data</span>: {
  <span class="hljs-attr">onlineUsers</span>: <span class="hljs-number">23</span>;
}
</code></pre>
<p>也就是说，<strong>每次有人连上或断开，所有前端都会收到更新</strong>，非常适合“在线人数展示”。</p>
<p>第三步就是定期心跳和活跃检测：</p>
<ul>
<li>
<p>每 15 秒服务端会发一个 <code>: heartbeat</code>，保持连接不断开；</p>
</li>
<li>
<p>每 60 秒调用 <code>pingConnection()</code>，告诉后台“我还活着”，防止被误判为不活跃连接而清理。</p>
</li>
</ul>
<p>第四步是清理逻辑，当连接被取消（比如用户关闭页面）或出错时，后台会：</p>
<ul>
<li>
<p>调用 <code>closeConnection()</code> 把这条连接从统计中移除；</p>
</li>
<li>
<p>取消掉在线人数的订阅；</p>
</li>
<li>
<p>停掉心跳和活跃检测定时器；</p>
</li>
<li>
<p>安全关闭这个数据流。</p>
</li>
</ul>
<p>这个清理逻辑保证了<strong>数据准确、资源不浪费</strong>，不会出现“人数不减”或“内存泄露”。</p>
<p>最后总结一下，这段代码实现了一个完整的“<strong>谁连接我就+1，谁断开我就-1，然后实时广播当前在线人数</strong>”的机制。你只要在前端用 <code>EventSource</code> 接收这条 SSE 流，就能看到用户数量实时跳动，非常适合用在聊天室、控制台、直播页面等场景。</p>
<p>目前后端代码我们是编写完成了，我们来实现一个前端页面来实现这个功能来对接这个接口：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-string">"use client"</span>;

<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">OnlineCounter</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [onlineUsers, setOnlineUsers] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> [connected, setConnected] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> eventSourceRef = useRef&lt;<span class="hljs-title class_">EventSource</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 创建SSE连接</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">connectSSE</span> = (<span class="hljs-params"></span>) =&gt; {
      <span class="hljs-keyword">if</span> (eventSourceRef.<span class="hljs-property">current</span>) {
        eventSourceRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">close</span>();
      }

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">`/api/sse?t=<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>`</span>);
        eventSourceRef.<span class="hljs-property">current</span> = eventSource;

        eventSource.<span class="hljs-property">onopen</span> = <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-title function_">setConnected</span>(<span class="hljs-literal">true</span>);
        };

        eventSource.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>);
            <span class="hljs-comment">// 只处理在线用户数</span>
            <span class="hljs-keyword">if</span> (data.<span class="hljs-property">onlineUsers</span> !== <span class="hljs-literal">undefined</span>) {
              <span class="hljs-title function_">setOnlineUsers</span>(data.<span class="hljs-property">onlineUsers</span>);
            }
          } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"解析数据失败:"</span>, error);
          }
        };

        eventSource.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"SSE连接错误:"</span>, error);
          <span class="hljs-title function_">setConnected</span>(<span class="hljs-literal">false</span>);
          eventSource.<span class="hljs-title function_">close</span>();

          <span class="hljs-comment">// 5秒后尝试重新连接</span>
          <span class="hljs-built_in">setTimeout</span>(connectSSE, <span class="hljs-number">5000</span>);
        };
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"创建SSE连接失败:"</span>, error);
        <span class="hljs-built_in">setTimeout</span>(connectSSE, <span class="hljs-number">5000</span>);
      }
    };

    <span class="hljs-title function_">connectSSE</span>();

    <span class="hljs-comment">// 组件卸载时清理</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">if</span> (eventSourceRef.<span class="hljs-property">current</span>) {
        eventSourceRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">close</span>();
      }
    };
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"min-h-screen bg-gradient-to-b from-slate-900 to-slate-800 text-white flex flex-col items-center justify-center p-4"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"bg-slate-800 rounded-xl shadow-2xl overflow-hidden max-w-sm w-full"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"p-6"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-3xl font-bold text-center text-blue-400 mb-6"</span>&gt;</span>
            在线用户统计
          <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex items-center justify-center mb-4"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
              <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">h-3</span> <span class="hljs-attr">w-3</span> <span class="hljs-attr">rounded-full</span> <span class="hljs-attr">mr-2</span> ${
                <span class="hljs-attr">connected</span> ? "<span class="hljs-attr">bg-green-500</span>" <span class="hljs-attr">:</span> "<span class="hljs-attr">bg-red-500</span>"
              }`}
            &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-sm text-slate-300"</span>&gt;</span>
              {connected ? "已连接" : "连接断开"}
            <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex items-center justify-center bg-slate-700 rounded-lg p-8 mt-4"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex flex-col items-center"</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-6xl font-bold text-green-400 mb-2"</span>&gt;</span>
                {onlineUsers}
              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex items-center"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">svg</span>
                  <span class="hljs-attr">className</span>=<span class="hljs-string">"w-5 h-5 text-green-400 mr-2"</span>
                  <span class="hljs-attr">fill</span>=<span class="hljs-string">"currentColor"</span>
                  <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 20 20"</span>
                &gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">"M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z"</span> /&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-lg font-medium text-green-300"</span>&gt;</span>
                  在线用户
                <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
              <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>最终输出结果如下图所示：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/092f763c07ee4ad7a8cd750f803fdec2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9tZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1752440549&amp;x-signature=hJSP5ssBoiWlbOIYLWbj07G0Mrs%3D" alt="20250414134818" loading="lazy"></p>
<h2 data-id="heading-5">总结</h2>
<p>SSE 实现在线人数统计可以说是<strong>简单高效又刚刚好</strong>的选择：它支持服务端单向推送，客户端只用监听就能实时获取在线人数更新，不用自己轮询。相比 WebSocket 来说，SSE 更轻量，部署起来也更方便。我们还通过心跳机制和活跃时间管理，保证了数据准确、连接稳定。整体来说，<strong>功能对得上，性能扛得住，代码写起来也不费劲</strong>，是非常适合这个场景的一种实现方式。</p>





































<table><thead><tr><th>技术方式</th><th>实时性</th><th>实现难度</th><th>性能消耗</th><th>适不适合这个功能</th><th>备注</th></tr></thead><tbody><tr><td><strong>轮询</strong></td><td>★★☆☆☆</td><td>★☆☆☆☆（最简单）</td><td>★☆☆☆☆（浪费）</td><td>❌ 不推荐</td><td>太低效了</td></tr><tr><td><strong>WebSocket</strong></td><td>★★★★★</td><td>★★★★☆（较复杂）</td><td>★★★☆☆（重型）</td><td>❌ 不合适</td><td>太强大、太复杂</td></tr><tr><td><strong>SSE</strong></td><td>★★★★☆</td><td>★★☆☆☆（非常容易上手）</td><td>★★★★☆（轻量）</td><td>✅ 非常适合</td><td>简单好用又高效</td></tr></tbody></table></div></div>