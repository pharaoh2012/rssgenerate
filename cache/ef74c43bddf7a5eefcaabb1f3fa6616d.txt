
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipsoft/p/19058216" title="发布于 2025-08-26 10:00">
    <span role="heading" aria-level="2">Vue 缓存之坑，变量赋值方式和响应式数据</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<pre><code class="language-js">const { IsSuperAdmin } = useUserStore().userInfo;

  /**
   * 获取后台动态路由数据，解析并注册到全局路由
   *
   * @returns Promise&lt;RouteRecordRaw[]&gt; 解析后的动态路由列表
   */
  function generateRoutes() {
    return new Promise&lt;RouteRecordRaw[]&gt;((resolve, reject) =&gt; {
      console.log("userInfo", useUserStore().userInfo);
      console.log("IsSuperAdmin", IsSuperAdmin);
      .....
  }
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/80824/202508/80824-20250826095605906-1602852772.png" alt="image" loading="lazy"></p>
<p>这个问题涉及到 JavaScript 的<strong>变量赋值方式</strong>和<strong>响应式数据</strong>的特性。让我详细解释一下：</p>
<h2 id="问题原因">问题原因</h2>
<pre><code class="language-js">const { IsSuperAdmin } = useUserStore().userInfo;
</code></pre>
<p>这行代码使用了<strong>解构赋值</strong>，它创建了一个新的变量 <code>IsSuperAdmin</code>，这个变量是<strong>原始值的拷贝</strong>，而不是引用。</p>
<h2 id="具体解释">具体解释</h2>
<ol>
<li>
<p><strong>解构赋值创建的是拷贝</strong>：</p>
<ul>
<li><code>const { IsSuperAdmin } = useUserStore().userInfo;</code> 相当于：</li>
<li><code>const IsSuperAdmin = useUserStore().userInfo.IsSuperAdmin;</code></li>
<li>这是一个<strong>值拷贝</strong>，不是引用</li>
</ul>
</li>
<li>
<p><strong>响应式数据需要特殊处理</strong>：</p>
<ul>
<li>如果 <code>useUserStore().userInfo</code> 是响应式对象（如 Vue 的 reactive 或 Pinia 的 store）</li>
<li>直接解构会失去响应性，得到的是当前时刻的静态值</li>
</ul>
</li>
<li>
<p><strong>console.log 显示的是不同来源</strong>：</p>
<ul>
<li><code>useUserStore().userInfo.IsSuperAdmin</code> → 直接从 store 读取，获取最新值</li>
<li><code>IsSuperAdmin</code> → 解构时拷贝的旧值，不会自动更新</li>
</ul>
</li>
</ol>
<h2 id="解决方案">解决方案</h2>
<h3 id="方案1直接访问-store推荐">方案1：直接访问 store（推荐）</h3>
<pre><code class="language-js">function generateRoutes() {
  return new Promise&lt;RouteRecordRaw[]&gt;((resolve, reject) =&gt; {
    const userStore = useUserStore();
    console.log("userInfo", userStore.userInfo.IsSuperAdmin); // 最新值
    console.log("IsSuperAdmin", userStore.userInfo.IsSuperAdmin); // 最新值
    // ...
  });
}
</code></pre>
<h3 id="方案2使用计算属性如果需要响应式">方案2：使用计算属性（如果需要响应式）</h3>
<pre><code class="language-js">import { computed } from 'vue';

const IsSuperAdmin = computed(() =&gt; useUserStore().userInfo.IsSuperAdmin);

function generateRoutes() {
  return new Promise&lt;RouteRecordRaw[]&gt;((resolve, reject) =&gt; {
    console.log("userInfo", useUserStore().userInfo.IsSuperAdmin);
    console.log("IsSuperAdmin", IsSuperAdmin.value); // 使用 .value
    // ...
  });
}
</code></pre>
<h3 id="方案3使用-torefs-保持响应性">方案3：使用 toRefs 保持响应性</h3>
<pre><code class="language-js">import { toRefs } from 'vue';

const { IsSuperAdmin } = toRefs(useUserStore().userInfo);

function generateRoutes() {
  return new Promise&lt;RouteRecordRaw[]&gt;((resolve, reject) =&gt; {
    console.log("userInfo", useUserStore().userInfo.IsSuperAdmin);
    console.log("IsSuperAdmin", IsSuperAdmin.value); // 使用 .value
    // ...
  });
}
</code></pre>
<h2 id="最佳实践">最佳实践</h2>
<p><strong>避免在函数外部解构响应式数据</strong>，而是在需要的时候直接从 store 中读取：</p>
<pre><code class="language-js">function generateRoutes() {
  return new Promise&lt;RouteRecordRaw[]&gt;((resolve, reject) =&gt; {
    const userStore = useUserStore();
    // 始终使用 userStore.userInfo.IsSuperAdmin 来获取最新值
    console.log("IsSuperAdmin status:", userStore.userInfo.IsSuperAdmin);
    // ...
  });
}
</code></pre>
<p>这样可以确保你总是获取到最新的数据，而不是过时的拷贝值。</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/vipsoft/" target="_blank">VipSoft</a>  转载请注明原文链接：<a href="https://www.cnblogs.com/vipsoft/p/19058216" target="_blank">https://www.cnblogs.com/vipsoft/p/19058216</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.001388888888888889" data-date-updated="2025-08-26 10:02">2025-08-26 10:00</span>&nbsp;
<a href="https://www.cnblogs.com/vipsoft">VipSoft</a>&nbsp;
阅读(<span id="post_view_count">25</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19058216);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19058216', targetLink: 'https://www.cnblogs.com/vipsoft/p/19058216', title: 'Vue 缓存之坑，变量赋值方式和响应式数据' })">举报</a>
</div>
        