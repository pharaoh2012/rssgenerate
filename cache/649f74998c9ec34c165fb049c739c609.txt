
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiaoniu142857/p/19059909" title="发布于 2025-08-26 23:05">
    <span role="heading" aria-level="2">C++ I/O 终极加速指南，全网最全整理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="0x01-前置准备">0x01 前置准备</h2>
<p>所有代码依赖以下头文件，建议统一包含：</p>
<ul>
<li><code>&lt;cstdio&gt;</code>：提供 <code>getchar()</code>、<code>putchar()</code>、<code>fread()</code>、<code>fwrite()</code>；</li>
<li><code>&lt;iostream&gt;</code>：提供 <code>cin</code>、<code>cout</code>；</li>
<li><code>&lt;cctype&gt;</code>：提供 <code>isspace()</code>；</li>
</ul>
<h2 id="0x02-基础-io-优化基于-cin-和-cout">0x02 基础 I/O 优化：基于 <code>cin</code> 和 <code>cout</code></h2>
<h3 id="优化步骤">优化步骤</h3>
<ol>
<li><strong>关闭流同步</strong>：</li>
</ol>
<ul>
<li>实现：通过 <code>ios::sync_with_stdio(false)</code> 关闭 C++ 和 C 输入输出流的同步；</li>
<li>解释：为了确保混用 C++ 的 <code>cin</code> / <code>cout</code> 和 C 的 <code>printf</code> / <code>scanf</code> 不会产生 I/O 混乱，C++ 和 C 的两种流之间进行了同步。这提高了兼容性，但是产生了大常数。关闭流同步之后就不要同时使用 <code>cin</code> 和 <code>scanf</code>，也不要同时使用 <code>cout</code> 和 <code>printf</code>，否则会造成 I/O 混乱。但可以同时使用 <code>cin</code> 和 <code>printf</code>，也可以同时使用 <code>scanf</code> 和 <code>cout</code>；</li>
</ul>
<ol start="2">
<li><strong>解除绑定</strong>：</li>
</ol>
<ul>
<li>实现：通过 <code>cin.tie(nullptr)</code> 解除 <code>cin</code> 与 <code>cout</code> 的绑定；</li>
<li>解释：在 C++ 中，<code>cin</code> 默认绑定的是 <code>&amp;cout</code>，这意味着每次读入都会调用 <code>flush()</code>。可以用 <code>cin.tie(nullptr)</code> 函数解除这种绑定；</li>
</ul>
<ol start="3">
<li><strong>针对 <code>endl</code> 的优化</strong>：</li>
</ol>
<ul>
<li>实现：用 <code>'\n'</code> 替换 <code>endl</code>；</li>
<li>解释：<code>endl</code> 的作用是换行并刷新缓冲区，相当于 <code>cout&lt;&lt;'\n'&lt;&lt;flush</code>。而刷新缓冲区会带来一定开销；</li>
</ul>
<p>其中前两步一般合称「关流」。后文会沿用这个称呼。</p>
<h3 id="代码实现">代码实现</h3>
<p>以下两种写法是等价的：</p>
<pre><code class="language-cpp">// 写法1：链式调用
cin.tie(0)-&gt;sync_with_stdio(0);
</code></pre>
<pre><code class="language-cpp">// 写法2：分步调用
ios::sync_with_stdio(0);
cin.tie(0);
</code></pre>
<p>可以这样将所有 <code>endl</code> 替换为 <code>'\n'</code>：</p>
<pre><code class="language-cpp">// 注意：该宏需在包含&lt;iostream&gt;之后定义，避免与std::endl声明冲突
#define endl '\n'
</code></pre>
<h2 id="0x03-进阶优化快读">0x03 进阶优化：快读</h2>
<h3 id="普通快读基于-getchar">普通快读：基于 <code>getchar()</code></h3>
<p>通过 <code>getchar()</code> 函数逐字符读取，手动解析整数或字符串。</p>
<pre><code class="language-cpp">void read(int &amp;x){  // 读整数（支持负数）
	int c,f=1;
	while((c=getchar())&lt;'0'||c&gt;'9') if(c=='-') f=-1;
	for(x=c^48;(c=getchar())&gt;='0'&amp;&amp;c&lt;='9';x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48));
    x*=f;
}
void read(char &amp;c){  // 读一个非空字符
	while(isspace(c=getchar()));
}
int read(char s[]){  // 读一个字符串，到空格/EOF为止，返回长度
	int len=0;
    char c;
	while(isspace(c=getchar()));
    do s[len++]=c;
    while(!isspace(c=getchar())&amp;&amp;c!=EOF);
    s[len]='\0';  // 补字符串结束符
    return len;
}
int getline(char s[]){  // 读一行字符串，返回长度
    int len=0;
    char c;
    while((c=getchar())!='\n'&amp;&amp;c!=EOF) s[len++]=c;
    s[len]='\0';  // 补字符串结束符
    return len;
}
</code></pre>
<h3 id="缓冲区快读基于-fread">缓冲区快读：基于 <code>fread()</code></h3>
<p><code>getchar()</code> 每次从系统读取 1 个字符，频繁调用系统接口，开销大。<code>fread()</code> 一次性读取一整块数据到自定义缓冲区，后续从缓冲区取字符。这样可以减少系统调用次数，速度通常可以提升 5~10 倍。</p>
<p>缓冲区一般大小设为 1MB 左右，即 <span class="math inline">\(2^{20}\)</span> 字节，这样既不会占太大空间，不会刷新太多次缓冲区。</p>
<p>由于 <code>fread</code> 可以一次整块读入，因此速度比 <code>getchar</code> 快多了。</p>
<pre><code class="language-cpp">char in[1&lt;&lt;20],*p1,*p2;
inline char gc(){  // 从缓冲区读1个字符，空则补充
	return p1==p2&amp;&amp;(p2=(p1=in)+fread(in,1,1&lt;&lt;20,stdin))==in?EOF:*p1++;
}
</code></pre>
<p>加上这段代码，然后用 <code>gc()</code> 替换掉所有 <code>getchar()</code> 就可以了。</p>
<h2 id="0x04-进阶优化快写">0x04 进阶优化：快写</h2>
<h3 id="普通快写基于-putchar">普通快写：基于 <code>putchar()</code></h3>
<p>通过 <code>putchar()</code> 函数逐字符输出。</p>
<pre><code class="language-cpp">void write(int x){  // 写整数（支持负数）
	if(x&lt;0) putchar('-'),x=-x;
	x&lt;10?putchar(x|48):(write(x/10),putchar(x%10|48));
}
void write(char s[],int len){  // 写字符串，指定长度
	for(int i=0;i&lt;len;++i) putchar(s[i]);
}
void write(char s[]){  // 写字符串，直到'\0'为止
	for(int i=0;s[i];++i) putchar(s[i]);
}
</code></pre>
<h3 id="缓冲区快写基于-fwrite">缓冲区快写：基于 <code>fwrite()</code></h3>
<p>和缓冲区快读差不多，自定义一个缓冲区，每次写一个字符到缓冲区，满了就刷新缓冲区，通过 <code>fwrite()</code> 一次性将整个缓冲区里的内容输出。</p>
<p>加上如下代码，再用 <code>pc()</code> 替换掉所有 <code>putchar()</code> 就可以了。</p>
<pre><code class="language-cpp">char out[1&lt;&lt;20],*p3=out;
inline void pc(char c){  // 向缓冲区写1个字符，满则刷新
	if(p3-out==1&lt;&lt;20) fwrite(out,1,1&lt;&lt;20,stdout),p3=out;
	*p3++=c;
}
</code></pre>
<p>但是程序结束时，缓冲区里可能还有东西，因此我们必须在结束前清空缓冲区。<strong>这一步千万不要忘！</strong></p>
<pre><code class="language-cpp">fwrite(out,1,p3-out,stdout);
</code></pre>
<h2 id="0x05-工程化实现io-类封装">0x05 工程化实现：I/O 类封装</h2>
<h3 id="封装的核心目的">封装的核心目的</h3>
<ul>
<li><strong>自动管理缓冲区</strong>：析构函数自动调用 <code>fwrite()</code> 刷新输出缓冲区，避免忘记刷新；</li>
<li><strong>统一接口</strong>：将快读和快写整合到同一个类中，使用时直接调用 <code>io.函数名(参数)</code> 即可，无需再关注底层实现，适合作为缺省源使用；</li>
</ul>
<h3 id="代码实现-1">代码实现</h3>
<pre><code class="language-cpp">class IO{
    #define SIZE 1&lt;&lt;20
    private:
        char in[SIZE],out[SIZE],*p1,*p2,*p3;
    public:
        IO():p1(in),p2(in),p3(out){}
        ~IO(){fwrite(out,1,p3-out,stdout);}
        inline char gc(){  // 从缓冲区读1个字符，空则补充
            return p1==p2&amp;&amp;(p2=(p1=in)+fread(in,1,SIZE,stdin))==in?EOF:*p1++;
        }
        inline void pc(char c){  // 向缓冲区写1个字符，满则刷新
            if(p3-out==SIZE) fwrite(out,1,SIZE,stdout),p3=out;
            *p3++=c;
        }
        void read(int &amp;x){  // 读整数（支持负数）
            int c,f=1;
            while((c=gc())&lt;'0'||c&gt;'9') if(c=='-') f=-1;
            for(x=c^48;(c=gc())&gt;='0'&amp;&amp;c&lt;='9';x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48));
            x*=f;
        }
        void read(char &amp;c){  // 读一个非空字符
            while(isspace(c=gc()));
        }
        int read(char s[]){  // 读一个字符串，到空格/EOF为止，返回长度
            int len=0;
            char c;
            while(isspace(c=gc()));
            do s[len++]=c;
            while(!isspace(c=gc())&amp;&amp;c!=EOF);
            s[len]='\0';  // 补字符串结束符
            return len;
        }
        int getline(char s[]){  // 读一行字符串，返回长度
            int len=0;
            char c;
            while((c=gc())!='\n'&amp;&amp;c!=EOF) s[len++]=c;
            s[len]='\0';  // 补字符串结束符
            return len;
        }
        void write(int x){  // 写整数（支持负数）
            if(x&lt;0) pc('-'),x=-x;
            x&lt;10?pc(x|48):(write(x/10),pc(x%10|48));
        }
        void write(char s[],int len){  // 写字符串，指定长度
            for(int i=0;i&lt;len;++i) pc(s[i]);
        }
        void write(char s[]){  // 写字符串，直到'\0'为止
            for(int i=0;s[i];++i) pc(s[i]);
        }
    #undef SIZE
}io;  // 全局实例化，无需重复创建对象
</code></pre>
<h2 id="0x06-关键避坑指南">0x06 关键避坑指南</h2>
<ol>
<li><strong>混用不同 I/O 方式</strong>：
<ul>
<li>关流后不能混用 <code>cin</code> 和 <code>scanf</code>，也不能混用 <code>cout</code> 和 <code>printf</code>；</li>
<li>缓冲区快读与 <code>getchar()</code> 不可混用，缓冲区快写和 <code>putchar()</code> 也不能混用；</li>
</ul>
</li>
<li><strong>缓冲区快写忘记刷新</strong>：非封装版本需在程序结束前调用 <code>fwrite(out,1,p3-out,stdout)</code>，否则缓冲区剩余数据不会输出；</li>
<li><strong>整数快读快写处理边界值</strong>：处理 <code>INT_MIN</code> 即 <span class="math inline">\(-2147483648\)</span> 时会溢出，若需支持要开 <code>long long</code>；</li>
</ol>
<h2 id="0x07-性能对比与选型建议">0x07 性能对比与选型建议</h2>
<table>
<thead>
<tr>
<th>I/O 方式</th>
<th>速度排序</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>缓冲区快读快写</td>
<td>1</td>
<td>速度极致，适合大数据</td>
<td>代码长，需封装，不支持复杂类型（如浮点数）</td>
<td>输入超大，高频 I/O 的题目</td>
</tr>
<tr>
<td>普通快读快写</td>
<td>2</td>
<td>代码短，速度快</td>
<td>不支持复杂类型（如浮点数）</td>
<td>输入较大，需要卡常的题目</td>
</tr>
<tr>
<td>关流 <code>cin</code> / <code>cout</code></td>
<td>3</td>
<td>代码超短</td>
<td>兼容性差</td>
<td>一般题目</td>
</tr>
<tr>
<td><code>scanf</code> / <code>printf</code></td>
<td>4</td>
<td>适合输出格式串</td>
<td>格式控制符复杂，速度较慢</td>
<td>一般题目</td>
</tr>
<tr>
<td>不关流 <code>cin</code> / <code>cout</code></td>
<td>5</td>
<td>兼容性好</td>
<td>速度极慢</td>
<td>极小数据量的题目，调试输出</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注：若需支持浮点数（如 <code>double</code>），需扩展快读快写函数，手动解析小数点前后数字。因浮点数 I/O 场景较少，通常含有浮点数的题目数据量也不会太大，本文暂不展开，可根据需求自行扩展。</p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.002777777777777778" data-date-updated="2025-08-26 23:09">2025-08-26 23:05</span>&nbsp;
<a href="https://www.cnblogs.com/xiaoniu142857">xiaoniu142857</a>&nbsp;
阅读(<span id="post_view_count">127</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19059909);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19059909', targetLink: 'https://www.cnblogs.com/xiaoniu142857/p/19059909', title: 'C++ I/O 终极加速指南，全网最全整理' })">举报</a>
</div>
        