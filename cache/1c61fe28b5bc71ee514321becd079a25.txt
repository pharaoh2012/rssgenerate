
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/longfurcat/p/18664750" title="发布于 2025-01-11 13:54">
    <span role="heading" aria-level="2">【源码】Kafka订制协议如何处理粘拆包</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h3>前言</h3>
<p>在上一篇随笔中，我们探讨了如何使用 Netty 处理自定义协议中的粘包和拆包问题。Netty 提供了高度封装的 API，帮助开发者轻松应对这一挑战，因此很多人都对其解决方案非常熟悉。</p>
<p>但如果我们直接使用 Java NIO 来实现类似的功能，应该怎么做呢？</p>
<p>Kafka，作为一个成熟的分布式消息队列系统，正是直接基于 Java NIO 实现的，它的设计与实现方式值得我们深入学习。今天我们就来看看，Kafka 是如何使用 Java NIO 处理粘包拆包问题的。</p>
<p><em>注：以下内容基于 Kafka 3.9.0 源码进行分析。</em></p>
<h3>Kafka协议格式</h3>
<p>Kafka 消息的协议格式比较简单，采用了经典的消息头+消息体格式。消息头包含一个 4 字节的 <code>int</code>，表示消息体的长度。剩下的部分就是实际的消息体。</p>
<p>简而言之，Kafka 协议的消息格式大致如下：</p>
<ol>
<li><strong>消息头</strong>：4 字节，表示消息体的长度。</li>
<li><strong>消息体</strong>：根据消息头的长度字段读取相应大小的数据。</li>
</ol>
<p>这种简单的设计方式使得 Kafka 消息的解码变得非常高效，但也带来了一个需要解决的关键问题：如何处理粘包和拆包？</p>
<h3>架构背景</h3>
<p>为了理解 Kafka 如何处理消息的粘包拆包问题，我们首先来看看 Kafka 的NIO架构。下图展示了 Kafka 的基本架构，其中 <code>Processor</code> 组件负责接收和解析数据包，并将请求写入请求队列（<code>RequestQueue</code>）等待进一步处理。既然能写入请求队列，则解码操作肯定已经完成了，下面我们具体看看Processor的代码。</p>
<p>注：下面这张图不太对。RequestChannel内只有一个requestQueue对象，类型是ArrayBlockingQueue，没有多个队列。</p>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202501/1313132-20250110215520122-158560786.png" alt="" width="623" height="517" loading="lazy"></p>
<h3>&nbsp;Processor处理线程</h3>
<p>Kafka 的 <code>Processor</code> 线程负责从网络通道中读取消息，解码并处理请求。以下是 <code>Processor</code> 的 <code>run</code> 函数实现，我们可以看到它执行了一些关键操作：</p>
<div class="cnblogs_code">
<pre>// SocketServer.scala</pre>
<pre>override def run(): Unit =<span style="color: rgba(0, 0, 0, 1)"> {
    </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
      </span><span style="color: rgba(0, 0, 255, 1)">while</span><span style="color: rgba(0, 0, 0, 1)"> (shouldRun.get()) {
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
          </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置新连接</span>
<span style="color: rgba(0, 0, 0, 1)">          configureNewConnections()
          </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 处理新响应</span>
<span style="color: rgba(0, 0, 0, 1)">          processNewResponses()
          </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 轮询处理网络事件</span>
<span style="color: rgba(0, 0, 0, 1)">          poll()
          </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 处理完成的接收操作</span>
<span style="color: rgba(0, 0, 0, 1)">          processCompletedReceives()
          </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 处理完成的发送操作</span>
<span style="color: rgba(0, 0, 0, 1)">          processCompletedSends()
          </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 处理断开连接的操作</span>
<span style="color: rgba(0, 0, 0, 1)">          processDisconnected()
          </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 关闭多余的连接</span>
<span style="color: rgba(0, 0, 0, 1)">          closeExcessConnections()
        } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> {
          </span><span style="color: rgba(0, 0, 255, 1)">case</span> e: Throwable =&gt; processException("Processor got uncaught exception."<span style="color: rgba(0, 0, 0, 1)">, e)
        }
      }
    } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
      debug(s</span>"Closing selector - processor $id"<span style="color: rgba(0, 0, 0, 1)">)
      CoreUtils.swallow(closeAll(), </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">, Level.ERROR)
    }
}</span></pre>
</div>
<p>在 <code>run</code> 方法中，<code>Processor</code> 线程会执行一系列的操作来管理网络连接和消息的处理。可以看到，整个处理过程是通过轮询（<code>poll</code>）和不同的处理方法（如 <code>processCompletedReceives</code> 和 <code>processCompletedSends</code>）来实现的。</p>
<h3>定位解码逻辑</h3>
<p>根据方法名，解包操作应该是在 <code>processCompletedReceives</code> 方法中进行的。然而，实际代码中，我们发现 <code>processCompletedReceives</code> 方法在处理时，已经能够读取到请求头信息，这意味着消息已经是完整的。如果消息还不完整，肯定会存在边界问题。</p>
<p>因此，可以推测，<code>completedReceives</code> 中的消息已经经过了解码处理。接下来，我们只需要找到 <code>completedReceives</code> 是何时写入的，便能清楚了解解码的时机。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">SocketServer.scala</span>

<span style="color: rgba(0, 0, 255, 1)">private</span> def processCompletedReceives(): Unit =<span style="color: rgba(0, 0, 0, 1)"> {
  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 遍历所有已完成的接收（消息）</span>
  selector.completedReceives.forEach { receive =&gt;
    <span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
      </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 根据消息的源（source）获取通道，判断该通道是否处于打开或关闭状态</span>
<span style="color: rgba(0, 0, 0, 1)">      openOrClosingChannel(receive.source) match {
        </span><span style="color: rgba(0, 0, 255, 1)">case</span> Some(channel) =&gt;
          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 解析请求头（消息头部分）</span>
          val header =<span style="color: rgba(0, 0, 0, 1)"> parseRequestHeader(receive.payload)

          </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果消息类型是 SASL 握手请求，可能需要开始重新认证</span>
          <span style="color: rgba(0, 0, 255, 1)">if</span> (header.apiKey == ApiKeys.SASL_HANDSHAKE &amp;&amp;<span style="color: rgba(0, 0, 0, 1)"> channel.maybeBeginServerReauthentication(receive,
            () </span>=&gt;<span style="color: rgba(0, 0, 0, 1)"> time.nanoseconds())) {
            trace(s</span>"Begin re-authentication: $channel"<span style="color: rgba(0, 0, 0, 1)">)
          } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 获取当前时间戳（用于后续操作）</span>
            val nowNanos =<span style="color: rgba(0, 0, 0, 1)"> time.nanoseconds()

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 判断通道的认证会话是否过期</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (channel.serverAuthenticationSessionExpired(nowNanos)) {
              </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果过期，关闭连接并记录过期连接数</span>
              debug(s"Disconnecting expired channel: $channel : $header"<span style="color: rgba(0, 0, 0, 1)">)
              close(channel.id)
              expiredConnectionsKilledCount.record(</span><span style="color: rgba(0, 0, 255, 1)">null</span>, 1, 0<span style="color: rgba(0, 0, 0, 1)">)
            } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
              </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 获取连接ID（消息来源）</span>
              val connectionId =<span style="color: rgba(0, 0, 0, 1)"> receive.source

              </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 构建请求上下文</span>
              val context = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> RequestContext(header, connectionId, channel.socketAddress, Optional.of(channel.socketPort()),
                channel.principal, listenerName, securityProtocol, channel.channelMetadataRegistry.clientInformation,
                isPrivilegedListener, channel.principalSerde)

              </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 创建请求对象</span>
              val req = <span style="color: rgba(0, 0, 255, 1)">new</span> RequestChannel.Request(processor = id, context =<span style="color: rgba(0, 0, 0, 1)"> context,
                startTimeNanos </span>=<span style="color: rgba(0, 0, 0, 1)"> nowNanos, memoryPool, receive.payload, requestChannel.metrics, None)

              </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> KIP-511: 拦截 API_VERSIONS 请求以捕获客户端软件名和版本信息</span>
              <span style="color: rgba(0, 0, 255, 1)">if</span> (header.apiKey ==<span style="color: rgba(0, 0, 0, 1)"> ApiKeys.API_VERSIONS) {
                val apiVersionsRequest </span>=<span style="color: rgba(0, 0, 0, 1)"> req.body[ApiVersionsRequest]
                </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (apiVersionsRequest.isValid) {
                  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 注册客户端信息</span>
                  channel.channelMetadataRegistry.registerClientInformation(<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ClientInformation(
                    apiVersionsRequest.data.clientSoftwareName,
                    apiVersionsRequest.data.clientSoftwareVersion))
                }
              }

              </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 将请求发送到请求通道</span>
<span style="color: rgba(0, 0, 0, 1)">              requestChannel.sendRequest(req)

              </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 将通道设置为静默状态，防止进一步的操作，直到请求处理完毕</span>
<span style="color: rgba(0, 0, 0, 1)">              selector.mute(connectionId)

              </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 处理通道的静默事件</span>
<span style="color: rgba(0, 0, 0, 1)">              handleChannelMuteEvent(connectionId, ChannelMuteEvent.REQUEST_RECEIVED)
            }
          }
        </span><span style="color: rgba(0, 0, 255, 1)">case</span> None =&gt;
          <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果通道没有在选择器中找到，这应该永远不会发生
          </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 因为已完成的接收总是会在 `poll()` 后立即处理</span>
          <span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> IllegalStateException(s"Channel ${receive.source} removed from selector before processing completed receive"<span style="color: rgba(0, 0, 0, 1)">)
      }
    } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> {
      </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果处理请求时发生异常，捕获异常并继续处理</span>
      <span style="color: rgba(0, 0, 255, 1)">case</span> e: Throwable =&gt;<span style="color: rgba(0, 0, 0, 1)">
        processChannelException(receive.source, s</span>"Exception while processing request from ${receive.source}"<span style="color: rgba(0, 0, 0, 1)">, e)
    }
  }

  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 清空已完成的接收队列，确保下次可以处理新的消息</span>
<span style="color: rgba(0, 0, 0, 1)">  selector.clearCompletedReceives()
}</span></pre>
</div>
<p>进一步深入代码后，发现解码操作实际上是在 <code>poll()</code> 方法中完成的。其中具体执行流程如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202501/1313132-20250111130527613-2123020095.png" alt="" width="770" height="586" loading="lazy"></p>
<p>&nbsp;</p>
<p><code>Processor</code> 通过 <code>KafkaChannel</code> 和 <code>NetworkReceive</code> 来处理每一条消息。<code>NetworkReceive</code> 是 Kafka 用来包装完整消息的对象，它包含了两个缓冲区（<code>ByteBuffer</code>）：</p>
<ul>
<li><strong>消息头缓冲区</strong>：用于存放固定大小的消息头（4 字节）。</li>
<li><strong>消息体缓冲区</strong>：用于存放动态大小的消息体。</li>
</ul>
<p><code>KafkaChannel</code>&nbsp;任何时候都只持有一个<code>NetworkReceive</code>&nbsp;对象。意味着它缓存的数据不会超过1条消息。</p>
<p>NetworkReceive类的属性如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//NetworkReceive.java</span></pre>
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">KafkaChannel id</span>
<span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span><span style="color: rgba(0, 0, 0, 1)"> String source;
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">消息头缓存，new的时候固定4字节</span>
<span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span><span style="color: rgba(0, 0, 0, 1)"> ByteBuffer size;
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">最大值，消息体不能超过这个大小。超过则报错</span>
<span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span> <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> maxSize;
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">内存分配器，使用这个分配消息体缓存空间</span>
<span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span><span style="color: rgba(0, 0, 0, 1)"> MemoryPool memoryPool;
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">消息体请求分配的空间大小</span>
<span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">int</span> requestedBufferSize = -1<span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">消息体缓存</span>
<span style="color: rgba(0, 0, 255, 1)">private</span> ByteBuffer buffer;</pre>
</div>
<p><strong>数据读取过程</strong></p>
<p>Kafka 的数据读取过程分为几个步骤：</p>
<ol>
<li>
<p><strong>读取消息头</strong>：Kafka 会首先尝试从 <code>SocketChannel</code> 中读取消息头。消息头固定为 4 字节，表示消息体的大小。每次读取时，Kafka 会优先读取这 4 字节的数据。</p>
</li>
<li>
<p><strong>计算消息体大小</strong>：根据读取到的消息头（消息体的长度），Kafka 会分配一个新的缓冲区用于存放消息体数据。</p>
</li>
<li>
<p><strong>读取消息体</strong>：接下来，Kafka 会继续从 <code>SocketChannel</code> 中读取剩余的数据，直到消息体完全被读取到新的缓冲区中。</p>
</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1313132/202501/1313132-20250111133809133-1260593648.png" alt="" width="614" height="669" loading="lazy"></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">NetworkReceive.java</span>

<span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">long</span> readFrom(ScatteringByteChannel channel) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> IOException {
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> read = 0;  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 初始化已读取字节数

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 首先检查 size 缓冲区是否还有剩余字节可读</span>
    <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (size.hasRemaining()) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 从 channel 中读取数据到 size 缓冲区</span>
        <span style="color: rgba(0, 0, 255, 1)">int</span> bytesRead =<span style="color: rgba(0, 0, 0, 1)"> channel.read(size);
        
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果读取到文件末尾，抛出 EOFException 异常</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> (bytesRead &lt; 0<span style="color: rgba(0, 0, 0, 1)">)
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> EOFException();
        
        read </span>+= bytesRead;  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 累加已读取的字节数
        
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果 size 缓冲区已读取完成（没有剩余字节）</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">size.hasRemaining()) {
            size.rewind();  </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 重置 position 为 0，准备读取数据
            
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 获取消息体的大小</span>
            <span style="color: rgba(0, 0, 255, 1)">int</span> receiveSize =<span style="color: rgba(0, 0, 0, 1)"> size.getInt();
            
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果消息体大小无效（小于 0），抛出异常</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (receiveSize &lt; 0<span style="color: rgba(0, 0, 0, 1)">)
                </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> InvalidReceiveException("Invalid receive (size = " + receiveSize + ")"<span style="color: rgba(0, 0, 0, 1)">);
            
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果消息体大小超过了允许的最大值，抛出异常</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (maxSize != UNLIMITED &amp;&amp; receiveSize &gt;<span style="color: rgba(0, 0, 0, 1)"> maxSize)
                </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> InvalidReceiveException("Invalid receive (size = " + receiveSize + " larger than " + maxSize + ")"<span style="color: rgba(0, 0, 0, 1)">);
            
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置请求的缓冲区大小，可能是 0（例如用于处理某些 SASL 消息）</span>
            requestedBufferSize =<span style="color: rgba(0, 0, 0, 1)"> receiveSize;
            
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果消息体大小为 0，表示没有有效的消息体，则使用空缓冲区</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (receiveSize == 0<span style="color: rgba(0, 0, 0, 1)">) {
                buffer </span>=<span style="color: rgba(0, 0, 0, 1)"> EMPTY_BUFFER;
            }
        }
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果 buffer 仍然为 null 且 requestedBufferSize 不是 -1，表示还没有为消息体分配缓冲区</span>
    <span style="color: rgba(0, 0, 255, 1)">if</span> (buffer == <span style="color: rgba(0, 0, 255, 1)">null</span> &amp;&amp; requestedBufferSize != -1<span style="color: rgba(0, 0, 0, 1)">) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 尝试为消息体分配请求的缓冲区大小</span>
        buffer =<span style="color: rgba(0, 0, 0, 1)"> memoryPool.tryAllocate(requestedBufferSize);
        
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果内存池没有足够的空间分配缓冲区，记录警告日志</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> (buffer == <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">)
            log.trace(</span>"Broker low on memory - could not allocate buffer of size {} for source {}"<span style="color: rgba(0, 0, 0, 1)">, requestedBufferSize, source);
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果缓冲区已分配</span>
    <span style="color: rgba(0, 0, 255, 1)">if</span> (buffer != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 从 channel 中读取数据到 buffer 缓冲区</span>
        <span style="color: rgba(0, 0, 255, 1)">int</span> bytesRead =<span style="color: rgba(0, 0, 0, 1)"> channel.read(buffer);
        
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果读取到文件末尾，抛出 EOFException 异常</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> (bytesRead &lt; 0<span style="color: rgba(0, 0, 0, 1)">)
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> EOFException();
        
        read </span>+= bytesRead;  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 累加已读取的字节数</span>
<span style="color: rgba(0, 0, 0, 1)">    }

    </span><span style="color: rgba(0, 0, 255, 1)">return</span> read;  <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 返回已读取的总字节数</span>
}</pre>
</div>
<p><code>NetworkReceive</code> 并不主动判断数据是否已经准备就绪，它的生命周期和状态完全由外部组件（如 <code>Processor</code> 线程）来管理。它只是一个数据容器，负责保存消息头和消息体。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">判断是否已完成的方式，就是看看两个缓冲区是否都已填满    </span>
<span style="color: rgba(0, 0, 0, 1)">@Override
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">boolean</span><span style="color: rgba(0, 0, 0, 1)"> complete() {
     </span><span style="color: rgba(0, 0, 255, 1)">return</span> !size.hasRemaining() &amp;&amp; buffer != <span style="color: rgba(0, 0, 255, 1)">null</span> &amp;&amp; !<span style="color: rgba(0, 0, 0, 1)">buffer.hasRemaining();
}</span></pre>
</div>
<h3>与 Netty 的比较</h3>
<p><strong>读取方式：</strong>Netty 提供了更高层次的封装，自动化地从 <code>SocketChannel</code> 中读取数据，并将其存储在 <code>ByteBuf</code> 中，极大地简化了开发者的工作。而Kafka则需要手动从SocketChannel中读取数据，给开发者带来了更多的控制力，但也增加了代码的复杂度。</p>
<p><strong>解码方式：</strong>Netty 提供了 <code>ByteToMessageDecoder</code> 这样的解码器来处理粘包和拆包问题，帮助开发者轻松应对消息边界问题。与此相比，Kafka需要开发者手动实现更多的解码逻辑，因此代码量较大，当然灵活性也更高。</p>
<p><strong>读取数据量</strong>：Kafka 每次最多从 <code>Socket</code> 的内核缓冲区读取一条完整的消息，这种设计确保了每次读取的数据都是单一的完整消息，有助于提高处理的精确性和效率。相比之下，Netty 则可能在一次读取中处理多个消息，这取决于数据的大小和 <code>ByteBuf</code> 的容量。Kafka 的这种方式能避免一次读取过多数据，减少了内存的压力，同时也能给其他 <code>Channel</code> 留出更多的处理机会，提升系统的响应性。</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.40257115620949074" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-11 16:38">2025-01-11 13:54</span>&nbsp;
<a href="https://www.cnblogs.com/longfurcat">猫毛·波拿巴</a>&nbsp;
阅读(<span id="post_view_count">45</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18664750" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18664750);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18664750', targetLink: 'https://www.cnblogs.com/longfurcat/p/18664750', title: '【源码】Kafka订制协议如何处理粘拆包' })">举报</a>
</div>
        