
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18674080" title="发布于 2025-01-16 08:22">
    <span role="heading" aria-level="2">掌握设计模式--责任链模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="责任链模式chain-of-responsibility">责任链模式（Chain of Responsibility）</h2>
<p>责任链模式（Chain of Responsibility）是一种行为型设计模式，旨在通过将请求<strong>沿着一系列处理者传递</strong>，形成一条处理链，直到请求被处理链上特定的结点处理为止。它允许多个对象有机会处理请求，而不需要明确指定哪个对象将处理该请求。<strong>每个处理者包含对下一个处理者的引用</strong>，如果当前处理者无法处理请求，它会将请求传递给下一个处理者。这样可以将请求的处理职责链式地分配给多个处理者，而不需要将它们紧密耦合。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250116082127900-596073375.jpg" alt="image" loading="lazy"></p>
<h3 id="组成部分">组成部分</h3>
<ol>
<li><strong>抽象处理者（Handler）</strong>：定义一个处理请求的接口，并且持有一个指向下一个处理者的引用。如果当前处理者无法处理请求，就将其传递给下一个处理者。</li>
<li><strong>具体处理者（ConcreteHandler）</strong>：实现抽象处理者的接口，处理请求。如果无法处理，则传递给下一个处理者。</li>
<li><strong>客户端（Client）</strong>：发起请求，并将请求发送到责任链的起始点。</li>
</ol>
<h2 id="案例实现">案例实现</h2>
<p>假设我们需要处理不同等级的日志信息，并<strong>根据不同的日志等级，将日志信息写入不同的日志文件</strong>。日志等级包括info、debug、error和warning 日志级别。使用者只需指定日志级别，即可在责任链对象中自动处理对应的日志信息。</p>
<p>注：为了代码的实现简单，这里不编写具体的写入文件IO流操作，只是控制台输出。</p>
<h3 id="设计思路">设计思路</h3>
<ul>
<li><strong><code>handleLog</code> 方法</strong>：每个 <code>LogHandler</code> 只关注自己的日志级别，并在处理完成后调用 <code>nextHandler</code> 的 <code>handleLog</code> 方法；</li>
<li><strong>责任链的链式处理</strong>：<code>LoggerChain</code> 类负责维护日志处理器的顺序，并且通过一个 <code>nextHandler</code> 参数将责任传递给下一个处理器，实现责任的传递；</li>
<li><strong>灵活扩展</strong>：不需要每个处理器显式管理 <code>nextHandler</code>，在理想情况下只需要维护日志枚举类即可。</li>
</ul>
<h3 id="案例类图">案例类图</h3>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250116082134582-56738743.png" alt="image" loading="lazy"></p>
<h3 id="1-定义loghandler接口">1. 定义LogHandler接口</h3>
<p>在接口中，<code>handleLog</code> 方法接收一个 <code>nextHandler</code> 参数，决定是否将日志传递给下一个处理器。</p>
<pre><code class="language-java">public interface LogHandler {
    void handleLog(LoggerEnum logLevel, String message, LogHandler nextHandler);
}
</code></pre>
<h3 id="2-具体日志处理器实现">2. 具体日志处理器实现</h3>
<p>每个日志处理器只关心自己负责的日志等级，如果当前处理器能处理，则输出日志，并将控制权交给下一个处理器。</p>
<pre><code class="language-java">public class InfoLogHandler implements LogHandler {
    @Override
    public void handleLog(LoggerEnum logLevel, String message, LogHandler nextHandler) {
        if (logLevel.shouldLog(LoggerEnum.INFO)) {
            System.out.println(this.getClass().getSimpleName() + "&gt;&gt; INFO: " + message);
        }
        // 如果存在下一个处理器
        if (nextHandler != null) {
            nextHandler.handleLog(logLevel, message, nextHandler);
        }
    }
}

class DebugLogHandler implements LogHandler {
    @Override
    public void handleLog(LoggerEnum logLevel, String message, LogHandler nextHandler) {
        if (logLevel.shouldLog(LoggerEnum.DEBUG)) {
            System.out.println(this.getClass().getSimpleName() + "&gt;&gt; DEBUG: " + message);
        }
        // 如果存在下一个处理器
        if (nextHandler != null) {
            nextHandler.handleLog(logLevel, message, nextHandler);
        }
    }
}

class ErrorLogHandler implements LogHandler {
    @Override
    public void handleLog(LoggerEnum logLevel, String message, LogHandler nextHandler) {
        if (logLevel.shouldLog(LoggerEnum.ERROR)) {
            System.out.println(this.getClass().getSimpleName() + "&gt;&gt; ERROR: " + message);
        }
        // 如果存在下一个处理器
        if (nextHandler != null) {
            nextHandler.handleLog(logLevel, message, nextHandler);
        }
    }
}

class WarningLogHandler implements LogHandler {
    @Override
    public void handleLog(LoggerEnum logLevel, String message, LogHandler nextHandler) {
        if (logLevel.shouldLog(LoggerEnum.WARNING)) {
            System.out.println(this.getClass().getSimpleName() + "&gt;&gt; WARNING: " + message);
        }
        // 如果存在下一个处理器
        if (nextHandler != null) {
            nextHandler.handleLog(logLevel, message, nextHandler);
        }
    }
}
</code></pre>
<h3 id="3-创建处理器链">3. 创建处理器链</h3>
<pre><code class="language-java">public class LoggerChain implements LogHandler{
    private int currentPosition = 0;
    private List&lt;LogHandler&gt; handlers = new ArrayList&lt;&gt;();

    // 初始化日志责任链时可以结合创建型设计模式来动态实现，符合开闭原则
    public LoggerChain() {
        // 自动创建并排序处理器，按优先级从低到高
        handlers.add(new InfoLogHandler());
        handlers.add(new DebugLogHandler());
        handlers.add(new ErrorLogHandler());
        handlers.add(new WarningLogHandler());
    }

    // 处理日志
    public void log(LoggerEnum logLevel, String message) {
        this.handleLog(logLevel,message,null);
    }

    @Override
    public void handleLog(LoggerEnum logLevel, String message, LogHandler nextHandler) {
        if (currentPosition == handlers.size()) {
            // 退出责任链
            currentPosition = 0;
        }else{
            LogHandler firstHandler = handlers.get(currentPosition++);
            firstHandler.handleLog(logLevel, message, this);
        }
    }

}
</code></pre>
<h3 id="4-日志等级枚举">4. 日志等级枚举</h3>
<p><code>LoggerEnum</code> 枚举定义了不同的日志等级</p>
<pre><code class="language-java">public enum LoggerEnum {
    INFO(1),    // 信息日志
    DEBUG(2),   // 调试日志
    ERROR(3),   // 错误日志
    WARNING(4); // 警告日志

    private final int priority;

    LoggerEnum(int priority) {
        this.priority = priority;
    }

    public int getPriority() {
        return priority;
    }
    // 判断当前等级是否符合输出要求：比如Debug级别的日志可以输出debug和info的日志
    public boolean shouldLog(LoggerEnum currentLogLevel) {
        return this.priority &gt;= currentLogLevel.getPriority();
    }
}
</code></pre>
<h3 id="5-测试类">5. 测试类</h3>
<pre><code class="language-java">public class LoggerTest {
    public static void main(String[] args) {
        LoggerChain loggerChain = new LoggerChain();

        // 模拟不同日志级别的请求
        System.out.println("日志级别: INFO");
        loggerChain.log(LoggerEnum.INFO, "这是 info 信息.");

        System.out.println("\n日志级别: DEBUG");
        loggerChain.log(LoggerEnum.DEBUG, "这是 debug 信息.");

        System.out.println("\n日志级别: ERROR");
        loggerChain.log(LoggerEnum.ERROR, "这是 error 信息.");

        System.out.println("\n日志级别: WARNING");
        loggerChain.log(LoggerEnum.WARNING, "这是 warning 信息.");
    }
}
</code></pre>
<h3 id="执行结果">执行结果</h3>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250116082142629-1887867495.jpg" alt="image" loading="lazy"></p>
<p>在这个案例中，初始化日志责任链时可以结合创建型设计模式来动态实现，才符合开闭原则，新增或删除日志级别时只需要维护枚举类即可。将控制台输出改为IO流写入文件，即可实现不同日志级别的信息写入到不同的日志文件。</p>
<h2 id="优缺点和应用场景">优缺点和应用场景</h2>
<h3 id="优点">优点</h3>
<ol>
<li><strong>降低耦合度</strong>：客户端不需要知道哪个具体的对象会处理请求，处理请求的对象可以动态变化;</li>
<li><strong>扩展性强</strong>：新的处理器可以很容易地被添加到责任链中，且不需要修改现有的代码；</li>
<li><strong>职责分离</strong>：每个处理者只关注自己能处理的逻辑，职责清晰。</li>
</ol>
<h3 id="缺点">缺点</h3>
<ol>
<li><strong>链过长时可能造成性能问题</strong>：请求可能在链中经过多个处理者，这可能导致性能上的损耗，尤其是责任链较长时；</li>
<li><strong>调试复杂性</strong>：由于请求被多个处理者处理，调试时可能较难追踪请求的流转路径；</li>
<li><strong>请求可能永远无法得到处理</strong>：如果责任链中的所有处理器都没有处理该请求，则请求会被忽略或终止。这种情况可能会导致某些请求得不到预期的处理结果，需要在设计时注意链的完整性和错误处理机制。</li>
</ol>
<h3 id="应用场景">应用场景</h3>
<ol>
<li>
<p><strong>日志记录</strong>：责任链模式可以用于日志记录的处理。不同的日志级别（例如，INFO、DEBUG、ERROR）可以通过责任链模式传递，依次被不同的日志处理器（如控制台日志、文件日志、网络日志等）处理。</p>
</li>
<li>
<p><strong>权限校验</strong>：在复杂的权限校验中，不同的权限校验可以作为责任链的一部分，依次处理。每个处理器检查不同的权限要求，直到满足条件或结束。</p>
</li>
</ol>
<p><strong>例子</strong>：在SpringSecurity中，访问控制或权限校验可以通过<code>过滤链</code>模式来实现。例如，检查用户是否拥有访问某个页面的权限，可以通过多个权限处理器（如角色权限、用户权限、IP 白名单等）进行逐层处理。</p>
<ol start="3">
<li>
<p><strong>请求过滤</strong>：Servlet 的过滤器链（Filter Chain），每个过滤器负责请求的某个方面（例如，身份验证、权限检查、日志记录等）。请求被传递到链中的下一个过滤器，直到最终响应。</p>
</li>
<li>
<p><strong>表单验证</strong>：表单验证可以通过责任链模式进行处理，每个验证器可以处理不同的验证规则，直到表单满足所有验证条件。</p>
</li>
</ol>
<p><strong>例子</strong>：在表单提交时，可以有多个验证器（如空值检查、格式验证、长度验证、范围验证等），每个验证器都负责处理不同的验证逻辑。</p>
<ol start="5">
<li><strong>数据处理管道</strong>：在数据处理流程中，责任链模式适合于处理多个步骤的数据流。每个步骤可以视为一个处理器，负责对数据进行某种操作，数据会被传递到下一个步骤。</li>
</ol>
<p><strong>例子</strong>：数据清洗和转换流程中，每个数据清洗步骤（如去除空值、格式化、转换编码等）可以作为责任链的一部分，按顺序处理数据。</p>
<h2 id="责任链模式的应用">责任链模式的应用</h2>
<p>Spring Security的过滤链（Filter Chain）是责任链模式的一种典型实现。它是一个按顺序执行的过滤器集合，负责拦截和处理HTTP请求，以实现认证、授权、安全控制等功能，并且支持自定义过滤器插入到Spring Security的过滤链中，从而实现自定义的安全处理逻辑，使得Spring Security变得更加灵活。</p>
<h2 id="总结">总结</h2>
<p>责任链设计模式是一种行为设计模式，其核心在于将多个处理对象连接成一条链，允许请求沿链传递，直到有一个处理者能够处理该请求，从而实现请求的解耦和动态的处理顺序管理，并且处理者易于扩展，使得程序更加灵活。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250116082151971-1263762110.gif" alt="image" loading="lazy"></p>
<p>需要查看往期设计模式文章的，可以在个人主页中或者文章开头的集合中查看，可关注我，持续更新中。。。</p>
<hr>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3303630518634259" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-16 08:23">2025-01-16 08:22</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">220</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18674080" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18674080);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18674080', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18674080', title: '掌握设计模式--责任链模式' })">举报</a>
</div>
        