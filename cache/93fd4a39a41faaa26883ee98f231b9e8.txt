
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lori/p/18736220" title="发布于 2025-02-25 14:33">
    <span role="heading" aria-level="2">keycloak~refresh_token的标准化</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>内容大纲</p>
<ol>
<li>keycloak关于会话有效期的配置</li>
<li>refresh_token作用</li>
<li>使用方法</li>
<li>refresh_token规范</li>
<li>keycloak开启refresh_token的限制</li>
<li>refresh_token时的错误汇总</li>
<li>keycloak中refresh_token的底层逻辑</li>
</ol>
<h1 id="一-keycloak关于会话有效期的配置">一 keycloak关于会话有效期的配置</h1>
<h3 id="1-配置-access-token-lifespan">1. <strong>配置 <code>Access Token Lifespan</code></strong></h3>
<ul>
<li><strong>作用</strong>: 控制<code>access_token</code>的有效期。</li>
<li><strong>配置值</strong>: 5分钟</li>
<li><strong>操作</strong>:
<ol>
<li>进入Keycloak管理控制台。</li>
<li>选择你的Realm。</li>
<li>进入<code>Realm Settings</code> &gt; <code>Tokens</code>。</li>
<li>将<code>Access Token Lifespan</code>设置为<code>5</code>分钟。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-配置-refresh-token-lifespan">2. <strong>配置 <code>Refresh Token Lifespan</code></strong></h3>
<ul>
<li><strong>作用</strong>: 控制<code>refresh_token</code>的有效期。<code>refresh_token</code>用于在<code>access_token</code>过期后获取新的<code>access_token</code>。</li>
<li><strong>配置值</strong>: 7天</li>
<li><strong>操作</strong>:
<ol>
<li>进入<code>Realm Settings</code> &gt; <code>Tokens</code>。</li>
<li>将<code>Refresh Token Lifespan</code>设置为<code>7</code>天（604800秒）。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-配置-sso-session-idle">3. <strong>配置 <code>SSO Session Idle</code></strong></h3>
<ul>
<li><strong>作用</strong>: 控制用户会话的空闲时间。如果用户在7天内没有任何操作，会话将过期，用户需要重新登录。</li>
<li><strong>配置值</strong>: 7天</li>
<li><strong>操作</strong>:
<ol>
<li>进入<code>Realm Settings</code> &gt; <code>Tokens</code>。</li>
<li>将<code>SSO Session Idle</code>设置为<code>7</code>天（604800秒）。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-配置-sso-session-max">4. <strong>配置 <code>SSO Session Max</code></strong></h3>
<ul>
<li><strong>作用</strong>: 控制用户会话的最大持续时间。设置为一个非常大的值（如1年），以确保用户在7天内操作过就可以保持登录状态。</li>
<li><strong>配置值</strong>: 1年（31536000秒）</li>
<li><strong>操作</strong>:
<ol>
<li>进入<code>Realm Settings</code> &gt; <code>Tokens</code>。</li>
<li>将<code>SSO Session Max</code>设置为<code>31536000</code>秒（1年）。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="5-配置-client-session-idle-和-client-session-max">5. <strong>配置 <code>Client Session Idle</code> 和 <code>Client Session Max</code></strong></h3>
<ul>
<li><strong>作用</strong>: 控制客户端会话的空闲时间和最大持续时间。建议与SSO会话配置保持一致。</li>
<li><strong>配置值</strong>:
<ul>
<li><code>Client Session Idle</code>: 7天（604800秒）</li>
<li><code>Client Session Max</code>: 1年（31536000秒）</li>
</ul>
</li>
<li><strong>操作</strong>:
<ol>
<li>进入<code>Realm Settings</code> &gt; <code>Tokens</code>。</li>
<li>将<code>Client Session Idle</code>设置为<code>604800</code>秒。</li>
<li>将<code>Client Session Max</code>设置为<code>31536000</code>秒。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="6-配置-offline-session-idle-和-offline-session-max">6. <strong>配置 <code>Offline Session Idle</code> 和 <code>Offline Session Max</code></strong></h3>
<ul>
<li><strong>作用</strong>: 控制离线会话的空闲时间和最大持续时间。如果你不需要离线会话功能，可以忽略此配置。</li>
<li><strong>配置值</strong>:
<ul>
<li><code>Offline Session Idle</code>: 7天（604800秒）</li>
<li><code>Offline Session Max</code>: 1年（31536000秒）</li>
</ul>
</li>
<li><strong>操作</strong>:
<ol>
<li>进入<code>Realm Settings</code> &gt; <code>Tokens</code>。</li>
<li>将<code>Offline Session Idle</code>设置为<code>604800</code>秒。</li>
<li>将<code>Offline Session Max</code>设置为<code>31536000</code>秒。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="7-配置-remember-me-功能可选">7. <strong>配置 <code>Remember Me</code> 功能（可选）</strong></h3>
<ul>
<li><strong>作用</strong>: 如果希望用户在关闭浏览器后仍能保持登录状态，可以启用“记住我”功能。</li>
<li><strong>配置值</strong>:
<ul>
<li><code>SSO Session Idle Remember Me</code>: 7天（604800秒）</li>
<li><code>SSO Session Max Remember Me</code>: 1年（31536000秒）</li>
</ul>
</li>
<li><strong>操作</strong>:
<ol>
<li>进入<code>Realm Settings</code> &gt; <code>Tokens</code>。</li>
<li>将<code>SSO Session Idle Remember Me</code>设置为<code>604800</code>秒。</li>
<li>将<code>SSO Session Max Remember Me</code>设置为<code>31536000</code>秒。</li>
</ol>
</li>
</ul>
<h1 id="二-refresh_token作用">二 refresh_token作用</h1>
<p>refresh_token是用来刷新access_token的，当access_token过期后，可以通过refresh_token来获取新的access_token，而不需要重新登录。</p>
<h1 id="三-使用方法">三 使用方法</h1>
<pre><code class="language-json">curl --location --request POST 'https://{keycloak}/auth/realms/{realm}/protocol/openid-connect/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'grant_type=refresh_token' \
--data-urlencode 'refresh_token={refresh_token}' \
--data-urlencode 'client_id={client_id}' \
--data-urlencode 'client_secret={client_secret}'
</code></pre>
<h1 id="四-refresh_token规范">四 refresh_token规范</h1>
<ul>
<li>每个refresh_token只能使用一次，不可重复使用，KC这边也会进行回收它</li>
<li>通过refresh_token获取新的token时，返回值里会带有<code>新的refresh_token</code>，我们应该使用新的refresh_token来覆盖上一次的refresh_token</li>
<li>refresh_token有效期取决于keycloak<sub>tokens</sub>sso session idle的值，即会话空闲时间，如果refresh_token在这个时间内没有使用，那么它会失效</li>
<li>refresh_token失效后，当前会话session_state也即失效，此时，需要重新登录</li>
</ul>
<blockquote>
<p>注意：<code>sso session max</code>表示会话最大有效期，在这个时间范围内，用户不需要重新登录，<code>sso session idle</code>表示空间时间，在这个时间内用户不进行操作，也示为退出，用户需要重新登录，这两个值必须大于0；单位为分，小时，天，不支持永久有效期。</p>
</blockquote>
<h1 id="五-keycloak开启refresh_token的限制">五 keycloak开启refresh_token的限制</h1>
<p><img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250225142930947-1969867623.png" alt="" loading="lazy"></p>
<h1 id="六-refresh_token时的错误汇总">六 refresh_token时的错误汇总</h1>
<ul>
<li>
<p>当refresh_token超过限制时，会返回<code>invalid_grant</code>错误，此时，需要重新登录<br>
<img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250225142825999-2128311384.png" alt="" loading="lazy"></p>
</li>
<li>
<p>再次使用refresh_token，同样返回状态码400，但返回消息体会有变化<br>
<img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250225142943597-1584897669.png" alt="" loading="lazy"></p>
</li>
<li>
<p>如果当前session已经失效，即会话达到了session max的时间，将返回下面错误<br>
<img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250225143006849-736393783.png" alt="" loading="lazy"></p>
</li>
<li>
<p>如果当前客户端与token客户端不一致，将返回下面错误<br>
<img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250225143031802-2049687941.png" alt="" loading="lazy"></p>
</li>
<li>
<p>如果当前当前端开启了同意许可，将返回下面错误<br>
<img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250225143043112-822731793.png" alt="" loading="lazy"></p>
</li>
</ul>
<h1 id="七-keycloak中refresh_token的底层逻辑">七 keycloak中refresh_token的底层逻辑</h1>
<ol>
<li>
<p>validateToken方法<br>
<img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250225143107197-1498684481.png" alt="" loading="lazy"></p>
</li>
<li>
<p>通过session_state获取userSession对象，如果userSession对象为空，说明refresh_token已经失效，返回<code>400</code> <code>Session not active</code><br>
<img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250225143118453-1409736499.png" alt="" loading="lazy"></p>
</li>
<li>
<p>isSessionValid方法主要验证会话是否有效，主要判断以下几个部分</p>
</li>
</ol>
<ul>
<li>用户会话是否存在,user-session是否存在</li>
<li>获取session空闲时间和最大时间，它们的逻辑与是否开启<code>记住我</code>有关</li>
<li>会有两层时间的比较，来确定session是否有效
<ul>
<li>第一层，session空闲时间是否大于（当前时间-最后刷新token时间-容错窗口期（120秒））</li>
<li>第二层，session最大时间是否大于（当前时间-session开始时间）</li>
</ul>
</li>
<li>上面两层同时满足，说明session是有效的<br>
<img src="https://img2024.cnblogs.com/blog/118538/202502/118538-20250225143134744-1871602317.png" alt="" loading="lazy"></li>
</ul>
<ol start="4">
<li>从userSession中获取当前用户对象</li>
<li>判断用户是否有效
<ul>
<li>如果用户被删除，返回<code>400</code> <code>Unknown user</code></li>
<li>如果用户状态为禁用，返回<code>400</code> <code>User disabled</code></li>
<li>如果用户需要一个<code>必要的行为</code>，返回<code>400</code> <code>User has required action</code></li>
</ul>
</li>
<li>判断当前refresh_token的建立时间是否早于会话开始时间，正常情况下肯定是晚于会话时间，如果早于，返回<code>400</code> <code>Refresh toked issued before the user session started</code></li>
<li>判断当前userSession是否在当前client_id对应的clientSession里，如果没有，返回<code>400</code> <code>Session doesn't have required client</code></li>
<li>判断当前refresh_token里的azp是否与请求参数<code>client_id</code>相同，不同返回<code>400</code> <code>Unmatching clients</code></li>
<li>验证refresh_token是否被篡改</li>
<li>检查客户端是否有consent的授权许可同意，如果开启了，会返回<code>400</code> <code>Client no longer has requested consent from user</code></li>
<li>成功建立新的token对象，整个刷新token流程结束</li>
</ol>
<pre><code class="language-json">{
    "access_token": "",
    "expires_in": 120,
    "refresh_expires_in": 300,
    "refresh_token": "",
    "token_type": "Bearer",
    "id_token": "",
    "not-before-policy": 1740449130,
    "session_state": "424b8022-600d-421e-a45d-e0315d1a524d",
    "scope": "openid roles email profile"
}
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p></p>
<div class="navgood">
<p>作者：仓储大叔，张占岭，<br>
荣誉：微软MVP<br>QQ：853066980</p>

<p><strong>支付宝扫一扫，为大叔打赏!</strong>
<br><img src="https://images.cnblogs.com/cnblogs_com/lori/237884/o_IMG_7144.JPG"></p>
</div>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3767082874502315" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-25 15:18">2025-02-25 14:33</span>&nbsp;
<a href="https://www.cnblogs.com/lori">张占岭</a>&nbsp;
阅读(<span id="post_view_count">12</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18736220" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18736220);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18736220', targetLink: 'https://www.cnblogs.com/lori/p/18736220', title: 'keycloak~refresh_token的标准化' })">举报</a>
</div>
        