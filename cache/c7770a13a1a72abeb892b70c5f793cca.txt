
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/san-mu/p/18967224" title="发布于 2025-07-07 09:37">
    <span role="heading" aria-level="2">MySQL 07 行锁功过：怎么减少行锁对性能的影响？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>行锁是针对数据表中行记录的锁，是在引擎层由引擎实现的。</p>
<h3 id="从两阶段锁说起">从两阶段锁说起</h3>
<p>在InnoDB<strong>事务</strong>中，行锁是在需要的时候才加上的，但并不是不需要了就立即释放，而是等到事务结束时才释放，这就是<strong>两阶段锁协议</strong>。</p>
<p>知道这个设定后，如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁<strong>尽量往后放</strong>。</p>
<p>举个例子，假设有个电影票交易业务，顾客A要在影院B买电影票，其涉及如下操作：</p>
<ul>
<li>
<p>从顾客A账户余额中扣减电影票价；</p>
</li>
<li>
<p>给影院B账户余额增加电影票价；</p>
</li>
<li>
<p>记录一条交易日志。</p>
</li>
</ul>
<p>这些操作涉及三条语句，为了保证原子性，会把三个操作放在一个事务中。而观察这三个操作，会发现语句2最可能造成冲突，因为不同顾客买票都会使用语句2修改同一行数据。</p>
<p>根据两阶段锁协议，锁等待是一定有的，而把语句2安排在最后，比如按照312这样的顺序，就能做到最可能造成锁冲突的锁放在后面，最大程度减少了事务之间的等待。</p>
<h3 id="死锁和死锁检测">死锁和死锁检测</h3>
<p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p>
<p>以行锁举例：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250705144158562-1924508644.png" width="40%"></div>
<p>这时，事务A等待事务B释放id=2的行锁，而事务B等待事务A释放id=1的行锁，造成死锁。</p>
<p>当出现死锁，有两种策略：</p>
<ul>
<li>
<p>直接进入等待，直到超时。这个超时时间可以通过参数<code>innodb_lock_wait_timeout</code>设置。在InnoDB里，默认值是50秒，这往往无法接受。但也不能直接把这个时间设置成一个很小的值，因为会无法区分死锁和简单的锁等待，造成误伤。因此，这种方法一般不使用。</p>
</li>
<li>
<p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。设置参数<code>innode_deadlock_detect=on</code>，表示开启这个逻辑。</p>
</li>
</ul>
<p>正常情况使用第二种策略，但死锁检测也是有负担的。假如n个事务都要更新同一行，由于每个新来的被堵住的线程都要判断自己是否导致了死锁，这个复杂度为<span class="math inline">\(O(n)\)</span>，总复杂度就会达到<span class="math inline">\(O(n^2)\)</span>。</p>
<p>对于这种热点行更新导致的性能问题，思路主要是：</p>
<ul>
<li>
<p>对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作。</p>
</li>
<li>
<p>将一行改成逻辑的多行来减少锁冲突。比如将影院账户拆成10个记录，这样每次加金额时随机选择其中一条记录来加，每次冲突概率变成原来的1/10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。</p>
</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-07 09:37">2025-07-07 09:37</span>&nbsp;
<a href="https://www.cnblogs.com/san-mu">叁沐</a>&nbsp;
阅读(<span id="post_view_count">228</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18967224);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18967224', targetLink: 'https://www.cnblogs.com/san-mu/p/18967224', title: 'MySQL 07 行锁功过：怎么减少行锁对性能的影响？' })">举报</a>
</div>
        