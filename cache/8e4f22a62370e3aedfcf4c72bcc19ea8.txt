
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/feiyangqingyun/p/18795201" title="发布于 2025-03-27 08:51">
    <span role="heading" aria-level="2">Qt/C++开发经验小技巧311-315</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<ol start="311">
<li>关于流媒体推拉流延时的几点说明。</li>
</ol>
<ul>
<li>经常看到一些流媒体相关的程序，号称零延迟，不用怀疑，这肯定吹牛逼的。</li>
<li>搞音视频开发，有个核心的指标就是实时性，也就是延迟多少毫秒，这个问题问的也是最多的。</li>
<li>音视频文件几乎不存在实时性问题，只有音视频流才有实时性的指标。</li>
<li>延迟多久这个涉及到很多方面，也要看你如何计算，从推流开始计算还是从拉流开始计算。</li>
<li>很多小伙伴们并不能明白什么叫延时，认为随便一个播放器播放出来的画面跟原始流画面时间差就是延时，其实这是对延时最大的误解。延时不是表象，很多人在测试延时时很不专业，对延时测试的专业性认识不足。</li>
<li>下面整理的是zlm作者写的关于延时的文章，非常完整而且有代表性。</li>
<li>采集延时：在采集摄像头或显卡画面时，由于fps的限制和cpu性能、内存拷贝速度等客观限制，采集画面成YUV/RGB等数据时会有一定的延时，一般延时为毫秒级别。由于一般编码器对输入数据格式存在限制，譬如要求统一输入YUV420P，这样在做RGB-&gt;YUV420P转换时，也会有转换计算延时(这个可以通过libyuv库来降低)。总而延时，采集延时大概为毫秒级别，如果fps为25，那么一般采集延时会有40毫秒（1000毫秒/25fps）以上的延时，在内存拷贝和颜色转换时，又可能增加若干毫秒的延时。</li>
<li>编码延时：在把原始画面输入到编码器时，并不会立即输出编码后的数据，特别是在开启B帧时，由于需要参考后面的P帧，那么延时会更大，所以延时敏感的情况下一般不开启B帧，这种情况下编码延时应该是毫秒级别，不是很大。</li>
<li>上行延时：编码后的数据，要经过一定的协议打包才能写入socket，然后传输给推流服务器或拉流代理服务器，协议打包会有一定的内存拷贝和计算量，那么会增加延时，不过这个延时很小，基本忽略不计。数据在上传到服务器时，这个延时可大可小，取决于网络质量。</li>
<li>转换延时：服务器在收到数据后，要读socket缓存、协议解析、解复用、重新打包等操作，不过总体而言，这个延时比较小，基本没什么影响。有时，服务器为了提高性能，会采取合并写的机制，也就是收到一定量的数据后才会一并转发，这个延时一般为几百毫秒，ZLMediaKit默认300毫秒左右，不过ZLMediaKit默认关闭合并写，也就是这个延时也很小。</li>
<li>下行延时：流媒体在把视频数据转发给播放器时，会存在网络发送，这个延时大小取决于网络质量，ZLMediaKit在关闭低延时模式时，还会增加MSG_MORE和关闭TCP_NODELAY导致的延时，不过ZLMediaKit默认开启低延时模式。</li>
<li>播放延时：播放器延时主要有网路接收延时、协议解析解复用延时、解码延时、缓存延时、渲染延时组成，这些延时中缓存延时最大，因为一般的播放器为了保证在网络抖动情况下视频播放的流畅性，会以增加延时为代价，增加播放缓存，这样在网络变差时，不至于播放缓冲卡顿。而且为了音视频同步，也必须确保一定的缓存量。这种延时一般都是秒级别，一般5秒左右。有部分播放策略是接收到数据后立即解码显示比如rtsp视频流，这样可以做到延迟最小。</li>
<li>缓存延时：流媒体服务器为了能让播放器立即出画面，往往会缓存最近的一个I帧，这个I帧往后的所有音视频数据被称作为GOP缓存。如果不缓存GOP，那么播放器要等下一个I帧才能解码成功或不花屏，显然为了提高播放体验，这个GOP缓存是不能去掉的。而一般GOP短则1~3秒，长则10几秒，这个跟采集端编码器设置有关，服务器改变不了。但是由于一般的播放器收到缓存后，并不会丢弃过多的画面来确保低延时。况且播放器还希望有一定的缓存来确保播放的流畅性，所以这个GOP缓存将会增大播放器的延时。</li>
<li>综合延时：最快可以做到200-300ms的延迟，比如rtsp视频流，对实时性要求高，可以不做缓存和音视频同步，收到就立即解码播放。hls一般最快可以做到5s延迟，flv一般可以做到3s延迟。</li>
<li>最终总结：综合考虑实时性以及支持的音视频格式，个人建议，推流用rtsp推流（支持的音视频格式最友好，比如支持265），拉流在web上个人推荐用ws-flv格式拉流（支持的格式多，没有6个同源的限制），拉流在可执行文件上用rtsp（格式多而且实时性最好，可以最快速度解码播放），在网页上虽然webrtc实时性最好，但是不支持265，这个就难搞。</li>
</ul>
<ol start="312">
<li>Qt自带的对话框的按钮设置中文。</li>
</ol>
<pre><code class="language-cpp">//信息框设置中文
QMessageBox dialog(QMessageBox::Question, "询问", text);
dialog.setStandardButtons(QMessageBox::Yes | QMessageBox::No);
dialog.button(QMessageBox::Yes)-&gt;setText("确 定");
dialog.button(QMessageBox::No)-&gt;setText("取 消");
return dialog.exec();

//输入框设置中文
QInputDialog dialog;
dialog.setOkButtonText("确定");
dialog.setCancelButtonText("取消");
return dialog.exec();

//对话框设置中文
QFileDialog dialog;
dialog.setOption(QFileDialog::DontUseNativeDialog, true);
QLabel *lookinLabel = dialog.findChild&lt;QLabel*&gt;("lookInLabel");
lookinLabel-&gt;setText("文件目录：");
</code></pre>
<ol start="313">
<li>有时候需要对树状节点进行搜索过滤显示，匹配到的节点显示，没有匹配的隐藏。这个功能很多地方用，封装了一个静态函数直接调用。</li>
</ol>
<pre><code class="language-cpp">//调用方法 QtHelper::search(ui-&gt;treeWidget, "测试", 5);
void QtHelper::search(QTreeWidget *treeWidget, const QString &amp;key, int level)
{
    //找到所有匹配的节点
    QList&lt;QTreeWidgetItem *&gt; items = treeWidget-&gt;findItems(key, Qt::MatchContains | Qt::MatchRecursive);

    //将匹配到的节点加入队列/该节点的父节点也相当于匹配/不然父节点隐藏子节点也会跟着隐藏
    QList&lt;QTreeWidgetItem *&gt; itemAll;
    foreach (QTreeWidgetItem *item, items) {
        //当前节点的所有父节点也添加进去/几次循环相当于几个层级
        for (int i = 0; i &lt; level; ++i) {
            //去重添加
            if (!itemAll.contains(item)) {
                itemAll &lt;&lt; item;
            }
            //为空表示没有父节点则跳出循环
            item = item-&gt;parent();
            if (!item) {
                break;
            }
        }
    }

    //遍历所有节点/匹配的节点显示否则隐藏
    QTreeWidgetItemIterator it(treeWidget);
    while (*it) {
        (*it)-&gt;setHidden(!itemAll.contains(*it));
        ++it;
    }
}
</code></pre>
<ol start="314">
<li>在Qt中实现组播是非常容易的事情，从4.8开始支持组播，为啥要用组播而不是广播？因为广播会产生广播数据风暴，每个设备都会收到，而且针对某个网段的广播比如192.168.0.255，不能跨网段。而组播不仅可以跨网段，还不会出现数据风暴，只对加入了组播的目标进行数据发送，非常适合用来做局域网设备搜索和配置。在测试过程中，如果是两台真机之间测试组播，没有问题，但是很多时候开发机只有一台，最多就是在开发机上安装了虚拟机，可以有多个系统可以测试，那么问题来了，虚拟机之间的组播需要经过设置才能正常通信。第一点就是虚拟机的网络必须是桥接模式，也就是网络地址和宿主主机同一网段。第二点最关键，需要在两个虚拟机产生的网卡设备（VMware Network Adapter VMnet1/VMware Network Adapter VMnet8）右键属性进去设置，在此连接使用下列项目中勾选一个VMware Bridge Protocol确定，重启网卡即可。</li>
</ol>
<pre><code class="language-cpp">//绑定端口
udpSocket-&gt;bind(QHostAddress("0.0.0.0"), 6789);
//设置组播数据不给自己发送/一般都会有这个设置/防止数据又发给自己造成死循环
udpSocket-&gt;setSocketOption(QAbstractSocket::MulticastLoopbackOption, 0);
//加入组播地址
udpSocket-&gt;joinMulticastGroup(QHostAddress("224.0.0.10"));
//往组播发送数据
udpSocket-&gt;writeDatagram("hello", QHostAddress("224.0.0.10"), 6789);
//接收数据和UDP接收数据处理完全一致
</code></pre>
<ol start="315">
<li>在Qt中结构体数据也是可以保存到ini配置文件，只不过保存后的数据是一堆qbytearray之类的字符，所以如果可读性优先，建议不要存储结构体数据，最起码也要是格式化后的结构体数据存储进去。要想用QSettings保存结构体数据，必须在结构体中重载实现输入输出数据流。</li>
</ol>
<pre><code class="language-cpp">struct ClientConfig {
    int tabIndex;    
    QString serverInfo;  

    //重载数据流输出
    friend QDataStream &amp;operator &lt;&lt; (QDataStream &amp;out, const ClientConfig &amp;clientConfig) {
        out &lt;&lt; clientConfig.tabIndex;        
        out &lt;&lt; clientConfig.serverInfo;        
        return out;
    }

    //重载数据流输入
    friend QDataStream &amp;operator &gt;&gt; (QDataStream &amp;in, ClientConfig &amp;clientConfig)
    {
        in &gt;&gt; clientConfig.tabIndex;        
        in &gt;&gt; clientConfig.serverInfo;        
        return in;
    }
};

//必须加上下面这句用来注册元数据类型,不然报错
//error: static assertion failed: Type is not registered, please use the Q_DECLARE_METATYPE macro to make it known to Qt's meta-object system
Q_DECLARE_METATYPE(ClientConfig)

//定义
ClientConfig clientConfig;

//读取
set.beginGroup("ClientConfig");
clientConfig = set.value("clientConfig").value&lt;ClientConfig&gt;();
set.endGroup();

//写入
set.beginGroup("ClientConfig");
set.setValue("clientConfig", QVariant::fromValue(clientConfig)); 
set.endGroup();
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/63094/202503/63094-20250327085048868-866994266.jpg" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.01012933765625" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-27 08:52">2025-03-27 08:51</span>&nbsp;
<a href="https://www.cnblogs.com/feiyangqingyun">飞扬青云</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18795201" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18795201);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18795201', targetLink: 'https://www.cnblogs.com/feiyangqingyun/p/18795201', title: 'Qt/C++开发经验小技巧311-315' })">举报</a>
</div>
        