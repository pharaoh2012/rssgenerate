
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18919081" title="发布于 2025-06-25 22:35">
    <span role="heading" aria-level="2">为什么说方法的参数最好不要超过4个？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="简介">简介</h1>
<p>在很多年前的一次Code Review中，有大佬指出，<code>方法的参数太多了，最好不要超过四个</code>，对于当时还是萌新的我，虽然不知道什么原因，但听人劝，吃饱饭，这个习惯也就传递下来了，直到参加工作很多年后，才明白这其中的缘由。</p>
<h1 id="调用协定">调用协定</h1>
<p>在计算机编程中，调用协定(Calling Convention)是一套关于方法/函数被调用时<code>参数传递方式</code>，<code>栈由谁清理</code>和<code>寄存器如何使用</code>的规范。</p>
<ol>
<li><strong>参数传递方式</strong></li>
</ol>
<ul>
<li><strong>寄存器传递</strong>：将参数存入CPU寄存器，速度最快。</li>
<li><strong>栈传递</strong>：将参数压入调用栈，再依次从栈中取出，速度最慢</li>
<li><strong>混合传递</strong>：前N个参数用寄存器，剩余参数用栈，速度适中</li>
</ul>
<ol start="2">
<li><strong>栈由谁清理</strong></li>
</ol>
<ul>
<li><strong>Caller清理</strong>：调用函数后由调用方负责恢复栈指针（如C/C++的<code>__cdecl</code>）。</li>
<li><strong>Callee清理</strong>：被调用函数返回前自行清理栈（如x64的默认协定）。</li>
</ul>
<ol start="3">
<li><strong>寄存器如何使用</strong></li>
</ol>
<ul>
<li><strong>易变寄存器（Volatile Registers）</strong>：函数调用时可能被修改的寄存器（如x64的<code>RAX</code>、<code>RCX</code>、<code>RDX</code>），调用方需自行保存这些寄存器的值。</li>
<li><strong>非易变寄存器（Non-Volatile Registers）</strong>：函数必须保存并恢复的寄存器（如x64的<code>RBX</code>、<code>RBP</code>、<code>R12-R15</code>）。</li>
</ul>
<h1 id="x86架构混乱的调用协定">x86架构混乱的调用协定</h1>
<p>x86架构发展较早，因此调用协定野蛮生长，有多种调用协定</p>
<table>
<thead>
<tr>
<th>协定名称</th>
<th>参数传递方式</th>
<th>栈清理</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__cdecl</code></td>
<td>通过栈传递（右→左）</td>
<td>调用者清理栈</td>
<td>C/C++默认，支持可变参数</td>
</tr>
<tr>
<td><code>__stdcall</code></td>
<td>通过栈传递（右→左）</td>
<td>被调用者清理栈</td>
<td>Windows API（如Win32）</td>
</tr>
<tr>
<td><code>__fastcall</code></td>
<td>前两个参数通过寄存器，剩余通过栈(右→左)</td>
<td>被调用者清理栈</td>
<td>高性能场景</td>
</tr>
<tr>
<td><code>__thiscall</code></td>
<td>this指针通过寄存器, 剩余通过栈(右→左)</td>
<td>被调用者清理栈</td>
<td>C++类成员函数</td>
</tr>
</tbody>
</table>
<h2 id="眼见为实">眼见为实</h2>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1084317/202506/1084317-20250625181829664-2062614404.png" class="lazyload"></p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1084317/202506/1084317-20250625181840235-352174074.png" class="lazyload"></p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1084317/202506/1084317-20250625181905573-160792192.png" class="lazyload"></p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1084317/202506/1084317-20250625181947730-1673360760.png" class="lazyload"></p>
<blockquote>
<p>可以看到，cdecl，stdcall是通过压栈的方式将参数压入栈中，而fastcall直接赋值给寄存器，并无压栈操作</p>
</blockquote>
<details>
<summary>点击查看代码</summary>
<pre><code>#include &lt;iostream&gt;

int __cdecl cdecl_add(int a, int b) {
	return a + b;
}

int __stdcall stdcall_add(int a, int b) {
	return a + b;
}

int __fastcall fastcall_add(int a, int b) {
	return a + b;
}

class Calculator {
public:
	int __thiscall thiscall_add(int b) {
		return this-&gt;a + b;
	}
	int a;
};


int main()
{
	int a = 10, b = 5;

	int cdecl_add_value = cdecl_add(a, b);
	int stdcall_add_value = stdcall_add(a, b);
	int fastcall_add_value = fastcall_add(a, b);

	Calculator calc;
	calc.a = 10;

	int thiscall_add_value = calc.thiscall_add(5);
}
</code></pre>
</details>
<h1 id="x64的大一统">x64的大一统</h1>
<p>而在x64架构下，为了解决割裂的调用协定，windows与linux实现了统一。</p>
<table>
<thead>
<tr>
<th>协定名称</th>
<th>参数传递方式</th>
<th>栈清理</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MS x64</code></td>
<td><strong>前4个</strong>参数通过寄存器，剩余通过栈<code>(左→右)</code></td>
<td>被调用者清理栈</td>
<td>Windows x64程序</td>
</tr>
<tr>
<td><code>System V AMD64</code></td>
<td><strong>前6个</strong>参数通过寄存器，剩余通过栈<code>(左→右)</code></td>
<td>被调用者清理栈</td>
<td>Unix/Linux x64程序</td>
</tr>
</tbody>
</table>
<h2 id="眼见为实-1">眼见为实</h2>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1084317/202506/1084317-20250625183349143-687453240.png" class="lazyload"></p>
<blockquote>
<p>linux下暂无图(因为我懒)，大概就是这意思，自行脑补</p>
</blockquote>
<details>
<summary>点击查看代码</summary>
<pre><code>#include &lt;stdio.h&gt;

int add(int a, int b, int c, int d, int e) {
    return a + b + c + d + e;
}

int main() {
    int result = add(1, 2, 3, 4, 5);
    return 0;
}
</code></pre>
</details>
<h1 id="c中使用哪种调用协定">C#中使用哪种调用协定？</h1>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1084317/202506/1084317-20250625212801159-2114274060.png" class="lazyload"></p>
<p>C#在x86下，有自己独特的调用协定</p>
<table>
<thead>
<tr>
<th>协定名称</th>
<th>参数传递方式</th>
<th>栈清理</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Standard</code></td>
<td>前两个参数通过寄存器，剩余通过栈<code>(左→右)</code></td>
<td>被调用者清理栈</td>
<td>C#静态方法</td>
</tr>
<tr>
<td><code>HasThis</code></td>
<td>前两个参数通过寄存器(第一个为This)，剩余通过栈<code>(左→右)</code></td>
<td>被调用者清理栈</td>
<td>C#实例方法</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在x64形成实现统一，与操作系统保持一致</p>
</blockquote>
<h2 id="眼见为实-2">眼见为实</h2>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1084317/202506/1084317-20250625213106738-520037254.png" class="lazyload"><br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1084317/202506/1084317-20250625214057324-773247664.png" class="lazyload"><br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1084317/202506/1084317-20250625214754527-1685032026.png" class="lazyload"></p>
<blockquote>
<p>注意寄存器与栈是两片独立运行的区域，光从汇编代码，很容易陷入误区，就拿上图来说，从上往下阅读汇编，你会发现参数传递的顺序是30(1Eh),40(28h),50(32h),10(0Ah),20(14h)。明显不对，这是因为一个是寄存器，一个是线程栈，这是两个不相关的区域，谁前谁后都不违反从左到右的规定。不能死脑筋，寄存器与栈之间是存在位置无关性的。</p>
</blockquote>
<pre><code>/*这种顺序也是正确的，寄存器是寄存器，栈是栈，汇编的顺序不影响他们的位置无关性，因为是两片独立运行的区域*/
push 1Eh
mov ecx,0Ah
push 28h
mov edx,14h
push 32h
</code></pre>
<details>
<summary>点击查看代码</summary>
<pre><code>    internal class Program
    {
        static void Main(string[] args)
        {
            var t = new Test();
            var sum = t.Add(10, 20, 30, 40, 50);

            var sum2 = Test.StaticAdd(10, 20, 30, 40, 50);

            Console.ReadKey();
        }
    }

    public class Test
    {
        public int Add(int a, int b, int c, int d, int e)
        {
            var sum = a + b + c + d + e;
            return sum;
        }

        public static int StaticAdd(int a, int b, int c, int d, int e)
        {
            var sum = a + b + c + d + e;
            return sum;
        }
    }
</code></pre>
</details>
<h1 id="结论">结论</h1>
<p>可以看到，在Windows x64下，如果方法的参数&lt;=4  那么就就完全避免了栈传递的开销，实现性能最佳化。<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1084317/202506/1084317-20250625223043077-1392443910.png" class="lazyload"></p>
<p>在linux下，参数为&lt;=6，根据木桶效应，取4为最佳。</p>
<blockquote>
<p>当然，此文不是让你严格遵守此规则，随着CPU性能的发展，在微服务集群大行其道的今天。这点性能差距可以忽略不计，权当饭后消遣，补充冷知识，<code>好让你在未来的Code Review中，没活硬整</code>.</p>
</blockquote>
<details>
<summary>点击查看代码</summary>
<pre><code>    internal class Program
    {
        static void Main(string[] args)
        {
            ParameterPassingBenchmark.Run();
        }
    }
    public class ParameterPassingBenchmark
    {
        private const int WarmupIterations = 100000;
        private const int BenchmarkIterations = 10000000;
        private const int BatchSize = 1000; // 批量调用次数，提高测量精度
        private static readonly Random _random = new Random(42);

        // x64平台前4个参数通过寄存器传递
        [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
        public static int Register4Params(int a, int b, int c, int d) =&gt; a + b + c + d;

        // 第5个参数通过栈传递
        [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
        public static int Stack1Param(int a, int b, int c, int d, int e) =&gt; a + b + c + d + e;

        // 第5-8个参数通过栈传递
        [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
        public static int Stack4Params(int a, int b, int c, int d, int e, int f, int g, int h)
            =&gt; a + b + c + d + e + f + g + h;

        public static void Run()
        {
            Console.WriteLine($"参数传递性能测试 - 预热: {WarmupIterations:N0}, 测试: {BenchmarkIterations:N0} 次");
            Console.WriteLine("----------------------------------------------------------------");

            // 生成随机输入数据以避免优化
            var inputData = GenerateInputData();

            // 预热
            Warmup(inputData);

            // 测试
            var reg4Time = Measure(() =&gt; Register4ParamsTest(inputData));
            var stack1Time = Measure(() =&gt; Stack1ParamTest(inputData));
            var stack4Time = Measure(() =&gt; Stack4ParamsTest(inputData));

            // 输出结果
            Console.WriteLine("\n===== 测试结果 =====");
            Console.WriteLine($"4寄存器参数: {reg4Time,12:N2} ns/次");
            Console.WriteLine($"4寄存器+1栈参数: {stack1Time,10:N2} ns/次 ({((double)stack1Time / reg4Time - 1) * 100:F1}% 性能下降)");
            Console.WriteLine($"4寄存器+4栈参数: {stack4Time,10:N2} ns/次 ({((double)stack4Time / reg4Time - 1) * 100:F1}% 性能下降)");
        }

        private static (int[], int[], int[]) GenerateInputData()
        {
            var data4 = new int[BenchmarkIterations * 4];
            var data5 = new int[BenchmarkIterations * 5];
            var data8 = new int[BenchmarkIterations * 8];

            for (int i = 0; i &lt; BenchmarkIterations; i++)
            {
                for (int j = 0; j &lt; 4; j++) data4[i * 4 + j] = _random.Next();
                for (int j = 0; j &lt; 5; j++) data5[i * 5 + j] = _random.Next();
                for (int j = 0; j &lt; 8; j++) data8[i * 8 + j] = _random.Next();
            }

            return (data4, data5, data8);
        }

        private static void Warmup((int[], int[], int[]) inputData)
        {
            Console.Write("预热中...");
            var (data4, data5, data8) = inputData;

            for (int i = 0; i &lt; WarmupIterations; i++)
            {
                Register4Params(data4[i * 4], data4[i * 4 + 1], data4[i * 4 + 2], data4[i * 4 + 3]);
                Stack1Param(data5[i * 5], data5[i * 5 + 1], data5[i * 5 + 2], data5[i * 5 + 3], data5[i * 5 + 4]);
                Stack4Params(data8[i * 8], data8[i * 8 + 1], data8[i * 8 + 2], data8[i * 8 + 3],
                            data8[i * 8 + 4], data8[i * 8 + 5], data8[i * 8 + 6], data8[i * 8 + 7]);
            }
            Console.WriteLine("完成");
        }

        private static long Measure(Func&lt;long&gt; testMethod)
        {
            // 强制GC并等待完成
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();

            // 冷启动
            testMethod();

            // 实际测量
            var stopwatch = Stopwatch.StartNew();
            long result = testMethod();
            stopwatch.Stop();

            // 使用结果以避免被优化掉
            if (result == 0) Console.WriteLine("警告: 结果为0，可能存在优化问题");

            // 计算平均时间（纳秒）
            long totalNs = stopwatch.ElapsedTicks * 10000000L / Stopwatch.Frequency;
            return totalNs / (BenchmarkIterations / BatchSize); // 除以实际调用批次
        }

        private static long Register4ParamsTest((int[], int[], int[]) inputData)
        {
            var (data4, _, _) = inputData;
            long sum = 0;
            int index = 0;

            for (int i = 0; i &lt; BenchmarkIterations / BatchSize; i++)
            {
                // 批量调用以提高测量精度
                for (int j = 0; j &lt; BatchSize; j++)
                {
                    sum += Register4Params(
                        data4[index++],
                        data4[index++],
                        data4[index++],
                        data4[index++]
                    );
                }
            }

            return sum;
        }

        private static long Stack1ParamTest((int[], int[], int[]) inputData)
        {
            var (_, data5, _) = inputData;
            long sum = 0;
            int index = 0;

            for (int i = 0; i &lt; BenchmarkIterations / BatchSize; i++)
            {
                // 批量调用以提高测量精度
                for (int j = 0; j &lt; BatchSize; j++)
                {
                    sum += Stack1Param(
                        data5[index++],
                        data5[index++],
                        data5[index++],
                        data5[index++],
                        data5[index++]
                    );
                }
            }

            return sum;
        }

        private static long Stack4ParamsTest((int[], int[], int[]) inputData)
        {
            var (_, _, data8) = inputData;
            long sum = 0;
            int index = 0;

            for (int i = 0; i &lt; BenchmarkIterations / BatchSize; i++)
            {
                // 批量调用以提高测量精度
                for (int j = 0; j &lt; BatchSize; j++)
                {
                    sum += Stack4Params(
                        data8[index++],
                        data8[index++],
                        data8[index++],
                        data8[index++],
                        data8[index++],
                        data8[index++],
                        data8[index++],
                        data8[index++]
                    );
                }
            }

            return sum;
        }
    }
</code></pre>
</details>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-25 22:36">2025-06-25 22:35</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">782</span>)&nbsp;
评论(<span id="post_comment_count">14</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18919081);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18919081', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18919081', title: '为什么说方法的参数最好不要超过4个？' })">举报</a>
</div>
        