
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18793857" title="发布于 2025-03-31 09:28">
    <span role="heading" aria-level="2">掌握设计模式--中介者模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="中介者模式mediator-pattern">中介者模式（Mediator Pattern）</h2>
<p><strong>中介者模式</strong>（Mediator Pattern）是一种行为型设计模式，它通过引入一个中介者对象，来减少多个对象之间的直接依赖，使对象之间的通信变得松耦合。对象不直接相互引用，而是通过中介者与其他对象交互。这有助于提高系统的可维护性和扩展性。</p>
<p><strong>核心思想：</strong> 将对象间复杂的<code>依赖关系</code><strong>抽象到</strong><code>中介者</code>中，从而使对象之间的依赖关系变得简单。</p>
<h3 id="主要组成部分">主要组成部分</h3>
<ul>
<li><strong>中介者接口（Mediator）：</strong> 定义了同事对象（Colleague）之间通信的接口。</li>
<li><strong>具体中介者（ConcreteMediator）：</strong> 实现中介者接口，协调各同事对象的通信逻辑。</li>
<li><strong>同事类（Colleague）：</strong> 持有中介者的引用，所有与其他同事的交互都通过中介者进行。</li>
</ul>
<h2 id="案例实现">案例实现</h2>
<p>以一个聊天系统为例，其中服务端作为中介者协调用户之间的通信。该案例不完全是中介者设计模式，但<strong>中介者模式的思想仍然保留</strong>服务器端负责协调各客户端之间的通信。</p>
<h3 id="案例交互关系">案例交互关系</h3>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202503/1209017-20250326152051181-42189907.png" alt="image" loading="lazy"></p>
<h3 id="服务端作为中介者">服务端作为中介者</h3>
<p>服务器端管理用户信息及接收来自客户端的消息并将其广播给其他客户端</p>
<pre><code class="language-java">public class ChatServer {
    private static final int PORT = 12345;
    private Set&lt;ClientHandler&gt; clients = new HashSet&lt;&gt;();

    public static void main(String[] args) {
        new ChatServer().startServer();
    }

    public void startServer() {
        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
            System.out.println("服务器启动，等待客户端连接...");

            while (true) {
                Socket socket = serverSocket.accept();
                System.out.println("新客户端连接：" + socket.getInetAddress().getHostAddress());
                // 处理用户发来的信息
                ClientHandler clientHandler = new ClientHandler(socket, this);
                clients.add(clientHandler);
                new Thread(clientHandler).start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 中介者分发消息
     * @param message 信息
     * @param sender 发送者
     */
    public synchronized void broadcast(String message, ClientHandler sender) {
        for (ClientHandler client : clients) {
            if (client != sender) {
                client.sendMessage(message);
            }
        }
    }

    public synchronized void removeClient(ClientHandler clientHandler) {
        clients.remove(clientHandler);
        System.out.println("客户端断开连接：" + clientHandler.getSocket().getInetAddress().getHostAddress());
    }

}
</code></pre>
<h3 id="处理客户端发来的消息">处理客户端发来的消息</h3>
<pre><code class="language-java">public class ClientHandler implements Runnable {
    private Socket socket;
    private ChatServer server;
    private PrintWriter out;

    public ClientHandler(Socket socket, ChatServer server) {
        this.socket = socket;
        this.server = server;
    }

    public Socket getSocket() {
        return socket;
    }

    @Override
    public void run() {
        try (
                InputStream input = socket.getInputStream();
                BufferedReader reader = new BufferedReader(new InputStreamReader(input))
        ) {
            out = new PrintWriter(socket.getOutputStream(), true);

            String message;
            while ((message = reader.readLine()) != null) {
                System.out.println("收到消息：" + message);
                server.broadcast(message, this);
            }
        } catch (IOException e) {
            System.out.println("客户端连接异常：" + e.getMessage());
        } finally {
            server.removeClient(this);
            closeSocket();
        }
    }

    public void sendMessage(String message) {
        if (out != null) {
            out.println(message);
        }
    }

    private void closeSocket() {
        try {
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="客户端作为同事类">客户端作为同事类</h3>
<pre><code class="language-java">public class ChatClient {
    private static final String SERVER_HOST = "localhost";
    private static final int SERVER_PORT = 12345;

    public static void main(String[] args) {
        try (
                Socket socket = new Socket(SERVER_HOST, SERVER_PORT);
                PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))
        ) {
            System.out.println("已连接到服务器，开始聊天...");

            // 启动线程处理接收消息
            new Thread(() -&gt; {
                try {
                    String message;
                    while ((message = in.readLine()) != null) {
                        System.out.println("收到消息：" + message);
                    }
                } catch (IOException e) {
                    System.out.println("服务器断开连接：" + e.getMessage());
                }
            }).start();

            // 主线程负责发送消息
            Scanner scanner = new Scanner(System.in);
            while (true) {
                String message = scanner.nextLine();
                out.println(message);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="测试步骤">测试步骤</h3>
<ol>
<li><strong>运行服务器端</strong>：启动 <code>ChatServer</code>，它会监听指定端口（12345）。</li>
<li><strong>运行多个客户端</strong>：启动多个 <code>ChatClient</code> 实例，每个客户端会连接到服务器。</li>
<li><strong>发送消息</strong>：在任意客户端中输入消息，服务器会将消息广播给其他所有已连接的客户端。</li>
</ol>
<h3 id="示例输出">示例输出</h3>
<p><strong>服务器端：</strong></p>
<pre><code>服务器启动，等待客户端连接...
新客户端连接：127.0.0.1
新客户端连接：127.0.0.1
收到消息：hi 1
收到消息：hi 2
</code></pre>
<p><strong>客户端 1：</strong></p>
<pre><code>已连接到服务器，开始聊天...
hi 1
收到消息：hi 2
</code></pre>
<p><strong>客户端 2：</strong></p>
<pre><code>已连接到服务器，开始聊天...
收到消息：hi 1
hi 2
</code></pre>
<h2 id="优缺点和使用场景">优缺点和使用场景</h2>
<h3 id="优点">优点</h3>
<ol>
<li><strong>降低对象耦合性：</strong> 对象不再直接依赖，而是通过中介者交互。</li>
<li><strong>集中控制复杂度：</strong> 中介者封装了对象间的交互逻辑，简化了对象管理。</li>
<li><strong>易于扩展：</strong> 新增同事类时，只需在中介者中添加相应的处理逻辑，无需修改现有同事类。</li>
</ol>
<h3 id="缺点">缺点</h3>
<ol>
<li><strong>中介者复杂性提升：</strong> 随着同事类和交互逻辑的增加，中介者可能变得臃肿难以维护。</li>
<li><strong>潜在性能问题：</strong> 由于所有交互通过中介者处理，可能导致性能瓶颈。</li>
</ol>
<h3 id="使用场景">使用场景</h3>
<ul>
<li>多个对象之间的交互复杂且逻辑分散；</li>
<li>系统中需要一个集中管理的通信控制器；</li>
<li>需要解耦对象间的依赖。</li>
</ul>
<h2 id="中介者模式的应用">中介者模式的应用</h2>
<p>Spring MVC的核心组件<code>DispatcherServlet</code>作为中介者，协调请求的处理过程。它调度不同的组件（<code>HandlerMapping</code>、<code>HandlerAdapter</code>、<code>ViewResolver</code>等）完成请求的分发和响应生成。<code>DispatcherServlet</code>负责管理整个请求的生命周期，避免了组件之间的直接耦合。</p>
<h2 id="总结">总结</h2>
<p>中介者模式适合用于多对象复杂交互的场景，通过引入中介者降低耦合度，集中管理交互逻辑。然而，要避免中介者变得过于复杂，需要合理设计中介者的职责边界。</p>
<p><strong>注意事项</strong></p>
<p>当中介者的逻辑过于复杂时，可以将其拆分为多个中介者或使用其他设计模式辅助管理复杂性。</p>
<p>在某些场景下，中介者模式可能被事件总线、观察者模式替代，根据实际需求选择适合的模式。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202503/1209017-20250326152035991-2015851425.gif" alt="image" loading="lazy"></p>
<p>需要查看往期设计模式文章的，可以在个人主页中或者文章开头的集合中查看，可关注我，持续更新中。。。</p>
<hr>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.06661083328935186" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-31 09:29">2025-03-31 09:28</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18793857" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18793857);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18793857', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18793857', title: '掌握设计模式--中介者模式' })">举报</a>
</div>
        