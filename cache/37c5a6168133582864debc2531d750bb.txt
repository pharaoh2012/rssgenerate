
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiaokang-coding/p/18759789" title="发布于 2025-03-08 20:10">
    <span role="heading" aria-level="2">别再用vector＜bool＞了！Google高级工程师：这可能是STL最大的设计失误</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>大家好，我是小康。今天我们来聊一个藏在C++标准库中的"定时炸弹"，它看起来人畜无害，但却坑了无数C++程序员。</p>
<h2 id="前言当你以为自己用的是vector结果却不是">前言：当你以为自己用的是vector，结果却不是</h2>
<p>嘿，各位码农兄弟姐妹们！今天咱们来聊一个你可能每天都在用，但是却从来没注意过的C++小怪兽：<code>vector&lt;bool&gt;</code>。</p>
<p>前几天，我在帮同事调一个莫名奇妙的bug，看到他代码里用了一堆<code>vector&lt;bool&gt;</code>来存储状态标志。我随口问了一句："你知道这玩意儿不是真正的 vector 吗？"</p>
<p>他一脸懵逼："啥？不可能吧？名字明明白白写着 vector 啊！"</p>
<p>就是这样，在C++的世界里，<code>vector&lt;bool&gt;</code>其实是个披着vector外衣的奇葩东西！据说在Google内部的一次技术分享中，一位高级工程师直言不讳地称它为"STL中最大的设计失误之一"。这不是我瞎编的，在C++标准委员会的多份提案文件中，也多次讨论过这个问题，甚至想在新标准中"修正"它，但又担心破坏向后兼容性。</p>
<p>今天我就来给大家扒一扒这个C++界的"猫头鹰"（白天是鸟，晚上是猫...不，是看起来像vector，实际不是vector）到底坑在哪里。保证讲得通俗易懂，小白也能看明白，包你看完直呼"涨姿势了"！</p>
<blockquote>
<p><strong>微信搜索 【跟着小康学编程】，关注我，定期分享计算机编程硬核技术文章。</strong></p>
</blockquote>
<h2 id="一vector是个什么妖怪">一、vector<bool>是个什么妖怪？</bool></h2>
<h3 id="正常的vector是啥样">正常的vector是啥样？</h3>
<p>在深入了解<code>vector&lt;bool&gt;</code>之前，我们得先搞清楚一个普通的 vector 该是啥样的。</p>
<p>想象一下，vector就像是一排连续的小格子，每个格子里放一个元素。当你用<code>vector&lt;int&gt;</code>时，每个格子大小固定为4字节（在大多数平台上），整齐划一地排列着：</p>
<pre><code class="language-c++">vector&lt;int&gt; normal_vec = {1, 2, 3};
int&amp; first = normal_vec[0];  // 拿到第一个元素的引用
first = 100;  // 修改这个引用
cout &lt;&lt; normal_vec[0];  // 输出100，没问题！
</code></pre>
<p>一切正常，对吧？你可以获取 vector 中元素的引用，然后通过引用修改元素值。这就是 C++ 引用的基本用法，相当于给同一块内存起了个别名，通过别名修改内存就是修改原始数据。</p>
<h3 id="再看vector">再看vector<bool></bool></h3>
<p>现在我们来试试 bool 版本的：</p>
<pre><code class="language-c++">vector&lt;bool&gt; weird_vec = {true, false, true};
bool&amp; first = weird_vec[0];  // 嗯？这行编译不过！
</code></pre>
<p>等一下！上面这行代码竟然编译不过！为啥？因为<code>vector&lt;bool&gt;[0]</code>返回的根本不是<code>bool&amp;</code>！</p>
<p>怎么回事？打开STL源码看看（为了便于理解，我简化了一下）：</p>
<pre><code class="language-c++">template &lt;typename T&gt;
class vector {
public:
    T&amp; operator[](size_t n) { return _data[n]; }
    // ...其他成员...
};

// 但是对于bool有特殊版本！
template &lt;&gt;
class vector&lt;bool&gt; {
public:
    // 注意返回类型不是bool&amp;
    reference operator[](size_t n) { /* 特殊实现 */ }
    // ...其他成员...
};
</code></pre>
<p>看到没？普通的 vector 返回的是<code>T&amp;</code>，但<code>vector&lt;bool&gt;</code>返回的是一个叫<code>reference</code>的东西，它不是真正的<code>bool&amp;</code>，而是一个代理类（proxy class）！</p>
<p>实际上，<code>vector&lt;bool&gt;</code>为了节省空间，内部做了特殊处理：它不是存储bool值，而是把8个bool打包成一个字节来存！让我用一个简单的图来说明：</p>
<pre><code class="language-bash">vector&lt;bool&gt; v_bool = { true, false, true };

内存布局:
+------------------------+
| 10100000 | .... | .... |
+------------------------+
   ↑↑↑        
   |||
   ||+--- 第3个元素 (true = 1)
   |+---- 第2个元素 (false = 0)
   +----- 第1个元素 (true = 1)


# 对于普通的vector&lt;int&gt;或其他类型，每个元素会占用完整的内存单元
vector&lt;int&gt; v_int = { 1, 0, 1 };

内存布局:
+--------+--------+--------+
|   1    |   0    |   1    |
+--------+--------+--------+
 4字节    4字节     4字节
</code></pre>
<p>与普通 vector 不同，<code>vector&lt;bool&gt;</code>在内部使用了位压缩存储。一个字节(8位)可以存储8个bool值，这就是它能节省空间的原因。</p>
<p>但这种存储方式带来了一个问题：C++中的引用必须指向一个完整的对象，不能指向对象的一部分位域。所以<code>vector&lt;bool&gt;</code>不能像其他 vector 一样返回元素的引用，而是返回一个特殊的代理对象，这个对象会记住元素的位置信息，并在需要时执行必要的位运算来读取或修改那一位。</p>
<p>这听起来是不是很像那些"挂羊头卖狗肉"的餐馆？你以为点的是"酱爆羊肉"，结果端上来的是"酱爆鸡肉假扮的羊肉"...</p>
<h2 id="二vector有什么坑">二、vector<bool>有什么坑？</bool></h2>
<h3 id="坑1引用返回不了许多常见操作失效">坑1：引用返回不了，许多常见操作失效</h3>
<p>我们来看一个更具体的例子：</p>
<pre><code class="language-c++">// 普通vector
vector&lt;int&gt; v_int(10, 0);
int* ptr = &amp;v_int[0];  // 正常
int&amp; ref = v_int[0];   // 正常

// 但对于vector&lt;bool&gt;
vector&lt;bool&gt; v_bool(10, false);
bool* ptr = &amp;v_bool[0];  // 编译错误！
bool&amp; ref = v_bool[0];   // 编译错误！
</code></pre>
<p>为啥会出错？因为<code>v_bool[0]</code>返回的是一个临时对象，不是真正的bool，你不能对临时对象取地址或绑定非常量引用。</p>
<p>这导致的一个严重后果是，很多依赖于引用语义的算法或操作在<code>vector&lt;bool&gt;</code>上会失效。</p>
<h3 id="坑2迭代器行为异常">坑2：迭代器行为异常</h3>
<p>迭代器在STL中扮演着至关重要的角色，但<code>vector&lt;bool&gt;</code>的迭代器行为与普通vector完全不同：</p>
<pre><code class="language-c++">vector&lt;int&gt; v_int = {1, 2, 3};
auto it = v_int.begin();
*it = 10;  // 没问题，修改了第一个元素

vector&lt;bool&gt; v_bool = {true, false, true};
auto it2 = v_bool.begin();
bool val = *it2;  // 获取值没问题
*it2 = false;     // 看起来也没问题

bool&amp; ref = *it2;  // 编译错误！
</code></pre>
<p>最后那行代码会报错，因为<code>*it2</code>返回的是一个临时对象，不是真正的bool引用。</p>
<p>这个例子完美展示了<code>vector&lt;bool&gt;</code>的特殊性：对于普通vector，你可以获取元素的引用；但对于<code>vector&lt;bool&gt;</code>，你只能获取一个临时代理对象。这个代理对象可以转换为 bool 值，也可以接受赋值，但它不是引用。</p>
<p>这种差异在使用标准算法时尤其成问题：</p>
<pre><code class="language-c++">// 对普通vector能正常工作
vector&lt;int&gt; nums = {1, 2, 3};
transform(nums.begin(), nums.end(), nums.begin(), 
          [](int&amp; x) { return x * 2; });  // 正常

// 但对vector&lt;bool&gt;会失败
vector&lt;bool&gt; flags = {true, false, true};
transform(flags.begin(), flags.end(), flags.begin(),
          [](bool&amp; x) { return !x; });  // 编译错误！
</code></pre>
<p>当编写泛型代码时，这种不一致性可能导致难以调试的问题。</p>
<h3 id="坑3作为模板参数时与其他类型不一致">坑3：作为模板参数时与其他类型不一致</h3>
<p>当你写一个通用模板函数，本来期望它能处理各种vector类型，结果<code>vector&lt;bool&gt;</code>却让你失望了：</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void process_vector(vector&lt;T&gt;&amp; vec) {
    T&amp; first = vec[0];  // 当T是bool时，这行爆炸！
    // ...处理逻辑...
}

vector&lt;int&gt; vi = {1, 2, 3};
process_vector(vi);  // 没问题

vector&lt;bool&gt; vb = {true, false, true};
process_vector(vb);  // 轰！编译错误！
</code></pre>
<p>这导致你要么放弃使用<code>vector&lt;bool&gt;</code>，要么为它写特殊处理代码，破坏了泛型编程的一致性。</p>
<h3 id="坑4与c-api交互困难">坑4：与C API交互困难</h3>
<p>假设你需要调用一个C API，它接受bool数组指针：</p>
<pre><code class="language-c++">// C API
extern "C" void process_flags(bool* flags, size_t count);

// 如果用普通数组
bool arr[100] = {false};
process_flags(arr, 100);  // 正常工作

// 如果用vector&lt;int&gt;
vector&lt;int&gt; vi(100, 0);
process_flags(reinterpret_cast&lt;bool*&gt;(vi.data()), vi.size());  // 勉强可以

// 如果用vector&lt;bool&gt;
vector&lt;bool&gt; vb(100, false);
process_flags(vb.data(), vb.size());  // 编译错误！vector&lt;bool&gt;没有data()方法！
</code></pre>
<p><code>vector&lt;bool&gt;</code>由于内部实现特殊，没有提供直接访问底层内存的方法，这使得它与C API交互变得异常困难。</p>
<h3 id="坑5并发编程中的噩梦">坑5：并发编程中的噩梦</h3>
<p>在多线程环境下，<code>vector&lt;bool&gt;</code>可能导致更严重的问题：</p>
<pre><code class="language-c++">vector&lt;bool&gt; flags(100, false);

// 线程1
flags[10] = true;

// 线程2（同时）
flags[11] = true;
</code></pre>
<p>因为<code>vector&lt;bool&gt;</code>内部可能8个bool值压缩在一个字节里，当两个线程同时修改相邻的位，它们实际上可能在修改同一个字节的不同位！这会导致数据竞争，即使从逻辑上看它们修改的是不同的元素。</p>
<p>这种问题在普通vector中是不会发生的，因为每个元素都是独立的内存区域。</p>
<h3 id="坑6常见的性能陷阱">坑6：常见的性能陷阱</h3>
<p>虽然<code>vector&lt;bool&gt;</code>的设计初衷是为了节省空间，但在某些情况下，它实际上可能导致性能下降：</p>
<pre><code class="language-c++">// 设置一百万个标志
vector&lt;bool&gt; flags(1000000);
for (int i = 0; i &lt; 1000000; i++) {
    flags[i] = (i % 2 == 0);  // 每次赋值都涉及位操作
}

// 相比之下，普通数组可能更快
bool* arr = new bool[1000000];
for (int i = 0; i &lt; 1000000; i++) {
    arr[i] = (i % 2 == 0);  // 简单的内存写入
}
</code></pre>
<p>由于<code>vector&lt;bool&gt;</code>每次赋值都需要计算位置并进行位操作，它的写入性能可能比直接使用bool数组要差。当然，这取决于具体的使用场景和编译器优化。</p>
<h2 id="三怎么避坑">三、怎么避坑？</h2>
<p>既然知道了<code>vector&lt;bool&gt;</code>是个大坑，那我们怎么避开它呢？根据不同的使用场景，有多种替代方案：</p>
<h3 id="方案1用vector或vectoruint8_t">方案1：用vector<char>或vector&lt;uint8_t&gt;</char></h3>
<p>最简单的替代方案是用<code>vector&lt;char&gt;</code>或<code>vector&lt;uint8_t&gt;</code>，这样每个bool值仍然占用一个字节，但行为与其他vector一致：</p>
<pre><code class="language-c++">vector&lt;char&gt; better_bools(100, 0);  // 0表示false
better_bools[50] = 1;  // 1表示true

char&amp; ref = better_bools[50];  // 可以获取引用，没问题！
</code></pre>
<p>这种方案的优点是简单直观，符合 vector 的一般行为，缺点是不如<code>vector&lt;bool&gt;</code>节省空间。</p>
<h3 id="方案2用deque或list">方案2：用deque<bool>或list<bool></bool></bool></h3>
<p>另一个选择是使用其他容器，如<code>deque&lt;bool&gt;</code>或<code>list&lt;bool&gt;</code>：</p>
<pre><code class="language-c++">deque&lt;bool&gt; deque_bools = {true, false, true};
bool&amp; first = deque_bools[0];  // 这行没问题！
</code></pre>
<p>这些容器没有为bool类型做特殊优化，所以它们的行为与其他类型一致。不过，它们的内存布局和性能特性与vector不同，使用前需要考虑你的具体需求。</p>
<h3 id="方案3如果真要省空间用stdbitset或动态位集">方案3：如果真要省空间，用std::bitset或动态位集</h3>
<p>如果空间效率确实很重要，可以考虑使用<code>std::bitset</code>或第三方的动态位集库：</p>
<pre><code class="language-c++">// 固定大小的位集
bitset&lt;100&gt; bits;
bits[0] = true;
bits[1] = false;

// 如果需要动态大小，可以考虑boost::dynamic_bitset
#include &lt;boost/dynamic_bitset.hpp&gt;
boost::dynamic_bitset&lt;&gt; dyn_bits(100);
dyn_bits[0] = true;
</code></pre>
<p><code>bitset</code>和<code>dynamic_bitset</code>明确告诉你它们是按位存储的，API设计也是针对位操作的，不会让你产生"这是普通容器"的误解。</p>
<h3 id="方案4用现代c的stdspan">方案4：用现代C++的std::span<bool></bool></h3>
<p>在C++20中，引入了<code>std::span</code>，它可以提供对连续序列的视图：</p>
<pre><code class="language-c++">#include &lt;span&gt;    // 用于std::span
  
// C++20
vector&lt;char&gt; storage(100, 0);  // 底层存储
span&lt;bool&gt; bool_view(reinterpret_cast&lt;bool*&gt;(storage.data()), storage.size());

// 现在可以当作bool数组使用
bool_view[10] = true;
</code></pre>
<p><code>span</code>本身不拥有存储空间，只是提供一个视图，所以它的行为更加可预测。不过，这需要C++20支持，而且你仍然需要自己管理底层存储。</p>
<blockquote>
<p><strong>微信搜索 【跟着小康学编程】，关注我，定期分享计算机编程硬核技术文章。</strong></p>
</blockquote>
<h3 id="方案5自定义boolvector类完整实战例子">方案5：自定义BoolVector类（完整实战例子）</h3>
<p>如果你需要一个完全符合vector语义的bool容器，可以自己实现一个：</p>
<pre><code class="language-c++">#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;

// 自定义一个与vector接口一致的bool容器
class BoolVector {
private:
    vector&lt;char&gt; data;  // 用char存bool，确保每个元素独立

public:
    // 构造函数
    BoolVector() = default;
    BoolVector(size_t size, bool value = false) : data(size, value) {}
    
    // 从初始化列表构造
    BoolVector(initializer_list&lt;bool&gt; il) {
    data.reserve(il.size());  // 预分配空间以提高效率
    for (bool value : il) {
        data.push_back(value);  // 将bool值转换为char存储
    }
}
    
    // 添加元素
    void push_back(bool value) {
        data.push_back(value);
    }
    
    // 访问元素（返回引用！）
    bool&amp; operator[](size_t pos) {
        return reinterpret_cast&lt;bool&amp;&gt;(data[pos]);
    }
    
    // 常量版本
    const bool&amp; operator[](size_t pos) const {
        return reinterpret_cast&lt;const bool&amp;&gt;(data[pos]);
    }
    
    // 获取大小
    size_t size() const {
        return data.size();
    }
    
    // 判断是否为空
    bool empty() const {
        return data.empty();
    }
    
    // 调整大小
    void resize(size_t new_size, bool value = false) {
        data.resize(new_size, value);
    }
    
    // 预留空间
    void reserve(size_t new_capacity) {
        data.reserve(new_capacity);
    }
    
    // 清空
    void clear() {
        data.clear();
    }
    
    // 支持迭代器
    typedef char* iterator;
    typedef const char* const_iterator;
    
    iterator begin() { return &amp;data[0]; }
    iterator end() { return &amp;data[0] + data.size(); }
    
    const_iterator begin() const { return &amp;data[0]; }
    const_iterator end() const { return &amp;data[0] + data.size(); }
};

// 使用示例
int main() {
    BoolVector my_bools(3, false);
    my_bools[0] = true;
    
    bool&amp; first = my_bools[0];  // 可以获取引用！
    first = false;
    
    cout &lt;&lt; "第一个元素: " &lt;&lt; (my_bools[0] ? "true" : "false") &lt;&lt; endl;
    
    // 支持迭代
    for (auto&amp; b : my_bools) {
        cout &lt;&lt; (b ? "true" : "false") &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    
    // 支持push_back
    my_bools.push_back(true);
    cout &lt;&lt; "大小: " &lt;&lt; my_bools.size() &lt;&lt; endl;
    
    return 0;
}
</code></pre>
<p>这个自定义的<code>BoolVector</code>类虽然占用空间比<code>vector&lt;bool&gt;</code>大，但行为与其他vector一致，不会给你带来意外惊喜。当然，这只是一个简化版本，完整实现还需要添加更多方法和优化。</p>
<h2 id="四为什么会有这种设计">四、为什么会有这种设计？</h2>
<p>说实话，<code>vector&lt;bool&gt;</code>的设计初衷是好的——节省内存空间。毕竟 bool 值只需要1个位就能表示，但C++中 bool 类型却占了1个字节（8位）。在内存非常宝贵的年代，这种优化是有意义的。</p>
<p>实际上，<code>vector&lt;bool&gt;</code>的特化是在C++98标准中引入的，那时候：</p>
<ol>
<li>C++标准库刚刚形成，很多设计理念还不成熟</li>
<li>内存资源相对珍贵，节省空间被认为比API一致性更重要</li>
<li>泛型编程和模板元编程的技术还没有充分发展</li>
<li>人们对"概念(Concept)"和"类型特征(Type Traits)"的理解还不够深入</li>
</ol>
<p>在当时看来，<code>vector&lt;bool&gt;</code>的空间优化似乎是一个不错的主意。但随着时间推移，人们逐渐认识到这种设计破坏了容器的抽象性和一致性，带来的麻烦远大于好处。</p>
<p>这就像是开发团队想给你省钱，结果却不小心把你的钱包丢了...</p>
<p>现在C++标准委员会已经认识到了这个问题，但由于向后兼容性的考虑，不能直接改变<code>vector&lt;bool&gt;</code>的行为。在C++17和C++20标准中，已经引入了更好的位集合处理方案，但<code>vector&lt;bool&gt;</code>这个"历史遗留问题"仍然存在。</p>
<h2 id="五现代c中的最佳实践">五、现代C++中的最佳实践</h2>
<p>随着C++的发展，处理bool集合的最佳实践也在不断演进。在现代C++项目中，我推荐以下做法：</p>
<h3 id="1-明确你的需求">1. 明确你的需求</h3>
<p>首先要思考你真正需要的是什么：</p>
<ul>
<li>需要高效的随机访问和修改？考虑<code>vector&lt;char&gt;</code></li>
<li>需要节省空间？考虑<code>bitset</code>或<code>dynamic_bitset</code></li>
<li>需要频繁插入删除？考虑<code>deque&lt;bool&gt;</code>或<code>list&lt;bool&gt;</code></li>
<li>需要与C API交互？使用原生bool数组</li>
</ul>
<h3 id="2-用适当的封装隐藏实现细节">2. 用适当的封装隐藏实现细节</h3>
<p>封装实现细节通常是个好主意，但不是绝对必要的。具体选择应该取决于实际需求：</p>
<pre><code class="language-c++">class FlagManager {
private:
    vector&lt;char&gt; flags_;  // 内部实现

public:
    // 提供bool语义的接口
    bool get(size_t index) const {
        return flags_[index] != 0;
    }
    
    void set(size_t index, bool value) {
        flags_[index] = value;
    }
    
    // ...其他方法...
};
</code></pre>
<p>这样，即使将来实现变了，用户代码也不需要改变。</p>
<p>但在某些情况下，直接使用标准容器可能更简单明了，特别是在性能关键的内循环或简单场景中。如同所有设计决策，应根据具体需求和上下文来选择适当的方法。</p>
<h3 id="3-考虑使用stdspanc20">3. 考虑使用std::span（C++20）</h3>
<p>如前所述，C++20的<code>std::span</code>提供了一个灵活的非拥有视图，可以用来处理bool序列：</p>
<pre><code class="language-c++">void process_flags(span&lt;bool&gt; flags) {
    for (bool&amp; flag : flags) {
        // 处理每个标志
    }
}

// 调用
vector&lt;char&gt; storage(100);
process_flags({reinterpret_cast&lt;bool*&gt;(storage.data()), storage.size()});
</code></pre>
<h3 id="4-使用强类型枚举代替单个bool">4. 使用强类型枚举代替单个bool</h3>
<p>当你需要表示多个相关的状态时，考虑使用强类型枚举而不是多个bool：</p>
<pre><code class="language-c++">// 不好：多个分散的bool
bool is_active;
bool is_visible;
bool is_enabled;

// 更好：使用枚举
enum class ItemState {
    Inactive = 0,
    Active = 1,
    Visible = 2,
    Enabled = 4
};

// 使用位操作
ItemState state = ItemState::Active | ItemState::Visible;
</code></pre>
<p>这样不仅代码更清晰，而且避免了处理多个bool的麻烦。</p>
<h2 id="六总结避开这个stl的设计失误">六、总结：避开这个STL的"设计失误"</h2>
<p>总结一下：</p>
<ol>
<li><code>vector&lt;bool&gt;</code>不是真正的vector，而是对bool做了特殊优化的容器适配器</li>
<li>它的行为与其他vector不一致，在引用、迭代器和并发等方面可能导致意想不到的错误</li>
<li>替代方案包括<code>vector&lt;char&gt;</code>、<code>deque&lt;bool&gt;</code>、<code>bitset</code>和自定义容器，根据具体需求选择合适的方案</li>
<li>现代C++提供了更多工具来解决这个问题，如<code>std::span</code>和强类型枚举</li>
</ol>
<p>最后，我想说的是，C++的设计哲学一向是"你不用的，你不付费"。但<code>vector&lt;bool&gt;</code>违背了这一哲学，它是少数几个会让你"被迫付费"的特性之一——即使你不需要空间优化，也不得不面对它与众不同的行为。</p>
<p>所以，下次当你想要一个bool的vector时，三思而后行，问问自己：我真的需要<code>vector&lt;bool&gt;</code>吗？还是其他替代方案更适合我的需求？</p>
<hr>
<p>欢迎在评论区分享你踩过的<code>vector&lt;bool&gt;</code>的坑！如果这篇文章对你有帮助，别忘了点赞、收藏和关注，我们下期再见！</p>
<p><strong>PS</strong>: 你知道吗？<code>vector&lt;bool&gt;</code>的这个"特例化"还有一个专业术语叫做"概念破坏者(concept breaker)"，因为它破坏了"容器"这个概念应有的一致性。这也是为什么在C++20的概念(Concepts)机制中，它不满足某些对常规容器的约束。有趣的是，C++标准委员会曾经考虑过引入一个真正的位向量类型来替代<code>vector&lt;bool&gt;</code>，但由于向后兼容性的考虑，最终没有这样做。相反，他们选择在标准中明确指出<code>vector&lt;bool&gt;</code>的特殊行为，并建议开发者在需要位集合时使用其他替代方案。</p>
<p>也欢迎各位小伙伴关注我的公众号「<strong>跟着小康学编程</strong>」，这里每周都会分享 <strong>C++、Linux编程、计算机网络、性能优化</strong> 等干货内容，未来还会新增 <strong>数据库MySQL、Redis、操作系统以及Go编程、Go微服务</strong> 等领域的知识。帮你少走弯路，一起进步！点击下方公众号名片关注我吧，加入我们的编程学习社区吧！</p>
<h4 id="怎么关注我的公众号">怎么关注我的公众号？</h4>
<p>扫下方二维码即可关注。</p>
<p><img src="https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png" alt="" loading="lazy"></p>
<p>另外，小康还建了一个技术交流群，专门聊技术、答疑解惑。如果你在读文章时碰到不懂的地方，随时欢迎来群里提问！我会尽力帮大家解答，群里还有不少技术大佬在线支援，咱们一起学习进步，互相成长！</p>
<p><img src="https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.170017957" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-08 20:11">2025-03-08 20:10</span>&nbsp;
<a href="https://www.cnblogs.com/xiaokang-coding">江小康</a>&nbsp;
阅读(<span id="post_view_count">20</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18759789" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18759789);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18759789', targetLink: 'https://www.cnblogs.com/xiaokang-coding/p/18759789', title: '别再用vector＜bool＞了！Google高级工程师：这可能是STL最大的设计失误' })">举报</a>
</div>
        