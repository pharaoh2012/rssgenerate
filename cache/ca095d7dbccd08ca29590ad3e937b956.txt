
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/san-mu/p/18982701" title="发布于 2025-07-13 19:11">
    <span role="heading" aria-level="2">MySQL 13 为什么表数据删掉一半，表文件大小不变？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>一个InnoDB表包含两部分：表结构定义和数据。在MySQL 8.0版本前，表结构存在以<code>.frm</code>为后缀的文件里。之后的版本允许把表结构定义放在系统数据表中。由于表结构定义占用空间很小，所以主要讨论表数据。</p>
<p>接下来，先说明为什么简单删除表数据达不到表空间回收的效果，再介绍正确回收空间的方法。</p>
<h3 id="参数innodb_file_per_table">参数<code>innodb_file_per_table</code></h3>
<p>表数据既可以存在共享表空间里，也可以是单独的文件，这由参数<code>innodb_file_per_table</code>控制：</p>
<ul>
<li>
<p>设为OFF，表示表数据放在系统共享表空间，也就是跟数据字典放在一起；</p>
</li>
<li>
<p>设为ON，表示每个InnoDB表数据存储在一个以<code>.ibd</code>为后缀的文件中。</p>
</li>
</ul>
<p>从MySQL 5.6.6版本开始，默认值为ON。建议也是使用ON，因为一个表单独存储为一个文件更容易管理，而且在不需要该表时通过<code>drop table</code>命令，系统就会直接删除文件；如果是放在共享表空间中，即使表删除，空间也是不会回收的。</p>
<p>接下来的讨论也是基于<code>innodb_file_per_table=ON</code>的设置。</p>
<p>在删除整张表的时候，可以使用<code>drop table</code>命令回收表空间。但是，平时更多的场景是删除某些行。</p>
<h3 id="数据删除流程">数据删除流程</h3>
<p>为了搞懂删除部分行的场景，需要先从数据删除流程开始说。</p>
<p>看一下InnoDB中一个索引的示意图：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250713190811977-506347502.png" width="30%"></div>
<p>假设要删除R4这个记录，InnoDB只会把R4这个记录标记为删除。如果之后插入一个ID在300-600间的记录，可能会复用这个位置，但磁盘文件的大小不会缩小。</p>
<p>那么如果将一个数据页上的所有记录都删除，会怎么样呢？答案是整个数据页可以复用。</p>
<p>但是数据页的复用和记录的复用还是不一样的。记录的复用只限于符合范围条件的数据，而一旦一个数据页可以复用，所有范围的数据都可以使用。比如在上面的索引中，若page A是可复用的，ID=50这样的记录也能使用该页。</p>
<p>如果相邻两个数据页利用率都很小，系统会把这两个页上的数据合到其中一个页上，另一个页就会被标记为可以复用。</p>
<p>进一步地，如果用delete命令删除整个表的数据，那么所有数据页都会被标记为可复用，而磁盘上的文件并不会变小。也就是说，delete命令不能回收表空间，这些可以复用却没被使用的空间，看起来就像“空洞”。</p>
<p>实际上不止删除数据会造成空洞，插入数据也会。如果数据的插入是随机的，可能造成索引的数据页分裂。比如在上面的索引中，假设page A已满，这时若要再插入一行数据ID=550：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250713190847646-531975448.png" width="30%"></div>
<p>当page A已满的情况下进行插入，就必须再申请一个新的页面page B来保存数据。由于页分裂导致部分数据移动，page A就出现了空洞。</p>
<p>除了插入，由于更新可以看为删除+插入，也可能造成空洞。即，增删改都可能出现空洞。所以，如果能把这些空洞去掉，就能达到收缩表空间的目的。</p>
<p>重建表就可以达到这样的目的。</p>
<h3 id="重建表">重建表</h3>
<p>假设现在有一个表A，需要去除其中的空洞，有什么办法呢？</p>
<p>可以新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据逐行从表A读取出来再插入到表B中。由于表B是新建的表，所以没有表A上的空洞。把表B作为临时表，数据从表A导入表B后，再用表B替换表A，从效果上就是表A没有空洞了。</p>
<p>可以使用<code>alter table A engine=InnoDB</code>的命令重建表。在MySQL 5.5版本前，这个命令的执行流程和上面描述的差不多，区别只是不需要自己创建临时表，MySQL会自动完成转存数据、交换表名、删除旧表的操作。</p>
<p>在往临时表插入数据的过程中，如果有新的数据要写入表A，会造成数据损失，因此整个DDL的过程中，表A不能有更新，即DDL不是Online的。</p>
<p>而MySQL 5.6开始的版本引入了Online DDL，对这个操作流程做了优化。新的流程为：</p>
<ul>
<li>
<p>建立一个临时文件；</p>
</li>
<li>
<p>扫描表A主键的所有数据页，用里面的记录生成B+树，存储到临时文件中；</p>
</li>
<li>
<p>生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中，对应下图中state 2的状态；</p>
</li>
<li>
<p>临时文件生成以后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的临时文件；</p>
</li>
<li>
<p>用临时文件替换表A。</p>
</li>
</ul>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250713190925264-640185922.png" width="50%"></div>
<p>该操作流程由于日志文件和重放操作的功能，在重建表的过程中允许对表A做增删改操作。</p>
<p>当然，由于对表做改动，会有MDL锁的存在。alter语句在启动时会获取MDL写锁，但这个锁在真正拷贝数据之前就会退化成读锁，目的是禁止其他线程对这个表同时做DDL，又不会阻塞增删改操作。</p>
<p>对于一个大表来说，Online DDL最耗时的过程就是拷贝数据到临时表的过程，所以相对整个DDL过程来说，写锁锁住的时间非常短，可以认为是Online的。</p>
<p>需要说明的是，上述这些重建方法都会扫描原表数据和构建临时文件，对于很大的表来说，该操作很消耗IO和CPU资源。因此，如果是线上服务需要控制操作时间，推荐使用开源的gh-ost来做。</p>
<h3 id="online和inplace">Online和inplace</h3>
<p>说到Online，再讲一个容易混淆的概念inplace。</p>
<p>在早版本的重建表过程中，表A数据导出来的存放位置叫做tmp_table，这个临时表是在Server层创建的。</p>
<p>而在后面的版本，表A重建出来的数据是放在tmp_file里的（见前面的图），这个临时文件是InnoDB在内部创建出来的。由于整个DDL过程在InnoDB内部完成，对于Server层来说，没有把数据挪动到临时表，是一个“原地”操作，因此叫inplace。</p>
<p>那么假如表大小为1TB，磁盘空间为1.2TB，是否能做inplace的DDL呢？答案是不行的，因为tmp_file会占用临时空间。</p>
<p>重建表的完整语句其实是下面这样：</p>
<pre><code class="language-sql">alter table t engine=innodb,ALGORITHM=inplace;
alter table t engine=innodb,ALGORITHM=copy;
</code></pre>
<p>其中，copy表示强制拷贝表，即使用临时表；inplace表示使用临时文件。</p>
<p>那是否表示，inplace就是Online？也不是，只是在重建表这个逻辑中刚好是这样。</p>
<p>如果说这两个逻辑之间的关系是什么，可以概括为：</p>
<ul>
<li>
<p>DDL过程如果是Online的，就一定是inplace的；</p>
</li>
<li>
<p>反之不正确，inplace的DDL，不一定是Online的。截止到 MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引 (SPATIAL index) 就属于这种情况。比如要给InnoDB表的一个字段加全文索引，过程是inplace的，但会阻塞增删改。</p>
</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-13 19:12">2025-07-13 19:11</span>&nbsp;
<a href="https://www.cnblogs.com/san-mu">叁沐</a>&nbsp;
阅读(<span id="post_view_count">98</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18982701);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18982701', targetLink: 'https://www.cnblogs.com/san-mu/p/18982701', title: 'MySQL 13 为什么表数据删掉一半，表文件大小不变？' })">举报</a>
</div>
        