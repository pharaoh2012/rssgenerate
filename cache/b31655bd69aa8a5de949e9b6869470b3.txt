
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/renzhesuanfa/p/18740031" title="发布于 2025-02-26 23:25">
    <span role="heading" aria-level="2">【忍者算法】从快慢指针到倒数查找：优雅解决链表倒数问题｜LeetCode第19题"删除链表的倒数第N个结点"</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="从快慢指针到倒数查找优雅解决链表倒数问题">从快慢指针到倒数查找：优雅解决链表倒数问题</h1>
<h2 id="从生活场景说起">从生活场景说起</h2>
<p>想象你在一个漫长的队伍中，想知道自己距离队尾还有多少人。一个巧妙的方法是：让你的朋友从你所在位置往后数N步，然后你和朋友一起向后走。当朋友走到队尾时，你的位置就正好是倒数第N个。这个生活中的小技巧，正是我们今天要探讨的链表算法的灵感来源。</p>
<h2 id="问题描述">问题描述</h2>
<p>LeetCode第19题"删除链表的倒数第N个结点"要求：给你一个链表的头节点 head 和一个整数 n ，请你删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>例如：</p>
<pre><code>输入：1 → 2 → 3 → 4 → 5, n = 2 
输出：1 → 2 → 3 → 5
解释：删除倒数第2个节点（值为4）

输入：1 → 2, n = 2
输出：2
解释：删除倒数第2个节点（值为1）

输入：1, n = 1
输出：空链表
解释：删除唯一的节点
</code></pre>
<h2 id="初步思路两次遍历法">初步思路：两次遍历法</h2>
<p>最直观的解法是先遍历一遍链表得到长度，然后再遍历一次删除目标节点：</p>
<pre><code class="language-java">public ListNode removeNthFromEnd(ListNode head, int n) {
    // 第一次遍历，计算链表长度
    int length = 0;
    ListNode current = head;
    while (current != null) {
        length++;
        current = current.next;
    }
    
    // 如果要删除的是头节点
    if (length == n) {
        return head.next;
    }
    
    // 找到待删除节点的前一个节点
    current = head;
    for (int i = 0; i &lt; length - n - 1; i++) {
        current = current.next;
    }
    
    // 执行删除操作
    current.next = current.next.next;
    
    return head;
}
</code></pre>
<h2 id="优化解法快慢指针一次遍历">优化解法：快慢指针一次遍历</h2>
<p>就像我们在队伍中的例子，我们可以用快慢指针在一次遍历内解决问题：</p>
<pre><code class="language-java">public ListNode removeNthFromEnd(ListNode head, int n) {
    // 创建哨兵节点，统一处理头节点的删除
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    
    // 初始化快慢指针
    ListNode fast = dummy;
    ListNode slow = dummy;
    
    // 快指针先走n+1步（多走一步是为了让慢指针停在待删除节点的前一个位置）
    for (int i = 0; i &lt;= n; i++) {
        fast = fast.next;
    }
    
    // 快慢指针同步移动
    while (fast != null) {
        fast = fast.next;
        slow = slow.next;
    }
    
    // 执行删除操作
    slow.next = slow.next.next;
    
    return dummy.next;
}
</code></pre>
<h3 id="图解过程">图解过程</h3>
<pre><code>例子：删除倒数第2个节点
1) 初始状态：
dummy → 1 → 2 → 3 → 4 → 5
S,F

2) 快指针先走n+1步：
dummy → 1 → 2 → 3 → 4 → 5
S           F

3) 同步移动直到快指针到末尾：
dummy → 1 → 2 → 3 → 4 → 5
            S           F

4) 删除slow.next节点：
dummy → 1 → 2 → 3 → 5
</code></pre>
<h2 id="深入理解快慢指针解法">深入理解快慢指针解法</h2>
<p>为什么这个方法能工作？让我们仔细分析：</p>
<ol>
<li>快指针先走n+1步，与慢指针产生n+1的距离</li>
<li>当快指针到达末尾（null）时，慢指针正好在待删除节点的前一个位置</li>
<li>这保证了我们总能找到待删除节点的前驱节点，便于执行删除操作</li>
</ol>
<h2 id="复杂度分析">复杂度分析</h2>
<p>两次遍历法：</p>
<ul>
<li>时间复杂度：O(L)，需要两次遍历</li>
<li>空间复杂度：O(1)</li>
<li>优点：直观易懂</li>
<li>缺点：需要两次遍历</li>
</ul>
<p>快慢指针法：</p>
<ul>
<li>时间复杂度：O(L)，只需一次遍历</li>
<li>空间复杂度：O(1)</li>
<li>优点：一次遍历即可完成，更优雅</li>
<li>缺点：需要理解快慢指针的原理</li>
</ul>
<h2 id="技巧总结">技巧总结</h2>
<ol>
<li>
<p>哨兵节点的使用</p>
<ul>
<li>统一了头节点的处理</li>
<li>避免了额外的边界检查</li>
</ul>
</li>
<li>
<p>快慢指针的设计</p>
<ul>
<li>快指针先走n+1步的巧妙设计</li>
<li>同步移动直至快指针到达末尾</li>
</ul>
</li>
<li>
<p>边界情况的处理</p>
<ul>
<li>链表长度等于n</li>
<li>只有一个节点</li>
<li>n等于链表长度</li>
</ul>
</li>
</ol>
<h2 id="实际应用延伸">实际应用延伸</h2>
<p>这种快慢指针的思想在实际开发中有很多应用：</p>
<ol>
<li>缓存淘汰算法</li>
<li>流式数据的滑动窗口处理</li>
<li>实时数据处理中的延迟计算</li>
</ol>
<h2 id="小结与思考">小结与思考</h2>
<p>通过这个问题，我们学到了：</p>
<ol>
<li>如何用空间换时间（两次遍历）</li>
<li>如何用巧妙的算法优化空间（快慢指针）</li>
<li>哨兵节点的实用价值</li>
<li>如何优雅处理链表的边界情况</li>
</ol>
<p>当我们遇到类似的"倒数"问题时，可以考虑：</p>
<ol>
<li>是否可以用快慢指针解决？</li>
<li>是否需要哨兵节点简化处理？</li>
<li>如何在一次遍历中完成任务？</li>
</ol>
<p>记住：有时看似复杂的问题，用合适的思维方式就能找到优雅的解决方案。</p>
<hr>
<p>作者：忍者算法<br>
公众号：忍者算法</p>
<p>我准备了一份刷题清单，以及这些题目的详细题解，覆盖了绝大部分常见面试题。我可以很负责任地说，只要你把这些题真正掌握了，80%的算法面试都能遇到相似题目。公众号回复【刷题清单】获取～</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03790373546180555" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-26 23:25">2025-02-26 23:25</span>&nbsp;
<a href="https://www.cnblogs.com/renzhesuanfa">忍者算法</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18740031" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18740031);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18740031', targetLink: 'https://www.cnblogs.com/renzhesuanfa/p/18740031', title: '【忍者算法】从快慢指针到倒数查找：优雅解决链表倒数问题｜LeetCode第19题&amp;quot;删除链表的倒数第N个结点&amp;quot;' })">举报</a>
</div>
        