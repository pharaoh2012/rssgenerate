
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/WoodJim/p/18664104" title="发布于 2025-01-10 15:45">
    <span role="heading" aria-level="2">Android 稳定性(二)：治理思路篇</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        一般来讲Android稳定性包括crash和ANR，本文主要围绕crash（应用的crash率）来讲述如何来做Android的稳定性相关的工作。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>本文同步发布于公众号：移动开发那些事:<a href="https://mp.weixin.qq.com/s/KihQ646esmZl_q-oY2_xkg" target="_blank" rel="noopener nofollow">Android 稳定性(二)：治理思路篇</a></p>
<p>一般来讲<code>Android</code>稳定性包括<code>crash</code>和<code>ANR</code>，本文主要围绕<code>crash</code>（应用的<code>crash</code>率）来讲述如何来做<code>Android</code>的稳定性相关的工作。在讲具体的思路之前，我们先来了解一下<code>Android</code>的异常捕获机制</p>
<h2 id="1-异常捕获机制">1 异常捕获机制</h2>
<p><code>Android</code>中的异常捕获机制从语言层面可以划分为<code>java</code>层和<code>native(C++)</code>层。</p>
<h3 id="11-java异常捕获机制">1.1 java异常捕获机制</h3>
<h4 id="111-基础">1.1.1 基础</h4>
<p><code>Throwable</code>是所有异常的基类，它有两个重要的子类：</p>
<ul>
<li><code>Error</code> : 严重的系统错误，如<code>OOM</code>,一般应用程序没有办法对其进行处理</li>
<li><code>Exception</code>:可被应用程序捕获和处理的异常，如<code>NPE</code></li>
</ul>
<p>一般我们在代码里处理的都是<code>Exception</code>相关的异常，而这些异常里，根据是否需要编译阶段处理，划分为两类：</p>
<ul>
<li>受检异常： 编译阶段就需要处理的，否则代码就无法通过编译（一般通过<code>try-catch</code>或者方法签名中使用<code>throws</code>声明会抛出该异常），如文件操作时的<code>IOException</code>;</li>
<li>非受检异常：编译阶段不要求处理，但运行时会出现的异常，包括运行时异常<code>RuntimeException</code>及其子类</li>
</ul>
<h4 id="112-使用">1.1.2 使用</h4>
<p>除了代码中很常用的,通过<code>try-catch</code>块来进行包裹可能出现异常的问题代码块外，还可以通过 <code>Thread.setDefaultUncaughtExceptionHandler</code> 对应用全局的异常进行捕获。例如在 <code>Application </code>类中设置此方法，当发生未处理的异常时，能够将异常信息记录下来，方便后续分析。一般是通过自定义类来实现<code>UncaughtExceptionHandler</code>的接口来实现全局的异常处理：</p>
<pre><code>class ACrash implements Thread.UncaughtExceptionHandler {
	public UncaughtExceptionHandler exceptionHandler;
	@Override
	public void uncaughtException(@NonNull Thread t, @NonNull Throwable e) {
       // 这里根据异常的类型和线程来做自定义的处理    

       // 在处理完自定义逻辑后，判断是否要把异常继续给原来的异常处理器
       if (exceptionHandler != null) {
       	exceptionHandler.uncaughtException(t, e) 
       } 

    }
}
</code></pre>
<p>这里在设置自定义异常处理接口时，有个点需要注意的是，如果有使用第三方的的<code>crash</code>收集系统，像<code>bugly</code>,<code>acrc</code>，此时在设置异常处理器时，需要注意是否已经设置过了：</p>
<pre><code>UncaughtExceptionHandler tmpHandler = Thread.getDefaultUncaughtExceptionHandler()
ACrash aHandle = ACrash()
// 要保留原来的异常处理
aHandle.exceptionHandler = tmpHandler
Thread.setDefaultUncaughtExceptionHandler(aHandle)
</code></pre>
<h3 id="12-native-异常捕获机制">1.2 native 异常捕获机制</h3>
<h4 id="121-基础">1.2.1 基础</h4>
<p><code>native</code> 层的异常捕获机制，除了类似的<code>try-catch</code>和<code>throw</code>抛出异常外，还有个系统层的信号分发处理机制。系统会通过分发信号来告知异常信息，所以异常的处理就是一个信号的处理,<br>
一般可通过<code>sigaction</code>函数来注册信息处理函数：</p>
<pre><code>static void signalHandler(int signal, siginfo_t *info, void *reserved) {
    // 处理信号
}
void initSignalHandler() {
    struct sigaction action;
    action.sa_flags = SA_SIGINFO;
    action.sa_sigaction = signalHandler;
    sigaction(SIGSEGV, &amp;action, NULL); // 捕获段错误
}
</code></pre>
<p>常见的信号量：</p>
<ul>
<li>SIGSEGV 11 无效的内存引用</li>
<li>SIGABRT 6 由abort发出的退出指令</li>
<li>SIGFPE 8 C浮点异常</li>
<li>SIGILL 4 非法指令</li>
<li>SIGBUS 10，7，总线错误（内存错误）</li>
<li>SIGKILL 9 kill 信号</li>
</ul>
<h4 id="122-使用">1.2.2 使用</h4>
<p><code>native</code> 异常捕获后，还涉及到<code>minidump</code>文件的获取和整个堆栈的还原，比较复杂，所以一般我们不直接自己注册信号监听来处理，会使用第三方的解决方案，如<code>bugly</code>，或使用<code>breakpad</code> 库来处理（<code>bugly</code>底层也是使用的<code>breakpad</code>）,<code>breakpad</code>的使用可参考:<a href="https://zhuanlan.zhihu.com/p/37378536" target="_blank" rel="noopener nofollow">如何在Android平台使用Google Breakpad</a></p>
<h2 id="2-分类与治理思路">2 分类与治理思路</h2>
<h3 id="21-分类">2.1 分类</h3>
<p>除了常规的业务代码的优化外（像常规的<code>npe</code>,<code>indexoutofboundsexception</code>等）还可以从操作系统的角度，将稳定性的优化问题可以大概分为以下几类：</p>
<ul>
<li>内存稳定性优化</li>
<li>线程稳定性优化</li>
<li>系统问题优化</li>
</ul>
<h3 id="22-治理思路">2.2 治理思路</h3>
<p>稳定性治理其实最终是为用户服务的，因此整个治理也是围绕<strong>提高用户的体验</strong>来展开。治理的思路主要是：</p>
<ul>
<li>能修复的，尽量去修复（像npe,oom）；</li>
<li>从业务上没有办法修复(像系统bug)，则尽可能减少对用户的影响，对一些异常进行降级</li>
</ul>
<p>提高用户的体验，无非就是要降低应用的<code>crash</code>率，这里有个核心的原则是：<strong>主要精力要花在<code>Top 10</code>，<code>Top20</code>的问题分析上</strong>，把主要的问题解决，顺带解决一些长尾的问题；</p>
<h4 id="221-内存治理">2.2.1 内存治理</h4>
<p>内存问题的治理主要围绕：<strong>尽可能减少运行的内存占用同时避免出现内存泄露</strong>，内存溢出的问题。这里需要借助一些工具来辅助我们判断可能的问题是什么：</p>
<ul>
<li>leakcanary: Square开源的，检测和诊断 Android 应用中的内存泄漏的工具，用于开发过程；</li>
<li>KOOM : 快手出的线上内存监控方案，可帮助更好优化应用的内存</li>
<li>Profiler：Android 自带的性能监控工具，可辅助分析内存<br>
（业内也还有其他的用于内存分析的工具，可以自行选择合适的，能解决问题就行）</li>
</ul>
<p>一些优化内存的方式，可参考前面的文章<a href="https://mp.weixin.qq.com/s/O6C5YvKH0Jv8RpNIvSRI7w" target="_blank" rel="noopener nofollow">Android稳定性(一)：内存使用指南</a></p>
<h4 id="222-线程治理">2.2.2 线程治理</h4>
<p>线程治理主要围绕：</p>
<ul>
<li>线程复用，尽可能使用线程池的方式来调度（不同的业务会采用不同的线程池策略）；</li>
<li>线程回收，线程使用完毕后，要及时调用关闭（shutdown）,如果有持有线程的变量，也要及时置空</li>
</ul>
<p>这里笔者在业务中，有尝试过几个优化的方向：</p>
<ul>
<li>限制<code>OkHttpClient</code>的最大线程数，避免无限增长，并且尽可能复用同一个<code>OKHttpClient</code></li>
<li>收敛线程，提供几个从线程池获取线程的方法，避免业务直接<code>new</code></li>
<li>线程池初始化的<code>core</code>线程根据不同的业务做差异化的初始化；</li>
<li>避免线程的实例被某个单例持有，导致线程关闭后也没有办法释放资源；</li>
</ul>
<h4 id="223-系统问题治理">2.2.3 系统问题治理</h4>
<p>由于<code>Android</code>版本的碎片化问题，会遇到各种只收集到系统堆栈的<code>crash</code>问题，无法从业务层面解决，这里就只能具体问题具体分析。针对系统问题，有个大的治理（分析）思路：<strong>对发生问题的系统版本进行聚类，判断是特定版本的问题还是通用的问题</strong>，有个猜测后，再去分析对应版本的源码验证猜测（假设 -&gt; 确定问题-&gt;解决问题）</p>
<p>可在线查看<code>Android</code>源码的地址:<a href="https://cs.android.com/android/platform/superproject" target="_blank" rel="noopener nofollow">Android Code Search</a></p>
<p>在确定问题后，在思考如何解决问题（系统问题大概率无法根治，只能尽可能减小对用户的影响）时，这里也有个大的框架：</p>
<ul>
<li>能通过<code>hook</code>系统接口处理的，就通过<code>hook</code>系统接口来处理（一般需要在<code>C++</code>层进行<code>hook</code>），如：
<ul>
<li>扩大系统的限制，如<code>Android 8.1</code>系统的文件描述符限制为1024，可通过<code>hook</code>接口扩充到<code>4096</code>,可减小由于<code>fd</code>溢出引起的问题；</li>
<li>降低系统的级别影响，如将<code>RenderThread</code>的问题由<code>abart</code>的 crash降低到丟帧；</li>
</ul>
</li>
<li>没有办法通过<code>hook</code>系统处理的：
<ul>
<li>不影响用户的异常，如<code>DeadSystemException</code>,<code>FinalizerWatchdogDaemonTimeout</code>这一类的，则可以直接在业务层<code>catch</code>住（可参考前面的异常捕获机制）</li>
<li>影响用户体验的异常，则还是要走<code>crash</code>的逻辑</li>
</ul>
</li>
</ul>
<h2 id="3-总结">3 总结</h2>
<p>本文围绕<code>Android</code>应用的<code>crash</code>率阐述了<code>Android</code>稳定性相关工作，先介绍异常捕获机制，再提出分类与治理的思路，旨在降低应用 crash 率，提升用户体验。<br>
通过合理的异常捕获机制的设置和优化策略，重点关注应用Top10和Top20的问题，对问题进行分类治理，可以有效提升应用的稳定性。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.9397961865034722" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-10 15:45">2025-01-10 15:45</span>&nbsp;
<a href="https://www.cnblogs.com/WoodJim">woodWu</a>&nbsp;
阅读(<span id="post_view_count">71</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18664104" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18664104);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18664104', targetLink: 'https://www.cnblogs.com/WoodJim/p/18664104', title: 'Android 稳定性(二)：治理思路篇' })">举报</a>
</div>
        