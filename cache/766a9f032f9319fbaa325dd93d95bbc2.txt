
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18823844" title="发布于 2025-04-13 21:35">
    <span role="heading" aria-level="2">深入理解权值线段树</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在上一篇探讨线段树的文章中 <a href="https://www.cnblogs.com/ofnoname/p/18625369" target="_blank">https://www.cnblogs.com/ofnoname/p/18625369</a>，我们已经掌握了如何利用线段树高效处理数组区间查询与更新问题。这种经典线段树以数组下标为构建基础，完美解决了诸如区间求和、最值查询等典型场景。</p>
<p>而线段树结构还有另外一个用处：想象这样一个场景：我们需要实时统计当前集合中数值在<code>[L,R]</code>范围内的元素个数，或者快速查询第<code>K</code>大的数值。此时，<strong>权值线段树（Weight Segment Tree）</strong>便闪亮登场——它巧妙的维护基础从"数组下标"转换为"值域空间"，开辟了线段树应用的新维度。</p>
<p>与常规线段树不同，权值线段树面临两个独特挑战：首先，值域范围可能非常庞大（如<code>[1,1e9]</code>），使得传统的数组存储方式变得不切实际；其次，值域分布往往极其稀疏（仅有少量离散点被使用）。这促使我们放弃静态的数组表示法，转而采用<strong>动态节点生成</strong>的指针表示法，只在必要时创建节点，从而大幅节省空间。</p>
<h2 id="权值线段树的基本原理">权值线段树的基本原理</h2>
<h3 id="从下标维护到值域维护">从下标维护到值域维护</h3>
<p>传统线段树维护的是<strong>数组下标区间</strong>的信息，例如：</p>
<ul>
<li>区间和：<span class="math inline">\(\text{sum}(l, r) = \sum_{i=l}^{r} a_i\)</span></li>
<li>区间最大值：<span class="math inline">\(\max(l, r) = \max(a_l, a_{l+1}, \dots, a_r)\)</span></li>
</ul>
<p>而权值线段树（也称为<strong>值域线段树</strong>）维护的是<strong>数值的值域区间</strong>，例如：</p>
<ul>
<li>数值在 <span class="math inline">\([L, R]\)</span> 范围内的出现次数</li>
<li>整个集合中第 <span class="math inline">\(K\)</span> 小的数</li>
</ul>
<h3 id="二叉树的表示方法">二叉树的表示方法</h3>
<p>线段树是一个二叉树。由于权值线段树的值域可能非常大（如 <span class="math inline">\([1, 10^9]\)</span>），甚至稀疏（仅有少量数值被插入），我们无法像传统线段树那样使用<strong>固定数组存储</strong>，而必须采用<strong>动态节点生成</strong>的指针表示法：</p>
<h4 id="数组表示法静态存储"><strong>数组表示法（静态存储）</strong></h4>
<ul>
<li>适用于<strong>紧凑且值域较小</strong>的情况（如 <span class="math inline">\([1, N]\)</span>，<span class="math inline">\(N \leq 10^6\)</span>）</li>
<li>类似堆式存储，节点 <span class="math inline">\(i\)</span> 的左儿子是 <span class="math inline">\(2i\)</span>，右儿子是 <span class="math inline">\(2i+1\)</span></li>
<li><strong>缺点</strong>：如果值域很大（如 <span class="math inline">\([1, 10^9]\)</span>），空间爆炸</li>
</ul>
<h4 id="指针表示法动态开点"><strong>指针表示法（动态开点）</strong></h4>
<ul>
<li>仅在实际插入数值时才创建对应的节点</li>
<li>每个节点存储：
<ul>
<li>值域区间 <span class="math inline">\([l, r]\)</span></li>
<li>统计信息（如出现次数 <span class="math inline">\(cnt\)</span>，区间和 <span class="math inline">\(sum\)</span>）</li>
<li>左儿子 <code>left</code> 和右儿子 <code>right</code> 指针</li>
</ul>
</li>
<li><strong>优点</strong>：节省空间，仅 <span class="math inline">\(O(M \log N)\)</span>，其中 <span class="math inline">\(M\)</span> 是操作次数，<span class="math inline">\(N\)</span> 是值域范围</li>
</ul>
<p><strong>关键点</strong>：</p>
<ul>
<li>只有被访问过的区间才会生成节点</li>
<li>父节点的信息由其子节点汇总（如 <code>cnt = left-&gt;cnt + right-&gt;cnt</code>）</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202504/1545207-20250413213315327-1106586517.png" alt="image" loading="lazy"></p>
<h2 id="权值线段树的实现细节">权值线段树的实现细节</h2>
<h3 id="节点结构设计">节点结构设计</h3>
<p>我们采用面向对象的方式定义权值线段树的节点结构：</p>
<pre><code class="language-cpp">struct Node {
    int l, r;       // 值域区间[l,r]
    int cnt;        // 该值域内数字出现次数
    int sum;        // 该值域内数字的和（可选）
    Node *left, *right; // 左右子节点指针

    Node(int _l, int _r) : l(_l), r(_r), cnt(0), sum(0), left(nullptr), right(nullptr) {}
};
</code></pre>
<h3 id="核心操作插入数值">核心操作：插入数值</h3>
<p>每次插入一个数x时，我们从根节点开始递归更新线段树：</p>
<ol>
<li>如果当前节点的值域区间[l,r]不包含x，直接返回</li>
<li>如果当前节点是叶子节点（l==r），更新统计信息</li>
<li>否则递归处理左右子树，并动态创建不存在的子节点</li>
</ol>
<pre><code class="language-cpp">void insert(Node* root, int x) {
    if (x &lt; root-&gt;l || x &gt; root-&gt;r) return;
    
    if (root-&gt;l == root-&gt;r) {
        root-&gt;cnt++;
        root-&gt;sum += x;
        return;
    }
    
    int mid = root-&gt;l + (root-&gt;r - root-&gt;l) / 2;
    if (x &lt;= mid) {
        if (!root-&gt;left) root-&gt;left = new Node(root-&gt;l, mid);
        insert(root-&gt;left, x);
    } else {
        if (!root-&gt;right) root-&gt;right = new Node(mid + 1, root-&gt;r);
        insert(root-&gt;right, x);
    }
    
    // 更新父节点统计信息
    root-&gt;cnt = (root-&gt;left ? root-&gt;left-&gt;cnt : 0) 
              + (root-&gt;right ? root-&gt;right-&gt;cnt : 0);
    root-&gt;sum = (root-&gt;left ? root-&gt;left-&gt;sum : 0)
              + (root-&gt;right ? root-&gt;right-&gt;sum : 0);
}
</code></pre>
<h3 id="查询值域统计">查询值域统计</h3>
<p>查询值域<span class="math inline">\([L,R]\)</span>内的数字个数（类似地可以查询和、最大值等）：</p>
<pre><code class="language-cpp">int query(Node* root, int L, int R) {
    if (!root || R &lt; root-&gt;l || L &gt; root-&gt;r) return 0;
    if (L &lt;= root-&gt;l &amp;&amp; root-&gt;r &lt;= R) return root-&gt;cnt;
    return query(root-&gt;left, L, R) + query(root-&gt;right, L, R);
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202504/1545207-20250413213526342-2074139561.png" alt="image" loading="lazy"></p>
<h3 id="查询第k小的数">查询第K小的数</h3>
<p>利用权值线段树可以高效查询第K小的数：</p>
<pre><code class="language-cpp">int kth(Node* root, int k) {
    if (root-&gt;l == root-&gt;r) return root-&gt;l;
    
    int left_cnt = root-&gt;left ? root-&gt;left-&gt;cnt : 0;
    if (k &lt;= left_cnt) return kth(root-&gt;left, k);
    return kth(root-&gt;right, k - left_cnt);
}
</code></pre>
<h3 id="内存管理">内存管理</h3>
<p>由于采用动态开点，需要手动管理内存以避免泄漏：</p>
<pre><code class="language-cpp">void clear(Node* root) {
    if (!root) return;
    clear(root-&gt;left);
    clear(root-&gt;right);
    delete root;
}
</code></pre>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度分析">时间复杂度分析</h3>
<p>权值线段树的所有核心操作都遵循二叉树搜索模式，其时间复杂度主要取决于树的高度。设值域范围为<span class="math inline">\([1, N]\)</span>：</p>
<ul>
<li><strong>插入操作</strong>：每次插入需要从根节点递归到叶子节点，时间复杂度为<span class="math inline">\(O(\log N)\)</span></li>
<li><strong>查询操作</strong>：
<ul>
<li>区间统计查询：<span class="math inline">\(O(\log N)\)</span></li>
<li>第K小查询：<span class="math inline">\(O(\log N)\)</span></li>
</ul>
</li>
<li><strong>删除操作</strong>（实现类似插入）：<span class="math inline">\(O(\log N)\)</span></li>
</ul>
<p>值得注意的是，这里的 <span class="math inline">\(N\)</span> 是值域范围，而非元素个数。当值域极大时（如 <span class="math inline">\([1,10^{18}]\)</span>），可以通过离散化预处理将<span class="math inline">\(N\)</span>降至元素数量级。</p>
<h3 id="空间复杂度分析">空间复杂度分析</h3>
<p>权值线段树的空间消耗主要来自动态创建的节点：</p>
<ul>
<li><strong>最坏情况</strong>：每个操作都访问全新的路径，需要创建<span class="math inline">\(O(\log N)\)</span>个新节点</li>
<li><strong>M次操作的空间消耗</strong>：<span class="math inline">\(O(M \log N)\)</span></li>
<li><strong>优化技巧</strong>：
<ul>
<li>惰性删除：标记删除而非立即回收节点</li>
<li>内存池预分配：减少动态内存分配开销</li>
</ul>
</li>
</ul>
<p>下表对比了不同情况下的空间使用：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>空间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态数组实现</td>
<td><span class="math inline">\(O(N)\)</span></td>
<td>值域较大时不可行</td>
</tr>
<tr>
<td>动态开点（最坏）</td>
<td><span class="math inline">\(O(M \log N)\)</span></td>
<td>每次操作都访问新路径</td>
</tr>
<tr>
<td>动态开点（平均）</td>
<td><span class="math inline">\(O(K \log N)\)</span></td>
<td>K为一个小于 M 的数</td>
</tr>
</tbody>
</table>
<h3 id="与离散化的配合使用">与离散化的配合使用</h3>
<p>对于极大值域但数据较为稀疏，若允许离线，可以先进行离散化处理：</p>
<pre><code class="language-cpp">vector&lt;int&gt; nums = {5, 3, 7, 1e9}; // 原始数据
sort(nums.begin(), nums.end());
nums.erase(unique(nums.begin(), nums.end()), nums.end());

// 建立值到排名的映射
unordered_map&lt;int, int&gt; val2rank;
for (int i = 0; i &lt; nums.size(); ++i) {
    val2rank[nums[i]] = i + 1; // 排名从1开始
}

// 此时权值线段树的值域可设为[1, nums.size()]
WeightSegmentTree tree(1, nums.size());
</code></pre>
<p>离散化后的优势：</p>
<ol>
<li>值域<span class="math inline">\(N\)</span>从原始范围降至实际数据规模，此时可以改用区间线段树的四倍数组写法了。</li>
<li>保持数值间的大小关系不变</li>
<li>查询时需要先将查询边界值离散化</li>
</ol>
<h2 id="权值线段树-vs-平衡树">权值线段树 vs 平衡树</h2>
<p>权值线段树和平衡树（如AVL树、红黑树）都可以解决以下常见问题：</p>
<ul>
<li>动态插入/删除数值</li>
<li>查询第K小的数</li>
<li>统计值域区间内的元素个数</li>
<li>查询前驱/后继</li>
</ul>
<p>但它们在实现方式和扩展性上存在本质差异：</p>
<p><strong>功能实现方式对比</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>权值线段树实现方式</th>
<th>平衡树实现方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入/删除</td>
<td>递归更新值域区间统计量</td>
<td>通过旋转操作维持平衡</td>
</tr>
<tr>
<td>第K小查询</td>
<td>利用子树节点数二分搜索</td>
<td>中序遍历或维护子树大小</td>
</tr>
<tr>
<td>前驱/后继查询</td>
<td>转化为值域边界查询</td>
<td>直接查找相邻节点</td>
</tr>
<tr>
<td>区间统计</td>
<td>天然支持区间求和/最值</td>
<td>需要额外维护统计信息</td>
</tr>
</tbody>
</table>
<p><strong>优先选择权值线段树当：</strong></p>
<ul>
<li>需要频繁查询第K小或区间统计</li>
<li>值域范围可离散化处理</li>
<li>需要可持久化或高维扩展</li>
<li>数据离线处理（预先知道值域）</li>
</ul>
<p><strong>优先选择平衡树当：</strong></p>
<ul>
<li>需要频繁插入/删除动态数据</li>
<li>需要有序遍历或范围迭代</li>
<li>处理非数值型数据或自定义比较</li>
<li>内存限制严格</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6135525197372685" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-13 21:36">2025-04-13 21:35</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">46</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18823844);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18823844', targetLink: 'https://www.cnblogs.com/ofnoname/p/18823844', title: '深入理解权值线段树' })">举报</a>
</div>
        