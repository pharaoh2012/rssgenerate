
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/myleaf/p/18630804" title="发布于 2024-12-25 19:57">
    <span role="heading" aria-level="2">关于Jetson nano (B02)如何部署Yolov8以及一些必要的知识点</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一前言">一、前言</h2>
<p>记录一个简单的安装和部署过程，尽管笔者也是按照教程来的，但奈何参考了很多教程，虽然写的都非常好，但是却很散，因此笔者这里想把这些教程的精华提炼出来，汇总并且写在正文处。还是老规矩，笔者也在学习，如有错误，请在评论区及时指出！感谢！也欢迎评论区一起讨论！</p>
<h2 id="二正文">二、正文</h2>
<h3 id="0bashrc">0.bashrc</h3>
<p>不知道大家有没有发现，一些安装教程总是写着<code>sudo gedit ~/.bashrc</code>,然后也不告诉你为啥这么做，我这里就简单的交代一下。[3]<br>
<code>.bashrc</code>是home目录下的一个shell文件，用于储存用户的个性化设置。在bash每次启动时都会加载.bashrc文件中的内容，并根据内容定制当前bash的配置和环境。</p>
<h3 id="1类似于">1.类似于？</h3>
<p>这就类似于windows的快捷方式，不用每次进入都需要重新输入路径，这就是在bashrc文件修改后能够做到的事情之一。<br>
环境变量就等于一个路径，这个路径由你而定。<br>
如果我们把环境变量比作一个地址簿：<br>
<code>export</code>就像把地址簿中重要的地址标记为“全家可用”，每个人（子进程）都可以查阅。<br>
<code>快捷方式</code>就像给某个地址做一个备忘录，任何人可以通过它找到目标，但备忘录本身不能改变目标的内容。</p>
<h3 id="2怎么用">2.怎么用？</h3>
<pre><code>PATH=$PATH:路径
export PATH
</code></pre>
<pre><code>export PATH=$PATH:路径
</code></pre>
<p>最后再<code>source ~/.bashrc</code>一下，就是让上面你改的这些立即生效。</p>
<p>当然还可以自定义快捷键：<br>
<code>alias yyds="cd home/java/"</code><br>
或者<br>
<code>alias ikun="conda deactivate"</code><br>
等等（不小心露出只因脚了）</p>
<h2 id="三安装">三、安装</h2>
<h3 id="0clion远程主机可选择可不折腾">0.clion远程主机（可选择，可不折腾）</h3>
<p>实现在主机PC上使用Clion就可以在Jetson上面编程了，类似与你在ubuntu上使用VScode这种。<br>
博客地址：[参考链接]<br>
(<a href="https://blog.csdn.net/weixin_74027669/article/details/142391303" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_74027669/article/details/142391303</a> "参考链接")<br>
（抱歉又让你跳来跳去了，不过上面文章写的超级详细！）<br>
不过我还是更喜欢在ubuntu上直接用vscode</p>
<h3 id="1jetpack镜像烧录">1.Jetpack镜像烧录</h3>
<p>英伟达官方给Jetson开发板系列（Nano, NX, Xavier）配备了一个用于AI开发的集合包Jetpack，包含以下包：</p>
<pre><code>Cuda
cuDNN
OpenCV4
TensorRT
VPI
VisionWorks
Vulkan
</code></pre>
<blockquote>
<p>所以你不用再傻乎乎的装什么TensorRT了啥的。。。这就是为啥叫你装系统的时候不要执着装Ubuntu新系统了，而是要去官网下载Jetpack了，因为人家把包的封装好了，哈哈哈哈。虽然JetPack也是基于ubuntu系统。。。</p>
</blockquote>
<p>并且提供了已装好Jetpack的Ubuntu系统镜像官方Jetpack镜像。不过不同板子的镜像不一定能混用（部分板子架构不同）。</p>
<p><img src="https://img2024.cnblogs.com/blog/3481742/202412/3481742-20241225165803526-1468169246.png" alt="image" loading="lazy"></p>
<p>烧录后，可以查看Jetpack的版本：</p>
<pre><code>cat /etc/nv_tegra_release
</code></pre>
<p>出现信息：</p>
<pre><code># R32 (Release), REVISION: 6.1
</code></pre>
<p>意思是大版本为<code>32</code>, 小版本为<code>4.6.1</code>，即<code>v32.4.6.1</code>，就说明没问题了</p>
<h3 id="2安装jtop可跳过不过尽量安装">2.安装jtop(可跳过,不过尽量安装)</h3>
<p>jtop是一个很开门的检测工具，用来查看cuda的型号、tensorRT的版本等，还能实时的看cpu和gpu的使用率等。<br>
首先安装pip</p>
<pre><code>sudo apt install python-pip python3-pip #安装Pip
pip3 install --upgrade pip #这俩哥们是来给pip进行升级的
pip install --upgrade pip
</code></pre>
<p>pip换源：<a href="https://blog.csdn.net/weixin_57950978/article/details/142653359" title="请参考这篇博客" target="_blank" rel="noopener nofollow">请参考这篇博客</a>  为啥换源，不还是原来的下载速度太慢了嘛。。。</p>
<p>安装jtop<br>
<code>sudo -H pip3 install jetson-stats</code></p>
<p>使用：<br>
<code>sudo jtop</code></p>
<p>安装成功后的结果是这个样子的：<br>
<img src="https://img2024.cnblogs.com/blog/3481742/202412/3481742-20241225172703370-176118088.png" alt="image" loading="lazy"></p>
<p>还可以查看版本的信息：<br>
<img src="https://img2024.cnblogs.com/blog/3481742/202412/3481742-20241225172729166-1546866316.png" alt="image" loading="lazy"><br>
按<code>Q</code>退出。</p>
<blockquote>
<p>也可以 <code>free -h</code>查看内存的使用情况，首先要知道直接从物理内存读写数据比硬盘读写数据要快的多，但是内存是有限的，所以就引出了物理内存和虚拟内存，物理内存是系统硬件提供的内存，是真正的内存，虚拟内存是为了满足物理内存不足时而提出的策略，他是利用磁盘空间虚拟出的逻辑内存，用作虚拟内存的磁盘空间被称为交换空间（swap space）</p>
</blockquote>
<p>在这里很方便的就可以看到是否和指定的安装环境是否匹配了。相当开门的开源软件了。<br>
在这里其实可以看到，我已经默认安装完毕了<code>TensorRT</code>和<code>OpenCV</code>了</p>
<p><img src="https://img2024.cnblogs.com/blog/3481742/202412/3481742-20241225173057732-765825434.png" alt="image" loading="lazy"></p>
<h3 id="3pt转换为onnx">3..pt转换为ONNX</h3>
<p>为了将模型部署到jetson nano当中，我们首先需要将需要转换的模型导出为onnx格式。首先，你需要下载YOLOv8的模型文件: <a href="https://github.com/ultralytics/ultralytics" title="代码点击此处跳转" target="_blank" rel="noopener nofollow">代码点击此处跳转</a><br>
由于jetson nano的GPU计算能力较弱，在这里我使用了YOLOv8n模型，并将输入图像的尺寸缩小为原来的四分之一。转换的代码如下所示：（自己随便写个脚本，运行下就ok）</p>
<pre><code>from ultralytics import YOLO
model = YOLO("yolov8n.pt")
model.export(imgsz=320, format='onnx')
</code></pre>
<p>这样，我们就得到了onnx格式的YOLOv8模型了。</p>
<h3 id="4onnx转换为engine">4.ONNX转换为Engine</h3>
<p>在 Jetson Nano 上，我们可以使用 TensorRT 对模型进行加速并部署。由于 TensorRT 对模型的优化与硬件有关，因此需要将 ONNX 模型上传至 Jetson Nano，并通过 <code>trtexec</code> 工具进行模型的转换。以下是模型转换的命令：<br>
<code>trtexec --onnx=&lt;ONNX file&gt; --saveEngine=&lt;output file&gt;</code><br>
我这边用的方法是:<br>
先切到yolo.onnx所在的目录里面，然后打开控制台：<br>
<code>trtexec --onnx=yolov8n.onnx --saveEngine=yolov8n.engine</code></p>
<p>通过以上操作，即可将YOLOv8模型转换为jetson nano支持的格式了。</p>
<h3 id="5导入模型运行">5.导入模型，运行</h3>
<p>这里有开源的github代码，带入即可，下面两个图我指定了在哪里进行替换，实在不会的也可以看“写在最后”部分的引用链接的原文章的教程。。<br>
<img src="https://img2024.cnblogs.com/blog/3481742/202412/3481742-20241225181122218-1634188681.png" alt="image" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/3481742/202412/3481742-20241225181151516-2035781179.png" alt="image" loading="lazy"></p>
<p><a href="https://github.com/Dominic23331/yolov8_tensorrt" target="_blank" rel="noopener nofollow">参考代码下载，里面readme写的很详细了，我这篇博客可以作为一个辅助进行参考</a><br>
希望多给原作者star!</p>
<h3 id="6-什么你不会运行简单交代下cmake编译的原理">6. 什么你不会运行？？简单交代下Cmake编译的原理</h3>
<p>CMake主要是编写CMakeLists.txt文件，然后用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库（so(shared object)）。因此CMake的编译基本就两个步骤：</p>
<pre><code>1. cmake
2. make
</code></pre>
<p>cmake 指向CMakeLists.txt所在的目录，例如cmake … 表示CMakeLists.txt在当前目录的上一级目录。cmake后会生成很多编译的中间文件以及makefile文件，所以一般建议新建一个新的目录，专门用来编译，例如</p>
<pre><code>mkdir build
cd build
cmake ..
make
</code></pre>
<p>make根据生成makefile文件，编译程序。<br>
按照下图新建build文件夹<br>
<img src="https://img2024.cnblogs.com/blog/3481742/202412/3481742-20241225192857119-1113953000.png" alt="image" loading="lazy"><br>
然后照我的上文进行编译，最终将生成一个可执行文件<br>
<img src="https://img2024.cnblogs.com/blog/3481742/202412/3481742-20241225193046090-51603582.png" alt="image" loading="lazy"><br>
控制台运行<br>
<code>./yolov8_tensorrt</code><br>
文件名称对用CmakeList这个地方<br>
<img src="https://img2024.cnblogs.com/blog/3481742/202412/3481742-20241225193252740-1341768966.png" alt="image" loading="lazy"></p>
<p>下次别再不懂了！</p>
<h3 id="7cmakelist文件解释">7.Cmakelist文件解释</h3>
<p>简略解释以下一些关键地方的指令的含义，这里再网上找了一个例子：</p>
<pre><code>cmake_minimum_required (VERSION 2.8)
project(dome CXX)
 
aux_source_directory(. DIR_SRC)
add_executable (demo ${DIR_SRC})
</code></pre>
<p>（1）<code>project</code>中的CXX指的是C++，如果不特别指定，则支持所有语言 ；工程名称中的dome可以自由指定。</p>
<p>（2）<code>aux_source_directory</code>作用是自动搜索指定路径下的全部源文件，指定的路径由关键字提供，且与之前的“.”之间有空格，表示DIR_SRC的上一级目录为指定的搜索路径。</p>
<p>（3）<code>add_executable</code> 中的第一个名字dome是我们编译后生成的可执行文件的名字，可以自由指定，不要求必须与工程同名。</p>
<h2 id="四写在最后">四、写在最后</h2>
<p>我按照自己的理解和原始博客没有标注的一些坑进行了我自己的总结和思考。<br>
这篇博客只是一个过程记录以及一些知识点的总结，与其像一些教程直接把结论给你，我更想把结论为什么也给你，不但知道怎么安装的，而且还可以知道为什么这么安装。当然，只是笔者的个人总结，会有很多错误和不恰当之处，希望和读者共勉！</p>
<h2 id="五参考文献">五、参考文献</h2>
<p>重点参考这篇大佬的博客：</p>
<p><a href="https://blog.csdn.net/m0_75272311/article/details/137983073" title="博文" target="_blank" rel="noopener nofollow">博文</a></p>
<p>同时特此鸣谢以下参考博客！</p>
<p><a href="https://developer.nvidia.com/nvidia-tensorrt-8x-download" title="TensorRT下载链接" target="_blank" rel="noopener nofollow">[1].TensorRT下载链接</a></p>
<p><a href="https://docs.nvidia.com/deeplearning/tensorrt/quick-start-guide/index.html" title="TensorRT的官网教程" target="_blank" rel="noopener nofollow">[2].TensorRT的官网教程</a></p>
<p><a href="https://blog.csdn.net/Heyyellman/article/details/111565781" title="什么是bashrc??" target="_blank" rel="noopener nofollow">[3].什么是bashrc??</a></p>
<p><a href="https://blog.csdn.net/qq_41035283/article/details/122737243" title="[4].关于系统安装的一些事情" target="_blank" rel="noopener nofollow">[4].关于Jetson nano系统安装前的一些需要知道的事情</a></p>
<p><a href="https://developer.nvidia.com/embedded/jetpack-archive" title="[6].Jetpack的官网版本" target="_blank" rel="noopener nofollow">[5].Jetpack的官网版本下载跳转</a></p>
<p><a href="https://blog.csdn.net/HW140701/article/details/120399455" title="[6].Onnx转转转" target="_blank" rel="noopener nofollow">[6].Onnx转转转</a></p>
<p><a href="https://blog.csdn.net/hhz_999/article/details/107860728" title="[7].下载完的Vscode怎么总是感觉终端输出字母之间有空格？？" target="_blank" rel="noopener nofollow">[7].下载完的Vscode怎么总是感觉终端输出字母之间有空格？？</a></p>
<p><a href="https://blog.csdn.net/m0_51451952/article/details/121015656" title="[8]. Cmake编译原理" target="_blank" rel="noopener nofollow">[8]. Cmake编译原理</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.014100486971064814" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-25 20:05">2024-12-25 19:57</span>&nbsp;
<a href="https://www.cnblogs.com/myleaf">泪水下的笑靥</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18630804" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18630804);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18630804', targetLink: 'https://www.cnblogs.com/myleaf/p/18630804', title: '关于Jetson nano (B02)如何部署Yolov8以及一些必要的知识点' })">举报</a>
</div>
        