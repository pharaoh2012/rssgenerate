<!----> <meta itemprop="headline" content="前端必学-完美组件封装原则"> <meta itemprop="keywords" content="前端,JavaScript,设计模式"> <meta itemprop="datePublished" content="2025-08-09T10:04:45.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Freedom风间"> <meta itemprop="url" content="https://juejin.cn/user/3919096662727789"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端必学-完美组件封装原则
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3919096662727789/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Freedom风间
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-08-09T10:04:45.000Z" title="Sat Aug 09 2025 10:04:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-08-09
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    6,704
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><p>此文总结了我多年组件封装经验，以及拜读 <code>antd</code>、<code>element-plus</code>、<code>vant</code>、<code>fusion</code>等多个知名组件库所提炼的完美组件封装的经验；是一个开发者在封装项目组件，公共组件等场景时非常有必要遵循的一些原则，希望和大家一起探讨，也希望世界上少一些半吊子组件😄</p>
<p>----持续更新</p>
<blockquote>
<p>下面以react为例，但是思路是相通的，在vue上也适用</p>
</blockquote>
<h2 data-id="heading-0">1. 基本属性绑定原则</h2>
<p>任何组件都需要继承<code>className</code>, <code>style</code> 两个属性</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> classNames <span class="hljs-keyword">from</span> <span class="hljs-string">'classnames'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CommonProps</span> {
  <span class="hljs-comment">/** 自定义类名 */</span>
  className?: <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">/** 自定义内敛样式 */</span>
  style?: <span class="hljs-title class_">React</span>.<span class="hljs-property">CSSProperties</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInputProps</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CommonProps</span> {
  <span class="hljs-comment">/** 值 */</span>
  <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span>
}
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props: MyInputProps, ref: React.LegacyRef&lt;HTMLDivElement&gt;</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { className, ...rest } = props;
  <span class="hljs-keyword">const</span> displayClassName = <span class="hljs-title function_">classNames</span>(<span class="hljs-string">'chc-input'</span>, className);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> {<span class="hljs-attr">...rest</span>} <span class="hljs-attr">className</span>=<span class="hljs-string">{displayClassName}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
});
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ChcInput</span>
</code></pre>
<h2 data-id="heading-1">2. 注释使用原则</h2>
<ul>
<li>原则上所有的<code>props</code>和<code>ref属性</code>类型都需要有注释</li>
<li>且所有属性（<code>props</code>和<code>ref属性</code>）禁用 <code>// 注释内容</code> 语法注释，因为此注释不会被ts识别，也就是鼠标悬浮的时候不会出现对应注释文案</li>
<li>常用的注视参数 <code>@description</code> 描述, <code>@version</code> 新属性的起始版本, <code>@deprecated</code> 废弃的版本, <code>@default</code> 默认值</li>
<li>面向国际化使用的组件一般描述语言推荐使用英文</li>
</ul>
<p>bad ❌</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInputsProps</span> {
  <span class="hljs-comment">// 自定义class</span>
  className?: <span class="hljs-built_in">string</span>
}
<span class="hljs-keyword">const</span> <span class="hljs-attr">test</span>: <span class="hljs-title class_">MyInputsProps</span> = {}
test.<span class="hljs-property">className</span>
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/74d69fcae6124c239c972fab1a90937c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRnJlZWRvbemjjumXtA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756434649&amp;x-signature=Lpv9czSa2My5q3My8NL%2BoBOQK8M%3D" alt="image.png" loading="lazy"></p>
<p>应该使用如下注释方法<br>
after good ✅</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInputsProps</span> {
  <span class="hljs-comment">/**  custom class */</span>
  className?: <span class="hljs-built_in">string</span>
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@description</span> Custom inline style
   * <span class="hljs-doctag">@version</span> 2.6.0
   * <span class="hljs-doctag">@default</span> ''
   */</span>
  style?: <span class="hljs-title class_">React</span>.<span class="hljs-property">CSSProperties</span>;
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@description</span> Custom title style
   * <span class="hljs-doctag">@deprecated</span> 2.5.0 废弃
   * <span class="hljs-doctag">@default</span> ''
   */</span>
  customTitleStyle?: <span class="hljs-title class_">React</span>.<span class="hljs-property">CSSProperties</span>;
}
<span class="hljs-keyword">const</span> <span class="hljs-attr">test</span>: <span class="hljs-title class_">MyInputsProps</span> = {}
test.<span class="hljs-property">className</span>
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3bf024ba6d04080949b63d0feba2293~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRnJlZWRvbemjjumXtA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756434649&amp;x-signature=tuToq5ShKDlANOMJkmLIRfsw%2F5M%3D" alt="image.png" loading="lazy"></p>
<h2 data-id="heading-2">3. export暴露</h2>
<ul>
<li>组件<code>props</code>类型必须<code>export</code>导出</li>
<li>如有 <code>useImperativeHandle</code> 则<code>ref</code>类型必须<code>export</code>导出</li>
<li>组件导出<code>funtion</code>必须有名称</li>
<li>组件<code>funtion</code>一般<code>export default</code>默认导出</li>
</ul>
<p>在没有名称的组件报错时不利于定位到具体的报错组件</p>
<p>bad ❌</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInputProps</span> {
    ....
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyInputProps</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
};
</code></pre>
<p>after good ✅</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// 暴露 MyInputProps 类型</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInputProps</span> {
    ....
}
funtion <span class="hljs-title class_">MyInput</span>(<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyInputProps</span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
};
<span class="hljs-comment">// 也可以自己挂载一个组件名称</span>
<span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">'production'</span>) {
  <span class="hljs-title class_">MyInput</span>.<span class="hljs-property">displayName</span> = <span class="hljs-string">'MyInput'</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyInput</span>
</code></pre>
<p>index.ts</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'./input'</span>
<span class="hljs-keyword">export</span> { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">MyInput</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./input'</span>;
</code></pre>
<p>当然如果目标组件没有暴露相关的类型，可以通过<code>ComponentProps</code>和<code>ComponentRef</code>来分别获取组件的<code>props</code>和<code>ref</code>属性</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">DialogProps</span> = <span class="hljs-title class_">ComponentProps</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Dialog</span>&gt; 
<span class="hljs-keyword">type</span> <span class="hljs-title class_">DialogRef</span> = <span class="hljs-title class_">ComponentRef</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Dialog</span>&gt; 
</code></pre>
<h2 data-id="heading-3">4. 入参类型约束原则</h2>
<p><strong>入参类型必须遵循具体原则</strong></p>
<ul>
<li>确定入参类型的可能情况下，切忌不可用<code>基本类型</code>一笔带过</li>
<li>公共组件一般不使用<code>枚举</code>作为入参类型，因为这样在使用者需要引入此枚举才可以不报错</li>
<li>部分数值类型的参数需要描述最大和最小值</li>
</ul>
<p>bad ❌</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InputProps</span> {
  <span class="hljs-attr">status</span>: <span class="hljs-built_in">string</span>
}
</code></pre>
<p>after good ✅</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InputProps</span> {
  <span class="hljs-attr">status</span>: <span class="hljs-string">'success'</span> | <span class="hljs-string">'fail'</span>
}
</code></pre>
<p>bad ❌</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InputProps</span> {
  <span class="hljs-comment">/** 总数 */</span>
  <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span>
}
</code></pre>
<p>after good ✅</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InputProps</span> {
  <span class="hljs-comment">/** 总数 0-999 */</span>
  <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span>
}
</code></pre>
<h2 data-id="heading-4">5. class和style定义规则</h2>
<ul>
<li>禁用 CSS module 因为此类写法会让使用者无法修改组件内部样式；vue 的话可以用 scoped 标签来防止样式重复 也可以实现父亲可修改组件内部样式。</li>
<li>书写组件时，内部的 <code>class</code> 一定要加上统一的<code>前缀</code>来区分组件内外 <code>class</code>，避免和外部的 class 类有重复。</li>
<li>class 类的名称需要语意化。</li>
<li>组件内部的所有 class 类都可以被外部使用者改变</li>
<li>禁用 important，不到万不得已不用行内样式</li>
<li>可以为颜色相关 CSS 属性留好 CSS 变量，方便外部开发主题切换</li>
</ul>
<p>bad ❌</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.module.less'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> funtion <span class="hljs-title class_">MyInput</span>(<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyInputProps</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.input_box}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.detail}</span>&gt;</span>21312312<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p>after good ✅</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> <span class="hljs-string">'./index.less'</span>
<span class="hljs-keyword">const</span> prefixCls = <span class="hljs-string">'my-input'</span> <span class="hljs-comment">// 统一的组件内部前缀</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> funtion <span class="hljs-title class_">MyInput</span>(<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyInputProps</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">prefixCls</span>}<span class="hljs-attr">-box</span>`}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">prefixCls</span>}<span class="hljs-attr">-detail</span>`}&gt;</span>21312312<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p>after good ✅</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.my-input-box</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">var</span>(--my-input-box-background, <span class="hljs-number">#000</span>);
}
</code></pre>
<h2 data-id="heading-5">6. 继承透传原则</h2>
<p>书写组件时如果进行了二次封装切忌不可将传入的属性一个一个提取然后绑定，这有非常大的局限性，一旦你基础的组件更新了或者需要增加使用的参数则需要再次去修改组件代码</p>
<p>bad ❌</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Input</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'某组件库'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInputProps</span> {
  <span class="hljs-comment">/** 值 */</span>
  <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-comment">/** 限制 */</span>
  <span class="hljs-attr">limit</span>: <span class="hljs-built_in">number</span>
  <span class="hljs-comment">/** 状态 */</span>
  <span class="hljs-attr">state</span>: <span class="hljs-built_in">string</span>
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">MyInput</span> = (<span class="hljs-params">props: Partail&lt;MyInputProps&gt;</span>) =&gt; {
  <span class="hljs-keyword">const</span> { value, limit, state } = props
  <span class="hljs-comment">// ...一些处理</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span> <span class="hljs-attr">limit</span>=<span class="hljs-string">{limit}</span> <span class="hljs-attr">state</span>=<span class="hljs-string">{state}</span>  /&gt;</span></span>
  )
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyInput</span>
</code></pre>
<p>以<code>extends</code>继承基础组件的所有属性，并用<code>...rest</code> 承接所有传入的属性，并绑定到我们的基准组件上。</p>
<p>after good ✅</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Input</span>, <span class="hljs-title class_">InputProps</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'某组件库'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInputProps</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputProps</span> {
  <span class="hljs-comment">/** 值 */</span>
  <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">MyInput</span> = (<span class="hljs-params">props: Partial&lt;MyInputProps&gt;</span>) =&gt; {
  <span class="hljs-keyword">const</span> { value, ...rest } = props
  <span class="hljs-comment">// ...一些处理</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span> {<span class="hljs-attr">...rest</span>}  /&gt;</span></span>
  )
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyInput</span>
</code></pre>
<h2 data-id="heading-6">7.事件配套原则</h2>
<p>任何组件内部操作导致<code>UI视图</code>改变都需要有配套的事件，来给使用者提供全量的触发钩子，提高组件的可用性</p>
<p>bad ❌</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> funtion <span class="hljs-title class_">MyInput</span>(<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyInputProps</span>) {
  <span class="hljs-comment">// ...省略部分代码</span>
  <span class="hljs-keyword">const</span> [open, setOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">const</span> [showDetail, setShowDetail] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">const</span> currClassName = <span class="hljs-title function_">classNames</span>(className, {
    <span class="hljs-string">`<span class="hljs-subst">${prefixCls}</span>-box`</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">`<span class="hljs-subst">${prefixCls}</span>-open`</span>: open, <span class="hljs-comment">// 是否采用打开样式</span>
  })
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onCheckOpen</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-title function_">setOpen</span>(!open)
  }
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onShowDetail</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-title function_">setShowDetail</span>(!showDetail)
  }
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{currClassName}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onCheckOpen}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onShowDetail}</span>&gt;</span>{showDetail ? '123' : '...'}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p>所有组件内部会影响外部UI改变的事件都预留了钩子<br>
after good ✅</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> funtion <span class="hljs-title class_">MyInput</span>(<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyInputProps</span>) {
  <span class="hljs-keyword">const</span> { onChange, onShowChange } = props
  <span class="hljs-comment">// ...省略部分代码</span>
  <span class="hljs-keyword">const</span> [open, setOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">const</span> [showDetail, setShowDetail] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-comment">// ...省略部分代码</span>
  <span class="hljs-keyword">const</span> currClassName = <span class="hljs-title function_">classNames</span>(className, {
    <span class="hljs-string">`<span class="hljs-subst">${prefixCls}</span>-box`</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">`<span class="hljs-subst">${prefixCls}</span>-open`</span>: open, <span class="hljs-comment">// 是否采用打开样式</span>
  })
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onCheckOpen</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-title function_">setOpen</span>(!open)
    onChange?.(!open) <span class="hljs-comment">// 实现组件内部open改变的事件钩子</span>
  }
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onShowDetail</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-title function_">setShowDetail</span>(!showDetail)
    onShowChange?.(!showDetail) <span class="hljs-comment">// 实现组件详情展示改变的事件钩子</span>
  }
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{currClassName}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onCheckOpen}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onShowDetail}</span>&gt;</span>{showDetail ? '123' : '...'}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<h2 data-id="heading-7">8. ref绑定原则</h2>
<p>任何书写的组件在有可能绑定<code>ref</code>情况下都需要暴露有<code>ref</code>属性，不然使用者一旦挂载<code>ref</code>则会导致控制台报错警告。</p>
<ul>
<li>原创组件：useImperativeHandle 或 直接ref绑定组件根节点</li>
</ul>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChcInputRef</span> {
  <span class="hljs-comment">/** 值 */</span>
  <span class="hljs-attr">setValidView</span>: <span class="hljs-function">(<span class="hljs-params">isShow?: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>,
  <span class="hljs-comment">/** 值 */</span>
  <span class="hljs-attr">field</span>: <span class="hljs-title class_">Field</span>
}
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ChcInput</span> = forwardRef&lt;<span class="hljs-title class_">ChcInputRef</span>, <span class="hljs-title class_">MyProps</span>&gt;(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { className, ...rest } = props;
  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> ({
    <span class="hljs-title function_">setValidView</span>(<span class="hljs-params">isShow = <span class="hljs-literal">false</span></span>) {
      <span class="hljs-title function_">setIsCheckBalloonVisible</span>(isShow);
    },
    field
  }), []);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{displayClassName}</span>&gt;</span>
          ...
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
});
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ChcInput</span>
</code></pre>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ChcInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props: MyProps, ref: React.LegacyRef&lt;HTMLDivElement&gt;</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { className, ...rest } = props;
  <span class="hljs-keyword">const</span> displayClassName = <span class="hljs-title function_">classNames</span>(<span class="hljs-string">'chc-input'</span>, className);
  <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{displayClassName}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
          ...
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
});
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ChcInput</span>
</code></pre>
<ul>
<li>二次封装组件：则直接ref绑定在原基础组件上 或 组件根节点</li>
</ul>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Input</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'某组件库'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ChcInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props: InputProps, ref: React.LegacyRef&lt;Input&gt;</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { className, ...rest } = props;
  <span class="hljs-keyword">const</span> displayClassName = <span class="hljs-title function_">classNames</span>(<span class="hljs-string">'chc-input'</span>, className);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{displayClassName}</span> {<span class="hljs-attr">...rest</span>} /&gt;</span></span>;
});
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ChcInput</span>
</code></pre>
<h2 data-id="heading-8">9. 自定义扩展性原则</h2>
<p>在组件封装时，遇到组件内部会用一些固定逻辑来渲染UI或者计算时，最好预留一个使用者可以随意自定义的入口，而不是只能死板采用组件内部逻辑，这样可以</p>
<ol>
<li>增加组件的扩展灵活性</li>
<li>减少迭代修改</li>
</ol>
<p>bad ❌</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> funtion <span class="hljs-title class_">MyInput</span>(<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyInputProps</span>) {
  <span class="hljs-keyword">const</span> { value } = props
  <span class="hljs-keyword">const</span> detailText = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-string">`组件内部复杂的逻辑：<span class="hljs-subst">${item}</span>`</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">'\n'</span>)
  }, [value])
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{detailText}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p>after good ✅</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> funtion <span class="hljs-title class_">MyInput</span>(<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyInputProps</span>) {
  <span class="hljs-keyword">const</span> { value, render } = props
  <span class="hljs-keyword">const</span> detailText = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// render 用户自定义渲染</span>
      <span class="hljs-keyword">return</span> render ? <span class="hljs-title function_">render</span>(value) : value.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-string">`组件内部复杂的逻辑：<span class="hljs-subst">${item}</span>`</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">'\n'</span>)
  }, [value])
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{detailText}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p>同理复杂的ui渲染也可以采用用户自定义传入<code>render</code>方法的方式进行扩展</p>
<h2 data-id="heading-9">10. 受控与非受控模式原则</h2>
<p>对于react组件，我们往往都会要求组件在设计时需要包含<code>受控</code>和<code>非受控</code>两个模式。<br>
<code>非受控</code>： 的情况可以实现更加方便的使用组件<br>
<code>受控</code>： 的情况可以实现更加灵活的使用组件，以增加组件的可用性</p>
<p>bad ❌（只有一种受控模式）</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> classNames <span class="hljs-keyword">from</span> <span class="hljs-string">'classnames'</span>;
<span class="hljs-keyword">const</span> prefixCls = <span class="hljs-string">'my-input'</span> 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> funtion <span class="hljs-title class_">MyInput</span>(<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyInputProps</span>) {
  <span class="hljs-keyword">const</span> { value, className, style, onChange } = props
  <span class="hljs-keyword">const</span> currClassName = <span class="hljs-title function_">classNames</span>(className, {
    <span class="hljs-string">`<span class="hljs-subst">${prefixCls}</span>-box`</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">`<span class="hljs-subst">${prefixCls}</span>-open`</span>: value, <span class="hljs-comment">// 是否采用打开样式</span>
  })
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onCheckOpen</span> = (<span class="hljs-params"></span>) =&gt; {
    onChange?.(!value)
  }
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{currClassName}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onCheckOpen}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>12312<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p>after good ✅</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> classNames <span class="hljs-keyword">from</span> <span class="hljs-string">'classnames'</span>;
<span class="hljs-keyword">const</span> prefixCls = <span class="hljs-string">'my-input'</span> 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> funtion <span class="hljs-title class_">MyInput</span>(<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyInputProps</span>) {
  <span class="hljs-keyword">const</span> { value, defaultValue = <span class="hljs-literal">true</span>, className, style, onChange } = props
  <span class="hljs-comment">// 实现非受控模式</span>
  <span class="hljs-keyword">const</span> [open, setOpen] = <span class="hljs-title function_">useState</span>(value || defaultValue)
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'boolean'</span>) <span class="hljs-keyword">return</span>
    <span class="hljs-title function_">setOpen</span>(value)
  }, [value])
  <span class="hljs-keyword">const</span> currClassName = <span class="hljs-title function_">classNames</span>(className, {
    <span class="hljs-string">`<span class="hljs-subst">${prefixCls}</span>-box`</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">`<span class="hljs-subst">${prefixCls}</span>-open`</span>: open, <span class="hljs-comment">// 是否采用打开样式</span>
  })
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onCheckOpen</span> = (<span class="hljs-params"></span>) =&gt; {
    onChange?.(!open)
    <span class="hljs-comment">// 非受控模式下 组件内部自身处理</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'boolean'</span>) {
      <span class="hljs-title function_">setOpen</span>(!open)
    }
  }
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{currClassName}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onCheckOpen}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>12312<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<h2 data-id="heading-10">11. 最小依赖原则</h2>
<p>所有组件封装都要遵循最小依赖原则，在条件允许的情况下，简单的方法需要引入新的依赖的情况下采用手写方式。这样避免开发出非常依赖融于的组件或组件库</p>
<p>bad ❌</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { useLatest } <span class="hljs-keyword">from</span> <span class="hljs-string">'ahooks'</span>  <span class="hljs-comment">// 之前组件库无ahooks, 会引入新的依赖！</span>
<span class="hljs-keyword">import</span> classNames <span class="hljs-keyword">from</span> <span class="hljs-string">'classnames'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ChcInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props: InputProps, ref: React.LegacyRef&lt;Input&gt;</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { className, ...rest } = props;
  <span class="hljs-keyword">const</span> displayClassName = <span class="hljs-title function_">classNames</span>(<span class="hljs-string">'chc-input'</span>, className);
  <span class="hljs-keyword">const</span> funcRef = <span class="hljs-title function_">useLatest</span>(func); <span class="hljs-comment">// 解决回调内无法获取最新state问题</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{displayClassName}</span> {<span class="hljs-attr">...rest</span>}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
});
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ChcInput</span>
</code></pre>
<p>after good ✅</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// hooks/index.tsx</span>
<span class="hljs-keyword">import</span> { useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useLatest</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(value);
  ref.<span class="hljs-property">current</span> = value;
  <span class="hljs-keyword">return</span> ref;
}
...
<span class="hljs-comment">// 组件</span>
<span class="hljs-keyword">import</span> { useLatest } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/hooks'</span>  <span class="hljs-comment">// 之前组件库无ahooks引入新的依赖！</span>
<span class="hljs-keyword">import</span> classNames <span class="hljs-keyword">from</span> <span class="hljs-string">'classnames'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ChcInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props: InputProps, ref: React.LegacyRef&lt;Input&gt;</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { className, ...rest } = props;
  <span class="hljs-keyword">const</span> displayClassName = <span class="hljs-title function_">classNames</span>(<span class="hljs-string">'chc-input'</span>, className);
  <span class="hljs-keyword">const</span> funcRef = <span class="hljs-title function_">useLatest</span>(func); <span class="hljs-comment">// 解决回调内无法获取最新state问题</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{displayClassName}</span> {<span class="hljs-attr">...rest</span>}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
});
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ChcInput</span>
</code></pre>
<p>当然依赖包是否引入也要参考当时的使用情况，比如如果<code>ahooks</code>在公司内部基本都会使用，那这个时候引入也无妨。</p>
<h2 data-id="heading-11">12. 功能拆分，单一职责原则</h2>
<p>如果一个组件内部能力很强大，可能包含多个功能点，不建议将所有能力都只在组件内部体现，可以将这些功能拆分成其他的公共组件, 一个组件只处理一个功能点（单一职责原则），提高功能的复用性和灵活性。<br>
当然业务组件除外，业务组件可以在组件内实现多个组件的整合完成一个业务能力的单一职责。</p>
<p>bad ❌</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyShowPage</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props: MyTableProps, ref: React.LegacyRef&lt;Table&gt;</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { data, imgList, ...rest } = props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Table</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span> {<span class="hljs-attr">...rest</span>}&gt;</span>
        {/* 表格显示相关功能封装 ...省略一堆代码 */}
      <span class="hljs-tag">&lt;/<span class="hljs-name">Table</span>&gt;</span> 
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        {/* 图例相关功能封装  ...省略一堆代码 */}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
});
</code></pre>
<p>将<code>表格</code>和<code>图例</code>两个功能点拆分成单独的两个公共组件<br>
after good ✅</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyShowPage</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props: MyTableProps, ref: React.LegacyRef&lt;Table&gt;</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { data, imgList, ...rest } = props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {/* 表格组件只处理表格内容 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">MyTable</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span> {<span class="hljs-attr">...rest</span>}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Table</span>&gt;</span> 
      {/* 图片组件只处理图片展示能力 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">MyImg</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{imgList}</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  )
});
</span></code></pre>
<p>当然如果完全没有复用价值的组件或功能点也是没必要拆分的。</p>
<h2 data-id="heading-12">13. 通用组件去业务，业务组件内置业务</h2>
<p>组件分为通用组件和业务组件，两者比较有明确的界限</p>
<ul>
<li>通用组件更看重通用功能性和基本内容展示，组件涵盖的使用范围广</li>
<li>业务组件更看重业务的实现，组件的使用范围绑定具体的业务内容</li>
</ul>
<ol>
<li>通用组件内部不能包含业务</li>
</ol>
<p>组件内部如果包含了业务内容，就会大大失去他的通用性，增加开发者心智负担。</p>
<p>比如：有个通用的table组件，负责将传入的数据进行展示，内部封装了当数据值小于0时，还是以正数的形式展示，但是使用红色字体：</p>
<p>bad ❌</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyTable</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props: MyTableProps, ref: React.LegacyRef&lt;Table&gt;</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { data, columns, ...rest } = props;
  
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">dataRender</span> = (<span class="hljs-params">item: ListItem</span>) =&gt; { 
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(item.<span class="hljs-property">value</span>)
  }
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">styleRender</span> = (<span class="hljs-params">item: ListItem </span>) =&gt; {
    <span class="hljs-keyword">return</span> item.<span class="hljs-property">value</span> &lt; <span class="hljs-number">0</span> ? { <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span> } : <span class="hljs-literal">undefined</span>
  }
  <span class="hljs-keyword">const</span> tableColumns = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> columns.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
        <span class="hljs-keyword">if</span>(item.<span class="hljs-property">name</span> === <span class="hljs-string">'value'</span>) {
          <span class="hljs-keyword">return</span> { 
              ...item, 
              <span class="hljs-attr">render</span>: dataRender, 
              <span class="hljs-attr">styleRender</span>: styleRender 
          };
        }
        <span class="hljs-keyword">return</span> { ...item };
    })
  }, [column])
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Table</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span> {<span class="hljs-attr">...rest</span>}&gt;</span>
      {columns.map(column =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Table.Column</span> {<span class="hljs-attr">...column</span>}/&gt;</span>)}
    <span class="hljs-tag">&lt;/<span class="hljs-name">Table</span>&gt;</span></span>
  )
});
</code></pre>
<p>显然这样的逻辑在一个通用组件内是不合理的，业务性太强，开发者在使用的时候还要纳闷为什么值都是正数，难道是接口返回有问题？<br>
通用组件只承接通用的展示能力，上面的业务就放入到使用层去处理即可</p>
<p>after good ✅</p>
<p>组件内部：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyTable</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props: MyTableProps, ref: React.LegacyRef&lt;Table&gt;</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { data, columns, ...rest } = props;
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Table</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{tableData}</span> {<span class="hljs-attr">...rest</span>}&gt;</span>
      {columns.map(column =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Table.Column</span> {<span class="hljs-attr">...column</span>}/&gt;</span>)}
    <span class="hljs-tag">&lt;/<span class="hljs-name">Table</span>&gt;</span></span>
  )
});
</code></pre>
<p>使用：</p>
<pre><code class="hljs language-tsx" lang="tsx">
<span class="hljs-keyword">const</span> columns = [
  {
    <span class="hljs-attr">title</span>: <span class="hljs-string">'名称'</span>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'name'</span>, 
  },
  { 
    <span class="hljs-attr">title</span>: <span class="hljs-string">'数值'</span>, 
    <span class="hljs-attr">name</span>: <span class="hljs-string">'value'</span>, 
    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(item.<span class="hljs-property">value</span>), 
    <span class="hljs-attr">style</span>: <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">value</span> &lt; <span class="hljs-number">0</span> ? { <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span> } : <span class="hljs-literal">undefined</span> 
  },
  ...
]
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Home</span> = (<span class="hljs-params">props: MyTableProps, ref: React.LegacyRef&lt;Table&gt;</span>) =&gt; {
  <span class="hljs-keyword">const</span> [list, setList] = <span class="hljs-title function_">useState</span>([]);
  ...
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Table</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{list}</span> <span class="hljs-attr">columns</span>=<span class="hljs-string">{columns}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>
  )
};
</code></pre>
<ol start="2">
<li>业务组件尽可能的在内部实现业务，降低使用者的使用负担</li>
</ol>
<p>我们在封装业务组件的时候，切忌不可将相关复杂的业务逻辑以及运算放到组件外面由使用者去实现，在组件内部只是一些简单的封装；这很难达到业务组件的价值最大化，业务组件的目的就是聚焦某个业务尽可能的帮开发者快速完成。</p>
<p>比如：有个音乐table组件，负责将传入的数据进行一个音乐业务渲染和展示：</p>
<p>bad ❌</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyMusicTable</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props: MyTableProps, ref: React.LegacyRef&lt;Table&gt;</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { data, ...rest } = props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Table</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span> {<span class="hljs-attr">...rest</span>}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Table.Column</span> <span class="hljs-attr">dataIndex</span>=<span class="hljs-string">"test1"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"标题1"</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Table.Column</span> <span class="hljs-attr">dataIndex</span>=<span class="hljs-string">"test2"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"标题2"</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Table.Column</span> <span class="hljs-attr">dataIndex</span>=<span class="hljs-string">"data"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"值"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Table</span>&gt;</span></span>
  )
});
</code></pre>
<p>但是有一个业务是当数据的<code>type=1</code>时，data的值要乘2展示，则上面的组件使用者只能这样使用：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> res = [...]
<span class="hljs-keyword">const</span> data = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> ({
    ...item,
    <span class="hljs-attr">data</span>: item.<span class="hljs-property">type</span> === <span class="hljs-number">1</span> ? item.<span class="hljs-property">data</span> * <span class="hljs-number">2</span> : item.<span class="hljs-property">data</span>
  }))
}, [res])
<span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyMusicTable</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}/</span>&gt;</span></span>
)
</code></pre>
<p>显然这样的封装在使用者这边会有一些心智负担，假如一个不熟悉业务的人来开发很容易会遗漏，所以这个时候需要业务组件内置业务，降低使用者的门槛</p>
<p>after good ✅</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyMusicTable</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props: MyTableProps, ref: React.LegacyRef&lt;Table&gt;</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { data, ...rest } = props;
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">dataRender</span> = (<span class="hljs-params">item: ListItem</span>) =&gt; {
    <span class="hljs-keyword">return</span> item.<span class="hljs-property">type</span> === <span class="hljs-number">1</span> ? item.<span class="hljs-property">data</span> * <span class="hljs-number">2</span> : item.<span class="hljs-property">data</span>
  }
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Table</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span> {<span class="hljs-attr">...rest</span>}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Table.Column</span> <span class="hljs-attr">dataIndex</span>=<span class="hljs-string">"test1"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"标题1"</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Table.Column</span> <span class="hljs-attr">dataIndex</span>=<span class="hljs-string">"test2"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"标题2"</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Table.Column</span> <span class="hljs-attr">dataIndex</span>=<span class="hljs-string">"data"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"值"</span> <span class="hljs-attr">render</span>=<span class="hljs-string">{dataRender}/</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Table</span>&gt;</span></span>
  )
});
</code></pre>
<p>使用者无需关心业务也可以顺利圆满完成任务：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> res = [...]
<span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyMusicTable</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{res}/</span>&gt;</span></span>
)
</code></pre>
<h2 data-id="heading-13">14. 最大深度扩展性</h2>
<p>当组件传入的数据可能会有树形等有深度的格式，而组件内部也会针对其渲染出有递归深度的UI时，需要考虑到使用者对于数据深度的不可控性，组件内部需要预留好无限深度的可能<br>
如下渲染组件方式只有一层的深度，很有局限性</p>
<p>bad ❌</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Columns</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TableColumnProps</span> {
   <span class="hljs-attr">columns</span>: <span class="hljs-title class_">TableColumnProps</span>[]
}
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyTable</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props: MyTableProps, ref: React.LegacyRef&lt;Table&gt;</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { data, columns = [], ...rest } = props;
  <span class="hljs-keyword">const</span> renderColumn = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> columns.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
       <span class="hljs-keyword">return</span> item.<span class="hljs-property">columns</span> ? (
         <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Table.Column</span> {<span class="hljs-attr">...item</span>}&gt;</span>
           {item.columns.map(column =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Table.Column</span> {<span class="hljs-attr">...column</span>}/&gt;</span>)}
         <span class="hljs-tag">&lt;/<span class="hljs-name">Table.Column</span>&gt;</span></span>
       ) :  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Table.Column</span> {<span class="hljs-attr">...item</span>}/&gt;</span></span>
    })
  }, [columns])
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Table</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span> {<span class="hljs-attr">...rest</span>}&gt;</span>
      {renderColumn}
    <span class="hljs-tag">&lt;/<span class="hljs-name">Table</span>&gt;</span></span>
  )
});
</code></pre>
<p>after good ✅</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Columns</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TableColumnProps</span> {
  <span class="hljs-attr">columns</span>: <span class="hljs-title class_">Columns</span>[] <span class="hljs-comment">// 改变为继承自己</span>
}
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyTable</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props: MyTableProps, ref: React.LegacyRef&lt;Table&gt;</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { data, columns = [], ...rest } = props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Table</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span> {<span class="hljs-attr">...rest</span>}&gt;</span>
      {/* 采用外部组件 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">MyColumn</span> <span class="hljs-attr">columns</span>=<span class="hljs-string">{columns}/</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Table</span>&gt;</span></span>
  )
});
<span class="hljs-keyword">const</span> <span class="hljs-title function_">MyColumn</span> = (<span class="hljs-params">props: MyColumnProps</span>) =&gt; {
  <span class="hljs-keyword">const</span> { columns = [] } = props
  <span class="hljs-keyword">return</span> (
    item.<span class="hljs-property">columns</span> ? (
     <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Table.Column</span> {<span class="hljs-attr">...item</span>}&gt;</span>
      {/* 递归渲染数据，实现数据的深度无限性 */}
       <span class="hljs-tag">&lt;<span class="hljs-name">MyColumn</span> <span class="hljs-attr">columns</span>=<span class="hljs-string">{item.columns}/</span>&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">Table.Column</span>&gt;</span></span>
   ) :  
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Table.Column</span> {<span class="hljs-attr">...item</span>}/&gt;</span></span>
  )
}
</code></pre>
<h2 data-id="heading-14">15. 多语言可配制化</h2>
<ul>
<li>组件内部所有的语言都需要可以修改，兼容多语言的使用场景</li>
<li>默认推荐英文</li>
<li>内部语言变量较多时可以统一暴露一个例如 <code>strings</code> 对象参数，其内部可以传入所有可以替换文案的key</li>
</ul>

<pre><code class="hljs language-css" lang="css">strings={{
  title: <span class="hljs-string">'标题'</span>,
  cancel: <span class="hljs-string">'取消'</span>,
  ....
}}
</code></pre>
<p>bad ❌</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> prefixCls = <span class="hljs-string">'my-input'</span> <span class="hljs-comment">// 统一的组件内部前缀</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> funtion <span class="hljs-title class_">MyInput</span>(<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyInputProps</span>) {
  <span class="hljs-keyword">const</span> { title = <span class="hljs-string">'标题'</span> } = props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">prefixCls</span>}<span class="hljs-attr">-box</span>`}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">prefixCls</span>}<span class="hljs-attr">-title</span>`}&gt;</span>{title}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">prefixCls</span>}<span class="hljs-attr">-detail</span>`}&gt;</span>详情<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p>after good ✅</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> prefixCls = <span class="hljs-string">'my-input'</span> <span class="hljs-comment">// 统一的组件内部前缀</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> funtion <span class="hljs-title class_">MyInput</span>(<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyInputProps</span>) {
  <span class="hljs-keyword">const</span> { title = <span class="hljs-string">'title'</span>, detail = <span class="hljs-string">'detail'</span> } = props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">prefixCls</span>}<span class="hljs-attr">-box</span>`}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">prefixCls</span>}<span class="hljs-attr">-title</span>`}&gt;</span>{title}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">prefixCls</span>}<span class="hljs-attr">-detail</span>`}&gt;</span>{detail}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<h2 data-id="heading-15">16.异常捕获和提示</h2>
<ul>
<li>对于用户传入意外的参数可能带来错误时要控制台 console.error 提示</li>
<li>不要直接在组件内部 throw error，这样会导致用户的白屏</li>
<li>缺少某些参数或者参数不符合要求但不会导致报错时可以使用 console.warn 提示</li>
</ul>
<p>bad ❌</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> funtion <span class="hljs-title class_">MyCanvas</span>(<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyCanvasProps</span>) {
  <span class="hljs-keyword">const</span> { instanceId } = props;
  
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
     <span class="hljs-title function_">initDom</span>(instanceId)
  }, [])
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{instanceId}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p>after good ✅</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> funtion <span class="hljs-title class_">MyCanvas</span>(<span class="hljs-attr">props</span>: <span class="hljs-title class_">MyCanvasProps</span>) {
  <span class="hljs-keyword">const</span> { instanceId } = props;
  
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span>(!instanceId){
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'missing instanceId!'</span>)
      <span class="hljs-keyword">return</span>
    }
     <span class="hljs-title function_">initDom</span>(instanceId)
  }, [])
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{instanceId}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<h2 data-id="heading-16">17. 语义化原则</h2>
<p>组件的命名，组件的api，方法，包括内部的变量定义都要遵循语义化的原则，严格按照其代表的功能来命名。</p></div></div>