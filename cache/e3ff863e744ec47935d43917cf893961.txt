
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zqfstack/p/19037690" title="发布于 2025-08-14 14:24">
    <span role="heading" aria-level="2">linux三剑客详解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3678334/202508/3678334-20250814142402802-509931861.png" alt="linux三剑客详解" class="desc_img">
        grep,sed,awk三剑客命令详解
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="grep命令">grep命令</h1>
<h2 id="持的正则参数">⽀持的正则参数</h2>
<table>
<thead>
<tr>
<th>支持的正则</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-E，–extended-regexp</td>
<td>模式是扩展正则表达式（ERE)</td>
</tr>
<tr>
<td>-P，–perl-regexp</td>
<td>模式是perl正则表达式</td>
</tr>
<tr>
<td>-e，–regexp=PATTERN</td>
<td>使用模式匹配，可指定多个模式匹配</td>
</tr>
<tr>
<td>-f，–file=FILE</td>
<td>从文件每一行获取匹配模式</td>
</tr>
<tr>
<td>-i，–ignore-case</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>-l，–files-with-matches</td>
<td>只匹配列出行所在的文件名</td>
</tr>
<tr>
<td>-w，–word-regexp</td>
<td>模式匹配整个单词（精确匹配）</td>
</tr>
<tr>
<td>-x，–line-regexp</td>
<td>模式匹配整行，精确匹配</td>
</tr>
<tr>
<td>-v，–invert-match</td>
<td>打印不匹配的行（取反）</td>
</tr>
</tbody>
</table>
<h2 id="输出控制参数">输出控制参数</h2>
<table>
<thead>
<tr>
<th>输出控制</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c，–count</td>
<td>只打印每个文件匹配的行数</td>
</tr>
<tr>
<td>-h，–no-filename</td>
<td>不输出文件名</td>
</tr>
<tr>
<td>-H，–with-filename</td>
<td>打印每个匹配的文件名</td>
</tr>
<tr>
<td>-m，–max-count=NUM</td>
<td>输出匹配的结果num数</td>
</tr>
<tr>
<td>-n，–line-number</td>
<td>打印行号</td>
</tr>
<tr>
<td>-o，–only-matching</td>
<td>只打印匹配的内容</td>
</tr>
<tr>
<td>-q，–quiet</td>
<td>不输出正常信息</td>
</tr>
<tr>
<td>-r，–recursive</td>
<td>递归目录</td>
</tr>
<tr>
<td>-s, --no-messages</td>
<td>不输出错误信息</td>
</tr>
<tr>
<td>–include=FILE_PATTERN</td>
<td>只检索匹配的文件</td>
</tr>
<tr>
<td>–exclude=FILE_PATTERN</td>
<td>跳过匹配的文件</td>
</tr>
<tr>
<td>–exclude-from=FILE</td>
<td>跳过匹配的文件，来自文件模式</td>
</tr>
<tr>
<td>–exclude-dir=PATTERN</td>
<td>跳过匹配的目录</td>
</tr>
</tbody>
</table>
<h2 id="内容行控制参数">内容行控制参数</h2>
<table>
<thead>
<tr>
<th>内容行控制</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-A，–after-context=NUM</td>
<td>打印匹配的后几行</td>
</tr>
<tr>
<td>-B，–before-context=NUM</td>
<td>打印匹配的前几行</td>
</tr>
<tr>
<td>-C，–context=NUM</td>
<td>打印匹配的前后几行</td>
</tr>
<tr>
<td>–color[=WHEN],</td>
<td>匹配的字体颜色</td>
</tr>
</tbody>
</table>
<h1 id="sed命令">sed命令</h1>
<h2 id="选项参数">选项参数</h2>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>不打印模式空间 取消默认sed的输出，常与sed内置命令的-p连用 输出想要的内容</td>
</tr>
<tr>
<td>-e</td>
<td>执行脚本，表达式来处理</td>
</tr>
<tr>
<td>-f</td>
<td>执行动作从文件读取执行</td>
</tr>
<tr>
<td>-i</td>
<td>修改原文件 直接修改文件内容，而不是输出到终端</td>
</tr>
<tr>
<td>-r</td>
<td>使用扩展正则表达式和正则表达式</td>
</tr>
<tr>
<td>-i.bak</td>
<td>在将处理的结果写入文件之前备份一份</td>
</tr>
</tbody>
</table>
<h2 id="内置参数">内置参数</h2>
<p>常用的：</p>
<table>
<thead>
<tr>
<th>-p</th>
<th>全拼print，表示打印匹配行的内容,通常p会与选项-n一起使用※</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>delete 删除的意思</td>
</tr>
<tr>
<td>=</td>
<td>显示行号</td>
</tr>
<tr>
<td>s</td>
<td>替换 通常和g一起</td>
</tr>
<tr>
<td>g</td>
<td>全局替换</td>
</tr>
<tr>
<td>a</td>
<td>追加，添加 当前行追加文本</td>
</tr>
<tr>
<td>i</td>
<td>当前插入 当前行上面插入文本</td>
</tr>
</tbody>
</table>
<p>全部：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>s /regexp/replac ement/</td>
<td>替换字符串 加上g 全局替换</td>
</tr>
<tr>
<td>a \text</td>
<td>当前行追加文本</td>
</tr>
<tr>
<td>i \text</td>
<td>当前行上面插入文本</td>
</tr>
<tr>
<td>c \text</td>
<td>所选行替换新文本</td>
</tr>
<tr>
<td>b label</td>
<td>分支到脚本中带有标签的位置，如果分支不存在则分支到脚本的末尾</td>
</tr>
<tr>
<td>d</td>
<td>删除模式空间，开始下⼀个循环</td>
</tr>
<tr>
<td>D</td>
<td>删除模式空间的第⼀⾏，开始下⼀个循环</td>
</tr>
<tr>
<td>g G</td>
<td>复制/追加保持空间到模式空间</td>
</tr>
<tr>
<td>h H</td>
<td>复制/追加模式空间到保持空间</td>
</tr>
<tr>
<td>I</td>
<td>打印模式空间的⾏，并显示控制字符$</td>
</tr>
<tr>
<td>n N</td>
<td>读取/追加下⼀⾏输⼊到模式空间</td>
</tr>
<tr>
<td>p</td>
<td>打印当前模式空间</td>
</tr>
<tr>
<td>P</td>
<td>打印模式空间的第⼀⾏</td>
</tr>
<tr>
<td>q</td>
<td>⽴即退出 sed 脚本</td>
</tr>
<tr>
<td>r</td>
<td>追加⽂本来⾃⽂件</td>
</tr>
<tr>
<td>t label</td>
<td>如果 s///是⼀个成功的替换，才跳转到标签</td>
</tr>
<tr>
<td>w filename</td>
<td>写⼊当前模式空间到⽂件</td>
</tr>
<tr>
<td>x</td>
<td>交换模式空间和保持空间内容</td>
</tr>
<tr>
<td>=</td>
<td>打印当前⾏号</td>
</tr>
<tr>
<td>: label</td>
<td>label 为 b 和 t 命令</td>
</tr>
<tr>
<td>!</td>
<td>取反、否定</td>
</tr>
<tr>
<td>&amp;</td>
<td>引⽤已匹配字符串</td>
</tr>
</tbody>
</table>
<h2 id="地址参数">地址参数</h2>
<table>
<thead>
<tr>
<th>地址</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>first~step</td>
<td>步⻓，每 step ⾏，从第 first 开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配最后⼀⾏</td>
</tr>
<tr>
<td>/regexp/</td>
<td>正则表达式匹配行</td>
</tr>
<tr>
<td>number</td>
<td>只匹配指定⾏</td>
</tr>
<tr>
<td>addr1,addr2</td>
<td>开始匹配 addr1 ⾏开始，直接 addr2 ⾏结束</td>
</tr>
<tr>
<td>addr1,+N</td>
<td>从 addr1 ⾏开始，向后的 N ⾏</td>
</tr>
<tr>
<td>addr1,~N</td>
<td>从addr1行开始，到N行结束</td>
</tr>
</tbody>
</table>
<h1 id="awk">awk</h1>
<h2 id="awk常用参数">awk常用参数</h2>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F</td>
<td>指定分隔符</td>
</tr>
<tr>
<td>-v</td>
<td>指定变量和默认值</td>
</tr>
<tr>
<td>$NF</td>
<td>代表最后一个字段</td>
</tr>
<tr>
<td>NR</td>
<td>代表第几行</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
</tr>
<tr>
<td>$ (NF- (n-1))</td>
<td>取倒数第n列</td>
</tr>
<tr>
<td>FS</td>
<td>输入分隔符，与-F分隔符一样</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符</td>
</tr>
<tr>
<td>$0</td>
<td>显示整行</td>
</tr>
<tr>
<td>1…N</td>
<td>第一个字段到第N个字段</td>
</tr>
</tbody>
</table>
<h2 id="awk参数具体玩法">awk参数具体玩法</h2>
<h3 id="-f-指定分隔符">-F 指定分隔符</h3>
<pre><code># 指定分隔符":",并截取第六个字段
tail -1 /etc/passwd | awk -F ":" '{print $6}'

# 指定两个记录分隔符（空格和:）
awk -F'[ :]' '{print $2,$4}' 

# 多一个加号表明将连续出现的记录分隔符当做一个来处理
awk -F'[ :]+' '{print $2,$4}'

# 在awk中，当记录分隔符指定为空字符串时，awk会将多个连续的空白看做一个单一的记录分隔符。此外，awk还会忽略开头和结尾处的空白。
</code></pre>
<h3 id="-v-指定变量和默认值">-v 指定变量和默认值</h3>
<pre><code># 生成一个1到10的文件,我想计算出文件内的总和
seq 1 10 &gt; 1.txt 

# 给a赋值为0，让a与文件内的第一个字段相加，最后结果通过tail 打印出来 但是看的出来很麻烦
awk -v "a=0" '{a+=$1;print a}' 1.txt | tail -1

# 优先级END方式 下面会有讲
awk -v "a=0" '{a+=$1}END{print a}' 1.txt
</code></pre>
<h3 id="nf代表最后一个字段">$NF代表最后一个字段</h3>
<pre><code>awk -F ":" 'NR==10{print $NF}' /etc/passwd 
# 截取/etc/passwd文件下面的第10行，最后一个字段
</code></pre>
<h3 id="nr-选行">NR 选行</h3>
<pre><code>awk NR==44'{print $0}' /etc/passwd 
# 打印/etc/passwd下的第44行，$0代表整行
</code></pre>
<h3 id="与">&amp;&amp;与</h3>
<p>条件1 &amp;&amp; 条件2 都要满足才为真，真返回1，假返回0</p>
<pre><code># 如果条件为假则返回0
awk -v "a=0" 'NR==1{print (a+=$1 &gt; 10) &amp;&amp; (a+=$2 &gt;10)}' 2.txt 

# 如果为真返回 1
awk -v "a=0" 'NR==1{print (a+=$1 &lt; 10) &amp;&amp; (a+=$2 &lt;10)}' 2.txt
</code></pre>
<h3 id="或">||或</h3>
<p>条件1 || 条件2 ,条件满足一边 为真</p>
<pre><code># 两个条件都不满足，返回假，也就是0
awk -v 'a=0' 'NR==1{print (a+=$1 &gt;10) || (a+=$2 &lt; 10)}' 2.txt

# 第二行，两边条件满足一遍，所以结果为1
awk -v 'a=0' 'NR==2{print (a+=$1 &gt;10) || (a+=$2 &lt; 10)}' 2.txt
</code></pre>
<h3 id="fs指定分隔符">FS指定分隔符</h3>
<pre><code># 没有优先级写法
awk '{FS=":"}NR==2{print $1,$2}' 3.txt

# 优先级写法
awk 'BEGIN{FS=":"}NR==2{print $1,$2}' 1.txt
</code></pre>
<h3 id="ofs一般与fs或者-f共同使用">OFS一般与FS或者-F共同使用</h3>
<pre><code>#指定分隔符":",OFS中间的间隔换成你指定的
awk -F ":" 'NR==2{OFS="_";print $1,$2}' 1.txt  

#FS用法与上面意思相同
awk 'BEGIN{FS=":";OFS="-"}NR==2{print $1,$2,$3}' 1.txt
</code></pre>
<h3 id="rs指定结尾符一般与ofs配合">RS指定结尾符一般与OFS配合</h3>
<p>写法单独写RS：</p>
<pre><code># 在文本操作的时候结尾默认是回车（\n），RS指定结尾符号
awk 'BEGIN{RS=""}{print $0}' 2.txt
</code></pre>
<p>RS与OFS配合使用写法：<br>
注意 如果是$0的话，不会有效果，单独使用是可以，如果配合OFS使用就不能是整行</p>
<pre><code># RS指定结尾符，OFS指定链接符
awk 'BEGIN{RS="";OFS="##"}{print $1,$2,$3}' 2.txt

# 也可以指定特殊符号
awk 'BEGIN{RS="";OFS="\n"}{print $1,$2,$3}' 2.txt
</code></pre>
<h2 id="awk优先级">awk优先级</h2>
<p>最高：BEGIN是最高优先级，是在执行PROGRAM之前执行的，不需要提供数据源，因为不涉及任何数据，也不依赖PROGRAM代码块；<br>
默认：PROGRAM是对数据流干什么，是必选代码块，也是默认代码块。所以执行的时候必须要加上数据源； 默认优先级（不加优先级就是默认）<br>
最低：END是处理完数据流后，如果需要执行END代码块，就必须要PROGAM的支持，单个无法执行<br>
注意：如果只用最高或者最低优先级，后面跟上数据源（file）不会有效果，只有默认优先级PROGRAM才会有效果</p>
<h3 id="最高优先级-begin">最高优先级 BEGIN</h3>
<p>写法一:</p>
<pre><code># BEGIN后面不需要加任何数据源，也可以打印内容
awk 'BEGIN{print "zhangsan"}'
</code></pre>
<p>写法二（赋值写法）:</p>
<pre><code># 将a[1],a[2]赋值，并打印
awk 'BEGIN{a[1]="zhangsan";a[2]="28";print a[1],a[2]}'

# 与上面同理
awk 'BEGIN{name="zhangsan";age="28";print name,age}'
</code></pre>
<h3 id="默认优先级program对数据源操作">默认优先级PROGRAM（对数据源操作）</h3>
<pre><code># 比如我想计算机内存使用率（总内存 - 空闲 *100 / 总内存）
# 将总内存赋值给a，空闲内存赋予b ，在利用算法算出内存使用率
awk 'NR==1{a=$2}NR==2{b=$2;print(a-b)*100/a"%"}' /proc/meminfo
</code></pre>
<h3 id="end最低优先级">END最低优先级</h3>
<p>对数据处理的最后一个值</p>
<pre><code># 生成一个1到10 的文件
seq 1 10  &gt; 1.txt

# $1代表第一个字段，将第一个字段的所有数相加
awk -v "a=0" '{a+=$1}END{print a}' 1.txt
</code></pre>
<p>我们把第一个字段加起来了，会发现很多数值，我们就要最后一个结果，我们就加上END看两者的区别</p>
<h2 id="awk模糊匹配">awk模糊匹配</h2>
<p>比如说我想看我的用户信息，我就记得用户是gx开头的，我不打开文件下，我们可以这么做：</p>
<pre><code>awk -F ":" '$1 ~ "gx"{print $0}' /etc/passwd
# 注意“~”匹配查询，后面关键字要用引号引起来一定要双引号 
# $1代表第一个字段，可以写成别字段比如第二字段就是$2...

# 匹配多个写法
awk -F ":" '$1 ~"gx"{print $0};$1 ~ "roo"{print $0}' /etc/passwd
</code></pre>
<h2 id="awk命令控制流">awk命令控制流</h2>
<h3 id="if判断语句">if判断语句</h3>
<pre><code># 双分支
awk '{
    if (条件) {
        # 条件成立时执行
        动作1
    } else {
        # 条件不成立时执行
        动作2
    }
}' 文件名

# 多分支
awk '{
    if (条件) {
        动作1
    } else {
        动作2
    }
}' 文件名

# 如果$1大于5，$1乘以$2，否则$1除以$2
awk '{
    if ($1 &gt; 5) {
        print $1 * $2
    } else {
        print $1 / $2
    }
}' 2.txt
</code></pre>
<h3 id="for循环">for循环</h3>
<pre><code># 初始化值a，然后内容有几行循环就几次，最后将字段相加，就是结果了
awk '{a=0;for(i=1;i&lt;11;i++){a+=$i}print a}' 2.txt
</code></pre>
<h3 id="while循环">while循环</h3>
<pre><code># 单条语句写法
awk '{a=0;b=1;while(b&lt;10){a+=$b;b++}print a}' 2.txt

# 逐行写法
awk '{
    sum = 0
    i = 1
    while (i &lt; 11) {
        sum += $i
        i++
    }
    print sum
}' 2.txt
</code></pre>
<h3 id="dowhile写法">do…while写法</h3>
<pre><code># do...while 就是将写在while中的语句拿出来写，最后while循环
awk '{a=0;b=1;do{a+=$b;b++}while (b&lt;11)print a}' 2.txt

# 多行写法
awk '{
    a = 0
    b = 1
    do {
        a += $b
        b++
    } while (b &lt; 11)
    print a
}' 2.txt
</code></pre>
<h2 id="awk数组">awk数组</h2>
<h3 id="语法">语法</h3>
<pre><code>array_name[index]=value

array_name：数组的名称
index：数组索引
value：数组中元素所赋予的值
</code></pre>
<h3 id="访问数组元素">访问数组元素</h3>
<pre><code># 访问数组中某个值
arrayname[index]

# 访问数组中所有的元素
for(idx in arrayname){print arr[idx]}
</code></pre>
<h3 id="删除数组元素">删除数组元素</h3>
<pre><code># 删除数组中特定下标的元素
delete arrayname[index]

# 删除数组中所有的元素
for (idx in arrayname){delete arrayname[idx]}
</code></pre>
<h3 id="数组案例">数组案例</h3>
<p>这个文件包括了网关服务器所需要的ip地址列表，文件中的数据符合下面的格式：</p>
<pre><code>cat Iplogs.txt
180607 093423    123.12.23.122 133
180607 121234    125.25.45.221 153
190607 084849   202.178.23.4 44
190607 084859   164.78.22.64 12
200607 012312    202.188.3.2 13
210607 084849   202.178.23.4 34
210607 121435    202.178.23.4 32
210607 132423    202.188.3.2 167
</code></pre>
<p>列出所有的IP地址和它被请求的次数:</p>
<pre><code>awk '{Ip[$3]++} END {for (var in Ip) print var, "accessed", Ip[var], "times"}' Iplogs.txt
123.12.23.122 accessed 1 times
164.78.22.64 accessed 1 times
202.188.3.2 accessed 2 times
125.25.45.221 accessed 1 times
202.178.23.4 accessed 3 times

# Ip[$3]++ 表示每次遇到一个 IP 地址时，其计数加 1
# 遍历 Ip 数组中的每个元素。输出每个 IP 地址及其访问次数。
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-14 14:24">2025-08-14 14:24</span>&nbsp;
<a href="https://www.cnblogs.com/zqfstack">阿峰博客站</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19037690);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19037690', targetLink: 'https://www.cnblogs.com/zqfstack/p/19037690', title: 'linux三剑客详解' })">举报</a>
</div>
        