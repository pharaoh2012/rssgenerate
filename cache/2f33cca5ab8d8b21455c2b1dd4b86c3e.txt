
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18873873" title="发布于 2025-05-13 10:40">
    <span role="heading" aria-level="2">【Java持久层技术演进全解析】从JDBC到MyBatis再到MyBatis-Plus</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="从jdbc到mybatis再到mybatis-plusjava持久层技术演进全解析">从JDBC到MyBatis再到MyBatis-Plus：Java持久层技术演进全解析</h1>
<h2 id="引言">引言</h2>
<p>在Java企业级应用开发中，数据持久化是核心需求之一。本文将系统性地介绍Java持久层技术的演进过程，从最基础的JDBC开始，到广泛应用的MyBatis，再到功能强大的MyBatis-Plus。通过详细的源码解析和对比分析，帮助开发者深入理解这三种技术的实现原理、优缺点及适用场景。</p>
<h2 id="一原生jdbc数据库操作的基石">一、原生JDBC：数据库操作的基石</h2>
<h3 id="1-jdbc核心架构">1. JDBC核心架构</h3>
<p>JDBC(Java Database Connectivity)是Java访问数据库的标准API，由以下核心组件构成：</p>
<ul>
<li><strong>DriverManager</strong>：管理数据库驱动</li>
<li><strong>Connection</strong>：数据库连接对象</li>
<li><strong>Statement/PreparedStatement</strong>：SQL执行接口</li>
<li><strong>ResultSet</strong>：结果集对象</li>
</ul>
<div class="mermaid">classDiagram
    class DriverManager
    class Connection
    class Statement
    class PreparedStatement
    class ResultSet
    
    DriverManager --&gt; Connection
    Connection --&gt; Statement
    Connection --&gt; PreparedStatement
    Statement --&gt; ResultSet
    PreparedStatement --&gt; ResultSet
</div><h3 id="2-完整crud实现">2. 完整CRUD实现</h3>
<h4 id="21-数据库连接管理">2.1 数据库连接管理</h4>
<pre><code class="language-java">public class JdbcUtil {
    private static final String URL = "jdbc:mysql://localhost:3306/test?useSSL=false";
    private static final String USER = "root";
    private static final String PASSWORD = "password";
    
    // 静态代码块加载驱动(JDBC4.0+可省略)
    static {
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
        } catch (ClassNotFoundException e) {
            throw new ExceptionInInitializerError("加载数据库驱动失败");
        }
    }
    
    /**
     * 获取数据库连接
     * @return Connection对象
     * @throws SQLException 如果获取连接失败
     */
    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(URL, USER, PASSWORD);
    }
    
    /**
     * 关闭连接资源
     * @param conn 连接对象
     * @param stmt Statement对象
     * @param rs 结果集对象
     */
    public static void close(Connection conn, Statement stmt, ResultSet rs) {
        try {
            if (rs != null) rs.close();
            if (stmt != null) stmt.close();
            if (conn != null) conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h4 id="22-查询操作实现">2.2 查询操作实现</h4>
<pre><code class="language-java">public class JdbcQueryExample {
    /**
     * 查询单个用户
     * @param id 用户ID
     * @return User对象
     */
    public User getUserById(int id) {
        String sql = "SELECT id, name, age, email FROM users WHERE id = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        User user = null;
        
        try {
            // 1. 获取连接
            conn = JdbcUtil.getConnection();
            // 2. 创建PreparedStatement(预编译防止SQL注入)
            pstmt = conn.prepareStatement(sql);
            // 3. 设置参数
            pstmt.setInt(1, id);
            // 4. 执行查询
            rs = pstmt.executeQuery();
            
            // 5. 处理结果集
            if (rs.next()) {
                user = new User();
                user.setId(rs.getInt("id"));
                user.setName(rs.getString("name"));
                user.setAge(rs.getInt("age"));
                user.setEmail(rs.getString("email"));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            // 6. 关闭资源
            JdbcUtil.close(conn, pstmt, rs);
        }
        return user;
    }
    
    /**
     * 查询所有用户(使用try-with-resources简化资源管理)
     */
    public List&lt;User&gt; getAllUsers() {
        String sql = "SELECT id, name, age, email FROM users";
        List&lt;User&gt; users = new ArrayList&lt;&gt;();
        
        // try-with-resources自动关闭资源
        try (Connection conn = JdbcUtil.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                User user = new User();
                user.setId(rs.getInt("id"));
                user.setName(rs.getString("name"));
                user.setAge(rs.getInt("age"));
                user.setEmail(rs.getString("email"));
                users.add(user);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return users;
    }
}
</code></pre>
<h4 id="23-更新操作实现">2.3 更新操作实现</h4>
<pre><code class="language-java">public class JdbcUpdateExample {
    /**
     * 更新用户信息
     * @param user 用户对象
     * @return 影响的行数
     */
    public int updateUser(User user) {
        String sql = "UPDATE users SET name = ?, age = ?, email = ? WHERE id = ?";
        int affectedRows = 0;
        
        try (Connection conn = JdbcUtil.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            
            // 设置参数
            pstmt.setString(1, user.getName());
            pstmt.setInt(2, user.getAge());
            pstmt.setString(3, user.getEmail());
            pstmt.setInt(4, user.getId());
            
            // 执行更新
            affectedRows = pstmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return affectedRows;
    }
    
    /**
     * 批量插入用户
     * @param users 用户列表
     * @return 每条SQL影响的行数数组
     */
    public int[] batchInsert(List&lt;User&gt; users) {
        String sql = "INSERT INTO users(name, age, email) VALUES (?, ?, ?)";
        
        try (Connection conn = JdbcUtil.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            
            // 关闭自动提交，开启事务
            conn.setAutoCommit(false);
            
            // 添加批处理
            for (User user : users) {
                pstmt.setString(1, user.getName());
                pstmt.setInt(2, user.getAge());
                pstmt.setString(3, user.getEmail());
                pstmt.addBatch();
            }
            
            // 执行批处理
            int[] results = pstmt.executeBatch();
            // 提交事务
            conn.commit();
            return results;
        } catch (SQLException e) {
            e.printStackTrace();
            return new int[0];
        }
    }
}
</code></pre>
<h3 id="3-jdbc的优缺点分析">3. JDBC的优缺点分析</h3>
<p><strong>优点</strong>：</p>
<ol>
<li>标准API，所有数据库厂商都提供实现</li>
<li>直接操作底层，性能最高</li>
<li>灵活性最强，可以执行任意SQL</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>样板代码多，开发效率低</li>
<li>需要手动管理连接和事务</li>
<li>SQL与Java代码耦合度高</li>
<li>需要手动处理异常和资源释放</li>
<li>结果集到对象的映射需要手动实现</li>
</ol>
<h2 id="二mybatissql与java的优雅桥梁">二、MyBatis：SQL与Java的优雅桥梁</h2>
<h3 id="1-mybatis核心架构">1. MyBatis核心架构</h3>
<p>MyBatis通过以下核心组件简化了JDBC操作：</p>
<ul>
<li><strong>SqlSessionFactory</strong>：创建SqlSession的工厂</li>
<li><strong>SqlSession</strong>：执行CRUD操作的主要接口</li>
<li><strong>Executor</strong>：SQL执行器</li>
<li><strong>MappedStatement</strong>：封装SQL语句和映射信息</li>
<li><strong>TypeHandler</strong>：处理Java与JDBC类型转换</li>
</ul>
<div class="mermaid">classDiagram
    class SqlSessionFactory
    class SqlSession
    class Executor
    class MappedStatement
    class TypeHandler
    
    SqlSessionFactory --&gt; SqlSession
    SqlSession --&gt; Executor
    Executor --&gt; MappedStatement
    MappedStatement --&gt; TypeHandler
</div><h3 id="2-mybatis配置与映射">2. MyBatis配置与映射</h3>
<h4 id="21-配置文件示例">2.1 配置文件示例</h4>
<p><code>mybatis-config.xml</code>：</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;setting name="cacheEnabled" value="true"/&gt;
        &lt;setting name="lazyLoadingEnabled" value="true"/&gt;
    &lt;/settings&gt;
    
    &lt;typeAliases&gt;
        &lt;typeAlias type="com.example.User" alias="User"/&gt;
    &lt;/typeAliases&gt;
    
    &lt;environments default="development"&gt;
        &lt;environment id="development"&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;
                &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt;
                &lt;property name="username" value="root"/&gt;
                &lt;property name="password" value="password"/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    
    &lt;mappers&gt;
        &lt;mapper resource="mapper/UserMapper.xml"/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h4 id="22-mapper-xml示例">2.2 Mapper XML示例</h4>
<p><code>UserMapper.xml</code>：</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace="com.example.mapper.UserMapper"&gt;
    &lt;resultMap id="userResultMap" type="User"&gt;
        &lt;id property="id" column="id"/&gt;
        &lt;result property="name" column="name"/&gt;
        &lt;result property="age" column="age"/&gt;
        &lt;result property="email" column="email"/&gt;
    &lt;/resultMap&gt;
    
    &lt;select id="selectUserById" resultMap="userResultMap"&gt;
        SELECT id, name, age, email FROM users WHERE id = #{id}
    &lt;/select&gt;
    
    &lt;insert id="insertUser" parameterType="User" useGeneratedKeys="true" keyProperty="id"&gt;
        INSERT INTO users(name, age, email) VALUES(#{name}, #{age}, #{email})
    &lt;/insert&gt;
    
    &lt;update id="updateUser" parameterType="User"&gt;
        UPDATE users SET name=#{name}, age=#{age}, email=#{email} WHERE id=#{id}
    &lt;/update&gt;
    
    &lt;delete id="deleteUser" parameterType="int"&gt;
        DELETE FROM users WHERE id=#{id}
    &lt;/delete&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="3-mybatis核心源码解析">3. MyBatis核心源码解析</h3>
<h4 id="31-sqlsession创建过程">3.1 SqlSession创建过程</h4>
<pre><code class="language-java">public class MyBatisExample {
    public static void main(String[] args) {
        // 1. 加载配置文件
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        
        // 2. 构建SqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        
        // 3. 获取SqlSession
        try (SqlSession session = sqlSessionFactory.openSession()) {
            // 4. 获取Mapper接口代理对象
            UserMapper userMapper = session.getMapper(UserMapper.class);
            
            // 5. 执行CRUD操作
            User user = userMapper.selectUserById(1);
            System.out.println(user);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h4 id="32-mapper代理实现">3.2 Mapper代理实现</h4>
<p>MyBatis通过动态代理将Mapper接口方法调用转换为SQL执行：</p>
<pre><code class="language-java">public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable {
    private final SqlSession sqlSession;
    private final Class&lt;T&gt; mapperInterface;
    private final Map&lt;Method, MapperMethod&gt; methodCache;
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 处理Object方法
        if (Object.class.equals(method.getDeclaringClass())) {
            return method.invoke(this, args);
        }
        
        // 获取缓存的MapperMethod
        final MapperMethod mapperMethod = cachedMapperMethod(method);
        // 执行SQL
        return mapperMethod.execute(sqlSession, args);
    }
    
    private MapperMethod cachedMapperMethod(Method method) {
        return methodCache.computeIfAbsent(method, k -&gt; new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));
    }
}
</code></pre>
<h4 id="33-sql执行流程">3.3 SQL执行流程</h4>
<pre><code class="language-java">public class DefaultSqlSession implements SqlSession {
    private final Configuration configuration;
    private final Executor executor;
    
    @Override
    public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) {
        try {
            // 1. 获取MappedStatement
            MappedStatement ms = configuration.getMappedStatement(statement);
            // 2. 委托给Executor执行
            return executor.query(ms, wrapCollection(parameter), RowBounds.DEFAULT, Executor.NO_RESULT_HANDLER);
        } catch (Exception e) {
            throw ExceptionFactory.wrapException("Error querying database. Cause: " + e, e);
        }
    }
}

public class CachingExecutor implements Executor {
    private final Executor delegate;
    
    @Override
    public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, 
                           RowBounds rowBounds, ResultHandler resultHandler,
                           CacheKey key, BoundSql boundSql) throws SQLException {
        // 检查二级缓存
        Cache cache = ms.getCache();
        if (cache != null) {
            flushCacheIfRequired(ms);
            if (ms.isUseCache() &amp;&amp; resultHandler == null) {
                List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);
                if (list == null) {
                    list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
                    tcm.putObject(cache, key, list);
                }
                return list;
            }
        }
        return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
    }
}
</code></pre>
<h3 id="4-mybatis的优缺点分析">4. MyBatis的优缺点分析</h3>
<p><strong>优点</strong>：</p>
<ol>
<li>SQL与Java代码分离，易于维护</li>
<li>自动参数映射和结果集映射</li>
<li>支持动态SQL</li>
<li>提供一级和二级缓存</li>
<li>插件机制支持扩展</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>需要编写SQL和映射配置</li>
<li>复杂查询仍需手动编写SQL</li>
<li>分页功能需要插件支持</li>
<li>代码生成器功能较弱</li>
</ol>
<h2 id="三mybatis-plusmybatis的增强工具包">三、MyBatis-Plus：MyBatis的增强工具包</h2>
<h3 id="1-mybatis-plus核心特性">1. MyBatis-Plus核心特性</h3>
<ol>
<li><strong>通用Mapper</strong>：内置常用CRUD方法</li>
<li><strong>条件构造器</strong>：链式API构建查询条件</li>
<li><strong>代码生成器</strong>：自动生成Entity/Mapper/Service代码</li>
<li><strong>分页插件</strong>：内置物理分页支持</li>
<li><strong>性能分析插件</strong>：输出SQL执行时间</li>
<li><strong>乐观锁插件</strong>：支持@Version注解</li>
</ol>
<h3 id="2-mybatis-plus配置与使用">2. MyBatis-Plus配置与使用</h3>
<h4 id="21-spring-boot集成配置">2.1 Spring Boot集成配置</h4>
<pre><code class="language-java">@Configuration
@MapperScan("com.example.mapper")
public class MybatisPlusConfig {
    
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        // 添加分页插件
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        // 添加乐观锁插件
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        return interceptor;
    }
    
    @Bean
    public GlobalConfig globalConfig() {
        GlobalConfig globalConfig = new GlobalConfig();
        globalConfig.setMetaObjectHandler(new MetaHandler());
        return globalConfig;
    }
}
</code></pre>
<h4 id="22-实体类定义">2.2 实体类定义</h4>
<pre><code class="language-java">@Data
@TableName("users")
public class User {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String name;
    private Integer age;
    private String email;
    
    @Version
    private Integer version;
    
    @TableField(fill = FieldFill.INSERT)
    private Date createTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Date updateTime;
}
</code></pre>
<h3 id="3-mybatis-plus核心源码解析">3. MyBatis-Plus核心源码解析</h3>
<h4 id="31-通用mapper实现">3.1 通用Mapper实现</h4>
<pre><code class="language-java">public interface BaseMapper&lt;T&gt; extends Mapper&lt;T&gt; {
    int insert(T entity);
    int deleteById(Serializable id);
    int updateById(@Param(Constants.ENTITY) T entity);
    T selectById(Serializable id);
    List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);
    // 其他方法...
}

public class MybatisMapperProxy&lt;T&gt; implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 处理默认方法
        if (method.isDefault()) {
            return invokeDefaultMethod(proxy, method, args);
        }
        
        // 处理Wrapper条件
        if (args != null &amp;&amp; args.length &gt; 0 &amp;&amp; args[0] instanceof Wrapper) {
            processWrapper((Wrapper&lt;?&gt;) args[0]);
        }
        
        // 转换为MyBatis的MapperMethod执行
        return cachedInvoker(method).invoke(proxy, method, args, sqlSession);
    }
    
    private void processWrapper(Wrapper&lt;?&gt; wrapper) {
        if (wrapper instanceof AbstractWrapper) {
            ((AbstractWrapper&lt;?, ?, ?&gt;) wrapper).checkEntityClass();
        }
    }
}
</code></pre>
<h4 id="32-条件构造器实现">3.2 条件构造器实现</h4>
<pre><code class="language-java">public abstract class AbstractWrapper&lt;T, R, Children extends AbstractWrapper&lt;T, R, Children&gt;&gt; 
    implements Wrapper&lt;T&gt;, Compare&lt;Children, R&gt; {
    
    protected final List&lt;SqlSegment&gt; sqlSegments = new ArrayList&lt;&gt;();
    protected Entity&lt;T&gt; entity;
    
    public Children eq(R column, Object val) {
        return addCondition(column, SqlKeyword.EQ, val);
    }
    
    protected Children addCondition(R column, SqlKeyword keyword, Object val) {
        String columnName = columnToString(column);
        sqlSegments.add(new SimpleSqlSegment(columnName + keyword.getSqlSegment() + "?"));
        paramNameValuePairs.put(columnName, val);
        return typedThis;
    }
    
    public String getSqlSegment() {
        mergeExpression();
        return sqlSegments.stream()
            .map(SqlSegment::getSqlSegment)
            .collect(Collectors.joining(" "));
    }
}
</code></pre>
<h4 id="33-分页插件实现">3.3 分页插件实现</h4>
<pre><code class="language-java">@Intercepts({
    @Signature(type = Executor.class, method = "query", 
              args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}),
    @Signature(type = Executor.class, method = "query", 
              args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class})
})
public class PaginationInnerInterceptor implements InnerInterceptor {
    
    @Override
    public void beforeQuery(Executor executor, MappedStatement ms, 
                          Object parameter, RowBounds rowBounds, 
                          ResultHandler resultHandler, BoundSql boundSql) {
        if (parameter instanceof Map &amp;&amp; ((Map&lt;?, ?&gt;) parameter).containsKey(IPage.class.getName())) {
            // 获取分页参数
            IPage&lt;?&gt; page = (IPage&lt;?&gt;) ((Map&lt;?, ?&gt;) parameter).get(IPage.class.getName());
            
            // 执行COUNT查询
            String countSql = generateCountSql(boundSql.getSql());
            Long total = executeCount(executor, ms, parameter, boundSql, countSql);
            page.setTotal(total);
            
            // 生成分页SQL
            String pageSql = dialect.buildPaginationSql(boundSql.getSql(), page, buildCountKey(ms.getId()));
            
            // 修改BoundSql
            resetSql(boundSql, pageSql);
        }
    }
}
</code></pre>
<h3 id="4-mybatis-plus的优缺点分析">4. MyBatis-Plus的优缺点分析</h3>
<p><strong>优点</strong>：</p>
<ol>
<li>极大减少样板代码</li>
<li>强大的条件构造器</li>
<li>内置分页和乐观锁支持</li>
<li>完善的代码生成器</li>
<li>保留MyBatis所有特性</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>复杂SQL仍需手写XML</li>
<li>学习成本比原生MyBatis高</li>
<li>自动生成的SQL可能不够优化</li>
</ol>
<h2 id="四技术对比与选型建议">四、技术对比与选型建议</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>JDBC</th>
<th>MyBatis</th>
<th>MyBatis-Plus</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>开发效率</strong></td>
<td>低</td>
<td>中</td>
<td>高</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高</td>
<td>中高</td>
<td>中高</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>最高</td>
<td>高</td>
<td>中高</td>
</tr>
<tr>
<td><strong>学习曲线</strong></td>
<td>低</td>
<td>中</td>
<td>中高</td>
</tr>
<tr>
<td><strong>社区支持</strong></td>
<td>标准</td>
<td>强大</td>
<td>强大</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>需要极致性能/特殊需求</td>
<td>需要灵活SQL控制</td>
<td>快速开发CRUD功能</td>
</tr>
</tbody>
</table>
<p><strong>选型建议</strong>：</p>
<ol>
<li>需要极致性能或特殊数据库特性 → JDBC</li>
<li>需要灵活控制SQL且项目复杂 → MyBatis</li>
<li>常规业务系统快速开发 → MyBatis-Plus</li>
</ol>
<h2 id="五扩展知识点">五、扩展知识点</h2>
<h3 id="1-连接池技术">1. 连接池技术</h3>
<ul>
<li><strong>HikariCP</strong>：目前性能最好的连接池</li>
<li><strong>Druid</strong>：阿里开源，带监控功能</li>
<li><strong>Tomcat JDBC Pool</strong>：Tomcat内置连接池</li>
</ul>
<h3 id="2-分布式事务">2. 分布式事务</h3>
<ul>
<li><strong>XA协议</strong>：传统两阶段提交</li>
<li><strong>TCC模式</strong>：Try-Confirm-Cancel</li>
<li><strong>Saga模式</strong>：长事务解决方案</li>
<li><strong>Seata</strong>：阿里开源的分布式事务框架</li>
</ul>
<h3 id="3-orm框架对比">3. ORM框架对比</h3>
<table>
<thead>
<tr>
<th>框架</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hibernate</td>
<td>全自动ORM，开发效率高</td>
<td>性能较差，复杂查询难优化</td>
</tr>
<tr>
<td>JPA</td>
<td>标准规范，可移植性好</td>
<td>灵活性不足</td>
</tr>
<tr>
<td>MyBatis</td>
<td>SQL可控，性能好</td>
<td>需要写SQL</td>
</tr>
<tr>
<td>MyBatis-Plus</td>
<td>开发效率高，功能丰富</td>
<td>复杂SQL支持不够</td>
</tr>
</tbody>
</table>
<h3 id="4-性能优化建议">4. 性能优化建议</h3>
<ol>
<li>合理使用缓存（一级/二级/分布式）</li>
<li>批量操作代替循环单条操作</li>
<li>避免N+1查询问题</li>
<li>合理设计索引</li>
<li>使用连接池并正确配置参数</li>
</ol>
<h2 id="结语">结语</h2>
<p>通过本文的系统性讲解，我们从最基础的JDBC开始，逐步深入到MyBatis和MyBatis-Plus的核心实现原理。理解这些技术的演进过程和底层机制，有助于我们在实际项目中做出合理的技术选型，并根据业务需求进行适当的定制和优化。无论选择哪种技术，都要在开发效率、维护成本和系统性能之间找到平衡点。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.02116609536458333" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-13 10:41">2025-05-13 10:40</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18873873);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18873873', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18873873', title: '【Java持久层技术演进全解析】从JDBC到MyBatis再到MyBatis-Plus' })">举报</a>
</div>
        