
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/eanojiang/p/18857797" title="发布于 2025-05-02 21:03">
    <span role="heading" aria-level="2">树与二叉树</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        Hello算法——树与二叉树
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>github仓库：<a href="https://github.com/EanoJiang/Data-structures-and-algorithms" target="_blank" rel="noopener nofollow">https://github.com/EanoJiang/Data-structures-and-algorithms</a></p>
</blockquote>
<h1 id="树">树</h1>
<h2 id="定义">定义</h2>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210035142-732520967.png" alt="1744801497093" loading="lazy"></p>
<p>结点的度数其实就是这个结点下连的线，比如：A的度 = AB+AC+AD = 3</p>
<p>树的度就是MAX(结点的度)</p>
<p>叶子结点就是没后代的结点</p>
<h2 id="树的基本性质">树的基本性质</h2>
<ol>
<li>
<p>所有结点数 = 所有结点的度数之和 + 1(这个1也就是根节点)</p>
<blockquote>
<p>习题：</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210035763-238738105.png" alt="1744802125869" loading="lazy"></p>
<p>所有节点数 =4 + 20 * 4 + 10 * 3 + 1 * 2 + 10 * 1  +  1  = 123</p>
<p>123 - 20 - 10 - 1 - 10 = 82</p>
</li>
<li>
<p>所有结点数 =  不同度的节点数 之和</p>
<p><em>假设所有节点数为n，度0～4的个数为n0～n4，则n = n0 + n1 + n2 + n3 + n4</em></p>
</li>
<li>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210036368-1684758552.png" alt="1744802850820" loading="lazy"></p>
<p><em>第一层m<sup>0，第二层m</sup>1，第i层m^(i-1)</em></p>
</li>
<li>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210036802-691583687.png" alt="1744802831067" loading="lazy"></p>
<p><em>等比数列求和公式</em></p>
</li>
</ol>
<h1 id="二叉树">二叉树</h1>
<h2 id="定义-1">定义</h2>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210037468-817848288.png" alt="1744803001113" loading="lazy"></p>
<p>就是每个分支只有二叉的树，子树有左右之分</p>
<h2 id="基本形态">基本形态</h2>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210038186-1688082218.png" alt="1744803072638" loading="lazy"></p>
<h2 id="二叉树的性质">二叉树的性质</h2>
<ol>
<li>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210038676-1908399221.png" alt="1744803146039" loading="lazy"></p>
<p><em>这是某一层的最多结点数</em></p>
</li>
<li>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210039192-1504735669.png" alt="1744803158490" loading="lazy"></p>
</li>
</ol>
<ul>
<li>这是整个二叉树的最多结点数</li>
</ul>
<ol start="3">
<li>
<p>n0 = n2 + 1</p>
<p>对于任何非空的二叉树，度0(叶子)和度2的结点数为n0、n2，那么 <em>n0 = n2 + 1</em><br>
<em>n2 = 0 的时候，n0 = 1，每把一个叶子画一个二叉，n2++，n0++</em></p>
<blockquote>
<p><em>n = 1 * n1 + 2 * n2 + 1<br>
n = n0 + n1 + n2<br>
解得，n0 = n2 + 1</em></p>
</blockquote>
</li>
</ol>
<h2 id="特殊二叉树">特殊二叉树</h2>
<h3 id="满二叉树">满二叉树</h3>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210039846-1308559824.png" alt="1745893049718" loading="lazy"></p>
<h3 id="完全二叉树">完全二叉树</h3>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210040530-125902656.png" alt="1745893151509" loading="lazy"></p>
<p>没有左子树，不能有右子树，上一层没铺满，不能有下一层</p>
<blockquote>
<p>判断完全二叉树</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210041306-1477520133.png" alt="1745893303713" loading="lazy"></p>
<p>不是</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210041856-2036106227.png" alt="1745893334094" loading="lazy"></p>
<p>是</p>
<h4 id="完全二叉树的性质">完全二叉树的性质</h4>
<p>1.2.3.就是二叉树的性质</p>
<ol start="4">
<li><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210042484-177302170.png" alt="1745893412155" loading="lazy"></li>
<li><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210043100-1296589524.png" alt="1745893420252" loading="lazy"></li>
<li>如果总结点数-1是奇数，说明有一个度为1的结点</li>
</ol>
<blockquote>
<p>习题</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210043665-790308581.png" alt="1745894549231" loading="lazy"></p>
<p>叶子结点出现在最后2层，这里求的是最多，所以最后一层是第7层</p>
<p>第6层最多的结点数=2^(6-1)=32</p>
<p>第6层的非叶子结点=32-8=24</p>
<p>第7层的最多结点数= 24*2 = 48</p>
<p>前6层的最多结点数=2^6 - 1 = 63</p>
<p>总计=63+48 = 111，选c</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210044335-1312181819.png" alt="1745894768771" loading="lazy"></p>
<p>n = n0+n1+n2</p>
<p>n0=n2+1</p>
<p>所以，n = 2n2 + n1 + 1</p>
<p>而768-1是奇数，所以有一个度为1的结点，即n1 = 1</p>
<p>解得 n2 = 383</p>
<p>n0 = n2 + 1 = 384，选c</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210044893-633966897.png" alt="1746142966459" loading="lazy"></p>
<p>n=n0+n1+n2</p>
<p>n1 = 0</p>
<p>n0=n2+1</p>
<p>所以，n = 2n0 - 1 = 2k -1 ，选a</p>
<h1 id="二叉树的实现">二叉树的实现</h1>
<p>顺序结构实现——除了满二叉树和完全二叉树的其他场景比较浪费空间</p>
<h2 id="链式结构实现">链式结构实现</h2>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210045438-1554558701.png" alt="1746143423026" loading="lazy"></p>
<pre><code class="language-c">//链式结构实现
typedef char ElemType;

//树结点
typedef struct TreeNode {
    ElemType data;
    TreeNode *lchild;
    TreeNode *rchild;
} TreeNode;

//用树结点指针表示二叉树
typedef TreeNode* BiTree;
</code></pre>
<h3 id="创建二叉树">创建二叉树</h3>
<p>二级指针概念：</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210045981-621860933.png" alt="1746144696942" loading="lazy"></p>
<p>指针pp 存的是 指针p的地址</p>
<p>那么*pp 就是 得到p的地址，**pp就是得到p的值</p>
<pre><code class="language-c">char str[] = "ABDH#K###E##CFI###G#J##";
int idx = 0;

//创建二叉树
// T是二级指针(BiTree**)
//  *T就是对二叉树的结点进行操作
void createTree(BiTree *T)
{
	ElemType ch;
	ch = str[idx++];
	if (ch == '#')
	{
		*T = NULL;
	}
	else
	{
		*T = (BiTree)malloc(sizeof(TreeNode));
		(*T)-&gt;data = ch;
		createTree(&amp; ( (*T)-&gt;lchild ) );
		createTree(&amp; ( (*T)-&gt;rchild ) );
	}
}
</code></pre>
<h3 id="遍历">遍历</h3>
<h4 id="前序遍历">前序遍历</h4>
<p>NLR / NRL （根-左-右）/（根-右-左）</p>
<p><em><strong>不特别说明，一般情况都是先左的遍历</strong></em></p>
<p>从根节点开始，先从左子结点开始一层层向下递(进栈)<strong>并打印</strong>，如果左子节点是空就归(出栈)，然后开始递右结点，进行如上同样操作，并向上一层层归，归到根节点后，对根节点的右子节点进行同样的操作。</p>
<blockquote>
<p>具体动画演示可以看<a href="https://www.bilibili.com/video/BV1tNpbekEht?spm_id_from=333.788.videopod.episodes&amp;vd_source=5eb26c403edb4b6de737a9c6fad9b1de&amp;p=8" target="_blank" rel="noopener nofollow">《数据结构（C 语言描述）》</a>的55:00左右进度条</p>
</blockquote>
<pre><code class="language-c">//前序遍历
void preOrder(BiTree T){
    if(T == NULL) return;
    printf("%c ", T-&gt;data);
    //递归子树
    preOrder(T-&gt;lchild);
    preOrder(T-&gt;rchild);
}
</code></pre>
<h4 id="中序遍历">中序遍历</h4>
<p>LNR / RNL</p>
<p>从根节点开始，先从左子结点开始一层层向下递(进栈)，如果左子节点是空就归(出栈)<strong>并打印</strong>，然后开始递右结点，进行如上同样操作，并向上一层层归，归到根节点后，对根节点的右子节点进行同样的操作。</p>
<pre><code class="language-c">//中序遍历
void inOrder(BiTree T){
    if(T == NULL) return;
    inOrder(T-&gt;lchild);
    printf("%c ", T-&gt;data);
    inOrder(T-&gt;rchild);
}
</code></pre>
<h4 id="后序遍历">后序遍历</h4>
<p>LRN / RLN</p>
<p>从根节点开始，先从左子结点开始一层层向下递(进栈)，如果左子节点是空就归(出栈)，然后开始递右结点，进行如上同样操作，在右结点空的时候归(出栈)<strong>并打印</strong>，并向上一层层归，归到根节点后，对根节点的右子节点进行同样的操作。</p>
<pre><code class="language-c">//后序遍历
void postOrder(BiTree T){
    if(T == NULL) return;
    postOrder(T-&gt;lchild);
    postOrder(T-&gt;rchild);
    printf("%c ", T-&gt;data);
}
</code></pre>
<blockquote>
<p>习题</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210046773-1546152570.png" alt="1746150964391" loading="lazy"></p>
<p>前：ABDHEICFGJK</p>
<p>中：HDBEIAFCJGK</p>
<p>后：HDIEBFJKGCA</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210047553-1199477004.png" alt="1746151239563" loading="lazy"></p>
<p>前：ABDEGHCFI</p>
<p>中：DBGEHAFIC</p>
<p>后：DGHEBIFCA</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210048218-778129875.png" alt="1746151842540" loading="lazy"></p>
<p>先画出二叉树：</p>
<pre><code class="language-c">	 A
	/ \
       B   D
      /   / \  
     C   E   F
</code></pre>
<p>后：CBEFDA</p>
<h4 id="二叉树遍历性质">二叉树遍历性质</h4>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210048776-1688991065.png" alt="1746152045010" loading="lazy"></p>
<blockquote>
<p>习题</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210049487-1911840203.png" alt="1746152218722" loading="lazy"></p>
<p>先右后左的中序遍历，RNL，选d</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210050079-1521563158.png" alt="1746152503875" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210050632-1647201847.png" alt="1746153011612" loading="lazy"></p>
<p>ADB都能画出来，所以选c</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210051142-1888580654.png" alt="1746153077759" loading="lazy"></p>
<pre><code class="language-c">	1
         \
          2
           \
            3
</code></pre>
<p>选b</p>
<p>(这题不要多选，一般情况只需要考虑先左就行)</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210051719-1044614756.png" alt="1746153908485" loading="lazy"></p>
<pre><code class="language-c">	 f
       /   \
      c     g
       \   /
        a d
       /   \
      e     b
</code></pre>
<p>选b</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210052343-924710455.png" alt="1746154136577" loading="lazy"></p>
<p>因为对于顺序结构来说，没有的子树节点需要填NULL，所以相当于是高度为5的满二叉树需要的存储单元，也就是二叉树的最大结点数公式，即2^5 - 1 = 31</p>
<h2 id="线索二叉树">线索二叉树</h2>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210052925-2064906058.png" alt="1746154659118" loading="lazy"></p>
<p>目标：构建一个双向循环链表</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210053687-1429300814.png" alt="1746154913322" loading="lazy"></p>
<blockquote>
<p>会出现空余空间不够用的情况吗？</p>
</blockquote>
<p>不会，n个节点有n+1个空</p>
<h3 id="代码实现">代码实现</h3>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210054301-454977725.png" alt="1746157926154" loading="lazy"></p>
<pre><code class="language-c">typedef char ElemType;

typedef struct ThreadNode {
    ElemType data;
    struct ThreadNode *lchild, *rchild;
    int ltag, rtag;
} ThreadNode;

typedef ThreadNode *ThreadTree;
</code></pre>
<p>ltag：0 指向lchild，1指向前驱</p>
<p>rtag：0 指向rchild，1指向后继</p>
<h4 id="中序遍历线索化">中序遍历线索化</h4>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210055062-58605796.png" alt="1746158328489" loading="lazy"></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef char ElemType;

typedef struct ThreadNode {
    ElemType data;
    struct ThreadNode *lchild, *rchild;
    int ltag, rtag;
} ThreadNode;

typedef ThreadNode *ThreadTree;

char str[] = "ABDH##I##EJ###CF##G##";
int idx = 0;

ThreadTree prev;

//创建二叉树
void createTree(ThreadTree *T){
    ElemType ch;
	ch = str[idx++];
	if (ch == '#')
	{
		*T = NULL;
	}
	else
	{
		*T = (ThreadTree)malloc(sizeof(ThreadNode));
		(*T)-&gt;data = ch;

		createTree(&amp; ( (*T)-&gt;lchild ) );
        //lchild有左孩子，则ltag=0
        if( (*T)-&gt;lchild != NULL){
            (*T)-&gt;ltag = 0;
        }

        createTree(&amp; ( (*T)-&gt;rchild ) );
        if( (*T)-&gt;rchild != NULL){
            (*T)-&gt;rtag = 0;
        }
	}
}

//线索化——加前驱后继的逻辑
void threading(ThreadTree T){
    if(T != NULL){
        //一直往左边遍历
        threading(T-&gt;lchild);
        //当前结点的左孩子为空，当前结点的左孩子设定为指向前驱
        if(T-&gt;lchild == NULL){
            T-&gt;ltag = 1;
            T-&gt;lchild = prev;
        }
        //前驱结点的右孩子为空，前驱结点的右孩子设定为指向当前结点(当前结点就是前驱节点的后继)
        if(prev-&gt;rchild == NULL){
            prev-&gt;rtag = 1;
            prev-&gt;rchild = T;
        }
        //更新prev到根节点，往右边遍历
        prev = T;
        threading(T-&gt;rchild);
    }
}

//中序遍历线索化
void inOrderThreading(ThreadTree *head ,ThreadTree T){
    *head = (ThreadTree)malloc(sizeof(ThreadNode));
    (*head)-&gt;ltag = 0;
    (*head)-&gt;rtag = 1;
    (*head)-&gt;rchild = (*head);
    if(T == NULL){
        (*head)-&gt;lchild = (*head);
    }
    else{
        //头节点的左孩子指向树的根节点
        (*head)-&gt;lchild = T;

        //prev：上一个访问的节点是头节点
        prev = (*head);

        //加前驱后继的逻辑
        threading(T);

        //最后一个节点的右孩子指向头节点
        prev-&gt;rtag = 1;
        prev-&gt;rchild = (*head);

        //头节点的右孩子指向遍历的最后一个节点
        (*head)-&gt;rchild = prev;

    }
}

//基于线索的中序遍历
void inOrder(ThreadTree T){
    ThreadTree current = T-&gt;lchild;
    while(current != T){
        //如果当前节点有左孩子，则一直往左边遍历
        //没有左孩子，则退出当前循环 输出当前节点
        while(current-&gt;ltag == 0){
            current = current-&gt;lchild;
        }
        printf("%c",current-&gt;data);
        //往右边遍历, 直到右孩子不为空且当前的右孩子是头节点
        while(current-&gt;rtag == 1 &amp;&amp; current-&gt;rchild != T){
            current = current-&gt;rchild;
            printf("%c",current-&gt;data);
        }
        current = current-&gt;rchild;
    }
    printf("\n");
}

int main(){
    ThreadTree head;
    ThreadTree T;
    createTree(&amp;T);
    inOrderThreading(&amp;head,T);
    inOrder(head);
    return 0;
}
</code></pre>
<blockquote>
<p>习题</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210055704-825729549.png" alt="1746160668978" loading="lazy"></p>
<p>后序遍历：dbca</p>
<p>左虚线是前驱，右虚线是后继</p>
<p>根节点的前驱是头节点NULL</p>
<p>选D</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210056288-552051633.png" alt="1746161131561" loading="lazy"></p>
<pre><code class="language-c">	根节点
         / \
        Y   X
</code></pre>
<p>后序遍历：YX根</p>
<p>右虚线是后继，所以X的右线索指向根，也就是父节点</p>
<p>选A</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210056843-428904588.png" alt="1746161359418" loading="lazy"></p>
<p>中序遍历：debxac</p>
<p>左虚线是前驱，右虚线是后继</p>
<p>所以b、a</p>
<p>选D</p>
<h1 id="哈夫曼树">哈夫曼树</h1>
<blockquote>
<p>为什么要学哈夫曼树？</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210057383-445103587.png" alt="1746161652072" loading="lazy"></p>
<p>对于这样一个问题，通常用if分支表示</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210058010-872879910.png" alt="1746161690330" loading="lazy"></p>
<p>效率很低啊，有没有效率高的方式呢？</p>
<p>有的兄弟有的🤡</p>
<h2 id="基本概念">基本概念</h2>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210058566-54799438.png" alt="1746161736209" loading="lazy"></p>
<p>路径：两个结点之间经过的分支</p>
<p>路径长度：路径上的分支数，<em>也就是看这条路径上有几条线</em></p>
<p>树的路径长度：从根结点到每一个结点的路径长度之和</p>
<p>结点的权：权重</p>
<p>结点的带权路径长度：从该结点到树根之间的路径长度 * 该结点的权</p>
<p>树的带权路径长度(WPL)：树的<em><strong>所有叶子结点</strong></em>的带权路径长度之和</p>
<h2 id="计算wpl">计算WPL</h2>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210059185-2057764868.png" alt="1746185389854" loading="lazy"></p>
<h2 id="构造哈夫曼树">构造哈夫曼树</h2>
<ol>
<li>
<p>先把有权值的叶子结点从小到大排列，形成有序序列<br>
<img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210059976-1515444949.png" alt="1746185596032" loading="lazy"></p>
</li>
<li>
<p>取2个最小权值的结点作为新结点N1的子结点，新结点N1的权值就是这2个最小权值的和<br>
<img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210100549-1353689263.png" alt="1746185708799" loading="lazy"></p>
</li>
<li>
<p>把N1替换取出的2个结点，加入到有序序列中重新排列<img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210101158-1357425435.png" alt="1746185794238" loading="lazy"></p>
</li>
<li>
<p>回到步骤2重复操作(取2个最小权值结点，作为新结点)</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210101925-1238059339.png" alt="1746185936929" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210102861-764449814.png" alt="1746185988567" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210103400-1360377334.png" alt="1746186003996" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210104120-2117340533.png" alt="1746186118191" loading="lazy"></p>
</li>
</ol>
<p><strong>本质</strong>：让权重大的结点更靠近根结点，这样算WPL的时候就可以做到大权重乘小路径长度。</p>
<h3 id="哈夫曼树的性质">哈夫曼树的性质</h3>
<ol>
<li>哈夫曼树是WPL最小的二叉树</li>
<li>哈夫曼树只有度0(叶子)和度2的结点</li>
<li>哈夫曼树的叶子结点数为n，那么共有2n-1个结点</li>
</ol>
<blockquote>
<p>n = n0 + n2</p>
<p>n0 = n2 + 1</p>
<p>所以，n = 2 n0 - 1</p>
</blockquote>
<h2 id="哈夫曼编码">哈夫曼编码</h2>
<p>对于如下的表格：<img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210104704-995331187.png" alt="1746186959695" loading="lazy"></p>
<p>画出哈夫曼树，然后左0右1标号</p>
<pre><code>(也可以是左1右0)
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210105421-736447384.png" alt="1746186993488" loading="lazy"></p>
<p>哈夫曼编码结果：</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210106168-2089214702.png" alt="1746187088055" loading="lazy"></p>
<p>对比原编码，哈夫曼编码显然效率更高</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210106793-1180860848.png" alt="1746187117239" loading="lazy"></p>
<blockquote>
<p>习题</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210107643-1163759700.png" alt="1746187146697" loading="lazy"></p>
<p>哈夫曼树不一定是完全二叉树，因为不满足 <code>上一层没铺满不能有下一层</code></p>
<p>选A</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210108189-795930905.png" alt="1746187442859" loading="lazy"></p>
<p>前缀编码：任一编码都不是其他编码的前缀</p>
<p>ABC都满足前缀编码</p>
<p>D中110是1100的前缀，选D</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210109022-1108749974.png" alt="1746187642979" loading="lazy"></p>
<table>
<thead>
<tr>
<th>0100</th>
<th>011</th>
<th>001</th>
<th>001</th>
<th>011</th>
<th>11</th>
<th>0101</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>f</td>
<td>e</td>
<td>e</td>
<td>f</td>
<td>g</td>
<td>d</td>
</tr>
</tbody>
</table>
<p>选D</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210109639-1316223130.png" alt="1746187844837" loading="lazy"></p>
<p>选A</p>
<p>(自己画一下)</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210110261-377933150.png" alt="1746188144533" loading="lazy"></p>
<p>相当于叶子结点n，总结点115</p>
<p>115 = 2n - 1</p>
<p>解得n = 58</p>
<p>选C</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210110929-1117725459.png" alt="1746188584982" loading="lazy"></p>
<p>画出哈夫曼树，把每个叶子结点*路径长度加到一起</p>
<p>WPL = 16 2* + 21 * 2 +30 * 2 + 10 * 3 + 12 * 3 = 200</p>
<p>选B</p>
<h1 id="树与二叉树的转换">树与二叉树的转换</h1>
<h2 id="树--二叉树">树--&gt;二叉树</h2>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210111619-473957443.png" alt="1746188937392" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210112340-102138267.png" alt="1746188977652" loading="lazy"></p>
<h2 id="二叉树--树">二叉树--&gt;树</h2>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210113216-510902946.png" alt="1746189259111" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210114139-386290205.png" alt="1746189273570" loading="lazy"></p>
<h1 id="森林转二叉树">森林转二叉树</h1>
<h2 id="森林--二叉树">森林--&gt;二叉树</h2>
<ol>
<li>
<p>把每个树各自转成二叉树</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210114777-1469427715.png" alt="1746189700226" loading="lazy"></p>
<ol>
<li>
<p>所有兄弟结点连线</p>
</li>
<li>
<p>只保留每个结点与第一个孩子的连线</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210115326-1704129673.png" alt="1746189831039" loading="lazy"></p>
</li>
<li>
<p>旋转</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210115813-512174354.png" alt="1746189856440" loading="lazy"></p>
</li>
<li>
<p>后面的树也这样操作</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210116831-835387180.png" alt="1746189901115" loading="lazy"></p>
</li>
</ol>
</li>
<li>
<p>整合成一个二叉树</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210117605-665581319.png" alt="1746190052479" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210118141-642191432.png" alt="1746190071406" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210118664-2130186734.png" alt="1746190082245" loading="lazy"></p>
</li>
</ol>
<p>详细操作看<a href="https://www.bilibili.com/video/BV1tNpbekEht?spm_id_from=333.788.videopod.episodes&amp;vd_source=5eb26c403edb4b6de737a9c6fad9b1de&amp;p=10" target="_blank" rel="noopener nofollow">《数据结构（C 语言描述）》</a>的53:40左右进度条</p>
<h2 id="二叉树--森林">二叉树--&gt;森林</h2>
<ol>
<li>拆成多个二叉树
<ol>
<li>
<p>从根结点开始，右结点存在就删去与右孩子的连线</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210119288-1773623179.png" alt="1746190229686" loading="lazy"><br>
<img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210119811-482609508.png" alt="1746190259177" loading="lazy"></p>
</li>
</ol>
</li>
<li>每个 二叉树-&gt;树
<ol>
<li>
<p>从根结点开始，若结点的左孩存在，就把该结点与左孩的所有右孩相连</p>
</li>
<li>
<p>删去兄弟结点的连线</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210120859-781861551.png" alt="1746190569006" loading="lazy"></p>
</li>
<li>
<p>对每个二叉树做同样操作</p>
</li>
<li>
<p>旋转<br>
<img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250502210121410-2092994089.png" alt="1746190611787" loading="lazy"></p>
</li>
</ol>
</li>
</ol>
<h1 id="树的层序遍历">树的层序遍历</h1>
<h1 id="综合应用题">综合应用题</h1>
<p>详见<a href="https://www.bilibili.com/video/BV1tNpbekEht?spm_id_from=333.788.videopod.episodes&amp;vd_source=5eb26c403edb4b6de737a9c6fad9b1de&amp;p=11" target="_blank" rel="noopener nofollow">《数据结构（C 语言描述）》第11集</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.41972892935300926" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-03 16:35">2025-05-02 21:03</span>&nbsp;
<a href="https://www.cnblogs.com/eanojiang">EanoJiang</a>&nbsp;
阅读(<span id="post_view_count">67</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18857797);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18857797', targetLink: 'https://www.cnblogs.com/eanojiang/p/18857797', title: '树与二叉树' })">举报</a>
</div>
        