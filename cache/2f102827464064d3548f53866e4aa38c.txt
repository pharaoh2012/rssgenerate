
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18728372" title="发布于 2025-03-21 11:43">
    <span role="heading" aria-level="2">Windows核心编程 进程与线程</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="进程">进程</h1>
<p>Windows作为多任务操作系统，允许多个程序同时在系统中运行。这些程序被称为进程，进程运行在一片<code>独立</code>的空间中，受到操作系统保护，操作系统的很多资源都是围绕着进程来进行分配，可以理解为操作系统维度下资源分配的<code>最小粒度</code>.</p>
<p>一个进程由两部分构成</p>
<ol>
<li>一个内核对象<br>
内核对象保存进程的各种统计信息，操作系统依靠这些统计信息对进程进行管理</li>
<li>一个空间地址<br>
包含了exe，dll的代码和数据，以及线程栈与堆。</li>
</ol>
<p>在Windows操作系统中，进程拥有如下资源(节选)：</p>
<ol>
<li><strong>一片虚拟地址，也就是进程空间</strong></li>
<li><strong>PID</strong><br>
即ProcessId</li>
<li><strong>Image</strong><br>
即将程序加载到内存并使其能够运行所需的所有信息，也就死exe在内存中的表示</li>
<li><strong>线程</strong><br>
1-N个线程数量</li>
<li><strong>EPROCESS(Executive Process Block)</strong><br>
位于内核态，记录着内核态的关键信息</li>
<li><strong>句柄表</strong><br>
位于内核态，记录进程所创建/打开的内核对象。</li>
<li><strong>DirBase</strong><br>
进程的起始基地址</li>
<li><strong>PEB(Process Environment Block)</strong><br>
位于用户态，记录着用户态的关键信息</li>
<li><strong>Access token</strong><br>
表示进程的用户，安全组以及优先级</li>
</ol>
<h2 id="眼见为实">眼见为实</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250221142458718-244945339.png" alt="image" loading="lazy"></p>
<ol>
<li>SessionId<br>
指进程所在的windows会话Id,当多个用户登录时，有不同的会话Id</li>
<li>Cid/ParentCid<br>
即PID,以及创建该进程的那个进程Id</li>
</ol>
<h2 id="眼见为实句柄表">眼见为实:句柄表</h2>
<p>即ObjectTable<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250221144046038-277947348.png" alt="image" loading="lazy"></p>
<h2 id="眼见为实token">眼见为实:Token</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250221144315415-1570854155.png" alt="image" loading="lazy"></p>
<h2 id="eprocess内核态数据结构">EPROCESS,内核态数据结构</h2>
<p>每一个进程都会持有一个EPROCESS的结构，如果一个档案一样记录着进程的所有信息。上面所展示的信息，本质上就是对EPROCESS信息的提取</p>
<h3 id="眼见为实-1">眼见为实</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250221144620012-1229327888.png" alt="image" loading="lazy"></p>
<h2 id="peb用户态数据结构">PEB,用户态数据结构</h2>
<p>包含了进程的用户态信息，与EPROCESS位于内核态不同，PEB是先在内核态中创建，再映射到用户态之中</p>
<h3 id="眼见为实-2">眼见为实</h3>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250221145844393-783979351.png" alt="image" loading="lazy"></p>
<h1 id="进程空间">进程空间</h1>
<p>操作系统为了保护进程的安全，为不同的进程分配了独立的进程空间虚拟地址。目的旨在一个进程的代码与数据不会受到其它进程的修改，它们之间互相隔离。</p>
<h2 id="32位系统进程空间">32位系统进程空间</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250224101904106-1264974953.png" alt="image" loading="lazy"></p>
<h2 id="64位系统进程空间">64位系统进程空间</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250224101915077-1035737579.png" alt="image" loading="lazy"></p>
<h1 id="内核态与用户态">内核态与用户态</h1>
<p>Windows定义了两种访问模式，用户模式(user mode)与内核模式(kernel mode).<br>
应用程序运行在user mode下，操作系统运行的kernel model下，他们之间互相隔离，无法直接访问，即便应用程序知道了在内核态中的某个数据的正确指针，也会被终止访问。</p>
<p>虽然不可以直接访问，但Windows提供了<code>一道桥梁</code>,用于程序可以通过调用Win32 API来间接的访问内核态。</p>
<h2 id="眼见为实-3">眼见为实</h2>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250224102957959-21128994.png" alt="image" loading="lazy"></p>
<h1 id="线程">线程</h1>
<p>如果把操作系统比作一个国家，那么进程就是这个国家的家庭，而线程则是家庭的成员。</p>
<h2 id="懒惰的进程">懒惰的进程</h2>
<p>进程是非常<code>懒惰</code>的,从不执行任何东西，它只是线程与统计信息的一个容器，具体的工作需要由线程来执行。<br>
从上面的比喻也可以看出，家庭是一个抽象的概念，家庭的成员才是物理意义上的执行单位。</p>
<h2 id="臃肿的进程">臃肿的进程</h2>
<p>从上面的介绍可以看出，进程使用的资源会更多，其原因在于地址空间。<br>
为一个进程创建一个虚拟地址空间需要大量资源。</p>
<ol>
<li>大量的日志记录<br>
这需要用到大量内存</li>
<li>加载文件<br>
加载exe，dll到内存中，也是消耗大户</li>
</ol>
<p>相比之下，线程所使用的资源就要少得多了。一个线程实际上只有一个内核对象和一个栈。也不涉及日志记录。<br>
与进程类似，线程也由两个部分组成</p>
<ol>
<li>线程的内核对象<br>
内核对象保存线程的各种统计信息，操作系统依靠这些统计信息对线程进行管理</li>
<li>一个线程栈<br>
用于维护线程执行时所需要的函数参数与局部变量</li>
</ol>
<h2 id="ethread内核态数据结构">ETHREAD,内核态数据结构</h2>
<p>与EPROCESS结构来描述进程内核态的信息一样，线程也有一个类似的结构。名字叫做<code>ETHREAD</code><br>
<img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250221171002907-475013874.png" alt="image" loading="lazy"></p>
<p>ETHREAD的结构也很庞大，包含着线程各种属性。其中第一行的TCB(Thread Control Block)信息尤为重要，里面的字段主要是供内核调度线程时使用。<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250221171627666-406823169.png" alt="image" loading="lazy"></p>
<blockquote>
<p>ETHREAD 结构字段太多了，一般使用!thread来简化输出。</p>
</blockquote>
<h2 id="peb用户态数据结构-1">PEB,用户态数据结构</h2>
<p>与描述进程用户态信息的PEB一样，NT内核定义了线程环境块(Thread Environment Block)来描述线程的用户态信息。<br>
主要有用户态的栈空间，异常信息，线程本地存储等<br>
<img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250221173011357-487978691.png" alt="image" loading="lazy"></p>
<h1 id="创建进程的流程">创建进程的流程</h1>
<p><img src="https://img2024.cnblogs.com/blog/1084317/202502/1084317-20250224104600375-1340422994.png" alt="image" loading="lazy"></p>
<ol>
<li>打开执行文件，确定其名称，类型等前置资料，类似于C#中的EEClass</li>
<li>为新进程创建EPROCESS，进程空间，PEB</li>
<li>创建初始线程，状态为susepend<br>
这被称为主线程，然后这个线程会去创建更多的线程</li>
<li>通知CSRSS，类似新生儿上户口</li>
<li>初始线程开始执行</li>
<li>线程执行初始化动作，主要是加载依赖的dll</li>
</ol>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.19200117132523148" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-21 11:44">2025-03-21 11:43</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">49</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18728372" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18728372);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18728372', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18728372', title: 'Windows核心编程 进程与线程' })">举报</a>

		</p>
	