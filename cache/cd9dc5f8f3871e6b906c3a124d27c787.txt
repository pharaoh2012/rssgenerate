
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/san-mu/p/18964508" title="发布于 2025-07-04 21:13">
    <span role="heading" aria-level="2">MySQL 02 日志系统：一条SQL更新语句是如何执行的？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>比如执行一条更新语句：</p>
<pre><code class="language-sql">update T set c=c+1 where ID=2;
</code></pre>
<p>首先，更新语句也会走一遍查询语句的流程。除此以外，更新还涉及两个日志模块，分别是redo log和binlog。</p>
<h3 id="redo-log">redo log</h3>
<p>MySQL的更新用到了WAL（Write-Ahead Logging）技术，关键点就是先写日志，再写磁盘。具体来说，当有一条记录需要更新时，InnoDB引擎先将记录写到redo log并更新内存，这时更新就可以算完成了。之后，InnoDB会在适当的时候将这个操作记录更新到磁盘里。</p>
<p>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件大小为1GB。它的写法是从头开始写，写到末尾后又继续从开头写，如下所示：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250703213604980-1454586211.png" width="25%"></div>
<p>这里，write pos是当前记录的位置，check point是当前要擦除的位置。当记录更新到磁盘，check point会向前移动。当有新的更新操作要记录，write pos会向前移动。</p>
<p>因此，有可能write pos会追上check point。这时候就不能执行新的更新，需要先将一部分记录更新到磁盘。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<p>当设置<code>innodb_flush_log_at_trx_commit=1</code>，表示每次事务的redo log都直接持久化到磁盘。推荐设置，这样可以保证MySQL异常重启后数据不丢失。</p>
<h3 id="binlog">binlog</h3>
<p>redo log是InnoDB引擎特有的日志，而binlog是Server层的日志。最开始，由于MySQL自带引擎为MyISAM，并没有crash-safe的能力，因此后来引入InnoDB后，同时使用这两种日志。binlog的主要作用是做<strong>备份</strong>。</p>
<p>当设置<code>sync_binlog=1</code>，表示每次事务的binlog都持久化到磁盘。推荐设置，这样可以保证MySQL异常重启后binlog不丢失。</p>
<p>两者的具体区别如下：</p>
<ul>
<li>redo log是InnoDB引擎特有的，而binlog是Server层实现的。</li>
<li>redo log是物理日志，记录“在某个数据页上做了什么修改”；binlog是逻辑日志，记录这个语句的原始逻辑，比如“给ID=2的行的c字段加1”。</li>
<li>redo log是循环写，空间固定；binlog是追加写，写完一个文件会写下一个文件。</li>
</ul>
<br>
<br>
<p>介绍完两个日志的概念，来看执行器+InnoDB引擎完成前面的更新语句的流程：</p>
<ul>
<li>执行器找到ID=2这一行，若这一行所在的数据页在内存中，则直接返回给执行器，否则需要先从磁盘读入数据页再返回。</li>
<li>执行器拿到引擎返回的数据，做c+1的操作，得到新数据。</li>
<li>引擎将新数据更新到内存，同时将这个更新操作记录到redo log里，此时redo log处于prepare状态。然后告知执行器执行完成，随时可以提交事务。</li>
<li>执行器生成该操作的binlog，并将binlog写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚写入的redo log改成commit状态，更新完成。</li>
</ul>
<p>上面redo log写入拆为了prepare和commit，就是<strong>两阶段提交</strong>。</p>
<h3 id="为什么需要两阶段提交">为什么需要两阶段提交</h3>
<p>以前面的更新语句为例。假设ID=2的行中，字段c初始为0。并假设执行update过程中，写完第一个日志但还没写完第二个日志时发生了crash。</p>
<p>如果不使用两阶段提交，那么无非两种情况：</p>
<ul>
<li>先写redo log再写binlog。当redo log写完，系统即使崩溃，仍能恢复数据c=1。但binlog里并没有记录更新语句，之后要用binlog去做备份时，恢复出来的c=0，与原库不同。</li>
<li>先写binlog再写redo log。当binlog写完之后crash，由于redo log还没写，崩溃后恢复数据c=0。但由于binlog已写完，之后用binlog去做备份时，恢复出来的c=1，与原库不同。</li>
</ul>
<p>即如果不使用两阶段提交，那么恢复临时库或主从备份就可能出现不一致。</p>
<br>
<br>
<p>参考资料：极客时间专栏《MySQL实战45讲》<a href="https://time.geekbang.org/column/intro/100020801?tab=catalog" target="_blank" rel="noopener nofollow">https://time.geekbang.org/column/intro/100020801?tab=catalog</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-04 21:14">2025-07-04 21:13</span>&nbsp;
<a href="https://www.cnblogs.com/san-mu">叁沐</a>&nbsp;
阅读(<span id="post_view_count">11</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18964508);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18964508', targetLink: 'https://www.cnblogs.com/san-mu/p/18964508', title: 'MySQL 02 日志系统：一条SQL更新语句是如何执行的？' })">举报</a>
</div>
        