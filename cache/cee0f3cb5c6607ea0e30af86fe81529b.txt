
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiaokang-coding/p/18894717" title="发布于 2025-05-24 21:26">
    <span role="heading" aria-level="2">「C++黑魔法」future与promise：不加锁的异步编程，原来可以这么简单！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>大家好，我是小康。</p>
<p>你是否曾经为了让程序同时做多件事而绞尽脑汁？是否被多线程编程的各种锁、条件变量搞得头昏脑胀？今天，我要告诉你一个秘密武器，让你轻松驾驭异步编程的海洋！</p>
<h2 id="前言为什么要学future和promise">前言：为什么要学future和promise？</h2>
<p>朋友，想象一下这个场景：你在餐厅点了一份需要20分钟才能做好的复杂菜品。你有两个选择：</p>
<ol>
<li>坐在那里盯着厨房门口，等待20分钟（同步等待）</li>
<li>服务员给了你个取餐码，菜品好了会通知你，同时你可以刷刷手机或聊聊天（异步等待）</li>
</ol>
<p>显然，第二种方式更高效，对吧？</p>
<p>在C++编程中，<code>future</code>和<code>promise</code>就像是这个"取餐码+通知"系统，让你的程序能够优雅地处理异步任务。它们是C++11引入的现代并发编程工具，比传统的线程、互斥锁和条件变量更加简单易用。</p>
<h2 id="一异步任务是个啥通俗地说就是后台运行">一、异步任务是个啥？通俗地说就是"后台运行"</h2>
<p>在解释<code>future</code>和<code>promise</code>之前，我们先聊聊什么是异步任务。</p>
<p><strong>异步任务</strong>就是指那些可以在"后台"执行，不需要主线程等待的任务。比如：</p>
<ul>
<li>下载一个大文件</li>
<li>复杂计算（如图像处理）</li>
<li>访问远程服务器</li>
</ul>
<p>想象一下你的电脑在下载游戏的同时，你还能继续刷视频、聊天，这就是异步的魅力！</p>
<h2 id="二future未来会得到的结果">二、future：未来会得到的结果</h2>
<p><code>future</code>可以理解为"未来的结果"，它就像一张电影票根：</p>
<ul>
<li>你现在拿着票根（future）</li>
<li>电影（异步任务）正在后台准备中</li>
<li>当电影准备好了，你可以用票根进场（获取结果）</li>
</ul>
<p>用代码说话：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;

int compute_answer() {
    // 假装这是个复杂计算
    std::cout &lt;&lt; "开始计算终极问题的答案..." &lt;&lt; std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时操作
    std::cout &lt;&lt; "计算完成！" &lt;&lt; std::endl;
    return 42; // 返回结果
}

int main() {
    // 启动异步任务，立即返回一个future
    std::cout &lt;&lt; "主线程：启动一个耗时任务" &lt;&lt; std::endl;
    std::future&lt;int&gt; answer_future = std::async(compute_answer);

    std::cout &lt;&lt; "主线程：哇，不用等待，我可以继续做其他事情！" &lt;&lt; std::endl;

    // 做一些其他工作...
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout &lt;&lt; "主线程：我在异步任务计算的同时做了些其他事" &lt;&lt; std::endl;

    // 当需要结果时，我们可以获取它
    // 如果结果还没准备好，这会阻塞直到结果可用
    std::cout &lt;&lt; "主线程：好了，现在我需要知道答案了，等待结果..." &lt;&lt; std::endl;
    int answer = answer_future.get();

    std::cout &lt;&lt; "终极答案是：" &lt;&lt; answer &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><strong>输出结果</strong>：</p>
<pre><code class="language-plain">主线程：启动一个耗时任务
开始计算终极问题的答案...
主线程：哇，不用等待，我可以继续做其他事情！
主线程：我在异步任务计算的同时做了些其他事
计算完成！
主线程：好了，现在我需要知道答案了，等待结果...
终极答案是：42
</code></pre>
<p>看到了吗？主线程启动了计算，但并不立即等待结果，而是继续执行其他代码。只有当真正需要结果时（调用<code>get()</code>），才会等待异步任务完成。</p>
<h2 id="三promise我保证会给你结果">三、promise：我保证会给你结果</h2>
<p>如果说<code>future</code>是领取结果的凭证，那么<code>promise</code>就是一个承诺："我保证会在某个时刻设置一个值"。它们是一对好搭档：</p>
<ul>
<li><code>promise</code>负责在某个时刻设置结果</li>
<li><code>future</code>负责在需要时获取结果</li>
</ul>
<p>这就像你和朋友的约定：</p>
<ul>
<li>你：我承诺会告诉你考试成绩（promise）</li>
<li>朋友：我会等你告诉我（future）</li>
</ul>
<p>来看个例子：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;

void producer(std::promise&lt;int&gt; my_promise) {
    std::cout &lt;&lt; "生产者：我要开始生产一个重要的值了..." &lt;&lt; std::endl;

    // 假装我们在做一些复杂的计算
    std::this_thread::sleep_for(std::chrono::seconds(2));

    int result = 42;
    std::cout &lt;&lt; "生产者：计算完成，设置结果到promise" &lt;&lt; std::endl;

    // 设置promise的值，这会通知相关的future
    my_promise.set_value(result);
}

int main() {
    // 创建一个promise
    std::promise&lt;int&gt; answer_promise;

    // 从promise获取一个future
    std::future&lt;int&gt; answer_future = answer_promise.get_future();

    // 启动一个线程，传入promise
    std::cout &lt;&lt; "主线程：启动生产者线程" &lt;&lt; std::endl;
    std::thread producer_thread(producer, std::move(answer_promise));

    // 主线程继续做其他事情
    std::cout &lt;&lt; "主线程：我可以做自己的事，不用等待..." &lt;&lt; std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(1));

    // 当需要结果时
    std::cout &lt;&lt; "主线程：现在我需要结果了，等待future..." &lt;&lt; std::endl;
    int answer = answer_future.get();
    std::cout &lt;&lt; "主线程：收到结果：" &lt;&lt; answer &lt;&lt; std::endl;

    // 别忘了等待线程结束
    producer_thread.join();

    return 0;
}
</code></pre>
<p><strong>输出结果</strong>：</p>
<pre><code class="language-plain">主线程：启动生产者线程
生产者：我要开始生产一个重要的值了...
主线程：我可以做自己的事，不用等待...
主线程：现在我需要结果了，等待future...
生产者：计算完成，设置结果到promise
主线程：收到结果：42
</code></pre>
<p>这个例子展示了如何使用<code>promise</code>和<code>future</code>在线程间传递结果。生产者线程通过<code>promise</code>设置值，主线程通过<code>future</code>获取值。</p>
<h2 id="四future的几种获取方式">四、future的几种获取方式</h2>
<p>除了通过<code>promise</code>获取<code>future</code>，C++11还提供了其他便捷方式：</p>
<h3 id="1-通过async获取future">1. 通过async获取future</h3>
<p><code>std::async</code>是最简单的方式，它自动创建线程并返回<code>future</code>：</p>
<pre><code class="language-cpp">std::future&lt;int&gt; result = std::async([]() {
    return 42;
});
</code></pre>
<h3 id="2-通过packaged_task获取future">2. 通过packaged_task获取future</h3>
<p><code>std::packaged_task</code>包装了一个可调用对象，并允许你获取其<code>future</code>：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;thread&gt;

int main() {
    // 创建一个packaged_task，包装一个lambda函数
    std::packaged_task&lt;int(int, int)&gt; task([](int a, int b) {
        std::cout &lt;&lt; "计算 " &lt;&lt; a &lt;&lt; " + " &lt;&lt; b &lt;&lt; std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时计算
        return a + b;
    });

    // 获取future
    std::future&lt;int&gt; result = task.get_future();

    // 在新线程中执行任务
    std::thread task_thread(std::move(task), 10, 32);

    // 主线程做其他事情...
    std::cout &lt;&lt; "主线程：等待计算结果..." &lt;&lt; std::endl;

    // 获取结果
    int sum = result.get();
    std::cout &lt;&lt; "结果是：" &lt;&lt; sum &lt;&lt; std::endl;

    task_thread.join();
    return 0;
}
</code></pre>
<p><strong>输出结果</strong>：</p>
<pre><code class="language-plain">主线程：等待计算结果...
计算 10 + 32
结果是：42
</code></pre>
<h2 id="五实用功能future的超时等待">五、实用功能：future的超时等待</h2>
<p>有时候，我们不想无限期地等待异步任务。<code>future</code>提供了带超时的等待功能：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;chrono&gt;

int long_calculation() {
    std::this_thread::sleep_for(std::chrono::seconds(3));
    return 42;
}

int main() {
    auto future = std::async(std::launch::async, long_calculation);

    // 设置1秒超时
    auto status = future.wait_for(std::chrono::seconds(1));

    if (status == std::future_status::ready) {
        std::cout &lt;&lt; "任务已完成，结果是：" &lt;&lt; future.get() &lt;&lt; std::endl;
    } else if (status == std::future_status::timeout) {
        std::cout &lt;&lt; "等待超时！任务还没完成" &lt;&lt; std::endl;

        // 我们仍然可以继续等待完成
        std::cout &lt;&lt; "继续等待..." &lt;&lt; std::endl;
        std::cout &lt;&lt; "最终结果：" &lt;&lt; future.get() &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<p><strong>输出结果</strong>：</p>
<pre><code class="language-plain">等待超时！任务还没完成
继续等待...
最终结果：42
</code></pre>
<h2 id="六异常处理当异步任务出错时">六、异常处理：当异步任务出错时</h2>
<p>异步任务中的异常会被捕获并存储在<code>future</code>中，当你调用<code>get()</code>时会重新抛出：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;stdexcept&gt;

int may_throw() {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    throw std::runtime_error("哎呀，出错了！");
    return 42;
}

int main() {
    auto future = std::async(may_throw);

    try {
        int result = future.get();
        std::cout &lt;&lt; "结果：" &lt;&lt; result &lt;&lt; std::endl;
    } catch (const std::exception&amp; e) {
        std::cout &lt;&lt; "捕获到异常：" &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<p><strong>输出结果</strong>：</p>
<pre><code class="language-plain">捕获到异常：哎呀，出错了！
</code></pre>
<p>这种设计非常优雅——无论异步任务是成功返回值还是抛出异常，都能通过同一个<code>future</code>接口处理。</p>
<h2 id="七实际应用案例并行计算求和">七、实际应用案例：并行计算求和</h2>
<p>让我们用一个更实用的例子来巩固理解：并行计算大数组的和。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;
#include &lt;future&gt;
#include &lt;chrono&gt;

// 计算数组部分和的函数
long long partial_sum(const std::vector&lt;int&gt;&amp; data, size_t start, size_t end) {
    return std::accumulate(data.begin() + start, data.begin() + end, 0LL);
}

int main() {
    // 创建一个大数组
    const size_t size = 100000000; // 1亿个元素
    std::vector&lt;int&gt; data(size, 1); // 全是1的数组

    auto start_time = std::chrono::high_resolution_clock::now();

    // 单线程计算
    long long single_result = std::accumulate(data.begin(), data.end(), 0LL);

    auto single_end = std::chrono::high_resolution_clock::now();
    auto single_duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(single_end - start_time);

    std::cout &lt;&lt; "单线程结果: " &lt;&lt; single_result &lt;&lt; " (耗时: " 
        &lt;&lt; single_duration.count() &lt;&lt; "ms)" &lt;&lt; std::endl;

    // 使用4个线程并行计算
    auto multi_start = std::chrono::high_resolution_clock::now();

    const size_t num_threads = 4;
    const size_t block_size = size / num_threads;

    std::vector&lt;std::future&lt;long long&gt;&gt; futures;

    for (size_t i = 0; i &lt; num_threads; ++i) {
        size_t start = i * block_size;
        size_t end = (i == num_threads - 1) ? size : (i + 1) * block_size;

        // 启动异步任务
        futures.push_back(std::async(std::launch::async, 
            partial_sum, std::ref(data), start, end));
    }

    // 收集结果
    long long multi_result = 0;
    for (auto&amp; f : futures) {
        multi_result += f.get();
    }

    auto multi_end = std::chrono::high_resolution_clock::now();
    auto multi_duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(multi_end - multi_start);

    std::cout &lt;&lt; "多线程结果: " &lt;&lt; multi_result &lt;&lt; " (耗时: " 
        &lt;&lt; multi_duration.count() &lt;&lt; "ms)" &lt;&lt; std::endl;

    std::cout &lt;&lt; "加速比: " &lt;&lt; static_cast&lt;double&gt;(single_duration.count()) / multi_duration.count() &lt;&lt; "x" &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><strong>可能的输出结果</strong>（取决于你的硬件）：</p>
<pre><code class="language-plain">单线程结果: 100000000 (耗时: 570ms)
多线程结果: 100000000 (耗时: 171ms)
加速比: 3.33333x
</code></pre>
<p>看到没？多线程版本明显更快！这正是<code>future</code>的价值所在——让并行编程变得简单而高效。</p>
<h2 id="八总结为什么future和promise这么香">八、总结：为什么future和promise这么香？</h2>
<p>现在，你已经了解了C++11中<code>future</code>和<code>promise</code>的基本用法。它们的优势在于：</p>
<ol>
<li><strong>简化异步编程</strong>：比直接管理线程、互斥锁和条件变量简单得多</li>
<li><strong>清晰的所有权模型</strong>：<code>promise</code>负责生产值，<code>future</code>负责消费值</li>
<li><strong>异常传递</strong>：异步任务中的异常会自动传递给等待的<code>future</code></li>
<li><strong>超时控制</strong>：可以设置等待超时，避免无限阻塞</li>
<li><strong>与现代C++完美融合</strong>：配合lambda、智能指针等现代特性使用更加优雅</li>
</ol>
<p>记住这个类比就行：<code>promise</code>就像一个"承诺给你结果的人"，<code>future</code>就像"等待结果的凭证"。</p>
<p>下次当你需要在程序中执行耗时操作又不想阻塞主线程时，就想到<code>future</code>和<code>promise</code>吧！它们会让你的代码更加现代、高效，还能充分利用多核处理器的威力。</p>
<p>最后一个小提示：虽然C++11的<code>future</code>和<code>promise</code>已经很强大，但如果你追求更高级的异步编程，可以考虑看看C++20的协程(coroutine)特性，那又是另一个让人兴奋的话题了～</p>
<hr>
<h2 id="写在最后这只是异步编程旅程的开始">写在最后：这只是异步编程旅程的开始...</h2>
<p>嘿，朋友！看到这里，你已经掌握了C++异步编程的一把利器了！但编程世界就像宇宙一样浩瀚无边，我们的探索才刚刚开始～</p>
<p><strong>学到了新知识？有疑问？有心得？</strong><br>
👉 快到评论区和大家分享吧！我会亲自解答你的每一个问题。</p>
<p><strong>如果这篇文章让你有所收获...</strong><br>
请点赞、收藏、关注哦，这对我来说，就像异步任务完成时收到的一个<code>promise.set_value()</code>一样珍贵！转发给你的程序猿/媛朋友，他们一定也会感谢你分享这个编程"黑魔法"！</p>
<p><strong>想要更多编程"神器"吗？</strong></p>
<p>关注我的公众号「跟着小康学编程」，这里有：</p>
<p>🚀 <strong>多线程编程实战秘籍</strong> —— 让你的程序飞起来，CPU核心全利用！<br>
🔍 <strong>C++面试题深度解析</strong> —— 面试官：这水平，必须给offer！<br>
🛠️ <strong>现代C++高级技巧</strong> —— C++11/14/17/20新特性全解析，代码立减50%！<br>
🧩 <strong>STL源码探秘</strong> —— 看大神是怎么写代码的，学就要学最好的！<br>
💻 <strong>实战项目分享</strong> —— 纸上得来终觉浅，实战出真知！</p>
<p>👇 <strong>扫码即可关注</strong>。</p>
<p><img src="https://files.mdnice.com/user/71186/0dde803d-d52f-4ed8-b74b-b7f3da5817b9.png" alt="" loading="lazy"></p>
<p><strong>哈，想不想和一群志同道合的C++爱好者一起交流？</strong></p>
<p>扫描下方二维码，加入我们的技术交流群！</p>
<p>群里有什么？有大厂C++开发工程师坐镇，有热心的同行互帮互助...</p>
<p>遇到 bug 卡住了？代码性能优化不上去？面试准备没方向？</p>
<p>别着急，一个消息发出去，群里的大佬们立马帮你解决！</p>
<p><img src="https://files.mdnice.com/user/48364/971ccaa3-8f57-4e33-8bc9-d0863eeade81.png" alt="" loading="lazy"></p>
<p>记住，在编程的世界里，你从不孤单。我们的<code>future</code>已经连接，就等你的<code>get()</code>来获取知识的果实了！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6227688202719908" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-24 21:26">2025-05-24 21:26</span>&nbsp;
<a href="https://www.cnblogs.com/xiaokang-coding">江小康</a>&nbsp;
阅读(<span id="post_view_count">63</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18894717);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18894717', targetLink: 'https://www.cnblogs.com/xiaokang-coding/p/18894717', title: '「C++黑魔法」future与promise：不加锁的异步编程，原来可以这么简单！' })">举报</a>
</div>
        