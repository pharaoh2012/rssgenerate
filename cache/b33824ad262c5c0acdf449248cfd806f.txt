
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/damaoa/p/18964981" title="发布于 2025-07-04 09:16">
    <span role="heading" aria-level="2">MySQL查询执行顺序：一张图看懂SQL是如何工作的</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="mysql查询执行顺序一张图看懂sql是如何工作的">MySQL查询执行顺序：一张图看懂SQL是如何工作的</h1>
<blockquote>
<p>你写的SQL语句为什么这么慢？为什么有时候加了索引还是不走？为什么GROUP BY要放在WHERE后面？这些问题的答案都藏在SQL的执行顺序里！</p>
</blockquote>
<h2 id="-开篇一个让人困惑的问题">🔥 开篇：一个让人困惑的问题</h2>
<p>作为程序员，你是否遇到过这样的困惑：</p>
<pre><code class="language-sql">-- 这个查询为什么报错？
SELECT name, age, COUNT(*) as cnt
FROM users 
WHERE age &gt; 18 AND cnt &gt; 5
GROUP BY name;
</code></pre>
<p>明明逻辑很清楚：查找年龄大于18岁，且统计数量大于5的用户，为什么MySQL却告诉你 <code>cnt</code> 字段不存在？</p>
<p>答案就在SQL的执行顺序里！今天我们就来揭开这个神秘的面纱。</p>
<h2 id="-sql执行顺序全景图">📋 SQL执行顺序全景图</h2>
<p>让我们先看一个完整的SQL查询语句：</p>
<pre><code class="language-sql">SELECT DISTINCT column_name, COUNT(*)
FROM table_name t1
JOIN table_name2 t2 ON t1.id = t2.user_id
WHERE condition
GROUP BY column_name
HAVING COUNT(*) &gt; 1
ORDER BY column_name
LIMIT 10 OFFSET 20;
</code></pre>
<p>你以为MySQL是按照你写的顺序执行的吗？<strong>大错特错！</strong></p>
<p>MySQL的真实执行顺序是这样的：</p>
<div class="mermaid">graph TD
    A[FROM - 确定数据源] --&gt; B[JOIN - 连接表]
    B --&gt; C[WHERE - 过滤行]
    C --&gt; D[GROUP BY - 分组]
    D --&gt; E[HAVING - 过滤分组]
    E --&gt; F[SELECT - 选择列]
    F --&gt; G[DISTINCT - 去重]
    G --&gt; H[ORDER BY - 排序]
    H --&gt; I[LIMIT - 限制结果]
</div><h2 id="-详解每个执行步骤">🎯 详解每个执行步骤</h2>
<h3 id="第1步from---找到数据源">第1步：FROM - 找到数据源</h3>
<pre><code class="language-sql">FROM users u
</code></pre>
<p>MySQL首先要知道数据从哪里来，所以第一步是确定表和给表起别名。</p>
<p><strong>这一步做了什么？</strong></p>
<ul>
<li>找到指定的表</li>
<li>为表创建别名（如果有的话）</li>
<li>准备读取数据</li>
</ul>
<h3 id="第2步join---连接多张表">第2步：JOIN - 连接多张表</h3>
<pre><code class="language-sql">FROM users u
JOIN orders o ON u.id = o.user_id
</code></pre>
<p>如果查询涉及多张表，MySQL会根据JOIN条件将它们连接起来。</p>
<p><strong>常见的JOIN类型：</strong></p>
<ul>
<li><code>INNER JOIN</code>：只返回两表都有的数据</li>
<li><code>LEFT JOIN</code>：返回左表所有数据，右表没有则为NULL</li>
<li><code>RIGHT JOIN</code>：返回右表所有数据，左表没有则为NULL</li>
</ul>
<pre><code class="language-sql">-- 示例：查询用户及其订单信息
SELECT u.name, o.order_date
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;
</code></pre>
<h3 id="第3步where---过滤不需要的行">第3步：WHERE - 过滤不需要的行</h3>
<pre><code class="language-sql">WHERE u.age &gt; 18 AND u.status = 'active'
</code></pre>
<p>在分组之前，MySQL会根据WHERE条件过滤掉不符合条件的行。</p>
<p><strong>注意：WHERE不能使用聚合函数！</strong></p>
<pre><code class="language-sql">-- ❌ 错误写法
SELECT name, COUNT(*) as cnt
FROM users
WHERE COUNT(*) &gt; 5;  -- 报错！

-- ✅ 正确写法
SELECT name, COUNT(*) as cnt
FROM users
GROUP BY name
HAVING COUNT(*) &gt; 5;  -- 用HAVING
</code></pre>
<h3 id="第4步group-by---数据分组">第4步：GROUP BY - 数据分组</h3>
<pre><code class="language-sql">GROUP BY u.department, u.position
</code></pre>
<p>将数据按照指定的列进行分组，为聚合函数做准备。</p>
<p><strong>分组示例：</strong></p>
<pre><code class="language-sql">-- 按部门统计员工数量
SELECT department, COUNT(*) as employee_count
FROM users
WHERE status = 'active'
GROUP BY department;
</code></pre>
<h3 id="第5步having---过滤分组">第5步：HAVING - 过滤分组</h3>
<pre><code class="language-sql">HAVING COUNT(*) &gt; 10
</code></pre>
<p>HAVING是对分组后的结果进行过滤，可以使用聚合函数。</p>
<p><strong>WHERE vs HAVING 对比：</strong></p>
<table>
<thead>
<tr>
<th>条件</th>
<th>WHERE</th>
<th>HAVING</th>
</tr>
</thead>
<tbody>
<tr>
<td>执行时机</td>
<td>分组前</td>
<td>分组后</td>
</tr>
<tr>
<td>过滤对象</td>
<td>行</td>
<td>分组</td>
</tr>
<tr>
<td>能否使用聚合函数</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody>
</table>
<pre><code class="language-sql">-- 找出订单数量超过10的用户
SELECT user_id, COUNT(*) as order_count
FROM orders
WHERE order_status = 'completed'  -- 先过滤已完成的订单
GROUP BY user_id
HAVING COUNT(*) &gt; 10;  -- 再过滤订单数量超过10的用户
</code></pre>
<h3 id="第6步select---选择要显示的列">第6步：SELECT - 选择要显示的列</h3>
<pre><code class="language-sql">SELECT u.name, u.age, COUNT(o.id) as order_count
</code></pre>
<p>到了这一步，MySQL才开始处理SELECT子句，选择要显示的列。</p>
<p><strong>这就是为什么WHERE不能使用SELECT中定义的别名！</strong></p>
<pre><code class="language-sql">-- ❌ 错误：WHERE执行在SELECT之前
SELECT name, age * 2 as double_age
FROM users
WHERE double_age &gt; 50;  -- double_age还不存在！

-- ✅ 正确写法
SELECT name, age * 2 as double_age
FROM users
WHERE age * 2 &gt; 50;
</code></pre>
<h3 id="第7步distinct---去除重复">第7步：DISTINCT - 去除重复</h3>
<pre><code class="language-sql">SELECT DISTINCT department
FROM users;
</code></pre>
<p>如果使用了DISTINCT，MySQL会去除重复的行。</p>
<h3 id="第8步order-by---排序">第8步：ORDER BY - 排序</h3>
<pre><code class="language-sql">ORDER BY u.age DESC, u.name ASC
</code></pre>
<p>对最终结果进行排序。</p>
<p><strong>ORDER BY可以使用SELECT中的别名：</strong></p>
<pre><code class="language-sql">-- ✅ 正确：ORDER BY执行在SELECT之后
SELECT name, age * 2 as double_age
FROM users
ORDER BY double_age DESC;  -- 可以使用别名
</code></pre>
<h3 id="第9步limit---限制结果数量">第9步：LIMIT - 限制结果数量</h3>
<pre><code class="language-sql">LIMIT 10 OFFSET 20
</code></pre>
<p>最后一步，限制返回的结果数量。</p>
<h2 id="-实战案例执行顺序的应用">💡 实战案例：执行顺序的应用</h2>
<p>让我们通过一个实际案例来理解执行顺序：</p>
<pre><code class="language-sql">-- 需求：查询每个部门中年龄大于25岁的员工数量，
-- 只显示员工数量超过5人的部门，按员工数量降序排列

SELECT 
    department,
    COUNT(*) as employee_count
FROM users
WHERE age &gt; 25
GROUP BY department  
HAVING COUNT(*) &gt; 5
ORDER BY employee_count DESC;
</code></pre>
<p><strong>执行过程分析：</strong></p>
<ol>
<li><strong>FROM users</strong> - 确定数据源</li>
<li><strong>WHERE age &gt; 25</strong> - 过滤年龄大于25的员工</li>
<li><strong>GROUP BY department</strong> - 按部门分组</li>
<li><strong>HAVING COUNT(*) &gt; 5</strong> - 过滤员工数量超过5的部门</li>
<li><strong>SELECT department, COUNT(*)</strong> - 选择要显示的列</li>
<li><strong>ORDER BY employee_count DESC</strong> - 按员工数量降序排列</li>
</ol>
<h2 id="-性能优化技巧">🚀 性能优化技巧</h2>
<p>了解执行顺序后，我们可以进行一些性能优化：</p>
<h3 id="1-where条件优化">1. WHERE条件优化</h3>
<pre><code class="language-sql">-- ❌ 低效：先JOIN再过滤
SELECT u.name, o.order_date
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.status = 'active';

-- ✅ 高效：先过滤再JOIN
SELECT u.name, o.order_date
FROM (SELECT * FROM users WHERE status = 'active') u
JOIN orders o ON u.id = o.user_id;
</code></pre>
<h3 id="2-索引利用">2. 索引利用</h3>
<pre><code class="language-sql">-- 为WHERE条件创建索引
CREATE INDEX idx_user_status_age ON users(status, age);

-- 查询会自动使用索引
SELECT * FROM users WHERE status = 'active' AND age &gt; 25;
</code></pre>
<h3 id="3-避免不必要的排序">3. 避免不必要的排序</h3>
<pre><code class="language-sql">-- 如果不需要排序，不要使用ORDER BY
SELECT department, COUNT(*)
FROM users
GROUP BY department;
-- 而不是
SELECT department, COUNT(*)
FROM users
GROUP BY department
ORDER BY department;  -- 不必要的排序
</code></pre>
<h2 id="-常见错误及解决方案">🔧 常见错误及解决方案</h2>
<h3 id="错误1在where中使用聚合函数">错误1：在WHERE中使用聚合函数</h3>
<pre><code class="language-sql">-- ❌ 错误
SELECT department, COUNT(*) as cnt
FROM users
WHERE COUNT(*) &gt; 5;

-- ✅ 正确
SELECT department, COUNT(*) as cnt
FROM users
GROUP BY department
HAVING COUNT(*) &gt; 5;
</code></pre>
<h3 id="错误2在where中使用select别名">错误2：在WHERE中使用SELECT别名</h3>
<pre><code class="language-sql">-- ❌ 错误
SELECT name, salary * 12 as annual_salary
FROM employees
WHERE annual_salary &gt; 100000;

-- ✅ 正确
SELECT name, salary * 12 as annual_salary
FROM employees
WHERE salary * 12 &gt; 100000;
</code></pre>
<h3 id="错误3group-by与select不匹配">错误3：GROUP BY与SELECT不匹配</h3>
<pre><code class="language-sql">-- ❌ 错误：SELECT中的列必须在GROUP BY中，或者是聚合函数
SELECT department, name, COUNT(*)
FROM users
GROUP BY department;

-- ✅ 正确
SELECT department, COUNT(*)
FROM users
GROUP BY department;
</code></pre>
<h2 id="-执行顺序速记口诀">📊 执行顺序速记口诀</h2>
<p>为了帮助大家记忆，我总结了一个口诀：</p>
<blockquote>
<p><strong>"从哪连什么，分组再筛选，选择去重排，最后限数量"</strong></p>
</blockquote>
<ul>
<li><strong>从哪</strong> - FROM</li>
<li><strong>连什么</strong> - JOIN</li>
<li><strong>什么</strong> - WHERE</li>
<li><strong>分组</strong> - GROUP BY</li>
<li><strong>再筛选</strong> - HAVING</li>
<li><strong>选择</strong> - SELECT</li>
<li><strong>去重</strong> - DISTINCT</li>
<li><strong>排</strong> - ORDER BY</li>
<li><strong>最后限数量</strong> - LIMIT</li>
</ul>
<h2 id="-可视化理解">🎨 可视化理解</h2>
<p>让我们用一个图表来直观理解：</p>
<div class="mermaid">graph LR
    A[原始数据表] --&gt; B[FROM: 确定数据源]
    B --&gt; C[JOIN: 连接其他表]
    C --&gt; D[WHERE: 过滤行]
    D --&gt; E[GROUP BY: 分组]
    E --&gt; F[HAVING: 过滤分组]
    F --&gt; G[SELECT: 选择列]
    G --&gt; H[DISTINCT: 去重]
    H --&gt; I[ORDER BY: 排序]
    I --&gt; J[LIMIT: 限制数量]
    J --&gt; K[最终结果]
</div><h2 id="-实战练习">🏆 实战练习</h2>
<p>现在让我们做一个小练习，看看你是否真的理解了执行顺序：</p>
<pre><code class="language-sql">-- 题目：下面这个查询的执行顺序是什么？
SELECT 
    DISTINCT u.department,
    AVG(u.salary) as avg_salary
FROM users u
JOIN departments d ON u.dept_id = d.id
WHERE u.status = 'active' AND d.budget &gt; 100000
GROUP BY u.department
HAVING AVG(u.salary) &gt; 50000
ORDER BY avg_salary DESC
LIMIT 5;
</code></pre>
<p><strong>答案：</strong></p>
<ol>
<li>FROM users u - 确定主表</li>
<li>JOIN departments d ON u.dept_id = d.id - 连接部门表</li>
<li>WHERE u.status = 'active' AND d.budget &gt; 100000 - 过滤活跃用户和预算充足的部门</li>
<li>GROUP BY u.department - 按部门分组</li>
<li>HAVING AVG(u.salary) &gt; 50000 - 过滤平均工资超过5万的部门</li>
<li>SELECT DISTINCT u.department, AVG(u.salary) - 选择部门和平均工资</li>
<li>DISTINCT - 去重（虽然这里GROUP BY已经保证唯一性）</li>
<li>ORDER BY avg_salary DESC - 按平均工资降序排列</li>
<li>LIMIT 5 - 只取前5条记录</li>
</ol>
<h2 id="-总结">🎯 总结</h2>
<p>理解SQL执行顺序的重要性：</p>
<ol>
<li><strong>避免语法错误</strong> - 知道什么时候可以使用别名</li>
<li><strong>优化查询性能</strong> - 合理安排过滤条件的位置</li>
<li><strong>正确使用聚合函数</strong> - 区分WHERE和HAVING的使用场景</li>
<li><strong>编写高效SQL</strong> - 让数据库引擎更好地优化查询</li>
</ol>
<p>记住这个执行顺序：<strong>FROM → JOIN → WHERE → GROUP BY → HAVING → SELECT → DISTINCT → ORDER BY → LIMIT</strong></p>
<h2 id="-写在最后">💪 写在最后</h2>
<p>SQL执行顺序虽然看起来复杂，但掌握了这个核心概念，你就能：</p>
<ul>
<li>写出更高效的SQL语句</li>
<li>快速定位SQL错误</li>
<li>更好地理解数据库的工作原理</li>
<li>在面试中从容应对相关问题</li>
</ul>
<p>下次写SQL的时候，不妨在心里默念一遍执行顺序，相信你会发现很多之前困惑的问题都迎刃而解了！</p>
<hr>
<p><strong>关注【一只划水的程序猿】，每天分享实用的编程技巧和职场经验！</strong></p>
<p>如果这篇文章对你有帮助，别忘了点赞、收藏、分享给更多的小伙伴！你的支持是我继续创作的动力！</p>
<p>有问题欢迎在评论区留言，我会及时回复大家的疑问。让我们一起在编程的路上越走越远！ 🚀</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-04 09:17">2025-07-04 09:16</span>&nbsp;
<a href="https://www.cnblogs.com/damaoa">大毛啊</a>&nbsp;
阅读(<span id="post_view_count">144</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18964981);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18964981', targetLink: 'https://www.cnblogs.com/damaoa/p/18964981', title: 'MySQL查询执行顺序：一张图看懂SQL是如何工作的' })">举报</a>
</div>
        