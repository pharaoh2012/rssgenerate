
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wngtk/p/18922889" title="发布于 2025-06-10 22:11">
    <span role="heading" aria-level="2">现代 Python 包管理器 `uv`</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="用-uv--python-开发命令行工具">用 uv + Python 开发命令行工具</h2>
<p>当使用 uv 写正规一点的 CLI 应用的时候，还是应该使用</p>
<pre><code class="language-sh">uv init --package [package name]
</code></pre>
<p>因为写一个命令行程序总是要安装的，想分享到 PYPI 也必须要打包。</p>
<p>我都不知道我第一次用 uv 的时候是怎么正确打包，并能使用 uv 安装我开发的程序。当时真是误打误撞的，那时候我根本不知道 pyproject.toml 应该怎么写才能正确打包，更加不知道写一个命令行程序的规范是什么。当时我连 Build Backend 都没有设置，纯粹是运气好。</p>
<h2 id="目录结构">目录结构</h2>
<p>一个 Python 应用，不管是 CLI 工具，还是后端服务，只要是一个想分发给别人用，项目都要有一个规范的目录结构， flat-layout or src-layout。现在比较流行 src-layout，如果没有什么考量就使用 src-layout。</p>
<ul>
<li><a href="https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/" target="_blank" rel="noopener nofollow">src layout vs flat layout - Python Packaging User Guide</a></li>
</ul>
<p>有固定的目录结构之后，一个包（文件夹）里面的<code>__init__.py</code>很重要，构建系统默认是只把有 <code>__init__.py</code>文件的文件夹才当作是一个包。当然 <code>__init__.py</code> 可以没有，没有 <code>__init__.py</code> 的包叫做 namespace package。要打包 namespace package 需要在 <code>pyproject.toml</code>里面给构建系统指出怎么找到你的包。</p>
<p>Python 项目打包的细节我不太清楚，可以看看对应的构建后端的文档，例如 <a href="https://hatch.pypa.io/latest/" target="_blank" rel="noopener nofollow">hatch</a> 的文档。</p>
<h2 id="uv-的使用">uv 的使用</h2>
<h3 id="uv-init">uv init</h3>
<p>uv init 初始化一个项目</p>
<pre><code class="language-sh">uv init example-app
</code></pre>
<p>默认没有使用 <code>--lib</code>， uv 就会使用 <code>--app</code>，相当于</p>
<pre><code class="language-sh">uv init --app example-app
</code></pre>
<pre><code class="language-sh">$ tree example-app
example-app/
├── main.py
├── pyproject.toml
└── README.md
</code></pre>
<p><code>uv init</code> 创建一个 Python 项目，自动建立好 <code>pyproject.toml</code>，<code>README.md</code> 等文件。在这里你可以随意创建 <code>.py</code> 文件，也可以手动自己把代码组织成 package。</p>
<p>运行对应的 py 文件，也称为脚本。</p>
<pre><code class="language-sh">uv run main.py
</code></pre>
<p>uv 不仅仅是一个包管理器，还可以说是 Python 构建系统的前端，还是 Python 环境的管理器。</p>
<p>当你想写一个 Python 脚本做点事情，随便在一个文件夹运行 <code>uv init</code> 帮你创建好虚拟环境并管理依赖。运行脚本就直接使用 <code>uv run script.py</code>。</p>
<h3 id="uv-init---package">uv init --package</h3>
<p>如果是写一个正经的应用，想分发一个包或者分发一个可执行的命令，推荐使用 <code>uv init --package</code>。当然也可以先用 <code>uv init</code> 起步，然后再自己手动创建包。</p>
<pre><code class="language-sh">uv init --package
</code></pre>
<p>这相当于 <code>uv init --app --package</code>。</p>
<p>uv 会使用 src-layout，把代码放在 <code>src/</code> 的 Python 包下，uv 会在 <code>pyproject.toml</code> 中添加一个 <code>[project.scripts]</code> entrypoint。</p>
<p>我们使用 uv init --package 创建一个 example-pkg，我们在这里使用了 <code>--package</code>。</p>
<pre><code class="language-sh">~&gt; uv init --package example-pkg
Initialized project `example-pkg` at `/home/user/example-pkg`
~&gt; tree example-pkg/
example-pkg/
├── pyproject.toml
├── README.md
└── src
    └── example_pkg
        └── __init__.py
2 directories, 3 files
~&gt; cd example-pkg/
</code></pre>
<p><code>--package</code> 告诉 uv，我们希望用 Python 包来组织代码。因为代码放在 <code>src/</code> 的文件夹里面，运行起来不太方便。uv 在 <code>pyproject.toml</code> 中帮我们声明了 <code>[project.scripts]</code>。</p>
<pre><code class="language-toml">[project.scripts]
example-pkg = "example_pkg:main"
</code></pre>
<p><code>[project.scripts]</code> 声明了我们这个项目会有哪些命令，当执行这个 example-pkg 命令的时候调用对应的函数。<code>example_pkg:main</code> 代表 <code>example_pkg</code> 这个包下的 main 函数。</p>
<p>See also:</p>
<ul>
<li><a href="https://packaging.python.org/en/latest/guides/writing-pyproject-toml/" target="_blank" rel="noopener nofollow">Writing your pyproject.toml - Python Packaging User Guide</a></li>
<li><a href="https://docs.astral.sh/uv/concepts/projects/init/#packaged-applications" target="_blank" rel="noopener nofollow">Creating projects | uv</a></li>
<li><a href="https://peps.python.org/pep-0621/" target="_blank" rel="noopener nofollow">PEP 621 – Storing project metadata in pyproject.toml | peps.python.org</a></li>
</ul>
<p>创建一个项目后，为我们生成了一个命令叫做 example-pkg 要运行这个 <code>example-pkg</code> 命令我们有两个方式。</p>
<p>(1) 通过 uv run 来运行我们的 example-pkg。</p>
<pre><code class="language-sh"> ~/example-pkg (master)&gt; uv run example-pkg
Using CPython 3.11.11 interpreter at: /usr/bin/python3.11
Creating virtual environment at: .venv
      Built example-pkg @ file:///home/user/example-pkg
Installed 1 package in 0.75ms
Hello from example-pkg!
</code></pre>
<p>(2) 可以激活 uv 给我们创建好的虚拟环境，再运行我们的 example-pkg，我们就不需要通过 uv run 来运行这个命令了。uv run 的解释见下文。</p>
<pre><code class="language-sh">~/example-pkg (master)&gt; source .venv/bin/activate.fish
(example-pkg) ~/example-pkg (master)&gt; example-pkg
Hello from example-pkg!
</code></pre>
<p><code>.venv</code> 会在首次使用 <code>uv run</code> 自动创建。也可以使用 <code>uv run</code> 创建 <code>venv</code> 虚拟环境。<code>uv sync</code> 更新虚拟环境。</p>
<p>通常克隆下别人的项目后在项目的根目录运行 <code>uv sync</code>，<code>uv</code> 就会下载好需要的依赖并创建虚拟环境。</p>
<p><code>uv init --package</code> 创建项目的时候 uv 给我们创建了一个和项目名字一样的命令。</p>
<p>我们来加一个 <code>hello-pkg</code> 命令。</p>
<pre><code class="language-diff">--- a/pyproject.toml
+++ b/pyproject.toml
@@ -11,6 +11,7 @@ dependencies = []

 [project.scripts]
 example-pkg = "example_pkg:main"
+hello-pkg = "example_pkg:main"

 [build-system]
 requires = ["hatchling"]
</code></pre>
<p>我们运行 <code>hello-pkg</code>，uv 发现 <code>pyproject.toml</code> 更新后自动重新安装了我们的包。这个包会被安装在 <code>.venv</code>。</p>
<pre><code class="language-sh">~/example-pkg (master)&gt; uv run hello-pkg
      Built example-pkg @ file:///home/user/example-pkg
Uninstalled 1 package in 0.81ms
Installed 1 package in 0.67ms
Hello from example-pkg!
</code></pre>
<p>如果你习惯在虚拟环境里面开发，不想每次都运行命令都要使用 <code>uv run</code>，更新 <code>pyproject.toml</code> 后要运行一下 <code>uv sync</code> 更新当前的虚拟环境。</p>
<p>这是你开发的命令程序，你可以把你的程序安装用户的全局。</p>
<pre><code class="language-sh">uv tool install -e .
</code></pre>
<p>这样就不必激活虚拟环境，也不必使用 <code>uv run hello-pkg</code>。</p>
<pre><code class="language-sh">~&gt; hello-pkg
Hello from example-pkg!
</code></pre>
<p><code>-e</code> 代表 editable 安装，意味着你改动代码后是不需要重新安装的。如果你更新了 <code>pyproject.toml</code> 或者其他的改动需要重新安装，你可以运行 <code>uv tool upgrade example-pkg</code>。</p>
<p>editable 安装是 pip 也支持的命令，Python 3.6 就能用。</p>
<h3 id="uv-run"><code>uv run</code></h3>
<p>我的代码可能放在 Python 包里，也可能是一个单独的 .py 脚本，或者是一个脚本没有任何文件扩展名。</p>
<p><code>uv run</code> 确保你运行的命令/脚本是在一个 Python 的环境中。</p>
<p>当你使用 <code>uv init hello-uv-run</code> 创建了一个项目。</p>
<pre><code class="language-sh">~ $ uv init hello-uv-run
Initialized project `hello-uv-run` at `/home/user/hello-uv-run`
~ $ cd hello-uv-run/
~/hello-uv-run (master) $ eza -l
.rw-r--r--  90 user  9 Jun 23:04 main.py
.rw-r--r-- 158 user  9 Jun 23:04 pyproject.toml
.rw-r--r--   0 user  9 Jun 23:04 README.md
</code></pre>
<p>第一次使用 <code>uv run</code>，uv 创建了虚拟环境，uv 会确保你的 main.py 脚本是在创建的虚拟环境里面运行的。这个时候我们的代码就放在一个单独的 .py 脚本文件里面。</p>
<pre><code class="language-sh">$ uv run main.py
Using CPython 3.12.8 interpreter at: /usr/bin/python3.12
Creating virtual environment at: .venv
Hello from hello-uv-run!
</code></pre>
<p>我们给这个项目添加一个名为 typer 的依赖。演示一下如何使用库提供的 CLI 工具。</p>
<pre><code class="language-sh">~/hello-uv-run (master)&gt; uv add typer
Resolved 10 packages in 13ms
Installed 8 packages in 17ms
 + click==8.2.1
 + markdown-it-py==3.0.0
 + mdurl==0.1.2
 + pygments==2.19.1
 + rich==14.0.0
 + shellingham==1.5.4
 + typer==0.16.0
 + typing-extensions==4.14.0
</code></pre>
<p>typer 提供了一个命令行程序 typer。 我们可以使用 typer 来运行我们的 main.py 这个脚本。此时我们没有激活 venv 虚拟环境，运行 <code>uv add</code> 的 <code>typer</code> 命令，要使用 <code>uv run typer</code>。</p>
<pre><code class="language-sh">~/hello-uv-run (master)&gt; cat main.py
def main(name: str):
    print(f"Hello {name} from hello-uv-run!")
~/hello-uv-run (master)&gt; uv run typer main.py run Joe
Hello Joe from hello-uv-run!
</code></pre>
<p>激活 venv 虚拟环境，就可以直接运行 typer 命令。</p>
<pre><code>(hello-uv-run) ~/hello-uv-run (master)&gt; typer main.py run joe
Hello joe from hello-uv-run!
</code></pre>
<p><strong>uv run 运行一个命令或者脚本就和你激活虚拟环境后运行命令或者脚本一样</strong>。</p>
<p>有时候你需要给命令指定参数，为了不让 uv 误以为参数是 <code>uv run</code> 的，你可以这样：</p>
<pre><code class="language-sh">uv run -- python -m src.example
</code></pre>
<p>这样就 <code>-m</code> 就会正常传递给 <code>python</code>。如此常见的命令当然 uv 有直接的支持，<code>uv run -m</code> 运行一个 Python 模块。</p>
<p>下面解释一下前面的 typer 命令。typer 命令行程序的用处是：即便你只有一个 .py 脚本也能实现命令行的自动补全，脚本文件名通常不是一个命令的名字。<code>typer --install-completion</code> 安装自动补全后，使用 <code>typer main.py run</code> 就能获得命令行的自动补全。</p>
<p>下面这个例子来自 Typer 的官网。我们将代码保存到 main.py。</p>
<pre><code class="language-python">import typer

app = typer.Typer()


@app.command()
def hello(name: str):
    print(f"Hello {name}")


@app.command()
def goodbye(name: str, formal: bool = False):
    if formal:
        print(f"Goodbye Ms. {name}. Have a good day.")
    else:
        print(f"Bye {name}!")


if __name__ == "__main__":
    app()
</code></pre>
<p>因为我们需要<em>直接运行 typer 命令才能获得命令行的自动补全</em>，我们有两个办法：(1) 使用 uv tool install typer 安装 typer 到全局。(2) 激活 venv 虚拟环境，因为我们之前已经使用 uv add typer 将 typer 安装到了虚拟环境。</p>
<p>我们在 Shell 里面敲 <code>typer main.py run</code> 然后按 Tab 键就能得到命令行参数的补全了。</p>
<pre><code class="language-sh">~/hello-uv-run (master)&gt; typer main.py run
goodbye  hello
</code></pre>
<p><code>main.py</code> 只是一个脚本，并不是一个包。一个脚本算不上是一个完整的应用（或者项目），<em>Python 被称之为脚本语言，但 Python 能做的不仅仅是脚本，Python 能开发一个完整的应用</em>，JavaScript/Lua 也是。</p>
<p>单纯的脚本，或许只有 Bash 这样的才算吧。毕竟连 JavaScript 都有模块，有构建，有包（npm 包）。</p>
<p>我们可以通过 Shebang，chmod 赋予脚本可执行权限，把脚本名字的 <code>.py</code> 后缀去掉，手动做到一个脚本看起来是一个独立且完整的命令行程序。但是，这不是我们开发 Python 命令行程序的方式，我们常规的方式是创建一个 Python 的包，使用 entry_point 机制提供命令行程序/GUI程序。<code>uv init --package</code> 就是一个示例。</p>
<p>我一直在强调，你应该用包把 Python 代码组织起来。可我总不能写任何一个 Python 代码都创建一个包吧。</p>
<p>比方说你可能想在你的 Python 项目里面写一个小脚本，测试你的想法，试用一下某个库，或者试试开发的包的某一个函数实现对不对，或者在代码仓库中给出使用你的 Python 包的 Python  脚本示例。</p>
<p>运行你项目里的 <code>.py</code> 脚本你只需要使用 <code>uv run script.py</code> 就可以。</p>
<p><code>uv run</code> 后面可以指定的是命令/脚本。如果你的脚本是 <code>hello-uv-run/main.py</code> 你只需要 <code>uv run main.py</code>。如果你的脚本的后缀不是 .py，是没有后缀的。你可以加一个 <code>--script</code> 选项。</p>
<pre><code class="language-sh">uv run --script main
</code></pre>
<p><strong><code>uv run</code> 能自动更新虚拟环境，<code>uv run</code> 能知道你项目的可执行脚本（<code>[project.scripts]</code>），<code>uv run</code> 也能帮你运行你不想放在包里面的脚本，哪怕你不想命名脚本为 <code>.py</code> 结尾的文件</strong>。uv 帮你处理好环境问题，你不需要提前激活虚拟环境，也不需要提前把你开发的包安装到虚拟环境，只要你使用 <code>uv run</code> 来启动你写的脚本/命令就能找到它应该找到的包。</p>
<p>不要忘了前面提到的方法，你还可以这样来指定运行 Python 脚本时给 Python 的选项。例如：</p>
<pre><code class="language-sh">uv run -- python -i main.py
</code></pre>
<p>还是那句话，<strong>你想要代码被分发，你就要把代码放在一个包里面，有 <code>__init__.py</code> 的文件夹才是 Python 的包</strong>。如果一个文件夹里面没有 <code>__init__.py</code>，打包的时候，这个文件夹下的代码就不会被打包，文件夹名字对应的 Python 包也不存在。</p>
<p><strong>如果你的包要提供一个可执行的脚本，就在 <code>[project.scripts]</code> 里面声明一个命令，这个命令对应的是包下的某一个模块的某一个函数</strong>。这似乎是唯一的方式。<em>之前的那种在包之外创建一个脚本调用包是过时的做法</em>。不管你是使用 setup.py 还是 pyproject.toml，现在推荐的做法都是声明一个 entry_points。</p>
<p>我问了 DeepSeek，为什么现在的 pyproject.toml 不支持单独写一个脚本作为命令执行的入口。下面是它的回答。</p>
<blockquote>
<p>现代 Python 项目更倾向于使用&nbsp;<code>entry_points</code>&nbsp;和包内 CLI 代码，因其在兼容性、维护性和工具链支持上的显著优势。</p>
<p>通过&nbsp;<code>setup.py</code>&nbsp;或&nbsp;<code>pyproject.toml</code>&nbsp;的&nbsp;<code>entry_points</code>&nbsp;机制，可以直接将包内的函数注册为命令行工具，无需单独维护脚本文件。</p>
<p>一些老的 setup.py 里面会看到 setup 传一个 scripts 参数，指定一个单独的 python 脚本作为命令行程序的入口，这在现代 python 是不推荐的做法。</p>
</blockquote>
<p>TIPS：</p>
<p>开发的时候希望从环境变量读取 API KEY 或者数据库的连接地址和密码。创建一个 <code>.env</code> 文件，uv run 支持从指定文件读取环境变量。</p>
<pre><code class="language-sh">uv run --env-file .env main.py
</code></pre>
<p>如果你使用的是 Fish shell，你可以通过环境变量设置 uv 默认的 ENV_FILE。</p>
<pre><code class="language-sh">set -Ux UV_ENV_FILE .env
</code></pre>
<h3 id="uv-tool"><code>uv tool</code></h3>
<p>如果你只想临时运行一个由 Python 包提供的命令，你可以使用</p>
<pre><code class="language-sh">uv tool run
</code></pre>
<p><code>uv tool run</code> 是临时安装命令到一个隔离的环境中。<code>uv tool install</code> 可以取代 <code>pipx</code>。</p>
<p>如果你不想激活虚拟环境也不想切换你的工作目录，你就想运行一下本地计算机上你开发的某个 Python 包提供命令。</p>
<pre><code class="language-sh">uv tool run --from &lt;package path&gt; package-command
</code></pre>
<p>是的，这非常有用，尤其是你想运行一个命令，但是又不想安装它。不管这个命令从网上能下载到的，还是在你本地计算机上暂时不安装到全局的。</p>
<p>如果你要使用 pip 这个包管理器安装 cmake/meson，你不应该使用系统自带的 pip，因为这会污染系统的 Python 环境，安装一个独立的应用，应该使用 pipx 而不是 pip。不过现在有 uv 这样的工具，估计也不太会再使用 pipx 了。</p>
<p>你开发的命令行工具可以直接使用 uv tool install 安装，只需指定 git 的 clone 地址。</p>
<pre><code class="language-sh">uv tool install
</code></pre>
<h3 id="uv-workspace">uv workspace</h3>
<p>创建一个 <code>pyproject.toml</code> 表示这个目录是一个 Python 项目。</p>
<pre><code class="language-sh">$ uv init --bare example
Initialized project `example`
</code></pre>
<p>在 example 目录下创建新的 uv 项目都会自动更新 <code>example/pyproject.toml</code>, 一个项目依赖 workspace 的其他项目可以直接使用 uv add projectname 添加，就像这个项目已经放在 PYPI 上一样。</p>
<h2 id="总结">总结</h2>
<p>uv 的 CLI 规范和 Go 有点类似，尤其是 go help 和 uv help。uv 的任何命令有不理解的地方可以查看一下这个命令的 help。</p>
<p>如果希望有一个命令行命令，所有 CLI 逻辑应放在包的模块内（如&nbsp;<code>src/example_pkg/cli.py</code>），通过&nbsp;<code>__init__.py</code>&nbsp;定义包，而非分散的脚本文件。或者所有的 CLI 逻辑单独放在一个包里面（如 <code>src/cli/__init__.py</code>）。</p>
<p><code>uv run</code>​ 自动处理虚拟环境，直接运行脚本或命令。你可以把代码放在包里，也可以不放在包里。</p>
<ul>
<li><code>uv run script.py</code> 运行项目里面的脚本，<code>script.py</code> 在 <code>src/</code> 之外。</li>
<li><code>uv run --script myscript</code> 运行项目里面的脚本没有 <code>.py</code> 后缀</li>
<li><code>uv run -- python -m mymodule</code> 运行虚拟环境的 python 使用 -m 选项，将模块作为脚本运行</li>
<li><code>uv run console-script</code> 运行在 <code>[project.scripts]</code> 中声明的 <code>console-script</code></li>
</ul>
<p>如果你激活了虚拟环境，你就可以把 <code>uv run</code> 去掉了。如果你使用 uv tool 安装 Python 包，就可以不激活运行 <code>console-script</code>。</p>
<p>旧版&nbsp;<code>setup.py</code>&nbsp;中通过&nbsp;<code>scripts=["scripts/myscript.py"]</code>&nbsp;的方式已被淘汰。</p>
<p><strong>你想要代码被分发，你就要把代码放在一个包里面，有 <code>__init__.py</code> 的文件夹才是 Python 的包</strong>。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-10 22:11">2025-06-10 22:11</span>&nbsp;
<a href="https://www.cnblogs.com/wngtk">wngtk</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18922889);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18922889', targetLink: 'https://www.cnblogs.com/wngtk/p/18922889', title: '现代 Python 包管理器 `uv`' })">举报</a>
</div>
        