
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangxincheng/p/18911996" title="发布于 2025-06-05 11:21">
    <span role="heading" aria-level="2">聊一聊 .NET在Linux下的IO多路复用select和epoll</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景">一：背景</h2>
<h3 id="1-讲故事">1. 讲故事</h3>
<p>在windows平台上，相信很多人都知道.NET异步机制是借助了Windows自带的 <code>IO完成端口</code> 实现的异步交互，那在 Linux 下.NET 又是怎么玩的呢？主要还是传统的 select，poll，epoll 的IO多路复用，在 coreclr源代码中我们都能找到它们的影子。</p>
<ol>
<li>select &amp; poll</li>
</ol>
<p>在平台适配层的 <code>pal.cpp</code> 文件中，有这样的一句话。</p>
<pre><code class="language-C#">
#if HAVE_POLL
#include &lt;poll.h&gt;
#else
#include "pal/fakepoll.h"
#endif  // HAVE_POLL

</code></pre>
<p>简而言之就是在不支持 poll 的linux版本中使用 select（fakepoll） 模拟，参考代码如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202506/214741-20250605112043537-1166325015.png" alt="" loading="lazy"></p>
<ol start="2">
<li>epoll</li>
</ol>
<p>同样的在 linux 中你也会发现很多，截图如下：<br>
<img src="https://img2024.cnblogs.com/blog/214741/202506/214741-20250605112043521-642049923.png" alt="" loading="lazy"></p>
<h2 id="二select-io多路复用">二：select IO多路复用</h2>
<h3 id="1-select-解读">1. select 解读</h3>
<p>在没有 select 之前，我们需要手工管理多句柄的收发，在使用select IO多路复用技术之后，这些多句柄管理就由用户转交给linux系统了，这个也可以从核心的 <code>select</code> 函数看出。</p>
<pre><code class="language-C">
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

</code></pre>
<ol>
<li>readfds,writefds,exceptfds</li>
</ol>
<p>这三个字段依次监视着哪些句柄已成可读状态，哪些句柄已成可写状态，哪些句柄已成异常状态，那技术上是如何实现的呢？在libc 中定义了一个 bit 数组，刚好文件句柄<code>fd值</code>作为 bit数组的索引，linux 在内核中只需要扫描 __fds_bits 中哪些位为1 即可找到需要监控的句柄。</p>
<pre><code class="language-C">
/* fd_set for select and pselect.  */
typedef struct
  {
    /* XPG4.2 requires this member name.  Otherwise avoid the name
       from the global namespace.  */
#ifdef __USE_XOPEN
    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)-&gt;fds_bits)
#else
    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)-&gt;__fds_bits)
#endif
  } fd_set;

</code></pre>
<ol start="2">
<li>nfds，timeout</li>
</ol>
<p>为了减少扫描范围，提高程序性能，需要用户指定一个最大的扫描值到 nfds 上。后面的timeout即超时时间。</p>
<h3 id="2-select-的一个小例子">2. select 的一个小例子</h3>
<p>说了再多还不如一个例子有说服力，我们使用 select 机制对 Console 控制台句柄 (STDIN_FILENO) 进行监控，一旦有数据进来立马输出，参考代码如下：</p>
<pre><code class="language-C">
#include &lt;stdio.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;unistd.h&gt;

int main()
{
    fd_set readfds;
    struct timeval timeout;
    char buf[256];

    printf("Enter text (press Ctrl+D to end):\n");

    while (1)
    {
        FD_ZERO(&amp;readfds);
        FD_SET(STDIN_FILENO, &amp;readfds);
        timeout.tv_sec = 5; // 5秒超时
        timeout.tv_usec = 0;

        int ready = select(STDIN_FILENO + 1, &amp;readfds, NULL, NULL, &amp;timeout);

        if (ready == -1)
        {
            perror("select");
            break;
        }
        else if (ready == 0)
        {
            printf("\nTimeout (5秒无输入).\n");
            break;
        }
        else if (FD_ISSET(STDIN_FILENO, &amp;readfds))
        {
            // 使用 fgets 逐行读取
            if (fgets(buf, sizeof(buf), stdin) != NULL)
            {
                printf("You entered: %s", buf); // 输出整行（包含换行符）
            }
            else
            {
                printf("\nEnd of input (Ctrl+D pressed).\n");
                break;
            }
        }
    }

    return 0;
}

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/214741/202506/214741-20250605112043550-1061050524.png" alt="" loading="lazy"></p>
<p>稍微解释下代码逻辑。</p>
<pre><code class="language-C#">
/* Standard file descriptors.  */
#define	STDIN_FILENO	0	/* Standard input.  */
#define	STDOUT_FILENO	1	/* Standard output.  */
#define	STDERR_FILENO	2	/* Standard error output.  */

</code></pre>
<ol>
<li>将 STDIN_FILENO=0 塞入到可读句柄监控 (readfds) 中。</li>
<li>数据进来之后 select 被唤醒,执行后续逻辑。</li>
<li>通过 FD_ISSET 判断 bit=0 的位置(STDIN_FILENO)是否可用，可用的话读取数据。</li>
</ol>
<p>如果大家对 select 底层代码感兴趣，可以看下 linux 的 <code>do_select</code> 简化实现，大量的遍历逻辑(bit)。</p>
<pre><code class="language-C">
static noinline_for_stack int do_select(int n, fd_set_bits *fds, struct timespec64 *end_time)
{
	for (;;) {
		unsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;
		bool can_busy_loop = false;

		inp = fds-&gt;in; outp = fds-&gt;out; exp = fds-&gt;ex;
		rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;

		for (i = 0; i &lt; n; ++rinp, ++routp, ++rexp) {
			in = *inp++; out = *outp++; ex = *exp++;
			all_bits = in | out | ex;

			for (j = 0; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= 1) {
				mask = select_poll_one(i, wait, in, out, bit,busy_flag);
				if ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) {
					res_in |= bit;
					retval++;
					wait-&gt;_qproc = NULL;
				}
				if ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) {
					res_out |= bit;
					retval++;
					wait-&gt;_qproc = NULL;
				}
				if ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) {
					res_ex |= bit;
					retval++;
					wait-&gt;_qproc = NULL;
				}
			}
		}

		if (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE, to, slack))
			timed_out = 1;
	}

	return retval;
}

</code></pre>
<h2 id="三epoll-io多路复用">三：epoll IO多路复用</h2>
<h3 id="1-epoll-解读">1. epoll 解读</h3>
<p>现在主流的软件(Redis,Nigix) 都是采用 epoll，它解决了select低效的遍历，毕竟数组最多支持1024个bit位，一旦句柄过多会影响异步读取的效率。epoll的底层借助了。</p>
<ol>
<li>红黑树：对句柄进行管理，复杂度为 O(logN)。</li>
<li>就绪队列：一旦句柄变得可读或可写，内核会直接将句柄送到就绪队列。</li>
</ol>
<p>libc中使用 <code>epoll_wait</code> 函数监视着就绪队列，一旦有数据立即提取，复杂度 O(1)，其实这个机制和 Windows 的IO完成端口 已经很靠近了，最后配一下参考代码。</p>
<pre><code class="language-C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;

#define MAX_EVENTS 10   // 最大监听事件数
#define TIMEOUT_MS 5000 // epoll_wait 超时时间（毫秒）

int main()
{
    int epoll_fd, nfds;                        // epoll 文件描述符和返回的事件数
    struct epoll_event ev, events[MAX_EVENTS]; // epoll 事件结构体
    char buf[256];

    // 创建 epoll 实例
    epoll_fd = epoll_create1(0);
    if (epoll_fd == -1)
    {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }

    // 配置并添加标准输入到 epoll 监听
    ev.events = EPOLLIN;       // 监听文件描述符的可读事件（输入）
    ev.data.fd = STDIN_FILENO; // 监听标准输入（文件描述符 0）

    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;ev) == -1)
    {
        perror("epoll_ctl: STDIN_FILENO");
        exit(EXIT_FAILURE);
    }

    printf("Enter text line by line (press Ctrl+D to end):\n");

    // 主循环：监听事件
    while (1)
    {
        // 等待事件发生或超时
        nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, TIMEOUT_MS);

        if (nfds == -1)
        {
            perror("epoll_wait");
            break;
        }
        else if (nfds == 0)
        {
            printf("\nTimeout (5秒无输入).\n");
            break;
        }

        // 处理所有触发的事件
        for (int n = 0; n &lt; nfds; ++n)
        {
            if (events[n].data.fd == STDIN_FILENO)
            {
                // 使用 fgets 逐行读取输入
                if (fgets(buf, sizeof(buf), stdin) != NULL)
                {
                    printf("You entered: %s", buf);
                }
                else
                {
                    // 输入结束（用户按下 Ctrl+D）
                    printf("\nEnd of input (Ctrl+D pressed).\n");
                    break;
                }
            }
        }
    }

    close(epoll_fd);
    return 0;
}

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/214741/202506/214741-20250605112043492-649608060.png" alt="" loading="lazy"></p>
<h2 id="四总结">四：总结</h2>
<p>说了这么多，文尾总结下目前主流的 epoll 和 iocp 各自的特点。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>epoll (Linux)</th>
<th>IOCP (Windows)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>模型</strong></td>
<td>事件驱动 (Reactor)</td>
<td>完成端口 (Proactor)</td>
</tr>
<tr>
<td><strong>核心思想</strong></td>
<td>通知可读写事件</td>
<td>通知I/O操作完成</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>高并发网络编程</td>
<td>高并发I/O操作</td>
</tr>
<tr>
<td><strong>编程复杂度</strong></td>
<td>较低</td>
<td>较高</td>
</tr>
<tr>
<td>网络I/O性能</td>
<td>极佳(百万级连接)</td>
<td>优秀</td>
</tr>
<tr>
<td>磁盘I/O支持</td>
<td>有限</td>
<td>完善</td>
</tr>
<tr>
<td>CPU利用率</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td>内存开销</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td><img src="https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_210929020104最新消息优惠促销公众号关注二维码.jpg" width="700" height="300" alt="图片名称" align="center"></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.043875566976851854" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-05 11:21">2025-06-05 11:21</span>&nbsp;
<a href="https://www.cnblogs.com/huangxincheng">一线码农</a>&nbsp;
阅读(<span id="post_view_count">37</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18911996);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18911996', targetLink: 'https://www.cnblogs.com/huangxincheng/p/18911996', title: '聊一聊 .NET在Linux下的IO多路复用select和epoll' })">举报</a>
</div>
        