
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/blbl-blog/p/18873791" title="发布于 2025-05-13 09:56">
    <span role="heading" aria-level="2">王炸！SpringBoot+MCP 让你的系统秒变AI小助手</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="王炸springbootmcp-让你的系统秒变ai小助手">王炸！SpringBoot+MCP 让你的系统秒变AI小助手</h1>
<p>感觉本篇对你有帮助可以关注一下我的<mark>微信公众号（深入浅出谈java）</mark>，会不定期更新知识和面试资料、技巧！！！</p>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202504/2719585-20250424145859162-898697358.png" alt="" loading="lazy"></p>
<h2 id="一mcp-是什么">一、<strong>MCP 是什么？</strong></h2>
<p><strong>MCP（Model Context Protocol）</strong> 官网：<a href="https://modelcontextprotocol.io/introduction" target="_blank" rel="noopener nofollow">Introduction - Model Context Protocol</a></p>
<p><strong>解释：</strong>Model Context Protocol（MCP）是由 Anthropic 推出的开放协议，旨在标准化大型语言模型（LLM）与外部数据源、工具的交互方式。它类似于“AI 领域的 USB-C 接口”，通过统一的通信规范（如 JSON-RPC 2.0）实现跨模型、跨工具的兼容性。</p>
<p><strong>白话解释：</strong>MCP就像 AI 和工具之间的“翻译官”，它制定了一套标准对话规则，让不同 AI 模型（比如 ChatGPT、Claude）都能用同样的方式和你的系统“聊天”。比如以前每个 AI 都要学不同的方言才能操作你的数据库，现在它们只要会说 MCP 这个“普通话”就行！</p>
<p><strong>举个栗子🌰</strong>：。<br>
你做了一个文件管理系统，用 MCP 改造后，不管是 ChatGPT 还是 Claude，都能用同一套指令帮你查文件、删文件，不用为每个 AI 单独开发接口。</p>
<h3 id="二mcp-的核心原理一张图看懂">二、<strong>MCP 的核心原理（一张图看懂）</strong></h3>
<hr>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202505/2719585-20250513094701359-733779749.jpg" alt="" loading="lazy"></p>
<p><strong>解释</strong>：MCP 采用客户端-服务器（C/S）架构，包含以下组件：</p>
<ol>
<li>
<p><strong>MCP Host</strong>：集成 AI 模型的应用（如 IDE、聊天界面），负责发起请求。</p>
</li>
<li>
<p><strong>MCP Client</strong>：协议客户端，管理 Host 与 Server 的通信（如发送请求、解析响应）。</p>
</li>
<li>
<p><strong>MCP Server</strong>：轻量级程序，提供特定功能（如文件读写、数据库查询）。</p>
</li>
<li>
<p><strong>数据源/工具</strong>：本地文件、数据库、第三方 API 等</p>
</li>
</ol>
<p><strong>核心三兄弟</strong>：</p>
<ol>
<li><strong>MCP Client（传话筒）</strong>：负责把 AI 的请求转发给工具，类似快递小哥。</li>
<li><strong>MCP Server（工具管家）</strong>：管理你提供的工具（比如查数据库、读文件）。</li>
<li><strong>工具</strong>：你现有的功能（比如 SpringBoot 里的订单查询接口）。</li>
</ol>
<p><strong>白话解释:</strong></p>
<p>想象 MCP 是个“中间人”，负责协调 AI 和你的系统工具(可以理解为接口之类)之间的对话：</p>
<pre><code class="language-plaintext">用户问AI：“帮我查昨天的订单”  
   ↓  
AI 把问题翻译成 MCP 格式：“调用订单查询工具，时间=昨天”  
   ↓  
MCP 中间人找到对应的工具执行  
   ↓  
工具返回数据，MCP 翻译成自然语言给用户 


---------------------------------------------------------------

用户说话
   │
   ↓
AI 翻译成 MCP 格式
   │
   ↓
SpringBoot 收到请求
   │
   ↓
执行对应的Service方法（比如查订单）
   │
   ↓
返回结果给AI → AI 翻译成人话给用户
</code></pre>
<h3 id="三mcp-能干啥">三、<strong>MCP 能干啥？</strong></h3>
<hr>
<ol>
<li><strong>让AI操作你的系统</strong>
<ul>
<li>比如用户对AI说：“把订单123退货”，AI自动调用你的退款接口。</li>
</ul>
</li>
<li><strong>无缝切换AI模型</strong>
<ul>
<li>今天用 ChatGPT，明天换 Claude，系统接口不用改！</li>
</ul>
</li>
<li><strong>动态扩展功能</strong>
<ul>
<li>新增一个工具（比如短信发送），所有支持的 AI 都能立刻用上。</li>
</ul>
</li>
</ol>
<p><strong>实际场景</strong>：</p>
<ul>
<li>客服机器人自动查订单、退换货</li>
<li>AI 助手自动写周报（读取你的会议记录和邮件）</li>
<li>智能 IDE 自动调接口生成代码</li>
</ul>
<h2 id="四传统方式与mcp-服务-对比图">四、传统方式与MCP 服务 对比图：</h2>
<pre><code class="language-plaintext">传统接口开发流程：
用户请求→ 前端 → 路由分发 → 控制器 → 服务层 → 数据库操作 → 返回DTO-》前端

MCP服务开发流程：
用户自然语言 → MCP协议转换 → 工具路由 → 领域服务 → 数据库操作 → 自然语言生成
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202505/2719585-20250513094803576-1742610067.png" alt="" loading="lazy"></p>
<p><strong>流程步骤说明：</strong></p>
<ol>
<li>
<p>用户请求阶段</p>
<ul>
<li>用户向MCP Client发送自然语言指令："帮我查昨天的订单"</li>
<li>📍MCP Client作用：用户交互终端，负责自然语言处理</li>
</ul>
</li>
<li>
<p>指令翻译阶段</p>
<ul>
<li>
<p>AI将指令转换为MCP标准格式：</p>
<pre><code class="language-json">{
  "action": "order_query",
  "params": {"time": "yesterday"}
}
</code></pre>
</li>
<li>
<p>🔄 协议转换发生在MCP Client内部</p>
</li>
</ul>
</li>
<li>
<p>请求路由阶段</p>
<ul>
<li>MCP Client通过HTTPS将结构化数据发送至MCP Server</li>
<li>🌐 MCP Server作用：中央调度器，验证请求并匹配服务端点</li>
</ul>
</li>
<li>
<p>服务执行阶段</p>
<ul>
<li>MCP Server识别需调用"订单查询工具"，通过RPC调用MCP Host</li>
<li>⚙️ MCP Host作用：微服务执行环境，承载具体业务逻辑实现</li>
</ul>
</li>
<li>
<p>数据处理阶段</p>
<ul>
<li>
<p>订单工具在MCP Host执行SQL查询：</p>
<pre><code class="language-sql">SELECT * FROM orders 
WHERE order_date = CURRENT_DATE - 1;
</code></pre>
</li>
<li>
<p>查询结果经数据清洗后返回JSON格式</p>
</li>
</ul>
</li>
<li>
<p>响应返回阶段</p>
<ul>
<li>MCP Server接收Host返回的原始数据</li>
<li>MCP Client将结构化数据转换为自然语言：<br>
"您昨天共有5笔订单，总金额2380元，最新订单是XX商品..."</li>
</ul>
</li>
</ol>
<h2 id="五改造-springboot-项目的步骤保姆级教程">五、<strong>改造 SpringBoot 项目的步骤（保姆级教程）</strong></h2>
<p>核心步骤：</p>
<ul>
<li>添加MCP 的依赖包</li>
<li>修改配置文件</li>
<li>改造现有接口</li>
<li>注册到MCP服务器</li>
</ul>
<h3 id="1添加依赖">1、添加依赖</h3>
<hr>
<p>由于目前这些依赖还是预览版本，所以在Maven中央仓库中是找不到的，需要我们额外引入仓库地址。</p>
<pre><code class="language-xml">  &lt;!-- Spring AI 核心依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
            &lt;artifactId&gt;spring-ai-core&lt;/artifactId&gt;
            &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- Anthropic 模型支持 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
            &lt;artifactId&gt;spring-ai-anthropic-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- MCP 服务器支持 - WebMVC版本 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
            &lt;artifactId&gt;spring-ai-mcp-server-webmvc-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p><strong>其他仓库配置信息</strong></p>
<pre><code class="language-xml">&lt;repositories&gt;
&nbsp; &nbsp;&nbsp;&lt;repository&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;id&gt;spring-milestones&lt;/id&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;name&gt;Spring Milestones&lt;/name&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;snapshots&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;enabled&gt;false&lt;/enabled&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;/snapshots&gt;
&nbsp; &nbsp;&nbsp;&lt;/repository&gt;
&nbsp; &nbsp;&nbsp;&lt;repository&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;id&gt;spring-snapshots&lt;/id&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;name&gt;Spring Snapshots&lt;/name&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;releases&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;enabled&gt;false&lt;/enabled&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;/releases&gt;
&nbsp; &nbsp;&nbsp;&lt;/repository&gt;
&nbsp; &nbsp;&nbsp;&lt;repository&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;name&gt;Central Portal Snapshots&lt;/name&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;id&gt;central-portal-snapshots&lt;/id&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;url&gt;https://central.sonatype.com/repository/maven-snapshots/&lt;/url&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;releases&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;enabled&gt;false&lt;/enabled&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;/releases&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;snapshots&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;enabled&gt;true&lt;/enabled&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&lt;/snapshots&gt;
&nbsp; &nbsp;&nbsp;&lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<hr>
<h3 id="2项目配置">2、<strong>项目配置</strong></h3>
<hr>
<p>我们的目的是将一个Spring服务改造成MCP服务，所以这里不需要进行客户端的配置，同理，在引入依赖的时候也不用引入客户端的依赖。</p>
<p>Anthropic 旗下强大的 Claude 大语言模型 key 需要在官网申请       官网地址：<a href="https://console.anthropic.com" target="_blank" rel="noopener nofollow">https://console.anthropic.com</a></p>
<pre><code class="language-properties"># Spring AI api-key
spring.ai.anthropic.api-key=这里换成你的api-key

# MCP服务端开启
spring.ai.mcp.server.enabled=true

# MCP服务端配置
spring.ai.mcp.server.name=book-management-server
spring.ai.mcp.server.version=1.0.0
spring.ai.mcp.server.type=SYNC
spring.ai.mcp.server.sse-message-endpoint=/mcp/message
</code></pre>
<hr>
<h3 id="3改造原服务方法">3、改造原服务方法</h3>
<hr>
<p>改造方法有两种：</p>
<ol>
<li><strong>工具配置</strong></li>
<li><strong>函数Bean</strong></li>
</ol>
<h4 id="方法一工具配置"><strong>方法一：工具配置</strong></h4>
<p>工具配置方式在需要改造的实现类对需要改造的方法加上<code>@Tool</code>和<code>@ToolParam</code>注解分别标记方法和参数</p>
<pre><code class="language-java">@Service
@RequiredArgsConstructor
publicclass&nbsp;BookServiceImpl&nbsp;&nbsp;implements&nbsp;BookService&nbsp;{

@Resource
private&nbsp;BookRepository bookRepository;


@Override
@Tool(name =&nbsp;"findBooksByTitle", description =&nbsp;"根据书名模糊查询图书，支持部分标题匹配")
public&nbsp;List&lt;Book&gt;&nbsp;findBooksByTitle(@ToolParam(description =&nbsp;"书名关键词")&nbsp;String title)&nbsp;{
&nbsp; &nbsp;&nbsp;return&nbsp;bookRepository.findByTitleContaining(title);
&nbsp; }

@Override
@Tool(name =&nbsp;"findBooksByAuthor", description =&nbsp;"根据作者精确查询图书")
public&nbsp;List&lt;Book&gt;&nbsp;findBooksByAuthor(@ToolParam(description =&nbsp;"作者姓名")&nbsp;String author)&nbsp;{
&nbsp; &nbsp;&nbsp;return&nbsp;bookRepository.findByAuthor(author);
&nbsp; }

@Override
@Tool(name =&nbsp;"findBooksByCategory", description =&nbsp;"根据图书分类精确查询图书")
public&nbsp;List&lt;Book&gt;&nbsp;findBooksByCategory(@ToolParam(description =&nbsp;"图书分类")String category)&nbsp;{
&nbsp; &nbsp;&nbsp;return&nbsp;bookRepository.findByCategory(category);
&nbsp; }
}
</code></pre>
<p>接着将这个 <strong>BookServiceImpl</strong> 实现类注册到MCP服务器配置上即可。</p>
<pre><code class="language-java">/**
&nbsp;* MCP服务器配置类，负责注册MCP工具
&nbsp;*/
@Configuration
publicclass&nbsp;McpServerConfig&nbsp;{

/**
&nbsp; &nbsp;* 注册工具回调提供者，将BookQueryService中的@Tool方法暴露为MCP工具
&nbsp; &nbsp;*
&nbsp; &nbsp;*&nbsp;@param&nbsp;bookService 图书服务
&nbsp; &nbsp;*&nbsp;@return&nbsp;工具回调提供者
&nbsp; &nbsp;*/
@Bean
public&nbsp;ToolCallbackProvider&nbsp;bookToolCallbackProvider(BookService bookService)&nbsp;{
&nbsp; &nbsp;&nbsp;return&nbsp;MethodToolCallbackProvider.builder()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .toolObjects(bookService)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .build();
&nbsp; }

}
</code></pre>
<p>在<strong>聊天客户端</strong>配置引入注册工具</p>
<pre><code class="language-java">/**
&nbsp;* 聊天客户端配置类
&nbsp;*/
@Configuration
publicclass&nbsp;ChatClientConfig&nbsp;{


@Autowired
private&nbsp;ToolCallbackProvider toolCallbackProvider;

/**
&nbsp; &nbsp;* 配置ChatClient，注册系统指令和工具函数
&nbsp; &nbsp;*/
@Bean
public&nbsp;ChatClient&nbsp;chatClient(ChatClient.Builder builder)&nbsp;{
&nbsp; &nbsp;&nbsp;return&nbsp;builder
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .defaultSystem("你是一个图书管理助手，可以帮助用户查询图书信息。"&nbsp;+
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;"你可以根据书名模糊查询、根据作者查询和根据分类查询图书。"&nbsp;+
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;"回复时，请使用简洁友好的语言，并将图书信息整理为易读的格式。")
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 注册工具方法
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .defaultTools(toolCallbackProvider)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .build();
&nbsp; }
}
</code></pre>
<hr>
<h4 id="方法二函数bean"><strong>方法二：</strong>函数Bean</h4>
<hr>
<p>单独声明一个类将查询方法作为函数Bean导出</p>
<pre><code class="language-java">/**
&nbsp;* 图书查询服务，将查询方法作为函数Bean导出
&nbsp;*/
@Service
publicclass&nbsp;BookQueryService&nbsp;{

@Resource
private&nbsp;BookService bookService;

/**
&nbsp; &nbsp;* 根据书名查询图书的函数Bean
&nbsp; &nbsp;*/
@Bean
public&nbsp;Function&lt;String, List&lt;Book&gt;&gt; findBooksByTitle() {
&nbsp; &nbsp;&nbsp;return&nbsp;title -&gt; bookService.findBooksByTitle(title);
&nbsp; }

/**
&nbsp; &nbsp;* 根据作者查询图书的函数Bean
&nbsp; &nbsp;*/
@Bean
public&nbsp;Function&lt;String, List&lt;Book&gt;&gt; findBooksByAuthor() {
&nbsp; &nbsp;&nbsp;return&nbsp;author -&gt; bookService.findBooksByAuthor(author);
&nbsp; }

/**
&nbsp; &nbsp;* 根据分类查询图书的函数Bean
&nbsp; &nbsp;*/
@Bean
public&nbsp;Function&lt;String, List&lt;Book&gt;&gt; findBooksByCategory() {
&nbsp; &nbsp;&nbsp;return&nbsp;category -&gt; bookService.findBooksByCategory(category);
&nbsp; }

}
</code></pre>
<p>这种方式在定义AI聊天客户端的时候需要显式地声明。</p>
<pre><code class="language-java">/**
&nbsp;* 聊天客户端配置类
&nbsp;*/
@Configuration
publicclass&nbsp;ChatClientConfig&nbsp;{

/**
&nbsp; &nbsp;* 配置ChatClient，注册系统指令和工具函数
&nbsp; &nbsp;*/
@Bean
public&nbsp;ChatClient&nbsp;chatClient(ChatClient.Builder builder)&nbsp;{
&nbsp; &nbsp;&nbsp;return&nbsp;builder
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .defaultSystem("你是一个图书管理助手，可以帮助用户查询图书信息。"&nbsp;+
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;"你可以根据书名模糊查询、根据作者查询和根据分类查询图书。"&nbsp;+
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;"回复时，请使用简洁友好的语言，并将图书信息整理为易读的格式。")
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 注册工具方法，这里使用方法名称来引用Spring上下文中的函数Bean
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .defaultTools(
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;"findBooksByTitle",
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;"findBooksByAuthor",
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;"findBooksByCategory"
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .build();
&nbsp; }
}
</code></pre>
<hr>
<h3 id="4接口测试">4、接口测试</h3>
<hr>
<p>服务开发后，声明一个控制器对外暴露进行调用。</p>
<pre><code class="language-java">@Resource
private&nbsp;ChatClient chatClient;


/**
&nbsp; &nbsp;* 处理聊天请求，使用AI和MCP工具进行响应
&nbsp; &nbsp;*
&nbsp; &nbsp;*&nbsp;@param&nbsp;request 聊天请求
&nbsp; &nbsp;*&nbsp;@return&nbsp;包含AI回复的响应
&nbsp; &nbsp;*/
@PostMapping
public&nbsp;ResponseEntity&lt;ChatResponse&gt;&nbsp;chat(@RequestBody ChatRequest request)&nbsp;{
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp;&nbsp;// 创建用户消息
&nbsp; &nbsp; &nbsp; String userMessage = request.getMessage();

&nbsp; &nbsp; &nbsp;&nbsp;// 使用流式API调用聊天
&nbsp; &nbsp; &nbsp; String content = chatClient.prompt()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .user(userMessage)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .call()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .content();

&nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;ResponseEntity.ok(new&nbsp;ChatResponse(content));
&nbsp; &nbsp; }&nbsp;catch&nbsp;(Exception e) {
&nbsp; &nbsp; &nbsp; e.printStackTrace();
&nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;ResponseEntity.ok(new&nbsp;ChatResponse("处理请求时出错: "&nbsp;+ e.getMessage()));
&nbsp; &nbsp; }
&nbsp; }

}
</code></pre>
<h3 id="5测试">5、测试</h3>
<hr>
<p>通过测试工具进行接口请求</p>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202505/2719585-20250513094925959-157088888.png" alt="" loading="lazy"></p>
<h3 id="注意事项"><strong>注意事项</strong></h3>
<ol>
<li><strong>权限控制</strong>：别让AI随便删数据！可以用 Spring Security 限制敏感操作。</li>
<li><strong>错误处理</strong>：AI 不懂“系统异常”，记得把错误信息转成人话（比如“系统忙，稍后再试”）。</li>
<li><strong>提示词优化</strong>：在 <code>@Tool</code> 的 description 里写清楚功能，AI 才知道什么时候该调用它。</li>
</ol>
<h3 id="总结"><strong>总结</strong></h3>
<p>改造 MCP 就像给你的 SpringBoot 项目装了个“AI万能插座”：</p>
<ul>
<li><strong>省时</strong>：一次开发，所有 AI 都能用</li>
<li><strong>灵活</strong>：加新功能只需暴露接口，不用改 AI 端</li>
<li><strong>智能</strong>：让用户用自然语言操作你的系统</li>
</ul>
<p>赶紧试试，让你的项目秒变 AI 神器吧！</p>
<p>最后文章有啥不对，欢迎大佬在评论区指点！！！<br>
如果感觉对你有帮助就点赞推荐或者关注一下吧！！！</p>
<p><img src="https://img2024.cnblogs.com/blog/2719585/202409/2719585-20240927091023464-1188976011.gif" alt="img" loading="lazy"></p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.18598934782407409" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-13 09:56">2025-05-13 09:56</span>&nbsp;
<a href="https://www.cnblogs.com/blbl-blog">古渡蓝按</a>&nbsp;
阅读(<span id="post_view_count">34</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18873791);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18873791', targetLink: 'https://www.cnblogs.com/blbl-blog/p/18873791', title: '王炸！SpringBoot+MCP 让你的系统秒变AI小助手' })">举报</a>
</div>
	