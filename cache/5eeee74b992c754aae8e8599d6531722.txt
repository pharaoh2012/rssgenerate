
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zwwhnly/p/18820159" title="发布于 2025-04-11 10:40">
    <span role="heading" aria-level="2">Spring RestTemplate使用方法总结</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0.03332548431134259" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-11 13:34">2025-04-11 10:40</span>&nbsp;
<a href="https://www.cnblogs.com/zwwhnly">申城异乡人</a>&nbsp;
阅读(<span id="post_view_count">82</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18820159" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18820159);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18820159', targetLink: 'https://www.cnblogs.com/zwwhnly/p/18820159', title: 'Spring RestTemplate使用方法总结' })">举报</a>
</small>
    <div class="entry">
            <div id="cnblogs_post_description" style="display: none">
        
        Spring RestTemplate使用方法总结。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-引入依赖">1. 引入依赖</h2>
<p>首先，需要确认项目中是否直接或者间接引入过spring-web依赖，如果没有引入过，需要在pom.xml中添加以下代码引入依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
    &lt;version&gt;4.3.24.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="2-发送get请求">2. 发送GET请求</h2>
<p>使用RestTemplate发送GET请求主要有<code>getForObject()</code>和<code>getForEntity()</code>2个方法，每个方法分别提供了3种不同的重载。</p>
<h3 id="21-使用getforobject发送get请求无参数">2.1 使用getForObject发送GET请求(无参数)</h3>
<p>使用<code>getForObject()</code>实现：</p>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

String url = "https://www.example.com/getCurrentEnv";
String response = restTemplate.getForObject(url, String.class);
System.out.println(response);
</code></pre>
<p>假设以上接口返回的报文为：</p>
<pre><code class="language-json">{
    "serverAddress": "www.example.dev.com",
    "env": "dev"
}
</code></pre>
<p>也可以直接解析为自定义的类型：</p>
<pre><code class="language-java">import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class EnvInfo {
    private String serverAddress;

    private String env;
}
</code></pre>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

String url = "https://www.example.com/getCurrentEnv";
EnvInfo response = restTemplate.getForObject(url, EnvInfo.class);
System.out.println(JSON.toJSONString(response));
</code></pre>
<h3 id="22-使用getforentity发送get请求无参数">2.2 使用getForEntity发送GET请求(无参数)</h3>
<p>也可以使用<code>getForEntity()</code>实现和2.1同样的功能，代码如下所示：</p>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

String url = "https://www.example.com/getCurrentEnv";
ResponseEntity&lt;EnvInfo&gt; responseEntity = restTemplate.getForEntity(url, EnvInfo.class);
if (responseEntity.getStatusCode() == HttpStatus.OK) {
    EnvInfo response = responseEntity.getBody();
    System.out.println(JSON.toJSONString(response));
}
</code></pre>
<h3 id="23-使用getforobject发送get请求带参数">2.3 使用getForObject发送GET请求(带参数)</h3>
<p>第一种方法是直接在url上拼接上参数，如下所示：</p>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

String url = "https://www.example.com/getDataList?pageIndex=1&amp;pageSize=20";
EnvInfo response = restTemplate.getForObject(url, EnvInfo.class);
System.out.println(JSON.toJSONString(response));
</code></pre>
<p>第二种方法是使用占位符添加参数，如下所示：</p>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

String url = "https://www.example.com/getDataList?pageIndex={1}&amp;pageSize={2}";
EnvInfo response = restTemplate.getForObject(url, EnvInfo.class, 1, 20);
System.out.println(JSON.toJSONString(response));
</code></pre>
<p>以上代码也可以替换为：</p>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

String url = "https://www.example.com/getDataList?pageIndex={pageIndex}&amp;pageSize={pageSize}";
Map&lt;String, String&gt; uriVariables = new HashMap&lt;&gt;();
uriVariables.put("pageIndex", "1");
uriVariables.put("pageSize", "20");
EnvInfo response = restTemplate.getForObject(url, EnvInfo.class, uriVariables);
System.out.println(JSON.toJSONString(response));
</code></pre>
<p><strong>注意事项：</strong></p>
<p>uriVariables中的key必须和url中的占位符名称一致，否则会抛出异常：</p>
<blockquote>
<p>java.lang.IllegalArgumentException: Map has no value for 'pageIndex'</p>
</blockquote>
<p>第三种方法是使用<code>UriComponentsBuilder</code>添加参数，该种方法相比于前两种方法更加灵活，可以实现动态添加参数，代码如下所示：</p>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

String httpUrl = "https://www.example.com/getDataList";
UriComponentsBuilder uriComponentsBuilder = UriComponentsBuilder.fromHttpUrl(httpUrl);
uriComponentsBuilder.queryParam("pageIndex", 1);
uriComponentsBuilder.queryParam("pageSize", 20);

String url = uriComponentsBuilder.toUriString();
EnvInfo response = restTemplate.getForObject(url, EnvInfo.class);
System.out.println(JSON.toJSONString(response));
</code></pre>
<h3 id="24-使用getforentity发送get请求带参数">2.4 使用getForEntity发送GET请求(带参数)</h3>
<p>也可以使用<code>getForEntity()</code>实现和2.3同样的功能，代码如下所示：</p>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

String httpUrl = "https://www.example.com/getDataList";
UriComponentsBuilder uriComponentsBuilder = UriComponentsBuilder.fromHttpUrl(httpUrl);
uriComponentsBuilder.queryParam("pageIndex", 1);
uriComponentsBuilder.queryParam("pageSize", 20);

String url = uriComponentsBuilder.toUriString();
ResponseEntity&lt;EnvInfo&gt; responseEntity = restTemplate.getForEntity(url, EnvInfo.class);
if (responseEntity.getStatusCode() == HttpStatus.OK) {
    EnvInfo response = responseEntity.getBody();
    System.out.println(JSON.toJSONString(response));
}
</code></pre>
<h3 id="25-getforobject与getforentity的区别">2.5 getForObject与getForEntity的区别</h3>
<p><code>getForEntity()</code>与<code>getForObject()</code>相比，返回值用了<code>ResponseEntity</code>进行封装，可以多获取到以下2种信息：</p>
<ol>
<li>HTTP状态码</li>
<li>Response Headers</li>
</ol>
<p>代码示例：</p>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

String httpUrl = "https://www.example.com/getDataList";
UriComponentsBuilder uriComponentsBuilder = UriComponentsBuilder.fromHttpUrl(httpUrl);
uriComponentsBuilder.queryParam("pageIndex", 1);
uriComponentsBuilder.queryParam("pageSize", 20);

String url = uriComponentsBuilder.toUriString();
ResponseEntity&lt;EnvInfo&gt; responseEntity = restTemplate.getForEntity(url, EnvInfo.class);
System.out.println("statusCode: " + responseEntity.getStatusCode().toString());
System.out.println("statusCodeValue: " + responseEntity.getStatusCodeValue());
responseEntity.getHeaders().forEach((key, values) -&gt; {
    System.out.println(key + ": " + values);
});
</code></pre>
<p>输出结果：</p>
<blockquote>
<p>statusCode: 200<br>
statusCodeValue: 200<br>
Server: [openresty]<br>
Date: [Thu, 10 Apr 2025 05:39:02 GMT]<br>
Content-Type: [application/json]<br>
Transfer-Encoding: [chunked]<br>
Connection: [keep-alive]</p>
</blockquote>
<p>其中Response Headers输出部分和Chrome浏览器Network中的Response Headers是一致的：</p>
<p><img src="https://images.zwwhnly.com/picture/2025/snipaste_20250410_134345.png" alt="" loading="lazy"></p>
<h3 id="26-发送get请求带参数及请求头">2.6 发送GET请求(带参数及请求头)</h3>
<p>一般情况下，请求第三方接口都需要签名、时间戳等请求头，但<code>getForObject()</code>和<code>getForEntity()</code>都不支持，</p>
<p>此时需要使用<code>exchange()</code>方法，代码如下所示：</p>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

String httpUrl = "https://www.example.com/getDataList";
UriComponentsBuilder uriComponentsBuilder = UriComponentsBuilder.fromHttpUrl(httpUrl);
uriComponentsBuilder.queryParam("pageIndex", 1);
uriComponentsBuilder.queryParam("pageSize", 20);

HttpHeaders headers = new HttpHeaders();
headers.set("signature", "3045022100875efcef9eb54626bb0168a6baa7c61265d0001d49243f");
headers.set("timestamp", String.valueOf(System.currentTimeMillis()));

String url = uriComponentsBuilder.toUriString();
ResponseEntity&lt;EnvInfo&gt; responseEntity = restTemplate.exchange(url,
        HttpMethod.GET,
        new HttpEntity&lt;&gt;(headers),
        EnvInfo.class);
if (responseEntity.getStatusCode() == HttpStatus.OK) {
    EnvInfo response = responseEntity.getBody();
    System.out.println(JSON.toJSONString(response));
}
</code></pre>
<h2 id="3-发送post请求">3. 发送POST请求</h2>
<p>使用RestTemplate发送POST请求主要有<code>postForObject()</code>和<code>postForEntity()</code>2个方法，每个方法分别提供了3种不同的重载。</p>
<h3 id="31-发送post请求带参数json方式">3.1 发送POST请求(带参数、json方式)</h3>
<p>使用<code>postForObject()</code>实现：</p>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON_UTF8);

LoginParams loginParams = new LoginParams();
loginParams.setUsername("zhangsan");
loginParams.setPassword("123456");

HttpEntity&lt;LoginParams&gt; request = new HttpEntity&lt;&gt;(loginParams, headers);

String url = "https://www.example.com/login";
String response = restTemplate.postForObject(url, request, String.class);
System.out.println(response);
</code></pre>
<p>LoginParams的定义如下所示：</p>
<pre><code class="language-java">import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class LoginParams {
    private String username;

    private String password;
}
</code></pre>
<p>假设以上接口返回的报文为：</p>
<pre><code class="language-json">{
    "code": 200,
    "expire": "2025-04-11 14:42:22",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NDQzNTM3NDIsImlkZW50aXR5"
}
</code></pre>
<p>也可以直接解析为自定义的类型：</p>
<pre><code class="language-java">import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class LoginResponse {
    private Integer code;

    private String expire;

    private String token;
}
</code></pre>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON_UTF8);

LoginParams loginParams = new LoginParams();
loginParams.setUsername("zhangsan");
loginParams.setPassword("123456");

HttpEntity&lt;LoginParams&gt; request = new HttpEntity&lt;&gt;(loginParams, headers);

String url = "https://www.example.com/login";
LoginResponse response = restTemplate.postForObject(url, request, LoginResponse.class);
System.out.println(JSON.toJSONString(response));
</code></pre>
<p>也可以使用<code>postForEntity()</code>实现同样的功能，代码如下所示：</p>
<pre><code class="language-java">ResponseEntity&lt;LoginResponse&gt; responseEntity = restTemplate.postForEntity(url, request, LoginResponse.class);
if (responseEntity.getStatusCode() == HttpStatus.OK) {
    LoginResponse response = responseEntity.getBody();
    System.out.println(JSON.toJSONString(response));
}
</code></pre>
<h3 id="32-发送post请求带参数form表单方式">3.2 发送POST请求(带参数、form表单方式)</h3>
<p>使用<code>postForObject()</code>实现：</p>
<pre><code class="language-java">RestTemplate restTemplate = new RestTemplate();

HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;();
map.add("username", "zhangsan");
map.add("password", "123456");

HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = new HttpEntity&lt;&gt;(map, headers);

String url = "https://www.example.com/login";
LoginResponse response = restTemplate.postForObject(url, request, LoginResponse.class);
System.out.println(JSON.toJSONString(response));
</code></pre>
<p>也可以使用<code>postForEntity()</code>实现同样的功能，代码如下所示：</p>
<pre><code class="language-java">ResponseEntity&lt;LoginResponse&gt; responseEntity = restTemplate.postForEntity(url, request, LoginResponse.class);
if (responseEntity.getStatusCode() == HttpStatus.OK) {
    LoginResponse response = responseEntity.getBody();
    System.out.println(JSON.toJSONString(response));
}
</code></pre>
<h3 id="33-postforobject与postforentity的区别">3.3 postForObject与postForEntity的区别</h3>
<p><code>postForObject()</code>与<code>postForEntity()</code>的区别，与<code>getForEntity()</code>与<code>getForObject()</code>的区别一样，</p>
<p>返回值用了<code>ResponseEntity</code>进行封装。</p>
<h2 id="4-超时时间设置">4. 超时时间设置</h2>
<p>如果需要自定义HTTP请求的连接超时时间和数据传输超时时间，代码如下所示：</p>
<pre><code class="language-java">import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

@Configuration
public class RestTemplateConfig {
    @Value("${restTemplate.connectTimeout:5000}")
    private int connectTimeout;

    @Value("${restTemplate.readTimeout:10000}")
    private int readTimeout;

    @Bean
    public RestTemplate restTemplate() {
        SimpleClientHttpRequestFactory simpleClientHttpRequestFactory = new SimpleClientHttpRequestFactory();
        simpleClientHttpRequestFactory.setConnectTimeout(connectTimeout);
        simpleClientHttpRequestFactory.setReadTimeout(readTimeout);

        return new RestTemplate(simpleClientHttpRequestFactory);
    }
}
</code></pre>
<blockquote>
<p>文章持续更新，欢迎关注微信公众号「申城异乡人」第一时间阅读！</p>
</blockquote>

</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="zwwhnly" blog-id="121761" post-id="18820159"></vc:categories-tags>
    </ul>
