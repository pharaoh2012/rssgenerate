
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18630871" title="发布于 2024-12-25 17:11">
    <span role="heading" aria-level="2">二叉堆结构和操作详解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在许多应用中，我们需要快速执行一些操作，比如查询和提取数据中的最大值或最小值。举个例子，当我们需要排序学生的考试成绩时，我们可能要频繁地查找和提取最高或最低分。除此之外，这种需求还广泛存在于优先级调度、数据流处理中。</p>
<p>假定我们要解决这样一个问题：有一个集合，每次操作都可能从中<strong>添加数据</strong>，或<strong>取出最大值</strong>，应该怎么做？假如使用暴力，仅使用一个数组来维护，我们就需要经常对数据集进行一次遍历（值是 <span class="math inline">\(O(n)\)</span>）。尽管简单，但如果你需要重复地进行多次这类查询，效率就很低了。这时，二叉堆作为一种高效的数据结构，提供了更好的性能。它能够在 <span class="math inline">\(O(\log n)\)</span> 的时间复杂度内进行最大值或最小值的查询和删除操作，解决了暴力方法中遍历整个数组的问题。</p>
<h2 id="什么是二叉堆">什么是二叉堆？</h2>
<p>二叉堆是一种特殊的二叉树（Binary Tree），对于数来说分为大堆和小堆：</p>
<ul>
<li><strong>大堆 (Max Heap)</strong>: 根节点的值大于其所有子节点的值，且每个子树的根节点也满足这一性质。</li>
<li><strong>小堆 (Min Heap)</strong>: 根节点的值小于其所有子节点的值，且每个子树的根节点也满足这一性质。</li>
</ul>
<p>这种数据结构特别适合频繁进行最大值或最小值查询的场景，他们的用途相反，但实现原理是完全一样的，对于上例的题目来说，当然就要使用大根堆。而下图是一个典型的大根堆：</p>
<pre><code>          50
       /      \
     30        40
    /  \      /  \
  10   20   35   25
</code></pre>
<h2 id="为什么用数组构建二叉堆">为什么用数组构建二叉堆？</h2>
<p>二叉堆通常用一个数组（Array）来实现，而不是链表。这是因为：</p>
<ol>
<li>数组实现可以省去链表中用于存储指针的额外空间。</li>
<li>数组实现访问子节点或父节点更加高效，通过索引计算即可完成。这样一个密集完全的二叉树更适合数组法存储。</li>
</ol>
<p>假如设置根节点是 <span class="math inline">\(0\)</span> 号，节点在第 <span class="math inline">\(i\)</span> 位置，那么其左子节点在第 <span class="math inline">\(2i+1\)</span> 位置，右子节点在 <span class="math inline">\(2i+2\)</span> 位置，父节点在 <span class="math inline">\(\lfloor(i-1)/2\rfloor\)</span>。假如设置根节点是 <span class="math inline">\(1\)</span> 号，节点在第 <span class="math inline">\(i\)</span> 位置，那么其左子节点在第 <span class="math inline">\(2i\)</span> 位置，右子节点在 <span class="math inline">\(2i+1\)</span> 位置，父节点在 <span class="math inline">\(\lfloor i/2\rfloor\)</span>。</p>
<p>建堆时，惯例是直接在原数组上操作，将原数组视为二叉堆，并调整让其符合堆的性质。每次<code>heapify</code>将自身往下都进行比较和调整，保证这一条路径上有序。将每个数据从后往前都进行<code>heapify</code>，就可以使整个数组成为堆。当然，你也可以选择从下向上调整，这是一样的。</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;

void heapify(vector&lt;int&gt;&amp; heap, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left &lt; n &amp;&amp; heap[left] &gt; heap[largest]) {
        largest = left;
    }

    if (right &lt; n &amp;&amp; heap[right] &gt; heap[largest]) {
        largest = right;
    }

    if (largest != i) {
        swap(heap[i], heap[largest]);
        heapify(heap, n, largest);
    }
}

void buildHeap(vector&lt;int&gt;&amp; heap) {
    int n = heap.size();
    for (int i = n / 2 - 1; i &gt;= 0; --i) {
        heapify(heap, n, i);
    }
}
</code></pre>
<p><strong>处理时间复杂度</strong>: <span class="math inline">\(O(n)\)</span>。构建过程需要对每个非叶子节点进行调整，每次调整的最大操作次数取决于堆的高度。这看似是一个 nlog n 的过程。但实际上，通过 heapify 从最后一个非叶节点开始逐层向上调整，总体时间复杂度为 <span class="math inline">\(O(n)\)</span>。虽然每次 heapify 操作的时间复杂度是 <span class="math inline">\(O(\log n)\)</span>，但由于树的高度逐层递减，每层的节点数呈指数下降。因此，整体复杂度是 <span class="math inline">\(O(n)\)</span>，而不是 <span class="math inline">\(O(n \log n)\)</span>。</p>
<h2 id="堆操作插入push和删除pop">堆操作：插入(push)和删除(pop)</h2>
<h3 id="1-建堆-build-heap">1. 建堆 (Build Heap)</h3>
<p>通过从底部到顶部逐层对二叉树进行调整，我们可以快速地将无序数组变为二叉堆。上述代码展示了具体的实现方法。</p>
<h3 id="2-插入操作push">2. 插入操作：Push</h3>
<p>插入新元素时，我们需要将该元素添加到数组尾部，然后通过从他开始，不断向上调整来维护堆的性质：</p>
<pre><code class="language-cpp">void push(vector&lt;int&gt;&amp; heap, int value) {
    heap.push_back(value);
    int i = heap.size() - 1;

    while (i != 0 &amp;&amp; heap[(i - 1) / 2] &lt; heap[i]) {
        swap(heap[i], heap[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
}
</code></pre>
<ul>
<li><strong>处理时间复杂度</strong>: <span class="math inline">\(O(\log n)\)</span>，因为堆的高度为 <span class="math inline">\(\log n\)</span>，最多需要向上调整 <span class="math inline">\(\log n\)</span> 次。</li>
</ul>
<h3 id="3-删除操作pop">3. 删除操作：Pop</h3>
<p>删除堆的根节点时，惯例上，我们保存根节点为需要返回的值后，需要将堆尾元素移动到根节点，移除最后的节点（若不使用 vector 则需要额外的 n 保存数组当前使用的长度），然后通过一次向下调整来恢复堆的性质：</p>
<pre><code class="language-cpp">int pop(vector&lt;int&gt;&amp; heap) {
    if (heap.empty()) return -1; // Error case

    int root = heap[0];
    heap[0] = heap.back();
    heap.pop_back();

    heapify(heap, heap.size(), 0);
    return root;
}
</code></pre>
<p>当然，你也可以从被删节点开始向上调整，最后删除最后节点。</p>
<ul>
<li><strong>处理时间复杂度</strong>: <span class="math inline">\(O(\log n)\)</span>。调整操作涉及沿树向下的路径。</li>
</ul>
<p>由于添加和删除总是在数组尾部进行，树总会保持一颗高密度的完全二叉树形态，以保证树高为 <span class="math inline">\(\log n\)</span> 左右。</p>
<hr>
<h2 id="拓展知识">拓展知识</h2>
<h3 id="1-堆能解决的经典问题">1. 堆能解决的经典问题</h3>
<p>堆在算法设计中有广泛的应用，其功能涵盖了许多经典问题：</p>
<ul>
<li><strong>反悔贪心问题</strong>: 在某些贪心算法中，可以通过堆动态调整选择的结果。</li>
<li><strong>Dijkstra 算法</strong>: 优化单源最短路径算法中维护优先级队列的操作。</li>
<li><strong>Huffman 编码</strong>: 使用最小堆构建最优前缀编码树。</li>
<li><strong>动态中位数问题</strong>: 利用两个堆分别维护较小和较大部分的元素。</li>
<li><strong>多路归并 <span class="math inline">\(k\)</span> 个有序链表</strong>: 利用最小堆在每次操作中快速找到最小的头元素。</li>
</ul>
<h3 id="2-堆的其他变种">2. 堆的其他变种</h3>
<p>二叉堆只是堆的一种，其效率适中，实现简单，但是不支持合并操作。堆的基本思想被拓展成了许多其他高级变种，每种变种适用于特定的场景：</p>
<ul>
<li><strong>斜堆（Skew Heap）</strong>: 实现简单且支持高效合并。</li>
<li><strong>左倾堆（Leftist Heap）</strong>: 通过维护偏斜度加速合并操作。</li>
<li><strong>二项堆（Binomial Heap）</strong>: 由一系列二项树组成，适合合并大规模数据。</li>
<li><strong>斐波那契堆（Fibonacci Heap）</strong>: 用于优化 Dijkstra 等算法中的松弛操作。</li>
<li><strong>配对堆（Pairing Heap）</strong>: 通过简化操作提升实际效率。</li>
<li><strong>优先级搜索队列（Priority Search Queue）</strong>: 扩展了堆对键值对的支持。</li>
</ul>
<h3 id="3-堆与优先队列的关系">3. 堆与优先队列的关系</h3>
<p>优先队列是指可以进行入队和根据优先级出队的队列，而堆是实现典型优先队列的核心数据结构之一。优先队列的关键操作（插入、取最大/最小值）都可以通过堆实现高效的时间复杂度，许多语言内置了堆操作：</p>
<ul>
<li><strong>C++</strong>: 使用 <code>std::priority_queue</code>，默认是大根堆，小根堆需自定义比较器。<pre><code class="language-cpp">#include &lt;queue&gt;
std::priority_queue&lt;int&gt; maxHeap; // 大根堆
std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minHeap; // 小根堆
</code></pre>
</li>
<li><strong>Python</strong>: 使用 <code>heapq</code> 模块，默认是小根堆。<pre><code class="language-python">import heapq
heap = []
heapq.heappush(heap, value)  # 插入
smallest = heapq.heappop(heap)  # 弹出最小值
</code></pre>
</li>
<li><strong>Java</strong>: 使用 <code>PriorityQueue</code>，默认是小根堆。<pre><code class="language-java">PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());
</code></pre>
</li>
<li><strong>Go</strong>: 使用 <code>container/heap</code> 包。<pre><code class="language-go">import "container/heap"
</code></pre>
</li>
</ul>
<p>通过掌握这些实现方式，可以在不同的语言中快速构建适合特定场景的优先队列，实现高效的数据处理。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.031342253181712965" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-25 17:30">2024-12-25 17:11</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">11</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18630871" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18630871);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18630871', targetLink: 'https://www.cnblogs.com/ofnoname/p/18630871', title: '二叉堆结构和操作详解' })">举报</a>
</div>
        