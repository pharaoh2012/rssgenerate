
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fs7744/p/18928323" title="发布于 2025-06-14 14:43">
    <span role="heading" aria-level="2">VKProxy已提供命令行工具，镜像和简单的ui</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><a href="https://github.com/fs7744/VKProxy" target="_blank" rel="noopener nofollow">VKProxy</a> 是使用c#开发的基于 <a href="https://github.com/dotnet/aspnetcore/tree/main/src/Servers/Kestrel" target="_blank" rel="noopener nofollow">Kestrel</a> 实现 L4/L7的代理</p>
<p>经过6个月业余时间偶尔缝缝补补，已经达到能跑的地步了  （感兴趣的同学烦请点个<a href="https://github.com/fs7744/VKProxy" target="_blank" rel="noopener nofollow">github</a>小赞赞呢）</p>
<p>相关使用写了一些简单的文档说明</p>
<ul>
<li><a href="https://fs7744.github.io/VKProxy.Doc/docs/install.md" target="_blank" rel="noopener nofollow">安装</a></li>
<li><a href="https://fs7744.github.io/VKProxy.Doc/docs/extensibility/socks5" target="_blank" rel="noopener nofollow">通过UI站点配置</a></li>
<li><a href="https://fs7744.github.io/VKProxy.Doc/docs/howtolisten" target="_blank" rel="noopener nofollow">不同监听场景如何配置</a></li>
<li><a href="https://fs7744.github.io/VKProxy.Doc/docs/statement" target="_blank" rel="noopener nofollow">如何为HTTP配置路由复杂匹配</a></li>
<li><a href="https://fs7744.github.io/VKProxy.Doc/docs/transforms" target="_blank" rel="noopener nofollow">如何为HTTP配置请求和响应转换</a></li>
</ul>
<p>这里列举一下新增的安装使用方式</p>
<h2 id="dotnet-tool">dotnet tool</h2>
<p>提供简单的命令行工具，可以在本地进行相关测试</p>
<pre><code class="language-shell">dotnet tool install --global VKProxy.Cli
</code></pre>
<p>不过目前只支持 net9.0 (net10 正式发布后会切换制net10)</p>
<p>安装后可以使用如下命令</p>
<pre><code class="language-shell">vkproxy -h
// it will output
--config (-c)       json file config, like /xx/app.json
--socks5            use simple socks5 support
--etcd              etcd address, like http://127.0.0.1:2379
--etcd-prefix       default is /ReverseProxy/
--etcd-delay        delay change config when etcd change, default is 00:00:01
--help (-h)         show all options
View more at https://fs7744.github.io/VKProxy.Doc/docs/introduction.html
</code></pre>
<h4 id="如果使用json文件配置">如果使用json文件配置</h4>
<p>配置项很多，可参考后续<a href="https://fs7744.github.io/VKProxy.Doc/docs/file-config" target="_blank" rel="noopener nofollow">具体配置项说明</a></p>
<p>这里举个例子</p>
<p>创建json文件</p>
<pre><code class="language-json">{
  "ReverseProxy": {
    "Listen": {
      "http": {
        "Protocols": [
          "Http1"
        ],
        "Address": [
          "127.0.0.1:5001"
        ]
      }
    },
    "Routes": {
      "HTTPTEST": {
        "Match": {
          "Hosts": [
            "*com"
          ],
          "Paths": [
            "/ws*"
          ],
          "Statement": "Method = 'GET'"
        },
        "ClusterId": "apidemo",
        "Timeout": "00:10:11"
      }
    },
    "Clusters": {
      "apidemo": {
        "LoadBalancingPolicy": "RoundRobin",
        "HealthCheck": {
          "Active": {
            "Enable": true,
            "Policy": "Http",
            "Path": "/test",
            "Query": "?a=d",
            "Method": "post"
          }
        },
        "Destinations": [
          {
            "Address": "http://127.0.0.1:1104"
          },
          {
            "Address": "https://google.com"
          }
        ]
      }
    }
  }
}
</code></pre>
<p>然后启动</p>
<pre><code class="language-shell">vkproxy -c D:\code\test\proxy\config.json

// 启动后会看到类似如下的内容
info: VKProxy.Server.ReverseProxy[3]
      Listening on: [Key: http,Protocols: HTTP1,EndPoint: 127.0.0.1:5001]
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Production
info: Microsoft.Hosting.Lifetime[0]
      Content root path: D:\code\test\proxy
warn: VKProxy.Server.ReverseProxy[5]
      Active health failed, can not connect socket 127.0.0.1:1104 No connection could be made because the target machine actively refused it. (127.0.0.1:1104).
</code></pre>
<h4 id="使用-etcd-配置">使用 etcd 配置</h4>
<p>在多实例的情况，同一份配置分发就比较麻烦， 这里提供 ui 可以配置etcd + agent 从etcd读取配置 方便大家使用</p>
<p>ui使用可以参考 <a href="https://fs7744.github.io/VKProxy.Doc/docs/ui-config" target="_blank" rel="noopener nofollow">UI配置站点</a></p>
<p>用tool 启动 agent 可以这样使用</p>
<pre><code class="language-shell">vkproxy --etcd http://127.0.0.1:2379 --etcd-prefix /ReverseProxy/

// 启动后会看到类似如下的内容
info: VKProxy.Server.ReverseProxy[3]
      Listening on: [Key: http,Protocols: HTTP1,EndPoint: 127.0.0.1:5001]
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Production
info: Microsoft.Hosting.Lifetime[0]
      Content root path: D:\code\test\proxy
warn: VKProxy.Server.ReverseProxy[5]
      Active health failed, can not connect socket 127.0.0.1:1104 No connection could be made because the target machine actively refused it. (127.0.0.1:1104).
</code></pre>
<h2 id="docker">Docker</h2>
<p>当大家基本代理功能足够时，简化大家使用成本/快速构建的默认已构建镜像</p>
<p>所有的镜像可以在 <a href="https://hub.docker.com/r/vkproxy/agent" target="_blank" rel="noopener nofollow">docker hub vkproxy agent</a> 找到</p>
<p>提供如下环境变量</p>
<ul>
<li>
<p>VKPROXY_CONFIG</p>
<p>json file config, like /xx/app.json</p>
<p>example <code>VKPROXY_CONFIG=/xx/app.json</code></p>
</li>
<li>
<p>VKPROXY_SOCKS5</p>
<p>use simple socks5 support</p>
<p>example <code>VKPROXY_SOCKS5=true</code></p>
</li>
<li>
<p>ETCD_CONNECTION_STRING</p>
<p>etcd address, like <a href="http://127.0.0.1:2379" target="_blank" rel="noopener nofollow">http://127.0.0.1:2379</a></p>
<p>example <code>ETCD_CONNECTION_STRING=http://127.0.0.1:2379</code></p>
</li>
<li>
<p>ETCD_PREFIX</p>
<p>default is /ReverseProxy/</p>
<p>example <code>ETCD_PREFIX=/ReverseProxy/</code></p>
</li>
<li>
<p>ETCD_DELAY</p>
<p>delay change config when etcd change, default is 00:00:01</p>
<p>example <code>ETCD_DELAY=00:00:01</code></p>
</li>
</ul>
<h4 id="如果使用json文件配置-1">如果使用json文件配置</h4>
<p>配置项很多，可参考后续<a href="https://fs7744.github.io/VKProxy.Doc/docs/file-config" target="_blank" rel="noopener nofollow">具体配置项说明</a></p>
<p>这里举个例子</p>
<p>创建json文件</p>
<pre><code class="language-json">{
  "ReverseProxy": {
    "Listen": {
      "http": {
        "Protocols": [
          "Http1"
        ],
        "Address": [
          "127.0.0.1:5001"
        ]
      }
    },
    "Routes": {
      "HTTPTEST": {
        "Match": {
          "Hosts": [
            "*com"
          ],
          "Paths": [
            "/ws*"
          ],
          "Statement": "Method = 'GET'"
        },
        "ClusterId": "apidemo",
        "Timeout": "00:10:11"
      }
    },
    "Clusters": {
      "apidemo": {
        "LoadBalancingPolicy": "RoundRobin",
        "HealthCheck": {
          "Active": {
            "Enable": true,
            "Policy": "Http",
            "Path": "/test",
            "Query": "?a=d",
            "Method": "post"
          }
        },
        "Destinations": [
          {
            "Address": "http://127.0.0.1:1104"
          },
          {
            "Address": "https://google.com"
          }
        ]
      }
    }
  }
}
</code></pre>
<p>然后启动</p>
<pre><code class="language-shell">docker run --rm -v /mnt/d/code/test/proxy:/config -e VKPROXY_CONFIG=/config/config
.json -e ETCD_CONNECTION_STRING= --network host a.newegg.org/docker-hub-remote/vkproxy/agent:0.0.0.6

// 启动后会看到类似如下的内容
info: VKProxy.Server.ReverseProxy[3]
      Listening on: [Key: http,Protocols: HTTP1,EndPoint: 127.0.0.1:5001]
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Production
info: Microsoft.Hosting.Lifetime[0]
      Content root path: /app
warn: VKProxy.Server.ReverseProxy[5]
      Active health failed, can not connect socket [2404:6800:4012:7::200e]:443 Network is unreachable ([2404:6800:4012:7::200e]:443).
warn: VKProxy.Server.ReverseProxy[5]
      Active health failed, can not connect socket 127.0.0.1:1104 Connection refused (127.0.0.1:1104).
</code></pre>
<h4 id="使用-etcd-配置-1">使用 etcd 配置</h4>
<p>在多实例的情况，同一份配置分发就比较麻烦， 这里提供 ui 可以配置etcd + agent 从etcd读取配置 方便大家使用</p>
<p>ui使用可以参考 <a href="https://fs7744.github.io/VKProxy.Doc/docs/ui-config" target="_blank" rel="noopener nofollow">UI配置站点</a></p>
<p>用 docker 启动 agent 可以这样使用</p>
<pre><code class="language-shell">docker run --rm -e ETCD_CONNECTION_STRING=http://127.0.0.1:2379 --network host vkproxy/agent:0.0.0.6

// 启动后会看到类似如下的内容
info: VKProxy.Server.ReverseProxy[3]
      Listening on: [Key: http,Protocols: HTTP1,EndPoint: 127.0.0.1:5001]
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Production
info: Microsoft.Hosting.Lifetime[0]
      Content root path: D:\code\test\proxy
warn: VKProxy.Server.ReverseProxy[5]
      Active health failed, can not connect socket 127.0.0.1:1104 No connection could be made because the target machine actively refused it. (127.0.0.1:1104).
</code></pre>
<h2 id="通过ui站点配置">通过UI站点配置</h2>
<p>由于文件配置存在一定使用难度，所以也有提供简单的 ui配置站点<a href="https://github.com/fs7744/VKProxy.Web" target="_blank" rel="noopener nofollow">VKProxy.Web</a></p>
<blockquote>
<p>[!WARNING]<br>
由于文件分发会导致大家部署多实例的难度，所以 ui 站点目前只支持 etcd 作为配置源， 同时服务器参数相关无法通过ui站点配置, 请使用文件会程序配置 参见<a href="https://fs7744.github.io/VKProxy.Doc/docs/file-config/options" target="_blank" rel="noopener nofollow">服务器参数</a></p>
</blockquote>
<p>首先启动一个 etcd （可参考 <a href="https://etcd.io/docs/v3.4/op-guide/container/" target="_blank" rel="noopener nofollow">Run etcd clusters inside containers</a>)</p>
<pre><code class="language-shell">export NODE1=127.0.0.1

ETCD_VERSION=v3.4.37
REGISTRY=quay.io/coreos/etcd
# available from v3.2.5
REGISTRY=gcr.io/etcd-development/etcd

docker run \
  -p 2379:2379 \
  -p 2380:2380 \
  --volume=${DATA_DIR}:/etcd-data \
  --name etcd ${REGISTRY}:${ETCD_VERSION} \
  /usr/local/bin/etcd \
  --data-dir=/etcd-data --name node1 \
  --initial-advertise-peer-urls http://${NODE1}:2380 --listen-peer-urls http://0.0.0.0:2380 \
  --advertise-client-urls http://${NODE1}:2379 --listen-client-urls http://0.0.0.0:2379 \
  --initial-cluster node1=http://${NODE1}:2380
</code></pre>
<p>VKProxy agent 启动参考 <a href="https://fs7744.github.io/VKProxy.Doc/docs/install" target="_blank" rel="noopener nofollow">安装</a></p>
<p>UI 所有的镜像可以在 <a href="https://hub.docker.com/r/vkproxy/ui" target="_blank" rel="noopener nofollow">docker hub vkproxy ui</a> 找到</p>
<p>UI docker 部署</p>
<p>参数可以使用如下</p>
<ul>
<li>
<p>ETCD_CONNECTION_STRING</p>
<p>etcd address, like <a href="http://127.0.0.1:2379" target="_blank" rel="noopener nofollow">http://127.0.0.1:2379</a></p>
<p>example <code>ETCD_CONNECTION_STRING=http://127.0.0.1:2379</code></p>
</li>
<li>
<p>ETCD_PREFIX</p>
<p>default is /ReverseProxy/</p>
<p>example <code>ETCD_PREFIX=/ReverseProxy/</code></p>
</li>
<li>
<p>ASPNETCORE_URLS</p>
<p>example <code>ASPNETCORE_URLS=http://*:80</code></p>
</li>
</ul>
<p>举例：</p>
<pre><code class="language-shell">docker run --rm -e ETCD_CONNECTION_STRING=http://127.0.0.1:2379 -e ASPNETCORE_URLS=http://*:8770 --network host vkproxy/ui:0.0.0.7

// 启动后会看到类似输出
warn: Microsoft.AspNetCore.Hosting.Diagnostics[15]
      Overriding HTTP_PORTS '8080' and HTTPS_PORTS ''. Binding to values defined by URLS instead 'http://*:8770'.
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://[::]:8770
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Production
info: Microsoft.Hosting.Lifetime[0]
      Content root path: /app
</code></pre>
<p>然后你就可以在浏览器 访问 <a href="http://127.0.0.1:8770" target="_blank" rel="noopener nofollow">http://127.0.0.1:8770</a> 使用 UI 了</p>
<p><img src="https://fs7744.github.io/VKProxy.Doc/images/webui.jpg" alt="webui.jpg" loading="lazy"></p>
<h2 id="定制化扩展">定制化扩展</h2>
<p>为了方便大家使用 KVProxy 在一些场景，默认功能无法满足时，可以通过自定义扩展实现自己的需求。</p>
<p>同时也是遵照 asp.net core 设计理念，提供了两种扩展方式</p>
<h3 id="中间件管道">中间件管道</h3>
<p>中间件是一种装配到应用管道以处理请求和响应的软件。 每个组件：</p>
<ul>
<li>选择是否将请求传递到管道中的下一个组件。</li>
<li>可在管道中的下一个组件前后执行工作。</li>
</ul>
<p>请求委托用于生成请求管道。 请求委托处理每个 HTTP/tcp/udp 请求。</p>
<p>具体概念可参考<a href="https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0" target="_blank" rel="noopener nofollow">ASP.NET Core 中间件</a></p>
<p><img src="https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/yarp/media/yarp-pipeline.png?view=aspnetcore-9.0" alt="" loading="lazy"></p>
<p>KVProxy 添加了 udp 和 tcp 的特殊中间件</p>
<p>具体参见<a href="https://fs7744.github.io/VKProxy.Doc/docs/extensibility/middleware" target="_blank" rel="noopener nofollow">如何通过中间件定制化功能</a></p>
<p>还有一个socks5的示例以供大家参考<a href="https://fs7744.github.io/VKProxy.Doc/docs/extensibility/socks5" target="_blank" rel="noopener nofollow">如何利用中间件扩展实现socks5</a></p>
<h3 id="特定功能策略增加">特定功能策略增加</h3>
<p>有些特定功能策略比较难以直接使用中间件扩展，这里列举主要部分</p>
<p>（其实由于基于依赖注入，天生解耦，所以内部实现基本都可以覆盖或者添加新实现）</p>
<ul>
<li><a href="https://fs7744.github.io/VKProxy.Doc/docs/extensibility/destinationresolver" target="_blank" rel="noopener nofollow">如何扩展服务发现</a></li>
<li><a href="https://fs7744.github.io/VKProxy.Doc/docs/extensibility/loadbalancingpolicy" target="_blank" rel="noopener nofollow">如何扩展负载均衡策略</a></li>
<li><a href="https://fs7744.github.io/VKProxy.Doc/docs/extensibility/activehealthchecker" target="_blank" rel="noopener nofollow">如何扩展主动健康检查策略</a></li>
<li><a href="https://fs7744.github.io/VKProxy.Doc/docs/extensibility/transform" target="_blank" rel="noopener nofollow">如何扩展HTTP转换器</a></li>
</ul>
<h3 id="reverseproxyfeature">ReverseProxyFeature</h3>
<p>除了两大扩展方式之外，还有一个接口数据在运行时有表明当前路由匹配情况</p>
<pre><code class="language-csharp">public interface IReverseProxyFeature  // http 路由会使用该接口
{
    public RouteConfig Route { get; set; } // 匹配上的路由，如为 null 则未匹配任何路由
    public DestinationState? SelectedDestination { get; set; } // 在选中健康的目标地址后，对应配置会设置在这里
}

public interface IL4ReverseProxyFeature : IReverseProxyFeature // tcp / udp 路由会使用该接口
{
    public bool IsDone { get; set; }  // 表明是否已经处理，当为 true 时，KVProxy 内置L4代理将不会进行代理
    public bool IsSni { get; set; }   // 表明是否为 tcp sni 代理模式
    public SniConfig? SelectedSni { get; set; }  // 为 tcp sni 代理模式时的配置
}
</code></pre>
<p>运行时可通过 feature 获取， 比如</p>
<pre><code class="language-csharp">// http
internal class EchoHttpMiddleware : IMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var f = context.Features.Get&lt;IReverseProxyFeature&gt;();
    }
}

//tcp
internal class EchoTcpProxyMiddleware : ITcpProxyMiddleware
{
    public Task InitAsync(ConnectionContext context, CancellationToken token, TcpDelegate next)
    {
        var f = context.Features.Get&lt;IL4ReverseProxyFeature&gt;();
    }

    public Task&lt;ReadOnlyMemory&lt;byte&gt;&gt; OnRequestAsync(ConnectionContext context, ReadOnlyMemory&lt;byte&gt; source, CancellationToken token, TcpProxyDelegate next)
    {
        var f = context.Features.Get&lt;IL4ReverseProxyFeature&gt;();
    }

    public Task&lt;ReadOnlyMemory&lt;byte&gt;&gt; OnResponseAsync(ConnectionContext context, ReadOnlyMemory&lt;byte&gt; source, CancellationToken token, TcpProxyDelegate next)
    {
        logger.LogInformation($"tcp {DateTime.Now} {context.Features.Get&lt;IL4ReverseProxyFeature&gt;()?.SelectedDestination?.EndPoint.ToString()} reponse size: {source.Length}");
    }
}

//udp
internal class EchoUdpProxyMiddleware : IUdpProxyMiddleware
{
    public Task InitAsync(UdpConnectionContext context, CancellationToken token, UdpDelegate next)
    {
        var f = context.Features.Get&lt;IL4ReverseProxyFeature&gt;();
    }

    public Task&lt;ReadOnlyMemory&lt;byte&gt;&gt; OnRequestAsync(UdpConnectionContext context, ReadOnlyMemory&lt;byte&gt; source, CancellationToken token, UdpProxyDelegate next)
    {
        var f = context.Features.Get&lt;IL4ReverseProxyFeature&gt;();
    }

    public Task&lt;ReadOnlyMemory&lt;byte&gt;&gt; OnResponseAsync(UdpConnectionContext context, ReadOnlyMemory&lt;byte&gt; source, CancellationToken token, UdpProxyDelegate next)
    {
        logger.LogInformation($"udp {DateTime.Now} {context.Features.Get&lt;IL4ReverseProxyFeature&gt;()?.SelectedDestination?.EndPoint.ToString()} reponse size: {source.Length}");
    }
}
</code></pre>
<p>不建议大家直接修改 <code>IReverseProxyFeature</code> 的值，可能会破坏路由</p>
<h2 id="可扩展套接字应用程序框架">可扩展套接字应用程序框架</h2>
<p>除了代理功能外，由于通过反射释放了Kestrel的能力，你也可以把 VKProxy 当成可扩展套接字应用程序框架使用</p>
<p>使用它轻松构建始终连接的套接字应用程序，而无需考虑如何使用套接字，如何维护套接字连接以及套接字如何工作。</p>
<p>(在Kestrel基础上开发，理论可以帮大家节省一些比如直接socket要自己管理 socket之类的事情)</p>
<p>具体可以参考<a href="https://fs7744.github.io/VKProxy.Doc/docs/extensibility/socket" target="_blank" rel="noopener nofollow">可扩展套接字应用程序框架</a></p>
<p>2025年后续大概就继续添加限流 追踪啊之类功能吧</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-14 14:43">2025-06-14 14:43</span>&nbsp;
<a href="https://www.cnblogs.com/fs7744">victor.x.qu</a>&nbsp;
阅读(<span id="post_view_count">47</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18928323);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18928323', targetLink: 'https://www.cnblogs.com/fs7744/p/18928323', title: 'VKProxy已提供命令行工具，镜像和简单的ui' })">举报</a>
</div>
        