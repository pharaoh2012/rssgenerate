
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/CrescentWind/p/18667194" title="发布于 2025-01-12 21:05">
    <span role="heading" aria-level="2">find_package()使用指南</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="关于find_package">关于find_package()</h2>
<p>在使用cmake引用第三方库(比如<code>OpenCV</code>)时，我们总是使用find_package()这个指令来实现对包的查找(比如<code>find_package(OpenCV)</code>)。调用完后就可以使用一些似乎凭空出现的变量如<code>${OpenCV_INCLUDE_DIRS}</code>以及<code>${OpenCV_LIBS}</code>,分别指示了OpenCV库的头文件路径以及各个库文件位置。</p>
<pre><code class="language-cmake">find_package(OpenCV)
include_directories(${OpenCV_INCLUDE_DIRS})
target_link_libraries(${PROJECT_NAME} ${OpenCV_LIBS})
# 这样就可以使用到OpenCV了
</code></pre>
<p>cmake官方文档对find_package()的解释是这样的：</p>
<pre><code class="language-doc">find_package(&lt;PackageName&gt; [version] [EXACT] [QUIET] [MODULE]
             [REQUIRED] [[COMPONENTS] [components...]]
             [OPTIONAL_COMPONENTS components...]
             [REGISTRY_VIEW  (64|32|64_32|32_64|HOST|TARGET|BOTH)]
             [GLOBAL]
             [NO_POLICY_SCOPE]
             [BYPASS_PROVIDER])
</code></pre>
<p>其中<code>[]</code>中的内容表示为可选项。下面我们来解释find_package()是如何工作的。</p>
<h2 id="find_package的工作原理">find_package()的工作原理</h2>
<p>实际上，<code>find_package(&lt;PackageName&gt;)</code>运行时，会去指定路径查找一些名字为</p>
<blockquote>
<p><code>Find&lt;PackageName&gt;.cmake</code></p>
<p><code>&lt;PackageName&gt;Config.cmake</code></p>
<p><code>&lt;lowercasePackageName&gt;-config.cmake</code></p>
<p><code>&lt;lowercasePackageName&gt;-config-version.cmake</code> # 指定版本信息</p>
<p><code>&lt;PackageName&gt;ConfigVersion.cmake</code> # 指定版本信息</p>
</blockquote>
<p>的文件，注意这里的命名格式是非常的固定的，基本都是<code>FindXXX.cmake</code>或者<code>XXXConfig.cmake</code>。这些后缀为<code>.cmake</code>的文件本质上也是使用<code>cmake</code>语言编写的脚本文件，它们会定义一些变量，比如<code>&lt;PackageName&gt;_INCLUDE_DIRS</code>和<code>&lt;PackageName&gt;_LIBS</code>等。当<code>find_package()</code>找到这些文件时，会执行这些文件并将其中定义的变量引入到当前的<code>cmake</code>环境中。</p>
<p>对于搜索这些后缀为<code>.cmake</code>的文件，find_package()采用两种策略来实现</p>
<h2 id="find_package的模块模式">find_package()的模块模式</h2>
<p>这里引用官方文档的解释：</p>
<blockquote>
<p>在这种模式下，CMake 搜索名为<code>Find&lt;PackageName&gt;.cmake</code>的文件，首先在 CMAKE_MODULE_PATH 中列出的位置中查找，然后在 CMake 提供的 Find Modules 中查找安装。如果找到该文件，CMake 将读取并处理该文件。它负责查找包、检查版本并生成任何需要的消息。一些 Find 模块对版本控制提供有限支持或不支持；检查查找模块的文档。</p>
</blockquote>
<p>一般来说，FindXXX.cmake并非为包所提供，大多数包提供的是更为严谨的XXXConfig.cmake,这将在后面说到。也就是说，FindXXX.cmake是一个较为简单的查找模块，大多为用户或者cmake本身自行编写或者提供。查找时，cmake会优先查找cmake环境变量的<code>CMAKE_MODULE_PATH</code>中的路径(这个变量默认为空)，然后再查找cmake自带的Find Modules中的路径，这部分可以使用<code>cmake --help-module-list</code>查看cmake自带的模块列表,可以看到很多FindXXX.cmake文件。</p>
<p>或者对于一些轻量级的包，本身并不提供XXXConfig.cmake或者FindXXX.cmake，而是使用其他包管理器(比如<code>package-config</code>,使用后缀为.pc的文件来管理)，若想使用find_package()引用这些包，就需要自行编写FindXXX.cmake文件。(当然也可以直接使用cmake中的<code>pkg_check_modules()</code>来引用这些包)。下面给出一个FindXXX.cmake的例子，引用的是ffmpeg这个包。</p>
<pre><code class="language-cmake">#FindFFMEPG.cmake
set(FFMPEG_SOURCE /home/ruby/ffmpeg_loc) #指定ffmpeg位置

set(FFMPEG_INCLUDE_DIRS ${FFMPEG_SOURCE}/include)
set(FFMPEG_LIBDIRS_DIRS ${FFMPEG_SOURCE}/lib)

find_library(FFMPEG_AVCODEC_LIBRARY avcodec ${FFMPEG_LIBDIRS_DIR})
find_library(FFMPEG_AVFORMAT_LIBRARY avformat ${FFMPEG_LIBDIRS_DIR})
find_library(FFMPEG_AVUTIL_LIBRARY avutil ${FFMPEG_LIBDIRS_DIR})
find_library(FFMPEG_SWSCALE_LIBRARY swscale ${FFMPEG_LIBDIRS_DIR})
find_library(FFMPEG_SWRESAMPLE_LIBRARY swresample ${FFMPEG_LIBDIRS_DIR})

set(FFMPEG_LIBS ${FFMPEG_AVCODEC_LIBRARY} ${FFMPEG_AVFORMAT_LIBRARY} ${FFMPEG_AVUTIL_LIBRARY} ${FFMPEG_SWSCALE_LIBRARY} ${FFMPEG_SWRESAMPLE_LIBRARY})
</code></pre>
<p>可以看到，我们做到工作无非是设置一些变量，这些变量指向了ffmpeg的头文件路径以及库文件路径，然后使用<code>find_library()</code>来查找对应的库文件。</p>
<p>在使用时，我们可以使用<code>set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} /path/to/FindFFMPEG.cmake)</code>来指定FindFFMPEG.cmake的位置，然后使用<code>find_package(FFMPEG)</code>来引用ffmpeg这个包，然后就可以使用<code>${FFMPEG_INCLUDE_DIRS}</code>和<code>${FFMPEG_LIBS}</code>了。若这个脚本就在当前目录下，可以直接使用<code>set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR})</code>来指定。</p>
<h2 id="find_package的配置模式">find_package()的配置模式</h2>
<p>这里引用官方文档的解释：</p>
<pre><code>在这种模式下，CMake 搜索名为“&lt;lowercasePackageName&gt;-config.cmake”或“&lt;PackageName&gt;Config.cmake”的文件。如果指定了版本详细信息，它还将查找``&lt;lowercasePackageName&gt;-config-version.cmake`` 或``&lt;PackageName&gt;ConfigVersion.cmake``（请参阅:ref:version selection 以了解如何将它们分开使用版本文件）。

在配置模式下，可以为该命令提供一个名称列表，以作为包名称进行搜索。 CMake 搜索配置和版本文件的位置比模块模式复杂得多。

配置和版本文件通常作为包的一部分安装，因此它们往往比查找模块更可靠。它们通常包含包内容的直接知识，因此不需要在配置或版本文件本身中进行搜索或试探。
</code></pre>
<p>对于大多数的第三方包，都会提供<code>XXXConfig.cmake</code>文件，这个文件会定义一些变量，比如<code>XXX_INCLUDE_DIRS</code>和<code>XXX_LIBS/XXX_LIBRARIS</code>等。当模块模式搜索不到时，自动切换到配置模式进行搜索。配置模式的搜索非常繁琐，会尽一切可能去搜索。有一些我也看不懂，这里挑几个比较易懂且常用的来说。</p>
<ul>
<li>在<code>XXX_DIR</code>指定的路径下搜索<code>XXXConfig.cmake</code>文件，<code>XXX_DIR</code>为变量或者环境变量，指定到配置文件所在路径</li>
<li>在<code>CMAKE_PREFIX_PATH</code>指定的路径下搜索<code>XXXConfig.cmake</code>文件</li>
<li>在环境变量<code>PATH</code>下搜索<code>XXXConfig.cmake</code>文件</li>
<li>.....</li>
</ul>
<p>其中，第2和第3种方式提供了一种以前缀路径的方式来指定包的位置，当本级路径搜索不到时，cmake会将本级路径作为前缀去搜索该路径下其他文件中是否有配置文件。匹配规则如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/3147612/202501/3147612-20250112210428005-874539200.png" alt="image" loading="lazy"></p>
<p>其中的<code>&lt;prefix&gt;</code>或者&lt;前缀&gt;即为上述指定的根路径，以根路径为前缀，一直去搜索，直到找到配置文件为止。例如<code>find_package(OpenCV)</code>,其中<code>PATH</code>指定有一个路径为<code>/usr/lib/x86_64-linux-gnu/</code>,查找时便会找</p>
<blockquote>
<ul>
<li>/usr/lib/x86_64-linux-gnu/</li>
<li>/usr/lib/x86_64-linux-gnu/cmake/</li>
<li>/usr/lib/x86_64-linux-gnu/OpenCV(opencv)/</li>
<li>/usr/lib/x86_64-linux-gnu/cmake/OpenCV(opencv)/ ....</li>
</ul>
</blockquote>
<p>等能匹配上的路径，注意，这里的<code>&lt;name&gt;*</code>中的name对应于find_package()中的参数，即<code>find_package(OpenCV)</code>中的<code>OpenCV</code>。但是在作为前缀路径时，name参数不区分大小写，且允许有后缀，如<code>opencv4.5</code>。规则中的<code>|</code>代表选其一,<code>&lt;arch&gt;</code>为系统架构，比如x86,64位架构下就会搜索<code>/lib/x86_64-linux-gnu</code>而<code>arm64</code>架构下则会搜索<code>/lib/aarch64-linux-gnu</code>等。</p>
<h2 id="如何灵活使用">如何灵活使用？</h2>
<p>对于自己写的<code>FindXXX.cmake</code>,在使用时用</p>
<pre><code class="language-cmake">set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR})
# or不在本级目录
set(MY_FINDXXX "path/to/FindXXX.cmake")
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${MY_FINDXXX})
</code></pre>
<p>对于三方库，可以直接用find_package()</p>
<pre><code>find_package(OpenCV)
</code></pre>
<p>倘若找不到，可以用locate命令查找一下，然后手动指定路径</p>
<pre><code class="language-bash">locate OpenCVConfig.cmake
</code></pre>
<p>然后将配置文件所在路径赋值给XXX_DIR</p>
<pre><code class="language-cmake">set(OpenCV_DIR /path/to/opencv)
</code></pre>
<p>对于有多个配置文件的项目(如Qt)，使用<code>CMAKE_PREFIX_PATH</code>来指定路径</p>
<pre><code class="language-cmake">set(CMAKE_PREFIX_PATH /path/to/qt)
</code></pre>
<p>给出一个例子<br>
进入到可以匹配到路径的路径，我这里是<code>/home/ruby/Qt5.14.0/5.14.0/gcc_64</code>,里面的格式为<br>
<img src="https://img2024.cnblogs.com/blog/3147612/202501/3147612-20250112210450380-589772719.png" alt="image" loading="lazy"></p>
<p>也就是最好找到带有lib字眼或者cmake字眼的那一级目录即可，然后将这个路径赋值给<code>CMAKE_PREFIX_PATH</code></p>
<pre><code class="language-cmake">set(CMAKE_PREFIX_PATH /home/ruby/Qt5.14.0/5.14.0/gcc_64)
</code></pre>
<p>即可。使用这个方法可以简便的使用不同版本的Qt，比如我这里有5.14.0和5.15.0两个版本，只需要将<code>CMAKE_PREFIX_PATH</code>指定到对应的路径即可。</p>
<pre><code class="language-cmake">set(CMAKE_PREFIX_PATH /home/ruby/Qt5.15.0/5.15.0/gcc_64)
set(CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH} /home/ruby/Qt5.14.0/5.14.0/gcc_64)
# 注意，这两个路径正常直接find是find不到的，只能加入CMAKE_PREFIX_PATH中

#find_package(Qt5 &lt;version&gt; COMPONENTS Core Widgets REQUIRED), version填版本号，如

find_package(Qt5 5.15.0 COMPONENTS Core Widgets REQUIRED)
# or
find_package(Qt5 5.14.0 COMPONENTS Core Widgets REQUIRED)
可以加入EXACT来精确匹配，当匹配不到时会报错
find_package(Qt5 5.14.0 EXACT COMPONENTS Core Widgets REQUIRED)

</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.38018442496875" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-12 21:05">2025-01-12 21:05</span>&nbsp;
<a href="https://www.cnblogs.com/CrescentWind">凪风sama</a>&nbsp;
阅读(<span id="post_view_count">11</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18667194" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18667194);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18667194', targetLink: 'https://www.cnblogs.com/CrescentWind/p/18667194', title: 'find_package()使用指南' })">举报</a>
</div>
        