
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aslanvon/p/18932096" title="发布于 2025-06-17 00:02">
    <span role="heading" aria-level="2">c++ 模板</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="一什么是模板template">一、什么是模板（Template）</h1>
<p>模板是 C++ 支持的泛型编程机制，可以用来编写与类型无关的代码，实现代码的复用。编译器根据调用时提供的类型参数生成对应版本代码，称为<strong>模板实例化</strong>。</p>
<hr>
<h1 id="二函数模板function-template">二、函数模板（Function Template）</h1>
<ul>
<li>模板函数在<strong>编译时</strong>根据传入参数类型自动生成对应函数代码（实例化），普通函数是<strong>编写时</strong>确定类型。</li>
<li>模板函数可以避免为不同类型写多个重载版本。</li>
</ul>
<h2 id="语法">语法</h2>
<pre><code class="language-cpp">template&lt;typename T&gt;
返回类型 函数名(参数列表) {
    // 使用类型T的代码
}
</code></pre>
<p>或者：</p>
<pre><code class="language-cpp">template&lt;class T&gt;
返回类型 函数名(参数列表) {
    // 使用类型T的代码
}
</code></pre>
<p><code>typename</code> 和 <code>class</code> 在这里是等价的。</p>
<hr>
<h2 id="示例通用交换函数">示例：通用交换函数</h2>
<pre><code class="language-cpp">template&lt;typename T&gt;
void mySwap(T&amp; a, T&amp; b) {
    T temp = a;
    a = b;
    b = temp;
}
</code></pre>
<p>使用：</p>
<pre><code class="language-cpp">int x = 1, y = 2;
mySwap(x, y);  // 自动推导T为int

double a = 1.1, b = 2.2;
mySwap(a, b);  // 自动推导T为double
</code></pre>
<hr>
<h1 id="三类模板class-template">三、类模板（Class Template）</h1>
<h2 id="语法-1">语法</h2>
<pre><code class="language-cpp">template&lt;typename T&gt;
class ClassName {
public:
    T data;
    void print();
};
</code></pre>
<pre><code class="language-cpp">template&lt;typename T&gt;
class MyClass {
public:
    void show();
};

template&lt;typename T&gt;
void MyClass&lt;T&gt;::show() {
    std::cout &lt;&lt; "Show: " &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
}
</code></pre>
<h1 id="四模板参数多样性">四、模板参数多样性</h1>
<p><strong>模板不仅可以是类型，还可以是非类型参数：</strong></p>
<p>非类型参数可以是整数、指针、引用、布尔值等</p>
<pre><code class="language-cpp">template&lt;typename T, int size&gt;
class Array {
    T arr[size];
public:
    void printSize() {
        std::cout &lt;&lt; "Size: " &lt;&lt; size &lt;&lt; std::endl;
    }
};
</code></pre>
<p><strong>也可以是多个参数：</strong></p>
<pre><code class="language-cpp">template&lt;typename T1, typename T2&gt;
void printPair(T1 a, T2 b) {
    std::cout &lt;&lt; a &lt;&lt; " and " &lt;&lt; b &lt;&lt; std::endl;
}

//使用
printPair(1, 2.5);  // 输出：1 and 2.5
</code></pre>
<hr>
<p><strong>也可以是可变参数：</strong></p>
<p>C++11 引入，支持接收<strong>任意数量的参数</strong>。</p>
<pre><code class="language-cpp">//打印所有参数
void print() { }  // 终止递归

template&lt;typename T, typename... Args&gt;
void print(T first, Args... rest) {
    std::cout &lt;&lt; first &lt;&lt; " ";
    print(rest...);  // 递归展开
}

//使用
print(1, 2.5, "Hello");  // 输出：1 2.5 Hello
</code></pre>
<h1 id="五模板特化template-specialization">五、模板特化（Template Specialization）</h1>
<p>有时你希望对特定类型的模板做<strong>定制化处理</strong>。</p>
<h2 id="一类模板特化">一、类模板特化</h2>
<pre><code class="language-cpp">template&lt;typename T&gt;
class Printer {
public:
    void print(const T&amp; value) {
        std::cout &lt;&lt; "General: " &lt;&lt; value &lt;&lt; std::endl;
    }
};

// 对 std::string 类型进行特化
template&lt;&gt;
class Printer&lt;std::string&gt; {
public:
    void print(const std::string&amp; value) {
        std::cout &lt;&lt; "String: \"" &lt;&lt; value &lt;&lt; "\"" &lt;&lt; std::endl;
    }
};
</code></pre>
<p>使用：</p>
<pre><code class="language-cpp">Printer&lt;int&gt; p1;
p1.print(123);  // General: 123

Printer&lt;std::string&gt; p2;
p2.print("Hello");  // String: "Hello"
</code></pre>
<hr>
<h2 id="二函数模板特化">二、函数模板特化</h2>
<pre><code class="language-cpp">template&lt;typename T&gt;
void printValue(T value) {
    std::cout &lt;&lt; "Generic: " &lt;&lt; value &lt;&lt; std::endl;
}

template&lt;&gt;
void printValue&lt;char&gt;(char value) {
    std::cout &lt;&lt; "Char (int): " &lt;&lt; static_cast&lt;int&gt;(value) &lt;&lt; std::endl;
}
</code></pre>
<h2 id="三模板递归用于编译期计算">三、模板递归（用于编译期计算）</h2>
<h3 id="示例计算阶乘编译期">示例：计算阶乘（编译期）</h3>
<pre><code class="language-cpp">template&lt;int N&gt;
struct Factorial {
    static constexpr int value = N * Factorial&lt;N - 1&gt;::value;
};

template&lt;&gt;
struct Factorial&lt;0&gt; {
    static constexpr int value = 1;
};
</code></pre>
<p>使用：</p>
<pre><code class="language-cpp">int result = Factorial&lt;5&gt;::value;  // 120
</code></pre>
<h2 id="四模板默认参数">四、模板默认参数</h2>
<pre><code class="language-cpp">template&lt;typename T = int&gt;
class MyContainer {
    T value;
public:
    MyContainer(T v) : value(v) {}
    void show() { std::cout &lt;&lt; value &lt;&lt; std::endl; }
};
</code></pre>
<p>使用：</p>
<pre><code class="language-cpp">MyContainer&lt;&gt; c1(100);         // 使用默认int
MyContainer&lt;double&gt; c2(3.14);  // 指定double
</code></pre>
<h2 id="五模板别名c11">五、模板别名（C++11）</h2>
<pre><code class="language-cpp">template&lt;typename T&gt;
using Vec = std::vector&lt;T&gt;;

Vec&lt;int&gt; nums;  // 相当于 std::vector&lt;int&gt;
</code></pre>
<hr>
<h2 id="六sfinaesubstitution-failure-is-not-an-error">六、SFINAE（Substitution Failure Is Not An Error）</h2>
<p>允许根据类型特征选择不同实现（高级技巧）</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type
check(T t) {
    std::cout &lt;&lt; "Integral type\n";
}

template&lt;typename T&gt;
typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value&gt;::type
check(T t) {
    std::cout &lt;&lt; "Floating point type\n";
}
</code></pre>
<hr>
<h2 id="七模板中的-decltype-和-auto自动推导">七、模板中的 <code>decltype</code> 和 <code>auto</code>自动推导</h2>
<pre><code class="language-cpp">template&lt;typename T1, typename T2&gt;
auto add(T1 a, T2 b) -&gt; decltype(a + b) {
    return a + b;
}
</code></pre>
<hr>
<h2 id="八小结对照表">八、小结对照表</h2>
<table>
<thead>
<tr>
<th>模板技巧</th>
<th>作用/用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>函数模板</td>
<td>定义通用函数</td>
</tr>
<tr>
<td>类模板</td>
<td>定义通用类</td>
</tr>
<tr>
<td>模板特化</td>
<td>为特定类型提供特殊实现</td>
</tr>
<tr>
<td>非类型参数</td>
<td>指定大小、常量等</td>
</tr>
<tr>
<td>递归模板</td>
<td>编译时递归计算，如阶乘</td>
</tr>
<tr>
<td>可变参数模板</td>
<td>接收任意数量类型参数</td>
</tr>
<tr>
<td>SFINAE</td>
<td>启用/禁用特定模板实例（用于类型选择）</td>
</tr>
<tr>
<td><code>auto</code> + <code>decltype</code></td>
<td>自动推导返回类型</td>
</tr>
</tbody>
</table>
<h1 id="函数模板声明为什么放在头文件中">函数模板声明为什么放在头文件中</h1>
<p>在 C++ 中，<strong>函数模板与类模板</strong>的定义和声明有一个<strong>重要区别</strong>于普通函数或类：<strong>模板的定义必须可见于调用点</strong>，否则编译器在实例化时找不到它的实现。下面是详细解释与示例：</p>
<hr>
<h2 id="普通函数-vs-函数模板">普通函数 vs 函数模板</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>声明和定义可以分离吗？</th>
<th>实现可以放 .cpp 文件吗？</th>
</tr>
</thead>
<tbody>
<tr>
<td>普通函数</td>
<td>✅ 可以</td>
<td>✅ 可以</td>
</tr>
<tr>
<td>函数模板</td>
<td>❌ 不推荐分离</td>
<td>❌ 不建议放在 .cpp 文件</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="为什么函数模板不建议将定义放在-cpp">为什么函数模板不建议将定义放在 <code>.cpp</code>？</h2>
<p>因为模板的代码是在<strong>实例化（即使用）时生成</strong>的，编译器必须<strong>看到定义</strong>才能生成代码。这意味着：</p>
<ul>
<li>模板的定义通常要<strong>放在头文件</strong>中；</li>
<li>如果只写了声明放在头文件，而定义放在 <code>.cpp</code>，链接时会报错 <code>undefined reference</code>。</li>
</ul>
<hr>
<h2 id="正确方式函数模板定义写在头文件">正确方式：函数模板定义写在头文件</h2>
<p><code>my_template.hpp</code></p>
<pre><code class="language-cpp">#ifndef MY_TEMPLATE_HPP
#define MY_TEMPLATE_HPP

#include &lt;iostream&gt;

template&lt;typename T&gt;
void printValue(const T&amp; val) {
    std::cout &lt;&lt; val &lt;&lt; std::endl;
}

#endif
</code></pre>
<p>使用：</p>
<pre><code class="language-cpp">#include "my_template.hpp"

int main() {
    printValue(42);           // 输出：42
    printValue("hello");      // 输出：hello
}
</code></pre>
<hr>
<h2 id="错误方式声明在-hpp定义在-cpp">错误方式：声明在 <code>.hpp</code>，定义在 <code>.cpp</code></h2>
<p><code>my_template.hpp</code></p>
<pre><code class="language-cpp">#ifndef MY_TEMPLATE_HPP
#define MY_TEMPLATE_HPP

template&lt;typename T&gt;
void printValue(const T&amp; val);  // 只有声明

#endif
</code></pre>
<p><code>my_template.cpp</code></p>
<pre><code class="language-cpp">#include "my_template.hpp"
#include &lt;iostream&gt;

template&lt;typename T&gt;
void printValue(const T&amp; val) {
    std::cout &lt;&lt; val &lt;&lt; std::endl;
}
</code></pre>
<p>这段代码编译时不会出错，但<strong>链接时报错</strong>：</p>
<pre><code>undefined reference to `printValue&lt;int&gt;(int const&amp;)`
</code></pre>
<p>因为模板定义在 <code>.cpp</code>，在被 <code>main.cpp</code> 使用时不可见，无法实例化。</p>
<hr>
<h2 id="如果你一定要分离定义和声明">如果你一定要分离定义和声明？</h2>
<p>你可以使用 <strong><code>include "xxx.tpp"</code></strong> 的方式，将定义放在单独文件中，但最终仍然要包含进 <code>.hpp</code> 文件中。</p>
<p><code>my_template.hpp</code></p>
<pre><code class="language-cpp">#ifndef MY_TEMPLATE_HPP
#define MY_TEMPLATE_HPP

template&lt;typename T&gt;
void printValue(const T&amp; val);  // 声明

#include "my_template.tpp"      // 引入定义

#endif
</code></pre>
<p><code>my_template.tpp</code></p>
<pre><code class="language-cpp">template&lt;typename T&gt;
void printValue(const T&amp; val) {
    std::cout &lt;&lt; val &lt;&lt; std::endl;
}
</code></pre>
<p>这种方式是 Boost、Eigen 等大型模板库常用的技巧。</p>
<hr>
<h2 id="类模板也是一样的原则">类模板也是一样的原则</h2>
<p>类模板也必须将定义放在头文件中。</p>
<pre><code class="language-cpp">// MyClass.hpp
template&lt;typename T&gt;
class MyClass {
public:
    void show();
};

template&lt;typename T&gt;
void MyClass&lt;T&gt;::show() {
    std::cout &lt;&lt; "Show" &lt;&lt; std::endl;
}
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p>未经作者同意请勿转载</p>
<p>本文来自博客园作者：<a href="https://www.cnblogs.com/aslanvon/" target="_blank">aixueforever</a>，原文链接：<a href="https://www.cnblogs.com/aslanvon/p/18932096" target="_blank">https://www.cnblogs.com/aslanvon/p/18932096</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-17 00:03">2025-06-17 00:02</span>&nbsp;
<a href="https://www.cnblogs.com/aslanvon">aixueforever</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18932096);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18932096', targetLink: 'https://www.cnblogs.com/aslanvon/p/18932096', title: 'c++ 模板' })">举报</a>
</div>
        