
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/san-mu/p/18677567/sanmu-fed2" title="发布于 2025-01-17 19:29">
    <span role="heading" aria-level="2">Practical Secure Aggregation for Privacy-Preserving Machine Learning</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="1-介绍">1 介绍</h3>
<p>本文是谷歌团队发在CCS2017上的文章，旨在解决联邦学习中安全聚合的问题。</p>
<p><strong>安全聚合</strong>：多方参与者将信息传递给聚合者，聚合者除了知道这个信息的总和不能知道任何一个特定参与者的信息。</p>
<p>在这篇文章中，谷歌将用户手机作为联邦学习的客户端媒介，从而提出了联邦学习下安全聚合需要做到：</p>
<ul>
<li>
<p>通信：希望对参数进行安全处理后相比直接发送参数不超过两倍的通信开销</p>
</li>
<li>
<p>掉线：手机作为客户端可能经常掉线，协议需要抵抗掉线</p>
</li>
</ul>
<p>也提出了联邦学习下安全聚合协议的要求：</p>
<ul>
<li>
<p>能在高维向量下进行运算</p>
</li>
<li>
<p>通信高效，即使每次实例化都有一组新的用户集合</p>
</li>
<li>
<p>对用户掉线鲁棒</p>
</li>
<li>
<p>在以服务器为中介、未经身份验证的网络模型的约束下提供了最强的安全性</p>
</li>
</ul>
<h3 id="2-预备知识">2 预备知识</h3>
<p>本文提出的安全聚合协议需要一定的密码学知识，好消息是文章中给出了这些预备知识。</p>
<h4 id="21-秘密分享">2.1 秘密分享</h4>
<p><span class="math inline">\(\text{Shamir}\)</span>秘密分享：用户将秘密<span class="math inline">\(s\)</span>分成<span class="math inline">\(n\)</span>份，任意<span class="math inline">\(t\)</span>份可以重建秘密，但任意<span class="math inline">\(&lt; t\)</span>份的秘密得不到秘密的任何信息。</p>
<p>首先定义一个有限域<span class="math inline">\(F\)</span>，大小<span class="math inline">\(l&gt;2^k\)</span>，<span class="math inline">\(k\)</span>是安全参数</p>
<p>在有限域中有<span class="math inline">\(n\)</span>个元素可以来表示<span class="math inline">\(1,\cdots,n\)</span>(代表<span class="math inline">\(n\)</span>个参与方)</p>
<ul>
<li>
<p>分享(share)算法：<span class="math inline">\(\text{SS.share}(s,t,U)\rightarrow \lbrace (u,s_u)\rbrace_{u\in U}\)</span>，输入是秘密<span class="math inline">\(s\)</span>，集合<span class="math inline">\(U\)</span>有<span class="math inline">\(n\)</span>个元素表示<span class="math inline">\(n\)</span>个参与方的userID，阈值<span class="math inline">\(t\leq|U|\)</span>。输出是每个参与方得到的秘密分享<span class="math inline">\(s_u\)</span>。</p>
</li>
<li>
<p>重建算法：<span class="math inline">\(\text{SS.recon}(\lbrace (u,s_u)\rbrace_{u\in V},t)\rightarrow s\)</span>，输入阈值<span class="math inline">\(t\)</span>，以及全局<span class="math inline">\(U\)</span>的一个子集<span class="math inline">\(V\)</span>中各个元素的分享<span class="math inline">\(s_u\)</span>，这里要求子集<span class="math inline">\(V\)</span>大小<span class="math inline">\(|v|\ge t\)</span>。输出是秘密<span class="math inline">\(s\)</span>。</p>
</li>
</ul>
<h4 id="22-密钥协商">2.2 密钥协商</h4>
<p>密钥协商由算法元组<span class="math inline">\((\text{KA.param,KA.gen,KA.agree})\)</span>组成。</p>
<ul>
<li>
<p><span class="math inline">\(\text{KA.param}\)</span>：<span class="math inline">\(\text{KA.param(k)}\rightarrow pp\)</span>，由<span class="math inline">\(k\)</span>生成一些公共参数<span class="math inline">\(pp\)</span></p>
</li>
<li>
<p><span class="math inline">\(\text{KA.gen}\)</span>：<span class="math inline">\(\text{KA.gen}(pp)\rightarrow (s_u^{SK},s_u^{PK})\)</span>，用公共参数<span class="math inline">\(pp\)</span>为参与方<span class="math inline">\(u\)</span>生成私钥-公钥对。</p>
</li>
<li>
<p><span class="math inline">\(\text{KA.agree}\)</span>：<span class="math inline">\(\text{KA.agree}(s_u^{SK},s_u^{PK})\rightarrow s_{u,v}\)</span>，允许用户<span class="math inline">\(u\)</span>将其私钥<span class="math inline">\(s_u^{SK}\)</span>和任何用户<span class="math inline">\(v\)</span>的公钥<span class="math inline">\(s_v^{PK}\)</span>组合，获得两者之间私有的共享密钥<span class="math inline">\(s_{u,v}\)</span>。这里不同用户的私钥和公钥都是用相同的<span class="math inline">\(pp\)</span>生成的。</p>
</li>
</ul>
<h4 id="23-密钥协商算法">2.3 <span class="math inline">\(\text{Diffie-Hellman}\)</span>密钥协商算法</h4>
<p>假设用户<span class="math inline">\(u,v\)</span>协商一个密钥：</p>
<p>（1）首先<span class="math inline">\(u,v\)</span>共享一个素数<span class="math inline">\(p\)</span>以及素数的原根<span class="math inline">\(g\)</span>，<span class="math inline">\(g&lt;p\)</span>。这两个数的发送可以不加密。</p>
<p>原根： 对于<span class="math inline">\(i\neq j,1\leq i,j\leq p-1\)</span>，有<span class="math inline">\(g^i \space \text{mod}\space p\neq g^j \space \text{mod}\space p\)</span>，则<span class="math inline">\(g\)</span>为<span class="math inline">\(p\)</span>的原根。</p>
<p>（2）<span class="math inline">\(u\)</span>产生一个私有随机数<span class="math inline">\(A\)</span>，满足<span class="math inline">\(1\leq A \leq p-1\)</span>，计算<span class="math inline">\(X=g^A \space \text{mod}\space p\)</span>并发送给<span class="math inline">\(v\)</span>；同样地，<span class="math inline">\(v\)</span>产生一个私有随机数<span class="math inline">\(B\)</span>，满足<span class="math inline">\(1\leq B\leq p-1\)</span>，计算<span class="math inline">\(Y=g^B \space \text{mod}\space p\)</span>并发送给<span class="math inline">\(v\)</span>。</p>
<p>随后，<span class="math inline">\(u\)</span>可以通过<span class="math inline">\(K_u=Y^A\space \text{mod}\space p\)</span>得到密钥，<span class="math inline">\(v\)</span>可以通过<span class="math inline">\(K_v=X^B\space \text{mod}\space p\)</span>得到密钥。显然，两者的计算结果都是<span class="math inline">\(K=g^{A\times B}\space \text{mod}\space p\)</span></p>
<p>介绍完<span class="math inline">\(\text{Diffie-Hellman}\)</span>，再来看本文具体使用的密钥协商</p>
<p>这里采用的密钥协商与Diffie-Hellman相似：</p>
<ul>
<li>
<p><span class="math inline">\(\text{KA.param}\)</span>：<span class="math inline">\(\text{KA.param(k)}\rightarrow (G^{'},g,q,H)\)</span>，由<span class="math inline">\(k\)</span>生成公共参数：素数阶<span class="math inline">\(q\)</span>的群<span class="math inline">\(G^{'}\)</span>(阶表示群元素个数)，原根<span class="math inline">\(g\)</span>和一个哈希函数<span class="math inline">\(H\)</span>。</p>
</li>
<li>
<p><span class="math inline">\(\text{KA.gen}\)</span>：<span class="math inline">\(\text{KA.gen}(G^{'},g,q,H)\rightarrow (x,g^x)\)</span>，从<span class="math inline">\(Z_q\)</span>采样一个<span class="math inline">\(x\)</span>当做私钥<span class="math inline">\(s_u^{SK}\)</span>，将<span class="math inline">\(g^x\)</span>当做其公钥<span class="math inline">\(s_u^{PK}\)</span>。这里<span class="math inline">\(Z_q\)</span>表示<span class="math inline">\(q\)</span>的整数环，即包含了<span class="math inline">\(0-q-1\)</span>的整数。根据原根的定义，当私钥不同，公钥也不同。</p>
</li>
<li>
<p><span class="math inline">\(\text{KA.agree}\)</span>：<span class="math inline">\(\text{KA.agree}(x_u,g^{x_v})\rightarrow s_{u,v}\)</span>，其中<span class="math inline">\(s_{u,v}=H((g^{x_v})^{x_u})\)</span>。即用户<span class="math inline">\(u\)</span>将其私钥<span class="math inline">\(x_u\)</span>和用户<span class="math inline">\(v\)</span>的公钥<span class="math inline">\(g^{x_v}\)</span>组合，经过哈希得到共享密钥。可以看出，当用户<span class="math inline">\(v\)</span>获得了<span class="math inline">\(u\)</span>的公钥，能计算出一样的共享密钥。</p>
</li>
</ul>
<h4 id="24-认证加密">2.4 认证加密</h4>
<p>由3个算法组成：</p>
<ul>
<li>
<p>密钥生成算法：输出私钥</p>
</li>
<li>
<p>加密算法<span class="math inline">\(\text{AE.enc}\)</span>：输入明文和密钥，输出密文</p>
</li>
<li>
<p>解密算法<span class="math inline">\(\text{AE.dec}\)</span>：输入密文和密钥，输出明文或者特殊的错误标志符</p>
</li>
</ul>
<h4 id="25-签名机制">2.5 签名机制</h4>
<p>本文协议依赖标准UF-CMA安全签名机制。</p>
<ul>
<li>
<p>密钥生成算法：<span class="math inline">\(\text{SIG.gen}(k)\rightarrow (d^{PK},d^{SK})\)</span>，输入安全参数，输出私钥<span class="math inline">\(d^{SK}\)</span>和公钥<span class="math inline">\(d^{PK}\)</span></p>
</li>
<li>
<p>签名算法：<span class="math inline">\(\text{SIG.sign}(d^{SK},m)\rightarrow \sigma\)</span>，输入私钥和信息，输出签名</p>
</li>
<li>
<p>验签算法：<span class="math inline">\(\text{SIG.ver}(d^{PK},m,\sigma)\rightarrow \lbrace0,1\rbrace\)</span>，输入公钥，信息和签名，输出签名是否有效的结果</p>
</li>
</ul>
<h4 id="26-公钥基础设施">2.6 公钥基础设施</h4>
<p>每一方<span class="math inline">\(u\)</span>可以注册<span class="math inline">\((u,d_u^{PK})\)</span>作为身份信息，基础设施能根据身份对消息进行签名，使得其他方可以验证但无法冒充签名。这样做使得攻击方无法冒充诚实方。</p>
<h3 id="3-技术直觉">3 技术直觉</h3>
<p>为了保护用户的数据<span class="math inline">\(x_i\)</span>，最开始的方案是使用一次mask操作，即用户<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>协商得到一个随机数<span class="math inline">\(s_{u,v}\)</span>，然后用该随机数对真实数据<span class="math inline">\(x_i\)</span>进行扰动，得到扰动后的结果<span class="math inline">\(y_i\)</span></p>
<p></p><div class="math display">\[y_u=x_u+\sum\limits_{v\in U:u&lt;v}s_{u,v}-\sum\limits_{v\in U:u&gt;v}s_{v,u}(\text{mod} \space R)
\]</div><p></p><p>各客户端会将扰动后的数据<span class="math inline">\(y_i\)</span>发送给服务器，服务器随后可以进行计算：</p>
<p></p><div class="math display">\[\begin{aligned}
z&amp;=\sum_{u\in U} y_u \\
&amp;=\sum_{u\in U} y_u(x_u+\sum\limits_{v\in U:u&lt;v}s_{u,v}-\sum\limits_{v\in U:u&gt;v}s_{v,u}) \\
&amp;=\sum_{u\in U} x_u (\text{mod} \space R) \\
\end{aligned}
\]</div><p></p><p>我们可以对单次mask举例方便理解。假设有3个客户端，那么依据上述扰动方法，他们交给服务器的数据分别为：</p>
<p></p><div class="math display">\[y_1=x_1+s_{12}+s_{13}
\]</div><p></p><p></p><div class="math display">\[y_2=x_2-s_{12}+s_{23}
\]</div><p></p><p></p><div class="math display">\[y_3=x_3-s_{13}-s_{23}
\]</div><p></p><p>服务器进行求和：<span class="math inline">\(y_1+y_2+y_3=x_1+x_2+x_3\)</span></p>
<p>这个方案可以让服务器在不知道各方数据<span class="math inline">\(x_i\)</span>的情况下得到总和<span class="math inline">\(\sum x_i\)</span>，但有一些问题：</p>
<ul>
<li>
<p>通信开销过大</p>
</li>
<li>
<p>扰动值<span class="math inline">\(s_{uv}\)</span>若通过服务器分发，那么服务器直接得到了扰动值</p>
</li>
<li>
<p>如果有用户掉线，那么扰动值无法在总和中被消去</p>
</li>
</ul>
<h3 id="4-问题解决">4 问题解决</h3>
<h4 id="41-通信开销大">4.1 通信开销大</h4>
<p>直接发送扰动值<span class="math inline">\(s_{uv}\)</span>的通信开销较大，因此可以改变为发送<span class="math inline">\(\text{PRG}\)</span>的种子，让客户端自己使用<span class="math inline">\(\text{PRG}\)</span>对种子进行扩展来得到扰动值。该方法也能回答为什么需要使用一次mask进行扰动而不是直接采用</p>
<p>安全的方法分发数据<span class="math inline">\(x_i\)</span>，因为<span class="math inline">\(x_i\)</span>可能是维数很大的数据。</p>
<h4 id="42-扰动值保护">4.2 扰动值保护</h4>
<p>为了防止服务器直接获得扰动值，采用密钥协商的方法传递。那么各客户端本地持有密钥协商生成的私钥，仅通过服务器传递公钥，服务器无法用公钥获取扰动值。</p>
<h4 id="43-用户掉线">4.3 用户掉线</h4>
<p>我们假设有3个客户端，此时客户端3掉线，那么服务器求和为：</p>
<p></p><div class="math display">\[y_1+y_2=x_1+x_2+s_{13}+s_{23}
\]</div><p></p><p>为了消去上式的多余项，想法是让服务器去客户端1处获得<span class="math inline">\(s_{13}\)</span>，去客户端2处获得<span class="math inline">\(s_{23}\)</span>。然而这时又诞生两个新问题：</p>
<ul>
<li>
<p>若服务器还未获得扰动值，客户端1或3又掉线，那么无法获得扰动值。在真实场景中客户端数量众多，可能每次获取扰动值都有新的掉线用户。我们姑且称这种情况为循环掉线</p>
</li>
<li>
<p>若<span class="math inline">\(y_3\)</span>实际上是延迟到达而非掉线。若在服务器获得扰动值后，<span class="math inline">\(y_3\)</span>延迟到达，那么服务器可以计算<span class="math inline">\(y_3+s_{13}+s_{23}\)</span>求出<span class="math inline">\(x_3\)</span>，即得到了真实数据</p>
</li>
</ul>
<h3 id="5-最终方案">5 最终方案</h3>
<h4 id="51-循环掉线">5.1 循环掉线</h4>
<p>使用上面介绍过的秘密分享方法。当把扰动值<span class="math inline">\(s_{uv}\)</span>当做秘密分享出去，那么只要最后的在线客户端数量大于等于门限值<span class="math inline">\(t\)</span>，就能把扰动值恢复。</p>
<h4 id="52-double-masking">5.2 double-masking</h4>
<p>对每个数据<span class="math inline">\(x_i\)</span>，为其再加入一个掩码<span class="math inline">\(b_i\)</span>，然后再加入之前的扰动值，即：</p>
<p></p><div class="math display">\[\begin{aligned}
y_u=x_u&amp;+\text{PRG}(b_u) \\
&amp;+\sum\limits_{v\in U:u&lt;v} \text{PRG}(s_{u,v}) \\
&amp;-\sum\limits_{v\in U:u&gt;v} \text{PRG}(s_{v,u}) \\
\end{aligned}
\]</div><p></p><p>此时的流程变为：</p>
<ul>
<li>
<p>用户<span class="math inline">\(u\)</span>将扰动<span class="math inline">\(s\)</span>和<span class="math inline">\(b\)</span>都以秘密分享的形式分发出去</p>
</li>
<li>
<p>在恢复的一轮，对于诚实的用户<span class="math inline">\(v\)</span>：若用户<span class="math inline">\(u\)</span>掉线，<span class="math inline">\(v\)</span>会将<span class="math inline">\(s_{uv}\)</span>的share上传给服务器；若<span class="math inline">\(u\)</span>在线，<span class="math inline">\(v\)</span>会将<span class="math inline">\(b_u\)</span>的share上传给服务器</p>
</li>
</ul>
<p>服务器收集了在线用户的<span class="math inline">\(b\)</span>的share，可以减去<span class="math inline">\(\sum \text{PRG}(b_u)\)</span>；收集了掉线用户相关的扰动的share，可以安全地按一次mask掉线那样消去扰动。</p>
<h3 id="6-总流程">6 总流程</h3>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202501/3389949-20250117185700865-416846305.png" width="90%"></div>
<p>注：红色表示应对主动攻击者需要采取的措施</p>
<p>翻译与解读：</p>
<hr>
<p><span class="math inline">\(\text{setup}\)</span>：</p>
<p> - 所有参与方获得安全参数<span class="math inline">\(k\)</span>，用户总数<span class="math inline">\(n\)</span>和阈值<span class="math inline">\(t\)</span>，诚实生成公共参数<span class="math inline">\(pp\leftarrow \text{KA.gen}(k)\)</span>、<span class="math inline">\(m,R\)</span>用来规定输入采样空间<span class="math inline">\(Z_R^m\)</span>，秘密分享的域<span class="math inline">\(F\)</span>。所有参与方都有和server交互的私密通道。</p>
<p> - 用户<span class="math inline">\(u\)</span>从可信第三方处获得签名密钥<span class="math inline">\(d_u^{SK}\)</span>，同时获得对<span class="math inline">\(v\)</span>进行验签的公钥<span class="math inline">\(d_v^{PK}\)</span></p>
<hr>
<p><span class="math inline">\(\text{Round 0}\)</span>：</p>
<p> 用户<span class="math inline">\(u\)</span>：</p>
<p> - 生成两对公私钥<span class="math inline">\((c_u^{PK},c_u^{SK})\leftarrow \text{KA.gen}(pp),(s_u^{PK},s_u^{SK})\leftarrow \text{KA.gen}(pp)\)</span>，并生成签名<span class="math inline">\(\sigma_u \leftarrow \text{SIG.sign}(d_u^{SK},c_u^{PK}||s_u^{PK})\)</span>（<span class="math inline">\(PS\)</span>：<span class="math inline">\(c\)</span>用来做后面加密时的密钥，<span class="math inline">\(s\)</span>用来做扰动值）</p>
<p> - 将<span class="math inline">\((c_u^{PK}||s_u^{PK}||\sigma_u)\)</span>发送给server，移至下轮</p>
<p> server：</p>
<p> - 收集至少<span class="math inline">\(t\)</span>份信息（收集到的集合为<span class="math inline">\(U_1\)</span>）。否则终止</p>
<p> - 对<span class="math inline">\(U_1\)</span>中所有用户广播集合用户信息<span class="math inline">\(\lbrace (v,c_v^{PK},s_v^{PK},\sigma_v)\rbrace_{v\in U_1}\)</span></p>
<hr>
<p><span class="math inline">\(\text{Round 1}\)</span>：</p>
<p> 用户<span class="math inline">\(u\)</span>：</p>
<p> - 收到信息<span class="math inline">\(\lbrace (v,c_v^{PK},s_v^{PK},\sigma_v)\rbrace_{v\in U_1}\)</span>。判断<span class="math inline">\(|U_1|\ge t\)</span>，且所有公钥是不同的，并进行验签<span class="math inline">\(\forall v\in U_1,\text{SIG.ver}(d_v^{PK},c_v^{PK}||s_v^{PK},\sigma_u)=1\)</span></p>
<p> - 从<span class="math inline">\(F\)</span>中随机采样一个<span class="math inline">\(b_u\)</span></p>
<p> - 生成share <span class="math inline">\(s_u^{SK}:\lbrace(v,s_{u,v}^{SK})_{v\in u_1}\rbrace\leftarrow \text{SS.share}(s_u^{SK},t,U_1)\)</span></p>
<p> - 生成share <span class="math inline">\(b_u:\lbrace(v,b_{u,v})_{v\in u_1}\rbrace\leftarrow \text{SS.share}(b_u,t,U_1)\)</span> （<span class="math inline">\(PS\)</span>：这里生成share，但没有直接分发）</p>
<p> - 对每个<span class="math inline">\(v\in U_1 \backslash \lbrace u\rbrace\)</span>，计算<span class="math inline">\(e_{u,v}\leftarrow \text{AE.enc}(\text{KA.agree}(c_u^{SK},c_v^{PK}),u||v||s_{u,v}^{SK}||b_{u,v})\)</span></p>
<p> - 若上述有步骤失败，则终止</p>
<p> - 所有密文<span class="math inline">\(e_{u,v}\)</span>发给服务器</p>
<p> - 存储本轮生成所有的信息，并移至下轮</p>
<p> server：</p>
<p> - 从至少<span class="math inline">\(t\)</span>个用户处收集密文（收集到的集合为<span class="math inline">\(U_2 \subseteq U_1\)</span> ）</p>
<p> - 给<span class="math inline">\(U_2\)</span>中每个用户<span class="math inline">\(u\)</span>发送密文<span class="math inline">\(\lbrace e_{u,v}\rbrace_{v\in U_2}\)</span>，移至下轮</p>
<hr>
<p><span class="math inline">\(\text{Round 2}\)</span>：</p>
<p> 用户<span class="math inline">\(u\)</span>：</p>
<p> - 从服务器处收集并存储密文信息<span class="math inline">\(\lbrace e_{u,v}\rbrace_{v\in U_2}\)</span>，并推断出集合<span class="math inline">\(U_2\)</span>。如果大小小于<span class="math inline">\(t\)</span>，终止</p>
<p> - 对每个<span class="math inline">\(v\in U_2 \backslash \lbrace u\rbrace\)</span>，计算<span class="math inline">\(s_{u,v}\leftarrow \text{KA.agree}(s_u^{SK},s_v^{PK})\)</span>，并使用PRG将这个值扩展为一个随机向量<span class="math inline">\(p_{u,v}=\Delta_{u,v}\cdot \text{PRG}(s_{u,v})\)</span>，其中若<span class="math inline">\(u&gt;v\)</span>则<span class="math inline">\(\Delta_{u,v}=1\)</span>，若<span class="math inline">\(u&lt;v\)</span>则<span class="math inline">\(\Delta_{u,v}=-1\)</span>。且定义<span class="math inline">\(p_{u,u}=0\)</span>（<span class="math inline">\(PS\)</span>：<span class="math inline">\(s_u^{SK}\)</span>是<span class="math inline">\(u\)</span>自己持有的，<span class="math inline">\(s_v^{PK}\)</span>在<span class="math inline">\(\text{Round 1}\)</span>收到，密钥协商生成的<span class="math inline">\(s_{u,v}\)</span>就是扰动值的种子）</p>
<p> - 计算用户自己的私有掩码向量<span class="math inline">\(p_u=\text{PRG}(b_u)\)</span>。然后计算输入<span class="math inline">\(y_u\leftarrow x_u+p_u+\sum_{v\in U_2}p_{u,v}\)</span></p>
<p> - 若上述有步骤失败，则终止。否则将<span class="math inline">\(y_u\)</span>发送给服务器并移至下轮</p>
<p> server：</p>
<p> - 从至少<span class="math inline">\(t\)</span>个用户处收集<span class="math inline">\(y_u\)</span>（收集到的集合为<span class="math inline">\(U_3 \subseteq U_2\)</span> ）。给<span class="math inline">\(U_3\)</span>中每个用户发送<span class="math inline">\(U_3\)</span>用户列表</p>
<hr>
<p><span class="math inline">\(\text{Round 3}\)</span>：</p>
<p> 用户<span class="math inline">\(u\)</span>：</p>
<p> - 从服务器收集用户列表<span class="math inline">\(U_3 \subseteq U_2\)</span>（包括自身），若<span class="math inline">\(U_3\)</span>大小小于<span class="math inline">\(t\)</span>，终止</p>
<p> - 将自己的签名<span class="math inline">\(\sigma_u^{'}\leftarrow \text{SIG.sign}(d_u^{SK},U_3)\)</span>发送给服务器</p>
<p> server：</p>
<p> - 从至少<span class="math inline">\(t\)</span>个用户处收集<span class="math inline">\(\sigma_u^{'}\)</span>（收集到的集合为<span class="math inline">\(U_4\subseteq U_3\)</span>）。给<span class="math inline">\(U_4\)</span>中每个用户发送集合<span class="math inline">\(\lbrace v, \sigma_v^{'}\rbrace_{v\in U_4}\)</span></p>
<hr>
<p><span class="math inline">\(\text{Round 4}\)</span>：</p>
<p> 用户<span class="math inline">\(u\)</span>：</p>
<p> - 从服务器处得到列表<span class="math inline">\(\lbrace v, \sigma_v^{'}\rbrace_{v\in U_4}\)</span>。验证<span class="math inline">\(U_4 \subseteq U_3,|U_4|\ge t,\text{SIG.ver}(d^{PK},U_3,\sigma_v^{'})=1\)</span>。如果验证失败则终止</p>
<p> - 对于用户<span class="math inline">\(v\in U_2 \backslash \lbrace u\rbrace\)</span>， 解密密文得到<span class="math inline">\(v^{'}||u^{'}||s_{v,u}^{SK}||b_{v,u}\leftarrow \text{AE.dec}(\text{KA.agree}(c_u^{SK},c_v^{PK}),e_{v,u})\)</span>，并验证<span class="math inline">\(u=u^{'},v=v^{'}\)</span>（PS：解密后各方才得到share）</p>
<p> - 如果有解密操作失败，终止</p>
<p> - 给服务器发送shares，发送的内容包括：对用户<span class="math inline">\(v\in U_2 \backslash U_3\)</span>发送<span class="math inline">\(s_{v,u}^{SK}\)</span>，对用户<span class="math inline">\(v\in U_3\)</span>发送<span class="math inline">\(b_{v,u}\)</span>（PS：<span class="math inline">\(U_3\)</span>在Round 2被告知，这里可以看出在Round 2结束时必须明确哪些是掉线用户哪些是在线用户）</p>
<p> server：</p>
<p> - 从至少<span class="math inline">\(t\)</span>个用户处收集回复（收集到的集合为<span class="math inline">\(U_5\)</span>）</p>
<p> - 对每个用户<span class="math inline">\(u\in U_2\backslash U_3\)</span>，重建<span class="math inline">\(s_u^{SK}\leftarrow \text{SS.recon}(\lbrace s_{u,v}^{SK}\rbrace_{v\in U_5},t)\)</span>，并使用该值和PRG，来计算和<span class="math inline">\(U_3\)</span>中用户<span class="math inline">\(v\)</span>组成的扰动<span class="math inline">\(p_{v,u}\)</span></p>
<p> - 对每个用户<span class="math inline">\(u\in U_3\)</span>，重建<span class="math inline">\(b_u \leftarrow \text{SS.recon}(\lbrace b_{u,v}\rbrace_{v\in U_5},t)\)</span>，并使用PRG计算<span class="math inline">\(p_u\)</span></p>
<p> - 计算输出<span class="math inline">\(z=\sum_{u\in {U_3}}x_u=\sum_{u\in {U_3}}y_u-\sum_{u\in {U_3}}p_u+\sum_{u\in {U_3},v\in U_2 \backslash U_3}p_{v,u}\)</span></p>
<hr>
<p><strong>原文链接：</strong><a href="https://dl.acm.org/doi/10.1145/3133956.3133982" target="_blank" rel="noopener nofollow">https://dl.acm.org/doi/10.1145/3133956.3133982</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.36331897339583336" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-17 19:31">2025-01-17 19:29</span>&nbsp;
<a href="https://www.cnblogs.com/san-mu">叁沐</a>&nbsp;
阅读(<span id="post_view_count">2</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18677567" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18677567);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18677567', targetLink: 'https://www.cnblogs.com/san-mu/p/18677567/sanmu-fed2', title: 'Practical Secure Aggregation for Privacy-Preserving Machine Learning' })">举报</a>
</div>
        