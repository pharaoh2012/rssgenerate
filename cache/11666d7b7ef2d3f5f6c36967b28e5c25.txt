
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/somefuture/p/18674659" title="发布于 2025-01-16 17:23">
    <span role="heading" aria-level="2">RSA的原理和简单实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>RSA加密是一种非对称加密，原理是：</p>
<ul>
<li>使⽤算法可以⽣成两把钥匙 A 和 B</li>
<li>使⽤ A 加密的信息，使⽤ B 可以解开</li>
<li>使⽤ B 加密的信息，使⽤ A 可以解开</li>
</ul>
<p>⽇常使⽤中，我们把⼀把作为公钥公开发布。⼀把作为私钥，⾃⼰保留。这样，任何⼈都可以使⽤我们的公钥加密信息发给我们，我们则可以使⽤⾃⼰的私钥解开。</p>
<p>只要把私钥保存好，这个通信系统就⾮常安全。</p>
<h1 id="数学基础">数学基础</h1>
<h2 id="1-欧拉函数">1. 欧拉函数</h2>
<p>欧拉函数的输入是一个正整数，输出小于这个正整数的、跟它互质的整数数量。</p>
<p>定义是：</p>
<p></p><div class="math display">\[\phi(n)=n(1-\frac{1}{p_1})(1-\frac{1}{p_2})\cdots(1-\frac{1}{p_m})
\]</div><p></p><p><span class="math inline">\(p_1, p_2, \cdots, p_m\)</span> 表示 <span class="math inline">\(n\)</span> 的 $ m $ 个质因子，重复的算一个。</p>
<p>比如5，它是个质数，只有它自己一个因子，所以<span class="math inline">\(\phi(5) = 5 \times (1 - \frac{1}{5}) = 4\)</span>。<br>
当然你也能猜出来，因为跟一个质数互质的数就是从1到它的前驱数的全部自然数，所以对于任意质数 <span class="math inline">\(p\)</span> 都有</p>
<p></p><div class="math display">\[\phi(p) = p-1
\]</div><p></p><p>对于合数呢？比如 <span class="math inline">\(6 = 2 \times 3\)</span>，所以 <span class="math inline">\(\phi(6) = 6 \times \frac{1}{2} \times \frac{2}{3} = 2\)</span> ，也就是6有2个互质数，我们数一下就是1和5。<br>
再看一个比如12，<span class="math inline">\(12 = 2^2 \times 3\)</span>，所以 <span class="math inline">\(\phi(12) = 12 \times \frac{1}{2} \times \frac{2}{3} = 4\)</span>。我们数一下12的互质数有1、5、7、11四个。</p>
<blockquote>
<p>规定<span class="math inline">\(\phi(1)=1\)</span></p>
</blockquote>
<p>欧拉函数的证明比较简单，可以自行AI。</p>
<h2 id="2-欧拉定理">2. 欧拉定理</h2>
<p>当正整数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(n\)</span> 互质时，有</p>
<p></p><div class="math display">\[a^{\phi(n)}\equiv 1 (\textbf{mod } n )
\]</div><p></p><p>换句话说，<span class="math inline">\(a^{\phi(n)} - 1\)</span> 可以被 <span class="math inline">\(n\)</span> 整除。</p>
<p>例如，7和10互质。<span class="math inline">\(7^{\phi(10)} = 7^4 = 2401\)</span>，减去1时10的倍数；<br>
反过来，<span class="math inline">\(10^{\phi(7)} = 10^6 = 100,0000\)</span>，减去1是999999，<span class="math inline">\(999999 \div 7 = 142857\)</span> （就是1/7 的循环节）。</p>
<h2 id="3-模反元素">3. 模反元素</h2>
<p>从上面计算的过程可以看出来，如果正整数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(n\)</span> 互质时，一定能找出一个正整数 <span class="math inline">\(b\)</span>，使得</p>
<p></p><div class="math display">\[ab \equiv 1 (\textbf{mod } n)
\]</div><p></p><p><span class="math inline">\(b\)</span> 就叫 <span class="math inline">\(a\)</span> 的模反元素。<br>
模反元素肯定存在。最起码，由于 <span class="math inline">\(a^{\phi(n)} = a a^{\phi(n) - 1} \equiv 1 (\textbf{mod } n)\)</span> 所以 $ b = a^{\phi(n) - 1}$。</p>
<p>实际上，<span class="math inline">\(b\)</span> 加减 <span class="math inline">\(n\)</span> 的倍数都是 <span class="math inline">\(a\)</span> 的模反元素。<br>
比如上面看到了，10对7的模反元素可以是10万，因为100万减1是7的倍数。那么用10万减去7的14285倍也就是99995得到5，5乘以10得到50，再减1也是7的倍数。</p>
<h1 id="密钥生成">密钥生成</h1>
<p>上面就是全部的数学基础。通过这些可以来生成密钥了。</p>
<h2 id="1-随机选择两个大质数p和q并计算他们的积n">1. 随机选择两个大质数p和q并计算他们的积n</h2>
<p>为了演示，这里选择p = 7和q = 11，有 n = 77。<br>
实际应用中，要求n的位数在600位以上才能保证安全。</p>
<blockquote>
<p>因为要求n的二进制位大于2048，折成十进制就是617位以上</p>
</blockquote>
<h2 id="2-计算n的欧拉函数-">2. 计算n的欧拉函数 <span class="math inline">\(\phi(n)\)</span></h2>
<p>虽然n很大，但是由于p和q是质数，所以就简单了</p>
<p></p><div class="math display">\[\phi(n) = (p -1)(q-1)
\]</div><p></p><p>在我们例子里就是6*10 = 60。</p>
<p>后面为了写起来方便，用字母 <span class="math inline">\(z\)</span> 表示欧拉函数的结果：<span class="math inline">\(z = \phi(n)\)</span>。</p>
<h2 id="3-选择一个数e跟--互质并计算e的模反元素d">3. 选择一个数e跟 <span class="math inline">\(\phi(n)\)</span> 互质并计算e的模反元素d</h2>
<p>要找一个数跟 <span class="math inline">\(z\)</span> 互质，e可以比 <span class="math inline">\(\phi(n)\)</span> 更大。不过 <span class="math inline">\(\phi(n)\)</span> 已经很大了，所以一般最大也就使用65537。</p>
<blockquote>
<p>使用公开的数不会降低系统安全性</p>
</blockquote>
<p>这里需要跟60互质，我们选择e = 13。<br>
简单应用上面的方法，可以得到 <span class="math inline">\(d = e^{\phi({60})-1}\)</span>。<br>
这个60比较小，<span class="math inline">\(60=2^2 \times 3 \times 5\)</span>， 所以<span class="math inline">\(\phi(60) = 16\)</span>， <span class="math inline">\(d = 13 ^ {15}\)</span> 虽然大但是也能算出来。</p>
<p>但是在实际中，<span class="math inline">\(z\)</span> 通常大得很，就算能求出它的欧拉函数值，模反元素也算不出来。</p>
<h3 id="扩展欧几里得算法">扩展欧几里得算法</h3>
<p>换一种思路。既然 <span class="math inline">\(ed \equiv 1 (\textbf{mod } z)\)</span>，也就是 <span class="math inline">\(ed-kz=1\)</span>，k是某个整数。<br>
而扩展欧几里得算法不仅可以求出两个整数a和b的最大公约数d，还可以找到整数x和y，使得</p>
<p></p><div class="math display">\[ax+by=d
\]</div><p></p><p>算法实现很简单：</p>
<pre><code class="language-rust">fn extended_gcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    if b == 0 {
        (a, 1, 0)
    } else {
        let (gcd, x1, y1) = extended_gcd(b, a % b);
        let x = y1;
        let y = x1 - (a / b) * y1;
        (gcd, x, y)
    }
}
</code></pre>
<p>代入13和60，得到d=-23。给它加60的倍数使它变成正数，所以d=37。</p>
<p>这样，公钥就是[n, e]=[77,13]，私钥就是[n,d]=[77,37]。</p>
<h1 id="私钥的安全性">私钥的安全性</h1>
<p>已知公钥能算出私钥吗？</p>
<ul>
<li>因为 <span class="math inline">\(ed \equiv 1 (\textbf{mod } z)\)</span>，而e已知，所以想算出d需要知道z</li>
<li><span class="math inline">\(z = \phi(n) = (p -1)(q-1)\)</span>，需要拿到p和q</li>
<li><span class="math inline">\(n = p \times q\)</span>，n已知，分解质因数可得p和q</li>
</ul>
<p>所以这套逻辑的保证就是第三步很难。而一旦成功分解了，私钥就很容易算了。</p>
<h1 id="加密和解密">加密和解密</h1>
<h2 id="加密过程">加密过程</h2>
<p>被加密的消息 m 需要是⼀个⼩于 n 的整数（我们可以将任意字节流直接解读为⼀个⽆符号整数）。如果消息太⼤，解读为整数以后⽐ n 要⼤，那么就分段加密。<br>
实际应用中，我们不会直接⽤ RSA 来加密消息，⽽是⽤ RSA 来加密⼀个对称秘钥，再⽤这个秘钥加密消息。</p>
<p>加密的过程就是计算下面这个c的过程：</p>
<p></p><div class="math display">\[m^{e} \equiv c (\textbf{ mod } n)
\]</div><p></p><p>假设我们要加密的消息是50，使用上面的计算</p>
<p></p><div class="math display">\[50^{13}  \equiv c (\textbf{ mod } 77)
\]</div><p></p><p>可得c=29，这就是加密后的消息。<br>
计算c的算法可以参考</p>
<pre><code class="language-rust">fn main() {
    let base = 50; // 原始消息，不能大于77
    let exponent = 13;
    let modulus = 77;
    let result = modular_exponentiation(base, exponent, modulus);
    println!("{}", result); // 加密结果
}

fn modular_exponentiation(base: i64, exponent: i64, modulus: i64) -&gt; i64 {
    let mut result = 1;
    let mut base = base % modulus;
    let mut exponent = exponent;
    while exponent &gt; 0 {
        if exponent % 2 == 1 {
            result = (result * base) % modulus;
        }
        exponent &gt;&gt;= 1;
        base = (base * base) % modulus;
    }
    result
}
</code></pre>
<h2 id="解密过程">解密过程</h2>
<p>解密过程是一样的，依据是</p>
<p></p><div class="math display">\[c^{d} \equiv m (\textbf{ mod } n)
\]</div><p></p><pre><code class="language-rust">    let base = 29;
    let exponent = 37;
    let modulus = 77;
    let result = modular_exponentiation(base, exponent, modulus);
    println!("{}", result);
</code></pre>
<p>输出结果是50，就是我们原来的消息。</p>
<h3 id="解密依据的证明">解密依据的证明</h3>
<p>为什么当 <span class="math inline">\(m^{e} \equiv c (\textbf{ mod } n)\)</span> 时会有 <span class="math inline">\(c^{d} \equiv m (\textbf{ mod } n)\)</span> 呢？</p>
<hr>
<p></p><div class="math display">\[\because m^{e} \equiv c (\textbf{ mod } n) \\
\therefore c= m^e-kn
\]</div><p></p><p>代入目标式：</p>
<p></p><div class="math display">\[({m^e-kn})^d\equiv m (\textbf{ mod } n)
\]</div><p></p><p>根据二项式定理，左边展开后除了第一项是$ m^{ed}$ 其余项都含有 <span class="math inline">\(kn\)</span>，必然是n的倍数，所以舍弃这些项。只要证明</p>
<p></p><div class="math display">\[m^{ed} \equiv m (\textbf{ mod } n)
\]</div><p></p><p>即可。<br>
根据定义，</p>
<p></p><div class="math display">\[\because ed \equiv 1 (\textbf{ mod } z) \\
\therefore ed = 1+hz
\]</div><p></p><p>代入可得</p>
<p></p><div class="math display">\[m^{1+hz} = m^{h \phi(n) + 1} \equiv m (\textbf{ mod } n)
\]</div><p></p><ol>
<li>当m和n互质时</li>
</ol>
<p></p><div class="math display">\[\because m^{\phi(n)} \equiv 1(\textbf{ mod } n) \\
\therefore m^{\phi(n)} = rn + 1 \\
m^{\phi(n)h} = (rn + 1)^h \overset{\underset{\mathrm{二项式定理}}{}}{=} tn + 1 \\
\therefore m^{\phi(n)h}  \equiv 1(\textbf{ mod } n) \\
\therefore m^{\phi(n)h} m \equiv m(\textbf{ mod } n) 
\]</div><p></p><p>得证。<br>
2. 当m和n不互质<br>
不互质时m只能时p或q的倍数。<br>
以 <span class="math inline">\(m = kp\)</span> 为例，k必然小于q，因为m&lt;n。因为q是质数，所以k与q互质。同时m也跟q互质，否则m就大于n了。</p>
<p></p><div class="math display">\[\because m^{\phi(q)} \equiv 1(\textbf{ mod } q) \\
\therefore (kp)^{q-1}  \equiv 1(\textbf{ mod } q) \\
\therefore (kp)^{q-1} =tq + 1 \\
\therefore (kp)^{(q-1)h(p-1)} =(tq + 1)^{h(p-1)}
\]</div><p></p><p>又根据二项式定理</p>
<p></p><div class="math display">\[(kp)^{(q-1)h(p-1)} \equiv 1(\textbf{ mod } q) \\
\therefore (kp)^{(q-1)h(p-1)} kp \equiv kp (\textbf{ mod } q) \\
(kp)^{ed} \equiv kp (\textbf{ mod } q) \\
\therefore (kp)^{ed}  = kp + tq
\]</div><p></p><p>要使等式成立，每一项都需要是p的倍数，所以tq是p的倍数。因为q不是p的倍数，所以t是p的倍数 t = vp：</p>
<p></p><div class="math display">\[(kp)^{ed}  = kp + vpq \\
m^{ed} = m + vn \\
\therefore m^{ed} \equiv m (\textbf{ mod } n)
\]</div><p></p><p>得证。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.036725072415509256" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-16 17:23">2025-01-16 17:23</span>&nbsp;
<a href="https://www.cnblogs.com/somefuture">大卫小东（Sheldon）</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18674659" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18674659);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18674659', targetLink: 'https://www.cnblogs.com/somefuture/p/18674659', title: 'RSA的原理和简单实践' })">举报</a>
</div>
        