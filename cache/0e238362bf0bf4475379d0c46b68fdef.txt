
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhaoweiwei/p/18936701/secp256k1_1" title="发布于 2025-06-20 17:59">
    <span role="heading" aria-level="2">secp256k1算法详解一</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文详细介绍了secp256k1椭圆曲线的参数取值及相关含义，并介绍了如何下载编译最新版本的代码库，最后给出了一个简单的示例程序说明了库的用法。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>1 简介</h1>
<p>⽐特币基于椭圆曲线加密的椭圆曲线数字签名算法（ECDSA），特定的椭圆曲线称为secp256k1。其公式定义如下</p>
<p style="text-align: center">y<sup>2</sup>=x<sup>3</sup>+ax+b <em>mod</em> p</p>
<p style="text-align: left">其中：p&nbsp;= 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F = 2<sup>256</sup>-2<sup>32</sup>-2<sup>9</sup>-2<sup>8</sup>-2<sup>7</sup>-2<sup>6</sup>-2<sup>4</sup>-1 = 2<sup>256</sup>-2<sup>32</sup>-977，a = 0, b=7</p>
<p>基点G为：x=0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798，y=0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8</p>
<p>G的阶为：n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</p>
<p>secp256k1的命名出自一个密码协议标准，每一个字母和数字都代表着特定含义，下面分别进行介绍</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250619160749933-897128623.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<h2>1.1&nbsp;密码协议标准</h2>
<p>第一部分是「sec」，sec是Standards for Efficient Cryptography 的简称，是SECG发布的一种密码学协议标准。SECG发布的「SEC 1」和「SEC 2」两个关于椭圆曲线的协议标准，在「SEC 2」中有详细说明secp256k1以及其他曲线的参数定义。除了「sec」，还有众多其他关于椭圆曲线的协议标准，从<a href="https://safecurves.cr.yp.to/" rel="noopener nofollow">SafeCurve</a>中可以看到有下列不同类型的标准。</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250619160749982-1011148936.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>「SafeCurve」此处较久没有更新，有些标准已经更新了多次，例如NIST关于数字签名的标准 FIPS 186目前在用的是第四版，第五版也在起草中了，从「NIST」官网中可见。</p>
<h2>1.2 有限域</h2>
<p>第二部分是「p」，p表示该椭圆曲线是基于素数有限域F<sub>p</sub>。有限域是离散数学中的概念，它是一个由有限数量元素组成的集合，元素之间可以进行加法和乘法计算。密码学中使用椭圆曲线都是基于有限域的，除了素数有限域F<sub>p</sub>之外，还有另一种特征为2的有限域F<sub>2</sub><sup>m</sup>，F<sub>p</sub>的大小（元素个数）为p，F<sub>2</sub><sup>m</sup>的大小为2<sup>m</sup>。基于F<sub>p</sub>的椭圆曲线为：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250619160750175-1340371096.png" alt="" width="354" height="47" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>基于F<sub>2</sub><sup>m</sup>的椭圆曲线为：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250619160749966-373991490.png" alt="" width="411" height="53" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>在「SEC 2」中还定义了sect163k1、sect163r1等曲线，其中，t表示的是该曲线基于F<sub>2</sub><sup>m</sup>。在「NIST FIPS 186-4」中定了P-256、B-163等曲线，P-表示基于F<sub>p</sub>，B-表示基于F<sub>2</sub><sup>m</sup>。</p>
<h2>1.3&nbsp;有限域大小&nbsp;</h2>
<p>每个椭圆曲线E都有若干关键参数，包括阶为n的基点G和协因子h等，其中，n为一个大素数，n*h为椭圆曲线上点的数量。为了计算效率考虑，h通常设置为1、2或4。通俗地讲，如果椭圆曲线上的点数量越多，那么这条椭圆曲线的安全度就越高，因此n的取值是影响曲线安全的关键。椭圆曲线又都是基于有限域的，曲线上的点都是有限域中的元素，因此，有限域大小决定了曲线安全度。第三部分「256」就是有限域大小的表现形式，还有更多其他如192、224、384等，在「NIST FIPS 186-4」中有个表格展现了F<sub>p</sub> 和F<sub>2</sub><sup>m</sup>两个域的各种不同大小配置。</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250619160749958-1405542392.png" alt="" width="686" height="225" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>SEC标准在这块的设置和NIST标准类似，我们会看到p系列的曲线有p192、p224、p256（secp256k1就是其中一种）、p384和p521，t/B系列有t163/B-163、t233/B-233等。</p>
<h2>1.4&nbsp;Koblitz Curve</h2>
<p>第四部分「k」表示该曲线是Koblitz Curve（科布利兹曲线），从「SEC 2」中可以看到还有此处标记为r的曲线（如secp256r1），r表示该曲线是伪随机曲线Pseudo-Random Curve。Koblitz Curve命名源自数学家「Neal Koblitz」，它是一种特殊的曲线，它的一些参数是精心挑选设置的。Koblitz Curve具有自同态的性质，可以通过优化大幅提升计算效率。相比之下，Pesudo-Random Curve的对应参数是通过随机种子计算出来的，有标准的检验算法可以检测所有参数是随机种子产生而来。在「NIST FIPS 186-4」中Koblitz Curve曲线以「K-」标记开头，分别有K-163、K-233等。</p>
<h2>1.5&nbsp;末位标记</h2>
<p>到了第五部分「1」，这是代表在前4个条件下提供了多种推荐参数设置，在SEC标准中大部分该位都是1，即只提供一种推荐参数，sect163r2是一个例外。下面把SEC和NIST两个标准推荐的曲线分别列一下，二者有较大部分是相同的参数设置。</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250619160749961-1232445666.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>上述表格中，同一行中SEC和NIST都出现的，两个曲线虽然名字不同，但参数完全相同，也就是说其实一样的。橙色底纹的几个SEC曲线没有对应的NIST曲线，因此SEC标准包含的曲线比NIST多一些，如这里secp256k1就是SEC标准单独存在的。说到这里，不得不提一个正经八卦。据说，NIST推荐的Pesudo-Random Curve，也就是P和B系列，并没有公布随机数挑选规则，外界存在一种疑虑，可能NSA（美国国家安全局）掌握了后门，能够轻易破解这些密码协议。</p>
<h1>2&nbsp; 源码及编译</h1>
<p>secp256k1源码可以从以下地址下载：<a href="https://github.com/bitcoin-core/secp256k1" target="_blank" rel="noopener nofollow">https://github.com/bitcoin-core/secp256k1</a></p>
<p>用git下载源码</p>
<div class="cnblogs_code">
<pre>git clone https:<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">github.com/bitcoin-core/secp256k1</span></pre>
</div>
<p>Check out最新release版本</p>
<div class="cnblogs_code">
<pre>git checkout v0.<span style="color: rgba(128, 0, 128, 1)">6.0</span></pre>
</div>
<h2>2.1 Linux下编译</h2>
<p>在Linux下可以使用Autotools进行编译</p>
<div class="cnblogs_code">
<pre>$ ./autogen.<span style="color: rgba(0, 0, 255, 1)">sh</span>       # Generate a ./<span style="color: rgba(0, 0, 0, 1)">configure script
$ .</span>/<span style="color: rgba(0, 0, 0, 1)">configure        # Generate a build system
$ </span><span style="color: rgba(0, 0, 255, 1)">make</span><span style="color: rgba(0, 0, 0, 1)">               # Run the actual build process
$ </span><span style="color: rgba(0, 0, 255, 1)">make</span><span style="color: rgba(0, 0, 0, 1)"> check         # Run the test suite
$ </span><span style="color: rgba(0, 0, 255, 1)">sudo</span> <span style="color: rgba(0, 0, 255, 1)">make</span> <span style="color: rgba(0, 0, 255, 1)">install</span>  # Install the library into the system (optional)</pre>
</div>
<p>可以用./configure --prefix=指定安装路径，如我将编译结果安装到buildout目录下，其目录结构如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250619160606417-1969197968.png" alt="" width="361" height="302" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<h2>2.2 Windows编译</h2>
<p>在Windows下，使用CMake+VS2019进行编译，编译配置如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250619161656347-398694649.png" alt="" width="502" height="473" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>Generate时使用默认配置，完成后用VS2019打开生成好的工程，进行编译，结果如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250619162247676-466834458.png" alt="" width="591" height="434" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>运行其中的tests项目输出如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250619165820970-1900273406.png" alt="" width="484" height="70" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>由于内容比较多，所以运行花费时间较长。</p>
<h1>3 应用</h1>
<p>用VS2019创建控制台应用程序secp256k1Test，并将include和之前编译生成lib库及dll库放到工程目录下</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250620173757398-1953198017.png" alt="" width="517" height="392" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>按照以上目录结构，修改项目C/C++中的包含路径及链接器中的配置</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250620174012025-1397100223.png" alt="" width="660" height="435" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>&nbsp;</p>
<p>主程序secp256k1Test.c如下</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_bb801a0d-103a-47b2-8e6a-ed3efd55fd52" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_bb801a0d-103a-47b2-8e6a-ed3efd55fd52" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_bb801a0d-103a-47b2-8e6a-ed3efd55fd52" class="cnblogs_code_hide">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> #include &lt;stdlib.h&gt;
<span style="color: rgba(0, 128, 128, 1)"> 2</span> #include &lt;stdio.h&gt;
<span style="color: rgba(0, 128, 128, 1)"> 3</span> #include &lt;<span style="color: rgba(0, 0, 255, 1)">string</span>.h&gt;
<span style="color: rgba(0, 128, 128, 1)"> 4</span> #include &lt;stdint.h&gt;
<span style="color: rgba(0, 128, 128, 1)"> 5</span> #include <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">secp256k1.h</span><span style="color: rgba(128, 0, 0, 1)">"</span>
<span style="color: rgba(0, 128, 128, 1)"> 6</span> 
<span style="color: rgba(0, 128, 128, 1)"> 7</span> <span style="color: rgba(0, 0, 255, 1)">#define</span>    bswap_16(value)  \
<span style="color: rgba(0, 128, 128, 1)"> 8</span>     ((((value) &amp; <span style="color: rgba(128, 0, 128, 1)">0xff</span>) &lt;&lt; <span style="color: rgba(128, 0, 128, 1)">8</span>) | ((value) &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">))
</span><span style="color: rgba(0, 128, 128, 1)"> 9</span> 
<span style="color: rgba(0, 128, 128, 1)">10</span> <span style="color: rgba(0, 0, 255, 1)">#define</span>    bswap_32(value)    \
<span style="color: rgba(0, 128, 128, 1)">11</span>     (((uint32_t)bswap_16((uint16_t)((value) &amp; <span style="color: rgba(128, 0, 128, 1)">0xffff</span>)) &lt;&lt; <span style="color: rgba(128, 0, 128, 1)">16</span>) |<span style="color: rgba(0, 0, 0, 1)"> \
</span><span style="color: rgba(0, 128, 128, 1)">12</span>     (uint32_t)bswap_16((uint16_t)((value) &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">16</span><span style="color: rgba(0, 0, 0, 1)">)))
</span><span style="color: rgba(0, 128, 128, 1)">13</span> 
<span style="color: rgba(0, 128, 128, 1)">14</span> <span style="color: rgba(0, 0, 255, 1)">#define</span>    bswap_64(value)    \
<span style="color: rgba(0, 128, 128, 1)">15</span>     (((uint64_t)bswap_32((uint32_t)((value) &amp; <span style="color: rgba(128, 0, 128, 1)">0xffffffff</span><span style="color: rgba(0, 0, 0, 1)">)) \
</span><span style="color: rgba(0, 128, 128, 1)">16</span>     &lt;&lt; <span style="color: rgba(128, 0, 128, 1)">32</span>) |<span style="color: rgba(0, 0, 0, 1)"> \
</span><span style="color: rgba(0, 128, 128, 1)">17</span>     (uint64_t)bswap_32((uint32_t)((value) &gt;&gt; <span style="color: rgba(128, 0, 128, 1)">32</span><span style="color: rgba(0, 0, 0, 1)">)))
</span><span style="color: rgba(0, 128, 128, 1)">18</span> 
<span style="color: rgba(0, 128, 128, 1)">19</span> <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> main()
</span><span style="color: rgba(0, 128, 128, 1)">20</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">21</span>     <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> ret;
</span><span style="color: rgba(0, 128, 128, 1)">22</span>     secp256k1_context* pCtx =<span style="color: rgba(0, 0, 0, 1)"> NULL;
</span><span style="color: rgba(0, 128, 128, 1)">23</span> <span style="color: rgba(0, 0, 0, 1)">    secp256k1_pubkey pubkey;
</span><span style="color: rgba(0, 128, 128, 1)">24</span>     unsigned <span style="color: rgba(0, 0, 255, 1)">char</span> rand32[<span style="color: rgba(128, 0, 128, 1)">32</span>] = { <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)"> };
</span><span style="color: rgba(0, 128, 128, 1)">25</span>     printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">this is for secp256k1 testing\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">26</span>     
<span style="color: rgba(0, 128, 128, 1)">27</span>     pCtx =<span style="color: rgba(0, 0, 0, 1)"> secp256k1_context_create(SECP256K1_CONTEXT_NONE);
</span><span style="color: rgba(0, 128, 128, 1)">28</span>     <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (pCtx) {
</span><span style="color: rgba(0, 128, 128, 1)">29</span>         <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; <span style="color: rgba(0, 0, 255, 1)">sizeof</span>(rand32) / <span style="color: rgba(128, 0, 128, 1)">4</span>; i++<span style="color: rgba(0, 0, 0, 1)">) {
</span><span style="color: rgba(0, 128, 128, 1)">30</span>             <span style="color: rgba(0, 0, 255, 1)">int</span> r =<span style="color: rgba(0, 0, 0, 1)"> rand();
</span><span style="color: rgba(0, 128, 128, 1)">31</span>             memcpy(rand32 + i * <span style="color: rgba(128, 0, 128, 1)">4</span>, &amp;r, <span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">32</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">33</span>         <span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">secp256k1_context_randomize(pCtx, rand32))
</span><span style="color: rgba(0, 128, 128, 1)">34</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">secp256k1_context_randomize failed\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">35</span>         <span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
</span><span style="color: rgba(0, 128, 128, 1)">36</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">secp256k1_context_randomize success\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">37</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">38</span> 
<span style="color: rgba(0, 128, 128, 1)">39</span>         memset(rand32, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(0, 0, 255, 1)">sizeof</span><span style="color: rgba(0, 0, 0, 1)">(rand32));
</span><span style="color: rgba(0, 128, 128, 1)">40</span>         rand32[<span style="color: rgba(128, 0, 128, 1)">31</span>] = <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">41</span>         ret = secp256k1_ec_pubkey_create(pCtx, &amp;<span style="color: rgba(0, 0, 0, 1)">pubkey, rand32);
</span><span style="color: rgba(0, 128, 128, 1)">42</span>         <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (ret) {
</span><span style="color: rgba(0, 128, 128, 1)">43</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">private key\n0x</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">44</span>             <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; <span style="color: rgba(128, 0, 128, 1)">32</span>; i++<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">45</span>                 printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">%02x</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, rand32[i]);
</span><span style="color: rgba(0, 128, 128, 1)">46</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">47</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">secp256k1_ec_pubkey_create success\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">48</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">0x</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">49</span>             <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; <span style="color: rgba(128, 0, 128, 1)">32</span>; i++<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">50</span>                 printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">%02x</span><span style="color: rgba(128, 0, 0, 1)">"</span>, pubkey.data[<span style="color: rgba(128, 0, 128, 1)">31</span>-<span style="color: rgba(0, 0, 0, 1)">i]);
</span><span style="color: rgba(0, 128, 128, 1)">51</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">\n0x</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">52</span>             <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; <span style="color: rgba(128, 0, 128, 1)">32</span>; i++<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">53</span>                 printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">%02x</span><span style="color: rgba(128, 0, 0, 1)">"</span>, pubkey.data[<span style="color: rgba(128, 0, 128, 1)">63</span>-<span style="color: rgba(0, 0, 0, 1)">i]);
</span><span style="color: rgba(0, 128, 128, 1)">54</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">55</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">56</span>         <span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
</span><span style="color: rgba(0, 128, 128, 1)">57</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">secp256k1_ec_pubkey_create failed\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">58</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">59</span> 
<span style="color: rgba(0, 128, 128, 1)">60</span>         <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> order N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</span>
<span style="color: rgba(0, 128, 128, 1)">61</span>         unsigned <span style="color: rgba(0, 0, 255, 1)">int</span>* pData = (unsigned <span style="color: rgba(0, 0, 255, 1)">int</span>*<span style="color: rgba(0, 0, 0, 1)">)rand32;
</span><span style="color: rgba(0, 128, 128, 1)">62</span>         pData[<span style="color: rgba(128, 0, 128, 1)">0</span>] = bswap_32(<span style="color: rgba(128, 0, 128, 1)">0xFFFFFFFF</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">63</span>         pData[<span style="color: rgba(128, 0, 128, 1)">1</span>] = bswap_32(<span style="color: rgba(128, 0, 128, 1)">0xFFFFFFFF</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">64</span>         pData[<span style="color: rgba(128, 0, 128, 1)">2</span>] = bswap_32(<span style="color: rgba(128, 0, 128, 1)">0xFFFFFFFF</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">65</span>         pData[<span style="color: rgba(128, 0, 128, 1)">3</span>] = bswap_32(<span style="color: rgba(128, 0, 128, 1)">0xFFFFFFFE</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">66</span>         pData[<span style="color: rgba(128, 0, 128, 1)">4</span>] = bswap_32(<span style="color: rgba(128, 0, 128, 1)">0xBAAEDCE6</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">67</span>         pData[<span style="color: rgba(128, 0, 128, 1)">5</span>] = bswap_32(<span style="color: rgba(128, 0, 128, 1)">0xAF48A03B</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">68</span>         pData[<span style="color: rgba(128, 0, 128, 1)">6</span>] = bswap_32(<span style="color: rgba(128, 0, 128, 1)">0xBFD25E8C</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">69</span>         pData[<span style="color: rgba(128, 0, 128, 1)">7</span>] = bswap_32(<span style="color: rgba(128, 0, 128, 1)">0xD0364140</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">70</span>         ret = secp256k1_ec_pubkey_create(pCtx, &amp;<span style="color: rgba(0, 0, 0, 1)">pubkey, rand32);
</span><span style="color: rgba(0, 128, 128, 1)">71</span>         <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (ret) {
</span><span style="color: rgba(0, 128, 128, 1)">72</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">private key\n0x</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">73</span>             <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; <span style="color: rgba(128, 0, 128, 1)">32</span>; i++<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">74</span>                 printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">%02x</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, rand32[i]);
</span><span style="color: rgba(0, 128, 128, 1)">75</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">76</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">secp256k1_ec_pubkey_create success\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">77</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">0x</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">78</span>             <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; <span style="color: rgba(128, 0, 128, 1)">32</span>; i++<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">79</span>                 printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">%02x</span><span style="color: rgba(128, 0, 0, 1)">"</span>, pubkey.data[<span style="color: rgba(128, 0, 128, 1)">31</span> -<span style="color: rgba(0, 0, 0, 1)"> i]);
</span><span style="color: rgba(0, 128, 128, 1)">80</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">\n0x</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">81</span>             <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span>; i &lt; <span style="color: rgba(128, 0, 128, 1)">32</span>; i++<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)">82</span>                 printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">%02x</span><span style="color: rgba(128, 0, 0, 1)">"</span>, pubkey.data[<span style="color: rgba(128, 0, 128, 1)">63</span> -<span style="color: rgba(0, 0, 0, 1)"> i]);
</span><span style="color: rgba(0, 128, 128, 1)">83</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">84</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">85</span>         <span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
</span><span style="color: rgba(0, 128, 128, 1)">86</span>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">secp256k1_ec_pubkey_create failed\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 128, 128, 1)">87</span> <span style="color: rgba(0, 0, 0, 1)">        }
</span><span style="color: rgba(0, 128, 128, 1)">88</span> 
<span style="color: rgba(0, 128, 128, 1)">89</span> <span style="color: rgba(0, 0, 0, 1)">        secp256k1_context_destroy(pCtx);
</span><span style="color: rgba(0, 128, 128, 1)">90</span> <span style="color: rgba(0, 0, 0, 1)">    }
</span><span style="color: rgba(0, 128, 128, 1)">91</span>     
<span style="color: rgba(0, 128, 128, 1)">92</span>     <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 128, 1)">93</span> }</pre>
</div>
<span class="cnblogs_code_collapse">secp256k1Test.c</span></div>
<p>程序第40，41行，以0x1为私钥产生公钥，即椭圆曲线生成元G。程序第62~70行， 以阶n-1为私钥产生公钥，即(n-1)*G，这里仅为测试，所以两次取的私钥都是特殊值，正常情况下私钥要随机产生，程序最终运行结果如下</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">this</span> <span style="color: rgba(0, 0, 255, 1)">is</span> <span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> secp256k1 testing
secp256k1_context_randomize success
</span><span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> key
</span><span style="color: rgba(128, 0, 128, 1)">0x0000000000000000000000000000000000000000000000000000000000000001</span><span style="color: rgba(0, 0, 0, 1)">
secp256k1_ec_pubkey_create success
</span><span style="color: rgba(128, 0, 128, 1)">0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798</span>
<span style="color: rgba(128, 0, 128, 1)">0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8</span>
<span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> key
</span><span style="color: rgba(128, 0, 128, 1)">0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140</span><span style="color: rgba(0, 0, 0, 1)">
secp256k1_ec_pubkey_create success
</span><span style="color: rgba(128, 0, 128, 1)">0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798</span>
<span style="color: rgba(128, 0, 128, 1)">0xb7c52588d95c3b9aa25b0403f1eef75702e84bb7597aabe663b82f6f04ef2777</span></pre>
</div>
<p>有椭圆曲线理论可知两次产生的公钥点互为逆元，它们关于x轴对称，x坐标相同，y坐标互为相反数（在有限域内y坐标之和为模数p)。</p>
<p><img src="https://img2024.cnblogs.com/blog/465567/202506/465567-20250620175642198-640090703.png" alt="" width="892" height="50" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p>参考：</p>
<p><a href="https://cloud.tencent.com/developer/news/586021" target="_blank" rel="noopener nofollow">https://cloud.tencent.com/developer/news/586021</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-20 18:00">2025-06-20 17:59</span>&nbsp;
<a href="https://www.cnblogs.com/zhaoweiwei">weiwei22844</a>&nbsp;
阅读(<span id="post_view_count">66</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18936701);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18936701', targetLink: 'https://www.cnblogs.com/zhaoweiwei/p/18936701/secp256k1_1', title: 'secp256k1算法详解一' })">举报</a>
</div>
        