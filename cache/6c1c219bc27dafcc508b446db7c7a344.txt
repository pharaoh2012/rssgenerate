
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/qq21497936/p/18946197" title="发布于 2025-06-24 14:58">
    <span role="heading" aria-level="2">Qt+OPC开发笔记（三）：OPC客户端订阅特点消息的Demo</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div class="cl-preview-section">
<h1>前言</h1>
</div>
<div class="cl-preview-section">
<p>  本篇介绍opc客户端订阅消息，实现一个opc事件的订阅，当订阅的数据在服务器发生变化是，客户端能立即得到更新。</p>
</div>
<div class="cl-preview-section">&nbsp;</div>
<div class="cl-preview-section">
<h1><a id="Demo_5"></a>Demo</h1>
</div>
<div class="cl-preview-section">
<p>  <img alt="请添加图片描述" data-src="https://i-blog.csdnimg.cn/direct/2f5f36b43bbb4dd1aef4bf4cd2cb86f5.gif" class="lazyload"></p>
</div>
<div class="cl-preview-section">&nbsp;</div>
<div class="cl-preview-section">
<h1><a id="OPC_11"></a>OPC客户端</h1>
</div>
<div class="cl-preview-section">
<p>  OPC 客户端是一种利用OPC（OLE for Process Control）协议与 OPC 服务器进行通信的软件应用程序。</p>
</div>
<div class="cl-preview-section">
<h2><a id="_13"></a>功能特点</h2>
</div>
<div class="cl-preview-section">
<ul>
<li>数据访问：提供一套简单易用的 API，使开发人员能轻松地创建、读取、更新和删除OPC服务器上的数据项，可从传感器、PLC、DCS 系统、过程分析仪等各种数据源获取实时数据。</li>
<li>事件订阅（当前使用）：支持实时数据变化订阅，当服务器端的数据发生变化时，客户端能够立即获取到更新，以便及时响应和处理数据变化。</li>
<li>连接管理：负责建立和管理与 OPC 服务器的连接，包括连接的建立、监控连接状态以及在发生异常时进行重连或断开。</li>
<li>数据展示与处理：允许用户创建和管理数据视图，通常以表格或图形的方式展示实时数据流，还能对采集到的数据进行分析、存储、归档等处理，为决策提供支持。</li>
</ul>
</div>
<div class="cl-preview-section">
<h2><a id="_18"></a>数据访问方式</h2>
</div>
<div class="cl-preview-section">
<p>  OPC 协议支持多种数据访问方式，以满足不同的应用场景需求：</p>
</div>
<div class="cl-preview-section">
<ul>
<li>同步访问：客户端发送请求后会一直等待，直到服务器返回响应。这种方式适用于对实时性要求较高的场景，但如果服务器响应时间较长，可能会导致客户端程序阻塞。</li>
<li>异步访问：客户端发送请求后不会等待服务器响应，而是继续执行后续操作。当服务器处理完请求后，会通过回调函数通知客户端。这种方式可以提高客户端程序的效率，避免阻塞。</li>
<li>订阅访问（当前使用）：客户端可以订阅特定的数据项，当这些数据项的值发生变化时，服务器会主动将更新后的数据推送给客户端。这种方式适用于需要实时监控数据变化的场景。</li>
</ul>
</div>
<div class="cl-preview-section">
<h1><a id="_23"></a>订阅服务器某个消息</h1>
</div>
<div class="cl-preview-section">
<h2><a id="_24"></a>步骤一：连接服务器</h2>
</div>
<div class="cl-preview-section">
<p>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/5d83424e829942c5aa7abc33685d5d6c.png" class="lazyload"></p>
</div>
<div class="cl-preview-section">
<h2><a id="_27"></a>步骤二：创建订阅</h2>
</div>
<div class="cl-preview-section">
<p>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/fab8ebe57b3a4657a0e3351df3c896db.png" class="lazyload"></p>
</div>
<div class="cl-preview-section">
<p>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/fc83ce6725bb4022bbbc7256fd7cb408.png" class="lazyload"></p>
</div>
<div class="cl-preview-section">
<h2><a id="_32"></a>步骤三：创建监听项</h2>
</div>
<div class="cl-preview-section">
<p>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/cddaea815c7348c080a2ff659c22c7a6.png" class="lazyload"></p>
</div>
<div class="cl-preview-section">
<h2><a id="_35"></a>步骤四：处理回调函数</h2>
</div>
<div class="cl-preview-section">
<p>  这里是通过subId与监控id对应来确定是哪一个变量变化。<br>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/2b271d0d30724e2e80202c64dbf409ad.png" class="lazyload"></p>

</div>
<div class="cl-preview-section">
<h2><a id="Qt_39"></a>步骤五：Qt兼容使用定时器定时调用</h2>

</div>
<div class="cl-preview-section">
<p>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/7f876be86b57483eb1f0d04e4c12f7c4.png" class="lazyload"></p>

</div>
<div class="cl-preview-section">&nbsp;</div>
<div class="cl-preview-section">
<h1><a id="Demo_45"></a>Demo关键源码</h1>

</div>
<div class="cl-preview-section">
<h2><a id="_46"></a>创建订阅和监控项</h2>

</div>
<div class="cl-preview-section">
<pre><code class="prism language-cpp"><span class="token keyword">bool <span class="token class-name">OpcClientManager<span class="token double-colon punctuation">::<span class="token function">createSubscriptionResponse<span class="token punctuation">(<span class="token punctuation">)
<span class="token punctuation">{
    <span class="token comment">/*
       OPC UA中的订阅是异步的。也就是说，客户端向服务器发送多个PublishRequest。
       服务器返回带有通知的PublishResponses。但只有在生成通知时。客户端不会等待响应，而是继续正常操作。
       请注意订阅和受监视项目之间的区别。订阅用于报告通知。
       MonitoredItems用于生成通知。每个MonitoredItem只附加到一个订阅。订阅可以包含许多受监视的项目。
       客户端在后台自动处理PublishResponses（带回调），并在传输中保留足够的PublishRequests。
       ublishResponses可以在同步服务调用期间或在“UA_Client_run_iterate”中接收
    */

    <span class="token comment">// 步骤一：创建一个默认的订阅请求对象（有订阅再开放）
    _subscriptionRequest <span class="token operator">= <span class="token function">UA_CreateSubscriptionRequest_default<span class="token punctuation">(<span class="token punctuation">)<span class="token punctuation">;
    _subscriptionRequest<span class="token punctuation">.requestedPublishingInterval <span class="token operator">= <span class="token number">1000<span class="token punctuation">; <span class="token comment">// 设置发布间隔为1000毫秒，即每秒发布一次数据
    _subscriptionRequest<span class="token punctuation">.requestedLifetimeCount <span class="token operator">= <span class="token number">300<span class="token punctuation">;       <span class="token comment">// 设置生命周期计数为300，即服务器在300个发布周期后会终止该订阅
    _subscriptionRequest<span class="token punctuation">.requestedMaxKeepAliveCount <span class="token operator">= <span class="token number">10<span class="token punctuation">;    <span class="token comment">// 设置最大保持活动计数为10，即服务器在10个发布周期内没有数据变化时，仍会发送空的通知以保持连接活跃
    _subscriptionRequest<span class="token punctuation">.maxNotificationsPerPublish <span class="token operator">= <span class="token number">0<span class="token punctuation">;     <span class="token comment">// 设置每个发布周期的最大通知数为0，表示不限制通知数量
    _subscriptionRequest<span class="token punctuation">.publishingEnabled <span class="token operator">= <span class="token boolean">true<span class="token punctuation">;           <span class="token comment">// 启用发布功能，允许服务器主动推送数据
    _subscriptionRequest<span class="token punctuation">.priority <span class="token operator">= <span class="token number">0<span class="token punctuation">;                       <span class="token comment">// 设置订阅的优先级为0，数值越高优先级越高
    <span class="token comment">// 步骤二：设置订阅回复，设置状态改变通知回调和删除订阅回调
    _subscriptionResponse <span class="token operator">= <span class="token function">UA_Client_Subscriptions_create<span class="token punctuation">(_pUAClient<span class="token punctuation">,
                                                           _subscriptionRequest<span class="token punctuation">,
                                                           <span class="token constant">NULL<span class="token punctuation">,
                                                           OpcClientManager<span class="token double-colon punctuation">::statusChangeNotificationCallback<span class="token punctuation">,
                                                           OpcClientManager<span class="token double-colon punctuation">::deleteSubscriptionCallback<span class="token punctuation">)<span class="token punctuation">;
    <span class="token keyword">if<span class="token punctuation">(_subscriptionResponse<span class="token punctuation">.responseHeader<span class="token punctuation">.serviceResult <span class="token operator">!= UA_STATUSCODE_GOOD<span class="token punctuation">)
    <span class="token punctuation">{
        LOG <span class="token operator">&lt;&lt; <span class="token function">QString<span class="token punctuation">(<span class="token string">"Failed to UA_Client_Subscriptions_create, error code: 0x%1"<span class="token punctuation">)
               <span class="token punctuation">.<span class="token function">arg<span class="token punctuation">(<span class="token function">UA_StatusCode_name<span class="token punctuation">(_subscriptionResponse<span class="token punctuation">.responseHeader<span class="token punctuation">.serviceResult<span class="token punctuation">)<span class="token punctuation">)<span class="token punctuation">;
        <span class="token keyword">return <span class="token boolean">false<span class="token punctuation">;
    <span class="token punctuation">}
    LOG <span class="token operator">&lt;&lt; <span class="token string">"Succeed to UA_Client_Subscriptions_create, id:" <span class="token operator">&lt;&lt; _subscriptionResponse<span class="token punctuation">.subscriptionId<span class="token punctuation">;

    <span class="token function">startTimer<span class="token punctuation">(<span class="token number">100<span class="token punctuation">)<span class="token punctuation">;

    <span class="token keyword">return <span class="token boolean">true<span class="token punctuation">;
<span class="token punctuation">}

<span class="token keyword">bool <span class="token class-name">OpcClientManager<span class="token double-colon punctuation">::<span class="token function">createMonitoredItemRequest<span class="token punctuation">(<span class="token keyword">int ns<span class="token punctuation">, <span class="token keyword">int i<span class="token punctuation">)
<span class="token punctuation">{
    <span class="token comment">// 前置：有一个订阅实例
    <span class="token comment">// 步骤三：创建监控项请求，需要传入监控的节点
    LOG <span class="token operator">&lt;&lt; ns <span class="token operator">&lt;&lt; i<span class="token punctuation">;
    UA_NodeId nodeId <span class="token operator">= <span class="token function">UA_NODEID_NUMERIC<span class="token punctuation">(ns<span class="token punctuation">, i<span class="token punctuation">)<span class="token punctuation">;
    UA_MonitoredItemCreateRequest monitoredItemCreateRequest <span class="token operator">= <span class="token function">UA_MonitoredItemCreateRequest_default<span class="token punctuation">(nodeId<span class="token punctuation">)<span class="token punctuation">;
    monitoredItemCreateRequest<span class="token punctuation">.requestedParameters<span class="token punctuation">.samplingInterval <span class="token operator">= <span class="token number">100<span class="token punctuation">;  <span class="token comment">// 采样间隔（单位：毫秒），指定服务器多久读取一次被监控变量的实际值。
    monitoredItemCreateRequest<span class="token punctuation">.requestedParameters<span class="token punctuation">.discardOldest <span class="token operator">= <span class="token boolean">true<span class="token punctuation">;    <span class="token comment">// 当监控项的队列（Queue）已满时，是否丢弃最早的数据。
    monitoredItemCreateRequest<span class="token punctuation">.requestedParameters<span class="token punctuation">.queueSize <span class="token operator">= <span class="token number">10<span class="token punctuation">;          <span class="token comment">// 服务器为该监控项保留的历史值队列大小。queueSize = 10 表示服务器最多保存10个未发送给客户端的值

    <span class="token comment">// 添加监控项到订阅
    UA_MonitoredItemCreateResult monResult <span class="token operator">= <span class="token function">UA_Client_MonitoredItems_createDataChange<span class="token punctuation">(_pUAClient<span class="token punctuation">,
                                                                                       _subscriptionResponse<span class="token punctuation">.subscriptionId<span class="token punctuation">,
                                                                                       UA_TIMESTAMPSTORETURN_BOTH<span class="token punctuation">,
                                                                                       monitoredItemCreateRequest<span class="token punctuation">,
                                                                                       <span class="token constant">NULL<span class="token punctuation">,
                                                                                       OpcClientManager<span class="token double-colon punctuation">::dataChangeNotificationCallback<span class="token punctuation">,
                                                                                       <span class="token constant">NULL<span class="token punctuation">)<span class="token punctuation">;
    <span class="token keyword">if<span class="token punctuation">(monResult<span class="token punctuation">.statusCode <span class="token operator">!= UA_STATUSCODE_GOOD<span class="token punctuation">)
    <span class="token punctuation">{
        LOG <span class="token operator">&lt;&lt; <span class="token string">"监控项创建失败 error:" <span class="token operator">&lt;&lt; <span class="token function">QString<span class="token punctuation">(<span class="token function">UA_StatusCode_name<span class="token punctuation">(monResult<span class="token punctuation">.statusCode<span class="token punctuation">)<span class="token punctuation">)<span class="token punctuation">;
        <span class="token keyword">return <span class="token boolean">false<span class="token punctuation">;
    <span class="token punctuation">}<span class="token keyword">else
    <span class="token punctuation">{
       LOG <span class="token operator">&lt;&lt; <span class="token string">"成功监控节点 MonId: " <span class="token operator">&lt;&lt; monResult<span class="token punctuation">.monitoredItemId<span class="token punctuation">;
       <span class="token keyword">return <span class="token boolean">true<span class="token punctuation">;
    <span class="token punctuation">}

<span class="token punctuation">}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
</div>
<div class="cl-preview-section">
<h2><a id="_117"></a>回调函数</h2>
</div>
<div class="cl-preview-section">
<pre><code class="prism language-cpp"><span class="token keyword">void <span class="token class-name">OpcClientManager<span class="token double-colon punctuation">::<span class="token function">statusChangeNotificationCallback<span class="token punctuation">(UA_Client <span class="token operator">*client<span class="token punctuation">, UA_UInt32 subId<span class="token punctuation">, <span class="token keyword">void <span class="token operator">*subContext<span class="token punctuation">, UA_StatusChangeNotification <span class="token operator">*notification<span class="token punctuation">)
<span class="token punctuation">{
    LOG <span class="token operator">&lt;&lt; __FUNCTION__ <span class="token operator">&lt;&lt; client <span class="token operator">&lt;&lt; subId<span class="token punctuation">;
<span class="token punctuation">}

<span class="token keyword">void <span class="token class-name">OpcClientManager<span class="token double-colon punctuation">::<span class="token function">deleteSubscriptionCallback<span class="token punctuation">(UA_Client <span class="token operator">*client<span class="token punctuation">, UA_UInt32 subId<span class="token punctuation">, <span class="token keyword">void <span class="token operator">*subContext<span class="token punctuation">)
<span class="token punctuation">{
    LOG <span class="token operator">&lt;&lt; __FUNCTION__ <span class="token operator">&lt;&lt; client <span class="token operator">&lt;&lt; subId<span class="token punctuation">;
<span class="token punctuation">}

<span class="token keyword">void <span class="token class-name">OpcClientManager<span class="token double-colon punctuation">::<span class="token function">dataChangeNotificationCallback<span class="token punctuation">(UA_Client <span class="token operator">*client<span class="token punctuation">, UA_UInt32 subId<span class="token punctuation">, <span class="token keyword">void <span class="token operator">*subContext<span class="token punctuation">, UA_UInt32 monId<span class="token punctuation">, <span class="token keyword">void <span class="token operator">*monContext<span class="token punctuation">, UA_DataValue <span class="token operator">*value<span class="token punctuation">)
<span class="token punctuation">{
    LOG <span class="token operator">&lt;&lt; __FUNCTION__ <span class="token operator">&lt;&lt; client <span class="token operator">&lt;&lt; subId<span class="token punctuation">;
    LOG <span class="token operator">&lt;&lt; <span class="token string">"数据变化通知 - 监控项ID: " <span class="token operator">&lt;&lt; monId<span class="token punctuation">;
   <span class="token keyword">if<span class="token punctuation">(value<span class="token operator">-&gt;hasValue <span class="token operator">&amp;&amp; value<span class="token operator">-&gt;value<span class="token punctuation">.type<span class="token punctuation">)
   <span class="token punctuation">{
       UA_Variant <span class="token operator">*var <span class="token operator">= <span class="token operator">&amp;value<span class="token operator">-&gt;value<span class="token punctuation">;
       <span class="token keyword">if<span class="token punctuation">(var<span class="token operator">-&gt;type <span class="token operator">== <span class="token operator">&amp;UA_TYPES<span class="token punctuation">[UA_TYPES_BOOLEAN<span class="token punctuation">]<span class="token punctuation">)
       <span class="token punctuation">{
            LOG <span class="token operator">&lt;&lt; <span class="token operator">*<span class="token generic-function"><span class="token function">static_cast<span class="token generic class-name"><span class="token operator">&lt;<span class="token keyword">bool <span class="token operator">*<span class="token operator">&gt;<span class="token punctuation">(var<span class="token operator">-&gt;data<span class="token punctuation">)<span class="token punctuation">;
       <span class="token punctuation">}<span class="token keyword">else<span class="token punctuation">{
           LOG <span class="token operator">&lt;&lt; <span class="token string">"other types"<span class="token punctuation">;
       <span class="token punctuation">}
   <span class="token punctuation">}
<span class="token punctuation">}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
</div>
<div class="cl-preview-section">
<h2><a id="_145"></a>定时器处理</h2>
</div>
<div class="cl-preview-section">
<pre><code class="prism language-cpp"><span class="token keyword">void <span class="token class-name">OpcClientManager<span class="token double-colon punctuation">::<span class="token function">timerEvent<span class="token punctuation">(QTimerEvent <span class="token operator">*event<span class="token punctuation">)
<span class="token punctuation">{
    <span class="token keyword">if<span class="token punctuation">(_pUAClient<span class="token punctuation">)
    <span class="token punctuation">{
        <span class="token function">UA_Client_run_iterate<span class="token punctuation">(_pUAClient<span class="token punctuation">, <span class="token number">100<span class="token punctuation">)<span class="token punctuation">;
    <span class="token punctuation">}
<span class="token punctuation">}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
</div>
<div class="cl-preview-section">&nbsp;</div>
<div class="cl-preview-section">
<h1><a id="v120_158"></a>工程模板v1.2.0</h1>
</div>
<div class="cl-preview-section">
<p>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/f99b35c289e5481eaf6e560efd041c23.png" class="lazyload"></p>
</div>
<div class="cl-preview-section">&nbsp;</div>
<div class="cl-preview-section">
<h1><a id="_164"></a>入坑</h1>
</div>
<div class="cl-preview-section">
<h2><a id="_165"></a>入坑一：订阅变量后未通知</h2>
</div>
<div class="cl-preview-section">
<h3><a id="_166"></a>问题</h3>
</div>
<div class="cl-preview-section">
<p>  订阅变量后未通知<br>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/26f7f04236354278a3d6f8ca641ca03e.png" class="lazyload"></p>

</div>
<div class="cl-preview-section">
<h3><a id="_170"></a>尝试</h3>

</div>
<div class="cl-preview-section">
<p>  检查代码没有发现任何问题，考虑是否有其他问题。<br>  更换第三方单文件全代码订阅后，变化 也无通知：<br>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/722053bb23e04b26964a93021b6d62ff.png" class="lazyload"></p>

</div>
<div class="cl-preview-section">
<p>  使用uaexpert测试，订阅看起来是成了：<br>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/9ddfd684d65d416b97a8690f4eea8273.png" class="lazyload"></p>

</div>
<div class="cl-preview-section">
<p>  修改成5秒，发现就是5秒了，所以这里订阅是成功了。<br>  继续考虑代码问题了，再次查看，发现可能是打印缓存的问题，Qt输出printf需要设置stdout为0：<br>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/2f84f98ac5e145fd9973bb2f9119e7b2.png" class="lazyload"></p>

</div>
<div class="cl-preview-section">
<p>  那么这个代码是没问题的。<br>  回到封装的代码，对比检查，发下关键性代码：<br>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/d746357c2110496bb84a85a56057a9f3.png" class="lazyload"></p>

</div>
<div class="cl-preview-section">
<p>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/acf27b53fc394c7aa0e741c45806a89a.png" class="lazyload"></p>

</div>
<div class="cl-preview-section">
<p>  所以open ua这个代码，收到订阅通知需要跑这个循环才可以收到。<br>在OPC UA通信中，客户端需要持续运行并处理服务器推送的通知，而UA_Client_run_iterate函数正是用于实现这一点的关键机制。<br>  然后查看了其他一边监听一边写入的代码，跟想象中一样，间隔写入（PS：就是单片机的单路径一样）<br>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/4f1cac6cb6dc49c09e5824ae7c7f8937.png" class="lazyload"></p>

</div>
<div class="cl-preview-section">
<h3><a id="_193"></a>解决</h3>

</div>
<div class="cl-preview-section">
<p>  本意是用Qt的消息循环替代：<br>  <img alt="在这里插入图片描述" data-src="https://i-blog.csdnimg.cn/direct/52d19b3bb77c493dbb0741497e51e4c7.png" class="lazyload"><br>  这个靠Qt循环的不是那么准确，还需要完善这个流程，有可能处理会有2次一同处理。</p>

</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-24 14:58">2025-06-24 14:58</span>&nbsp;
<a href="https://www.cnblogs.com/qq21497936">长沙红胖子Qt创微智科</a>&nbsp;
阅读(<span id="post_view_count">143</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18946197);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18946197', targetLink: 'https://www.cnblogs.com/qq21497936/p/18946197', title: 'Qt+OPC开发笔记（三）：OPC客户端订阅特点消息的Demo' })">举报</a>
</div>
        