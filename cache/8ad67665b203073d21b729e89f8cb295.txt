<!----> <meta itemprop="headline" content="一份完整的「前端性能优化」手册"> <meta itemprop="keywords" content="前端,性能优化,JavaScript"> <meta itemprop="datePublished" content="2024-10-24T02:13:35.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="风骨"> <meta itemprop="url" content="https://juejin.cn/user/1714893871914381"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7cdd11fb="">
            一份完整的「前端性能优化」手册
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7cdd11fb=""><div class="author-info-box" data-v-7cdd11fb=""><div class="author-name" data-v-7cdd11fb=""><a href="/user/1714893871914381/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-7cdd11fb=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    风骨
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-7cdd11fb=""><time datetime="2024-10-24T02:13:35.000Z" title="Thu Oct 24 2024 02:13:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7cdd11fb="">
                    2024-10-24
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7cdd11fb=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7cdd11fb=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7cdd11fb=""></circle></svg> <span class="views-count" data-v-7cdd11fb="">
                    3,520
                  </span> <span class="read-time" data-v-7cdd11fb=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7cdd11fb=""><rect width="16" height="16" fill="none" data-v-7cdd11fb=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7cdd11fb=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7cdd11fb=""></path></svg>
                    阅读21分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7cdd11fb=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7cdd11fb=""><div class="article-viewer markdown-body result"><p>hi，我是风骨，今天和大家分享一篇有关「前端性能优化」的话题。作为优秀的前端工程师，我们需要<strong>时刻关注页面性能指标，并持续优化</strong>。</p>
<p>在这篇文章中，我们将深入探讨前端性能优化的各个方面，包括但不限于<strong>衡量性能指标、编程技巧、资源加载、代码分割、懒加载、缓存策略等</strong>。让我们一起来看看吧！</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7b0838d4436343fc8d0672f187773a8b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1735523291&amp;x-signature=WMlN%2BK9S1aXQY0PxiTan%2Bc%2B%2Bo3E%3D" alt="image.png" loading="lazy"></p>
<p><strong>在这里插播一条信息</strong>：作者最近也是在看工作机会，各位<strong>伙伴</strong>如果有适合的内推岗位，期待可以帮作者引荐一下（可以在掘金上私信 或是 添加 wx: iamcegz），感谢！作者个人信息如下：</p>
<p>26 岁，大专·统招，专业·计算机·软件技术，工作年限·5 年，Base·北京，擅长 React 技术栈。</p>
<h2 data-id="heading-0">一、衡量前端性能</h2>
<p>要做前端性能优化，首要工作是<strong>分析和衡量</strong>页面内容，找出网站中需要优化的部分，对症下药。</p>
<p>衡量性能的方式有以下几种：</p>
<ol>
<li>加载时间</li>
<li>性能指标</li>
<li>长任务卡顿</li>
<li>浏览器 Performance 选项卡</li>
</ol>
<h3 data-id="heading-1">1、加载时间</h3>
<p>在 <code>window.performance.timing</code> 变量对象中记录了加载页面期间的各种计时信息。比如可以分析 <strong>DOM 树构建完成的时间（<code>DOMContentLoaded</code>） 和 页面完整的加载时间（<code>load</code>）</strong>。</p>
<p>如下示例，在 DOM 树中增加一个 <img src="" loading="lazy"> 标签来渲染图片，其中：</p>
<ul>
<li><code>DOMContentLoadedTime</code> 的打印时间近为 178ms，表示 DOM 树构建完成的时间；</li>
<li><code>loadTime</code> 的打印时间近为 1201ms，它会在页面所有资源（<img src="" loading="lazy"> 图片资源）加载完成后执行。</li>
</ul>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://picsum.photos/200/300"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> {
          <span class="hljs-comment">// 开始发起 HTTP 请求文档的时间</span>
          fetchStart,
          <span class="hljs-comment">// DOMContentLoaded 事件发生的时间</span>
          domContentLoadedEventStart,
          <span class="hljs-comment">// window.onload 事件发生的时间</span>
          loadEventStart,
        } = performance.<span class="hljs-property">timing</span>;

        <span class="hljs-comment">// DOM 树构建完成后触发 DOMContentLoaded 事件</span>
        <span class="hljs-keyword">const</span> <span class="hljs-title class_">DOMContentLoadedTime</span> = domContentLoadedEventStart - fetchStart;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`DOMContentLoaded 的执行时间：<span class="hljs-subst">${DOMContentLoadedTime}</span>ms`</span>);

        <span class="hljs-comment">// 页面完整的加载时间</span>
        <span class="hljs-keyword">const</span> loadTime = loadEventStart - fetchStart;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`页面完整的加载时间：<span class="hljs-subst">${loadTime}</span>ms`</span>);
      };
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>有关参考资料：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FPerformanceTiming" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming" ref="nofollow noopener noreferrer">PerformanceTiming</a></p>
<h3 data-id="heading-2">2、性能指标</h3>
<p>分析以用户为中心的性能指标，包含 <strong>FP（首次像素绘制）、FCP（首次内容绘制）、FMP（首次有意义绘制）、LCP（页面中最大的元素加载时间）等</strong>。</p>
<p>一般在 <strong>客户端渲染单页面应用</strong> 中，为了优化<strong>首屏渲染白屏时间</strong>，会重点关注 <strong>FCP（首次内容绘制）</strong> 性能指标。该绘制时长越短，说明白屏时间越少，用户打开网站的使用体验就越好。</p>
<blockquote>
<p>说明：<strong>FCP 首次内容绘制</strong> 是指用户在页面中看到了有效内容。比如在 React 框架中，初始时会有一个空 id=root div 元素，此时不会计算 FCP，只有等 id=root 经过 ReactDOM render 以后，页面呈现了文本等有效内容，这时会计算出 FCP。</p>
</blockquote>
<p>JS 可以通过 <code>PerformanceObserver</code> 观察 <code>event type paint</code> 来获取 FCP 指标。如下示例，初始放置一个空 div，在 1s 以后给 div 中添加有效内容（模拟框架渲染），FCP 指标会在这时生成。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
      <span class="hljs-comment">/* 设置背景图，生成 FP 指标 */</span>
      <span class="hljs-selector-id">#root</span> {
        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
        <span class="hljs-attribute">background</span>: <span class="hljs-number">#eee</span>;
      }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
      <span class="hljs-comment">// 模拟框架渲染，1s 后在页面呈现有效内容</span>
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        root.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">"content"</span>;
      }, <span class="hljs-number">1000</span>);

      <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">list</span>) {
          <span class="hljs-keyword">const</span> perfEntries = list.<span class="hljs-title function_">getEntries</span>();
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> perfEntry <span class="hljs-keyword">of</span> perfEntries) {
            <span class="hljs-keyword">if</span> (perfEntry.<span class="hljs-property">name</span> === <span class="hljs-string">"first-paint"</span>) {
              <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FP</span> = perfEntry;
              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"首次像素 绘制时间："</span>, <span class="hljs-variable constant_">FP</span>?.<span class="hljs-property">startTime</span>); <span class="hljs-comment">// 674ms（div 设有背景图，会在元素渲染时生成 FP 指标）</span>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (perfEntry.<span class="hljs-property">name</span> === <span class="hljs-string">"first-contentful-paint"</span>) {
              <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FCP</span> = perfEntry;
              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"首次有效内容的绘制 绘制时间："</span>, <span class="hljs-variable constant_">FCP</span>?.<span class="hljs-property">startTime</span>); <span class="hljs-comment">// 1174ms</span>
              observer.<span class="hljs-title function_">disconnect</span>(); <span class="hljs-comment">// 断开观察，不再观察了</span>
            }
          }
        });

        <span class="hljs-comment">// 观察 paint 相关性能指标</span>
        observer.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">"paint"</span>] });
      };
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>相关参考资料：<br>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fw3c.github.io%2Fpaint-timing%2F" target="_blank" title="https://w3c.github.io/paint-timing/" ref="nofollow noopener noreferrer">Paint Timing：监控内容绘制</a><br>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fw3c.github.io%2Flargest-contentful-paint%2F" target="_blank" title="https://w3c.github.io/largest-contentful-paint/" ref="nofollow noopener noreferrer">LCP：监视屏幕上触发的元素的最大绘制</a><br>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.google.com%2Fdocument%2Fd%2F1BR94tJdZLsin5poeet0XoTW60M0SjvOJQttKT-JK8HI%2Fview%23heading%3Dh.tdqghbi9ia5d" target="_blank" title="https://docs.google.com/document/d/1BR94tJdZLsin5poeet0XoTW60M0SjvOJQttKT-JK8HI/view#heading=h.tdqghbi9ia5d" ref="nofollow noopener noreferrer">FMP：首次有意义绘制指标介绍</a></p>
<h3 data-id="heading-3">3、页面卡顿</h3>
<p>当一段代码的执行占用主线程时间过长时，用户在页面上的交互就会出现卡顿，我们可以通过监控这类长任务，针对性地进行优化。</p>
<p>如下示例，点击按钮执行一个 1000ms 长任务，我们可以使用 <code>PerformanceObserver</code> 观察 <code>event type longtask</code> 并设置阈值。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"longTaskBtn"</span>&gt;</span>执行longTask<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
      <span class="hljs-comment">// 默认长任务</span>
      <span class="hljs-keyword">const</span> longTaskBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"longTaskBtn"</span>);
      <span class="hljs-keyword">function</span> <span class="hljs-title function_">longTask</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"longTask开始 start"</span>);
        <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &lt; <span class="hljs-number">1000</span> + start) {}
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"longTask结束 end，耗时："</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start);
      }
      longTaskBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"click"</span>, longTask);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
      <span class="hljs-comment">// 观察长任务</span>
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {
        list.<span class="hljs-title function_">getEntries</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> {
          <span class="hljs-comment">// 设定卡顿阈值：执行时长大于 500 ms</span>
          <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">duration</span> &gt; <span class="hljs-number">500</span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"执行的长任务耗时："</span>, entry.<span class="hljs-property">duration</span>);
          }
        });
      }).<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">"longtask"</span>] });
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 data-id="heading-4">4、浏览器 Performance 选项卡</h3>
<p>除了上述通过代码进行度量性能外，还可以在 <strong>浏览器控制台 - Performance 选项卡</strong> 中查看和分析页面性能。其中包含 <strong>FCP 性能指标、页面内容绘制 的耗时统计</strong> 等。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/28ca989a63ae45b28a689f6a54bf4c67~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO6aqo:q75.awebp?rk3s=f64ab15b&amp;x-expires=1735523291&amp;x-signature=h%2BLxfZJhBEPBVJE0Op3RANkSYgc%3D" alt="image.png" loading="lazy"></p>
<h2 data-id="heading-5">二、代码逻辑</h2>
<p>在特定需求场景下，我们可以通过一些 <strong>编程技巧</strong> 来提升性能网站的运行时性能。如：<strong>防抖/节流、图片懒加载、时间切片</strong>等。</p>
<h3 data-id="heading-6">1、关注复杂度分析</h3>
<p>我们在学习算法的时候入门课就是接触<strong>复杂度分析(大 O 表示法)</strong>，通过它来分析一个算法的 执行效率 和 占用内存 的好坏。</p>
<p>复杂度分析同样可以应用在日常开发中，它能约束你的代码编写逻辑，也会考察你的 编程思维 和 基础内功。</p>
<p>现有一个需求：在一组数据中查询目标值。</p>
<p>如果不注重代码执行效率，可能会写成下面这样，查找 N 个目标值就要执行 N 遍循环，如果不忽略系数，它的时间复杂度为 O(n^2)：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> list = [
  { <span class="hljs-attr">cityId</span>: <span class="hljs-string">"bj"</span>, <span class="hljs-attr">cityName</span>: <span class="hljs-string">"北京"</span> },
  { <span class="hljs-attr">cityId</span>: <span class="hljs-string">"sh"</span>, <span class="hljs-attr">cityName</span>: <span class="hljs-string">"上海"</span> },
  { <span class="hljs-attr">cityId</span>: <span class="hljs-string">"gz"</span>, <span class="hljs-attr">cityName</span>: <span class="hljs-string">"广州"</span> },
  { <span class="hljs-attr">cityId</span>: <span class="hljs-string">"sz"</span>, <span class="hljs-attr">cityName</span>: <span class="hljs-string">"深圳"</span> },
];

<span class="hljs-keyword">const</span> bj = list.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">cityId</span> === <span class="hljs-string">"bj"</span>);
<span class="hljs-keyword">const</span> sh = list.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">cityId</span> === <span class="hljs-string">"sh"</span>);
<span class="hljs-keyword">const</span> gz = list.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">cityId</span> === <span class="hljs-string">"gz"</span>);
<span class="hljs-keyword">const</span> sz = list.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">cityId</span> === <span class="hljs-string">"sz"</span>);
</code></pre>
<p>而对于注重编程思维的工程师，只需进行一轮遍历并将结果存储在 <code>Map</code> 中实现需求（时间复杂度 O(n) ）：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> list = [
  { <span class="hljs-attr">cityId</span>: <span class="hljs-string">"bj"</span>, <span class="hljs-attr">cityName</span>: <span class="hljs-string">"北京"</span> },
  { <span class="hljs-attr">cityId</span>: <span class="hljs-string">"sh"</span>, <span class="hljs-attr">cityName</span>: <span class="hljs-string">"上海"</span> },
  { <span class="hljs-attr">cityId</span>: <span class="hljs-string">"gz"</span>, <span class="hljs-attr">cityName</span>: <span class="hljs-string">"广州"</span> },
  { <span class="hljs-attr">cityId</span>: <span class="hljs-string">"sz"</span>, <span class="hljs-attr">cityName</span>: <span class="hljs-string">"深圳"</span> },
];

<span class="hljs-keyword">const</span> cityMap = {};

list.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">city</span>) =&gt;</span> {
  cityMap[city.<span class="hljs-property">cityId</span>] = city;
});

<span class="hljs-keyword">const</span> { bj, sh, gz, sz } = cityMap;
</code></pre>
<h3 data-id="heading-7">2、防抖和节流</h3>
<p>防抖和节流大家都不陌生，在用户频繁操作一个功能时，可以适当使用 <strong>防抖和节流</strong> 优化逻辑执行时机，避免重复执行 JS 逻辑造成页面交互阻塞。</p>
<ul>
<li>对于防抖，常见的场景是 <strong>输入框搜索查询</strong>，短时间内重复操作会 <strong>清除并重新计时</strong> 来执行回调任务；</li>
<li>对于节流，常见的场景是 <strong>调整窗口大小</strong>，以 <strong>固定的短间隔频率</strong> 执行回调任务。</li>
</ul>
<h3 data-id="heading-8">3、图片懒加载</h3>
<p>图片懒加载也是一种网站优化手段。如果不做控制，图片全部加载发送 HTTP 请求可能会导致网站卡顿崩溃。</p>
<p>首次进入页面，我们只需要加载出首屏区域的图片，其他区域的图片放置一个小的默认图，后续将图片滑动到可视区域后再加载实际的图片。</p>
<p>懒加载可以使用 <strong>IntersectionObserver API</strong> 实现。</p>
<pre><code class="hljs language-js" lang="js">&lt;img src=<span class="hljs-string">"./loading-url.png"</span> data-src=<span class="hljs-string">"./url.png"</span> alt=<span class="hljs-string">""</span>&gt;

<span class="hljs-keyword">const</span> imgList = [...<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'img'</span>)];
<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span>{
  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
    <span class="hljs-comment">// isIntersecting 是一个 Boolean 值，判断目标元素当前是否进入 root 视窗（默认 root 是 window 窗口可视区域）</span>
    <span class="hljs-keyword">if</span> (item.<span class="hljs-property">isIntersecting</span>) {
      item.<span class="hljs-property">target</span>.<span class="hljs-property">src</span> = item.<span class="hljs-property">target</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>; <span class="hljs-comment">// 真实的图片地址存放在 data-src 自定义属性上</span>
      <span class="hljs-comment">// 图片加载后停止监听该元素，释放内存</span>
      io.<span class="hljs-title function_">unobserve</span>(item.<span class="hljs-property">target</span>);
    }
  });
});
<span class="hljs-comment">// observe 监听所有 img 节点</span>
imgList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> io.<span class="hljs-title function_">observe</span>(img));
</code></pre>
<h3 data-id="heading-9">4、时间切片</h3>
<p>我们知道 浏览器的渲染 和 JS 运行在一个单线程上，如果 JS 执行一个 <strong>LongTask 长任务</strong>，势必会阻塞浏览器渲染，导致用户在界面交互出现卡顿。</p>
<p>因此我们需要避免长任务的执行，或按照一定规则拆分成一个个小任务通过 <strong>时间切片</strong> 来管理和执行。</p>
<p>有关 <strong>时间切片</strong> 的详细介绍和使用可以参考这篇文章：<a href="https://juejin.cn/post/7146004454653820935" target="_blank" title="https://juejin.cn/post/7146004454653820935">React Scheduler - 时间切片</a></p>
<h3 data-id="heading-10">5、Web Worker 子线程</h3>
<p>如果说一个长任务仅是做一些计算的逻辑，并不一定非要在主线程上运行，那么可以选择使用 Worker 开启子线程并行执行计算任务。</p>
<p>常见的场景是 <strong>大文件切片上传 - 计算文件 hash</strong>，文件越大计算 hash 耗时就越长，因此这种耗时的工作可以交给 Web Worker。</p>
<p>利用 Web Worker 计算文件 hash 的详细介绍可以参考这里：<a href="https://juejin.cn/post/7314571744354271284#heading-34" target="_blank" title="https://juejin.cn/post/7314571744354271284#heading-34">大文件切片上传</a>。</p>
<h3 data-id="heading-11">6、LRU 算法</h3>
<p>实现业务功能时有时会涉及 <strong>已访问数据的缓存</strong> 操作，缓存存储可以是在 <strong>内存变量 或 浏览器本地缓存</strong> 中。</p>
<p>无论是哪种存放位置，都不宜无限制的向缓存中存储数据，存储的越多，就会导致计算机运行越来越慢。</p>
<p><strong>LRU（最近最少使用）算法用于管理缓存中的数据</strong>，确保缓存集合中数据的条目在一个可控的范围内。</p>
<p>通过 <strong>队列</strong> 可以实现 LRU 算法。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">max</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span> = max; <span class="hljs-comment">// 缓存容量</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 定义缓存 Map，优化查找速度</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span> = []; <span class="hljs-comment">// 队列，记录最近节点的 key</span>
  }

  <span class="hljs-comment">// 访问数据</span>
  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) {
      <span class="hljs-comment">// 更新节点到队列尾部</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">update</span>(key);
      <span class="hljs-keyword">const</span> val = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);
      <span class="hljs-keyword">return</span> val;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
  }

  <span class="hljs-comment">// 添加/更新数据</span>
  <span class="hljs-title function_">put</span>(<span class="hljs-params">key, val</span>) {
    <span class="hljs-comment">// 1、更新数据（和 get 相似都是更新节点到队列尾部，不过多了更新 val 操作）</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, val);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">update</span>(key);
    }
    <span class="hljs-comment">// 2、添加数据</span>
    <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, val); <span class="hljs-comment">// 记录到 Map 中</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-title function_">push</span>(key); <span class="hljs-comment">// 添加到队列尾部</span>
      <span class="hljs-comment">// 考虑容量是否超出</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>) {
        <span class="hljs-keyword">const</span> oldKey = <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 删除队列头部</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(oldKey);
      }
    }
  }

  <span class="hljs-comment">// 移动到队列尾部</span>
  <span class="hljs-title function_">update</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-title function_">indexOf</span>(key);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除旧的位置</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-title function_">push</span>(key); <span class="hljs-comment">// 添加到队列尾部</span>
  }
}
</code></pre>
<p>测试用例如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-number">3</span>);

<span class="hljs-comment">// 1. 添加新数据，此时缓存未满</span>
cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>);
cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>);
cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">"c"</span>, <span class="hljs-number">3</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-property">keys</span>); <span class="hljs-comment">// [a, b, c]</span>

<span class="hljs-comment">// 2. 访问已有数据</span>
cache.<span class="hljs-title function_">get</span>(<span class="hljs-string">"b"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-property">keys</span>); <span class="hljs-comment">// [a, c, b]</span>

<span class="hljs-comment">// 3. 添加新数据，此时缓存已满</span>
cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">"d"</span>, <span class="hljs-number">4</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache.<span class="hljs-property">keys</span>); <span class="hljs-comment">// [c, b, d]</span>
</code></pre>
<h2 data-id="heading-12">三、框架性能优化</h2>
<p>现代框架（Vue、React）在渲染流程上都有它的优化策略。掌握框架的 <strong>性能优化 API 和 底层运行原理</strong> 有助于编写出执行效率更高的程序。</p>
<p>这里以 <code>React</code> 框架为例介绍一些常见的性能优化手段。</p>
<h3 data-id="heading-13">1、React 底层性能优化策略</h3>
<p>在 React 底层，性能优化策略主要体现在：</p>
<ol>
<li><code>bailout 策略</code>：<strong>更新前后没有任何信息（props、state、context、type）发生变化，减少组件或子组件的 render 调用</strong>；</li>
<li><code>eagerState 策略</code>：<strong>本次触发更新先后值没有发生变化，不开启 render 更新渲染流程，减少不必要的更新</strong>。</li>
</ol>
<p>其中 <strong>eagerState 策略</strong>是指：在调用 setState(value) 时，若更新的 value 值和当前 state value 值相同，则不会进入 render 更新渲染流程。</p>
<p><strong>bailout 策略</strong> 则是在开启更新流程后，比较发现组件和子组件身上没有信息发生变化，跳过它们的 render 操作，直接复用节点。</p>
<p>我们在编写组件过程中，应尽可能靠近 <strong>bailout 策略</strong> 提升执行效率，如 <strong>将「变化的部分」与「不变的部分」分离</strong> 或使用 <strong>React.memo</strong>。</p>
<h3 data-id="heading-14">2、将「变化的部分」与「不变的部分」分离</h3>
<p>主要目的是：<strong>仅让「变化的部分」的组件执行 render，而「不变的部分」的组件命中 <strong>bailout 策略</strong> 跳过 render，减少不必要的代码执行</strong>。</p>
<p>我们先来看一个没有分离的例子：如下示例，在点击 button 触发更新后，除了 App 组件会 render 外，ExpensiveSubtree 组件也会 render。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-comment">// 假设这是一个 很庞大、渲染很耗性能 的组件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ExpensiveSubtree</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Expensive render"</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>ExpensiveSubtree<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [num, update] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"App render "</span>, num);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> update(num + 1)}&gt;+ 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>num is: {num}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveSubtree</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>为了让 App 和 ExpensiveSubtree 组件命中 <strong>bailout 策略</strong>，我们将「变化的部分」抽离出来：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, <span class="hljs-title class_">Fragment</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-comment">// 假设这是一个 很庞大、渲染很耗性能 的组件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ExpensiveSubtree</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Expensive render"</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>ExpensiveSubtree<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
}

<span class="hljs-comment">// 将「变化的部分 - state」抽离出来</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Num</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [num, update] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> update(num + 1)}&gt;+ 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>num is: {num}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"App render "</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Num</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveSubtree</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>现在，App 和 ExpensiveSubtree 仅在首屏渲染进行 render，后续的更新只有 Num 组件进行重新 render。</p>
<h3 data-id="heading-15">3、React.memo</h3>
<p>从上面 <strong>没有分离</strong> 的示例中我们也发现了：只要父组件（App）render，即使子组件（ExpensiveSubtree）没有发生状态更新，也会进行 render。</p>
<p>这是因为：父组件（App）在 render 时，调用 <code>React.createElement</code> 会重新给子组件（ExpensiveSubtree）分配一个全新对象 <code>props</code>，导致子组件没有命中 <strong>bailout 策略</strong>。</p>
<p><code>React.memo</code> 就是为了解决上述情况，它会浅比较 <code>props</code> 下的属性值，若属性值没有发生变化，则复用 <code>props</code> 引用地址，则命中 <strong>bailout 策略</strong> 跳过组件 render。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, memo } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-comment">// 假设这是一个 很庞大、渲染很耗性能 的组件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ExpensiveSubtree</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Expensive render"</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>ExpensiveSubtree<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
}
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ExpensiveSubtreeMemo</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-title class_">ExpensiveSubtree</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [num, update] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"App render "</span>, num);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> update(num + 1)}&gt;+ 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>num is: {num}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveSubtreeMemo</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<h3 data-id="heading-16">4、useMemo 和 useCallback</h3>
<p>useMemo 和 useCallback 是 React 函数组件中手动优化的方式。</p>
<ul>
<li>
<p><code>useMemo</code> 可以确保只有当依赖项改变时，回调函数才会执行计算新的结果，<strong>对于一些复杂的运算和转换，可以减少不必要的计算，起到优化作用</strong>；</p>
</li>
<li>
<p><code>useCallback</code> 可以确保只有当依赖项改变时，回调函数才会重新创建，这样可以避免每次渲染都创建新的函数实例。<strong>在将函数作为 props 传递给子组件时非常有用，函数引用没有变化，能够减少子组件不必要的 render</strong>。</p>
</li>
</ul>
<h3 data-id="heading-17">5、批处理更新</h3>
<p>以 React17 为例，在异步函数中多次调用 <code>setState</code> 将会开启 <strong>多次</strong> 更新流程，如下示例，会打印 3 次 count。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> count + <span class="hljs-number">1</span>);
      <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> count + <span class="hljs-number">1</span>);
      <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> count + <span class="hljs-number">1</span>);
    });
  };
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onClick}</span>&gt;</span>123, {count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<p>面对这种情况，我们需要手动给 setCount 添加 <code>batched</code> 批处理上下文，将多次更新合并为一次更新流程。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span>, { unstable_batchedUpdates } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">unstable_batchedUpdates</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> count + <span class="hljs-number">1</span>);
        <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> count + <span class="hljs-number">1</span>);
        <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> count + <span class="hljs-number">1</span>);
      });
    });
  };
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onClick}</span>&gt;</span>123, {count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<p><strong>从 React18 版本起，加入了 <code>Automatic Batching</code> 自动批处理机制，在任何环境下（包括异步回调函数）进行多次更新操作，都会合并为一次更新流程</strong>。</p>
<h2 data-id="heading-18">四、资源加载</h2>
<p>资源加载层面的优化，可以从以下方面入手：</p>
<ol>
<li><strong>把控资源体积</strong>：控制好资源的体积，避免某个资源过大影响页面渲染或其他资源的运行；</li>
<li><strong>合理使用缓存</strong>：利用缓存提升资源的二次访问速度；</li>
<li><strong>优化资源加载时机</strong>：将非首选资源延迟加载、按需加载。</li>
</ol>
<h3 data-id="heading-19">1、控制资源体积</h3>
<p>例举一个常见的场景：在 CSR 客户端渲染中，如果 main.js 资源体积过大，会导致在资源加载完成以前，页面会出现长时间的白屏。</p>
<p>因此对于页面的首要资源，可以适当的进行拆包（如 <code>Webpack spliceChunks</code>，下文「打包策略」中会介绍），减小资源体积，从而减少页面的白屏时间。</p>
<h3 data-id="heading-20">2、合理使用缓存</h3>
<p>浏览器会对 HTTP 请求过的文件进行缓存，以便下一次访问时重复使用，减少不必要的数据传输，提高页面访问速度。</p>
<p>缓存分为：<strong>强缓存</strong> 和 <strong>协商缓存</strong>，像一些 JS、CSS、图片等资源文件，推荐使用 <strong>强缓存</strong>，再结合 <strong>Webpack 构建生成 hash 文件名</strong> 或 <strong>使用版本号</strong> 在需要更新时跳过缓存。</p>
<h3 data-id="heading-21">3、优化资源加载时机</h3>
<p>浏览器在解析 HTML 的时候，如果遇到一个没有任何属性的 script 标签，就会暂停解析，先发送网络请求获取该 JS 脚本的代码内容，然后让 JS 引擎执行该代码，当代码执行完毕后恢复执行后续解析。</p>
<p>很明显，这种方式会阻塞后续内容的解析和执行。</p>
<p>我们可以给 <code>script</code> 标签添加 <code>async</code> 或 <code>defer</code> 属性，来改变资源的下载和执行时间，二者区别如下：</p>
<ul>
<li><code>defer</code> 异步下载资源，要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；</li>
<li><code>async</code> 异步下载资源，一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染；</li>
<li><code>defer</code> 是"渲染完再执行"，<code>async</code> 是"下载完就执行"；</li>
<li>另外，如果有多个 <code>defer</code> 脚本，会按照它们在页面出现的顺序加载，而多个 <code>async</code> 脚本无法保证加载顺序。</li>
</ul>
<p>除了上述优化方式外，我们还可以把 <strong>非首要资源</strong> 改成 <strong>按需加载</strong>。我举一个例子：有一个文件预览器，它是由一个 JS 脚本提供，但首屏渲染并不需要加载它，可以在用户实际预览文件的时候进行动态加载，可以再结合 Toast 提示 "资源准备中"。</p>
<p>下面是按需加载的代码示例，在首次调用 <code>openFilePreview</code> 预览文件时，加载相关资源：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">let</span> previewLoadStatus = <span class="hljs-string">"unload"</span>; <span class="hljs-comment">// "unload" | "loading" | "loaded"</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">openFilePreview</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-comment">// 1、避免重复加载</span>
  <span class="hljs-keyword">if</span> (previewLoadStatus === <span class="hljs-string">"loading"</span>) <span class="hljs-keyword">return</span>;

  <span class="hljs-keyword">const</span> previewScriptUrl = <span class="hljs-string">"path/to/your/script.js"</span>;
  <span class="hljs-keyword">const</span> previewLinkUrl = <span class="hljs-string">"path/to/your/script.css"</span>;

  <span class="hljs-keyword">if</span> (previewLoadStatus === <span class="hljs-string">"unload"</span>) {
    <span class="hljs-comment">// 2、首次加载资源</span>
    previewLoadStatus = <span class="hljs-string">"loading"</span>;
    <span class="hljs-title function_">showLoadingToast</span>(); <span class="hljs-comment">// Toast 提示 "正在初始化工具..."</span>
    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
      <span class="hljs-title function_">loadScript</span>(previewScriptUrl),
      <span class="hljs-title function_">loadLink</span>(previewLinkUrl),
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>)),
    ])
      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// 2.1、加载完成</span>
        previewLoadStatus = <span class="hljs-string">"loaded"</span>;
        <span class="hljs-comment">// 调用文件预览功能</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"文件预览功能已加载"</span>);
      })
      .<span class="hljs-keyword">catch</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// 2.2、加载失败，下次重新加载</span>
        previewLoadStatus = <span class="hljs-string">"unload"</span>;
      })
      .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">hideLoadingToast</span>(); <span class="hljs-comment">// 隐藏 Toast</span>
      });
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 3、调用文件预览功能</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"文件预览功能已加载"</span>);
  }
};
</code></pre>
<p>相关工具函数如下：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">loadScript</span> = url =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"script"</span>);
    script.<span class="hljs-property">src</span> = url;
    script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">resolve</span>();
    };
    script.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Failed to load script: <span class="hljs-subst">${url}</span>`</span>));
    };
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);
  });
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">loadLink</span> = url =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> link = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"link"</span>);
    link.<span class="hljs-property">rel</span> = <span class="hljs-string">"stylesheet"</span>;
    link.<span class="hljs-property">href</span> = url;
    link.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">resolve</span>();
    };
    link.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Failed to load link: <span class="hljs-subst">${url}</span>`</span>));
    };
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(link);
  });
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">showLoadingToast</span> = (<span class="hljs-params"></span>) =&gt; {...};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">hideLoadingToast</span> = (<span class="hljs-params"></span>) =&gt; {...};
</code></pre>
<h2 data-id="heading-22">五、优化白屏</h2>
<p>通常我们会使用类似 <code>create-react-app</code> 等脚手架创建 <strong>客户端渲染（CSR）项目</strong>，广泛使用在 SPA 单页面应用中。</p>
<p>随着项目的开发和维护，避免不了资源体积过大，导致白屏时间越来越长。上面其实也列举了一些优化白屏的时间，如：<strong>把控资源体积、非首选资源按需加载</strong>，还有后面要介绍的 <strong>路由按需加载</strong>。</p>
<p>如果是 <code>To C</code> 的应用且注重 SEO 搜索引擎优化，可以使用 <strong>服务端渲染（SSR）</strong> 来改善白屏问题。如现在成熟的服务端渲染框架：<a href="https://link.juejin.cn?target=https%3A%2F%2Fnextjs.org%2F" target="_blank" title="https://nextjs.org/" ref="nofollow noopener noreferrer">Next.js</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.nuxtjs.cn%2F" target="_blank" title="https://www.nuxtjs.cn/" ref="nofollow noopener noreferrer">Nuxt.js</a>。</p>
<h2 data-id="heading-23">六、交互体验</h2>
<p>在加载过程中，可以加入一些视觉观感元素，来过渡加载过程，提升使用体验。如：</p>
<ol>
<li><strong>呈现骨架屏（墓碑图）</strong></li>
<li><strong>加载消息提示</strong></li>
<li><strong>呈现过渡动画</strong></li>
</ol>
<h2 data-id="heading-24">七、打包策略</h2>
<p>现在前端框架项目，都是经过构建工具（Webpack、Vite、Rollup 等）打包生成。这一步也是 <strong>优化网站访问速度的主要手段</strong>。</p>
<p>如果你是使用 Webpack 打包工具，优化和分析构建产物可以使用 <code>webpack-bundle-analyzer</code> 插件。</p>
<p>下面是我经历过后的一些经验和建议，一起来看下~</p>
<h3 data-id="heading-25">1、按需加载路由</h3>
<p>在一个大型应用中，通常会设定多个路由页面。默认这些页面会被 Webpack 打包到同一个 chunk 文件中（main.js）。</p>
<p>在这种情况下，首屏渲染时就会出现白屏时间过长问题。</p>
<p>因此，我们可以将每个页面路由组件，拆成单独的一个个 chunk 文件，这样 main.js 文件体积降低，在首屏加载时，不会再加载其他页面的资源，从而提升首屏渲染速度。</p>
<p>要将路由组件拆分成 chunk 也很简单，使用异步 API <code>import()</code> 函数导入组件，Webpack 在打包时会将异步导入拆分成单独的 <code>chunk</code> 文件。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Home</span> = <span class="hljs-title class_">LazyComponent</span>(<span class="hljs-string">"Home"</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "Home" */</span> <span class="hljs-string">"@/pages/Home"</span>));
... 其他路由组件导入

&lt;<span class="hljs-title class_">Route</span> exact path=<span class="hljs-string">"/"</span> component={<span class="hljs-title class_">Home</span>} /&gt;
... 其他路由组件
</code></pre>
<p><code>LazyComponent</code> 是自行封装的一个懒加载组件，在拿到 <code>import()</code> 异步加载组件内容后，渲染对应组件。</p>
<h3 data-id="heading-26">2、合理进行分包</h3>
<p>在 Webpack5 中有一个配置选项 <code>spliceChunks</code>，可以用来拆包和提取公共代码。</p>
<ol>
<li><strong>拆包</strong>：将一些模块拆分到单独的 chunk 文件中，如将第三方模块拆分到 <code>vendor.js</code> 中；</li>
<li><strong>提取公共代码</strong>：将多处引入的模块代码，提取到单独的 chunk 文件中，防止代码被重复打包，如拆分到 <code>common.js</code> 中。</li>
</ol>
<p>如下是一个分包配置的示例：</p>
<pre><code class="hljs language-js" lang="js">...
<span class="hljs-comment">// 拆分 chunks</span>
<span class="hljs-attr">splitChunks</span>: {
  <span class="hljs-comment">// cacheGroups 配置拆分(提取)模块的方案（里面每一项代表一个拆分模块的方案）</span>
  <span class="hljs-attr">cacheGroups</span>: {
    <span class="hljs-comment">// 禁用默认的缓存组，使用下方自定义配置</span>
    <span class="hljs-attr">defaultVendors</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">default</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-comment">// 将 node_modules 中第三方模块抽离到 vendors.js 中</span>
    <span class="hljs-attr">vendors</span>: {
      <span class="hljs-comment">// chunk 名称</span>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'chunk-vendors'</span>,
      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,
      <span class="hljs-attr">priority</span>: -<span class="hljs-number">10</span>,
      <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>,
    },
    <span class="hljs-comment">// 按照模块的被引用次数，将公共模块抽离到 common.js 中</span>
    <span class="hljs-attr">common</span>: {
      <span class="hljs-comment">// chunk 名称</span>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'chunk-common'</span>,
      <span class="hljs-attr">priority</span>: -<span class="hljs-number">20</span>,
      <span class="hljs-attr">chunks</span>: <span class="hljs-string">"all"</span>,
      <span class="hljs-comment">// 模块被引入两次及以上，拆分到 common chunk 中</span>
      <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>,
    },
    <span class="hljs-comment">// 将 React 生态体系作为一个单独的 chunk，减轻 chunk-vendors 的体积</span>
    <span class="hljs-attr">react</span>: {
      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/](react|react-dom|redux|react-redux|history|react-router|react-router-dom)/</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'chunk-react-package'</span>,
      <span class="hljs-attr">priority</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">chunks</span>: <span class="hljs-string">'all'</span>,
      <span class="hljs-attr">enforce</span>: <span class="hljs-literal">true</span>,
    },
  }
},
</code></pre>
<h3 data-id="heading-27">3、启用代码压缩</h3>
<p>使用 <code>TerserWebpackPlugin</code> 和 <code>CssMinimizerPlugin</code> 插件对 JS/CSS 代码进行压缩，降低打包资源体积。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">TerserWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">"terser-webpack-plugin"</span>); <span class="hljs-comment">// JS 压缩</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">CssMinimizerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'css-minimizer-webpack-plugin'</span>); <span class="hljs-comment">// CSS 压缩</span>

...
<span class="hljs-attr">optimization</span>: {
  <span class="hljs-attr">minimize</span>: isEnvProduction,
  <span class="hljs-comment">// 配置压缩工具</span>
  <span class="hljs-attr">minimizer</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserWebpackPlugin</span>({
      <span class="hljs-comment">// 不提取注释到单独的 .txt 文件</span>
      <span class="hljs-attr">extractComments</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-comment">// 使用多进程并发运行以提高构建速度。并发运行的默认数量：os.cpus().length - 1。</span>
      <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>,
    }),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>(), <span class="hljs-comment">// CSS 压缩</span>
  ],
  ...
}
</code></pre>
<h3 data-id="heading-28">4、配置特定模块查找路径</h3>
<p>如果你的项目或老项目中有使用过 moment.js 时，默认 Webpack 打包会包含所有语言包，导致打包文件非常大。通过配置 <code>ContextReplacementPlugin</code>，可以仅包含特定的语言包，如 zh-cn 和 en，从而减小打包文件的大小 ‌。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-attr">plugins</span>: [
  <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">ContextReplacementPlugin</span>(<span class="hljs-regexp">/moment[/\\]locale$/</span>, <span class="hljs-regexp">/zh-cn|zh-hk|en/</span>),
];
</code></pre>
<h3 data-id="heading-29">5、externals 指定外部模块</h3>
<p>比如 <code>JQuery</code>，一般我们为了减少 <code>vendors chunk</code> 文件的体积，会采用 <code>CDN script</code> 方式引入。</p>
<p>为了在模块中继续使用 <code>import</code> 方式引入 JQuery（<code>import $ from 'jquery'</code>），同时期望 Webpack 不要对路径为 <code>jquery</code> 的模块进行打包，可以配置 <code>externals</code> 外部模块选项。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">//...</span>
  <span class="hljs-attr">externals</span>: {
    <span class="hljs-comment">// jquery 通过 script 引入之后，全局中即有了 jQuery 变量</span>
    <span class="hljs-attr">jquery</span>: <span class="hljs-string">"jQuery"</span>,
  },
};
</code></pre>
<h3 data-id="heading-30">6、静态图片管理</h3>
<p>在你的项目中可能有这样一个 <code>loader</code> 配置：使用 <code>url-loader</code> 将小于某一阈值的图片，打包成 <code>base64</code> 形式到 chunk 文件中。</p>
<pre><code class="hljs language-js" lang="js">{
  <span class="hljs-attr">test</span>: [<span class="hljs-regexp">/\.bmp$/</span>, <span class="hljs-regexp">/\.gif$/</span>, <span class="hljs-regexp">/\.jpe?g$/</span>, <span class="hljs-regexp">/\.png$/</span>, <span class="hljs-regexp">/\.webp$/</span>],
  <span class="hljs-attr">loader</span>: <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'url-loader'</span>),
  <span class="hljs-attr">options</span>: {
    <span class="hljs-attr">limit</span>: <span class="hljs-string">'10000'</span>, <span class="hljs-comment">// 大于10k，打包单独静态资源，否则处理成 base64</span>
    <span class="hljs-attr">name</span>: <span class="hljs-string">'static/media/[name].[contenthash:8].[ext]'</span>, <span class="hljs-comment">// 图片资源添加版本号</span>
  },
},
</code></pre>
<p>看着好像没啥问题，不过现在有一场景：有一组（20 个）文件封面图，平均文件体积大小在 9kb 左右，由于不满足阈值，最终会被打包成 base64 形式放到 chunk 中。</p>
<p>这会导致 chunk 文件中多了将近 200kb 的大小。建议这类一组文件图的情况，可以选择存放到 CDN 静态资源服务器上进行使用。</p>
<h3 data-id="heading-31">7、明确目标环境</h3>
<p>我们<strong>编写的 ES6+ 代码会经过 <code>Babel</code> 进行降级转换和 <code>polyfill</code> 得到 ES5 代码运行在浏览器上</strong>，不过这会增大 chunk 资源的体积。</p>
<p>但是如果明确我们的网站仅运行在主流浏览器上，不考虑 IE11，可以<strong>将构建目标调整为 <code>ES2015</code>，这样可以减少 Babel 的降级处理和 polyfill 的引入，减小打包后的 chunk 资源体积</strong>。</p>
<p>以下是一个 <code>Babel</code> 配置的示例：</p>
<pre><code class="hljs language-js" lang="js">{
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(js|mjs|jsx|ts|tsx)$/</span>,
  <span class="hljs-attr">include</span>: [path.<span class="hljs-title function_">resolve</span>(context, <span class="hljs-string">'src'</span>)],
  <span class="hljs-attr">loader</span>: <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'babel-loader'</span>),
  <span class="hljs-attr">options</span>: {
    <span class="hljs-attr">presets</span>: [
      [<span class="hljs-string">'@babel/preset-env'</span>, {
        <span class="hljs-string">"targets"</span>: {
          <span class="hljs-comment">// - 配置表示支持市场份额大于 0.2% 的浏览器，不包括已停止维护的浏览器和 Opera Mini。（此配置打包后是 es6+ 代码）</span>
          <span class="hljs-string">"browsers"</span>: [<span class="hljs-string">"&gt; 0.2%"</span>, <span class="hljs-string">"not dead"</span>, <span class="hljs-string">"not op_mini all"</span>],
          <span class="hljs-comment">// - 如果期望打包后是 es5 代码，可以使用下面配置，确保 Babel 会将代码转换为 ES5 语法，以兼容 IE 11 及更旧的浏览器。</span>
          <span class="hljs-comment">// "browsers": ["&gt; 0.2%", "ie 11"]</span>
        },
        <span class="hljs-comment">// Babel 会根据代码中使用的特性自动引入必要的 polyfill（通过 core-js），以确保这些特性在目标环境中可用。</span>
        <span class="hljs-string">"useBuiltIns"</span>: <span class="hljs-string">"usage"</span>,
        <span class="hljs-string">"corejs"</span>: <span class="hljs-number">3</span>
      }],
      <span class="hljs-string">'@babel/preset-react'</span>,
      <span class="hljs-string">'@babel/preset-typescript'</span>,
    ],
    ...
  }
},
</code></pre>
<h3 data-id="heading-32">8、优化构建速度</h3>
<p>打包构建速度过慢，也会影响我们的工作效率。可以从以下几个方向入手：</p>
<h4 data-id="heading-33">1、配置模块查找范围</h4>
<p>通过 <code>resolve</code> 选项配置模块的查找范围和文件扩展名。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 模块解析</span>
<span class="hljs-attr">resolve</span>: {
  <span class="hljs-comment">// 解析模块时应该搜索的目录</span>
  <span class="hljs-attr">modules</span>: [<span class="hljs-string">'node_modules'</span>],
  <span class="hljs-attr">extensions</span>: [<span class="hljs-string">'.ts'</span>, <span class="hljs-string">'.tsx'</span>, <span class="hljs-string">'.js'</span>, <span class="hljs-string">'.jsx'</span>], <span class="hljs-comment">// 查找模块时，为不带扩展名的模块路径，指定要查找的文件扩展名</span>
  ...
},
</code></pre>
<h4 data-id="heading-34">2、配置 babel-loader 编译范围</h4>
<p>通过 <code>exclude、include</code> 配置来确保编译尽可能少的文件。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">//...</span>
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js[x]?$/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-string">"babel-loader"</span>],
        <span class="hljs-attr">include</span>: [path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"src"</span>)],
      },
    ],
  },
};
</code></pre>
<h4 data-id="heading-35">3、开启 babel-loader 编译缓存</h4>
<p>设置 <code>cacheDirectory</code> 属性开启编译缓存，避免 Webpack 在每次构建时产生高性能消耗的 Babel 编译过程。</p>
<pre><code class="hljs language-js" lang="js">{
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(js|mjs|jsx|ts|tsx)$/</span>,
  <span class="hljs-attr">include</span>: [path.<span class="hljs-title function_">resolve</span>(context, <span class="hljs-string">'src'</span>)],
  <span class="hljs-attr">loader</span>: <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'babel-loader'</span>),
  <span class="hljs-attr">options</span>: {
    ...
    <span class="hljs-comment">// 开启编译缓存，缓存 loader 的执行结果（默认缓存目录：node_modules/.cache/babel-loader），提升构建速度（作用和单独使用 cache-loader 一致）</span>
    <span class="hljs-attr">cacheDirectory</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// 配合 cacheDirectory 使用，设置 false 禁用缓存文件压缩，这会增加缓存文件的大小，但会减少压缩的消耗时间，提升构建速度。</span>
    <span class="hljs-attr">cacheCompression</span>: <span class="hljs-literal">false</span>,
  }
},
</code></pre>
<h4 data-id="heading-36">4. 启用多进程对 JS 代码压缩</h4>
<p>在使用 <code>TerserWebpackPlugin</code> 对 JS 代码进行压缩时，默认选项 <code>parallel = true</code> 就开启了多进程并发运行，以提高构建速度。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserWebpackPlugin</span>({
  <span class="hljs-comment">// 使用多进程并发运行以提高构建速度。并发运行的默认数量：os.cpus().length - 1。</span>
  <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>,
  ...
}),
</code></pre>
<h2 data-id="heading-37">八、基础设施</h2>
<p>公司的基础设施，也是优化的一种手段。</p>
<ol>
<li>
<p><strong>开启 HTTP2</strong>：在 HTTP/1.x 中，每个请求/响应对都需要一个单独的 TCP 连接。HTTP/2 允许在单个 TCP 连接上并行交错多个请求和响应，减少了连接的开销和延迟。</p>
</li>
<li>
<p><strong>开启 Gzip 压缩</strong>：如在 Nginx 服务器上，为 JS、CSS 等静态资源开启 Gzip 压缩，体积会有明显缩小。你可以通过检查网络请求的响应头中的 <code>Content-Encoding: gzip</code> 来确认资源是否已经被 Gzip 压缩。</p>
</li>
<li>
<p><strong>使用 CDN</strong>：将静态文件、音视频、图片等分发到全球各地的服务器，通过从附近的 CDN 服务器提供资源，可以减少延迟并提高加载速度。</p>
</li>
</ol>
<h2 data-id="heading-38">文末</h2>
<p>内容挺长，希望可以给你的工作带来帮助。文章内容你觉得有用，可以<strong>点赞</strong>支持一下~</p>
<p>如果屏幕前的读者，你有更好的「前端性能优化」策略，欢迎在评论区发表你的观点。</p></div></div>