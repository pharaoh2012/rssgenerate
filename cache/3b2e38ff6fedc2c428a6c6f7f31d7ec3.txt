
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lori/p/18991485" title="发布于 2025-07-18 14:48">
    <span role="heading" aria-level="2">apisix~proxy-rewrite 的 regex_uri 深度解析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="apisix-路由正则与-proxy-rewrite-的-regex_uri-深度解析">APISIX 路由正则与 proxy-rewrite 的 regex_uri 深度解析</h1>
<p>在 APISIX 中，<code>proxy-rewrite</code> 插件的 <code>regex_uri</code> 功能是实现复杂路由重写的核心工具。下面我将全面总结各种转发场景的使用方法和技巧。</p>
<h2 id="regex_uri-基础语法">regex_uri 基础语法</h2>
<pre><code class="language-lua">"regex_uri": ["匹配正则", "替换模板"]
</code></pre>
<ul>
<li><strong>匹配正则</strong>：PCRE 格式的正则表达式</li>
<li><strong>替换模板</strong>：使用 <code>$1</code>, <code>$2</code> 等引用捕获组</li>
</ul>
<h2 id="常见转发场景总结">常见转发场景总结</h2>
<h3 id="场景-1简单前缀替换">场景 1：简单前缀替换</h3>
<pre><code class="language-json">"regex_uri": ["^/api/v1/(.*)", "/backend/$1"]
</code></pre>
<p>请求转换：</p>
<ul>
<li><code>/api/v1/users</code> → <code>/backend/users</code></li>
<li><code>/api/v1/products/123</code> → <code>/backend/products/123</code></li>
</ul>
<h3 id="场景-2多段路径重组">场景 2：多段路径重组</h3>
<pre><code class="language-json">"regex_uri": ["^/user/([^/]+)/profile/(.*)", "/profile/$1/$2"]
</code></pre>
<p>请求转换：</p>
<ul>
<li><code>/user/john/profile/settings</code> → <code>/profile/john/settings</code></li>
<li><code>/user/mary/profile/preferences</code> → <code>/profile/mary/preferences</code></li>
</ul>
<h3 id="场景-3版本号升级">场景 3：版本号升级</h3>
<pre><code class="language-json">"regex_uri": ["^/v1/(.*)", "/v2/$1"]
</code></pre>
<p>请求转换：</p>
<ul>
<li><code>/v1/orders</code> → <code>/v2/orders</code></li>
<li><code>/v1/inventory/items</code> → <code>/v2/inventory/items</code></li>
</ul>
<h3 id="场景-4路径参数提取">场景 4：路径参数提取</h3>
<pre><code class="language-json">"regex_uri": ["^/product/(\\d+)/detail", "/items/$1"]
</code></pre>
<p>请求转换：</p>
<ul>
<li><code>/product/123/detail</code> → <code>/items/123</code></li>
<li><code>/product/456/detail</code> → <code>/items/456</code></li>
</ul>
<h3 id="场景-5多条件组合匹配">场景 5：多条件组合匹配</h3>
<pre><code class="language-json">"regex_uri": ["^/(user|product)/(create|delete)/([a-z]+)", "/action/$2/$1/$3"]
</code></pre>
<p>请求转换：</p>
<ul>
<li><code>/user/create/account</code> → <code>/action/create/user/account</code></li>
<li><code>/product/delete/item</code> → <code>/action/delete/product/item</code></li>
</ul>
<h3 id="场景-6保留查询参数">场景 6：保留查询参数</h3>
<pre><code class="language-json">"regex_uri": ["^/search/(.*)", "/query/$1"]
</code></pre>
<p>请求转换：</p>
<ul>
<li><code>/search/books?category=sci-fi</code> → <code>/query/books?category=sci-fi</code></li>
<li><code>/search/movies?year=2023</code> → <code>/query/movies?year=2023</code></li>
</ul>
<h3 id="场景-7路径规范化">场景 7：路径规范化</h3>
<pre><code class="language-json">"regex_uri": ["^/([a-z]{2})/([a-z]+)/?$", "/$2/$1"]
</code></pre>
<p>请求转换：</p>
<ul>
<li><code>/en/home</code> → <code>/home/en</code></li>
<li><code>/es/about</code> → <code>/about/es</code></li>
</ul>
<h3 id="场景-8复杂重写模式">场景 8：复杂重写模式</h3>
<pre><code class="language-json">"regex_uri": ["^/(?:api|service)/v(\\d+)/(.*)", "/v$1/$2"]
</code></pre>
<p>请求转换：</p>
<ul>
<li><code>/api/v2/users</code> → <code>/v2/users</code></li>
<li><code>/service/v3/products</code> → <code>/v3/products</code></li>
</ul>
<h2 id="高级应用场景">高级应用场景</h2>
<h3 id="场景-9条件重写配合-vars">场景 9：条件重写（配合 vars）</h3>
<pre><code class="language-json">"plugins": {
    "proxy-rewrite": {
        "regex_uri": ["^/user/(.*)", "/$1"],
        "vars": [
            ["http_x_api_version", "==", "v2"]
        ]
    }
}
</code></pre>
<p>仅当请求头 <code>X-API-Version: v2</code> 时生效</p>
<h3 id="场景-10多重正则组合">场景 10：多重正则组合</h3>
<pre><code class="language-json">"plugins": [
    {
        "proxy-rewrite": {
            "regex_uri": ["^/api/", "/"]
        }
    },
    {
        "proxy-rewrite": {
            "regex_uri": ["^/v1/", "/v2/"]
        }
    }
]
</code></pre>
<p>分阶段重写：</p>
<ol>
<li><code>/api/v1/users</code> → <code>/v1/users</code></li>
<li><code>/v1/users</code> → <code>/v2/users</code></li>
</ol>
<h3 id="场景-11正则与直接-uri-重写结合">场景 11：正则与直接 URI 重写结合</h3>
<pre><code class="language-json">"plugins": {
    "proxy-rewrite": {
        "uri": "/new-base",
        "regex_uri": ["^/old/(.*)", "/$1"]
    }
}
</code></pre>
<p>组合效果：</p>
<ul>
<li><code>/old/path</code> → <code>/new-base/path</code></li>
<li><code>/other</code> → <code>/new-base/other</code></li>
</ul>
<h2 id="性能优化技巧">性能优化技巧</h2>
<ol>
<li>
<p><strong>非捕获组优化</strong>：使用 <code>(?:)</code> 代替 <code>()</code> 避免不必要的捕获</p>
<pre><code class="language-json">"regex_uri": ["^/(?:api|service)/v(\\d+)/(.*)", "/v$1/$2"]
</code></pre>
</li>
<li>
<p><strong>避免贪婪匹配</strong>：使用 <code>.*?</code> 代替 <code>.*</code> 防止过度匹配</p>
<pre><code class="language-json">"regex_uri": ["^/category/(.*?)/(detail)", "/$2/$1"]
</code></pre>
</li>
<li>
<p><strong>精确锚定</strong>：使用 <code>^</code> 和 <code>$</code> 限定匹配范围</p>
<pre><code class="language-json">"regex_uri": ["^/exact/path$", "/new/exact"]
</code></pre>
</li>
</ol>
<h2 id="调试与测试方法">调试与测试方法</h2>
<h3 id="1-使用-curl-测试">1. 使用 curl 测试</h3>
<pre><code class="language-bash">curl "http://127.0.0.1:9080/apisix/admin/plugin_metadata/proxy-rewrite" \
-H "X-API-KEY: your-admin-key" -X PUT -d '
{
    "regex_uri_debug": true
}'
</code></pre>
<h3 id="2-日志分析">2. 日志分析</h3>
<p>在 error.log 中查看匹配详情：</p>
<pre><code class="language-log">2023/10/15 14:30:22 [debug] regex_uri match: pattern=^/api/(.*), uri=/api/v1/users, matches=1
2023/10/15 14:30:22 [debug] regex_uri replace: /api/v1/users -&gt; /v1/users
</code></pre>
<h3 id="3-单元测试lua">3. 单元测试（Lua）</h3>
<pre><code class="language-lua">local rewrite = require("apisix.plugins.proxy-rewrite")
local ctx = {var = {uri = "/old/path"}}

rewrite.rewrite({regex_uri = {"^/old/(.*)", "/new/$1"}}, ctx)
ngx.say(ctx.var.uri) -- 输出: /new/path
</code></pre>
<h2 id="常见问题解决方案">常见问题解决方案</h2>
<h3 id="问题-1正则不匹配">问题 1：正则不匹配</h3>
<p><strong>解决方案</strong>：</p>
<ol>
<li>使用在线正则测试器验证（如 regex101.com）</li>
<li>添加调试日志 <code>regex_uri_debug: true</code></li>
<li>简化正则表达式，分步测试</li>
</ol>
<h3 id="问题-2特殊字符转义">问题 2：特殊字符转义</h3>
<p><strong>正确写法</strong>：</p>
<pre><code class="language-json">"regex_uri": ["^/search\\?q=(.+)", "/query/$1"]
</code></pre>
<h3 id="问题-3保留原始路径">问题 3：保留原始路径</h3>
<pre><code class="language-json">"regex_uri": ["", "$0"] -- 保留完整原始路径
</code></pre>
<h3 id="问题-4大小写敏感问题">问题 4：大小写敏感问题</h3>
<pre><code class="language-json">"regex_uri": ["(?i)^/api/(.*)", "/$1"] -- 忽略大小写
</code></pre>
<h2 id="最佳实践">最佳实践</h2>
<ol>
<li>
<p><strong>路径标准化</strong>：在网关层统一路径格式</p>
<pre><code class="language-json">"regex_uri": ["^/[A-Z]+/(.*)", "/${lower($1)}"]
</code></pre>
</li>
<li>
<p><strong>版本控制</strong>：无缝升级 API 版本</p>
<pre><code class="language-json">"regex_uri": ["^/v1/(.*)", "/v2/$1"]
</code></pre>
</li>
<li>
<p><strong>多租户支持</strong>：</p>
<pre><code class="language-json">"regex_uri": ["^/([a-z0-9]+)/api/(.*)", "/tenants/$1/$2"]
</code></pre>
</li>
<li>
<p><strong>A/B 测试路由</strong>：</p>
<pre><code class="language-json">"regex_uri": ["^/service/(.*)", "/service-v2/$1"],
"vars": [["http_x_test_group", "==", "B"]]
</code></pre>
</li>
<li>
<p><strong>协议升级重定向</strong>：</p>
<pre><code class="language-json">"plugins": {
    "proxy-rewrite": {
        "regex_uri": ["^(.*)", "https://new-domain.com$1"],
        "scheme": "https"
    }
}
</code></pre>
</li>
</ol>
<h2 id="性能对比表">性能对比表</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>复杂度</th>
<th>适用场景</th>
<th>性能影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>regex_uri</td>
<td>中-高</td>
<td>复杂路径转换</td>
<td>中（PCRE 编译）</td>
</tr>
<tr>
<td>uri 直接替换</td>
<td>低</td>
<td>简单前缀修改</td>
<td>低</td>
</tr>
<tr>
<td>多插件组合</td>
<td>高</td>
<td>分阶段处理</td>
<td>中-高</td>
</tr>
<tr>
<td>Nginx 原生 rewrite</td>
<td>中</td>
<td>深度定制</td>
<td>最低</td>
</tr>
</tbody>
</table>
<blockquote>
<p>建议：简单场景使用 <code>uri</code> 直接替换，复杂场景使用 <code>regex_uri</code></p>
</blockquote>
<h2 id="自己项目中的使用">自己项目中的使用</h2>
<p><strong>1. 静态改写，不需要正则</strong></p>
<pre><code> "proxy-rewrite": {
      "uri": "/auth/realms/xx/protocol/openid-connect/token/introspect"
  }
</code></pre>
<p><strong>2. 表达url一级路径的文件名，扩展名是.txt，例如:<a href="http://www.sina.com/1.txt" target="_blank" rel="noopener nofollow">http://www.sina.com/1.txt</a></strong></p>
<pre><code>"proxy-rewrite": {
      "regex_uri": [
        "^/([^/]+\\.txt)$",
        "/auth/$1"
      ]
    }
</code></pre>
<p><strong>3. 按前缀进行替换</strong></p>
<pre><code>"proxy-rewrite": {
    "regex_uri": [
        "^/user-xx(/.*)",
        "$1"
      ]
    }
</code></pre>
<p><strong>4. 以某个前缀开头的，在转发时，在前缀前面添加固定字符，下面添加了apim-es到apim-admin的前面</strong></p>
<pre><code>"proxy-rewrite": {
     "regex_uri": [
        "\"^/apim-admin/(.*)\"",
        "/apim-es/$1"
      ]
    }
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p></p>
<div class="navgood">
<p>作者：仓储大叔，张占岭，<br>
荣誉：微软MVP<br>QQ：853066980</p>

<p><strong>支付宝扫一扫，为大叔打赏!</strong>
<br><img src="https://images.cnblogs.com/cnblogs_com/lori/237884/o_IMG_7144.JPG"></p>
</div>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-18 14:48">2025-07-18 14:48</span>&nbsp;
<a href="https://www.cnblogs.com/lori">张占岭</a>&nbsp;
阅读(<span id="post_view_count">65</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18991485);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18991485', targetLink: 'https://www.cnblogs.com/lori/p/18991485', title: 'apisix~proxy-rewrite 的 regex_uri 深度解析' })">举报</a>
</div>
        