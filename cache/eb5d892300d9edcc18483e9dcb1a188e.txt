
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18950201" title="发布于 2025-06-26 15:36">
    <span role="heading" aria-level="2">【设计模式】单例模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="单例模式深度解析从基础到实现原理">单例模式深度解析：从基础到实现原理</h2>
<h3 id="一单例模式核心概念">一、单例模式核心概念</h3>
<p>单例模式是一种创建型设计模式，<strong>确保一个类只有一个实例，并提供该实例的全局访问点</strong>。这种模式的核心价值在于：</p>
<ul>
<li>✅ 避免资源冲突（如配置文件、数据库连接池）</li>
<li>✅ 节省系统资源开销</li>
<li>✅ 统一管理共享资源</li>
<li>✅ 控制全局访问点</li>
</ul>
<p><strong>典型应用场景</strong>：</p>
<ol>
<li>配置管理器（全局共享配置）</li>
<li>数据库连接池（避免重复创建连接）</li>
<li>日志记录器（统一管理日志写入）</li>
<li>设备驱动程序（如打印机控制）</li>
<li>缓存系统（全局共享缓存数据）</li>
</ol>
<h3 id="二单例模式实现方式大全">二、单例模式实现方式大全</h3>
<h4 id="1-饿汉式线程安全">1. 饿汉式（线程安全）</h4>
<pre><code class="language-java">public class EagerSingleton {
    private static final EagerSingleton INSTANCE = new EagerSingleton();
    
    private EagerSingleton() {
        // 防止反射攻击
        if (INSTANCE != null) {
            throw new IllegalStateException("Singleton already initialized");
        }
    }
    
    public static EagerSingleton getInstance() {
        return INSTANCE;
    }
}
</code></pre>
<ul>
<li>⚡ 优点：实现简单，线程安全</li>
<li>⚠️ 缺点：类加载时即初始化，可能造成资源浪费</li>
</ul>
<h4 id="2-懒汉式非线程安全">2. 懒汉式（非线程安全）</h4>
<pre><code class="language-java">public class LazySingleton {
    private static LazySingleton instance;
    
    private LazySingleton() {}
    
    public static LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
</code></pre>
<ul>
<li>⚡ 优点：延迟初始化</li>
<li>⚠️ 缺点：多线程环境下不安全</li>
</ul>
<h4 id="3-同步方法懒汉式线程安全">3. 同步方法懒汉式（线程安全）</h4>
<pre><code class="language-java">public class SynchronizedSingleton {
    private static SynchronizedSingleton instance;
    
    private SynchronizedSingleton() {}
    
    public static synchronized SynchronizedSingleton getInstance() {
        if (instance == null) {
            instance = new SynchronizedSingleton();
        }
        return instance;
    }
}
</code></pre>
<ul>
<li>⚡ 优点：线程安全</li>
<li>⚠️ 缺点：每次获取实例都加锁，性能差</li>
</ul>
<h4 id="4-双重检查锁dcl">4. 双重检查锁（DCL）</h4>
<pre><code class="language-java">public class DoubleCheckedLockingSingleton {
    private static volatile DoubleCheckedLockingSingleton instance;
    
    private DoubleCheckedLockingSingleton() {}
    
    public static DoubleCheckedLockingSingleton getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckedLockingSingleton.class) {
                if (instance == null) {
                    instance = new DoubleCheckedLockingSingleton();
                }
            }
        }
        return instance;
    }
}
</code></pre>
<ul>
<li>⚡ 优点：线程安全且高性能</li>
<li>⚠️ 注意：必须使用<code>volatile</code>防止指令重排序</li>
</ul>
<h4 id="5-静态内部类推荐">5. 静态内部类（推荐）</h4>
<pre><code class="language-java">public class StaticInnerClassSingleton {
    private StaticInnerClassSingleton() {}
    
    private static class Holder {
        static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();
    }
    
    public static StaticInnerClassSingleton getInstance() {
        return Holder.INSTANCE;
    }
    
    // 防止反序列化破坏单例
    protected Object readResolve() {
        return getInstance();
    }
}
</code></pre>
<h4 id="6-枚举单例最佳实践">6. 枚举单例（最佳实践）</h4>
<pre><code class="language-java">public enum EnumSingleton {
    INSTANCE;
    
    // 添加业务方法
    public void businessMethod() {
        System.out.println("Business logic executed");
    }
}
</code></pre>
<h3 id="三静态内部类原理深度剖析">三、静态内部类原理深度剖析</h3>
<p>静态内部类实现之所以<strong>无需同步开销</strong>，关键在于利用了Java类加载机制的天然线程安全性：</p>
<h4 id="-核心机制jvm的类初始化锁">🔍 核心机制：JVM的类初始化锁</h4>
<p>Java虚拟机规范明确规定：</p>
<blockquote>
<p><strong>每个类都有唯一的初始化锁</strong>。类初始化由JVM隐式加锁，确保多线程环境下只执行一次初始化。</p>
</blockquote>
<p><strong>实现原理</strong>：</p>
<pre><code class="language-java">public class Singleton {
    private Singleton() {}
    
    private static class Holder {
        static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return Holder.INSTANCE; // 触发类加载
    }
}
</code></pre>
<h4 id="-无同步开销的底层原理">✨ 无同步开销的底层原理</h4>
<ol>
<li>
<p><strong>延迟加载时机</strong><br>
<code>Holder</code>类在首次调用<code>getInstance()</code>时才会被加载</p>
</li>
<li>
<p><strong>类初始化锁机制</strong></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>多线程场景</th>
<th>JVM行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>线程A首次调用<code>getInstance()</code></td>
<td>触发<code>Holder</code>类加载</td>
<td>JVM获取类初始化锁</td>
</tr>
<tr>
<td>线程B同时调用<code>getInstance()</code></td>
<td>检测到<code>Holder</code>正在初始化</td>
<td>线程B阻塞</td>
</tr>
<tr>
<td>线程A完成初始化</td>
<td>释放锁</td>
<td></td>
</tr>
<tr>
<td>线程B被唤醒</td>
<td>发现类已初始化</td>
<td>直接返回实例</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>字节码验证</strong><br>
<code>getInstance()</code>方法的字节码中没有任何<code>monitorenter</code>/<code>monitorexit</code>指令（无同步锁操作）</p>
</li>
</ol>
<h4 id="️-同步机制对比">⚖️ 同步机制对比</h4>
<table>
<thead>
<tr>
<th>实现方式</th>
<th>同步机制</th>
<th>性能影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>同步方法懒汉式</td>
<td>方法级<code>synchronized</code></td>
<td>每次调用都加锁</td>
</tr>
<tr>
<td>双重检查锁</td>
<td>代码块<code>synchronized</code></td>
<td>首次创建后仍需读volatile</td>
</tr>
<tr>
<td><strong>静态内部类</strong></td>
<td><strong>JVM类初始化锁</strong></td>
<td><strong>仅首次加载时隐式同步</strong></td>
</tr>
</tbody>
</table>
<h4 id="️-jvm如何保证线程安全">🛡️ JVM如何保证线程安全</h4>
<p>根据Java语言规范（JLS §12.4.2）：</p>
<blockquote>
<p>类初始化阶段执行原子操作：</p>
<ol>
<li>获取类初始化锁</li>
<li>如果类正在初始化，则阻塞当前线程</li>
<li>如果类未初始化，执行静态初始化</li>
<li>释放锁并通知等待线程</li>
</ol>
</blockquote>
<h3 id="四单例模式防护措施">四、单例模式防护措施</h3>
<h4 id="1-反射攻击防护">1. 反射攻击防护</h4>
<pre><code class="language-java">private Singleton() {
    if (instance != null) {
        throw new IllegalStateException("Singleton already initialized");
    }
}
</code></pre>
<h4 id="2-反序列化防护">2. 反序列化防护</h4>
<pre><code class="language-java">// 在类中添加readResolve方法
protected Object readResolve() {
    return getInstance();
}
</code></pre>
<blockquote>
<p><strong>唯一完全防护方案</strong>：使用枚举单例（天然防反射和反序列化攻击）</p>
</blockquote>
<h3 id="五实现方式对比与最佳实践">五、实现方式对比与最佳实践</h3>
<table>
<thead>
<tr>
<th>实现方式</th>
<th>线程安全</th>
<th>延迟加载</th>
<th>防反射</th>
<th>防序列化</th>
<th>性能</th>
</tr>
</thead>
<tbody>
<tr>
<td>饿汉式</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td>懒汉式</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td>同步方法</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>⭐⭐</td>
</tr>
<tr>
<td>双重检查锁</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>⭐⭐⭐</td>
</tr>
<tr>
<td>静态内部类</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>枚举</strong></td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>⭐⭐⭐⭐</td>
</tr>
</tbody>
</table>
<p><strong>最佳实践建议</strong>：</p>
<ol>
<li>优先选择<strong>枚举实现</strong> - 简洁安全，满足大多数场景</li>
<li>需要延迟加载时选择<strong>静态内部类</strong> - 平衡性能和安全性</li>
<li>避免使用双重检查锁 - 除非明确理解内存模型细节</li>
<li>谨慎使用单例 - 过度使用会导致代码耦合度高</li>
</ol>
<h3 id="六总结">六、总结</h3>
<p>单例模式通过控制实例化过程，为系统提供了统一的访问入口，是管理共享资源的利器。关键要点：</p>
<ol>
<li><strong>静态内部类实现</strong>利用JVM类加载机制实现无锁线程安全</li>
<li><strong>枚举实现</strong>提供最全面的防护（反射+序列化）</li>
<li>所有实现都需考虑反射和序列化的防护</li>
<li>根据实际需求在安全性和性能间取得平衡</li>
</ol>
<blockquote>
<p>📌 <strong>设计警示</strong>：单例模式虽好，但不要滥用。在需要真正全局唯一实例时才使用，否则会增加系统耦合度和测试难度。</p>
</blockquote>
<div class="mermaid">graph TD
    A[需要单例吗？] --&gt; B{需要延迟加载？}
    B --&gt;|是| C{需要防御反射/序列化？}
    B --&gt;|否| D[使用枚举实现]
    C --&gt;|是| D
    C --&gt;|否| E[使用静态内部类]
    D --&gt; F[实现完成]
    E --&gt; F
</div><p>通过深入理解各种实现方式的原理和适用场景，开发者可以做出更明智的设计决策，构建出既安全又高效的系统架构。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-26 15:36">2025-06-26 15:36</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">12</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18950201);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18950201', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18950201', title: '【设计模式】单例模式' })">举报</a>
</div>
        