
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/guoxiaoyu/p/18688171" title="发布于 2025-02-10 08:57">
    <span role="heading" aria-level="2">WebClient  获取不到请求体如何破解？</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>起初在开发过程中，我遇到了一个困扰我的问题：当我将对象转换为JSON时，得到的结果与最终传给第三方接口的请求体并不一致。这个问题导致我在进行加密操作时出现了错误，因为加密的过程是基于请求体的，而请求体又受到不同因素的影响。因此，我希望能在类内部直接获取到请求体（body），以便进行加密。</p>
<p>然而，在查阅了一番资料后，发现 WebClient 并没有直接提供获取请求体的接口。即使我强行实现这一功能，过程也会相当繁琐。经过一番深思熟虑，我决定采用曲线救国的方法来解决这一问题。接下来，我将详细分享我是如何绕过这个困难并顺利解决问题的。</p>
<h1 id="破局">破局</h1>
<p>首先，问题的根源在于双方请求体的JSON转换结果不一致，导致加密过程中的报错。按照逻辑，既然加密是基于请求体进行的，而请求体的格式在转换时已经出现了问题，那是不是可以直接将我自己已经转换好的JSON数据传递给第三方接口呢？</p>
<p>这样一来，就不再需要纠结于双方请求体转换过程中不一致的原因和细节，避免了因各种差异性带来的困扰。</p>
<pre><code class="language-java">MultiValueMap&lt;String, String&gt; jsonContentHeaders = hunYuanAuthApi.getHttpHeadersConsumer(HunYuanConstants.DEFAULT_CHAT_ACTION,chatRequest);
        return this.webClient.post().uri("/").headers(headers -&gt; {
                headers.addAll(jsonContentHeaders);
            })
            .bodyValue(ModelOptionsUtils.toJsonString(chatRequest))
//            .body(Mono.just(chatRequest), ChatCompletionRequest.class)
            .retrieve()
            .bodyToFlux(String.class);
</code></pre>
<p>我之前在代码中使用的是 <code>body(Mono.just(chatRequest), ChatCompletionRequest.class)</code> 方法，其中传递的是一个对象，但这样做存在问题。后来我调整了代码，改为直接使用在加密时的转 JSON 方法，将数据转换成 JSON 格式再传递，结果完美解决了问题。</p>
<p>有些人可能想要去读取请求体，无非就是想打印数据，这里可以直接使用打印，并将数据传递过去即可。如果需求不仅限于打印请求体，且还希望获取一些额外的信息，例如请求头中的数据，那么在这种情况下，你可以考虑使用过滤器的方式来实现。具体的实现方法如下所示：</p>
<pre><code class="language-java">ExchangeFilterFunction filter = ExchangeFilterFunction.ofRequestProcessor(request -&gt; {
    //打印头和cookie
    logger.info("Request Headers: {}", request.headers());
    logger.info("Request Cookies: {}", request.cookies());
    return Mono.just(request);
});

this.webClient = WebClient.builder().baseUrl(baseUrl).filter(filter).defaultHeaders(jsonContentHeaders).build();
</code></pre>
<p>这个方法本身并不能直接打印请求体（body）参数，因为它的作用范围主要限于处理请求的元数据。</p>
<p>如果你还是执着于如何获取请求体方法，也不妨可以看看这里，解决方法确实很费劲。我也没有亲自尝试一下，地址如下：<a href="https://stackoverflow.com/questions/45240005/how-to-log-request-and-response-bodies-in-spring-webflux" target="_blank" rel="noopener nofollow">https://stackoverflow.com/questions/45240005/how-to-log-request-and-response-bodies-in-spring-webflux</a></p>
<p>起初我依赖传统的方式处理请求体，但最终却发现这些方法并不适用。经过反复思考和调整，我决定采取更加灵活的方式，直接传递已转换好的JSON数据，这一策略成功绕过了原本的问题。在解决这个问题的过程中面对复杂的技术难题，仅仅依赖常规的工具和方法并不足以高效解决问题。多尝试不同的解决方法是至关重要的。</p>
<hr>
<p>我是努力的小雨，一个正经的 Java 东北服务端开发，整天琢磨着 AI 技术这块儿的奥秘。特爱跟人交流技术，喜欢把自己的心得和大家分享。还当上了腾讯云创作之星，阿里云专家博主，华为云云享专家，掘金优秀作者。各种征文、开源比赛的牌子也拿了。</p>
<p>💡 想把我在技术路上走过的弯路和经验全都分享出来，给你们的学习和成长带来点启发，帮一把。</p>
<p>🌟 欢迎关注努力的小雨，咱一块儿进步！🌟</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.30650109010185184" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-10 08:58">2025-02-10 08:57</span>&nbsp;
<a href="https://www.cnblogs.com/guoxiaoyu">努力的小雨</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18688171" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18688171);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18688171', targetLink: 'https://www.cnblogs.com/guoxiaoyu/p/18688171', title: 'WebClient  获取不到请求体如何破解？' })">举报</a>
</div>
	