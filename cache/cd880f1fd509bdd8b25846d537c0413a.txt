
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18744568" title="发布于 2025-03-01 10:18">
    <span role="heading" aria-level="2">解决跨域问题的这6种方案，真香！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-什么事跨域问题">1 什么事跨域问题？</h2>
<p>很多小伙伴第一次遇到跨域问题，大概率会一脸懵逼：<strong>“我后端接口明明通了，Postman也能调，为啥浏览器就报红字？”</strong></p>
<p><img src="https://files.mdnice.com/user/5303/da6289be-89aa-431a-bdd8-8da50d09f400.png" alt="" loading="lazy"></p>
<p>其实这事儿得怪浏览器的<strong>“同源策略”</strong>（Same-Origin Policy）。</p>
<p>简单说，浏览器觉得“不同源的请求都是耍流氓”。</p>
<p>比如你的前端跑在http://localhost:8080。</p>
<p>而后端在https://api.xxx.com:8000。</p>
<p>只要<code>协议</code>、<code>域名</code>、<code>端口</code>任何一个不同，就会被浏览器直接掐断。</p>
<p>举个栗子🌰：</p>
<pre><code class="language-javascript">// 前端代码（http://localhost:8080）
fetch('http://api.xxx.com:8000/user')
  .then(res =&gt; res.json())
  .then(data =&gt; console.log(data));  
// 浏览器控制台报错：  
// Access to fetch from 'http://localhost:8080' has been blocked by CORS policy...
</code></pre>
<p>这时候，你就需要“跨域解决方案”来帮浏览器松绑了！</p>
<p>那么，如何解决跨域问题呢？</p>
<h2 id="2-解决跨域问题的方案">2 解决跨域问题的方案</h2>
<h3 id="21-cors跨域资源共享">2.1 CORS（跨域资源共享）</h3>
<p><strong>适用场景</strong>：前后端分离项目、接口需要兼容多种客户端。</p>
<p>CORS是W3C标准，后端只需在响应头里加几个字段，告诉浏览器<strong>“这个接口我允许谁访问”</strong>。</p>
<p><strong>后端代码示例（Spring Boot版）</strong>：</p>
<pre><code class="language-java">// 方法1：直接怼注解（适合单个接口）
@CrossOrigin(origins = "http://localhost:8080")
@GetMapping("/user")
public User getUser() { ... }

// 方法2：全局配置（一劳永逸）
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:8080")
                .allowedMethods("*")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
</code></pre>
<p><strong>关键响应头</strong>：</p>
<ul>
<li>Access-Control-Allow-Origin: <a href="http://localhost:8080" target="_blank" rel="noopener nofollow">http://localhost:8080</a>（允许的源）</li>
<li>Access-Control-Allow-Methods: GET,POST（允许的方法）</li>
<li>Access-Control-Allow-Credentials: true（允许带Cookie）</li>
</ul>
<p><strong>注意坑点</strong>：</p>
<ul>
<li>如果用了<code>allowCredentials(true)</code>，<code>allowedOrigins</code>不能为<code>*</code>（必须明确指定域名）。</li>
<li>复杂请求（比如Content-Type是<code>application/json</code>）会先发一个<strong>OPTIONS预检请求</strong>，记得处理！</li>
</ul>
<h3 id="22-jsonp">2.2 JSONP</h3>
<p><strong>适用场景</strong>：老项目兼容、只支持GET请求（比如调用第三方地图API）。</p>
<p>JSONP利用<strong><code>&lt;script&gt;</code>标签没有跨域限制</strong>的特性，让后端返回一段JS代码。</p>
<p><strong>前端代码</strong>：</p>
<pre><code class="language-javascript">function handleUserData(data) {
    console.log("收到数据：", data);
}

// 动态创建script标签
const script = document.createElement('script');
script.src = 'http://api.xxx.com:8000/user?callback=handleUserData';
document.body.appendChild(script);
</code></pre>
<p><strong>后端代码</strong>：</p>
<pre><code class="language-java">@GetMapping("/user")
public String jsonp(@RequestParam String callback) {
    User user = new User("Tony", 30);
    // 把数据包进回调函数里
    return callback + "(" + new Gson().toJson(user) + ")";
}
</code></pre>
<p><strong>输出结果</strong>：</p>
<pre><code class="language-javascript">handleUserData({"name":"Tony","age":30})  
</code></pre>
<p><strong>缺点</strong>：</p>
<ul>
<li>只支持GET（传参长度有限）。</li>
<li>容易被XSS攻击（毕竟得信任第三方脚本）。</li>
</ul>
<h3 id="23-nginx反向代理">2.3 Nginx反向代理</h3>
<p><strong>适用场景</strong>：生产环境部署、微服务网关统一处理。</p>
<p>直接把跨域问题甩给Nginx，让浏览器以为所有请求都是<strong>同源</strong>的。</p>
<p><strong>Nginx配置示例</strong>：</p>
<pre><code class="language-nginx">server {
    listen 80;
    server_name localhost;

    location /api {
        # 转发到真实后端
        proxy_pass http://api.xxx.com:8000;
        # 解决跨域
        add_header 'Access-Control-Allow-Origin' 'http://localhost:8080';
        add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS';
        add_header 'Access-Control-Allow-Headers' 'Content-Type';
    }
}
</code></pre>
<p>此时前端请求地址改成<strong>同源</strong>：</p>
<pre><code class="language-javascript">fetch('/api/user')  // 实际访问 http://localhost/api/user → 被Nginx转发
</code></pre>
<p><strong>优点</strong>：</p>
<ul>
<li>前后端代码零侵入。</li>
<li>能隐藏真实接口地址（安全加分）。</li>
</ul>
<h3 id="24-网关层统一处理">2.4 网关层统一处理</h3>
<p><strong>适用场景</strong>：Spring Cloud Gateway、Kong等API网关。</p>
<p>和Nginx思路类似，但更适合微服务场景，直接在网关层加CORS配置。</p>
<p><strong>Spring Cloud Gateway配置</strong>：</p>
<pre><code class="language-yaml">spring:
  cloud:
    gateway:
      globalcors:
        cors-configurations:
          '[/**]':
            allowed-origins: "http://localhost:8080"
            allowed-methods: "*"
            allowed-headers: "*"
            allow-credentials: true
</code></pre>
<h3 id="25-websocket">2.5 WebSocket</h3>
<p><strong>适用场景</strong>：实时通信需求（聊天室、股票行情）。</p>
<p>WebSocket协议没有跨域限制（因为握手阶段走HTTP，后续升级为长连接）。</p>
<p><strong>前端代码</strong>：</p>
<pre><code class="language-javascript">const socket = new WebSocket('ws://api.xxx.com:8000/ws');
socket.onmessage = (event) =&gt; {
    console.log('收到消息：', event.data);
};
</code></pre>
<p><strong>后端代码（Spring Boot）</strong>：</p>
<pre><code class="language-java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new MyWebSocketHandler(), "/ws");
    }
}
</code></pre>
<h3 id="26-postmessage">2.6 PostMessage</h3>
<p><strong>适用场景</strong>：页面与iframe、弹窗之间的跨域通信。</p>
<p>通过<code>window.postMessage</code>实现不同窗口间的数据传递。</p>
<p><strong>父页面（<a href="http://parent.com" target="_blank" rel="noopener nofollow">http://parent.com</a>）</strong>：</p>
<pre><code class="language-javascript">const childWindow = window.open('http://child.com');
childWindow.postMessage('我是你爹', 'http://child.com');
</code></pre>
<p><strong>子页面（<a href="http://child.com" target="_blank" rel="noopener nofollow">http://child.com</a>）</strong>：</p>
<pre><code class="language-javascript">window.addEventListener('message', (event) =&gt; {
    if (event.origin !== 'http://parent.com') return; // 验证来源
    console.log('收到爹的消息：', event.data);
});
</code></pre>
<h2 id="总结">总结</h2>
<ul>
<li><strong>简单粗暴</strong>：开发环境用CORS注解。</li>
<li><strong>生产环境</strong>：优先Nginx/网关统一处理，避免每个服务配一遍。</li>
<li><strong>老项目兼容</strong>：JSONP勉强能用，但别长期依赖。</li>
<li><strong>实时场景</strong>：直接上WebSocket，顺便解决通信问题。</li>
<li><strong>安全第一</strong>：<code>Access-Control-Allow-Origin</code>尽量别写<code>*</code>，白名单要用精确域名。</li>
</ul>
<p>最后提醒温馨提醒一下：跨域问题本质是<strong>浏览器行为</strong>，和HTTP协议无关。</p>
<p>如果你用Postman，发送curl请求，测试没问题，但浏览器报错，别怀疑人生，这可能是前端的锅！</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.026945244519675927" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-01 10:18">2025-03-01 10:18</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18744568" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18744568);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18744568', targetLink: 'https://www.cnblogs.com/12lisu/p/18744568', title: '解决跨域问题的这6种方案，真香！' })">举报</a>
</div>
        