<!----> <meta itemprop="headline" content="😮😮😮 我写出了被 Threejs 官推转发的项目🚀✨？！"> <meta itemprop="keywords" content="前端,开源,three.js"> <meta itemprop="datePublished" content="2025-04-30T09:18:45.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="何贤"> <meta itemprop="url" content="https://juejin.cn/user/277499952247869"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-5111268e="">
            😮😮😮 我写出了被 Threejs 官推转发的项目🚀✨？！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-5111268e=""><div class="author-info-box" data-v-5111268e=""><div class="author-name" data-v-5111268e=""><a href="/user/277499952247869/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-5111268e=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    何贤
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-5111268e=""><time datetime="2025-04-30T09:18:45.000Z" title="Wed Apr 30 2025 09:18:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-5111268e="">
                    2025-04-30
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-5111268e=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-5111268e=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-5111268e=""></circle></svg> <span class="views-count" data-v-5111268e="">
                    10,644
                  </span> <span class="read-time" data-v-5111268e=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-5111268e=""><rect width="16" height="16" fill="none" data-v-5111268e=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-5111268e=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-5111268e=""></path></svg>
                    阅读27分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-5111268e=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-5111268e=""><div class="article-viewer markdown-body cache result"><h2 data-id="heading-0">0.前置条件</h2>
<p>hello! 欢迎阅读本篇文章！这篇文章会探讨如何高定制化地构建一个自己喜欢的 3D 场景。我们将深入探讨 <code>Three.js</code>、<code>Shader(GLSL)</code>、<code>Cursor rules &amp; MCP Servers</code> 以及 <code>2D &amp; 3D 定制化资源获取</code>等技术领域。</p>
<p>在开始之前，请确保您已经具备以下基础知识：</p>
<p><strong>1. Three.js 基础</strong></p>
<ul>
<li>核心概念掌握：
<ul>
<li>场景（<code>Scene</code>）：3D 空间的容器</li>
<li>相机（<code>Camera</code>）：观察场景的视角</li>
<li>渲染器（<code>Renderer</code>）：将 3D 场景绘制到屏幕</li>
<li>几何体（<code>Geometry</code>）：物体的形状定义</li>
<li>材质（<code>Material</code>）：物体的外观特性</li>
<li>网格（<code>Mesh</code>）：几何体和材质的组合</li>
</ul>
</li>
</ul>
<p>推荐学习资源：<a href="https://link.juejin.cn?target=https%3A%2F%2Fbruno-simon.com%2F" target="_blank" title="https://bruno-simon.com/" ref="nofollow noopener noreferrer">Bruno Simon</a> 的 <code>threejs-journey</code> 课程是非常优秀的入门教程。如果您希望了解我的个人学习路径，欢迎在评论区留言，当评论数达到一定程度时，我会专门撰写一篇详细的学习路线指南。<strong>并且这篇文章所展示的作品会参加 Threejs-journey在今年5月的作品挑战，第一名会得到一个免费的threejs-journey，我相信这个作品会得到好的名次，并且承诺获得的任何奖品将会在下一篇文章或者沸点评论区中抽取一个已关注的读者赠予</strong></p>
<p><strong>2. Shader 编程基础</strong></p>
<ul>
<li>GLSL（OpenGL Shading Language）基础：
<ul>
<li>顶点着色器（Vertex Shader）：处理顶点位置和属性</li>
<li>片元着色器（Fragment Shader）：处理像素颜色和效果</li>
<li>Three.js 中的自定义着色器实现</li>
</ul>
</li>
</ul>
<h2 data-id="heading-1">1. Page 预览</h2>
<p>话说这天老何在准备去就业市场上看看自己几斤几两, 就和以前还有联系的老同学要了下他们公司 <code>HR</code> 的微信。把简历和个人网站发过去了。在经过10分钟的漫长等待后，我得到了以下尴尬的画面</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7a030f75ab254c42be138ea3e7987e9c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=bTWlmuYcMriGF6I2bOolHzAUfiw%3D" alt="01.png" loading="lazy"></p>
<p>那么让我们进入正题，究竟是什么样的网站能够让 HR 小姐姐对吴彦祖的关切问候置之不理(指 "还在吗?")</p>
<p>这次展示的内容有点多，请见谅 <em>(tips:靠近带感叹号的物体按下F有惊喜哦)</em></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ffc9bb516b7d4c81aaa53baf4ad585d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=Sra7him3V1DATbYV0kfWqvDn32M%3D" alt="03.png" loading="lazy"></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/805be880ec9949ebb3e19d0fd7ede67a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=GiLuZj%2F8qF4EAJ%2BsXARpyS3SWyY%3D" alt="111.png" loading="lazy"></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cfaa15789f244d4c86aab6116fc475c4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=NxtLq9ZtkYYm7Uj4pR49XHEA5tY%3D" alt="03.gif" loading="lazy"></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fisland.vercel.app%2F" target="_blank" title="https://island.vercel.app/" ref="nofollow noopener noreferrer">PC端在线预览地址(需要魔法）</a>:<a href="https://link.juejin.cn?target=https%3A%2F%2Fisland.vercel.app%2F" target="_blank" title="https://island.vercel.app/" ref="nofollow noopener noreferrer">island.vercel.app/</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fisland.vercel.app%2F%23debug" target="_blank" title="https://island.vercel.app/#debug" ref="nofollow noopener noreferrer">PC端在线调试界面(需要魔法）</a>:<a href="https://link.juejin.cn?target=https%3A%2F%2Fisland.vercel.app%2F%23debug" target="_blank" title="https://island.vercel.app/#debug" ref="nofollow noopener noreferrer">island.vercel.app/#debug</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FhexianWeb%2Fisland" target="_blank" title="https://github.com/hexianWeb/island" ref="nofollow noopener noreferrer">源码地址(需要魔法）</a>:<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FhexianWeb%2Fisland" target="_blank" title="https://github.com/hexianWeb/island" ref="nofollow noopener noreferrer">github.com/hexianWeb/i…</a></p>
<p><strong>Threejs 转发贴</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2132622d9c7d4e2fa123709d41e43721~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=5dm0Z70PCK%2F1p5GPCLJZ4YzsBZA%3D" alt="81bfafe8aa9e447fb28581008db7dd63_tplv-k3u1fbpfcp-jj-mark-v1_0_0_0_0_5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk_q75.webp" loading="lazy"></p>
<h2 data-id="heading-2">2. 2D &amp; 3D 资源获取</h2>
<p>如果在以前，很难想象这仅仅是一个对建模以及图形设计一知半解的普通程序员能写出的场景。但现在是  AI 时代 （只不过大部分是 AI 拿鞭子抽我，而不是我拿鞭子抽 AI）。所以在低于平均水平的地方统统由<code>AI</code>接管。</p>
<p>对于简单场景，资源获取类型分为两类，分别是 2D 资源 &amp; 3D 资源。普通通过资源网站上搜索以及下载的方式我不做过多介绍，详细介绍客制化资源获取 &amp; 处理方式。</p>
<p>3D <strong>lowpoly</strong> 风格模型网站</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarket.pmnd.rs%2F" target="_blank" title="https://market.pmnd.rs/" ref="nofollow noopener noreferrer">market.pmnd.rs/</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.kenney.nl%2Fassets" target="_blank" title="https://www.kenney.nl/assets" ref="nofollow noopener noreferrer">www.kenney.nl/assets</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzsky2000.itch.io%2F" target="_blank" title="https://zsky2000.itch.io/" ref="nofollow noopener noreferrer">zsky2000.itch.io/</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fpoly.pizza%2F" target="_blank" title="https://poly.pizza/" ref="nofollow noopener noreferrer">poly.pizza/</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fsketchfab.com%2Fsearch%3Fq%3Dlowpoly%26type%3Dmodels" target="_blank" title="https://sketchfab.com/search?q=lowpoly&amp;type=models" ref="nofollow noopener noreferrer">sketchfab.com/search?q=lo…</a></li>
</ul>
<h3 data-id="heading-3">2.1 3D 客制化资源的获取与处理</h3>
<p>现在的 <code>3D AI generation</code> 技术逐渐趋于成熟，虽然远远达不到工业化以及正规生产环境的水平，但是用来做一些小demo还是没问题的。这里附上我经常使用的 AI 3D 模型生成平台 &amp; 生成工作流。</p>
<p>首先我们可以根据 <code>Blender</code> 资源库中有的模型资源利用任意 <code>文生图 or 图生图</code>模型为我们生成一个简易的游戏画面</p>
<p>就比如以下画面：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0991e5a6656749088bfb1d999c146ef1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=pki77a0C9LP0K5b0sOFYxJcdPU8%3D" alt="05.png" loading="lazy"></p>
<p>在确定场景风格和界面UI后，我们就可以开始着手场景搭建工作。在这个过程中，经常会遇到资源库中缺少所需元素的情况。对此，我是通过以下方式解决：</p>
<p>先利用如 <code>gpt-4o</code>等一些文生图模型来生成一个背景干净无杂物的 2.5 D lowpoly 风格视图。而在这一步给我最大帮助的是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjamez-bondos%2Fawesome-gpt4o-images" target="_blank" title="https://github.com/jamez-bondos/awesome-gpt4o-images" ref="nofollow noopener noreferrer">awesome-gpt4o-images</a> ，<strong>这可以帮助您即使不利用节点式图像生成平台也能生成统一风格且稳定的图片方式</strong></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0c6224a04aa44f0e88737f9c2ede1f64~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=ZXT0v8tx574inv8Ia%2B35v6L4gXo%3D" alt="06.gif" loading="lazy"></p>
<p>在这里我们参考 [案例 55：低多边形 (Low-Poly) 3D 渲染 (by <a href="https://link.juejin.cn?target=https%3A%2F%2Fx.com%2Fazed_ai" target="_blank" title="https://x.com/azed_ai" ref="nofollow noopener noreferrer">@azed_ai</a>)](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjamez-bondos%2Fawesome-gpt4o-images%3Ftab%3Dreadme-ov-file%23%25E6%25A1%2588%25E4%25BE%258B-55%25E4%25BD%258E%25E5%25A4%259A%25E8%25BE%25B9%25E5%25BD%25A2-low-poly-3d-%25E6%25B8%25B2%25E6%259F%2593-by-azed_ai" target="_blank" title="https://github.com/jamez-bondos/awesome-gpt4o-images?tab=readme-ov-file#%E6%A1%88%E4%BE%8B-55%E4%BD%8E%E5%A4%9A%E8%BE%B9%E5%BD%A2-low-poly-3d-%E6%B8%B2%E6%9F%93-by-azed_ai" ref="nofollow noopener noreferrer">github.com/jamez-bondo…</a>) 的提示词生成一个 <code>lowpoly</code>风格的马作为使用案例。相应的提示词为:</p>
<pre><code class="hljs language-bash" lang="bash">一个 [subject] 的低多边形 3D 渲染图，由干净的三角形面构成，具有平坦的 [color1] 和 [color2] 表面。环境是一个风格化的数字沙漠，具有极简的几何形状和环境光遮蔽效果。
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/981c532a928e43a384ab060f7d9b34e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=C8Y0tAn512T62J4jhkAYSgA4fGg%3D" alt="07.png" loading="lazy"></p>
<p>随后再将这个对应的马导入任意的 <code>AI 3D generation</code> 平台 (这里是后期的何贤： 您现在可以尝试 <a href="https://link.juejin.cn?target=https%3A%2F%2F3d.hunyuan.tencent.com%2F" target="_blank" title="https://3d.hunyuan.tencent.com/" ref="nofollow noopener noreferrer">混元 3D V2.5</a>,他提供较多的免费额度 每日20次)</p>
<p>随后你可以很快的到一个 <code>lowpoly</code>风格的小马雕塑</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c0b412411dad4c64a7368eb1fb53007c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=MeypES%2BQI1zT6hZIdcQP2MXLxbI%3D" alt="08.gif" loading="lazy"></p>
<p>这样一来，您就可以在确立统一风格的前提下获取自己需要的 3D 资源，而不是场景中充斥着各种风格迥异的 3D 模型</p>
<h3 data-id="heading-4">2.2 2D  客制化资源的获取与处理</h3>
<p>相信大家GPT-4o 有着出色的利用 4o 固有的知识库和聊天上下文（包括转换上传的图像或将其用作视觉灵感）统一风格客制化图片生成以及输出能力，这也是我经常使用的统一风格 UI 生成工具。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cf780f8d0bf84373b2ca707cae78a9ca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=ltzCN72NgJoxZ12HHU4Gq1ROXLo%3D" alt="04.png" loading="lazy"></p>
<p>以下是我生成 UI 素材的工作流：</p>
<p>首先我会确定我想要 UI 素材的风格，这里当然也可以通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjamez-bondos%2Fawesome-gpt4o-images" target="_blank" title="https://github.com/jamez-bondos/awesome-gpt4o-images" ref="nofollow noopener noreferrer">awesome-gpt4o-images</a> 生成。让我们先假设我很想要的是 <code>pixel</code> 像素化的 UI，那么我们可以根据以下这张图片作为参考让 <code>gpt-4o</code> 生成图片。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9a09aaa4b8164259b2b5a8c8d4d31bc1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=VJtRpkMlTXA02Z%2FXbyPidlpOC5c%3D" alt="09.jpg" loading="lazy"></p>
<p>很明显的表述了我们想要的 UI 风格： <code>多色</code> <code>像素化</code> <code>规范大小</code>。</p>
<p>随后我们可以输入以下提示词让 <code>gpt 4o image</code> 生成图标墙</p>
<pre><code class="hljs language-bash" lang="bash">Style the icon <span class="hljs-keyword">in</span> the second photo <span class="hljs-keyword">in</span> the same pixelated style as the icons <span class="hljs-keyword">in</span> the left image. Give it the same style as the image on the right. Solid black background

🎨 图标墙规划设计
尺寸建议：正方形或横向 16:9 比例
背景：纯黑色（<span class="hljs-comment">#000000）</span>
风格：参考右侧图片作为色系参考 (右侧图片就是我们一开始让 GPT 4o 设计的 游戏 UI 画面)

🧱 图标排列（4x4 格式）
照相机 📷 对话框 💬 爱心 ❤️ 数字1️⃣ 
数字 2️⃣ 数字 3️⃣ 数字 4️⃣ 数字 5️⃣
数字 6️⃣ 数字 8️⃣数字 7️⃣ 数字 9️⃣
加号 ➕ 减号 ➖ 斜杠 ／ 乘号 X

✅ 图标样式细节建议
照相机图标：小巧有镜头感，可添加一点反光效果
对话框图标：经典漫画气泡形状，边缘加亮色描边
爱心图标：红紫渐变，带像素锯齿感
数字：3D立体像素字体风，配亮色阴影
加减号／斜杠：对称结构，颜色统一为亮青/蓝紫过渡
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a692cf1242024f99ac0ddb2394fdeafa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=Hs5GjAJSkdPistPFy3jyeRAj9BQ%3D" alt="10.png" loading="lazy"></p>
<p>现在就生成了如上的图表墙，这个时候只要去除背景就可以使用了。可以使用如</p>

























<table><thead><tr><th>网站名称</th><th>网站功能</th><th>网站地址</th></tr></thead><tbody><tr><td><a href="https://link.juejin.cn?target=http%3A%2F%2FRemove.bg" target="_blank" title="http://Remove.bg" ref="nofollow noopener noreferrer">Remove.bg</a></td><td>操作简单，专注于背景去除</td><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.remove.bg%2F" target="_blank" title="https://www.remove.bg/" ref="nofollow noopener noreferrer">www.remove.bg/</a></td></tr><tr><td>Photoshop</td><td>专业级处理，灵活性高</td><td>需本地安装</td></tr><tr><td>Adobe Express</td><td>集成度高，功能全面</td><td><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.adobe.com%2Fexpress%2F" target="_blank" title="https://www.adobe.com/express/" ref="nofollow noopener noreferrer">www.adobe.com/express/</a></td></tr></tbody></table>
<p>我这里就使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.remove.bg%2Fzh%2Fupload" target="_blank" title="https://www.remove.bg/zh/upload" ref="nofollow noopener noreferrer">remove bg</a> 来实现这个需求</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e73cf9ae2f214a39a1d0ba76a0321e3d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=ud2dSqk%2Fi9dU%2FV93%2BEy2QL2jYM8%3D" alt="11.png" loading="lazy"></p>
<p>这样就获得了对应的像素风格 <code>UI</code>。</p>
<p>当然如果说不想要图标墙或者使用雪碧图来使用图标的话可以使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fproducts.aspose.app%2Fwords%2Fzh%2Fsplitter%2Fpng" target="_blank" title="https://products.aspose.app/words/zh/splitter/png" ref="nofollow noopener noreferrer">Aspose PNG Splitter</a> 等工具网站来拆分图标。这里就看个人喜好。这些方法特别适用于需要少量定制化 UI 元素的项目，如数据可视化、游戏界面等场景。</p>
<h2 data-id="heading-5">3.场景搭建</h2>
<p>在场景搭建环境环境，我无法给出过多建议，因为这需要即使您已经会使用如<code>hyper3D</code> 或者 <code>混元3D</code>等 <code>AI 3D Generation</code> 工具，但您仍需要掌握一定程度的 <code>blender</code>基本使用能力。</p>
<h3 data-id="heading-6">3.1 使用<code>blender-mcp</code> 快速辅助 3D 建模、场景创建和操作</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fahujasid%2Fblender-mcp" target="_blank" title="https://github.com/ahujasid/blender-mcp" ref="nofollow noopener noreferrer">blender-mcp</a>，他通过 API 添加了对 Poly Haven 资产的支持，并且已经接入了 <code>hyper3d</code>，意味着我们可以借用支持 <code>MCP Servers</code>的任何工具(如 Cursor、Claude Desktop 以及最近刚刚支持 MCP 的Trae)。</p>
<p><code>Blender MCP</code>提供很多tool， 不仅可以通过其 <code>get_scene_info</code> tool 来获取当前 Blender 场景的详细信息，还可以通过<code>execute_blender_code </code>来在 Blender 中执行任意 Python 代码。这意味我们可以在场景物体中较多的情况下利用 <code>Cursor</code>批量的放置&amp;调整物体的位置以及大小，并规范管理所有命名。</p>
<p>除了这些基本功能外，<code>blender-mcp</code>拥有 tool 如 <code>generate_hyper3d_model_via_images</code> &amp; <code>generate_hyper3d_model_via_text</code>。意味着他可以直接通过终端传入图片或者文字来生成模型:</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/10c417f187a04b71a3c3656a62950a04~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=eqeJJmuQUHqotLnd8Uj8tSAQhGc%3D" alt="13.png" loading="lazy"></p>
<p>随后可以在 Blender 里直接获得</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cb07d09331504935b37c45a150f0855e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=D5QPhC%2FylwGPwQHz72GFBjub64w%3D" alt="16.gif" loading="lazy"></p>
<p>看起来还不错，但我仍然只推荐你把这个模型作为一个参考来构建自己的模型，或者单纯的让他充当一个<code>地建</code>的作用帮你获取构建一个场景的参考素材。</p>
<p>很遗憾目前为止没有万能的银弹能够支持我们不需要任何学习成本就可以构建一个完整的可用模型所以你仍然需要能靠自己走到这一步</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7db2dfab24aa4b36a80d58a6a3c5ccd5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=%2F1X2p0SKQtp7tRuTVsUMvHkJVC4%3D" alt="16.png" loading="lazy"></p>
<h2 data-id="heading-7">4. 核心代码部分</h2>
<p>在我今年的第一篇<code>Threejs</code>文章 <a href="https://juejin.cn/post/7472650702340046886" target="_blank" title="https://juejin.cn/post/7472650702340046886">2025 年了，我不允许有前端不会用 Trae 让页面 Hero Section 变得高级！！！(Threejs)</a> 中提到过</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0186872debf3467a98d12ce9724c39f0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=hJ5DhTz10XIuOVzUuh3w5U468k8%3D" alt="17.png" loading="lazy"></p>
<p>所以这篇文章我也只会将一部分核心功能是如何实现写出来，而不会从模型导入，光线 &amp; 色彩管理等等功能怎么实现的一一往下叙述。那么 现在让我们进入本项目的代码核心片段。</p>
<h3 data-id="heading-8">4.1 相机 以及 后处理</h3>
<p>让我们现将对应的模型简单的使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgltf-viewer.donmccurdy.com%2F" target="_blank" title="https://gltf-viewer.donmccurdy.com/" ref="nofollow noopener noreferrer">gltf Viewer</a> 进行查看</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/588fe0107ae847b793894b87a42a9986~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=F%2FwUKkCkKDQkJXRmi4%2BGV%2ButsAk%3D" alt="18.png" loading="lazy"></p>
<p>但要要实现呈现 2.5D 效果视角的来说，我们需要使用到正交相机而不是透视相机</p>
<p>此时我们将相机切换为正交相机</p>
<pre><code class="hljs language-js" lang="js">      <span class="hljs-keyword">const</span> aspect = <span class="hljs-variable language_">this</span>.<span class="hljs-property">sizes</span>.<span class="hljs-property">aspect</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">frustumSize</span> = <span class="hljs-number">8</span>

      <span class="hljs-variable language_">this</span>.<span class="hljs-property">orthographicCamera</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">OrthographicCamera</span>(
        -<span class="hljs-variable language_">this</span>.<span class="hljs-property">frustumSize</span> * aspect,
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">frustumSize</span> * aspect,
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">frustumSize</span>,
        -<span class="hljs-variable language_">this</span>.<span class="hljs-property">frustumSize</span>,
        -<span class="hljs-number">50</span>,
        <span class="hljs-number">100</span>,
      )
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>.<span class="hljs-title function_">add</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">orthographicCamera</span>)
</code></pre>
<p>此时场景呈现效果变为</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7e824a8471e24f6c8dd4b830dac67df2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=lYy%2FsuCHDwuEXKi9T7JiQAzNRrA%3D" alt="19.gif" loading="lazy"></p>
<p>随后使用合适的后处理优化场景呈现效果。这里我们追求展现出比较老旧游戏机风格的画面，所以我们选择使用 <code>RenderPixelatedPass</code> 后处理效果来处理画面</p>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderPass</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderPass</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">instance</span>) 

    <span class="hljs-comment">// 创建像素化Pass</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pixelPass</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderPixelatedPass</span>(<span class="hljs-number">3</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">instance</span>)
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pixelPass</span>.<span class="hljs-property">normalEdgeStrength</span> = <span class="hljs-number">0.53</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pixelPass</span>.<span class="hljs-property">depthEdgeStrength</span> = <span class="hljs-number">0.4</span>

    <span class="hljs-comment">// 创建输出Pass用于提亮画面</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">outputPass</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputPass</span>()
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">outputPass</span>.<span class="hljs-property">exposure</span> = <span class="hljs-number">1.2</span> <span class="hljs-comment">// 增加曝光度</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">outputPass</span>.<span class="hljs-property">toneMapping</span> = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">ReinhardToneMapping</span> <span class="hljs-comment">// 使用Reinhard色调映射</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">outputPass</span>.<span class="hljs-property">toneMappingExposure</span> = <span class="hljs-number">1.2</span> <span class="hljs-comment">// 色调映射曝光度</span>

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">composer</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EffectComposer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">renderer</span>)
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">composer</span>.<span class="hljs-title function_">addPass</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">renderPass</span>)
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">composer</span>.<span class="hljs-title function_">addPass</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">pixelPass</span>)
    <span class="hljs-comment">// 此时像素化效果已经生效，但画面比较灰暗 需要提亮</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">composer</span>.<span class="hljs-title function_">addPass</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">outputPass</span>) <span class="hljs-comment">// 添加输出Pass</span>
</code></pre>
<p>此时画面就已经有点复古 <code>GBA</code> 彩色游戏机画面的感觉了</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/25b063d960444a1f84736c5148295050~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=X%2Fwh0omtI0YllKAlmk9nu1Nzz%2Fg%3D" alt="20.gif" loading="lazy"></p>
<h3 data-id="heading-9">4.2 角色控制 以及 Octree</h3>
<p>在实现类似宝可梦城镇的经典四方向移动体验时，常规的3D角色控制器如<code>ecctrl</code>往往难以满足需求，这是因为它们通常提供的是自由的全方位移动控制。而要实现这种复古风格的受限移动，关键在于对键盘输入的特殊处理和移动方向的精确控制。</p>
<ul>
<li>传统3D控制器允许360度自由移动，而经典RPG需要限制为四个基本方向</li>
<li>常规控制器通常处理的是连续输入，而我们需要离散的方向切换</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/be27b9ea4aae4fc99777d67bcaced440~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=jGC%2Bk4JKBtDo7FY87lvluDpljhY%3D" alt="21.gif" loading="lazy"></p>
<p><strong>其实是我将角色的移动方向限制在了"上下左右"四个方向</strong>。那么我是如何做到的呢？</p>
<ul>
<li>首先我们需要让键盘能在合适的时候相应对应的行为</li>
</ul>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-comment">// 按键按下事件</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'keydown'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
      <span class="hljs-keyword">switch</span> (e.<span class="hljs-property">code</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'ArrowUp'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'KeyW'</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">up</span> = <span class="hljs-literal">true</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-property">w</span> = <span class="hljs-literal">true</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-property">arrowUp</span> = <span class="hljs-literal">true</span>
          <span class="hljs-keyword">break</span>

        <span class="hljs-keyword">case</span> <span class="hljs-string">'ArrowDown'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'KeyS'</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">down</span> = <span class="hljs-literal">true</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-property">s</span> = <span class="hljs-literal">true</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-property">arrowDown</span> = <span class="hljs-literal">true</span>
          <span class="hljs-keyword">break</span>

        <span class="hljs-keyword">case</span> <span class="hljs-string">'ArrowLeft'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'KeyA'</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">left</span> = <span class="hljs-literal">true</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-property">a</span> = <span class="hljs-literal">true</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-property">arrowLeft</span> = <span class="hljs-literal">true</span>
          <span class="hljs-keyword">break</span>

        <span class="hljs-keyword">case</span> <span class="hljs-string">'ArrowRight'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'KeyD'</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">true</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-property">d</span> = <span class="hljs-literal">true</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-property">arrowRight</span> = <span class="hljs-literal">true</span>
          <span class="hljs-keyword">break</span>

        <span class="hljs-keyword">case</span> <span class="hljs-string">'Space'</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">brake</span> = <span class="hljs-literal">true</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>.<span class="hljs-property">space</span> = <span class="hljs-literal">true</span>
          <span class="hljs-comment">// 跳跃逻辑</span>
          <span class="hljs-keyword">if</span> (e.<span class="hljs-property">code</span> === <span class="hljs-string">'Space'</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerOnFloor</span> &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">character</span>.<span class="hljs-property">isSitting</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">jump</span>()
          }
          <span class="hljs-keyword">break</span>


        <span class="hljs-keyword">case</span> <span class="hljs-string">'KeyR'</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">reset</span> = <span class="hljs-literal">true</span>
          <span class="hljs-keyword">break</span>

        <span class="hljs-keyword">case</span> <span class="hljs-string">'KeyZ'</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toggleSit</span>()
          <span class="hljs-keyword">break</span>
      }
    })
</code></pre>
<p>在这里有一个小插曲来解释我<strong>为什么使用 event.code 而不是 event.key</strong></p>
<p>对于欧洲的玩家比如法国来说他们使用的键盘布局被称为<code>AZERTY layout</code>，实际上对应键位如下</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/64aa1edc25894d1e8b4b2d3a0cee8d1a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=XNwK%2FsIxdXjZWPfR3X7cLDg7sus%3D" alt="23.webp" loading="lazy"></p>
<p><strong>所以我们需要根据，键位在键盘上的物理位置来确定用户输入的指令。</strong></p>
<p>物理键位能确保玩家获得相同的控制体验，无论使用什么语言的键盘。不论是<code>AZERTY</code>布局，或者我们常用的<code>QWERTY</code>布局都可以让方向控制保持一致。</p>
<p>在能够精确的控制当前相应不同地域键盘的指令之后，我们来实现角色的移动逻辑</p>
<p>移动逻辑相关 <code>flowmap</code>如下：</p>
<pre><code class="hljs language-bash" lang="bash">    ┌───────────────┐
    │ 1. 是否坐下?  │
    │ isSitting?    │
    └──────┬────────┘
           |       │是
           |       ▼
           |   [直接返回]
           │否
           ▼
    ┌────────────────────────────┐
    │ 2. 初始化 moveX, moveZ,    │
    │    newDirection            │
    └────────────┬───────────────┘
                 ▼
    ┌────────────────────────────┐
    │ 3. 是否在地面?             │
    │ !playerOnFloor             │
    └──────┬─────────────┬───────┘
           │否           │是
           │             ▼
           │     playerVelocity.y -= GRAVITY * dt
           ▼
    ┌────────────────────────────┐
    │ 4. 计算 speedDelta         │
    │   (地面上快, 空中慢)         │
    └────────────┬───────────────┘
                 ▼
    ┌────────────────────────────┐
    │ 5. 检查按键输入            │
    │  (WASD/方向键)             │
    └────────────┬───────────────┘
                 ▼
    ┌────────────────────────────┐
    │ 6. 有移动输入?             │
    │ (moveX ≠ 0 || moveZ ≠ 0)  │
    └──────┬─────────────┬───────┘
           │否           │是
           │             ▼
           │   updateCharacterRotation(调整朝向)
        |
           │   		行走动画
           │   playAnimation(<span class="hljs-string">'walk'</span>)
           │
           │   playerVelocity.x/z += moveX/Z
           ▼			  ▼
    ┌────────────────────────────┐
    │ 7. 没有移动且在地面?       │
    │ (!isSitting &amp;&amp; onFloor)    │
    └──────┬─────────────┬───────┘
           │计算完毕      │是
           │             ▼
           │     playAnimation(<span class="hljs-string">'idle'</span>)
           ▼
    ┌────────────────────────────┐
    │ 8. 速度阻尼                │
    │ playerVelocity *= damping  │
    └────────────┬───────────────┘
                 ▼
    ┌────────────────────────────┐
    │ 9. 计算位移                │
    │ deltaPosition =            │
    │   playerVelocity * dt      │
    └────────────┬───────────────┘
                 ▼
    ┌────────────────────────────┐
    │ 10. 移动碰撞体             │
    │ playerCollider.translate   │
    └────────────┬───────────────┘
                 ▼
    ┌────────────────────────────┐
    │ 11. 碰撞检测与修正         │
    │ playerCollisions()         │
    └────────────┬───────────────┘
                 ▼
    ┌────────────────────────────┐
    │ 12. 动画状态更新           │
    │ updateAnimationState()     │
    └────────────┬───────────────┘
                 ▼
    ┌────────────────────────────┐
    │ 13. 同步模型与碰撞体       │
    │ updateModelFromCollider()  │
    └────────────────────────────┘
</code></pre>
<p>现在我们需要引入 <code>Octree</code>了，他算是在<code>threejs</code>中常见的碰撞检测方法。但这里我建议不要直接使用场景模型作为 <code>Octree</code> ，<code>Octree</code>适合稀疏三维空间，层级分明，而在动态物体多时重建开销大 。我非常推荐你构建一个专属于 <code>Octree</code> 用的碰撞检测用 <code>Object 3D</code> 网格基本体，他要做的事情很简单，只是尽可能的将那些场景中的"实体"包裹住，比如当前**视觉场景( 图 1 )**如下：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c2cc6dd8cc584952b1a3226aba12127e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=w3gE1mCUDIw0QNKg5WwLYCm6q2A%3D" alt="24.png" loading="lazy"></p>
<p>那么对应的**碰撞用网格基本体(图 2 )**为：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9d0383d565f44f72b55f592016a2c865~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=PAMQ3b8VFe1a2%2FVoV4K26HIrAto%3D" alt="25.png" loading="lazy"></p>
<p>简单的网格基本体能够降低用户设备的性能需求！毕竟不可能要求大家的电脑都是 4090。那么<strong>用户操控的角色实际上更像是在图 2 中的碰撞专用基本体中移动，然后将位置实时映射到视觉场景中的详细模型上。当用户在"Octree"的世界中碰到障碍时，则会“阻碍”其继续进行移动</strong>。</p>
<p>现在先让我们看看角色控制代码, 从一个 <code>tick</code>内需要执行那些逻辑我想会更好理解一点 (你可以理解一个<code>tick</code>就是画面上的“一帧”，但这种从物理层面是错误的)</p>
<pre><code class="hljs language-js" lang="js">   <span class="hljs-comment">// 判断是否有移动动作</span>
    <span class="hljs-keyword">const</span> isAnyMovementKeyPressed = <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">up</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">down</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">left</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">right</span>

    <span class="hljs-comment">// 角色移动</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">character</span>.<span class="hljs-property">isSitting</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">moveCharacter</span>(deltaTime)
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isAnyMovementKeyPressed &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerOnFloor</span>) {
      <span class="hljs-comment">// 阻尼</span>
      <span class="hljs-keyword">const</span> damping = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">exp</span>(-<span class="hljs-number">10</span> * deltaTime) - <span class="hljs-number">1</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerVelocity</span>.<span class="hljs-title function_">addScaledVector</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">playerVelocity</span>, damping)

      <span class="hljs-comment">// 计算位移</span>
      <span class="hljs-keyword">const</span> deltaPosition = <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerVelocity</span>.<span class="hljs-title function_">clone</span>().<span class="hljs-title function_">multiplyScalar</span>(deltaTime) <span class="hljs-comment">//计算实际位移</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerCollider</span>.<span class="hljs-title function_">translate</span>(deltaPosition)	<span class="hljs-comment">//应用位置更新</span>
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">playerCollisions</span>() <span class="hljs-comment">//碰撞检测与修正</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateModelFromCollider</span>() <span class="hljs-comment">//同步模型和碰撞体</span>
</code></pre>
<p>我们可以看到，当用户在没有坐着时触发移动指令则会调用<code>moveCharacter</code> 相关逻辑，而当用户停止移动时则会使用户缓慢停下来，这里使用<code>Math.exp(-10 * deltaTime) - 1</code>来模拟阻尼效果，使得 <code>damping</code> 得以迅速降为 -1。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cdec833acd6c4a359f2a8afcbd9a87ae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=H0%2FduezhW%2F1O4DvcETR6RpVE6u0%3D" alt="26.png" loading="lazy"></p>
<p>而在之前的角色控制流程图中提到移动的逻辑说白了就是计算位移，移动碰撞体，碰撞检测与修正最后同步模型与碰撞体。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/681408aabd7249bbb78f5bc085d9c6ab~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=wLwVX5rN1nZsim1%2Fx68TX6%2F6E50%3D" alt="27.png" loading="lazy"></p>
<h4 data-id="heading-10">4.2.1 计算位移</h4>
<p>位移计算逻辑很简单，就像我们正常去操控一个网格基本体在三维空间的位置，速度 X 时间 = 位移(标量),确定方向将位移应用到该方向上构成矢量。</p>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-title function_">moveCharacter</span>(<span class="hljs-params">deltaTime</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">character</span>.<span class="hljs-property">isSitting</span>)
      <span class="hljs-keyword">return</span>

    <span class="hljs-comment">// 计算移动方向</span>
    <span class="hljs-keyword">let</span> moveX = <span class="hljs-number">0</span>
    <span class="hljs-keyword">let</span> moveZ = <span class="hljs-number">0</span>
    <span class="hljs-keyword">let</span> newDirection = <span class="hljs-literal">null</span>

    <span class="hljs-comment">// 重力</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">playerOnFloor</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerVelocity</span>.<span class="hljs-property">y</span> -= <span class="hljs-variable language_">this</span>.<span class="hljs-property">GRAVITY</span> * deltaTime
    }

    <span class="hljs-comment">// 速度</span>
    <span class="hljs-keyword">const</span> speedDelta = deltaTime * (<span class="hljs-variable language_">this</span>.<span class="hljs-property">playerOnFloor</span> ? <span class="hljs-number">25</span> : <span class="hljs-number">8</span>)

    <span class="hljs-comment">// 用 actions 判断移动</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">up</span>) {
      moveZ = -speedDelta
      newDirection = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 朝向-Z</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">down</span>) {
      moveZ = speedDelta
      newDirection = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment">// 朝向+Z</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">left</span>) {
      moveX = -speedDelta
      newDirection = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 朝向-X</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">right</span>) {
      moveX = speedDelta
      newDirection = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 朝向+X</span>
    }

    <span class="hljs-comment">// 添加速度</span>
    <span class="hljs-keyword">if</span> (moveX !== <span class="hljs-number">0</span> || moveZ !== <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// 更新角色朝向</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateCharacterRotation</span>(newDirection)

      <span class="hljs-comment">// 只有在地面且不是跳跃时才播放行走动画</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">playerOnFloor</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentAnimation</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">animations</span>.<span class="hljs-property">jump</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">playAnimation</span>(<span class="hljs-string">'walk'</span>)
      }

      <span class="hljs-comment">// 添加速度</span>
      <span class="hljs-keyword">if</span> (moveX !== <span class="hljs-number">0</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerVelocity</span>.<span class="hljs-property">x</span> += moveX
      }
      <span class="hljs-keyword">if</span> (moveZ !== <span class="hljs-number">0</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerVelocity</span>.<span class="hljs-property">z</span> += moveZ
      }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">playerOnFloor</span>) {
      <span class="hljs-comment">// 没有移动时播放待机动画</span>
      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">character</span>.<span class="hljs-property">isSitting</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentAnimation</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">animations</span>.<span class="hljs-property">jump</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">playAnimation</span>(<span class="hljs-string">'idle'</span>)
      }
    }

    <span class="hljs-comment">// 阻尼</span>
    <span class="hljs-keyword">const</span> damping = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">exp</span>(-<span class="hljs-number">4</span> * deltaTime) - <span class="hljs-number">1</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerVelocity</span>.<span class="hljs-title function_">addScaledVector</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">playerVelocity</span>, damping)

    <span class="hljs-comment">// 位置更新</span>
    <span class="hljs-keyword">const</span> deltaPosition = <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerVelocity</span>.<span class="hljs-title function_">clone</span>().<span class="hljs-title function_">multiplyScalar</span>(deltaTime)
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerCollider</span>.<span class="hljs-title function_">translate</span>(deltaPosition)

    <span class="hljs-comment">// 动画状态更新</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateAnimationState</span>()
  }
</code></pre>
<h4 data-id="heading-11">4.2.2 避免多转半圈</h4>
<p><strong>这里唯一要注意的地方就是更新角色朝向我单独拿出来写了</strong>，一般的思路不应该是在明确<code>WSAD</code>对应当前角色的东西南北面朝向前提下将代码写成以下形式吗？</p>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">up</span>) {
      moveZ = -speedDelta
      newDirection = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 朝向-Z</span>
      newRotation = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>/<span class="hljs-number">2</span>				<span class="hljs-comment">//更新旋转</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">down</span>) {
      moveZ = speedDelta
      newDirection = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment">// 朝向+Z</span>
      newRotation = -<span class="hljs-number">1</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>/<span class="hljs-number">2</span>				<span class="hljs-comment">//更新旋转</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">left</span>) {
      moveX = -speedDelta
      newDirection = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 朝向-X</span>
      newRotation = <span class="hljs-number">0</span>				<span class="hljs-comment">//更新旋转</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">actions</span>.<span class="hljs-property">right</span>) {
      moveX = speedDelta
      newDirection = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 朝向+X</span>
      newRotation = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>				<span class="hljs-comment">//更新旋转</span>
    }
</code></pre>
<p>但这种代码会在用户角色在从<code>+Z</code>轴转向<code> -X</code>轴时出现<strong>多转半圈</strong>的问题,因为我们转向用程序写出来就是从 <code>newRotation = -1 * Math.PI/2</code> 状态渐变到 <code>newRotation = Math.PI</code>状态 ，不经过特殊处理他一定会有一种情况如下图 先从 -π/2 到 0 再到 π。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/769caed3f0694a82a4e96d016a3830d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=N1IZ%2BCGjp2BJBNmWpa41S7oQvYM%3D" alt="28.png" loading="lazy"></p>
<p>实际画面为</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5720829e48df43f385566c028e9380d9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=ITKEj%2F8S8S%2BJtSgMRrBqY%2BKJrj4%3D" alt="29.gif" loading="lazy"></p>
<p>为了避免这种情况我们需要将转向限制在 <em>[-PI, PI]</em> 之间</p>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-title function_">updateCharacterRotation</span>(<span class="hljs-params">newDirection</span>) {
    <span class="hljs-keyword">if</span> (!newDirection || <span class="hljs-variable language_">this</span>.<span class="hljs-property">character</span>.<span class="hljs-property">currentDirection</span>.<span class="hljs-title function_">equals</span>(newDirection))
      <span class="hljs-keyword">return</span>

    <span class="hljs-comment">// Store new direction</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">character</span>.<span class="hljs-property">currentDirection</span> = newDirection

    <span class="hljs-comment">// Calculate the appropriate rotation based on direction</span>
    <span class="hljs-keyword">let</span> targetRotation = <span class="hljs-number">0</span>

    <span class="hljs-keyword">if</span> (newDirection.<span class="hljs-property">z</span> === -<span class="hljs-number">1</span>) {
      targetRotation = <span class="hljs-number">0</span> <span class="hljs-comment">// Facing -Z</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newDirection.<span class="hljs-property">z</span> === <span class="hljs-number">1</span>) {
      targetRotation = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> <span class="hljs-comment">// Facing +Z</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newDirection.<span class="hljs-property">x</span> === -<span class="hljs-number">1</span>) {
      targetRotation = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">2</span> <span class="hljs-comment">// Facing -X</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newDirection.<span class="hljs-property">x</span> === <span class="hljs-number">1</span>) {
      targetRotation = -<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">2</span> <span class="hljs-comment">// Facing +X</span>
    }

    <span class="hljs-comment">// Get the current rotation</span>
    <span class="hljs-keyword">const</span> currentRotation = <span class="hljs-variable language_">this</span>.<span class="hljs-property">character</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span>

    <span class="hljs-comment">// Calculate the difference between the current rotation and the target rotation</span>
    <span class="hljs-keyword">let</span> deltaRotation = targetRotation - currentRotation

    <span class="hljs-comment">// 归一化 deltaRotation 到 [-PI, PI] 区间</span>
    deltaRotation = ((deltaRotation + <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) % (<span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) + <span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) % (<span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) - <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>

    <span class="hljs-comment">// Calculate the new target rotation</span>
    <span class="hljs-keyword">const</span> newTargetRotation = currentRotation + deltaRotation

    <span class="hljs-comment">// Animate rotation</span>
    gsap.<span class="hljs-title function_">to</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">character</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">rotation</span>, {
      <span class="hljs-attr">y</span>: newTargetRotation,
      <span class="hljs-attr">duration</span>: <span class="hljs-number">0.2</span>,
      <span class="hljs-attr">ease</span>: <span class="hljs-string">'power1.out'</span>,
    })
  }
</code></pre>
<p>这样一来就不会多转半圈了</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f713af3a161f424ea1ff1618f2ab9e73~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=blBQ1M7jp53CQVkjlDIKVGuxlxg%3D" alt="30.gif" loading="lazy"></p>
<h4 data-id="heading-12">4.2.3 碰撞检测和修正</h4>
<p><em>移动碰撞体</em>没什么好讲的，仅仅只是应用矢量到对应的对象上，让我们集中在碰撞检测上。首先我们得使用 <code>Octree</code>基于我们创建的碰撞专用基本体构建八叉树</p>
<p><code>Octree</code> 提供给我们 <code>fromGraphNode</code>从 three.js 的 Object3D（通常是 Mesh 或 Group）中提取所有三角形，构建八叉树。</p>
<pre><code class="hljs language-js" lang="js">	<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Octree</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'three/addons/math/Octree.js'</span>   
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">worldOctree</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Octree</span>()

    <span class="hljs-title function_">setupCollider</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// Initialize octree from the collision model</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"碰撞专用网格基本体"</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">worldOctree</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Octree</span>()
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">worldOctree</span>.<span class="hljs-title function_">fromGraphNode</span>(<span class="hljs-string">"碰撞专用网格基本体"</span>)
        }
      }
</code></pre>
<p>随后为用户角色创建胶囊体</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Capsule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'three/addons/math/Capsule.js'</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">playerCollider</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Capsule</span>(
      <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2.35</span>, <span class="hljs-number">0</span>),
      <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>),
      <span class="hljs-number">0.35</span>,
)
</code></pre>
<p>此时场景实际上在 <code>Octree</code> 那边可能是这样的</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/288a03876e114fc6af40c53aa3563ed7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=zlxGrW4gbkYMxeEgKzT%2BLSK3PCo%3D" alt="31.png" loading="lazy"></p>
<p>用户角色的碰撞体积以胶囊体为准，而场景的碰撞体则以图中黑色建筑为准。</p>
<p>而碰撞检测则需要用到<code>Octree</code>提供的另一个方法<code>capsuleIntersect</code> : 检测胶囊体与八叉树内所有三角形的碰撞，返回碰撞法线和深度。</p>
<pre><code class="hljs language-js" lang="js">  <span class="hljs-title function_">playerCollisions</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-property">worldOctree</span>.<span class="hljs-title function_">capsuleIntersect</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">playerCollider</span>) <span class="hljs-comment">//检测胶囊体与八叉树内所有三角形的碰撞，返回碰撞法线和深度。</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerOnFloor</span> = <span class="hljs-literal">false</span>

    <span class="hljs-keyword">if</span> (result) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerOnFloor</span> = result.<span class="hljs-property">normal</span>.<span class="hljs-property">y</span> &gt; <span class="hljs-number">0</span>
      <span class="hljs-comment">// Adjust position to prevent clipping</span>
      <span class="hljs-keyword">if</span> (result.<span class="hljs-property">depth</span> &gt;= <span class="hljs-number">1e-10</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerCollider</span>.<span class="hljs-title function_">translate</span>(result.<span class="hljs-property">normal</span>.<span class="hljs-title function_">multiplyScalar</span>(result.<span class="hljs-property">depth</span>))
      }
    }
  }
</code></pre>
<p>那么他是如何起作用的呢?</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c2a754d7a1574e76b40a5b1afb6323ad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=QN6IYsi58I3Svmat6zsZe2KLOhI%3D" alt="32.png" loading="lazy"></p>
<p>正如前面提到<code>capsuleIntersect</code> : 检测胶囊体与八叉树内所有三角形的碰撞，返回碰撞法线和深度，则<strong>当有返回法线矢量，则证明胶囊体与墙壁碰撞。接着让角色朝法线方向移动来抵消掉用户向墙里走的位移,从而避免穿模的出现</strong></p>
<pre><code class="hljs language-js" lang="js">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">playerCollider</span>.<span class="hljs-title function_">translate</span>(result.<span class="hljs-property">normal</span>.<span class="hljs-title function_">multiplyScalar</span>(result.<span class="hljs-property">depth</span>))
</code></pre>
<p>如果你想了解更多的<code>Octree</code>碰撞检测逻辑，我推荐你看 <code>threejs</code>的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fexamples%2F%3Fq%3Dfps%23games_fps" target="_blank" title="https://threejs.org/examples/?q=fps#games_fps" ref="nofollow noopener noreferrer">这个官方用例</a></p>
<h3 data-id="heading-13">4.3.岩浆与海</h3>
<p>最后是场景中的水体，比如说岩浆和海，这里我简单拿岩浆举例</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cf069814ede14999af9bc73dd52a3d72~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=V02tc9tw9hm4S8SA3Sbo1ggCpyU%3D" alt="35.gif" loading="lazy"></p>
<p>通常这种风格的水体在行业内被称为 “风格化水体 (stylized water | toon water) ”。你可以通过搜索这些关键词来获取不一样的水体风格，让我们来分析做这样一个水体需要经理那些步骤。</p>
<p>Step1: 我们需要一个水面纹理</p>
<p>Step2: 在靠近水体边缘的地方加入渐变浮沫</p>
<p>Step3: 让水面真正流动起来</p>
<h4 data-id="heading-14">4.3.1水面纹理</h4>
<p>首先我们需要让一个平平无奇的平面看起来像是水面</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0513056fff534c039bbea4980a008e83~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=zmZgSmlQ5KVDLqkvJ7B3XqzDo9c%3D" alt="37.png" loading="lazy"></p>
<p>实现这种水面的方式由很多种，比如你可以在网上寻找这种水面遮罩素材</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3f789fcf04534b49aa941127c584166a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=KbT4w3Rb%2BjGoZXONjj8MtqvG66s%3D" alt="waterMask.png" loading="lazy"></p>
<p>或者自己选择一种噪声来模拟水面，比如 <a href="https://link.juejin.cn?target=https%3A%2F%2Ftympanus.net%2Fcodrops%2F2025%2F03%2F04%2Fcreating-stylized-water-effects-with-react-three-fiber%2F" target="_blank" title="https://tympanus.net/codrops/2025/03/04/creating-stylized-water-effects-with-react-three-fiber/" ref="nofollow noopener noreferrer">这篇文章</a> 使用柏林噪声来模拟水面效果</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/765558f8ddb344958409ae445bb6c4b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=fASqEtkb0FF4GKxVLhtUfRsfWDU%3D" alt="40.png" loading="lazy"></p>
<p>而我使用的则是<strong>蜂窝噪声(Cellular Noise)</strong>,也被称为网格噪声。网格噪声基于距离场，这里的距离是指到一个特征点集最近的点的距离。这里同样为你奉上由<code>ShaderBook</code>写的<a href="https://link.juejin.cn?target=https%3A%2F%2Fthebookofshaders.com%2F12%2F%3Flan%3Dch" target="_blank" title="https://thebookofshaders.com/12/?lan=ch" ref="nofollow noopener noreferrer">蜂窝噪声相关文章</a>, 但我仍会简单阐述其实现原理。</p>
<p>首先我们需要知道什么是距离场，即为(SDF)，定义说有符号距离场 (SDF) 是计算机图形学中常用于渲染的形状的数学表示。它是一个函数，接收空间中的一个点，并返回到该形状表面上最近点的距离，并用符号表示该点位于形状内部还是外部：</p>
<ul>
<li>如果值为负，则该点位于形状内部。</li>
<li>如果值为零，则该点位于形状的表面上。</li>
<li>如果值为正，则该点位于形状之外。</li>
</ul>
<p>让我们来看以下代码，</p>
<pre><code class="hljs language-glsl" lang="glsl">float sdfCircle(vec2 center, float r, vec2 pos) {
  return distance(center, pos) - r;
}

void main() {
  vec2 uv = gl_FragCoord.xy;

  float t = sdfCircle(iResolution * 0.5, iResolution.y * 0.4, uv);
  
  gl_FragColor = vec4(vec3(t), 1.0);
}
</code></pre>
<p>其中 <code>iResolution * 0.5</code> 就是画布中心的位置，而 <code>iResolution.y * 0.4</code> 则代表值为当前画布高度的 <code>0.4</code> 。</p>
<p><code>distance(center, pos) - r</code> 就是计算当前画布上的每一个点 <code>pos</code> 到画布中心 <code>center</code> 的举例跟 <code>iResolution.y * 0.4</code> 谁大谁小，举例</p>
<ul>
<li>当点 <code>pos</code> 的距离小于 <code>iResolution.y * 0.4</code> 时，则<code>t</code>为负数，此时<code>gl_FragColor = vec4(vec3(t), 1.0);</code> 就是<code>gl_FragColor = vec4(vec3(负数), 1.0);</code> 显示成黑色。</li>
<li>当点 <code>pos</code> 的距离大于 <code>iResolution.y * 0.4</code> 时，则<code>t</code>为正数，此时<code>gl_FragColor = vec4(vec3(t), 1.0);</code> 就是<code>gl_FragColor = vec4(vec3(正数), 1.0);</code> 显示成灰色或白色。</li>
</ul>
<p>最后得出的效果如下:</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc047c421c064b58bf7ae6f4cdacd85d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=mhQ5QOGYfst51doHoWC0hmLryH4%3D" alt="41-2.png" loading="lazy"></p>
<p>这是个很简单的理论，但也是蜂窝噪声的基石。再让我们会看这句话<strong>计算它们与当前像素的距离并存储最接近的值</strong></p>
<p>假设现在我们平面上有N个"中心点"，那么我们现在要做的事分别求出单个片元到所有"中心点"的距离并求出最小值</p>
<pre><code class="hljs language-glsl" lang="glsl">uniform vec2 iResolution;
uniform float iTime;

vec2 points[9];

void init() {
  points[0] = vec2(0.05,0.15);
  points[1] = vec2(0.35,0.27);
  points[2] = vec2(0.78,0.04);
  
  points[3] =  vec2(0.25,0.46);
  points[4] = vec2(0.50,0.55);
  points[5] = vec2(0.91,0.37);
  
  points[6] = vec2(0.28,0.67);
  points[7] =  vec2(0.53,0.76);
  points[8] = vec2(0.73,0.75); 
}

vec2 getPoint(int index) {
  return sin(points[index] * 6.28 + iTime / 3.0) * 0.5 + 0.5;
}

void main() {
  init();
  
  vec2 uv = gl_FragCoord.xy / iResolution.xy;
  float m_dist = 1.0;
  
  for (int i = 0; i &lt; 9; i++) {
    float dist = distance(uv, getPoint(i));
    m_dist = min(m_dist, dist);
  }
  
  gl_FragColor = vec4(0.0, m_dist * 2.25, 0.0, 1.0);
}
</code></pre>
<p>那么随着特征点越来越多，水面的效果也就随之显现了</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c660204b3c20469ca3370d3ee93d8127~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=%2FSRvOEgzHXyKi8%2BaPrNaGe19a3g%3D" alt="42.gif" loading="lazy"></p>
<p>随后可以使用灰度作为混合因子，混合水面颜色和浮沫颜色即可，这点也非常简单</p>
<pre><code class="hljs language-js" lang="js">        uniform vec3 color1;  <span class="hljs-comment">// 水色</span>
        uniform vec3 color2;  <span class="hljs-comment">// 白色</span>
</code></pre>
<p>片元着色器</p>
<pre><code class="hljs language-glsl" lang="glsl">        void main() {
          init();
          
          vec2 uv = gl_FragCoord.xy / iResolution.xy;
          float m_dist = 1.0;
          
          // 计算点的效果
          for (int i = 0; i &lt; 11; i++) {
            if (float(i) &gt;= numPoints) break;
            float dist = distance(uv, getPoint(i));
            m_dist = min(m_dist, dist);
          }
		float factor = smoothstep(0.05, 0.3, m_dist); 
          
          // 使用 factor 作为混合因子, 混合两种颜色
          vec3 waterColor = mix(color1, color2,factor);
          
          gl_FragColor = vec4(waterColor, 1.0);
        }
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/615ec05bc03c407b879a7a3c65cf537c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=5p24l5MzWxMylX6STxfA3Yb2OJU%3D" alt="43.png" loading="lazy"></p>
<p><strong>当然你现在可以增加多个特征点或者操控 uv 做出水面蠕动特效</strong>，但我们后续会使用<code>flowmap</code>就不在这里操作了。</p>
<h4 data-id="heading-15">4.3.2 边缘浮沫</h4>
<p>在水面边缘存在一圈白色的浮沫，这是一种 <code>hack</code>手段的模拟菲涅尔现象。我不推荐你学这一块，因为他的应用场景仅仅只在这个案例中，所以我只贴上基本的<code>shader</code>代码</p>
<p><strong>顶点着色器</strong></p>
<pre><code class="hljs language-glsl" lang="glsl">        // Calculate edge glow effect
        float getEdgeGlow(vec2 uv) {
          // Calculate distance to edge
          float distToEdge = min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y));
          
          // Use smooth step function to create a soft transition
          return 1.0 - smoothstep(0.0, edgeWidth, distToEdge);
        }
</code></pre>
<p><strong>片元着色器</strong></p>
<pre><code class="hljs language-glsl" lang="glsl">        void main() {
          init();
          
          vec2 uv = gl_FragCoord.xy / iResolution.xy;
          float m_dist = 1.0;
          
          // Calculate point effect
          for (int i = 0; i &lt; 9; i++) {
            if (float(i) &gt;= numPoints) break;
            float dist = distance(uv, getPoint(i));
            m_dist = min(m_dist, dist);
          }
          
          // Calculate base color
          vec3 baseColor = vec3(m_dist * colorIntensity);
          
          // Add edge glow
          float edgeGlow = getEdgeGlow(uv) * edgeIntensity;	// 获取边缘强度做混合因子
          
          // Mix base color and edge glow
          vec3 finalColor = mix(baseColor, vec3(1.0), edgeGlow);
          
          gl_FragColor = vec4(finalColor, 1.0);
        }
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e196fdc50ed44df190a40565c613442c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=LKkRaWOq1nJA02efcVCcTXT%2BCc8%3D" alt="44.png" loading="lazy"></p>
<h4 data-id="heading-16">4.3.3 流动水面</h4>
<p>这里我要向你介绍游戏中流动水体或者模拟流体的一种常见方法： <code>flowmap</code>。这里的<code>flowmap</code>指代的并不是程序中的流程图，而是<strong>一张记录了2D向量信息的纹理Flow map上的颜色（通常为RG通道）记录该处向量场的方向，让模型上某一点表现出定量流动的特征</strong></p>
<p>接下来我会向你解释 <code>flowmap</code>是如何工作的，以及如何低成本的构建一个<code>flowmap</code>。最后我会想你讲述如何将<code>flowmap</code>使用在 <code>threejs</code>中</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b671c45247a146cfa4acf635c2becf55~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=08I8LahiI34LY5YOKRd89YSF9Rc%3D" alt="43.gif" loading="lazy"></p>
<h5 data-id="heading-17">4.3.3.1 <code>flowmap</code>的原理</h5>
<p>**将<code>2D</code>向量场信息编码到纹理的红色通道&amp; 绿色通道中，每个纹素代表一个流动方向向量，通过在shader中偏移uv再对纹理进行采样，来模拟流动效果。**这就是<code>flowmap</code>的作用。</p>
<p>通俗地说，当片元着色器读取Flowmap上某一点的颜色值时：</p>
<ul>
<li>红色分量(R)代表X轴方向的流动</li>
<li>绿色分量(G)代表Y轴方向的流动</li>
<li>颜色值的大小决定了流动的强度</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bf8ddeb6bf1640cf9f326be322b41a55~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=cFOurfcNucEL2YVqTIc3b3e9mAI%3D" alt="45.png" loading="lazy"></p>
<p>接下来让我们来理解这段话。我们使用一个如图所示的<code>flowmap</code>，观察水面的流动方向。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c556f6ec872c4edf8083c9a9ad226a87~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=5W11abkDF%2FfOqJix2FYfHNmJ8xY%3D" alt="46.png" loading="lazy"></p>
<p>可以看到水面为橙色的会向右移动，水面为绿的则会向左移动.</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e9bc00a3e4fb4454aa1e12391f19fc8f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=FVWAtjirh5WupZWqNCJNrAHoAxs%3D" alt="47.gif" loading="lazy"></p>
<h5 data-id="heading-18">4.3.3.2 低成本的构建一个<code>flowmap</code></h5>
<p>如果要构建一个正规的工业化 <code>flowmap</code> ，其实最好选用如 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.sidefx.com%2F" target="_blank" title="https://www.sidefx.com/" ref="nofollow noopener noreferrer">Houdini</a> 等一些专业的软件，但是如果不想学习 <code>Houdini</code> 或者，需要再最短时间内拿出一个可运行的<code>demo</code> ，可以试试以下两个工具中的一个。</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fcables.gl%2Fedit%2FntZfmv" target="_blank" title="https://cables.gl/edit/ntZfmv" ref="nofollow noopener noreferrer">cables.gl </a>- 基于节点的可视化编程工具</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fteckartist.com%2F%3Fpage_id%3D107" target="_blank" title="https://teckartist.com/?page_id=107" ref="nofollow noopener noreferrer">FlowMap Painter</a> - 专门的Flowmap绘制工具</li>
</ul>
<p>这里我简单使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcables.gl%2Fedit%2FntZfmv" target="_blank" title="https://cables.gl/edit/ntZfmv" ref="nofollow noopener noreferrer">cables.gl</a> ,构建一个 <code>flowmap</code>。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/220d77df62404c7396b5ae9467a6e881~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=MMOrBiDY%2FJ8I5B%2B5ON99ZaD7IJc%3D" alt="47.png" loading="lazy"></p>
<p>就比如这样
<img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb7d66c669a14b31bc69545a550fa4b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=iJzoz27TNbtlHpMcHjKseKwbGIk%3D" alt="48-2.gif" loading="lazy"></p>
<p>**得到可用的效果后将 <code>Flowmap Visualize</code> 的值降低为 <code>0</code> ，随后点击下载就获得你想要的<code>flowmap</code>了。</p>
<h5 data-id="heading-19">4.3.3.3 如何在<code>Threejs</code>中使用<code>flowmap</code></h5>
<p>第一种方法是使用 <code>Threejs</code> 中自带的 <code>Water2</code> 类，详情可以参考 <a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fexamples%2Fwebgl_water_flowmap.html" target="_blank" title="https://threejs.org/examples/webgl_water_flowmap.html" ref="nofollow noopener noreferrer">Threejs Flowmap官网案例</a>。</p>
<p>核心代码如下:</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 创建水面几何体</span>
<span class="hljs-keyword">const</span> waterGeometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneGeometry</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);

<span class="hljs-comment">// 加载Flowmap纹理</span>
<span class="hljs-keyword">const</span> flowMap = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">'textures/water/flowmap.png'</span>);

<span class="hljs-comment">// 创建水面效果</span>
water = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Water</span>(waterGeometry, {
  <span class="hljs-attr">scale</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">textureWidth</span>: <span class="hljs-number">1024</span>,
  <span class="hljs-attr">textureHeight</span>: <span class="hljs-number">1024</span>,
  <span class="hljs-attr">flowMap</span>: flowMap
});

<span class="hljs-comment">// 设置位置和旋转</span>
water.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = <span class="hljs-number">1</span>;
water.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * -<span class="hljs-number">0.5</span>;
scene.<span class="hljs-title function_">add</span>(water);

</code></pre>
<p>随后就会在平面上生成一个带有flowmap流动效果的透明平面</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75462775281449ddb37065b677f57b86~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=k9j7o6w8UAw4hDojyq1zV7inTbI%3D" alt="49.png" loading="lazy"></p>
<p>但我们这里使用的是第二种方法,即为实打实的利用<code>fragment shader</code>操控<code>uv</code>来达到流动效果</p>
<pre><code class="hljs language-glsl" lang="glsl">// 从Flowmap获取流动向量（值范围从[0,1]映射到[-1,1]）
vec2 flow = texture2D(flowMap, vUv).rg * 2.0 - 1.0;

// 计算时间相关的流动偏移量
vec2 flowOffset = flow * flowSpeed * iTime;

// 应用偏移到UV坐标
vec2 uv = vUv + flowOffset;
</code></pre>
<p>最后来的效果为</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4277fce6bccf4acfa6b08cbaaa74ae88~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=2MbH9ewXR5HahGCITlrUJ%2BsG3vA%3D" alt="51.gif" loading="lazy"></p>
<p>具体效果还需要根据你自己的个人喜好来调整。完整实现代码可参考项目源码库。通过调整Flowmap纹理和着色器参数，您可以创建从平静水面到湍急河流等各种水体效果。</p>
<h2 data-id="heading-20">5.为什么会鸽一个月？</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2811fda2faa042d796679ee326f6c6ad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=PPgqThOxqYvxbxCB4R%2FRWBH1jEo%3D" alt="finally.gif" loading="lazy"></p>
<p>其实如果有看了上一期文章的朋友应该知道这个项目已经在上个月就完成了 80 %，但因为个人情感 &amp; 生活上出现了一点问题，之后我消沉了很长一段时间，于是就耽误了文章的更新。我并不是一个自驱力很强的人，真正的编程能力并没有多么的出色，顶多也就是喜欢鼓捣一些神秘小代码。在过去几个月的持续创作中，我收获了来自多个平台的关注和鼓励，甚至包括一些我曾视为行业偶像的人士的认可。这些支持让我既感到荣幸，也时常感到惶恐。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8f270d5d4d574493b1c80bca119d5636~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=Qa2UU5pf2eYC97zwSRV6vdedaOQ%3D" alt="finally2.png" loading="lazy">
但我时常看着平台消息通知倍感压力，我认为我远远没有达到能够“系统化教授别人”<code>threejs</code>的地步。</p>
<p>我必须坦诚地承认：</p>
<ol>
<li>我并非科班出身的专业开发者</li>
<li>我的Three.js知识体系还存在许多不足</li>
<li>持续的高质量输出对我而言是巨大的挑战</li>
</ol>
<p>这也是我想说的，我认为后续我会暂停目前Three.js技术文章的定期更新计划。没准会变回曾经的年更博主。但这并不意味着我会停止创作：</p>
<ul>
<li>我的GitHub仓库仍会持续更新有趣的项目</li>
<li>社交媒体账号会分享新的探索和发现</li>
<li>当有真正值得分享的内容时，我依然会撰写文章</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5ebc8fe1f88748b8aae9b243b2820e0a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5L2V6LSk:q75.awebp?rk3s=f64ab15b&amp;x-expires=1749128282&amp;x-signature=G7gfOmlavyLH8B%2FizX%2Bvc0ukIqc%3D" alt="video.gif" loading="lazy"></p>
<h3 data-id="heading-21">特别的感谢</h3>
<p>我要特别感谢：</p>
<ul>
<li>每一位留下评论和建议的读者</li>
<li>那些通过Star和Fork支持我项目的开发者</li>
<li>所有给予我鼓励的同行们</li>
</ul>
<p>Three.js领域有许多优秀的作者和教程资源，我相信这个充满活力的社区会继续蓬勃发展。虽然我的角色可能会改变，但我对创意编程的热情不会减退。</p>
<p>我认为这个平台上有很多其余的非常优秀的<code>Threejs</code>领域的作者。他们会继续推动着这个领域到大众视野之中。再会，我的朋友！</p>
<h2 data-id="heading-22">6.最后的一些话</h2>
<h3 data-id="heading-23">技术的未来与前端迁移</h3>
<p>随着 AI 技术的快速发展，各类技术的门槛正在大幅降低，以往被视为高门槛的 <code>3D</code> 技术也不例外。与此同时，过去困扰开发者的数字资产构建成本问题，也正在被最新的 <code>3D generation</code> 技术所攻克。这意味着，在不久的将来，前端开发将迎来一次技术迁移，开发者需要掌握更新颖的交互方式和更出色的视觉效果。</p>
<h3 data-id="heading-24">本专栏的愿景</h3>
<p>本专栏的愿景是通过分享 <code>Three.js</code> 的中高级应用和实战技巧，帮助开发者更好地将 <code>3D</code> 技术应用到实际项目中，打造令人印象深刻的 <code>Hero Section</code>。我们希望通过本专栏的内容，能够激发开发者的创造力，推动 <code>Web3D</code> 技术的普及和应用。</p>
<h3 data-id="heading-25">加入社区，共同成长</h3>
<p>如果您对 <code>Threejs</code> 这个 <code>3D</code> 图像框架很感兴趣，或者您也深信未来国内会涌现越来越多 <code>3D</code> 设计风格的网站，欢迎加入 <strong><a href="https://link.juejin.cn/?target=https%3A%2F%2Fopensource.icegl.cn" target="_blank" title="https://link.juejin.cn/?target=https%3A%2F%2Fopensource.icegl.cn">ice 图形学社区</a></strong>。这里是国内 Web 图形学最全的知识库，致力于打造一个全新的图形学生态体系！您可以在认证达人里找到我这个 <code>Threejs</code> 爱好者和其他大佬。</p>
<p>此外，如果您很喜欢 <code>Threejs </code>又在烦恼其原生开发的繁琐，那么我诚邀您尝试 <strong><a href="https://link.juejin.cn/?target=https%3A%2F%2Ftresjs.org%2F" target="_blank" title="https://link.juejin.cn/?target=https%3A%2F%2Ftresjs.org%2F">Tresjs</a></strong> 和 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.icegl.cn%2F" target="_blank" title="https://docs.icegl.cn/" ref="nofollow noopener noreferrer">TvTjs</a></strong>, 他们都是基于 <code>Vue</code> 的 <code>Threejs</code> 框架。 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.icegl.cn%2F" target="_blank" title="https://docs.icegl.cn/" ref="nofollow noopener noreferrer">TvTjs</a></strong> 也为您提供了大量的可使用案例，并且拥有较为活跃的开发社区，在这里你能碰到志同道合的朋友一起做开源！</p></div></div>