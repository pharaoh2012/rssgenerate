
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18763811" title="发布于 2025-03-10 22:01">
    <span role="heading" aria-level="2">Netty基础—1.网络编程基础一</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="3" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="4"><strong>1.什么是OSI开放系统互连</strong></p>
<p data-track="5"><strong>2.OSI七层模型各层的作用</strong></p>
<p data-track="6"><strong>3.TCP/IP协议的简介</strong></p>
<p data-track="7"><strong>4.TCP和UDP的简介</strong></p>
<p data-track="8"><strong>5.TCP连接的三次握手</strong></p>
<p data-track="9"><strong>6.TCP连接的四次挥手</strong></p>
<p data-track="10"><strong>7.TCP/IP中的数据包</strong></p>
<p data-track="11"><strong>8.TCP通过确认应答与序列号提高可靠性</strong></p>
<p data-track="12"><strong>9.HTTP请求的传输过程</strong></p>
<p data-track="13"><strong>10.HTTP协议报文结构</strong></p>
<p data-track="14"><strong>11.Socket、短连接、长连接、网络IO流程</strong></p>
<p data-track="15"><strong>12.Linux的IO模型详情</strong></p>
<p data-track="16"><strong>13.Linux的IO模型核心</strong></p>
<p data-track="17"><strong>14.select、poll、epoll的区别</strong></p>
<p data-track="18"><strong>15.水平触发和边缘触发</strong></p>
<p data-track="19">&nbsp;</p>
<p data-track="20"><strong>1.什么是OSI开放系统互连</strong></p>
<p data-track="21">OSI是Open System Interconnect的简称，即开放系统互连参考模型。OSI为开放系统的计算机互连提供了一个共同的基础和标准框架，并为保持相关标准的一致性和兼容性提供了共同的参考。</p>
<p data-track="22">&nbsp;</p>
<p data-track="23">OSI采用了分层的结构化技术，共分七层，分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p>
<p data-track="24">&nbsp;</p>
<p data-track="25">(应表会传网数物)</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d7e25447dbb94a058238e56995324ab3~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=oFik%2Fd3D%2BH2XbLLSB9cB3qF%2Fgks%3D" data-ic="false" data-width="1080" data-height="669" data-ic-uri=""></div>
<p data-track="26">&nbsp;</p>
<p data-track="27"><strong>2.OSI七层模型各层的作用</strong></p>
<p data-track="28"><strong>(1)物理层的简介</strong></p>
<p data-track="29"><strong>(2)数据链路层的简介</strong></p>
<p data-track="30"><strong>(3)网络层的简介</strong></p>
<p data-track="31"><strong>(4)传输层的简介</strong></p>
<p data-track="32"><strong>(5)会话层的简介</strong></p>
<p data-track="33"><strong>(6)表示层的简介</strong></p>
<p data-track="34"><strong>(7)应用层的简介</strong></p>
<p data-track="35">&nbsp;</p>
<p data-track="36"><strong>(1)物理层的简介</strong></p>
<p data-track="37">物理层并不是指物理媒体本身，而是指开放系统中利用物理媒体实现物理连接的功能描述，物理层的媒体包括架空明线、平衡电缆、光纤、无线信道等。</p>
<p data-track="38">&nbsp;</p>
<p data-track="39">物理层的主要功能如下：</p>
<p data-track="40">&nbsp;</p>
<p data-track="41"><strong>功能一：为数据端设备提供传送数据的通路</strong></p>
<p data-track="42">数据通路可以是一个物理媒体，也可以是多个物理媒体连接而成。一次完整的数据传输，包括激活物理连接、传送数据和终止物理连接。激活就是在通信的两个数据终端设备之间建立起连接，形成一条通路。</p>
<p data-track="43">&nbsp;</p>
<p data-track="44"><strong>功能二：传输数据</strong></p>
<p data-track="45">物理层如果要形成适合数据传输所需的实体来为数据传输进行服务，那么一要保证数据能在其上正确通过，二要提供足够的带宽来减少信道上的拥塞，其中带宽指的是每秒能通过的比特(Bit)数。此外数据传输的方式应该满足如下几种情况的需要：点到点、一点到多点、串行或并行、半双工或全双工、同步或异步。</p>
<p data-track="46">&nbsp;</p>
<p data-track="47"><strong>(2)数据链路层的简介</strong></p>
<p data-track="48">数据链路层可以粗略理解为数据通道，因为物理层已经为终端设备间的数据通信提供传输介质及其连接。其中介质是长期的，连接是有生存期的。在连接的生存期内，收发两端可以进行不等的一次或多次数据通信。每次通信都要经过建立通信联络和拆除通信联络两个过程。这种建立起来的数据收发关系就叫做数据链路。</p>
<p data-track="49">&nbsp;</p>
<p data-track="50">在物理媒体上传输的数据难免受到各种不可靠因素的影响而产生差错。为弥补物理层不足，为上层提供无差错的数据传输，需要对数据检错和纠错。</p>
<p data-track="51">&nbsp;</p>
<p data-track="52">数据链路层应具备如下功能：</p>
<p data-track="53">一.链路连接的建立、拆除和分离</p>
<p data-track="54">二.差错检测和恢复、链路标识、流量控制等</p>
<p data-track="55">三.独立的链路产品中最常见的当属网卡，网桥也是一种链路产品</p>
<p data-track="56">&nbsp;</p>
<p data-track="57"><strong>(3)网络层的简介</strong></p>
<p data-track="58">当数据终端增多时，它们之间会有中继设备进行相连，此时会出现一台终端要求不只是与惟一一台而是能和多台终端通信的情况。这就产生了把任意两台数据终端设备的数据链接起来的问题，也就是路由。</p>
<p data-track="59">&nbsp;</p>
<p data-track="60">另外，当一条物理信道建立后被一对用户使用，往往有许多空闲时间被浪费。这时候为了避免浪费，自然就会希望能够让多对用户共用一条链路。所以为了解决这一问题，于是就出现了逻辑信道技术和虚拟电路技术。</p>
<p data-track="61">&nbsp;</p>
<p data-track="62"><strong>(4)传输层的简介</strong></p>
<p data-track="63">有一个既定的事实，即世界上各种通信子网在性能上存在着很大差异。如电话交换网、分组交换网、公用数据交换网、局域网等通信子网都可互连，但它们提供的吞吐量、传输速率、数据延迟等数据传输却是各不相同。</p>
<p data-track="64">&nbsp;</p>
<p data-track="65">而对于会话层来说，却要求有一性能恒定的界面，所以传输层的作用就是：在终端用户之间提供透明的数据传输，向上层提供可靠的数据传输服务。</p>
<p data-track="66">&nbsp;</p>
<p data-track="67"><strong>(5)会话层的简介</strong></p>
<p data-track="68">会话层就是会话单位的控制层，其主要作用是：按照在应用进程间约定的原则、按正确顺序收发数据，进行各种形态的对话。</p>
<p data-track="69">&nbsp;</p>
<p data-track="70">会话层规定了会话服务期间，用户间的会话连接建立、拆除和数据传送流程。会话层提供的服务是应用建立和维持会话，并能使会话获得同步。会话层使用校验点可使通信会话在通信失效时从校验点继续恢复通信，这种能力对于传送大的文件极为重要。</p>
<p data-track="71">&nbsp;</p>
<p data-track="72"><strong>(6)表示层的简介</strong></p>
<p data-track="73">表示层的主要作用是把应用层提供的信息变换为能够共同理解的形式，提供字符代码、数据格式、控制信息格式、加密等的统一表示。表示层的作用之一是为异种机通信提供一种公共语言，以便能进行互操作。</p>
<p data-track="74">&nbsp;</p>
<p data-track="75">之所以需要表示层，是因为不同的计算机体系结构使用的数据表示法不同。例如，IBM主机使用EBCDIC编码，而大部分PC机使用的是ASCII码。在这种情况下，便需要表示层来完成这种转换。</p>
<p data-track="76">&nbsp;</p>
<p data-track="77"><strong>(7)应用层的简介</strong></p>
<p data-track="78">应用层的主要作用就是向应用程序提供服务，这些服务按其向应用程序提供的特性分成组，并称为服务元素。有些可以为多种应用程序共同使用，有些则只能为较少的一类应用程序使用。应用层是开放系统的最高层，是直接为应用进程提供服务的。在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需要的服务。</p>
<p data-track="79">&nbsp;</p>
<p data-track="80"><strong>3.TCP/IP协议的简介</strong></p>
<p data-track="81">TCP/IP是Transmission Control Protocol/Internet Protocol的简写，TCP/IP的字面上的意思是传输控制协议/因特网互联协议。TCP/IP协议由网络层的IP协议和传输层的TCP协议组成，采用的是4层模型。在很多情况下，TCP/IP协议是利用IP进行通信时所用到的协议群的统称。常说的TCP/IP协议通常是指TCP/IP协议族，而不仅仅是TCP协议和IP协议。</p>
<p data-track="82">&nbsp;</p>
<p data-track="83">通俗而言：TCP负责发现传输的问题，一旦发现有问题就发出信号要求重新传输。所以TCP可以保证所有数据安全正确地传输到目的地，IP则是给因特网的每一台联网设备规定一个地址。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/849fdc18b87c45f2bb0cff422488a2f3~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=M5eYPVB2fEcnwhZIvFmGyU1432c%3D" data-ic="false" data-width="1080" data-height="538" data-ic-uri=""></div>
<p data-track="84">&nbsp;</p>
<p data-track="85"><strong>4.TCP和UDP的简介</strong></p>
<p data-track="86"><strong>(1)TCP和UDP简单对比</strong></p>
<p data-track="87"><strong>(2)TCP的简介</strong></p>
<p data-track="88"><strong>(3)UDP的简介</strong></p>
<p data-track="89"><strong>(4)TCP和UDP的优缺点</strong></p>
<p data-track="90"><strong>(5)传输层中的端口号</strong></p>
<p data-track="91"><strong>(6)端口号的确定</strong></p>
<p data-track="92">&nbsp;</p>
<p data-track="93"><strong>(1)TCP和UDP简单对比</strong></p>
<p data-track="94">TCP是面向连接的、可靠的流协议。TCP通过三次握手建立连接，通讯完成时需要拆除连接。</p>
<p data-track="95">&nbsp;</p>
<p data-track="96">UDP是面向无连接的通讯协议。UDP通讯时不需要接收方进行确认，属于不可靠的传输，因此可能会出现丢包的现象。</p>
<p data-track="97">&nbsp;</p>
<p data-track="98"><strong>(2)TCP的简介</strong></p>
<p data-track="99">TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时拆除连接。由于TCP是面向连接的，所以只能用于端到端的通讯。</p>
<p data-track="100">&nbsp;</p>
<p data-track="101">TCP提供的是一种可靠的数据流服务，采用带重传的肯定确认技术来实现传输的可靠性。</p>
<p data-track="102">&nbsp;</p>
<p data-track="103">TCP还采用一种称为滑动窗口的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p>
<p data-track="104">&nbsp;</p>
<p data-track="105">如果IP数据包中有已封好的TCP数据包，那么IP将把它们向上传送到TCP。TCP会将数据包进行排序以及进行错误检查，同时实现虚电路间的连接。TCP数据包中包括序号和确认，所以收到的包可被排序，损坏的包可被重传。</p>
<p data-track="106">&nbsp;</p>
<p data-track="107">TCP将它的信息送到更高层的应用程序，例如Telnet的服务程序和客户程序，而更高层的应用程序又会将信息送回给TCP层。TCP层便将它们向下传送到IP层、设备驱动程序和物理介质，最后到接收方。面向连接的服务(如Telnet、FTP、SMTP)需要高度的可靠性，所以使用TCP。</p>
<p data-track="108">&nbsp;</p>
<p data-track="109"><strong>(3)UDP的简介</strong></p>
<p data-track="110">UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号。由于基于UDP的通讯不需要连接，所以UDP可以实现广播发送。</p>
<p data-track="111">&nbsp;</p>
<p data-track="112">UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象。所以实际应用中采用UDP进行通讯时，需要程序员编程验证。</p>
<p data-track="113">&nbsp;</p>
<p data-track="114">UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务。UDP主要用于那些面向查询应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。</p>
<p data-track="115">&nbsp;</p>
<p data-track="116">使用UDP的服务包括：</p>
<p data-track="117">一.NTP(网络时间协议)和DNS(DNS也使用TCP)，包总量较少的通信</p>
<p data-track="118">二.视频、音频等多媒体通信(即时通信)</p>
<p data-track="119">三.限定于LAN等特定网络中的应用通信</p>
<p data-track="120">四.广播通信(广播、多播)</p>
<p data-track="121">&nbsp;</p>
<p data-track="122"><strong>(4)TCP和UDP的优缺点</strong></p>
<p data-track="123">TCP主要用于在传输层必须要实现可靠传输的情况，UDP主要用于需要高速传输、对实时性要求较高的通信或广播通信。</p>
<p data-track="124">&nbsp;</p>
<p data-track="125"><strong>(5)传输层中的端口号</strong></p>
<p data-track="126">数据链路中的地址和IP中的地址，分别指的是MAC地址和IP地址。MAC地址用来识别同一链路中不同的计算机，IP地址用来识别TCP/IP网络中互连的主机和路由器。</p>
<p data-track="127">&nbsp;</p>
<p data-track="128">在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中可以进行通信的不同应用程序。因此，端口号也被称为程序地址。</p>
<p data-track="129">&nbsp;</p>
<p data-track="130">一台计算机上同时可以运行多个程序，传输层协议正是利用端口号识别正在进行通信的应用程序，并准确传输数据。</p>
<p data-track="131">&nbsp;</p>
<p data-track="132">MAC地址(数据链路层)：识别同一链路中不同的计算机，可以理解为网卡的地址。</p>
<p data-track="133">&nbsp;</p>
<p data-track="134">IP地址(传输层/网络层)：识别TCP/IP网络中互连的主机和路由器。</p>
<p data-track="135">&nbsp;</p>
<p data-track="136">程序地址或端口号(传输层)：识别同一台计算机中进行通信的不同应用程序。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/90a4ccdbb69e47beb9168e5d2ff505da~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=XjtADUMYVXLlme6i7R99lsS6kYA%3D" data-ic="false" data-width="882" data-height="718" data-ic-uri=""></div>
<p data-track="137">数据报文的构成(识别一个通信的5个元素)如下：源IP地址、目标IP地址、协议号、源端口号、目标端口号、数据。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a796e98d7c094e52b1db539fdc633753~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=UyMjns%2FDvo0MlyQM3Yxy5GFXXr4%3D" data-ic="false" data-width="1080" data-height="543" data-ic-uri=""></div>
<p data-track="138"><strong>(6)端口号的确定</strong></p>
<p data-track="139">标准既定的端口号：</p>
<p data-track="140">这种方法也叫静态方法，它是指每个应用程序都有其指定端口号，但并不是可随意使用任一端口号。例如HTTP、FTP等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在0~1023之间。除知名端口号之外，还有一些端口号被正式注册。它们分布在1024~49151之间，不过这些端口号可用于任何通信用途。</p>
<p data-track="141">&nbsp;</p>
<p data-track="142">时序分配法：</p>
<p data-track="143">服务端有必要确定监听端口号，但接受服务的客户端没必要确定端口号。客户端的应用程序可以不用自己设置端口号，而交给操作系统进行分配，动态分配的端口号范围是49152 ~ 65535。</p>
<p data-track="144">&nbsp;</p>
<p data-track="145"><strong>5.TCP连接的三次握手</strong></p>
<p data-track="146">TCP提供面向有连接的通信传输，面向有连接是指在数据通信开始之前先做好两端之间的准备工作。</p>
<p data-track="147">&nbsp;</p>
<p data-track="148">所谓三次握手是指：建立一个TCP连接时，需要客户端和服务器端发送三个包以确认连接建立。在Socket编程中，三次握手的过程由客户端执行connect()方法来触发。</p>
<p data-track="149">&nbsp;</p>
<p data-track="150"><strong>第一次握手：</strong></p>
<p data-track="151">首先客户端将标志位SYN设置为1，并随机产生一个值seq=x。然后将SYN=1,ACK=0,seq=x封装成数据包发送给服务器端，发起连接请求。接着客户端进入SYN_SENT状态，等待服务器端确认。</p>
<p data-track="152">&nbsp;</p>
<p data-track="153"><strong>第二次握手：</strong></p>
<p data-track="154">服务器端收到数据包后，通过标志位SYN=1知道客户端在请求建立连接。于是将标志位SYN和ACK设置为1，值ack=x+1，并随机产生一个值seq=y。然后将SYN=1,ACK=1,ack=x+1,seq=y封装成数据包发送给客户端，确认连接请求。接着服务器端进入SYN_RCVD状态。</p>
<p data-track="155">&nbsp;</p>
<p data-track="156"><strong>第三次握手：</strong></p>
<p data-track="157">客户端收到服务器端返回的确认后，检查ack是否为x+1，ACK是否为1。如果正确则将标志位ACK设置为1，值ack=y+1，并将该数据包发送给服务器端。服务器端收到数据包后检查ack是否为y+1，ACK是否为1。如果是则表明连接建立成功，客户端和服务器端进入ESTABLISHED状态。从而完成三次握手，之后客户端与服务器端就可以开始传输数据了。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/be86d401862643b892d83e8f3042eba5~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=vGRJevb8pOou%2BbcHfvVKkISzaXE%3D" data-ic="false" data-width="1052" data-height="914" data-ic-uri=""></div>
<p data-track="158">&nbsp;</p>
<p data-track="159"><strong>6.TCP连接的四次挥手</strong></p>
<p data-track="160">所谓四次挥手是指：断开一个TCP连接时，需要客户端和服务端发送四个包以确认连接断开。在Socket编程中，这一过程由客户端或服务端任一方执行close()方法触发。</p>
<p data-track="161">&nbsp;</p>
<p data-track="162">由于TCP连接是全双工的，因此每个方向都必须要单独进行关闭。也就是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接。收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据。但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p data-track="163">&nbsp;</p>
<p data-track="164"><strong>第一次挥手：</strong></p>
<p data-track="165">客户端发出断开连接的报文，并且停止发送数据。在断开连接的报文中，FIN=1，序列号seq=u。这个序列号u等于前面已经传送过来的数据的最后一个字节的序号加1，此时客户端会进入FIN-WAIT-1(终止等待1)状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p>
<p data-track="166">&nbsp;</p>
<p data-track="167"><strong>第二次挥手：</strong></p>
<p data-track="168">服务器收到断开连接的报文，发出确认报文。在确认报文中，ACK=1，ack=u+1，序列号seq=v。此时服务端就进入了CLOSE-WAIT(关闭等待)状态。这时处于半关闭状态，即客户端已没有数据要发送了。但如果服务器若发送数据给客户端，客户端依然需要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
<p data-track="169">&nbsp;</p>
<p data-track="170">客户端收到服务器的确认报文后，就会进入FIN-WAIT-2(终止等待2)状态，等待服务器发送断开连接的报文。在收到服务器的断开连接报文之前，还需要接收服务器发送的最后的数据。</p>
<p data-track="171">&nbsp;</p>
<p data-track="172"><strong>第三次挥手：</strong></p>
<p data-track="173">服务器将最后的数据发送完毕后，会向客户端发送断开连接的报文。由于在半关闭状态下，服务器很可能又发送了一些数据。在断开连接的报文中，FIN=1，ack=u+1，序列号为seq=w。此时服务器就进入了LAST-ACK(最后确认)状态，等待客户端的确认。</p>
<p data-track="174">&nbsp;</p>
<p data-track="175"><strong>第四次挥手：</strong></p>
<p data-track="176">客户端收到服务器的断开连接报文后，必须发出确认。在确认报文中，ACK=1，ack=w+1，序列号seq=u+1。此时客户端就进入了TIME-WAIT(时间等待)状态。注意此时TCP连接还没有释放，必须经过2∗MSL(最长报文段寿命)的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p>
<p data-track="177">&nbsp;</p>
<p data-track="178">服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/2b267c0820984d7ebf9099969040b16c~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=YHrkQVFtKV%2FoOLJkHJWRsI9op2o%3D" data-ic="false" data-width="1080" data-height="647" data-ic-uri=""></div>
<p data-track="179">&nbsp;</p>
<p data-track="180"><strong>7.TCP/IP中的数据包</strong></p>
<p data-track="181">包是全能性术语，帧用于表示数据链路层中包的单位，片是IP中数据的单位，段则表示TCP数据流中的信息，消息是指应用协议中数据的单位。</p>
<p data-track="182">&nbsp;</p>
<p data-track="183">每个分层中，都会对所发送的数据附加一个首部。在这个首部中会包含该层必要的信息，如发送的目标地址和协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>
<p data-track="184">&nbsp;</p>
<p data-track="185">网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息和所要处理的数据。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/51d02e09a59545baa1f55fb3f652b510~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=2xu7O%2FpBq4v4XTGVT8mDA%2FZtlT8%3D" data-ic="false" data-width="1080" data-height="960" data-ic-uri=""></div>
<p data-track="186">上图客户端发送的包到达服务端后，每一层的流转处理流程如下：</p>
<p data-track="187">&nbsp;</p>
<p data-track="188"><strong>一.应用程序处理</strong></p>
<p data-track="189">首先应用程序会进行编码处理，这些编码相当于OSI的表示层功能。编码转化后，邮件不一定马上被发送出去。这种何时建立通信连接何时发送数据的管理功能，相当于OSI的会话层功能。</p>
<p data-track="190">&nbsp;</p>
<p data-track="191"><strong>二.TCP模块的处理</strong></p>
<p data-track="192">TCP根据应用的指示，负责建立连接、发送数据以及断开连接，TCP提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个TCP首部。</p>
<p data-track="193">&nbsp;</p>
<p data-track="194"><strong>三.IP模块的处理</strong></p>
<p data-track="195">IP将TCP传过来的TCP首部和TCP数据合起来当做自己的数据，并在TCP首部的前端加上自己的IP首部。IP包生成后，参考路由控制表决定接受此IP包的路由或主机。</p>
<p data-track="196">&nbsp;</p>
<p data-track="197"><strong>四.网络接口(以太网驱动)的处理</strong></p>
<p data-track="198">从IP传过来的IP包对于以太网来说就是数据，给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</p>
<p data-track="199">&nbsp;</p>
<p data-track="200"><strong>五.网络接口(以太网驱动)的处理</strong></p>
<p data-track="201">主机收到以太网包后，首先从以太网包首部找到MAC地址判断是否为发送给自己的包。如果不是则丢弃数据，如果是则从以太网包首部中的类型确定数据类型。确定数据类型后，再将数据包传给相应的模块，如 IP、ARP等。</p>
<p data-track="202">&nbsp;</p>
<p data-track="203"><strong>六.IP模块的处理</strong></p>
<p data-track="204">IP模块接收到数据后也做类似的处理，从数据包首部中判断此IP地址是否与自己的IP地址匹配。如果匹配则根据首部的协议类型将数据发送给对应的模块，如TCP/UDP。另外对于有路由器的情况，接收端地址往往不是自己的地址。此时需要借助路由控制表，查出应发送的主机或路由器之后再进行数据转发。</p>
<p data-track="205">&nbsp;</p>
<p data-track="206"><strong>七.TCP模块的处理</strong></p>
<p data-track="207">在TCP模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</p>
<p data-track="208">&nbsp;</p>
<p data-track="209"><strong>八.应用程序的处理</strong></p>
<p data-track="210">接收端应用程序会直接接收发送端发送的数据，通过解析数据，展示相应的内容。</p>
<p data-track="211">&nbsp;</p>
<p data-track="212"><strong>8.TCP通过确认应答与序列号提高可靠性</strong></p>
<p data-track="213">TCP是如何提高可靠性：确认应答、序列号。开发时可借鉴TCP提高可靠性的方法来提高程序的可靠性。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/c86676a8f5624fc68a399022e72a0135~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=j3zsj3nd6%2BBiFJsMlksmAM4i9P4%3D" data-ic="false" data-width="1080" data-height="459" data-ic-uri=""></div>
<p data-track="214">在TCP中，当发送端发出的数据到达接收端的主机时，接收端主机会返回一个已收到消息的通知，这个消息叫做确认应答(ACK)。</p>
<p data-track="215">&nbsp;</p>
<p data-track="216">当发送端将数据发出之后会等待接收端的确认应答(ACK)。如果有确认应答，说明数据已经成功到达接收端。反之，则数据丢失的可能性很大。如果发送端在一定时间内没等到接收端的确认应答，则认为数据丢失要重发。因此即使出现丢包，发送端仍能保证数据能到达接收端，从而实现可靠传输。</p>
<p data-track="217">&nbsp;</p>
<p data-track="218">发送端未收到确认应答并不意味着数据一定丢失，也有可能是接收端已收到数据，但是返回的确认应答在途中丢失了，这种情况也会导致发送端误以为数据没有到达接收端而重发数据。</p>
<p data-track="219">&nbsp;</p>
<p data-track="220">对于接收端来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，接收端必须放弃重复的数据包。因此引入了序列号，即按顺序给发送数据的每一个字节都标上号码的编号。接收端会查询收到的TCP数据包首部中的序列号和数据长度，将自己下一步应该接收的序列号作为确认应答发送回去。</p>
<p data-track="221">&nbsp;</p>
<p data-track="222">通过序列号和确认应答号，TCP既能够识别是否已经接收到数据，又能够判断是否需要接收数据，从而实现可靠的传输。</p>
<p data-track="223">&nbsp;</p>
<p data-track="224"><strong>9.HTTP请求的传输过程</strong></p>
<p data-track="225"><strong>(1)HTTP请求的传输过程介绍</strong></p>
<p data-track="226"><strong>(2)一次完整的HTTP请求的8个过程</strong></p>
<p data-track="227"><strong>(3)建立TCP连接</strong></p>
<p data-track="228"><strong>(4)客户端向服务器发送请求行</strong></p>
<p data-track="229"><strong>(5)客户端发送请求头信息</strong></p>
<p data-track="230"><strong>(6)客户端发送请求数据</strong></p>
<p data-track="231"><strong>(7)服务器向客户端返回响应行</strong></p>
<p data-track="232"><strong>(8)服务器返回响应头信息</strong></p>
<p data-track="233"><strong>(9)服务器返回响应数据</strong></p>
<p data-track="234"><strong>(10)服务器关闭TCP连接</strong></p>
<p data-track="235">&nbsp;</p>
<p data-track="236"><strong>(1)HTTP请求的传输过程介绍</strong></p>
<p data-track="237">首先作为发送端的客户端在应用层(HTTP协议)发出一个HTTP请求，然后在传输层(TCP协议)把从应用层处收到的数据(HTTP请求报文)进行分割，并在各个报文上打上标记序号及端口号后转发给网络层，接着在网络层(IP协议)增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</p>
<p data-track="238">&nbsp;</p>
<p data-track="239">接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当数据传输到应用层时，才算真正接收到由客户端发送过来的HTTP请求。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/61b72ba8c6624c6bb02cb4619703f013~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=%2F4bbcarH%2Bkkf2XDy0Av8ga0JCqc%3D" data-ic="false" data-width="926" data-height="1202" data-ic-uri=""></div>
<p data-track="240">&nbsp;</p>
<p data-track="241"><strong>(2)一次完整的HTTP请求的8个过程</strong></p>
<p data-track="242">一.建立TCP连接</p>
<p data-track="243">二.客户端向服务器发送请求行</p>
<p data-track="244">三.客户端发送请求头信息</p>
<p data-track="245">四.服务器向客户端返回响应行</p>
<p data-track="246">五.服务器返回响应头信息</p>
<p data-track="247">六.服务器向客户端发送响应数据</p>
<p data-track="248">七.服务器关闭TCP连接</p>
<p data-track="249">&nbsp;</p>
<p data-track="250"><strong>(3)建立TCP连接</strong></p>
<p data-track="251">HTTP连接是无状态的，建立前需要进行3次握手。连接在HTTP工作开始前，客户端首先要通过网络与服务器建立连接。该连接是通过TCP来完成的，该协议与IP协议共同构建Internet。即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。</p>
<p data-track="252">&nbsp;</p>
<p data-track="253">HTTP是比TCP更高层次的应用层协议。根据规则，只有低层协议建立之后，才能进行高层协议的连接。因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p>
<p data-track="254">&nbsp;</p>
<p data-track="255"><strong>(4)客户端向服务器发送请求行</strong></p>
<p data-track="256">一旦建立了TCP连接，客户端就会向服务器发送请求行。例如：GET/sample/hello.html HTTP/1.1。</p>
<p data-track="257">&nbsp;</p>
<p data-track="258"><strong>(5)客户端发送请求头信息</strong></p>
<p data-track="259">客户端发送请求命令后，便会向服务器发送请求头信息。之后客户端发送一空白行给服务器，表示结束请求头信息的发送。</p>
<p data-track="260">&nbsp;</p>
<p data-track="261"><strong>(6)客户端发送请求数据</strong></p>
<p data-track="262">接着以Content-Type请求头信息所描述的格式发送请求数据。</p>
<p data-track="263">&nbsp;</p>
<p data-track="264"><strong>(7)服务器向客户端返回响应行</strong></p>
<p data-track="265">服务器收到客户端发来的请求后，将会向客户端返回响应行。例如HTTP/1.1 200 OK，响应结果的第一部分是协议版本号和响应状态码。</p>
<p data-track="266">&nbsp;</p>
<p data-track="267"><strong>(8)服务器返回响应头信息</strong></p>
<p data-track="268">服务器返回响应后，便会向客户端返回响应头信息，其中会发送一个空白行来表示响应头信息的发送到此为结束。</p>
<p data-track="269">&nbsp;</p>
<p data-track="270"><strong>(9)服务器返回响应数据</strong></p>
<p data-track="271">接着以Content-Type响应头信息所描述的格式返回响应数据。</p>
<p data-track="272">&nbsp;</p>
<p data-track="273"><strong>(10)服务器关闭TCP连接</strong></p>
<p data-track="274">一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭TCP连接。如果客户端或服务器在其头信息加入了Connection:keep-alive，那么TCP连接在发送后将仍然保持打开状态，于是客户端可以继续通过相同的连接发送请求。保持TCP连接可以节省为每个请求建立新连接的时间，以及节约网络带宽。</p>
<p data-track="275">&nbsp;</p>
<p data-track="276"><strong>10.HTTP协议报文结构</strong></p>
<p data-track="277">用于HTTP协议交互的信息被称为HTTP报文。请求端(客户端)的HTTP报文叫做请求报文，响应端(服务器端)的叫做响应报文。HTTP报文本身是由多行(用CR+LF作换行符)数据构成的字符串文本。HTTP报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行(CR+LF)来划分，通常并不一定有报文主体。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/cdc3710298284bc4a4f437141b0b0ee8~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=T8zHjss4q9lODyTaWdpc93UNwvg%3D" data-ic="false" data-width="972" data-height="684" data-ic-uri=""></div>
<p data-track="278"><strong>一.请求报文结构</strong></p>
<p data-track="279">请求报文的首部内容由以下数据组成：请求行——包含用于请求的方法、请求URI和HTTP版本，请求头——包含表示请求的各种条件和属性的各类首部。比如通用首部、请求首部、实体首部以及RFC里未定义的首部如Cookie等。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/f020905858e447b8b9643447efad4f7d~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=dR%2BpYmPE6sWaBqt%2Fjs4f2ltaA1U%3D" data-ic="false" data-width="1080" data-height="351" data-ic-uri=""></div>
<p data-track="280"><strong>二.响应报文结构</strong></p>
<p data-track="281">响应行——包含表明响应结果的状态码、原因短语和HTTP版本，响应头——包含表示请求的各种条件和属性的各类首部。比如通用首部、响应首部、实体首部以及RFC里未定义的首部如Cookie等。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d915844d15624ef6bfe74e2e7d951c1d~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=RhdGK%2BlPaOCdMrJjtHA%2Fzvas0oo%3D" data-ic="false" data-width="1080" data-height="357" data-ic-uri=""></div>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/4e17658023414b75b7d306c385c1780e~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=oSnu4ryOOG1yDtm9nN2IcwF26C0%3D" data-ic="false" data-width="1080" data-height="389" data-ic-uri=""></div>
<p data-track="282">&nbsp;</p>
<p data-track="283"><strong>11.Socket、短连接、长连接、网络IO流程</strong></p>
<p data-track="284"><strong>(1)Socket</strong></p>
<p data-track="285"><strong>(2)短连接和长连接</strong></p>
<p data-track="286"><strong>(3)网络IO读写的流程</strong></p>
<p data-track="287">&nbsp;</p>
<p data-track="288"><strong>(1)Socket</strong></p>
<p data-track="289">Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。Socket使用门面模式把复杂的TCP/IP协议族隐藏在Socket接口后面。</p>
<p data-track="290">&nbsp;</p>
<p data-track="291">主机A的应用程序要能和主机B的应用程序通信，必须通过Socket建立连接。而建立Socket连接必须需要底层TCP/IP协议来建立TCP连接，建立TCP连接需要底层IP协议来寻址网络中的主机。</p>
<p data-track="292">&nbsp;</p>
<p data-track="293">网络层使用的IP协议可以根据IP地址来找到目标主机，但是一台主机上可能运行着多个应用程序，为了与指定的应用程序通信，还要指定TCP或UPD的地址也就是端口号。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/b9b7cdcef02e42db83ff645b06d69210~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=YzFvZvhn597lkrD90oZec6zgTUk%3D" data-ic="false" data-width="1080" data-height="493" data-ic-uri=""></div>
<p data-track="294">下面是一对TCP客户端与服务端进程之间的交换流程时间表。服务端首先启动，稍后某个时刻客户端启动，它试图连接到服务端。假设客户端给服务端发送一个请求，服务端处理该请求后返回一个响应。这个过程一直持续下去，直到客户端关闭连接。</p>
<p data-track="295">&nbsp;</p>
<p data-track="296">客户端和服务端都从调用socket()方法开始，它会返回一个套接字描述符。随后客户端调用connect()方法，服务端则调用bind()、listen()和accept()。客户端和服务端的数据交互则通过调用read()和write()方法来实现。关闭连接时，则通过调用close()方法来实现。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/5c0d9feaa80144839fc2efa92b7bd4c7~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=4k4Hk1lNAzxSKkBx%2BtSkXaCNv5c%3D" data-ic="false" data-width="1080" data-height="1101" data-ic-uri=""></div>
<p data-track="297"><strong>(2)短连接和长连接</strong></p>
<p data-track="298">短连接的过程：连接 -&gt; 传输数据 -&gt; 关闭连接。浏览器和服务端每进行一次HTTP操作就建立一次连接，任务结束就中断连接。</p>
<p data-track="299">&nbsp;</p>
<p data-track="300">短连接是指：建立Socket(TCP)连接后，发送 + 接收完数据就马上断开连接。</p>
<p data-track="301">&nbsp;</p>
<p data-track="302">长连接的过程：连接 -&gt; 传输数据 -&gt; 保持连接 -&gt; 传输数据 -&gt; ... -&gt; 关闭连接。</p>
<p data-track="303">&nbsp;</p>
<p data-track="304">长连接是指：建立Socket(TCP)连接后，不管是否使用都保持连接，安全性较差。</p>
<p data-track="305">&nbsp;</p>
<p data-track="306">每个TCP连接都需要三步握手，这需要时间。如果每个操作都是先连接，再操作的话那么处理速度会降低很多。所以长连接适用于操作频繁的通信，但是长连接的数量不能太多。</p>
<p data-track="307">&nbsp;</p>
<p data-track="308">数据库的连接一般都用长连接。如果用短连接，那么频繁的通信会造成频繁的Socket创建，降低性能。所以，连接池一般使用的都是长连接。</p>
<p data-track="309">&nbsp;</p>
<p data-track="310">网站的HTTP服务一般都用短连接。因为长连接会消耗服务端的资源，而且网站服务通常需要处理大量的用户请求。所以请求量大，但每个请求不会频繁操作的情况下，使用短连接更好。</p>
<p data-track="311">&nbsp;</p>
<p data-track="312"><strong>(3)Java IO读写的底层流程</strong></p>
<p data-track="313">用户程序进行IO读写，基本上会用到系统调用read和write。系统调用read把数据从内核缓冲区(内核空间)复制到进程缓冲区(用户空间)，系统调用write把数据从用户缓冲区(用户空间)复制到内核缓冲区(内核空间)。它们并不等价数据在内核缓冲区和磁盘之间的交换。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/1270741b5be34eb0a6df1cd10d831047~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=vpXbiMx47M6CLqGpyla7oYG48Wo%3D" data-ic="false" data-width="1080" data-height="691" data-ic-uri=""></div>
<p data-track="314">Java服务端处理网络请求的典型过程：</p>
<p data-track="315">&nbsp;</p>
<p data-track="316"><strong>步骤一：接收客户端请求</strong></p>
<p data-track="317">Linux通过网卡，读取客户断的请求数据，将数据读取到内核缓冲区。</p>
<p data-track="318">&nbsp;</p>
<p data-track="319"><strong>步骤二：获取请求数据</strong></p>
<p data-track="320">服务端从内核缓冲区读取数据到Java进程缓冲区。</p>
<p data-track="321">&nbsp;</p>
<p data-track="322"><strong>步骤三：服务器端业务处理</strong></p>
<p data-track="323">Java服务端在自己的用户空间中处理客户端请求。</p>
<p data-track="324">&nbsp;</p>
<p data-track="325"><strong>步骤四：服务器端返回数据</strong></p>
<p data-track="326">Java服务端已构建好的响应，从Java进程缓冲区写入内核缓冲区。</p>
<p data-track="327">&nbsp;</p>
<p data-track="328"><strong>步骤五：发送数据给客户端</strong></p>
<p data-track="329">Linux内核通过网络IO ，将内核缓冲区中的数据，写入网卡。网卡通过底层的通讯协议，会将数据发送给目标客户端。</p>
<p data-track="330">&nbsp;</p>
<p data-track="331">由于系统调用是在内核态中运行的，所以进行系统调用时，系统需要从用户态切换到内核态。系统从用户态切换到内核态的这个过程会产生性能损耗。在切换之前需要保存用户态的状态，包括寄存器、程序指令等。然后才能执行内核态的系统调用指令，最后还要恢复用户态。</p>
<p data-track="332">&nbsp;</p>
<p data-track="333">用户态和内核态表示的是操作系统中的不同执行权限。两者最大的区别在于：运行在用户空间中的进程不能直接访问操作系统内核的指令和程序，运行在内核空间中的进程可以直接访问操作系统内核的指令和程序。进行权限划分是为了避免用户在进程中直接操作危险的系统指令，从而影响进程和系统的稳定。</p>
<p data-track="334">&nbsp;</p>
<p data-track="335"><strong>12.Linux的IO模型详情</strong></p>
<p data-track="336"><strong>(1)同步和异步、阻塞和非阻塞</strong></p>
<p data-track="337"><strong>(2)Linux的IO模型之阻塞IO模型(同步)</strong></p>
<p data-track="338"><strong>(3)Linux的IO模型之非阻塞IO模型(同步)</strong></p>
<p data-track="339"><strong>(4)Linux的IO模型之IO复用模型(同步)</strong></p>
<p data-track="340"><strong>(5)Linux的IO模型之信号驱动IO(同步)</strong></p>
<p data-track="341"><strong>(6)Linux的IO模型之异步IO模型(异步)</strong></p>
<p data-track="342"><strong>(7)Linux的5个IO模型对比</strong></p>
<p data-track="343">&nbsp;</p>
<p data-track="344"><strong>(1)同步和异步、阻塞和非阻塞</strong></p>
<p data-track="345">同步和异步关注的是：结果的通知方式。同步是指：调用方需要主动等待结果的返回。异步是指：调用方不需要主动等待结果的返回，调用方会通过其他方式(如状态通知、回调函数等)来等待结果的返回。</p>
<p data-track="346">&nbsp;</p>
<p data-track="347">阻塞和非阻塞关注的是：等待结果返回的调用方的状态。阻塞是指：结果返回之前，当前线程被挂起，不做任何事情。非阻塞是指：结果在返回之前，当前线程可以做其他事情，不会被挂起。</p>
<p data-track="348">&nbsp;</p>
<p data-track="349">同步和异步关注的是：是否亲自主动获取消息，是否由其他人通知自己。</p>
<p data-track="350">&nbsp;</p>
<p data-track="351">阻塞和非阻塞关注的是：当前事情还没好时是否还能做其他事情。</p>
<p data-track="352">&nbsp;</p>
<p data-track="353"><strong>一.同步阻塞</strong></p>
<p data-track="354">同步阻塞基本也是编程中最常见的模型。比如客户去商店买衣服，去了之后发现衣服卖完了，就在店里面一直等，期间不做任何事(包括看手机)，等着商家进货，直到有货为止，效率很低。</p>
<p data-track="355">&nbsp;</p>
<p data-track="356"><strong>二.同步非阻塞</strong></p>
<p data-track="357">同步非阻塞在编程中可以抽象为一个轮询模式。客户去了商店之后，发现衣服卖完了，这个时候不需要傻傻的等着，客户可以去其他地方比如奶茶店买杯水，但是还是需要客户时不时的主动去商店问老板新衣服到了没有。</p>
<p data-track="358">&nbsp;</p>
<p data-track="359"><strong>三.异步阻塞</strong></p>
<p data-track="360">异步阻塞这个编程里面用的较少。这类似于写了个线程池，submit()后马上future.get()，此时线程还是挂起的。客户去商店买衣服，发现衣服没有了，于是就给老板留给电话，告诉老板说衣服到了就打电话进行通知，然后就一直守着电话不做其他事情。</p>
<p data-track="361">&nbsp;</p>
<p data-track="362"><strong>四.异步非阻塞</strong></p>
<p data-track="363">客户去商店买衣服，衣服没了，然后给老板留下电话，衣服到了就打电话通知。然后客户就可以随心所欲地去做其他事情，也不用操心衣服什么时候到。只要衣服一到，老板就会打电话进行通知，收到通知后再去买衣服即可。</p>
<p data-track="364">&nbsp;</p>
<p data-track="365"><strong>(2)Linux的IO模型之阻塞IO模型(同步)</strong></p>
<p data-track="366"><strong>一.解析一</strong></p>
<p data-track="367">应用程序调用一个IO方法，导致应用程序阻塞，等待数据准备好。如果数据没有准备好，则一直等待。如果数据准备好，则将数据从内核空间拷贝到用户空间，然后返回是否成功。</p>
<p data-track="368">&nbsp;</p>
<p data-track="369"><strong>二.解析二</strong></p>
<p data-track="370">当调用recv()方法时，系统首先查是否有准备好的数据。如果数据没有准备好，那么系统就处于等待状态。如果数据已经准备好，则将数据从内核空间复制到用户空间，然后返回。在套接应用程序中，当调用recv()方法时，未必用户空间就已经存在数据，那么此时recv()方法就会处于等待状态。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d11a769e7f94482993e408554fc41dbd~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=VbGL%2BkaoIWqqjjqoHon3yy6f9dM%3D" data-ic="false" data-width="1080" data-height="559" data-ic-uri=""></div>
<p data-track="371"><strong>三.阻塞IO(BIO)的优点</strong></p>
<p data-track="372">程序简单，在阻塞等待数据期间，用户线程挂起，用户线程基本不会占用CPU资源。</p>
<p data-track="373">&nbsp;</p>
<p data-track="374"><strong>四.阻塞IO(BIO)的缺点</strong></p>
<p data-track="375">一般情况下，需要为每个连接配套一条独立的线程，或者说一条线程维护一个连接成功的IO流的读写。在并发量小的情况下，这没什么问题，内存和线程切换开销比较小。但是当在高并发的场景下，需要大量的线程来维护大量的网络连接。因此，基本上BIO模型在高并发场景下是不可用的。</p>
<p data-track="376">&nbsp;</p>
<p data-track="377"><strong>(3)Linux的IO模型之非阻塞IO模型(同步)</strong></p>
<p data-track="378"><strong>一.解析一</strong></p>
<p data-track="379">把一个Socket设置为非阻塞就是告诉系统内核：当所请求的IO操作无法完成时，不要将进程睡眠，而是返回一个错误。这样IO操作函数将不断测试数据是否已经准备好。如果没有准备好，则继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间，所以该模型不应该被推荐。</p>
<p data-track="380">&nbsp;</p>
<p data-track="381"><strong>二.解析二</strong></p>
<p data-track="382">把一个Socket设置为非阻塞就是告诉系统内核：在调用Sockets API时，不要让线程睡眠，而应该让函数立即返回。在返回时，该函数返回一个错误代码。</p>
<p data-track="383">&nbsp;</p>
<p data-track="384">下图展示了一个非阻塞模式的套接字多次调用recv()函数的过程。前三次调用recv()函数时，内核数据还没有准备好。因此recv()函数会立即返回EWOULDBLOCK错误代码。第四次调用recv()函数时，数据已经准备好，被复制到应用程序的缓冲区中。因此recv()函数会返回成功，之后应用程序便开始处理数据。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/91f2b653851048af81a14a76047607f5~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=6%2FNbSHxnT%2FUIG8yO%2Fiev0jjSpmA%3D" data-ic="false" data-width="1080" data-height="771" data-ic-uri=""></div>
<p data-track="385"><strong>三.非阻塞IO(NIO)的特点</strong></p>
<p data-track="386">应用程序线程需不断进行IO系统调用，轮询数据是否已准备好。如果还没准备好，则继续轮询，直到完成系统调用为止。</p>
<p data-track="387">&nbsp;</p>
<p data-track="388"><strong>四.非阻塞IO(NIO)的优点</strong></p>
<p data-track="389">每次发起IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。</p>
<p data-track="390">&nbsp;</p>
<p data-track="391"><strong>五.非阻塞IO(NIO)的缺点</strong></p>
<p data-track="392">需要不断重复发起IO系统调用，不断询问内核。这种不断的轮询将会占用大量的CPU时间，系统资源利用率比较低。</p>
<p data-track="393">&nbsp;</p>
<p data-track="394"><strong>(4)Linux的IO模型之IO复用模型(同步)</strong></p>
<p data-track="395"><strong>一.解析一</strong>(两次调用，两次返回)</p>
<p data-track="396">IO多路复用模型，是通过一种新的系统调用来实现的。一个进程可以监视多个文件描述符，一旦某个描述符就绪(可读/可写)，那么内核就会通知程序进行相应的IO系统调用。非阻塞的BIO就是一个线程只能轮询自己的一个文件描述符。</p>
<p data-track="397">&nbsp;</p>
<p data-track="398">IO多路复用模型的基本原理就是select/epoll系统调用。单个线程不断的轮询select/epoll系统调用所负责的成百上千的Socket连接，当某个或某些Socket网络连接有数据到达了，就返回这些可以读写的连接。好处是通过一次select/epoll调用，就能查询可读写的成百上千个网络连接。</p>
<p data-track="399">&nbsp;</p>
<p data-track="400">在这种模式中首先不是进行read系统调动，而是进行select/epoll系统调用。当然前提是要将目标网络连接提前注册到select/epoll可查询的Socket列表，然后才可以开启整个IO多路复用模型的读流程。</p>
<p data-track="401">&nbsp;</p>
<p data-track="402"><strong>步骤一：</strong></p>
<p data-track="403">首先进行select/epoll系统调用，查询可以读的连接。内核会通过select系统调用查询所有可查询的Socket列表。当任何一个Socket中的数据准备好了，select系统调用就会返回。注意：当用户线程调用了select系统调用时，整个线程是会被阻塞的。</p>
<p data-track="404">&nbsp;</p>
<p data-track="405"><strong>步骤二：</strong></p>
<p data-track="406">用户线程获得了目标连接后，会发起read系统调用，此时用户线程被阻塞。然后内核开始将数据从内核缓冲区复制到用户缓冲区，接着内核返回结果。</p>
<p data-track="407">&nbsp;</p>
<p data-track="408"><strong>步骤三：</strong></p>
<p data-track="409">用户线程才解除阻塞的状态，此时用户线程终于读取到数据，继续执行。</p>
<p data-track="410">&nbsp;</p>
<p data-track="411"><strong>二.解析二</strong>(两次调用，两次返回)</p>
<p data-track="412">对一个IO端口，两次调用两次返回，比阻塞IO并没有什么优越性，关键是能实现同时对多个IO端口进行监听。IO复用模型会用到select、poll、epoll函数，这几个函数也会阻塞进程。但是和阻塞IO不同的是，这几个函数可以同时阻塞多个IO操作，而且可以同时对多个读操作和写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数。</p>
<p data-track="413">&nbsp;</p>
<p data-track="414">当用户进程调用了select，那么整个进程会被阻塞。而同时，内核会监视所有select负责的Socket。当任何一个Socket中的数据准备好了，select系统调用就会返回。这时用户进程再调用read系统调用，将数据从内核拷贝到用户进程。</p>
<p data-track="415">&nbsp;</p>
<p data-track="416">这个图和阻塞IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而阻塞IO只调用了一个系统调用(recvfrom)。但是select的优势在于它可以同时处理多个连接，select的优势并不是能更快处理单个连接，而是能处理更多的连接。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/342dcfdc2366467496f0748d45932432~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=%2BNj3HkwD%2BzkK8py0z7HNOL6nncI%3D" data-ic="false" data-width="1080" data-height="684" data-ic-uri=""></div>
<p data-track="417"><strong>三.多路复用IO(NIO)的特点</strong></p>
<p data-track="418">多路复用IO需要用到两个系统调用：一个是select/epoll查询调用，一个是IO的读取调用。负责select/epoll查询调用的线程需要不断进行select/epoll轮询，查找出可以进行IO操作的连接。</p>
<p data-track="419">&nbsp;</p>
<p data-track="420"><strong>四.多路复用IO(NIO)的优点</strong></p>
<p data-track="421">使用select/epoll的优势是：可以同时处理成千上万个连接。与一条线程维护一个连接相比，IO多路复用技术的最大优势是：系统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。Java的NIO技术，使用的就是IO多路复用模型。</p>
<p data-track="422">&nbsp;</p>
<p data-track="423"><strong>五.多路复用IO(NIO)的缺点</strong></p>
<p data-track="424">select/epoll系统调用，本质上也是属于同步IO + 阻塞IO。都需要在读写事件就绪后，自己负责进行读写，这个读写过程是阻塞的。</p>
<p data-track="425">&nbsp;</p>
<p data-track="426"><strong>(5)Linux的IO模型之信号驱动IO(同步)</strong></p>
<p data-track="427">首先允许套接口进行信号驱动IO。然后安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，此时可以在信号处理函数中调用IO操作函数处理数据。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/39f6965d527540279668918b31034e9d~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=Dgu2cn6izQkSZ3bnLUv7ltAIro4%3D" data-ic="false" data-width="1080" data-height="682" data-ic-uri=""></div>
<p data-track="428"><strong>(6)Linux的IO模型之异步IO模型(异步)</strong></p>
<p data-track="429">AIO的基本流程是：</p>
<p data-track="430">一.用户线程通过系统调用，告知内核启动某个IO操作，用户线程返回</p>
<p data-track="431">二.内核在整个IO操作(包括数据准备、数据复制)完成后，通知用户程序</p>
<p data-track="432">三.用户程序收到通知后便可执行后续的业务操作</p>
<p data-track="433">&nbsp;</p>
<p data-track="434">内核的数据准备是将数据从网卡读取到内核缓冲区，内核的数据复制是将数据从内核缓冲区拷贝到用户空间的缓冲区。</p>
<p data-track="435">&nbsp;</p>
<p data-track="436">AIO的详细流程是：</p>
<p data-track="437">一.当用户线程调用read系统调用后就可以去做其它事了，用户线程不阻塞</p>
<p data-track="438">二.内核开始IO处理的第一个阶段——准备数据，当内核一直等到数据准备好了，就会将数据从内核缓冲区拷贝到用户缓冲区</p>
<p data-track="439">三.内核会给用户线程发送一个信号，或者回调用户线程注册的回调接口，告诉用户线程read操作已经完成了</p>
<p data-track="440">四.用户线程接着就可以读取用户缓冲区的数据，完成后续的业务操作</p>
<p data-track="441">&nbsp;</p>
<p data-track="442">异步IO模型的特点：在内核的等待数据和复制数据两个阶段，用户线程都不会阻塞。用户线程需要接收内核IO操作完成的事件，或者注册IO操作完成的回调函数到操作系统的内核中。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/502327e02dbd40c193c57c2aa9813f76~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=gUMXvq%2BYceS46wmOx15xV7ozt4M%3D" data-ic="false" data-width="1080" data-height="704" data-ic-uri=""></div>
<p data-track="443"><strong>(7)Linux的5个IO模型对比</strong></p>
<p data-track="444">其实常用的模型是阻塞IO模型和IO复用模型。</p>
<div class="pgc-img"><img src="https://p6-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/634ddf4cf6e64d02968bb013dece672d~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=YLl%2BS9MXAnyzW1%2FCBRbpANQpzHU%3D" data-ic="false" data-width="1080" data-height="672" data-ic-uri=""></div>
<p data-track="445">&nbsp;</p>
<p data-track="446"><strong>13.Linux的IO模型核心</strong></p>
<p data-track="447"><strong>(1)阻塞IO模型(BIO)</strong></p>
<p data-track="448"><strong>(2)非阻塞IO模型(NIO)</strong></p>
<p data-track="449"><strong>(3)IO复用模型(NIO)</strong></p>
<p data-track="450">&nbsp;</p>
<p data-track="451"><strong>(1)阻塞IO模型(BIO)</strong></p>
<p data-track="452">应用程序调用一个IO方法，导致应用程序阻塞，等待数据准备好。如果数据没有准备好，则一直等待。如果数据准备好，则将数据从内核空间拷贝到用户空间，然后返回是否成功。</p>
<p data-track="453">&nbsp;</p>
<p data-track="454"><strong>阻塞IO(BIO)的优点：</strong></p>
<p data-track="455">程序简单，在阻塞等待数据期间，用户线程挂起，用户线程基本不会占用CPU资源。</p>
<p data-track="456">&nbsp;</p>
<p data-track="457"><strong>阻塞IO(BIO)的缺点：</strong></p>
<p data-track="458">一般情况下，需要为每个连接配套一条独立的线程，或者说一条线程维护一个连接成功的IO流的读写。在并发量小的情况下，这没什么问题，内存和线程切换开销比较小。但是当在高并发的场景下，需要大量的线程来维护大量的网络连接。因此，基本上BIO模型在高并发场景下是不可用的。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/33a68032881f4fa3834946200620adde~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=p%2FyYdbY748IVyVDFKOZupeDSzlA%3D" data-ic="false" data-width="1080" data-height="996" data-ic-uri=""></div>
<p data-track="459"><strong>(2)非阻塞IO模型(NIO)</strong></p>
<p data-track="460">把一个Socket设置为非阻塞就是告诉系统内核：当所请求的IO操作无法完成时，不要将进程睡眠，而是返回一个错误。这样IO操作函数将不断测试数据是否已经准备好。如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间，所以该模型不应该被推荐。</p>
<p data-track="461">&nbsp;</p>
<p data-track="462"><strong>非阻塞IO(NIO)的特点：</strong></p>
<p data-track="463">应用程序线程需要不断进行IO系统调用，轮询数据是否已经准备好。如果还没准备好，则继续轮询，直到完成系统调用为止。</p>
<p data-track="464">&nbsp;</p>
<p data-track="465"><strong>非阻塞IO(NIO)的优点：</strong></p>
<p data-track="466">每次发起IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。</p>
<p data-track="467">&nbsp;</p>
<p data-track="468"><strong>非阻塞IO(NIO)的缺点：</strong></p>
<p data-track="469">需要不断重复发起IO系统调用，不断询问内核。这种不断轮询将占用大量CPU时间，系统资源利用率低。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/5e9ecd97dba64fd69bb3be8427b26161~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=B2U7uwzrAPJwSdX6Jlsbn1dGfMA%3D" data-ic="false" data-width="1080" data-height="675" data-ic-uri=""></div>
<p data-track="470"><strong>(3)IO复用模型(NIO)</strong></p>
<p data-track="471">IO多路复用模型，是通过一种新的系统调用来实现的。一个进程可以监视多个文件描述符，一旦某个描述符就绪(可读/可写)，那么内核就会通知程序进行相应的IO系统调用。非阻塞的BIO就是一个线程只能轮询自己的一个文件描述符。</p>
<p data-track="472">&nbsp;</p>
<p data-track="473">IO多路复用模型的基本原理就是select/epoll系统调用。单个线程不断的轮询select/epoll系统调用所负责的成百上千的Socket连接，当某个或某些Socket网络连接有数据到达了，就返回这些可以读写的连接。好处是通过一次select/epoll调用，就能查询可读写的成百上千个网络连接。</p>
<p data-track="474">&nbsp;</p>
<p data-track="475"><strong>一.select版的多路复用</strong></p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/2f279a5d8c6e4cb5bea34c3276bc8f91~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=euZo7EEsPfyeup5eRVTLrzZ6e6A%3D" data-ic="false" data-width="1080" data-height="619" data-ic-uri=""></div>
<p data-track="476"><strong>二.epoll版的多路复用</strong></p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/93c03c0a90b043be9edec6827d37f69d~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=90YxmXtik7FvWcFm0%2Fgc2LerI2E%3D" data-ic="false" data-width="1080" data-height="619" data-ic-uri=""></div>
<p data-track="477">在这种模式中首先不是进行read系统调动，而是进行select/epoll系统调用。当然前提是要将目标网络连接提前注册到select/epoll可查询的Socket列表，然后才可以开启整个IO多路复用模型的读流程。</p>
<p data-track="478">&nbsp;</p>
<p data-track="479"><strong>步骤一：</strong></p>
<p data-track="480">首先进行select/epoll系统调用，查询可以读的连接，内核会通过select系统调用查询所有可查询的Socket列表。当任何一个Socket中的数据准备好了，select系统调用就会返回。注意：当用户线程调用了select系统调用时，整个线程是会被阻塞的。</p>
<p data-track="481">&nbsp;</p>
<p data-track="482"><strong>步骤二：</strong></p>
<p data-track="483">用户线程获得了目标连接后，会发起read系统调用，此时用户线程被阻塞。然后内核开始将数据从内核缓冲区复制到用户缓冲区，接着内核返回结果。</p>
<p data-track="484">&nbsp;</p>
<p data-track="485"><strong>步骤三：</strong></p>
<p data-track="486">用户线程才解除阻塞的状态，此时用户线程终于读取到数据，继续执行。</p>
<p data-track="487">&nbsp;</p>
<p data-track="488"><strong>三.多路复用IO(NIO)的特点</strong></p>
<p data-track="489">多路复用IO需要用到两个系统调用：一个是select/epoll查询调用，一个是IO的读取调用。负责select/epoll查询调用的线程：需要不断进行select/epoll轮询，查找出可以进行IO操作的连接。</p>
<p data-track="490">&nbsp;</p>
<p data-track="491"><strong>四.多路复用IO(NIO)的优点</strong></p>
<p data-track="492">使用select/epoll的优势是：可以同时处理成千上万个连接。与一条线程维护一个连接相比，IO多路复用技术的最大优势是：系统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。Java的NIO技术，使用的就是IO多路复用模型。</p>
<p data-track="493">&nbsp;</p>
<p data-track="494"><strong>五.多路复用IO(NIO)的缺点</strong></p>
<p data-track="495">select/epoll系统调用，本质上也是属于同步IO + 阻塞IO。都需要在读写事件就绪后，自己负责进行读写，这个读写过程是阻塞的。</p>
<p data-track="496">&nbsp;</p>
<p data-track="497"><strong>14.select、poll、epoll的区别</strong></p>
<p data-track="498"><strong>(1)支持一个进程所能打开的最大连接数</strong></p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/e9cfe36905ce4461a73adcd3d40e35fc~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=0Xe4khilwqofQos8%2FO38BAOsM3U%3D" data-ic="false" data-width="1080" data-height="386" data-ic-uri=""></div>
<p data-track="499"><strong>(2)FD剧增后带来的IO效率问题</strong></p>
<div class="pgc-img"><img src="https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/dc24314fddb6453a8ce8163e9d03949e~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=DOJwXokpemOS%2FhA8HTGzoAHrP84%3D" data-ic="false" data-width="1080" data-height="365" data-ic-uri=""></div>
<p data-track="500"><strong>(3)消息传递方式</strong></p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/81f7ccd0c7914057a41cd6bfb0cc1493~tplv-obj.image?lk3s=ef143cfe&amp;traceid=2025031021570975CB056A1234F9181D21&amp;x-expires=2147483647&amp;x-signature=tywCKfzV62m8gHhWuzV3bgyh2C4%3D" data-ic="false" data-width="1080" data-height="254" data-ic-uri=""></div>
<p data-track="501">&nbsp;</p>
<p data-track="502"><strong>15.水平触发和边缘触发</strong></p>
<p data-track="503"><strong>(1)Level_triggered(水平触发)</strong></p>
<p data-track="504">当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写。当然如果处理程序一直不去读写，它会一直通知处理程序。</p>
<p data-track="505">&nbsp;</p>
<p data-track="506">如果系统中有大量不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索处理程序关心的就绪文件描述符的效率。</p>
<p data-track="507">&nbsp;</p>
<p data-track="508"><strong>(2)Edge_triggered(边缘触发)</strong></p>
<p data-track="509">当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知处理程序，也就是它只会通知处理程序一次，直到该文件描述符上出现第二次可读写事件才会通知处理程序。</p>
<p data-track="510">&nbsp;</p>
<p data-track="511">这种模式比水平触发效率高，系统不会充斥大量处理程序不关心的就绪文件描述符。select()、poll()模型都是水平触发模式，信号驱动IO是边缘触发模式。epoll()模型即支持水平触发，也支持边缘触发，默认是水平触发。</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.010694188542824074" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-10 22:01">2025-03-10 22:01</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">5</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18763811" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18763811);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18763811', targetLink: 'https://www.cnblogs.com/mjunz/p/18763811', title: 'Netty基础—1.网络编程基础一' })">举报</a>
</div>
        