
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhennann/p/19050467" title="发布于 2025-08-21 11:56">
    <span role="heading" aria-level="2">这个Database Transaction功能多多，你用过吗？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1462384/202508/1462384-20250821115419556-1893865245.png" alt="这个Database Transaction功能多多，你用过吗？" class="desc_img">
        Vona ORM 对数据库事务提供了完整的支持，提供了直观、优雅、强大的特性：事务传播机制、事务补偿机制、确保数据库与缓存数据一致性
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><a href="https://github.com/vonajs/vona" target="_blank" rel="noopener nofollow">Vona</a> 是一款直观、优雅、强大的 Node.js Web 框架，用于快速开发任何规模的企业级应用。首创 DTO 动态推断与生成能力，从而显著提升开发效率和开发体验。Vona ORM 对数据库事务提供了完整的支持，提供了直观、优雅、强大的特性：</p>
<ol>
<li>使用装饰器启用事务</li>
<li>事务传播机制</li>
<li>事务补偿机制</li>
<li>确保数据库与缓存数据一致性</li>
</ol>
<h2 id="使用装饰器启用事务">使用装饰器启用事务</h2>
<pre><code class="language-typescript">import { Database } from 'vona-module-a-orm';

class ServicePost {
  @Database.transaction()
  async transaction() {
    // insert
    const post = await this.scope.model.post.insert({
      title: 'Post001',
    });
    // update
    await this.scope.model.post.update({
      id: post.id,
      title: 'Post001-Update',
    });
  }
}  
</code></pre>
<h2 id="手工启用事务">手工启用事务</h2>
<h3 id="1-使用当前数据源">1. 使用当前数据源</h3>
<pre><code class="language-typescript">class ServicePost {
  async transactionManually() {
    const db = this.bean.database.current;
    await db.transaction.begin(async () =&gt; {
      await this.scope.model.post.update({ id: 1, title: 'Post001_Update' });
    });
  }
}
</code></pre>
<h3 id="2-使用指定数据源">2. 使用指定数据源</h3>
<pre><code class="language-typescript">class ServicePost {
  async transactionManually() {
    const db = this.bean.database.getDb({ clientName: 'default' });
    await db.transaction.begin(async () =&gt; {
      const modelPost = this.scope.model.post.newInstance(db);
      await modelPost.update({ id: 1, title: 'Post001_Update' });
    });
  }
}
</code></pre>
<h2 id="事务参数">事务参数</h2>
<pre><code class="language-diff">class ServicePost {
  @Database.transaction({
+   isolationLevel: 'READ_COMMITTED',
+   propagation: 'REQUIRED'
  })
  async transaction() {
    ...
  }
}  
</code></pre>
<pre><code class="language-diff">class ServicePost {
  async transactionManually() {
    const db = this.bean.database.getDb({ clientName: 'default' });
    await db.transaction.begin(
      async () =&gt; {
        ...
      },
      {
+       isolationLevel: 'READ_COMMITTED',
+       propagation: 'REQUIRED',
      }
    );
  }
}  
</code></pre>
<h2 id="事务参数isolationlevel">事务参数：isolationLevel</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEFAULT</td>
<td>数据库相关的缺省isolationLevel</td>
</tr>
<tr>
<td>READ_UNCOMMITTED</td>
<td></td>
</tr>
<tr>
<td>READ_COMMITTED</td>
<td></td>
</tr>
<tr>
<td>REPEATABLE_READ</td>
<td></td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td></td>
</tr>
<tr>
<td>SNAPSHOT</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="事务参数propagation">事务参数：propagation</h2>
<p>Vona ORM 支持数据库事务传播机制</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>REQUIRED</td>
<td>默认的事务传播级别。如果当前存在事务, 则加入该事务。如果当前没有事务, 则创建一个新的事务</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>如果当前存在事务，则加入该事务. 如果当前没有事务, 则以非事务的方式继续运行</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>强制性。如果当前存在事务, 则加入该事务。如果当前没有事务，则抛出异常</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>创建一个新的事务。如果当前存在事务, 则把当前事务挂起。也就是说不管外部方法是否开启事务，总是开启新的事务, 且开启的事务相互独立, 互不干扰</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>以非事务方式运行。如果当前存在事务，则把当前事务挂起(不用)</td>
</tr>
<tr>
<td>NEVER</td>
<td>以非事务方式运行。如果当前存在事务，则抛出异常</td>
</tr>
</tbody>
</table>
<h2 id="事务补偿机制">事务补偿机制</h2>
<p>当事务成功或者失败时执行一些逻辑</p>
<h3 id="1-成功补偿">1. 成功补偿</h3>
<pre><code class="language-typescript">this.bean.database.current.commit(async () =&gt; {
  // do something when success
});
</code></pre>
<h3 id="2-失败补偿">2. 失败补偿</h3>
<pre><code class="language-typescript">this.bean.database.current.compensate(async () =&gt; {
  // do something when failed
});
</code></pre>
<h2 id="事务与cache数据一致性">事务与Cache数据一致性</h2>
<p>许多框架使用最简短的用例来证明是否高性能，而忽略了业务复杂性带来的性能挑战。随着业务的增长和变更，项目性能就会断崖式下降，各种优化补救方案让项目代码繁杂冗长。而 Vona 正视大型业务的复杂性，从框架核心引入缓存策略，并实现了<code>二级缓存</code>、<code>Query缓存</code>和<code>Entity缓存</code>等机制，轻松应对大型业务系统的开发，可以始终保持代码的优雅和直观</p>
<p>Vona 系统对数据库事务与缓存进行了适配，当数据库事务失败时会自动执行缓存的补偿操作，从而让数据库数据与缓存数据始终保持一致</p>
<p>针对这个场景，Vona 提供了内置的解决方案</p>
<h3 id="1-使用当前数据源-1">1. 使用当前数据源</h3>
<pre><code class="language-typescript">class ServicePost {
  @Database.transaction()
  async transaction() {
    // insert
    const post = await this.scope.model.post.insert({
      title: 'Post001',
    });
    // cache
    await this.scope.cacheRedis.post.set(post, post.id);
  }
}  
</code></pre>
<ul>
<li>当新建数据后，将数据放入 redis 缓存中。如果这个事务出现异常，就会进行数据回滚，同时缓存数据也会回滚，从而让数据库数据与缓存数据保持一致</li>
</ul>
<h3 id="2-使用指定数据源-1">2. 使用指定数据源</h3>
<pre><code class="language-typescript">class ServicePost {
  async transactionManually() {
    const db = this.bean.database.getDb({ clientName: 'default' });
    await db.transaction.begin(async () =&gt; {
      const modelPost = this.scope.model.post.newInstance(db);
      const post = await modelPost.insert({ title: 'Post001' });
      await this.scope.cacheRedis.post.set(post, post.id, { db });
    });
  }
}  
</code></pre>
<ul>
<li>如果对指定的数据库进行操作，那么就需要将数据库对象<code>db</code>传入缓存，从而让缓存针对数据库对象<code>db</code>执行相应的补偿操作。当数据库事务回滚时，让数据库数据与缓存数据保持一致</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-21 11:56">2025-08-21 11:56</span>&nbsp;
<a href="https://www.cnblogs.com/zhennann">濮水大叔</a>&nbsp;
阅读(<span id="post_view_count">11</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19050467);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19050467', targetLink: 'https://www.cnblogs.com/zhennann/p/19050467', title: '这个Database Transaction功能多多，你用过吗？' })">举报</a>
</div>
        