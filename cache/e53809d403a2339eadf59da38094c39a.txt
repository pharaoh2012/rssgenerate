<!----> <meta itemprop="headline" content="我为什么在团队里，强制要求大家用pnpm而不是npm？"> <meta itemprop="keywords" content="前端,JavaScript,NPM"> <meta itemprop="datePublished" content="2025-07-24T02:27:51.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="ErpanOmer"> <meta itemprop="url" content="https://juejin.cn/user/3878732754331096"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我为什么在团队里，强制要求大家用pnpm而不是npm？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3878732754331096/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    ErpanOmer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-07-24T02:27:51.000Z" title="Thu Jul 24 2025 02:27:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-07-24
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    11,806
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/31ed1e09ba5c4ce6bd7c7d9a6cc19a16~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRXJwYW5PbWVy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1756936051&amp;x-signature=6nPlqi0g9x3sgQlHoiwxsAt0Cqk%3D" alt="image.png" loading="lazy"></p>
<p>最近，我在我们前端团队里推行了一个“强制性”的规定：<strong>所有新项目，必须使用<code>pnpm</code>作为包管理工具；所有老项目，必须在两个月内，逐步迁移到<code>pnpm</code>。</strong></p>
<p>这个决定，一开始在团队里是有阻力的。</p>
<p>有同事问：“老大，npm用得好好的，为啥非要换啊？我们都习惯了。”</p>
<p>也有同事说：“yarn不也挺快的吗？再换个pnpm，是不是在瞎折腾？”</p>
<p>我理解大家的疑问。但我之所以要用“强制”这个词，是因为在我看来，在2025年的今天，<strong>继续使用npm或yarn，就像是明明有高铁可以坐，你却非要坚持坐绿皮火车一样，不是不行，而是没必要。</strong></p>
<p>这篇文章，我就想把我的理由掰开揉碎了，讲给大家听。</p>
<hr>
<h4 data-id="heading-0"><strong>npm和yarn的“原罪”：那个又大又慢的<code>node_modules</code></strong></h4>
<p>在聊pnpm的好处之前，我们得先搞明白，npm和yarn（特指yarn v1）到底有什么问题。</p>
<p>它们最大的问题，都源于一个东西——<strong>扁平化的<code>node_modules</code></strong>。</p>
<p>你可能觉得奇怪，“扁平化”不是为了解决npm v2时代的“依赖地狱”问题吗？是的，它解决了老问题，但又带来了新问题：</p>
<p><strong>1. “幽灵依赖”（Phantom Dependencies）</strong></p>
<p>这是我最不能忍受的一个问题。</p>
<p>举个例子：你的项目只安装了<code>A</code>包（<code>npm install A</code>）。但是<code>A</code>包自己依赖了<code>B</code>包。因为是扁平化结构，<code>B</code>包也会被提升到<code>node_modules</code>的根目录。</p>
<p>结果就是，你在你的代码里，明明没有在<code>package.json</code>里声明过<code>B</code>，但你却可以<code>import B from 'B'</code>，而且代码还能正常运行！</p>
<p>这就是“幽灵依赖”。它像一个幽灵，让你的项目依赖关系变得混乱不堪。万一有一天，<code>A</code>包升级了，不再依赖<code>B</code>了，你的项目就会在某个意想不到的地方突然崩溃，而你甚至都不知道<code>B</code>是从哪来的。</p>
<p><strong>2. 磁盘空间的巨大浪费</strong></p>
<p>如果你电脑上有10个项目，这10个项目都依赖了<code>lodash</code>，那么在npm/yarn的模式下，你的磁盘上就会实实在在地存着<strong>10份</strong>一模一样的<code>lodash</code>代码。</p>
<p>对于我们这些天天要开好几个项目的前端来说，电脑的存储空间就这么被日积月累地消耗掉了。</p>
<p><strong>3. 安装速度的瓶颈</strong></p>
<p>虽然npm和yarn都有缓存机制，但在安装依赖时，它们仍然需要做大量的I/O操作，去复制、移动那些文件。当项目越来越大，<code>node_modules</code>动辄上G的时候，那个安装速度，真的让人等到心焦。</p>
<hr>
<h4 data-id="heading-1"><strong>pnpm是怎么解决这些问题的？——“符号链接”</strong></h4>
<p>好了，现在主角pnpm登场。pnpm的全称是“performant npm”，意为“高性能的npm”。它解决上面所有问题的核心武器，就两个字：<strong>链接</strong>。</p>
<p>pnpm没有采用扁平化的<code>node_modules</code>结构，而是创建了一个<strong>嵌套的、有严格依赖关系的结构</strong>。</p>
<p><strong>1. 彻底告别“幽灵依赖”</strong></p>
<p>在pnpm的<code>node_modules</code>里，你只会看到你在<code>package.json</code>里<strong>明确声明</strong>的那些依赖。</p>
<p>你项目里依赖的<code>A</code>包，它自己所依赖的<code>B</code>包，会被存放在<code>node_modules/.pnpm/</code>这个特殊的目录里，然后通过 <strong>符号链接（Symbolic Link）</strong> 的方式，链接到<code>A</code>包的<code>node_modules</code>里。</p>
<p>这意味着，在你的项目代码里，你根本访问不到<code>B</code>包。你想<code>import B</code>？对不起，直接报错。这就从结构上保证了，你的项目依赖关系是绝对可靠和纯净的。</p>
<p><strong>2. 磁盘空间的“终极节约”</strong></p>
<p>pnpm会在你的电脑上创建一个“全局内容可寻址存储区”（content-addressable store），通常在用户主目录下的<code>.pnpm-store</code>里。</p>
<p>你电脑上所有项目的所有依赖，<strong>都只会在这个全局仓库里，实实在在地只存一份</strong>。</p>
<p>当你的项目需要<code>lodash</code>时，pnpm不会去复制一份<code>lodash</code>到你的<code>node_modules</code>里，而是通过 <strong>硬链接（Hard Link）</strong> 的方式，从全局仓库链接一份过来。硬链接几乎不占用磁盘空间。</p>
<p>这意味着，就算你有100个项目都用了<code>lodash</code>，它在你的硬盘上也只占一份的空间。这个特性，对于磁盘空间紧张的同学来说，简直是福音。</p>
<p><strong>3. 极速的安装体验</strong></p>
<p>因为大部分依赖都是通过“链接”的方式实现的，而不是“复制”，所以pnpm在安装依赖时，大大减少了磁盘I/O操作。</p>
<p>它的安装速度，尤其是在有缓存的情况下，或者在安装一个已经存在于全局仓库里的包时，几乎是“秒级”的。这种“飞一般”的感觉，一旦体验过，就再也回不去了。</p>
<hr>
<h4 data-id="heading-2"><strong>为什么我要“强制”？</strong></h4>
<p>聊完了技术优势，再回到最初的问题：我为什么要“强制”推行？</p>
<p>因为<strong>包管理工具的统一，是前端工程化规范里最基础、也最重要的一环。</strong></p>
<p>如果一个团队里，有人用npm，有人用yarn，有人用pnpm，那就会出现各种各样的问题：</p>
<ul>
<li><strong>不一致的<code>lock</code>文件</strong>：<code>package-lock.json</code>, <code>yarn.lock</code>, <code>pnpm-lock.yaml</code>互相冲突，导致不同成员安装的依赖版本可能不完全一致，引发“在我电脑上是好的”这种经典问题。</li>
<li><strong>不一致的依赖结构</strong>：用npm的同事，可能会不小心写出依赖“幽灵依赖”的代码，而用pnpm的同事拉下来，代码直接就跑不起来了。</li>
</ul>
<p>在一个团队里，工具的统一，是为了保证环境的一致性和协作的顺畅。而pnpm，在我看来，就是当前这个时代下，包管理工具的“最优解”。</p>
<p>所以，这个“强制”，不是为了搞独裁，而是为了从根本上提升我们整个团队的开发效率和项目的长期稳定性。</p>
<hr>
<h4 data-id="heading-3"><strong>最后的经验</strong></h4>
<p>从npm到yarn，再到pnpm，前端的包管理工具一直在进化。</p>
<p>pnpm用一种更先进、更合理的机制，解决了过去遗留下的种种问题。它带来的不仅仅是速度的提升，更是一种对“依赖关系纯净性”和“工程化严谨性”的保障。</p>
<p>我知道，改变一个人的习惯很难。但作为团队的负责人，我有责任去选择一条更高效、更正确的路，然后带领大家一起走下去。</p>
<p>如果你还没用过pnpm，我强烈建议你花十分钟，在你的新项目里试一试🙂。</p></div></div>