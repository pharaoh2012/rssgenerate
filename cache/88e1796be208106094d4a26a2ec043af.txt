
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/flyfire-cn/p/18642507" title="发布于 2024-12-30 22:11">
    <span role="heading" aria-level="2">dotnet最小webApi开发实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        软件开发过程中，经常需要写一些功能验证代码。通常是创建一个console程序来验证测试，但黑呼呼的方框界面，实在是不讨人喜欢。
Web开发目前已是网络世界中的主流，微软在asp.net框架大行其道之下，在web开发向导中提供了最小webapi项目开发向导。
让我们拥抱新的开发模式，使用webapi方式来进行功能应用实践。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>dotnet最小webApi开发实践<a name="_Toc281482007"></a><a name="_Toc281482577"></a></p>
<p>软件开发过程中，经常需要写一些功能验证代码。通常是创建一个console程序来验证测试，但黑呼呼的方脑袋界面，实在是不讨人喜欢。</p>
<p>Web开发目前已是网络世界中的主流，微软在asp.net框架大行其道之下，也整了个最小webapi项目开发向导。</p>
<p>今天，我也拥抱一下新的开发模式，来使用webapi方式来做一个小的应用实践。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 打开宇宙最强编辑器VS2022，根据向导进行创建新项目，我们选择ASP.NET Core Web API项目。</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1525067/202412/1525067-20241230214344555-1026603119.png" alt=""></p>
<p>&nbsp;</p>
<p>填写项目配置信息，我们今天来创建一个访客IP白名单授权的功能。功能就是当访客访问web页面时，页面请求api授权，api对网络授权请求来源进行判断，当访客来源地址为白名单中的地址时，返回一个http 200的响应，当访客来源IP不在白名单时，返回一个 http 401未证的响应。</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1525067/202412/1525067-20241230214415338-430805468.png" alt=""></p>
<p>&nbsp;</p>
<p>.net框架选项中，最低只有.net8.0可选</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1525067/202412/1525067-20241230214514651-1218023384.png" alt=""></p>
<p>&nbsp;</p>
<p>点击创建，vs自动为我们生成了项目和代码</p>
<p>&nbsp;</p>
<div class="cnblogs_Highlighter sh-gutter">
<pre class="brush:csharp;gutter:true;collapse:false">namespace flyfire.whitelistAuthorization
{
    public class Program
    {
        public static void Main( string [] args)
        {
            var builder = WebApplication.CreateBuilder(args);
            // Add services to the container.
            builder.Services.AddControllers();

            // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle

            builder.Services.AddEndpointsApiExplorer();
            builder.Services.AddSwaggerGen();

            var app = builder.Build();

            // Configure the HTTP request pipeline.

            if (app.Environment.IsDevelopment())
            {
                app.UseSwagger();
                app.UseSwaggerUI();
            }

            app.UseAuthorization();
            app.MapControllers();
            app.Run();
        }
    }
}</pre>
</div>
<p>&nbsp;</p>
<p>框架不仅生成了代码，还默认增加了调试模式下使用丝袜哥（swagger）作为web测试的界面，真是贴心啊。</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1525067/202412/1525067-20241230214931051-1628068699.png" alt=""></p>
<p>&nbsp;</p>
<p>向导生成了一个天气预报的类和一个web控制器</p>
<p>天气预报的类</p>
<div class="cnblogs_Highlighter sh-gutter">
<pre class="brush:csharp;gutter:true;collapse:false">namespace flyfire.whitelistAuthorization
{
    public class WeatherForecast
    {
        public DateOnly Date {  get ;  set ; }
        public int TemperatureC {  get ;  set ; }
        public int TemperatureF =&gt; 32 + ( int )(TemperatureC / 0.5556);
        public string ? Summary {  get ;  set ; }
    }
}</pre>
</div>
<p>　</p>
<p>天气预报web控制器</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">using</span><span style="color: rgba(0, 0, 0, 1)"> Microsoft.AspNetCore.Mvc;
</span><span style="color: rgba(0, 0, 255, 1)">namespace</span><span style="color: rgba(0, 0, 0, 1)"> flyfire.whitelistAuthorization.Controllers
{
    [ApiController]
    [Route(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">[controller]</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)]
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> WeatherForecastController : ControllerBase
    {
        </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span> <span style="color: rgba(0, 0, 255, 1)">string</span>[] Summaries = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">[]
        {
            </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Freezing</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Bracing</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Chilly</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Cool</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Mild</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Warm</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Balmy</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Hot</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Sweltering</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Scorching</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
        };

        </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">readonly</span> ILogger&lt;WeatherForecastController&gt;<span style="color: rgba(0, 0, 0, 1)"> _logger;
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> WeatherForecastController(ILogger&lt;WeatherForecastController&gt;<span style="color: rgba(0, 0, 0, 1)"> logger)
        {
            _logger </span>=<span style="color: rgba(0, 0, 0, 1)"> logger;
        }

        [HttpGet(Name </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">GetWeatherForecast</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)]
         </span><span style="color: rgba(0, 0, 255, 1)">public</span> IEnumerable&lt;WeatherForecast&gt;<span style="color: rgba(0, 0, 0, 1)"> Get()
        {
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> Enumerable.Range(<span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">5</span>).Select(index =&gt; <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> WeatherForecast
            {
                Date </span>=<span style="color: rgba(0, 0, 0, 1)"> DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
                TemperatureC </span>= Random.Shared.Next(-<span style="color: rgba(128, 0, 128, 1)">20</span>, <span style="color: rgba(128, 0, 128, 1)">55</span><span style="color: rgba(0, 0, 0, 1)">),
                Summary </span>=<span style="color: rgba(0, 0, 0, 1)"> Summaries[Random.Shared.Next(Summaries.Length)]
            })
            .ToArray();
        }
    }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>什么代码都不用写，一个最小示例webApi接口方法就OK了。</p>
<p>&nbsp;</p>
<p>下面我们来编写一个自己的功能。</p>
<p>在解决方案管理器控制目录上，右键菜单，新建一个API控制器。</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1525067/202412/1525067-20241230214955228-138198948.png" alt=""></p>
<p>&nbsp;选择API分类</p>
<p><img src="https://img2024.cnblogs.com/blog/1525067/202412/1525067-20241230215024527-1603664325.png" alt=""></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/1525067/202412/1525067-20241230215042162-1995344460.png" alt=""></p>
<p>&nbsp;</p>
<p>我们创建一个名为 “WhitelistAuthorization”的空的API控制器.</p>
<p>我们将在WhitelistAuthorization控制器中，实现一个Authorization接口方法，当请求来源的IP地址为白名单地址时，返回StatusCode &nbsp;200,并返回一些信息，否则返回StatusCode &nbsp;401和未授权信息。</p>
<p>我们在appsetting.json中使用的个section存放白名单IP信息。</p>
<div class="cnblogs_code">
<pre> <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">WhiteIpList</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">: {
    </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">IpList</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">: [
      </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">127.0.0.1</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
    ]
  }</span></pre>
</div>
<p>我们创建一个类WhiteIpList用于映射配置数据。</p>
<div class="cnblogs_Highlighter sh-gutter">
<pre class="brush:csharp;gutter:true;collapse:false">public class WhiteIpList
{
    public List&lt; string &gt; IpList {  get ;  set ; }
}</pre>
</div>
<p>&nbsp;</p>
<p>在Main函数中，增加如下代码，将配置段实例化绑定并注入到依赖注入（DI）容器</p>
<p>builder.Services.Configure&lt;WhiteIpList&gt;(builder.Configuration.GetSection("WhiteIpList"));</p>
<p>&nbsp;</p>
<p>然后，我们在WhitelistAuthorization控制器的构造函数中，注入配置参数。</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private readonly WhiteIpList _whiteIpList;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public WhitelistAuthorizationController(IOptions&lt;WhiteIpList&gt; whiteIpList)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _whiteIpList = whiteIpList.Value;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;</p>
<p>接着，我们增加一个认证授权方法，用于认证授权，返回状态码200或401。</p>
<p>&nbsp;</p>
<div class="cnblogs_code" contenteditable="false">
<pre>       [HttpGet(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">[action]</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)]
       [HttpPost(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">[action]</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)]
        </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> IActionResult Authorization()
        {
            </span><span style="color: rgba(0, 0, 255, 1)">var</span> remote_ip =<span style="color: rgba(0, 0, 0, 1)"> GetClientIpAddress(HttpContext.Request);

            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (Untility.IsIpExist(_whiteIpList.IpList, remote_ip))
            {
                </span><span style="color: rgba(0, 0, 255, 1)">return</span> Ok(<span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">
                {
                    body </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">
                    {
                        code </span>= <span style="color: rgba(128, 0, 128, 1)">200</span><span style="color: rgba(0, 0, 0, 1)">
                    }
                });
            }
            </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
            {
                </span><span style="color: rgba(0, 0, 255, 1)">return</span> StatusCode(<span style="color: rgba(128, 0, 128, 1)">401</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Unauthorized: IP address not in whitelist.</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
            }
        }</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>HttpRequest的HttpContext.Connection.RemoteIpAddress中可获得浏览端的IP地址。</p>
<p>&nbsp;</p>
<p>不过，如果认证服务接口需经过Nginx转发时，则需要对Nginx进行一些配置以及相应的代码处理方可有效获取到浏览端的IP。</p>
<p>当网络HTTP请求经过Nginx服务器转发时，Web API仍然有可能获取到请求方的IP地址，但这取决于Nginx的配置以及Web API如何解析这些信息。&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; Nginx配置</p>
<p>&nbsp;&nbsp;&nbsp; Nginx可以通过proxy_set_header指令来添加或修改转发给后端服务器的请求头。为了获取请求方的IP地址，你需要在Nginx配置文件中设置X-Forwarded-For请求头，该请求头会包含客户端的原始IP地址。</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 例如，你可以在Nginx的配置文件（通常是nginx.conf或某个站点的配置文件）中添加以下行：</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;<code> proxy_set_header X-Forwarded-For $remote_addr;</code></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 这行代码会将客户端的IP地址添加到X-Forwarded-For请求头中，并将其转发给后端服务器。如果客户端和Nginx之间有多层代理，X-Forwarded-For请求头可能会包含多个IP地址，第一个地址通常是客户端的原始IP。</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; Web API解析</p>
<p>&nbsp;&nbsp;&nbsp; 在Web API中，你需要检查X-Forwarded-For请求头来获取客户端的IP地址。这通常涉及到从HTTP请求中提取请求头信息。</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 以下是一个在ASP.NET Core Web API中获取客户端IP地址的示例代码：</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">    csharp

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)"> GetClientIpAddress(HttpRequest request)

    {

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 首先尝试从X-Forwarded-For请求头中获取IP地址</span>

        <span style="color: rgba(0, 0, 255, 1)">var</span> xForwardedFor = request.Headers[<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">X-Forwarded-For</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">].ToString();

        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)">.IsNullOrEmpty(xForwardedFor))

        {

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果X-Forwarded-For包含多个IP地址，取第一个地址作为客户端IP</span>

            <span style="color: rgba(0, 0, 255, 1)">var</span> ipAddresses = xForwardedFor.Split(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">,</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">);

            </span><span style="color: rgba(0, 0, 255, 1)">return</span> ipAddresses.FirstOrDefault()?<span style="color: rgba(0, 0, 0, 1)">.Trim();

        }

 

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 如果X-Forwarded-For不存在，则尝试从RemoteAddress属性中获取IP地址</span>

        <span style="color: rgba(0, 0, 255, 1)">return</span> request.HttpContext.Connection.RemoteIpAddress?<span style="color: rgba(0, 0, 0, 1)">.ToString();

    }

 </span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 在这段代码中，我们首先尝试从X-Forwarded-For请求头中获取IP地址。如果请求头不存在或为空，我们则回退到从RemoteAddress属性中获取IP地址。但请注意，当请求经过Nginx转发时，RemoteAddress属性可能会包含Nginx服务器的IP地址，而不是客户端的IP地址。</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 注意事项</p>
<p>&nbsp;&nbsp;&nbsp; 安全性：X-Forwarded-For请求头可以被客户端伪造，因此它不应该被视为绝对可靠的客户端IP地址来源。在需要高安全性的场景中，你可能需要采取额外的措施来验证客户端的IP地址。</p>
<p>&nbsp;&nbsp;&nbsp; 配置一致性：确保你的Nginx服务器和后端Web API都正确配置了相关的请求头处理和解析逻辑。</p>
<p>&nbsp;&nbsp;&nbsp; 多层代理：如果请求经过了多层代理服务器，X-Forwarded-For请求头可能会包含多个IP地址。你需要确定如何解析和使用这些地址。<span style="color: rgba(0, 128, 0, 1)">如果X-Forwarded-For包含多个IP地址，取第一个地址作为客户端IP</span></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp;</p>
<p>运行项目，在swaggerUI界面框架中进行测试验证</p>
<p><img src="https://img2024.cnblogs.com/blog/1525067/202412/1525067-20241230220452305-102650791.png"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; 使用localhost地址测试，无法得到有效的IP址，白名单验证失败。</p>
<p><img src="https://img2024.cnblogs.com/blog/1525067/202412/1525067-20241230220502279-1168333299.png"></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; 使用127.0.0.1的回环地址测试，可通过白名单验证。</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; 以上，我们使用少量代码，就简单实现了一个支持Get和Post方法的并且可使用配置文件的Authorization授权接口。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5239087750474537" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-30 22:11">2024-12-30 22:11</span>&nbsp;
<a href="https://www.cnblogs.com/flyfire-cn">赫山老妖</a>&nbsp;
阅读(<span id="post_view_count">150</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18642507" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18642507);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18642507', targetLink: 'https://www.cnblogs.com/flyfire-cn/p/18642507', title: 'dotnet最小webApi开发实践' })">举报</a>
</div>
        