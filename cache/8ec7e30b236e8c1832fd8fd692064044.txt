
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/grey-wolf/p/18679576" title="发布于 2025-01-19 14:59">
    <span role="heading" aria-level="2">利用mybatis拦截器记录sql，辅助我们建立索引(二)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="背景">背景</h1>
<p>上一篇中讲述了mybatis的mapper初始化过程和执行过程，这篇再讲讲具体的拦截器的使用，以实现记录sql到持久化存储，通过分析这些sql，我们就能更方便地建立索引。<br>
<a href="https://www.cnblogs.com/grey-wolf/p/18665853" target="_blank">利用mybatis拦截器记录sql，辅助我们建立索引(一) </a></p>
<p>我本地项目的大概版本：</p>
<p>spring boot版本2.7，mybatis版本大致如下：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501111621512.png" alt="image-20250111162136395" loading="lazy"></p>
<h1 id="mybatis中sql执行过程">mybatis中sql执行过程</h1>
<p>上篇中介绍了mapper的初始化过程、mapper的简单执行过程，但没涉及太多的mapper执行中的细节，但是不把这里讲细一点，拦截器的部分也不好讲，无法知道拦截器是在什么时间执行的，所以我们本篇会再细化一下mapper的执行过程。</p>
<h2 id="上下文">上下文</h2>
<p>以下图举例，这里会执行一个sysDictMapper.selectList方法：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191232472.png" alt="image-20250119123239326" loading="lazy"></p>
<h2 id="mapper构造">mapper构造</h2>
<p>上一篇中，我们提到了，每个mapper接口，背后都对应了一个FactoryBean：<code>org.mybatis.spring.mapper.MapperFactoryBean</code>。</p>
<p>对于这种FactoryBean，要生成实际的bean，会调用其getObject方法：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191237417.png" alt="image-20250119123757327" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191238173.png" alt="image-20250119123813102" loading="lazy"></p>
<p>其中，getSqlSession方法，代码如下，就是返回一个<code>org.mybatis.spring.SqlSessionTemplate</code>对象：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191242947.png" alt="image-20250119124254852" loading="lazy"></p>
<p>然后是getMapper方法：</p>
<p>这里会先获取<code>org.apache.ibatis.session.Configuration</code>类型对象，然后从这个configuration中获取Mapper。</p>
<p>不过我这里，返回的是com.baomidou.mybatisplus.core.MybatisConfiguration，这个类是mybatis-plus的，继承了<code>org.apache.ibatis.session.Configuration</code>。</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191244872.png" alt="image-20250119124447768" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191245071.png" alt="image-20250119124511989" loading="lazy"></p>
<p>接下来就是调用<code>com.baomidou.mybatisplus.core.MybatisConfiguration的getMapper</code>方法：</p>
<p>在mybatis-plus版本的configuration对象中，有一个mapper注册表对象：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191253085.png" alt="image-20250119125308004" loading="lazy"></p>
<p>这里就会从这个注册表中获取Mapper：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191248841.png" alt="image-20250119124839725" loading="lazy"></p>
<p>注册表对象的getMapper方法代码如下，会先根据mapper的class，获取一个对应的工厂，再调用工厂的方法：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191251212.png" alt="image-20250119125120095" loading="lazy"></p>
<p>该工厂的newInstance实现如下：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191257732.png" alt="image-20250119125741628" loading="lazy"></p>
<p>构造了一个MybatisMapperProxy类型的对象，该对象是实现了jdk的动态代理的：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191258314.png" alt="image-20250119125817205" loading="lazy"></p>
<p>最终呢，就利用这个jdk动态代理对象，代理了mapper对应的class，也就是说，后续调用这个mapper接口的中方法，都会被该动态代理给拦截：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191259348.png" alt="image-20250119125906275" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191300777.png" alt="image-20250119130020707" loading="lazy"></p>
<p>所以，最终构造的mapper，就是下面这样一个动态代理对象，动态代理的处理类呢，为<code>com.baomidou.mybatisplus.core.override.MybatisMapperProxy</code>类型，里面包含了两个field：</p>
<p>sqlSessionTemplate、mapper接口对应的class。</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191301489.png" alt="image-20250119130121414" loading="lazy"></p>
<h2 id="mapper的select方法执行">mapper的select方法执行</h2>
<h3 id="plainmethodinvoker创建">PlainMethodInvoker创建</h3>
<p>接下来，开始执行其select方法：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191303236.png" alt="image-20250119130339132" loading="lazy"></p>
<p>然后，被动态代理拦截：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191304436.png" alt="image-20250119130430316" loading="lazy"></p>
<p>上图红框的cacheInvoker如下：</p>
<p>由于我们不是接口中的default方法，所以进入如下红框所示：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191306886.png" alt="image-20250119130639769" loading="lazy"></p>
<p>先是构造了一个MybatisMapperMethod对象：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191308817.png" alt="image-20250119130804735" loading="lazy"></p>
<p>然后构造了如下<code>PlainMethodInvoker</code>类型的对象：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191309522.png" alt="image-20250119130905434" loading="lazy"></p>
<h3 id="plainmethodinvokerinvoke">PlainMethodInvoker#invoke</h3>
<pre><code class="language-java">public Object invoke(Object proxy, Method method, Object[] args, SqlSession sqlSession) {
    return mapperMethod.execute(sqlSession, args);
}
</code></pre>
<p>进入MybatisMapperMethod#executeForMany:</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191312914.png" alt="image-20250119131225799" loading="lazy"></p>
<p>接下来，会交给spring的sqlSessionTemplate来执行：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191313895.png" alt="image-20250119131346780" loading="lazy"></p>
<h3 id="sqlsessiontemplateselectlist">SqlSessionTemplate#selectList</h3>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191315556.png" alt="image-20250119131524451" loading="lazy"></p>
<p>这里会交给sqlSessionProxy，本来正常是每次都要获取一个新的session，但是spring考虑到事务管理，由于事务管理是在整个事务中必须使用同一个session，所以就不能每次获取一个新的session，所以搞了个sqlSessionProxy来实现这个事情。</p>
<p>来看看其构造：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191318295.png" alt="image-20250119131820207" loading="lazy"></p>
<p>根据上图，最终调用进入到<code>SqlSessionInterceptor</code></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191319471.png" alt="image-20250119131937381" loading="lazy"></p>
<p>上图中的getSqlSession如下：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191320094.png" alt="image-20250119132043996" loading="lazy"></p>
<p>由于我们这里没加事务注解，自然是没事务的，所以会走到上面的无事务那部分：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191322856.png" alt="image-20250119132227753" loading="lazy"></p>
<h3 id="mybatis的sessionfactoryopensession">mybatis的sessionFactory#openSession</h3>
<p>这里就进入mybatis相关jar包的代码了，当前this为：<code>DefaultSqlSessionFactory</code></p>
<pre><code class="language-java">org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSession(org.apache.ibatis.session.ExecutorType)

public SqlSession openSession(ExecutorType execType) {
  return openSessionFromDataSource(execType, null, false);
}
</code></pre>
<p>我们进入具体实现：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191337586.png" alt="image-20250119133754459" loading="lazy"></p>
<p>这里刚开始，获取了一个environment，注意这个不是springboot里那个environment，是myabtis里的。具体其中有啥字段，可以看上图右下角：里面包含了transactionFactory、datasource等。</p>
<p>然后，这里会再new一个Transaction：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191339080.png" alt="image-20250119133945003" loading="lazy"></p>
<p>完成事务对象tx创建后，进入如下方法：</p>
<pre><code class="language-java">final Executor executor = configuration.newExecutor(tx, execType);
</code></pre>
<pre><code class="language-java">  public Executor newExecutor(Transaction transaction, ExecutorType executorType) {
    // 1 计算Executor的type
    executorType = executorType == null ? defaultExecutorType : executorType;
    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;
    // 2 根据type，创建不同类的Executor对象，我们一般是Simple
    Executor executor;
    if (ExecutorType.BATCH == executorType) {
      executor = new BatchExecutor(this, transaction);
    } else if (ExecutorType.REUSE == executorType) {
      executor = new ReuseExecutor(this, transaction);
    } else {
      executor = new SimpleExecutor(this, transaction);
    }
    // 3 如果开启了缓存，会装饰一层
    if (cacheEnabled) {
      executor = new CachingExecutor(executor);
    }
    // 4 利用拦截器对Executor进行代理
    executor = (Executor) interceptorChain.pluginAll(executor);
    return executor;
  }
</code></pre>
<p>如上图所示，先是计算ExecutorType，我们一般是simple</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191343274.png" alt="image-20250119134347179" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191344904.png" alt="image-20250119134419797" loading="lazy"></p>
<p>在完成SimpleExecutor的创建后，检查是否开启了cacheEnabled选项，就是mybatis的一二级缓存啥的，这个是默认开启的，我这边为了减少干扰，改了配置项，先关了。</p>
<pre><code class="language-yml">  configuration:
    cache-enabled: false
</code></pre>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191346820.png" alt="image-20250119134603749" loading="lazy"></p>
<p>再接下来，会有一个拦截器链，对我们创建出来的Executor对象进行动态代理（如果发现Executor接口中的方法，有匹配的拦截器的话）</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191347272.png" alt="image-20250119134728175" loading="lazy"></p>
<h3 id="拦截器链">拦截器链</h3>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191348113.png" alt="image-20250119134804004" loading="lazy"></p>
<p>我们这里只有一个拦截器，就是分页的拦截器，target就是我们传入的SimpleExecutor。</p>
<p>然后调用拦截器的plugin方法：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191349405.png" alt="image-20250119134919295" loading="lazy"></p>
<p>这里会继续调用Plugin类的wrap方法，这是个static方法，参数就是拦截器本身、要被拦截的target本身（即这里的SimpleExecutor）。</p>
<p>我们看看分页插件的代码中怎么定义的，看看是拦截了哪些方法：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191352002.png" alt="image-20250119135229887" loading="lazy"></p>
<p>这里怎么检查target（SimpleExecutor）是否需要被拦截呢，那就检测下有没有交集就行了（看看target实现的所有接口，是否和拦截器定义的类匹配）。如下，先获取target中的接口和拦截器中接口，是否有交集：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191355389.png" alt="image-20250119135304897" loading="lazy"></p>
<p>如果有交集，就会给SimpleExecutor创建代理对象，其中invocationHandler的类型就是Plugin类型：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191356772.png" alt="image-20250119135650685" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191358978.png" alt="image-20250119135808873" loading="lazy"></p>
<p>通过这样，就完成了对Executor对象的动态代理。</p>
<p>接下来呢，就会继续完成DefaultSqlSession的创建：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191359656.png" alt="image-20250119135924542" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191359235.png" alt="image-20250119135952158" loading="lazy"></p>
<p>接下来，放入事务中（如果开了的话）：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191400758.png" alt="image-20250119140033641" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191401292.png" alt="image-20250119140131171" loading="lazy"></p>
<h3 id="session执行select">session执行select</h3>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191402589.png" alt="image-20250119140234487" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191402205.png" alt="image-20250119140256112" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191403602.png" alt="image-20250119140314519" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191403076.png" alt="image-20250119140356954" loading="lazy"></p>
<p>这里的细节就是，根据statement唯一标识，获取具体的statement。</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191405032.png" alt="image-20250119140505939" loading="lazy"></p>
<p>这样，Executor就知道要具体做什么事，要执行的statement在哪里了。</p>
<p>接下来，执行Executor的方法：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191406275.png" alt="image-20250119140653151" loading="lazy"></p>
<p>由于Executor被代理了，这里就会跳转到Plugin中，判断要执行的方法，是否在拦截器链中定义了，决定是否要执行拦截器</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191407862.png" alt="image-20250119140743728" loading="lazy"></p>
<p>我这边，会被分页拦截器拦截住，就执行到了如下代码：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191411786.png" alt="image-20250119141100646" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191411570.png" alt="image-20250119141126451" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191412220.png" alt="image-20250119141210097" loading="lazy"></p>
<h3 id="statementhandler创建">statementHandler创建</h3>
<p>如下图，执行configuration的newStatementHandler方法：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191413124.png" alt="image-20250119141300980" loading="lazy"></p>
<p>可以看到，创建完成后，又会被拦截器链给拦截，检查是否需要创建动态代理。</p>
<p>我们继续看看statementHandler如何创建的：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191414550.png" alt="image-20250119141442413" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191415512.png" alt="image-20250119141507429" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191415139.png" alt="image-20250119141541002" loading="lazy"></p>
<p>在上图，在创建PreparedStatementHandler时，先创建父类BaseStatementHandler.</p>
<p>在父类BaseStatementHandler的构造函数的倒数两行，又去创建了：</p>
<pre><code class="language-java">ParameterHandler/ResultSetHandler
</code></pre>
<p>点进具体实现后，我们看到：分别创建这两种对象后，又用拦截器链进行了代理（当然，还是会先看看是否匹配拦截器中是否拦截了这些接口）</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191417900.png" alt="image-20250119141736801" loading="lazy"></p>
<p>至此，这几个对象就都创建好了，而且，拦截器目前也仅支持拦截这几种接口：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191420413.png" alt="image-20250119142000321" loading="lazy"></p>
<h3 id="preparestatement">prepareStatement</h3>
<p>接下来继续看下执行流程：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191421569.png" alt="image-20250119142124455" loading="lazy"></p>
<pre><code class="language-java">  private Statement prepareStatement(StatementHandler handler, Log statementLog)  {
    Statement stmt;
    // 获取连接
    Connection connection = getConnection(statementLog);
    // StatementHandler#prepare，该方法可以被拦截器链拦截
    stmt = handler.prepare(connection, transaction.getTimeout());
    handler.parameterize(stmt);
    return stmt;
  }
</code></pre>
<p>这里会先去获取连接：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191423602.png" alt="image-20250119142339486" loading="lazy"></p>
<p>这里也会看看是否要对连接进行动态代理，如果需要打印statement的log，就会对connection进行代理：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191425233.png" alt="image-20250119142509111" loading="lazy"></p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191425959.png" alt="image-20250119142533850" loading="lazy"></p>
<p>我们平时看到的mybatis sql日志，就是这里打印的。</p>
<p>我们回到主航线：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191427269.png" alt="image-20250119142705149" loading="lazy"></p>
<p>这里就会调用jdk中的connection类的prepareStatement方法，传入了原始的预编译sql：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191428508.png" alt="image-20250119142847404" loading="lazy"></p>
<p>完成statement创建后，再设置下属性：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191430381.png" alt="image-20250119143009260" loading="lazy"></p>
<p>再后面，就是执行具体的statement了，这块就不讲了：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191431605.png" alt="image-20250119143140468" loading="lazy"></p>
<h1 id="sql统计拦截器相关代码">sql统计拦截器相关代码</h1>
<h2 id="原理">原理</h2>
<p>至此，我们搞清楚了拦截器的大概逻辑：</p>
<p>拦截器链，会对四大对象进行动态代理：</p>
<p>org.apache.ibatis.executor.Executor</p>
<p>org.apache.ibatis.executor.statement.StatementHandler</p>
<p>org.apache.ibatis.executor.resultset.ResultSetHandler</p>
<p>org.apache.ibatis.executor.parameter.ParameterHandler</p>
<p>动态代理后，会先执行：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191435747.png" alt="image-20250119143512632" loading="lazy"></p>
<p>像我们的sql统计这个场景，需要获取到具体的sql，我这里选择拦截如下这个方法：</p>
<pre><code class="language-java">public interface StatementHandler {

  Statement prepare(Connection connection, Integer transactionTimeout)
      throws SQLException;
  ...
</code></pre>
<h2 id="拦截器代码">拦截器代码</h2>
<pre><code class="language-java">
import com.xx.util.spring.ApplicationContextUtils;
import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.executor.statement.StatementHandler;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.plugin.Interceptor;
import org.apache.ibatis.plugin.Intercepts;
import org.apache.ibatis.plugin.Invocation;
import org.apache.ibatis.plugin.Signature;
import org.springframework.beans.BeansException;

import java.sql.Connection;
import java.util.Objects;

@Intercepts(
        {
                @Signature(
                        type = StatementHandler.class,
                        method = "prepare",
                        args = {
                                Connection.class,
                                Integer.class
                        }
                )
        }
)
@Slf4j
public class SqlStatInterceptor implements Interceptor {
    private SqlStatService sqlStatService;

    private SqlStatProperties sqlStatProperties;

    private Boolean init = null;

    public SqlStatInterceptor() {
        log.info("create sqlStatInterceptor");
    }

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        if (init == null) {
            try {
                sqlStatService = ApplicationContextUtils.getBean(SqlStatService.class);
                sqlStatProperties = ApplicationContextUtils.getBean(SqlStatProperties.class);
            } catch (BeansException exception) {
                log.warn("no bean of type:SqlStatService or SqlStatProperties");
            }
            init = true;
        }
        if (sqlStatService == null) {
            return invocation.proceed();
        }
        if (sqlStatProperties == null) {
            return invocation.proceed();
        }
        boolean enableInterceptorOrNot = Objects.equals(sqlStatProperties.getStartInterceptOrNot(),
                true);
        if (!enableInterceptorOrNot) {
            return invocation.proceed();
        }

        if (invocation.getTarget() instanceof StatementHandler) {
            StatementHandler statementHandler = (StatementHandler) invocation.getTarget();
            BoundSql boundSql = statementHandler.getBoundSql();
            String sql = boundSql.getSql();
            sqlStatService.sqlStat(sql);
        }
        return invocation.proceed();

    }

}
</code></pre>
<p>核心代码就这两行：</p>
<p><img src="https://dump-1252523945.cos.ap-shanghai.myqcloud.com/img/202501191438082.png" alt="image-20250119143846985" loading="lazy"></p>
<p>这个sqlStatServcie可以自由定义，反正就是一个service，用来存储sql。</p>
<h2 id="sqlstatservice">sqlStatService</h2>
<pre><code class="language-java">
/**
 * 每次遇到一个sql，就记录到数据库；
 * 目的是为了方便建索引
 */
@Service
@Slf4j
public class SqlStatServiceImpl implements SqlStatService {
    @Autowired
    private SysSqlStatMapper sysSqlStatMapper;

    @Autowired
    private DataSource dataSource;

    @Override
    public void sqlStat(String sql) {
        // 我这边是存储到db的，表名为sys_sql_stat，这里return是为了避免循环
        boolean b = sql.contains("sys_sql_stat");
        if (b) {
            return;
        }
        /**
         * 没有where的语句一般不用建索引，直接不记录
         */
        boolean hasWhereClause = sql.contains("where") || sql.contains("WHERE");
        if (!hasWhereClause) {
            return;
        }

        try {
            String sqlAfterTrim = trimLimitClause(sql);
            String md5Hex = MD5Util.md5Hex(sqlAfterTrim);
            LocalDateTime now = LocalDateTime.now();
            int count = sysSqlStatMapper.updateBySqlHash(now, md5Hex);
            if (count == 0) {
                saveSqlStat(sqlAfterTrim, md5Hex, now);
            }
        } catch (Throwable throwable) {
            // rawSqlHash为唯一索引，未加锁的情况下，可能重复
            log.error("err", throwable);
        }
    }
    
    
    
    private void saveSqlStat(String sql, String md5Hex, LocalDateTime now) {
        SysSqlStat sysSqlStat = new SysSqlStat();
        sysSqlStat.setRawSql(sql);
        sysSqlStat.setRawSqlHash(md5Hex);
        sysSqlStat.setCount(1L);
        sysSqlStat.setCreatedAt(now);
        sysSqlStat.setUpdatedAt(now);
        sysSqlStatMapper.insert(sysSqlStat);
    }
    
    
    private static final Pattern PATTERN = Pattern.compile("limit\\s+\\d+,\\d+");

    private String trimLimitClause(String sql) {
        int index = sql.lastIndexOf("limit");
        if (index == -1) {
            return sql;
        }
        String limitClause = sql.substring(index);
        Matcher m = PATTERN.matcher(limitClause.trim());
        if (m.matches()) {
            String newSql = sql.substring(0,index);
            return newSql;
        }
        return sql;
    }
</code></pre>
<pre><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;commons-codec&lt;/groupId&gt;
    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
    &lt;version&gt;1.15&lt;/version&gt;
&lt;/dependency&gt;

public class MD5Util {

    public static String md5Hex(final String data) {
        return DigestUtils.md5Hex(data);
    }
}
</code></pre>
<pre><code class="language-java">@Component
public final class ApplicationContextUtils implements BeanFactoryPostProcessor{

    /**
     * Spring应用上下文环境
     */
    private static ConfigurableListableBeanFactory beanFactory;


    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        ApplicationContextUtils.beanFactory = beanFactory;
    }
    
    public static &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) {
        return beanFactory.getBean(requiredType);
    }
}
</code></pre>
<p>为什么使用spring工具类呢，因为如果改成autowired注入的话，会导致constructor类型的循环依赖，可以自行试试。</p>
<h2 id="外部装配类properties类">外部装配类、properties类</h2>
<pre><code class="language-java">@ConfigurationProperties(prefix = "sql-stat")
@Data
public class SqlStatProperties {
    private Boolean enabled;

    private Boolean startInterceptOrNot;
}
</code></pre>
<pre><code class="language-java">@Configuration
@Slf4j
@EnableConfigurationProperties(SqlStatProperties.class)
@ConditionalOnProperty(value = "sql-stat.enabled", havingValue = "true")
public class SqlStatInterceptorConfig {

    @Bean
    public SqlStatInterceptor sqlStatInterceptor(){
        SqlStatInterceptor interceptor = new SqlStatInterceptor();

        return interceptor;
    }
}
</code></pre>
<h2 id="sql-ddl">sql ddl</h2>
<p>我这边只有pg版本的（现在改成信创db了，这个db是基于pg改的）</p>
<pre><code class="language-shell">CREATE TABLE sys_sql_stat (
	id bigserial NOT NULL, -- id主键
	raw_sql varchar NOT NULL, -- 原始sql
	raw_sql_hash varchar NOT NULL, -- 对原始sql进行md5这类hash操作，便于计数
	count int8 NULL, -- sql的执行次数
	created_at timestamp NULL, -- 创建时间
	updated_at timestamp NULL, -- 更新时间
	CONSTRAINT sys_sql_stat_pk PRIMARY KEY (id)
)
WITH (
	orientation=row,
	compression=no,
	fillfactor=80
);
CREATE UNIQUE INDEX sys_sql_stat_raw_sql_hash_idx ON sys_sql_stat USING btree (raw_sql_hash) TABLESPACE pg_default;

-- Column comments

COMMENT ON COLUMN sys_sql_stat.id IS 'id主键';
COMMENT ON COLUMN sys_sql_stat.raw_sql IS '原始sql';
COMMENT ON COLUMN sys_sql_stat.raw_sql_hash IS '对原始sql进行md5这类hash操作，便于计数';
COMMENT ON COLUMN sys_sql_stat.count IS 'sql的执行次数';
COMMENT ON COLUMN sys_sql_stat.created_at IS '创建时间';
COMMENT ON COLUMN sys_sql_stat.updated_at IS '更新时间';
</code></pre>
<h2 id="查询接口">查询接口</h2>
<p>我还写了个查询接口来按表将这些sql查出来，逆序排序。</p>
<pre><code class="language-java">    @Autowired
    private SysSqlStatMapper sysSqlStatMapper;

    @Autowired
    private DataSource dataSource;

    @Override
    public List&lt;SqlStatDto&gt; querySqlStat() {
        Connection connection = null;
        List&lt;String&gt; tableNames;
        try {
            connection = dataSource.getConnection();
            DatabaseMetaData metaData = connection.getMetaData();
            ResultSet resultSet = metaData.getTables(null, "改成自己的schema", null, new String[]{"TABLE"});

            tableNames = new ArrayList&lt;&gt;();
            while (resultSet.next()) {
                tableNames.add(resultSet.getString("TABLE_NAME"));
            }
        } catch (Throwable throwable) {
            throw new RuntimeException(throwable);
        }
        List&lt;SysSqlStat&gt; sysSqlStats = sysSqlStatMapper.selectList(null);
        List&lt;SqlStatDto&gt; list = tableNames.stream().map(tableName -&gt; {
            SqlStatDto dto = new SqlStatDto();
            dto.setTableName(tableName);
            List&lt;SysSqlStat&gt; sqlStatListByTable = sysSqlStats.stream().filter(sqlStat -&gt; {
                return sqlStat.getRawSql().contains(tableName);
            }).sorted(Comparator.comparing(SysSqlStat::getCount).reversed())
                    .collect(Collectors.toList());

            List&lt;SqlStatDtoByTable&gt; sqlStatDtoByTableList = sqlStatListByTable.stream().map(item -&gt; {
                SqlStatDtoByTable statDtoByTable = new SqlStatDtoByTable();
                statDtoByTable.setId(item.getId());
                statDtoByTable.setRawSql(item.getRawSql());
                statDtoByTable.setRawSqlHash(item.getRawSqlHash());
                statDtoByTable.setCount(item.getCount());
                statDtoByTable.setCreatedAt(item.getCreatedAt());
                statDtoByTable.setUpdatedAt(item.getUpdatedAt());

                return statDtoByTable;
            }).collect(Collectors.toList());

            dto.setList(sqlStatDtoByTableList);
            return dto;
        }).collect(Collectors.toList());

        return list;
    }
</code></pre>
<pre><code class="language-java">
@Data
@Schema(description = "")
public class SysSqlStat {
    /**
     * 字典表
     */
    @Schema(description = "字典表")
    private Long id;

    /**
     * 原始sql
     */
    @Schema(description = "原始sql")
    private String rawSql;

    /**
     * 对原始sql进行md5这类hash操作，便于计数
     */
    @Schema(description = "对原始sql进行md5这类hash操作，便于计数")
    private String rawSqlHash;

    /**
     * sql的执行次数
     */
    @Schema(description = "sql的执行次数")
    private Long count;

    /**
     * 创建时间
     */
    @Schema(description = "创建时间")
    private LocalDateTime createdAt;

    /**
     * 更新时间
     */
    @Schema(description = "更新时间")
    private LocalDateTime updatedAt;


}
</code></pre>
<pre><code class="language-java">
@Data
public class SqlStatDtoByTable {

    @Schema(description = "字典表")
    private Long id;

    /**
     * 原始sql
     */
    @Schema(description = "原始sql")
    private String rawSql;

    /**
     * 对原始sql进行md5这类hash操作，便于计数
     */
    @Schema(description = "对原始sql进行md5这类hash操作，便于计数")
    private String rawSqlHash;

    /**
     * sql的执行次数
     */
    @Schema(description = "sql的执行次数")
    private Long count;

    /**
     * 创建时间
     */
    @Schema(description = "创建时间")
    private LocalDateTime createdAt;

    /**
     * 更新时间
     */
    @Schema(description = "更新时间")
    private LocalDateTime updatedAt;
}
</code></pre>
<pre><code class="language-java">@Data
public class SqlStatDto {
    private String tableName;

    private List&lt;SqlStatDtoByTable&gt; list;

}
</code></pre>
<h1 id="总结">总结</h1>
<p>这个拦截器就算写完了。写得过程中，也算是梳理了下代码，方便后续查看吧。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5511373175034722" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-19 15:00">2025-01-19 14:59</span>&nbsp;
<a href="https://www.cnblogs.com/grey-wolf">三国梦回</a>&nbsp;
阅读(<span id="post_view_count">31</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18679576" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18679576);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18679576', targetLink: 'https://www.cnblogs.com/grey-wolf/p/18679576', title: '利用mybatis拦截器记录sql，辅助我们建立索引(二)' })">举报</a>
</div>
        