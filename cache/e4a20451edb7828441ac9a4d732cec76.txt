
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/handsometaoa/p/18799314" title="发布于 2025-03-29 11:56">
    <span role="heading" aria-level="2">使用AOP技术实现Java通用接口验签工具</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景">一、背景</h2>
<p>在给第三方提供接口时，我们需要对接口进行验签。具体来说，当外部系统调用我们的接口时，请求中需要携带一个签名，我们接收到请求后，会解析数据并校验签名是否正确，以确保请求的合法性和安全性。</p>
<p><img src="https://img2024.cnblogs.com/blog/1704037/202503/1704037-20250329115449104-1586037272.png" alt="" loading="lazy"></p>
<p>为了在不同项目中方便地使用这一功能，我们将签名校验规则封装成一个工具包。使用方只需通过简单的注解即可轻松集成验签功能，无需重复编写验签逻辑，从而提高开发效率并确保一致性。</p>
<h2 id="二实现原理">二、实现原理</h2>
<ol>
<li>使用AOP来拦截方法</li>
<li>获取参数值进行组装、校验签名是否一致</li>
</ol>
<h2 id="三设计思路">三、设计思路</h2>
<p>通过俩个注解进行标记所需要进行验签的方法</p>
<pre><code class="language-java">@Target(ElementType.METHOD) // 注解只能用于方法
@Retention(RetentionPolicy.RUNTIME) // 注解在运行时可见
public @interface SignatureChecker {
    
    // 服务Code
    String serviceCode();
    // 密钥
    String secretKey() default "";
    // 默认为true，表示需要验证签名
    boolean required() default true;
    // 过期时间，单位为分钟
    int expireMinutes() default -1;
    
}
</code></pre>
<blockquote>
<p>serviceCode：服务编码，进行区分不同的服务/业务<br>
secretKey：双方约定好的密钥，进行生成签名，可以写在配置文件中。<br>
expireMinutes：标识签名有效时长，默认5分钟，可以配置文件中进行全局修改。</p>
</blockquote>
<pre><code class="language-java">@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
public @interface SignatureParam {

    String requestIdField() default "";
    String timestampField() default "";
    String signatureField() default "";
    
}
</code></pre>
<p>对于不同的请求实体，可能对应的字段名不相同，所以我们需要使用一个注解进行标注当前实体验签字段的名称。</p>
<p>当签名字段发生变化时，可以使用requestIdField、timestampField、signatureField 字段进行指定。</p>
<h2 id="四代码">四、代码</h2>
<h3 id="41-代码结构">4.1 代码结构</h3>
<p><img src="https://img2024.cnblogs.com/blog/1704037/202503/1704037-20250329121035583-497846560.png" alt="" loading="lazy"></p>
<h3 id="42-详细代码">4.2 详细代码</h3>
<h4 id="421-signaturecheckerclass">4.2.1 <strong>SignatureChecker.class</strong></h4>
<pre><code class="language-java">import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD) // 注解只能用于方法
@Retention(RetentionPolicy.RUNTIME) // 注解在运行时可见
public @interface SignatureChecker {
    
    // 服务Code
    String serviceCode();
    // 密钥
    String secretKey() default "";
    // 默认为true，表示需要验证签名
    boolean required() default true;
    // 过期时间，单位为分钟
    int expireMinutes() default -1;
    
}
</code></pre>
<h4 id="422-signatureparamclass">4.2.2 <strong>SignatureParam.class</strong></h4>
<pre><code class="language-java">import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
public @interface SignatureParam {

    String requestIdField() default "";
    String timestampField() default "";
    String signatureField() default "";

}
</code></pre>
<h4 id="423-signatureaspectclass">4.2.3 <strong>SignatureAspect.class</strong></h4>
<pre><code class="language-java">import com.alibaba.fastjson2.JSON;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.tao.anno.SignatureChecker;
import org.tao.anno.SignatureParam;
import org.tao.config.SignatureProperties;
import org.tao.ecxeption.SignatureValidationException;
import org.tao.util.SignatureUtil;

import javax.annotation.Resource;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.Map;

@Aspect
@Component
public class SignatureAspect {
    private static final Logger logger = LoggerFactory.getLogger(SignatureAspect.class);

    @Resource
    private SignatureProperties signatureProperties;

    @Around("@annotation(org.tao.anno.SignatureChecker)")
    public Object validateSignature(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        // 获取方法的所有参数
        Annotation[][] parameterAnnotations = method.getParameterAnnotations();
        Object[] args = joinPoint.getArgs();

        Map&lt;String, Object&gt; paramMap = null;
        SignatureChecker signatureChecker = method.getAnnotation(SignatureChecker.class);
        if (signatureChecker != null &amp;&amp; signatureChecker.required()) {
            SignatureParam signatureParam = null;
            // 遍历参数注解，找到被 @SignatureParam 注解修饰的参数
            outerLoop:
            for (int i = 0; i &lt; parameterAnnotations.length; i++) {
                for (Annotation anno : parameterAnnotations[i]) {
                    if (anno instanceof SignatureParam) {
                        signatureParam = (SignatureParam) anno;
                        Object paramValue = args[i];
                        try {
                            paramMap = JSON.parseObject(JSON.toJSONString(paramValue), Map.class);
                        } catch (Exception e) {
                            logger.error("[签名校验] 失败，请检查参数是否正确, paramValue =&gt; {}, message =&gt; {}", JSON.toJSONString(paramValue), e.getMessage());
                        }
                        break outerLoop;
                    }
                }
            }
            try {
                validateSignature(signatureChecker, signatureParam, paramMap);
            } catch (SignatureValidationException e) {
                logger.warn("[签名校验] 校验失败，paramMap =&gt; {}, message =&gt; {}", JSON.toJSONString(paramMap), e.getMessage());
                throw e;
            }
        }

        // 继续执行原方法
        return joinPoint.proceed();
    }

    private void validateSignature(SignatureChecker checker, SignatureParam signatureParam, Map&lt;String, Object&gt; paramMap) throws SignatureValidationException {
        // 获取服务编码
        String servicedCodeNew = checker.serviceCode();
        if (StringUtils.isEmpty(servicedCodeNew)) {
            throw new SignatureValidationException("缺失服务编码，请联系管理员配置！");
        }
        // 获取密钥
        String secretKey = StringUtils.isEmpty(checker.secretKey()) ? signatureProperties.getSecretKeys().get(servicedCodeNew) : checker.secretKey();
        if (StringUtils.isEmpty(secretKey)) {
            throw new SignatureValidationException("缺失验签密钥，请联系管理员配置！");
        }

        String signatureField = StringUtils.isEmpty(signatureParam.signatureField()) ? signatureProperties.getSignatureField() : signatureParam.signatureField();
        String requestIdField = StringUtils.isEmpty(signatureParam.requestIdField()) ? signatureProperties.getRequestIdField() : signatureParam.requestIdField();
        String timestampField = StringUtils.isEmpty(signatureParam.timestampField()) ? signatureProperties.getTimestampField() : signatureParam.timestampField();
        // 获取请求参数
        String requestId = paramMap.get(requestIdField) == null ? null : paramMap.get(requestIdField).toString();
        String signature = paramMap.get(signatureField) == null ? null : paramMap.get(signatureField).toString();
        Long timestamp = paramMap.get(timestampField) == null ? null : Long.parseLong(paramMap.get(timestampField).toString());

        if (requestId == null || signature == null || timestamp == null) {
            throw new SignatureValidationException("缺失验签参数，请检查！");
        }

        // 校验时间戳
        validateTimestamp(timestamp, checker.expireMinutes());
        // 校验签名
        if (!SignatureUtil.verifySignature(requestId + timestamp, secretKey, signature)) {
            throw new SignatureValidationException("签名校验不通过！");
        }
    }

    private void validateTimestamp(long timestamp, int expireMinutes) throws SignatureValidationException {
        // 如果是-1，则使用配置文件中的默认值
        expireMinutes = expireMinutes == -1 ? signatureProperties.getExpireMinutes() : expireMinutes;
        // 如果是0，则代表永久有效，不进行时间判断
        if (expireMinutes == 0) {
            return;
        } else if (expireMinutes &lt;= 0) {
            throw new SignatureValidationException("过期时间配置无效，请检查！");
        }

        long currentTime = System.currentTimeMillis();
        if (timestamp &gt; currentTime + 5 * 60 * 1000) {
            throw new SignatureValidationException("调用端时间与服务器时间未同步，请检查！");
        } else if (currentTime - timestamp &gt; (long) expireMinutes * 60 * 1000) {
            throw new SignatureValidationException("请求已过期，请重新请求！");
        }
    }
}
</code></pre>
<h4 id="424-signatureautoconfigurationclass">4.2.4 <strong>SignatureAutoConfiguration.class</strong></h4>
<pre><code class="language-java">import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.tao.aop.SignatureAspect;

/**
 * @author: handsometaoa
 * @description
 * @date: 2025/3/29 11:00
 */


@Configuration
@EnableConfigurationProperties(SignatureProperties.class)
public class SignatureAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public SignatureAspect signatureAspect() {
        return new SignatureAspect();
    }


}

</code></pre>
<h4 id="425-signaturepropertiesclass">4.2.5 <strong>SignatureProperties.class</strong></h4>
<pre><code class="language-java">import org.springframework.boot.context.properties.ConfigurationProperties;

import java.util.HashMap;
import java.util.Map;

@ConfigurationProperties(prefix = "signature")
public class SignatureProperties {

    private String requestIdField = "requestId";
    private String timestampField = "timestamp";
    private String signatureField = "signature";
    private Integer expireMinutes = 5;
    private Map&lt;String, String&gt; secretKeys = new HashMap&lt;&gt;();

    public Map&lt;String, String&gt; getSecretKeys() {
        return secretKeys;
    }

    public void setSecretKeys(Map&lt;String, String&gt; secretKeys) {
        this.secretKeys = secretKeys;
    }

    public Integer getExpireMinutes() {
        return expireMinutes;
    }

    public void setExpireMinutes(Integer expireMinutes) {
        this.expireMinutes = expireMinutes;
    }

    public String getRequestIdField() {
        return requestIdField;
    }

    public void setRequestIdField(String requestIdField) {
        this.requestIdField = requestIdField;
    }

    public String getSignatureField() {
        return signatureField;
    }

    public void setSignatureField(String signatureField) {
        this.signatureField = signatureField;
    }

    public String getTimestampField() {
        return timestampField;
    }

    public void setTimestampField(String timestampField) {
        this.timestampField = timestampField;
    }
}
</code></pre>
<h4 id="427-globalexceptionhandler">4.2.7 <strong>GlobalExceptionHandler</strong></h4>
<pre><code class="language-java">import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(SignatureValidationException.class)
    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; handleSignatureValidationException(SignatureValidationException ex) {
        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();
        response.put("code", 500);
        response.put("message", ex.getMessage());
        return new ResponseEntity&lt;&gt;(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
</code></pre>
<h4 id="428-signaturevalidationexceptionclass">4.2.8 SignatureValidationException.class</h4>
<pre><code class="language-java">public class SignatureValidationException extends RuntimeException {
    public SignatureValidationException(String message) {
        super(message);
    }
}
</code></pre>
<h4 id="429-signatureutilclass">4.2.9 <strong>SignatureUtil.class</strong></h4>
<pre><code class="language-java">

import org.springframework.util.DigestUtils;

/**
 * @author: handsometaoa
 * @description
 * @date: 2025/3/29 11:00
 */
public class SignatureUtil {

    /**
     * 校验签名是否正确
     *
     * @param params    请求参数
     * @param sign      客户端传递的签名
     * @param secretKey 密钥
     * @return 是否校验通过
     */
    public static boolean verifySignature(String params, String secretKey, String sign) {
        String serverSign = generateSignature(params, secretKey);
        return serverSign.equals(sign);
    }

    /**
     * 生成签名
     *
     * @param params    请求参数
     * @param secretKey 密钥
     * @return 生成的签名
     */
    private static String generateSignature(String params, String secretKey) {
        String rawData = params + secretKey;
        return DigestUtils.md5DigestAsHex(rawData.getBytes());
    }


}

</code></pre>
<h4 id="4210-springfactoriesclass">4.2.10 spring.factories.class</h4>
<pre><code class="language-plain">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.tao.config.SignatureAutoConfiguration
</code></pre>
<h4 id="4211-pomxml">4.2.11 pom.xml</h4>
<pre><code class="language-plaintext">  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
      &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
      &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
      &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt;
      &lt;artifactId&gt;fastjson2&lt;/artifactId&gt;
      &lt;version&gt;2.0.31&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre>
<h2 id="五使用方式">五、使用方式</h2>
<h3 id="51-集成方式-俩种方式">5.1 集成方式 （俩种方式）</h3>
<ol>
<li>打成 jar 包引入依赖</li>
<li>直接将代码拷进自己项目</li>
</ol>
<h3 id="52-使用说明">5.2 使用说明</h3>
<ol>
<li>在方法上添加 <code>@SignatureChecker</code> 注解，包含密钥的参数前添加 <code>@SignatureParam</code> 注解；举例：假设需要给XX业务进行验签，约定密钥为XXX，请求参数分别为 request_id、timeStamp、signature</li>
</ol>
<pre><code class="language-java">@PostMapping("test")
@SignatureChecker(serviceCode = "XX", secretKey = "XXX")
public String test(@RequestBody @SignatureParam(requestIdField = "request_id", timestampField = "timeStamp") Request request) {
    return "test";
}
</code></pre>
<ol start="2">
<li>基于 注解值 &gt; 配置值 &gt; 默认值  （约定大于配置）</li>
</ol>
<ul>
<li>密钥 secretKey : 注解(secretKey) &gt; 配置值 （signature.secretKeys 中定义的）</li>
<li>有效期 expireMinutes：注解（expireMinutes）&gt; 配置值 （signature.expireMinutes）&gt; 默认值（5）</li>
<li>验签字段：注解（requestIdField、timestampField、signatureField）&gt; 配置值 （signature.requestIdField) &gt; 默认值（requestId、timestamp、signature）</li>
</ul>
<ol start="3">
<li>请求接口<br>
<img src="https://img2024.cnblogs.com/blog/1704037/202503/1704037-20250329115525854-1672255685.png" alt="" loading="lazy"></li>
</ol>
<h2 id="六最后">六、最后</h2>
<p>当然代码还是有很多不足的地方，仅供学习参考。<br>
源码：<a href="https://github.com/handsometaoa/signutare-kit" target="_blank" rel="noopener nofollow">https://github.com/handsometaoa/signutare-kit</a></p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/handsometaoa/" target="_blank">帅气的涛啊</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/handsometaoa/p/18799314" target="_blank">https://www.cnblogs.com/handsometaoa/p/18799314</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.0827663786655093" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-29 12:21">2025-03-29 11:56</span>&nbsp;
<a href="https://www.cnblogs.com/handsometaoa">帅气的涛啊</a>&nbsp;
阅读(<span id="post_view_count">106</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18799314" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18799314);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18799314', targetLink: 'https://www.cnblogs.com/handsometaoa/p/18799314', title: '使用AOP技术实现Java通用接口验签工具' })">举报</a>
</div>
        