
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wenbochang/p/18688107" title="发布于 2025-01-23 16:31">
    <span role="heading" aria-level="2">详细剖析Java动态线程池的扩容以及缩容操作</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="前言">前言</h1>
<p>在项目中，我们经常会使用到线程来处理加快我们的任务。但为了节约资源，大多数程序员都会把线程进行池化，使用线程池来更好的支持我们的业务。</p>
<p>Java线程池<code>ThreadPoolExecutor</code>有几个比较核心的参数，如<code>corePoolSize、maximumPoolSize</code>等等。无论是在工作中还是在面试中，都会被问到，如何正确的设置这几个参数。</p>
<p><strong>线程池的参数并不好配置</strong>。一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识。项目IO密集型还是CPU密集型等等，总归很难确定一个完美的参数，此时就有了动态线程池的诞生。</p>
<h1 id="动态线程池dtp原理">动态线程池(DTP)原理</h1>
<p>其实动态线程池并不是很高大上的技术，它底层依旧是依赖了<code>ThreadPoolExecutor</code>的一些核心接口方法。我们通过下面图片可以很清楚的看到，<code>ThreadPoolExecutor</code>本身就给我们提供了很多钩子方法，让我们去定制化。</p>
<p><img src="https://img2024.cnblogs.com/blog/1335795/202501/1335795-20250123163019168-1782918333.png" alt="" loading="lazy"></p>
<p>那么其原理也非常简单了，我们在运行中假设有一个线程池叫做<code>TaskExecutor</code></p>
<ol>
<li>他的核心线程池默认假设是10，现在我发觉不够用了，此时我想把他的核心线程池调整为20</li>
<li>我可以写一个远程配置(可以阿波罗，zk，redis什么都可以)。然后监听到了这个配置变为了core.pool.size=20</li>
<li>然后我获取到了这个线程池<code>TaskExecutor</code>，并且调用<code>setCorePoolSize(20)</code>，那么这个<code>TaskExecutor</code>核心线程数就变为了20</li>
</ol>
<p>就是这么简单，拨开表面，探究原理，内部其实非常的简单。当时公司里面的线程池还有加一些<strong>友好的界面、监控告警、操作日志、权限校验、审核</strong>等等，但本质就是监听配置，然后调用setCorePoolSize方法去实现的，最大线程数类似。</p>
<pre><code class="language-java">public void setCorePoolSize(int corePoolSize) {
    if (corePoolSize &lt; 0)
        throw new IllegalArgumentException();
    int delta = corePoolSize - this.corePoolSize;
    this.corePoolSize = corePoolSize;
    if (workerCountOf(ctl.get()) &gt; corePoolSize)
        interruptIdleWorkers();
    else if (delta &gt; 0) {
        int k = Math.min(delta, workQueue.size());
        while (k-- &gt; 0 &amp;&amp; addWorker(null, true)) {
            if (workQueue.isEmpty())
                break;
        }
    }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1335795/202501/1335795-20250123163028281-515625009.png" alt="" loading="lazy"></p>
<h1 id="动态线程池缩容">动态线程池缩容</h1>
<p>首先提出几个问题</p>
<ol>
<li>核心线程数为5，现在有3个线程在执行，并且没有执行完毕，我修改核心线程数为4，是否修改成功</li>
<li>核心线程数为5，现在有3个线程在执行，并且没有执行完毕，我修改核心线程数为1，是否修改成功</li>
</ol>
<p><strong>让我们带着疑问去思考问题。</strong></p>
<ol>
<li>首先第一个问题，因为核心线程池数为5，仅有3个在执行，我修改为4，那么因为有2个空闲的线程，它只需要销毁1个空闲线程即可，因此是成功的</li>
<li>第二个问题，核心线程池数为5，仅有3个在执行，我修改为1。虽然有2个空闲线程，但是我需要销毁4个线程。因为有2个空闲线程，2个非空闲线程。<strong>我只能销毁2个空闲线程，另外2个执行的任务不能被打断</strong>，也就是执行后仍然为3个核心线程数。</li>
<li>那什么时候销毁剩下2个执行的线程呢，等到2个执行的任务完毕之后，就会销毁它了。假设这个任务是一个死循环，永远不会结束，那么核心线程数永远是3，永远不能设置为1</li>
</ol>
<p>我们举一个代码的例子如下</p>
<pre><code class="language-java">ThreadPoolExecutor es = new ThreadPoolExecutor(5, 10, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;());
es.prestartAllCoreThreads();  // 预启动所有核心线程

// 启动三个任务，执行次数不一样
for (int i = 0; i &lt; 3; i++) {
    int finalI = i;
    es.execute(() -&gt; {
        int cnt = 0;
        while (true) {
            try {
                cnt++;
                TimeUnit.SECONDS.sleep(2);

                if (cnt &gt; finalI + 1) {
                    log.info(Thread.currentThread().getName() + " 执行完毕");
                    break;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });
}
TimeUnit.SECONDS.sleep(1);  // 等待线程池中的线程执行
log.info("修改前 es = {}", es);  // 这里核心线程数必定是5

es.setCorePoolSize(1);  // 修改核心线程数为1，但是核心线程数为5，并且有3个线程在执行任务，

while (true) {
    TimeUnit.SECONDS.sleep(1); // 等待
    log.info("修改后 es = {}", es);
}
</code></pre>
<p>输出结果为如下</p>
<pre><code class="language-js">// 修改前核心线程数为5，运行线程数为3
[修改前 es = java.util.concurrent.ThreadPoolExecutor@72d818d1[Running, pool size = 5, active threads = 3, queued tasks = 0, completed tasks = 0]]

// 因为有2个空闲线程，先把2个空闲线程给销毁了，剩下3个线程
[修改后 es = java.util.concurrent.ThreadPoolExecutor@72d818d1[Running, pool size = 3, active threads = 3, queued tasks = 0, completed tasks = 0]]

// 等第1个任务执行完毕，剩下2个线程
[Main.lambda$d$0:38] [pool-2-thread-1 执行完毕]
[修改后 es = java.util.concurrent.ThreadPoolExecutor@72d818d1[Running, pool size = 2, active threads = 2, queued tasks = 0, completed tasks = 1]]

// 等第2个任务执行完毕，剩下1个线程
[Main.lambda$d$0:38] [pool-2-thread-2 执行完毕]
[修改后 es = java.util.concurrent.ThreadPoolExecutor@72d818d1[Running, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 2]]

// 等第3个任务执行完毕，剩下1个线程。因为我修改的就是1个核心线程
[Main.lambda$d$0:38] [pool-2-thread-3 执行完毕]
[修改后 es = java.util.concurrent.ThreadPoolExecutor@72d818d1[Running, pool size = 1, active threads = 0, queued tasks = 0, completed tasks = 3]]

</code></pre>
<p>有兴趣的读者可以拿这块带去自己去试试，输出结果里面的注释 我写的非常详细，大家可以详细品品这块输出结果。</p>
<h1 id="动态线程池扩容">动态线程池扩容</h1>
<p>扩容我就不提问问题了，和缩容异曲同工，但我希望读者可以先看下以下代码，不要看答案，认为会输出什么结果，看下是否和自己想的是否一样，如果一样，那说明你已经完全懂了，如果不一样，是什么原因。</p>
<pre><code class="language-java">// 核心线程数1，最大线程数10
ThreadPoolExecutor es = new ThreadPoolExecutor(1, 10, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;());
es.prestartAllCoreThreads();  // 预启动所有核心线程

for (int i = 0; i &lt; 5; i++) {
    int finalI = i;
    es.execute(() -&gt; {
        int cnt = 0;
        while (true) {
            try {
                cnt++;
                TimeUnit.SECONDS.sleep(2);

                if (cnt &gt; finalI + 1) {
                    log.info(Thread.currentThread().getName() + " 执行完毕");
                    break;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });
}

TimeUnit.SECONDS.sleep(1);  // 等待线程池中的线程执行
log.info("修改前 es = {}", es);  // 这里核心线程数必定是1, 队列里面有4个任务

es.setCorePoolSize(3);  // 修改核心线程数为3

while (true) {
    TimeUnit.SECONDS.sleep(1); // 等待
    log.info("修改后 es = {}", es);
}   
</code></pre>
<p>输出结果为如下 （<strong>注意观察输出queued tasks的变化！！！</strong>）</p>
<pre><code class="language-js">[修改前 es = java.util.concurrent.ThreadPoolExecutor@1e397ed7[Running, pool size = 1, active threads = 1, queued tasks = 4, completed tasks = 0]]
[修改后 es = java.util.concurrent.ThreadPoolExecutor@1e397ed7[Running, pool size = 3, active threads = 3, queued tasks = 2, completed tasks = 0]]

[Main.lambda$a$1:73] [pool-2-thread-1 执行完毕]
[修改后 es = java.util.concurrent.ThreadPoolExecutor@1e397ed7[Running, pool size = 3, active threads = 3, queued tasks = 1, completed tasks = 1]]

[Main.lambda$a$1:73] [pool-2-thread-2 执行完毕]
[修改后 es = java.util.concurrent.ThreadPoolExecutor@1e397ed7[Running, pool size = 3, active threads = 3, queued tasks = 0, completed tasks = 2]]

[Main.lambda$a$1:73] [pool-2-thread-3 执行完毕]
[修改后 es = java.util.concurrent.ThreadPoolExecutor@1e397ed7[Running, pool size = 3, active threads = 2, queued tasks = 0, completed tasks = 3]]

[Main.lambda$a$1:73] [pool-2-thread-1 执行完毕]
[修改后 es = java.util.concurrent.ThreadPoolExecutor@1e397ed7[Running, pool size = 3, active threads = 1, queued tasks = 0, completed tasks = 4]]

[Main.lambda$a$1:73] [pool-2-thread-2 执行完毕]
[修改后 es = java.util.concurrent.ThreadPoolExecutor@1e397ed7[Running, pool size = 3, active threads = 0, queued tasks = 0, completed tasks = 5]]
</code></pre>
<h1 id="最后">最后</h1>
<p>在业务中，我们为了提高效率使用了线程，为了加快线程我们使用了线程池，而又为了更好的利用线程池的资源，我们又实现了动态化线程池。这也就是遇到问题、探索问题、解决问题的一套思路吧。</p>
<p>我们从底层原理分析，发现动态线程池的底层原理非常简单，希望大家不要恐惧，往往拨开外衣，发现里面最根本的原理，才能是我们更好的捋清楚其中的逻辑。希望本文提供的动态化线程池思路能对大家有帮助。</p>
<p>最终也极力希望读者朋友们，可以将上述两个例子详细分析一下原因，相信会有不小的进步，谢谢大家。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07345706539814814" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-23 16:31">2025-01-23 16:31</span>&nbsp;
<a href="https://www.cnblogs.com/wenbochang">程序员博博</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18688107" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18688107);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18688107', targetLink: 'https://www.cnblogs.com/wenbochang/p/18688107', title: '详细剖析Java动态线程池的扩容以及缩容操作' })">举报</a>
</div>
        