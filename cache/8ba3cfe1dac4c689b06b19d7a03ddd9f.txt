
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fivestudy/p/18826453" title="发布于 2025-04-15 11:54">
    <span role="heading" aria-level="2">华为od机考2025A卷真题 -查找接口成功率最优时间段</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="题目描述与示例">题目描述与示例</h1>
<h2 id="题目描述">题目描述</h2>
<p>服务之间交换的接口成功率作为服务调用关键质量特性，某个时间段内的接口失败率使用一个数组表示，数组中每个元素都是单位时间内失败率数值，数组中的数值为 <code>0~100</code> 的整数，给定一个数值(<code>minAverageLost</code>)表示某个时间段内平均失败率容忍值，即平均失败率小于等于 <code>minAverageLost</code>，找出数组中最长时间段，如果未找到则直接返回 <code>NULL</code>。</p>
<p>题目练习网址：<a href="https://www.algomooc.com/problem/P3281" target="_blank" rel="noopener nofollow">https://www.algomooc.com/problem/P3281</a></p>
<h2 id="输入描述">输入描述</h2>
<p>输入有两行内容，第一行为<code>minAverageLost</code>，第二行为数组，数组元素通过空格<code>" "</code>分隔，<code>minAverageLost</code> 及数组中元素取值范围为 <code>0~100</code> 的整数，数组元素的个数不会超过 <code>100</code> 个。</p>
<h2 id="输出描述">输出描述</h2>
<p>找出平均值小于等于 <code>minAverageLost</code> 的最长时间段，输出数组下标对，格式<code>{beginIndex}-{endIndx}</code>(下标从 <code>0</code> 开始)，如果同时存在多个最长时间段，则输出多个下标对且下标对之间使用空格<code>" "</code>拼接，多个下标对按下标从小到大排序。</p>
<h2 id="示例一">示例一</h2>
<h3 id="输入">输入</h3>
<pre><code class="language-Plain">1
0 1 2 3 4
</code></pre>
<h3 id="输出">输出</h3>
<pre><code class="language-Plain">0-2
</code></pre>
<h3 id="说明">说明</h3>
<p>A、输入解释：<code>minAverageLost=1</code>，数组<code>[0, 1, 2, 3, 4]</code></p>
<p>B、前 <code>3</code> 个元素的平均值为 <code>1</code>，因此数组第一个至第三个数组下标，即 <code>0-2</code></p>
<h2 id="示例二">示例二</h2>
<h3 id="输入-1">输入</h3>
<pre><code class="language-Plain">2
0 0 100 2 2 99 0 2
</code></pre>
<h3 id="输出-1">输出</h3>
<pre><code class="language-Plain">0-1 3-4 6-7
</code></pre>
<h3 id="说明-1">说明</h3>
<p>A、输入解释：<code>minAverageLost = 2</code>，数组<code>[0, 0, 100, 2, 2, 99, 0, 2]</code></p>
<p>B、通过计算小于等于 <code>2</code> 的最长时间段为：数组下标为 <code>0-1</code> 即<code>[0, 0]</code>，数组下标为 <code>3-4</code> 即<code>[2, 2]</code>，数组下标为 <code>6-7</code> 即<code>[0, 2]</code>，这三个部分都满足平均值小于等 <code>2</code> 的要求，因此输出 <code>0-1 3-4 6-7</code></p>
<h1 id="解题思路">解题思路</h1>
<p>本题数据规模不大，可以用暴力法枚举所有的区间来解决。</p>
<p>暴力法就略去不表，这里主要讲解复杂度较优秀的解法。</p>
<h2 id="贪心思想">贪心思想</h2>
<p>由于题目要求我们找到数组中平均失败率小于等于 <code>minAverageLost</code>的中最长时间段，我们<strong>贪心地优先从区间长度更大的情况开始考虑</strong>。</p>
<p>对于已知长度为<code>n</code>的数组<code>nums</code>而言，其中的连续子区间的长度<code>l</code>的最大值即为<code>n</code>。</p>
<p>故我们可以从<code>n</code>开始到<code>1</code>结束，逆序遍历连续子区间的长度<code>l</code>，即</p>
<pre><code class="language-Python">for l in range(n, 0, -1):
    pass
</code></pre>
<p>一旦发现，对于某一个固定长度<code>l</code>，我们能够找到长度为<code>l</code>的连续区间的区间和的平均值小于等于<code>minAverageLost</code>，则说明我们一定找到的是最长的满足题意的区间。</p>
<h2 id="将除法转换为乘法">将除法转换为乘法</h2>
<p>由于计算平均值涉及到除法，我们在计算过程中应该尽量地避免除法（尤其是可能出现不整除的情况）。</p>
<p>对于某个特定的<code>l</code>，连续区间的长度已经确定为<code>l</code>，假设连续区间和为<code>interval_sum</code>，那么满足题意的式子<code>interval_sum / l &lt;= minAverageLost</code>可以转化为<code>interval_sum &lt;= minAverageLost * l</code>。</p>
<p>设阈值<code>threshold = minAverageLost * l</code>，我们就可以把问题进一步转化为，求在特定<code>l</code>的情况下，存在哪一些区间满足条件<code>interval_sum &lt;= threshold</code>了。</p>
<p>所以剩下的问题，就是解决如何方便地计算长度为<code>l</code>的连续区间和了。</p>
<p>计算连续子数组的和相关的题目，一般就是<strong>使用滑窗或者前缀和来解决</strong>。</p>
<h2 id="固定滑窗">固定滑窗</h2>
<p>对于某一个确定的<code>l</code>值，我们可以使用固定滑窗算法来计算连续区间和（即窗口和）<code>interval_sum</code>。</p>
<p>整个过程的核心代码为</p>
<pre><code class="language-Python"># 计算阈值threshold，
# 连续区间和必须小于这个阈值才可以
threshold = minAverageLost * l
# 初始化第一个窗口的窗口和
interval_sum = sum(nums[:l])
if interval_sum &lt;= threshold:
    ans.append(f"{0}-{l-1}")
# 固定滑窗过程
for right, num_right in enumerate(nums[l:], l):
    # A1
    interval_sum += num_right
    # A2
    interval_sum -= nums[right-l]
    # A3
    if interval_sum &lt;= threshold:
        # 储存的区间是左闭右闭区间，故左边界应该为right-l+1
        ans.append(f"{right-l+1}-{right}")
</code></pre>
<h2 id="前缀和">前缀和</h2>
<p>考虑前缀和技巧。构建前缀和数组为<code>pre_sum</code>（注意前缀和数组的大小比原数组<code>nums</code>多一位，为<code>n+1</code>）。</p>
<p>我们可以枚举所有区间的起始点<code>i</code>，那么所有长度为<code>l</code>的连续区间和可以表示为<code>pre_sum[i+l]-pre_sum[i]</code></p>
<p>这里唯一的难点在于确定起始位置<code>i</code>的范围。我们可以通过取特殊边界值代入的方式来确定。若</p>
<ul>
<li>选取<code>l = n</code>
<ul>
<li>原数组仅存在一个连续区间<code>nums[0:n]</code></li>
<li>区间和<code>interval_sum = pre_sum[n]-pre_sum[0]</code></li>
<li><code>i</code>的范围应该是<code>range(0, 1)</code></li>
<li>考虑右边界，<code>1 = n - n + 1 = n - l + 1</code>，故确定区间范围应该是<code>range(0, n-l+1)</code></li>
</ul>
</li>
<li>选取<code>l = 1</code>
<ul>
<li>考虑原数组最后一个连续区间<code>nums[n-1:n]</code></li>
<li>区间和<code>interval_sum = pre_sum[n]-pre_sum[n-1]</code></li>
<li><code>i</code>的范围应该是<code>range(0, n)</code></li>
<li>考虑右边界，<code>n = n - 1 + 1 = n - l + 1</code>，故确定区间范围应该是<code>range(0, n-l+1)</code></li>
</ul>
</li>
</ul>
<p>故整个过程的核心代码为</p>
<pre><code class="language-Python"># 计算阈值threshold，
# 连续区间和必须小于这个阈值才可以
threshold = minAverageLost * l
# 遍历区间的起始位置i，其范围为[0, n-l+1)
# 这里的范围，可以用特殊值代入法来确定：
# 选取特例l = n，那么n-l+1 = 1
# 由于前缀和数组的长度为n+1，因此选取pre_sum[i+l]才不越界
for i in range(0, n-l+1):
    # 对于每一个区间的起始位置i，我们都需要考虑长度为l的区间[i:i+l]的区间和
    # 使用前缀和计算区间和interval_sum
    interval_sum = pre_sum[i+l] - pre_sum[i]
    # 如果区间和小于等于阈值，则这个区间是满足题意的区间，将其加入ans中
    if interval_sum &lt;= threshold:
        # 储存的区间是左闭右闭区间，故右边界应该为i+l-1
        ans.append(f"{i}-{i+l-1}")
</code></pre>
<h1 id="代码">代码</h1>
<h2 id="解法一前缀和">解法一：前缀和</h2>
<h3 id="python">Python</h3>
<pre><code class="language-Python"># 欢迎来到「欧弟算法 - 华为OD全攻略」,收录华为OD题库、面试指南、八股文与学员案例！
# 地址：https://www.odalgo.com



from itertools import accumulate


# 输入
minAverageLost = int(input())
nums = list(map(int, input().split()))

# 构建解决问题的函数
def solve(minAverageLost, nums):
    # 数据长度
    n = len(nums)
    # 构建前缀和数组，注意首位需要填充一个0，表示不选取任何数字的前缀和
    pre_sum = [0] + list(accumulate(nums))
    # 构建答案数组
    ans = list()
    # 逆序遍历区间的长度l，
    # 贪心地优先考虑尽可能大的区间
    for l in range(n, 0, -1):
        # 计算阈值threshold，
        # 连续区间和必须小于这个阈值才可以
        threshold = minAverageLost * l
        # 遍历区间的起始位置i，其范围为[0, n-l+1)
        # 这里的范围，可以用特殊值代入法来确定：
        # 选取特例l = n，那么n-l+1 = 1
        # 由于前缀和数组的长度为n+1，因此选取pre_sum[i+l]才不越界
        for i in range(0, n-l+1):
            # 对于每一个区间的起始位置i，我们都需要考虑长度为l的区间[i:i+l]的区间和
            # 使用前缀和计算区间和interval_sum
            interval_sum = pre_sum[i+l] - pre_sum[i]
            # 如果区间和小于等于阈值，则这个区间是满足题意的区间，将其加入ans中
            if interval_sum &lt;= threshold:
                # 储存的区间是左闭右闭区间，故右边界应该为i+l-1
                ans.append(f"{i}-{i+l-1}")
        # 在考虑大小为l的区间之后，如果ans中有值
        # 则说明找到了最长的满足题意的区间，将ans合并后返回输出
        if ans:
            return " ".join(ans)
    
    # 如果退出循环后，没有返回任何的一个ans，则说明找不到任意一个区间满足题意
    # 此时应该返回"NULL"输出
    return "NULL"

# 调用函数并输出答案
print(solve(minAverageLost, nums))
</code></pre>
<h3 id="java">Java</h3>
<pre><code class="language-Java">import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.StringJoiner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 输入
        int minAverageLost = scanner.nextInt();
        scanner.nextLine(); // 读取换行符
        String line = scanner.nextLine();
        String[] numStrs = line.split(" ");
        int[] nums = new int[numStrs.length];
        for (int i = 0; i &lt; numStrs.length; i++) {
            nums[i] = Integer.parseInt(numStrs[i]);
        }

        // 调用函数并输出答案
        System.out.println(solve(minAverageLost, nums));
    }

    // 构建解决问题的函数
    public static String solve(int minAverageLost, int[] nums) {
        // 数据长度
        int n = nums.length;
        // 构建前缀和数组，注意首位需要填充一个0，表示不选取任何数字的前缀和
        int[] preSum = new int[n + 1];
        for (int i = 1; i &lt;= n; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }

        // 构建答案数组
        List&lt;String&gt; ans = new ArrayList&lt;&gt;();
        // 逆序遍历区间的长度l，
        // 贪心地优先考虑尽可能大的区间
        for (int l = n; l &gt; 0; l--) {
            // 计算阈值threshold，
            // 连续区间和必须小于这个阈值才可以
            int threshold = minAverageLost * l;
            // 遍历区间的起始位置i，其范围为[0, n-l+1)
            // 这里的范围，可以用特殊值代入法来确定：
            // 选取特例l = n，那么n-l+1 = 1
            // 由于前缀和数组的长度为n+1，因此选取preSum[i+l]才不越界
            for (int i = 0; i &lt;= n - l; i++) {
                // 对于每一个区间的起始位置i，我们都需要考虑长度为l的区间[i:i+l]的区间和
                // 使用前缀和计算区间和intervalSum
                int intervalSum = preSum[i + l] - preSum[i];
                // 如果区间和小于等于阈值，则这个区间是满足题意的区间，将其加入ans中
                if (intervalSum &lt;= threshold) {
                    // 储存的区间是左闭右闭区间，故右边界应该为i+l-1
                    ans.add(i + "-" + (i + l - 1));
                }
            }
            // 在考虑大小为l的区间之后，如果ans中有值
            // 则说明找到了最长的满足题意的区间，将ans合并后返回输出
            if (!ans.isEmpty()) {
                StringJoiner result = new StringJoiner(" ");
                for (String s : ans) {
                    result.add(s);
                }
                return result.toString();
            }
        }

        // 如果退出循环后，没有返回任何的一个ans，则说明找不到任意一个区间满足题意
        // 此时应该返回"NULL"输出
        return "NULL";
    }
}
</code></pre>
<h3 id="c">C++</h3>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;numeric&gt;

using namespace std;

string solve(int minAverageLost, const vector&lt;int&gt;&amp; nums) {
    // 数据长度
    int n = nums.size();
    // 构建前缀和数组，注意首位需要填充一个0，表示不选取任何数字的前缀和
    vector&lt;int&gt; pre_sum(n + 1, 0);
    partial_sum(nums.begin(), nums.end(), pre_sum.begin() + 1);

    // 构建答案数组
    vector&lt;string&gt; ans;
    // 逆序遍历区间的长度l，
    // 贪心地优先考虑尽可能大的区间
    for (int l = n; l &gt; 0; --l) {
        // 计算阈值threshold，
        // 连续区间和必须小于这个阈值才可以
        int threshold = minAverageLost * l;
        // 遍历区间的起始位置i，其范围为[0, n-l+1)
        // 这里的范围，可以用特殊值代入法来确定：
        // 选取特例l = n，那么n-l+1 = 1
        // 由于前缀和数组的长度为n+1，因此选取pre_sum[i+l]才不越界
        for (int i = 0; i &lt;= n - l; ++i) {
            // 对于每一个区间的起始位置i，我们都需要考虑长度为l的区间[i:i+l]的区间和
            // 使用前缀和计算区间和interval_sum
            int interval_sum = pre_sum[i + l] - pre_sum[i];
            // 如果区间和小于等于阈值，则这个区间是满足题意的区间，将其加入ans中
            if (interval_sum &lt;= threshold) {
                // 储存的区间是左闭右闭区间，故右边界应该为i+l-1
                ans.push_back(to_string(i) + "-" + to_string(i + l - 1));
            }
        }
        // 在考虑大小为l的区间之后，如果ans中有值
        // 则说明找到了最长的满足题意的区间，将ans合并后返回输出
        if (!ans.empty()) {
            string result;
            for (size_t i = 0; i &lt; ans.size(); ++i) {
                if (i &gt; 0) {
                    result += " ";
                }
                result += ans[i];
            }
            return result;
        }
    }

    // 如果退出循环后，没有返回任何的一个ans，则说明找不到任意一个区间满足题意
    // 此时应该返回"NULL"输出
    return "NULL";
}

int main() {
    int minAverageLost;
    // 输入
    cin &gt;&gt; minAverageLost;
    cin.ignore();  // 忽略换行符

    string line;
    getline(cin, line);
    stringstream ss(line);
    vector&lt;int&gt; nums;
    int num;

    while (ss &gt;&gt; num) {
        nums.push_back(num);
        if (ss.peek() == ',') {
            ss.ignore();
        }
    }

    // 调用函数并输出答案
    cout &lt;&lt; solve(minAverageLost, nums) &lt;&lt; endl;

    return 0;
}
</code></pre>
<h2 id="解法二固定滑窗">解法二：固定滑窗</h2>
<h3 id="python-1">Python</h3>
<pre><code class="language-Python"># 欢迎来到「欧弟算法 - 华为OD全攻略」,收录华为OD题库、面试指南、八股文与学员案例！
# 地址：https://www.odalgo.com



# 输入
minAverageLost = int(input())
nums = list(map(int, input().split()))

# 构建解决问题的函数
def solve(minAverageLost, nums):
    # 数据长度
    n = len(nums)
    # 构建答案数组
    ans = list()
    # 逆序遍历区间的长度l，
    # 贪心地优先考虑尽可能大的区间
    for l in range(n, 0, -1):
        # 计算阈值threshold，
        # 连续区间和必须小于这个阈值才可以
        threshold = minAverageLost * l
        # 初始化第一个窗口的窗口和
        interval_sum = sum(nums[:l])
        if interval_sum &lt;= threshold:
            ans.append(f"{0}-{l-1}")
        # 固定滑窗过程
        for right, num_right in enumerate(nums[l:], l):
            # A1
            interval_sum += num_right
            # A2
            interval_sum -= nums[right-l]
            # A3
            if interval_sum &lt;= threshold:
                # 储存的区间是左闭右闭区间，故左边界应该为right-l+1
                ans.append(f"{right-l+1}-{right}")
        if len(ans) &gt; 0:
            return " ".join(ans)

    # 如果退出循环后，没有返回任何的一个ans，则说明找不到任意一个区间满足题意
    # 此时应该返回"NULL"输出
    return "NULL"

# 调用函数并输出答案
print(solve(minAverageLost, nums))
</code></pre>
<h3 id="java-1">Java</h3>
<pre><code class="language-Java">import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // 输入
        int minAverageLost = scanner.nextInt();
        scanner.nextLine(); // 读取换行符
        String[] numStrs = scanner.nextLine().split(" ");
        int[] nums = new int[numStrs.length];
        for (int i = 0; i &lt; numStrs.length; i++) {
            nums[i] = Integer.parseInt(numStrs[i]);
        }

        // 调用函数并输出答案
        System.out.println(solve(minAverageLost, nums));
    }

    // 构建解决问题的函数
    public static String solve(int minAverageLost, int[] nums) {
        // 数据长度
        int n = nums.length;
        // 构建答案数组
        List&lt;String&gt; ans = new ArrayList&lt;&gt;();
        // 逆序遍历区间的长度l，
        // 贪心地优先考虑尽可能大的区间
        for (int l = n; l &gt; 0; l--) {
            // 计算阈值threshold，
            // 连续区间和必须小于这个阈值才可以
            int threshold = minAverageLost * l;
            // 初始化第一个窗口的窗口和
            int interval_sum = 0;
            for (int i = 0; i &lt; l; i++) {
                interval_sum += nums[i];
            }
            if (interval_sum &lt;= threshold) {
                ans.add("0-" + (l - 1));
            }
            // 固定滑窗过程
            for (int right = l; right &lt; n; right++) {
                // A1
                interval_sum += nums[right];
                // A2
                interval_sum -= nums[right - l];
                // A3
                if (interval_sum &lt;= threshold) {
                    // 储存的区间是左闭右闭区间，故左边界应该为right-l+1
                    ans.add((right - l + 1) + "-" + right);
                }
            }
            if (!ans.isEmpty()) {
                return String.join(" ", ans);
            }
        }

        // 如果退出循环后，没有返回任何的一个ans，则说明找不到任意一个区间满足题意
        // 此时应该返回"NULL"输出
        return "NULL";
    }
}
</code></pre>
<h3 id="c-1">C++</h3>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;

using namespace std;

string solve(int minAverageLost, const vector&lt;int&gt;&amp; nums) {
    // 数据长度
    int n = nums.size();
    // 构建答案数组
    vector&lt;string&gt; ans;
    // 逆序遍历区间的长度l，
    // 贪心地优先考虑尽可能大的区间
    for (int l = n; l &gt; 0; --l) {
        // 计算阈值threshold，
        // 连续区间和必须小于这个阈值才可以
        int threshold = minAverageLost * l;
        // 初始化第一个窗口的窗口和
        int interval_sum = 0;
        for (int i = 0; i &lt; l; ++i) {
            interval_sum += nums[i];
        }
        if (interval_sum &lt;= threshold) {
            ans.push_back(to_string(0) + "-" + to_string(l - 1));
        }
        // 固定滑窗过程
        for (int right = l; right &lt; n; ++right) {
            // A1
            interval_sum += nums[right];
            // A2
            interval_sum -= nums[right - l];
            // A3
            if (interval_sum &lt;= threshold) {
                // 储存的区间是左闭右闭区间，故左边界应该为right-l+1
                ans.push_back(to_string(right - l + 1) + "-" + to_string(right));
            }
        }
        if (!ans.empty()) {
            string result;
            for (size_t i = 0; i &lt; ans.size(); ++i) {
                if (i &gt; 0) {
                    result += " ";
                }
                result += ans[i];
            }
            return result;
        }
    }

    // 如果退出循环后，没有返回任何的一个ans，则说明找不到任意一个区间满足题意
    // 此时应该返回"NULL"输出
    return "NULL";
}

int main() {
    int minAverageLost;
    // 输入
    cin &gt;&gt; minAverageLost;
    cin.ignore();  // 忽略换行符

    string line;
    getline(cin, line);
    stringstream ss(line);
    vector&lt;int&gt; nums;
    int num;

    while (ss &gt;&gt; num) {
        nums.push_back(num);
        if (ss.peek() == ',') {
            ss.ignore();
        }
    }

    // 调用函数并输出答案
    cout &lt;&lt; solve(minAverageLost, nums) &lt;&lt; endl;

    return 0;
}
</code></pre>
<h2 id="时空复杂度">时空复杂度</h2>
<p>时间复杂度：<code>O(N^2)</code>。无论是固定滑窗还是前缀和算法，都需要进行双重循环。</p>
<p>空间复杂度：<code>O(1)</code>。仅需若干长度变量。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.016940091699074074" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-15 11:55">2025-04-15 11:54</span>&nbsp;
<a href="https://www.cnblogs.com/fivestudy">五分钟学算法</a>&nbsp;
阅读(<span id="post_view_count">2</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18826453);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18826453', targetLink: 'https://www.cnblogs.com/fivestudy/p/18826453', title: '华为od机考2025A卷真题 -查找接口成功率最优时间段' })">举报</a>
</div>
        