
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/caoruipeng/p/18831900" title="发布于 2025-04-18 10:07">
    <span role="heading" aria-level="2">理解.NET Core中的配置Configuration</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2>什么是配置</h2>
<p>.NET中的配置，本质上就是key-value键值对，并且key和value都是字符串类型。</p>
<p>在.NET中提供了多种配置提供程序来对不同的配置进行读取、写入、重载等操作，这里我们以为.NET 的源码项目为例，来看下.NET中的配置主要是有那些类库。下面这个截图是.NET 源码中和配置相关的所有类库，所有配置相关的类库都是都是以Microsoft.Extensions.Configuration开头的。</p>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202504/665785-20250417233558723-2125498217.png" height="181" width="410"></figure>
<p>貌似很多，没关系我们来简单理解一下。</p>
<figure class="table">
<table class="ck-table-resized"><colgroup><col><col></colgroup>
<thead>
<tr>
<th>类库名称</th>
<th>类库作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>1、Microsoft.Extensions.Configuration.Abstractions</td>
<td>定义配置相关的接口，其他所有配置类库都必须引用这个类库</td>
</tr>
<tr>
<td>2、Microsoft.Extensions.Configuration</td>
<td>Microsoft.Extensions.Configuration.Abstractions类库的简单实现</td>
</tr>
<tr>
<td>3、配置提供程序:Microsoft.Extensions.Configuration.CommandLine</td>
<td>基于命令行的配置提供程序，负责对命令行的配置进行读写、载入、重载等操作。</td>
</tr>
<tr>
<td>4、配置提供程序:Microsoft.Extensions.Configuration.EnvironmentVariables</td>
<td>基于环境变量的配置提供程序，负责对环境变量的配置进行读写、载入、重载等操作</td>
</tr>
<tr>
<td>5、配置提供程序：Microsoft.Extensions.Configuration.FileExtensions</td>
<td>基于的文件提供程序的基类库，文件提供程序包括基于Json文件、Ini文件、Xml文件或者自定义文件等。</td>
</tr>
<tr>
<td>6、配置提供程序：Microsoft.Extensions.Configuration.Json</td>
<td>基于Json文件的配置提供程序程序，负责从Json文本文件中对配置读写、载入、重载等操作。</td>
</tr>
<tr>
<td>7、配置提供程序：Microsoft.Extensions.Configuration.Ini</td>
<td>基于Ini文件的配置提供程序，负责从Ini文件中对配置进行读写、载入、重载等操作。</td>
</tr>
<tr>
<td>8、配置提供程序：Microsoft.Extensions.Configuration.UserSecrets</td>
<td>基于UserSecrets的配置提供程序，这个本质上也是一种基于Json文件类型的配置程序。主要用于管理应用机密</td>
</tr>
<tr>
<td>9、Microsoft.Extensions.Configuration.Binder</td>
<td>负责将key-value键值对的配置列表绑定到指定的C#实体类上，方便程序使用。</td>
</tr>
</tbody>
</table>
</figure>
<p>从上面可以看到，主要有四个类库：第1个类库<code>Abstractions</code>负责定义配置的一些接口，第2个类库<code>Configuration</code>负责定义配置的简单实现。第3到第8个类库都是具体的配置提供程序，第9个类库<code>Binder</code>负责将配置绑定到指定的的Model，方便程序使用。</p>
<p>配置提供程序，.NET中有多个类库提供程序，每个类库提供程序都是以单独的类库向外提供，基本上每个类库就是三个文件，分别是ConfigurationExtensions.cs、ConfigurationProvider.cs和ConfigurationSource.cs,这三个类分别表示配置的扩展方法、配置提供程序和配置源。配置源用于生成配置提供程序。</p>
<p>在第2个类库中，微软帮助我们实现了一个基于类库的配置提供程序，我们在列表中没有单独列举这个类库提供程序。</p>
<h2>配置源IConfigurationSource</h2>
<p>配置源表示一个单独的配置集合，可以表示来自内存的配置源、来自Json文件的配置源。但是配置源不直接提供对配置的访问操作，它只有一个接口<code>Build</code>，该接口一个具体的配置提供程序<code>IConfigurationProvider&nbsp;</code>，每个配置提供程序负责对配置的读取、写入、载入配置、重载配置等访问操作。</p>
<pre class="highlighter-hljs"><code>public interface IConfigurationSource
{
    IConfigurationProvider Build(IConfigurationBuilder builder);
}</code></pre>
<h2>配置提供程序IConfigurationProvider</h2>
<p>配置提供程序负责实现配置的设置、读取、重载等功能，并以键值对形式提供配置。</p>
<pre class="highlighter-hljs"><code>public interface IConfigurationProvider
{
	//读取配置
    bool TryGet(string key, out string? value);
    //修改配置
    void Set(string key, string? value);
    //获取重载配置的Token
    IChangeToken GetReloadToken();
    //载入配置
    void Load();
    //获取指定父路径下的直接子节点Key，然后 Concat(earlierKeys) 一同返回
    IEnumerable&lt;string&gt; GetChildKeys(IEnumerable&lt;string&gt; earlierKeys, string? parentPath);
}</code></pre>
<h2>配置构建者IConfigurationBuilder</h2>
<p>上面的IConfigurationSource和IConfigurationProvider分别表示一种数据源和对一种数据源进行读写操作。但是一个程序的配置可能来自很多地方，可能一部分配置来自环境变量、一部分配置来自文件等等。这个时候IConfigurationBuilder配置构建者就诞生了，IConfigurationBuilder接口维护了多个配置源，并提供一个Build方法生成一个统一的配置<code>IConfigurationRoot&nbsp;</code>来统一对整个程序的配置进行读取、写入、重载等操作。但是这里大家注意，<code>IConfigurationRoot&nbsp;</code>对配置的访问，本质上还是通过配置提供程序<code>IConfigurationProvider</code>来进行的。</p>
<p>假设，当我们查找一个Key为Name的配置，<code>IConfigurationRoot&nbsp;</code>内部会遍历所有<code>Sources&nbsp;</code>属性生成的<code>IConfigurationProvider</code>，然后依次调用<code>IConfigurationProvider</code>的TryGet来获取Name的具体配置数据。</p>
<pre class="highlighter-hljs"><code>public interface IConfigurationBuilder
{
	//保存Build的一些公开的字典属性，有需要的化可以使用该字段存放一些变量
    IDictionary&lt;string, object&gt; Properties { get; }
    //来自多个地方的配置源集合
    IList&lt;IConfigurationSource&gt; Sources { get; }
    //向Sources属性中添加一个配置源
    IConfigurationBuilder Add(IConfigurationSource source);
    //基于所有配置源生成一个全局的配置，供程序读写，一般我们都是用这个接口对配置进行读写。
    IConfigurationRoot Build();
}</code></pre>
<h2>配置构建者实现类ConfigurationBuilder</h2>
<p>在具体的配置构建者的Build方法中，我们可以看到，它依次调用<code>IConfigurationProvider</code>的Buid方法生成多个配置提供程序<code>IConfigurationProvider&nbsp;</code>，然后将所有的配置提供程序<code>providers&nbsp;</code>传给了<code>ConfigurationRoot</code>。<code>ConfigurationRoot</code>正是调用<code>providers&nbsp;</code>的一系列方法实现对配置的读取、写入、重载等操作。</p>
<pre class="highlighter-hljs"><code> public class ConfigurationBuilder : IConfigurationBuilder
 {
     private readonly List&lt;IConfigurationSource&gt; _sources = new();
     public IList&lt;IConfigurationSource&gt; Sources =&gt; _sources;
     public IDictionary&lt;string, object&gt; Properties { get; } = new Dictionary&lt;string, object&gt;();
     public IConfigurationBuilder Add(IConfigurationSource source)
     {
         ThrowHelper.ThrowIfNull(source);
         _sources.Add(source);
         return this;
     }
     public IConfigurationRoot Build()
     {
         var providers = new List&lt;IConfigurationProvider&gt;();
         foreach (IConfigurationSource source in _sources)
         {
             IConfigurationProvider provider = source.Build(this);
             providers.Add(provider);
         }
         return new ConfigurationRoot(providers);
     }
 }</code></pre>
<h2>配置接口IConfiguration</h2>
<p>这个接口就是最核心的配置接口，提供了对配置的读取、写入、重载等操作，它的实现类是<code>ConfigurationRoot</code>，上面我们已经介绍过，<code>IConfiguration</code>本身还是通过各个配置提供程序对配置进行访问操作。</p>
<pre class="highlighter-hljs"><code>public interface IConfiguration
{
	//获取或设置配置
    string? this[string key] { get; set; }
	//获取指定key的配置子节点
    IConfigurationSection GetSection(string key);
	//获取当前配置的直接子节点列表
    IEnumerable&lt;IConfigurationSection&gt; GetChildren();
    
    //当配置发生变更时的token
    IChangeToken GetReloadToken();
}</code></pre>
<h2>配置接口IConfigurationRoot</h2>
<p>IConfigurationRoot其实是配置的根接口，该接口有个最重要的属性<code>Providers&nbsp;</code>负责保存所有的配置提供程序，<code>IConfiguration</code>对配置的访问，就是通过遍历这个<code>Providers</code>来访问的。</p>
<pre class="highlighter-hljs"><code>public interface IConfigurationRoot : IConfiguration
{
	//强制重载所有配置
    void Reload();
    //所有配置提供程序
    IEnumerable&lt;IConfigurationProvider&gt; Providers { get; }
}</code></pre>
<h2>实现自定义配置提供程序</h2>
<p>实现自定义配置提供程序，其实只需要实现三个类就可以，一个是配置源、一个是配置提供程序、一个是针对当前配置的扩展方法。第三个类可有可无，不过我们一般都要实现。我们来参考下基于命令行的配置提供程序类库的文件。</p>
<figure class="image"><img src="https://img2024.cnblogs.com/blog/665785/202504/665785-20250417233558762-715358399.png" height="156" width="434"></figure>
<p>接下来，我们来实现一个基于数据库的配置提供程序，分别实现配置源<code>DataBaseConfigurationSource&nbsp;</code>、配置提供程序<code>DataBaseConfigurationExtensions&nbsp;</code>和扩展方法类<code>DataBaseConfigurationExtensions</code>，当然在这里我们只做对应的演示，没有实现具体的配置方法。</p>
<pre class="highlighter-hljs"><code>public class DataBaseConfigurationSource : IConfigurationSource
{
    public IConfigurationProvider Build(IConfigurationBuilder builder)
    {
        return new DataBaseConfigurationProvider();
    }
}

public class DataBaseConfigurationProvider : ConfigurationProvider
{
    public override void Load()
    {
        base.Load();
        //读取数据库配置
    }
}
public static class DataBaseConfigurationExtensions
{
    public static IConfigurationBuilder AddDb(this IConfigurationBuilder configurationBuilder)
    {
        configurationBuilder.Sources.Add(new DataBaseConfigurationSource());
        return configurationBuilder;
    }
}</code></pre>
<h2>调用自定义配置程序</h2>
<pre class="highlighter-hljs"><code>static void Main(string[] args)
{
    var builder = new ConfigurationBuilder()
        .AddDb()
        .Build();
    var value = builder["key"];
}</code></pre>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.0331684354675925" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-18 10:08">2025-04-18 10:07</span>&nbsp;
<a href="https://www.cnblogs.com/caoruipeng">caoruipeng</a>&nbsp;
阅读(<span id="post_view_count">296</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18831900);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18831900', targetLink: 'https://www.cnblogs.com/caoruipeng/p/18831900', title: '理解.NET Core中的配置Configuration' })">举报</a>
</div>
        