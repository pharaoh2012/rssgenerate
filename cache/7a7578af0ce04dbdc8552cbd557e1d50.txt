
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chaoguo1234/p/18800600" title="发布于 2025-03-30 14:35">
    <span role="heading" aria-level="2">WebKit Inside: 渲染树</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        iOS WebKit 渲染树的构建过程
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>经过<code>CSS</code>的匹配，就要进入渲染树的构建。</p>
<p>渲染树也叫<code>RenderObject</code>树，因为渲染树上每一个节点，都是<code>RenderObject</code>的子类。</p>
<p>首先来看一下<code>RenderObject</code>的继承类图。</p>
<h1 id="1-renderobject-继承类图">1 RenderObject 继承类图</h1>
<p><img src="https://img2024.cnblogs.com/blog/489427/202503/489427-20250330142844226-1637450101.png" alt="image" loading="lazy"></p>
<p><code>RenderText</code>表示要渲染的文本。</p>
<p><code>RenderButton</code>表示要渲染的按钮。</p>
<p><code>RenderBlockFlow</code>表示要渲染的块级元素，比如<code>&lt;div&gt;</code>。</p>
<p><code>RenderView</code>表示浏览器<code>window</code>中显示的视口(<code>viewport</code>)。</p>
<p><code>RenderVideo</code>表示要渲染的视频。</p>
<p><code>RenderImage</code>表示要渲染的图片。</p>
<p><code>RenderInline</code>表示要渲染的内联元素，比如<code>&lt;span&gt;</code>。</p>
<h1 id="2-渲染树构建时机">2 渲染树构建时机</h1>
<p>渲染树的构建时机在<code>CSS</code>匹配完成之后:</p>
<pre><code class="language-c++">void Document::resolveStyle(ResolveStyleType type)
{
   ...
   {
      // 1. CSS 匹配
      Style::TreeResolver resolver(*this, WTFMove(m_pendingRenderTreeUpdate));
      auto styleUpdate = resolver.resolve();

      ...

      if (styleUpdate) {
            // 2. 渲染树构建
            updateRenderTree(WTFMove(styleUpdate));
            ...
      }
   }

   ...
}
</code></pre>
<p>代码注释<code>1</code>，<code>CSS</code>进行匹配。</p>
<p>代码注释<code>2</code>，渲染树开始构建。</p>
<p>调用栈如下图所示:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202503/489427-20250330142927379-497068837.png" alt="image" loading="lazy"></p>
<h1 id="3-渲染树构建过程">3 渲染树构建过程</h1>
<h2 id="31-相关类图">3.1 相关类图</h2>
<p><img src="https://img2024.cnblogs.com/blog/489427/202503/489427-20250330143007841-171641854.png" alt="image" loading="lazy"></p>
<p><code>Document</code>代表文档对象，从继承图上看，其继承自<code>ContainerNode</code>。</p>
<p><code>Element</code>代表<code>DOM</code>树节点对象，从继承图上看，其继承自<code>ContainerNode</code>。</p>
<p><code>StyleUpdate</code>存储所有<code>DOM</code>节点匹配的<code>CSS</code>样式。</p>
<p><code>RenderStyle</code>存储单个<code>DOM</code>节点匹配的<code>CSS</code>样式。</p>
<p><code>RenderTreeUpdater</code>负责整个渲染树的构建过程。</p>
<p><code>RenderTreeBuilder</code>负责将渲染树节点添加到渲染树上，它持有<code>RenderView</code>，<code>RenderView</code>是渲染树的根节点。</p>
<p><code>RenderTreeBuilder</code>内部持有不同渲染树节点类型的构建器，比如块级渲染树节点构建器<code>RnederTreeBuilder::BlockFlow</code>。</p>
<h2 id="32-创建-rendertreeupdater">3.2 创建 RenderTreeUpdater</h2>
<p>渲染树的构建入口函数为<code>Document::updateRnederTree</code>。</p>
<p>在这个函数内部，创建了<code>RenderTreeUpdater</code>对象:</p>
<pre><code class="language-c++">void Document::updateRenderTree(std::unique_ptr&lt;Style::Update&gt; styleUpdate)
{
    ...
    {
      ...
        {
            // 1. 创建 RenderTreeUpdater
            RenderTreeUpdater updater(*this, callbackDisabler);
            // 2. 调用 commit 方法，继续渲染树构建
            updater.commit(WTFMove(styleUpdate));
        }
    }
}
</code></pre>
<p>代码注释<code>1</code>，创建<code>RenderTreeUpdater</code>对象。</p>
<p>代码注释<code>2</code>，继续渲染树的构建。</p>
<h2 id="33-遍历-dom-树前的准备">3.3 遍历 DOM 树前的准备</h2>
<p>为了进行渲染树的构建，需要找到<code>renderingRoot</code>，对其进行遍历。</p>
<p>通常情况下，<code>renderingRoot</code>就是<code>Document</code>对象。</p>
<pre><code class="language-c++">void RenderTreeUpdater::commit(std::unique_ptr&lt;Style::Update&gt; styleUpdate)
{
   ...
   // 1. 存储 CSS 匹配结果
   m_styleUpdate = WTFMove(styleUpdate);
   ...

   // 2. 遍历所有的 root 节点
   for (auto&amp; root : m_styleUpdate-&gt;roots()) {
      if (&amp;root-&gt;document() != m_document.ptr())
         continue;
      // 3. 找到 renderingRoot
      auto* renderingRoot = findRenderingRoot(*root);
      if (!renderingRoot)
         continue;
      // 4. 遍历 renderingRoot，构造渲染树
      updateRenderTree(*renderingRoot);
   }

   ...
}
</code></pre>
<p>代码注释<code>1</code>，存储<code>CSS</code>匹配结果。</p>
<p>代码注释<code>2</code>，遍历<code>StyleUpdate</code>对象中的<code>roots</code>数组。</p>
<p>从下文可以知道，正常情况下，<code>roots</code>数组里只有<code>Document</code>对象。</p>
<p>代码注释<code>3</code>，判断当前的<code>root</code>节点是否是一个合格的<code>renderingRoot</code>。</p>
<p>代码注释<code>4</code>，遍历找到的<code>renderingRoot</code>，也就是<code>Document</code>对象。</p>
<h3 id="331-styleupdate-的-root-数组">3.3.1 StyleUpdate 的 root 数组</h3>
<p>那么<code>StyleUpdate</code>对象中的<code>roots</code>数组中存储的是什么呢？</p>
<p>在<code>CSS</code>匹配的过程中，当匹配完一个<code>DOM</code>节点的<code>CSS</code>样式后，会将<code>CSS</code>样式与这个<code>DOM</code>节点进行关联:</p>
<pre><code class="language-c++">void TreeResolver::resolveComposedTree()
{
    ...
    while (it != end) {
        ...
        if (resolutionType) {
            ...
            // 1. 匹配当前 DOM 节点 element 的样式
            auto [elementUpdate, elementDescendantsToResolve] = resolveElement(element, style, *resolutionType);
            ...
            // 2. style 为当前 DOM 节点 element 匹配的样式
            style = elementUpdate.style.get();
            ...

            if (style || element.hasDisplayNone())
               // 3. 样式匹配成功，将匹配的样式与当前的 DOM 节点相关联
                m_update-&gt;addElement(element, parent.element, WTFMove(elementUpdate));
            ...
        }
        ...
        it.traverseNext();
    }

    popParentsToDepth(1);
}

void Update::addElement(Element&amp; element, Element* parent, ElementUpdate&amp;&amp; elementUpdate)
{
    ...
    // 4. 向 StyleUpdate 对象中的 m_roots 数组添加对象
    addPossibleRoot(parent);
    ...
    // 5. 关联当前 DOM 节点与其匹配的样式
    m_elements.add(&amp;element, WTFMove(elementUpdate));
}

void Update::addPossibleRoot(Element* element)
{
    if (!element) {
       // 6. 当匹配 HTML 节点时，element = nil，Document 对象增加到 m_roots 数组中
        m_roots.add(m_document.ptr());
        return;
    }
    if (element-&gt;needsSVGRendererUpdate() || m_elements.contains(element))
        // 7. 正常情况下，由于满足 m_elements.contains(element) 条件，直接返回，m_roots 里始终只有 Document 对象
        return;
    m_roots.add(element);
}
</code></pre>
<p>代码注释<code>1</code>，匹配当前<code>DOM</code>节点的<code>CSS</code>样式。</p>
<p>代码注释<code>2</code>，<code>style</code>为当前<code>DOM</code>节点匹配成功的<code>CSS</code>样式。</p>
<p>代码注释<code>3</code>，样式匹配成功，将样式与当前的<code>DOM</code>节点相关联。</p>
<p>也就是，将当前<code>DOM</code>节点与匹配的样式，存储到<code>StyleUpdate</code>的<code>m_elements</code> <code>Map</code>中。</p>
<p>代码注释<code>4</code>，将当前<code>DOM</code>节点的父节点，添加到<code>StyleUpdate</code>对象的<code>m_roots</code>数组中(前提是要满足对应的条件)。</p>
<p>代码注释<code>5</code>，将关联当前<code>DOM</code>节点与匹配的样式。</p>
<p>代码注释<code>6</code>，当匹配<code>HTML</code>节点时，它的父节点是<code>null</code>，因此会运行到这里，此时<code>m_roots</code>数组会存储<code>Document</code>对象。</p>
<p>代码注释<code>7</code>，正常情况下，由于会满足<code>m_elements.contains</code>条件，会直接返回。</p>
<p>比如，当匹配<code>BODY</code>节点时，其父节点<code>HMTL</code>已经存储在<code>StyleUpdate</code>的<code>m_elements</code> <code>Map</code>中，因此会直接返回。</p>
<p>所以，正常情况下，<code>StyleUpdate</code>的<code>m_roots</code>数组，只会有<code>Document</code>对象。</p>
<h3 id="332-确认-renderingroot">3.3.2 确认 renderingRoot</h3>
<p>从上文可以知道，<code>StyleUpdate</code>的<code>roots</code>数组中，正常情况下，只有<code>Document</code>对象。</p>
<p>因此，这里的<code>node</code>参数就是<code>Document</code>对象。</p>
<pre><code class="language-c++">static ContainerNode* findRenderingRoot(ContainerNode&amp; node)
{
    if (node.renderer())
        // 1. Document 节点的 renderer() 方法返回 RenderView
        return &amp;node;
    return findRenderingAncestor(node);
}
</code></pre>
<p>代码注释<code>1</code>，判断当前<code>node</code>是否有关联的<code>RenderObject</code>对象。</p>
<p><code>Document</code>对象关联的<code>RenderObject</code>就是<code>RenderView</code>，因此这里直接返回。</p>
<h2 id="34-遍历-dom-树">3.4 遍历 DOM 树</h2>
<p>渲染树是根据<code>DOM</code>树渲染创建出来的。</p>
<p>为了创建渲染树，需要遍历<code>DOM</code>树.</p>
<p>遍历<code>DOM</code>树的过程与<a href="https://www.cnblogs.com/chaoguo1234/p/18778101" target="_blank">《WebKit Inside: CSS 的匹配原理》</a>中类似，本次只关心渲染树构建的过程。</p>
<pre><code class="language-c++">void RenderTreeUpdater::updateRenderTree(ContainerNode&amp; root)
{
    ASSERT(root.renderer());
    ASSERT(m_parentStack.isEmpty());

    m_parentStack.append(Parent(root));

    auto descendants = composedTreeDescendants(root);
    auto it = descendants.begin();
    auto end = descendants.end();

    // FIXME: https://bugs.webkit.org/show_bug.cgi?id=156172
    it.dropAssertions();

    // 1. 遍历 DOM 树
    while (it != end) {
      popParentsToDepth(it.depth());
      auto&amp; node = *it;
      ...
      auto&amp; element = downcast&lt;Element&gt;(node);
      ...
      auto* elementUpdate = m_styleUpdate-&gt;elementUpdate(element);
      ...

      // 2. 只有匹配到 CSS 样式的 DOM 节点，才有对应的渲染树节点
      if (elementUpdate)
         // 3. 创建当前 DOM 节点对应的渲染树节点
         updateElementRenderer(element, *elementUpdate);
         ...
      pushParent(element, elementUpdate);
      it.traverseNext();
    }

    popParentsToDepth(0);
}
</code></pre>
<p>代码注释<code>1</code>，遍历<code>DOM</code>树。</p>
<p>代码注释<code>2</code>，<code>elementUpdate</code>中存储着当前节点匹配成功的<code>CSS</code>样式，这里只有成功匹配的<code>DOM</code>节点，才能创建对应的渲染树节点。</p>
<p>因此，那些没有样式的<code>HTML</code>节点，比如<code>HEAD</code>，是不会出现在渲染树中的。</p>
<p>代码注释<code>3</code>，创建当前<code>DOM</code>节点对应的渲染树节点。</p>
<h3 id="341-rendertreeupdaterparent">3.4.1 RenderTreeUpdater::Parent</h3>
<p>上面代码中，注意到<code>m_parentStack</code>的代码:</p>
<pre><code class="language-c++">void RenderTreeUpdater::updateRenderTree(ContainerNode&amp; root)
{
   ...
   // 1. 将 root 节点，也就是 Document 添加到 m_parentStack
   m_parentStack.append(Parent(root));
   ...
   while (it != end) 
   {
      ...
      // 2. 将已经创建渲染树节点的 DOM 节点，添加到 m_parentStack
      pushParent(element, elementUpdate);
      it.traverseNext();
   }
}
</code></pre>
<p>代码注释<code>1</code>，<code>m_parentStack</code>中加入的<code>Parent</code>对象，并不是<a href="https://www.cnblogs.com/chaoguo1234/p/18778101" target="_blank">《WebKit Inside: CSS 的匹配原理》</a>中的<code>Style::TreeResolver::Parent</code>，而是<code>RenderTreeUpdater::Parent</code>。</p>
<p>与<code>RenderTreeUpdater::Parent</code>相关的类图如下:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202503/489427-20250330143205083-830678619.png" alt="image" loading="lazy"></p>
<p>代码注释<code>2</code>，当前<code>DOM</code>节点已经创建好了渲染树节点，将当前<code>DOM</code>节点以及其匹配的样式，添加到<code>m_parentStack</code>中。</p>
<p>下图给出了一个遍历<code>DOM</code>树时，<code>m_parentStack</code>变化的例子:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202503/489427-20250330143326634-2089883230.png" alt="image" loading="lazy"></p>
<h2 id="35-创建渲染树节点">3.5 创建渲染树节点</h2>
<pre><code class="language-c++">void RenderTreeUpdater::updateElementRenderer(Element&amp; element, const Style::ElementUpdate&amp; elementUpdate)
{
   if (!elementUpdate.style)
      // 1. 没有匹配 CSS 样式的 DOM 节点不会创建对应的渲染树节点
      return;
   ...

   // 2. 如果当前 DOM 节点 display 属性为 none，也不会创建渲染树节点
   bool shouldCreateNewRenderer = !element.renderer() &amp;&amp; !hasDisplayContentsOrNone &amp;&amp; !(element.isInTopLayer() &amp;&amp; renderTreePosition().parent().style().hasSkippedContent());
   if (shouldCreateNewRenderer) {
      ...
      // 3. 创建当前 DOM 节点的渲染树节点
      createRenderer(element, WTFMove(elementUpdateStyle));
      ...
      return;
   }
   ...
}
</code></pre>
<p>代码注释<code>1</code>，判断当前<code>DOM</code>节点有没有匹配<code>CSS</code>样式。</p>
<p>没有匹配<code>CSS</code>样式的<code>DOM</code>节点不会创建对应的渲染树节点。</p>
<p>代码注释<code>2</code>，判断当前<code>DOM</code>节点是否可见。</p>
<p>如果当前<code>DOM</code>节点的<code>display</code>属性值为<code>none</code>，那么也不会创建对应的渲染树节点。</p>
<p>代码注释<code>3</code>，为当前的<code>DOM</code>节点创建对应的渲染树节点，并添加到渲染树上。</p>
<h3 id="351-渲染树节点">3.5.1 渲染树节点</h3>
<p>上面代码注释<code>3</code>处的函数真正的创建渲染树节点，代码如下:</p>
<pre><code class="language-c++">void RenderTreeUpdater::createRenderer(Element&amp; element, RenderStyle&amp;&amp; style)
{
   ...
   // 1. 获取当前创建的渲染树节点，要插入的位置
   RenderTreePosition insertionPosition = computeInsertionPosition();
   // 2. 创建当前 DOM 节点的渲染树节点
   auto newRenderer = element.createElementRenderer(WTFMove(style), insertionPosition);
   if (!newRenderer)
      return;

   if (!insertionPosition.parent().isChildAllowed(*newRenderer, newRenderer-&gt;style()))
      return;
   ...
   // 3. 将创建的渲染树节点，与对应的 DOM 节点关联
   element.setRenderer(newRenderer.get());
   ...
   // 4. 将创建的渲染树节点，添加到渲染树上
   m_builder.attach(insertionPosition.parent(), WTFMove(newRenderer), insertionPosition.nextSibling());
   ...
}
</code></pre>
<p>代码注释<code>1</code>，获取当前要创建的渲染树节点，其插入的位置。</p>
<p><code>RenderTreePosition</code>前面介绍过，它持有当前<code>DOM</code>节点的父节点，以及父渲染树节点。</p>
<p>代码注释<code>2</code>，创建当前<code>DOM</code>节点的渲染树节点。</p>
<p>不同的<code>DOM</code>树节点，会覆写<code>createElementRender</code>方法，从而创建不同的渲染树节点。</p>
<p>比如，<code>&lt;img&gt;</code>节点会创建<code>RenderImage</code>类型的渲染树节点。</p>
<p>比如，<code>&lt;div&gt;</code>这种块级标签，会创建<code>RenderBlockFlow</code>类型的渲染树节点。</p>
<p>创建好的渲染树节点，与其对应的<code>DOM</code>节点以及匹配的<code>CSS</code>样式关系如下:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202503/489427-20250330143255444-1088858969.png" alt="image" loading="lazy"></p>
<p>代码注释<code>3</code>，将当前<code>DOM</code>节点与创建好的渲染树节点相关联。</p>
<p>这样，<code>DOM</code>节点与渲染树节点，可以相互引用了。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202503/489427-20250330143306788-2112813257.png" alt="image" loading="lazy"></p>
<h2 id="36-添加渲染树节点">3.6 添加渲染树节点</h2>
<p>上面代码注释<code>4</code>，将新创建的渲染树节点，添加到渲染树上。</p>
<p><code>RenderTreeBuilder::attach</code>方法接收<code>3</code>个参数:<br>
第<code>1</code>个参数，是当前要添加渲染树节点的父渲染树节点。</p>
<p>第<code>2</code>个参数，是要添加的渲染树节点。</p>
<p>第<code>3</code>个参数，与<code>HTML</code>伪元素有关，正常情况下为<code>null</code>。</p>
<p><code>RenderTreeBuilder::attach</code>方法会调用到<code>RenderTreeBuilder::attachInternal</code>方法。</p>
<p>在<code>RenderTreeBuilder::attachInternal</code>方法中，会根据当前渲染树节点的父渲染树节点类型，调用具体的<code>Builder</code>:</p>
<pre><code class="language-c++">void RenderTreeBuilder::attachInternal(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
{
    ...
    // 1. 如果父渲染树节点是 RenderBlockFlow，也就是块级元素，那么调用块级元素的 builder
    if (auto* parentBlockFlow = dynamicDowncast&lt;RenderBlockFlow&gt;(parent)) {
        blockFlowBuilder().attach(*parentBlockFlow, WTFMove(child), beforeChild);
        return;
    }
   ...
}
</code></pre>
<p>代码注释<code>1</code>，给出了块级父渲染树节点类型的例子。</p>
<p>如果父渲染树节点是<code>RenderBlockFlow</code>类型，也就是块级元素，那么就调用块级元素的<code>Builder</code>。</p>
<p>在具体的<code>Builder</code>内部，会有一些额外的操作，但是最终的添加过程，还是会调用到<code>RenderTreeBuilder</code>中:</p>
<pre><code class="language-c++">void RenderTreeBuilder::attachToRenderElementInternal(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
{
   ...
   // Take the ownership.
   // 1. 将 child 渲染树节点，添加到 parent 渲染树节点下面
   auto* newChild = parent.attachRendererInternal(WTFMove(child), beforeChild);
   ...
}
</code></pre>
<p>代码注释<code>1</code>，将<code>child</code>渲染树节点，添加到<code>parent</code>渲染树节点下面。</p>
<p>需要注意的是，参数<code>bedoreChild</code>和<code>HTML</code>伪元素有关，正常情况下为<code>null</code>。</p>
<p>添加的主要过程代码为:</p>
<pre><code class="language-c++">RenderObject* RenderElement::attachRendererInternal(RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
{
    child-&gt;setParent(this);
    ...
    ...
    {
        CheckedPtr lastChild = m_lastChild.get();
        if (lastChild)
            lastChild-&gt;setNextSibling(child.get());
        child-&gt;setPreviousSibling(lastChild.get());
    }
    m_lastChild = child.get();
    return child.release();
}
</code></pre>
<p>如果之前看过<a href="https://www.cnblogs.com/chaoguo1234/p/15811950.html" target="_blank">《WebKit Inside: DOM 树的构建》</a>，会发现渲染树在内存中的结构，和<code>DOM</code>树类似:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202503/489427-20250330143400531-1920989382.png" alt="image" loading="lazy"></p>
<p>但是习惯上，常常会将渲染树画成下面的逻辑结构，这样更方便:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202503/489427-20250330143433558-341592820.png" alt="image" loading="lazy"></p>
<h1 id="4-renderview-根节点">4 RenderView 根节点</h1>
<p>上面提到<code>RenderView</code>是渲染树的根节点。</p>
<p>那根节点<code>RenderView</code>是什么时候创建的呢？</p>
<p>答案就是，创建<code>Document</code>对象时，会将<code>RenderView</code>创建出来:</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202503/489427-20250330143454940-1220621263.png" alt="image" loading="lazy"></p>
<h1 id="5-dom-树与渲染树">5 DOM 树与渲染树</h1>
<p>从前面的介绍可以知道，渲染树是遍历<code>DOM</code>树创建出来的。</p>
<p>但是，并不是每一个<code>DOM</code>树上的节点，在渲染树上都有对应的节点。</p>
<p>如果<code>DOM</code>树上的节点，不会显示在屏幕上，那么，渲染树上就不会有相应的节点。</p>
<p>不显示在屏幕上包括:<br>
<code>1</code> 该节点不会有对应的<code>CSS</code>样式，不如<code>HEAD</code>节点。</p>
<p><code>2</code> 即使有<code>CSS</code>样式，但是<code>display</code>属性值为<code>none</code>，也不会在渲染树上。</p>
<p><img src="https://img2024.cnblogs.com/blog/489427/202503/489427-20250330143507809-513070993.png" alt="image" loading="lazy"></p>
<p>上面图中，<code>&lt;head&gt;</code>节点由于不会显示在屏幕上，没有出现在渲染树上。</p>
<p><code>&lt;h2&gt;</code>节点因为<code>display</code>属性值为<code>none</code>，不会出现在屏幕上，因此也没有出现在渲染树上。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.40422555353935186" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-30 14:36">2025-03-30 14:35</span>&nbsp;
<a href="https://www.cnblogs.com/chaoguo1234">chaoguo1234</a>&nbsp;
阅读(<span id="post_view_count">12</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18800600" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18800600);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18800600', targetLink: 'https://www.cnblogs.com/chaoguo1234/p/18800600', title: 'WebKit Inside: 渲染树' })">举报</a>
</div>
        