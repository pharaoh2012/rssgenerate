
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dawnkylin/p/18723992" title="发布于 2025-02-19 14:10">
    <span role="heading" aria-level="2">JavaScript RegExp 正则表达式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="regexp">RegExp</h1>
<p>RegExp 类型的字面量写法：</p>
<pre><code>let expression = /pattern/flags;
</code></pre>
<p>这个正则表达式的 pattern（模式）可以是任何简单或复杂的正则表达式。</p>
<h2 id="正则表达式的标记">正则表达式的标记</h2>
<p>每个正则表达式可以带零个或多个 flags（标记），用于控制正则表达式的行为。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>标记</td>
<td>功能</td>
<td>示例及解释</td>
</tr>
<tr>
<td><code>g</code></td>
<td>全局匹配：查找所有匹配，而非找到第一个就停止。</td>
<td><code>console.log("abcabc".match(/a/g)); // 输出：["a", "a"]</code></td>
</tr>
<tr>
<td><code>i</code></td>
<td>忽略大小写：匹配时不区分大小写。</td>
<td><code>console.log("Abc".match(/a/i)); // 输出：["A"]</code></td>
</tr>
<tr>
<td><code>m</code></td>
<td>多行模式：<code>^</code>和`</td>
<td></td>
</tr>
<tr>
<td>---</td>
<td>---------------------------------</td>
<td>----------------------------------------------------------------------</td>
</tr>
<tr>
<td>标记</td>
<td>功能</td>
<td>示例及解释</td>
</tr>
<tr>
<td><code>g</code></td>
<td>全局匹配：查找所有匹配，而非找到第一个就停止。</td>
<td><code>console.log("abcabc".match(/a/g)); // 输出：["a", "a"]</code></td>
</tr>
<tr>
<td><code>i</code></td>
<td>忽略大小写：匹配时不区分大小写。</td>
<td><code>console.log("Abc".match(/a/i)); // 输出：["A"]</code></td>
</tr>
<tr>
<td>匹配每一行的开头和结尾。</td>
<td><code>console.log("a\nb".match(/^b/m)); // 输出：["b"]</code></td>
<td></td>
</tr>
<tr>
<td><code>s</code></td>
<td>单行模式（dotAll 模式）：<code>.</code>  <br>匹配包括换行符。</td>
<td><code>console.log("a\nb".match(/a.b/s)); // 输出：["a\nb"]</code></td>
</tr>
<tr>
<td><code>u</code></td>
<td>Unicode 模式：支持 Unicode 的完整字符匹配。</td>
<td><code>console.log("\u{1F600}".match(/\u{1F600}/u)); // 输出：["😀"]</code></td>
</tr>
<tr>
<td><code>y</code></td>
<td>粘性匹配：从当前位置开始匹配，且不回溯。</td>
<td><code>let re = /a/y; re.lastIndex = 1; console.log(re.test("ba")); // true</code></td>
</tr>
<tr>
<td><code>d</code></td>
<td>匹配索引：返回匹配项在字符串中的索引（ES2022）。</td>
<td><code>console.log("abcabc".matchAll(/a/d)); // { index: 0 }, { index: 3 }</code></td>
</tr>
</tbody>
</table>
<h2 id="正则表达式的元字符">正则表达式的元字符</h2>
<h3 id="1字符匹配元字符">1.字符匹配元字符</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>元字符</td>
<td>用途</td>
<td>示例</td>
</tr>
<tr>
<td><code>.</code></td>
<td>匹配任意单个字符（除换行符）。</td>
<td><code>/a.b/</code>匹配 <code>"acb"</code>, <code>"a1b"</code>，但不匹配 <code>"ab"</code>, <code>"a\nb"</code>。</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配任意数字（相当于 <code>[0-9]</code>  <br>）。</td>
<td><code>/\d+/</code>匹配 <code>"12345"</code>中的 <code>"12345"</code>。</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配非数字字符（相当于 <code>[^0-9]</code>）。</td>
<td><code>/\D+/</code>匹配 <code>"abc"</code>，但不匹配 <code>"123"</code>。</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配单词字符（字母、数字、下划线）。</td>
<td><code>/\w+/</code>匹配 <code>"hello_123"</code>。</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配非单词字符。</td>
<td><code>/\W+/</code>匹配 <code>"@!#"</code>。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配空白字符（空格、制表符等）。</td>
<td><code>/\s+/</code>匹配字符串中的空格。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配非空白字符。</td>
<td><code>/\S+/</code>匹配 <code>"abc"</code>，但不匹配 <code>" "</code>。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配单词边界。</td>
<td><code>/\bcat\b/</code>匹配 <code>"cat"</code>，但不匹配 <code>"catalog"</code>或 <code>"scatter"</code>。</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>匹配非单词边界。</td>
<td><code>/\Bcat\B/</code>匹配 <code>"scattering"</code>中的 <code>"cat"</code>。</td>
</tr>
</tbody>
</table>
<h3 id="2定位元字符">2.定位元字符</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>元字符</strong></td>
<td><strong>用途</strong></td>
<td><strong>示例</strong></td>
</tr>
<tr>
<td><code>^</code></td>
<td>匹配字符串开头。</td>
<td><code>/^abc/</code>匹配 <code>"abc123"</code>的开头 <code>"abc"</code>，但不匹配 <code>"123abc"</code>。</td>
</tr>
<tr>
<td>`</td>
<td></td>
<td></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td><strong>元字符</strong></td>
<td><strong>用途</strong></td>
<td><strong>示例</strong></td>
</tr>
<tr>
<td><code>^</code></td>
<td>匹配字符串开头。</td>
<td><code>/^abc/</code>匹配 <code>"abc123"</code>的开头 <code>"abc"</code>，但不匹配 <code>"123abc"</code>。</td>
</tr>
<tr>
<td>|匹配字符串结尾。|<code>/abc$/</code>匹配 <code>"123abc"</code>的结尾 <code>"abc"</code>，但不匹配 <code>"abc123"</code>。</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="3重复元字符">3.重复元字符</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>元字符</strong></td>
<td><strong>用途</strong></td>
<td><strong>示例</strong></td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配前一个字符 0 次或多次。</td>
<td><code>/a*/</code>匹配 <code>"aaa"</code>, <code>"b"</code>  <br>, <code>"ab"</code>中的 <code>"aaa"</code>, <code>""</code>, <code>"a"</code>。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配前一个字符 1 次或多次。</td>
<td><code>/a+/</code>匹配 <code>"aaa"</code>, <code>"ab"</code>中的<code>"aaa"</code>, <code>"a"</code>，但不匹配 <code>"b"</code>。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前一个字符 0 次或 1 次。</td>
<td><code>/a?b/</code>匹配 <code>"b"</code>, <code>"ab"</code>，但不匹配 <code>"aab"</code>。</td>
</tr>
<tr>
<td><code>{n}</code></td>
<td>匹配前一个字符 <strong>恰好 n 次</strong>。</td>
<td><code>/a{3}/</code>匹配 <code>"aaa"</code>，但不匹配 <code>"aa"</code>或 <code>"aaaa"</code>。</td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td>匹配前一个字符 <strong>至少 n 次</strong>。</td>
<td><code>/a{2,}/</code>匹配 <code>"aaa"</code>, <code>"aaaa"</code>，但不匹配 <code>"a"</code>。</td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td>匹配前一个字符 <strong>至少 n 次，至多 m 次</strong>。</td>
<td><code>/a{2,4}/</code>匹配 <code>"aa"</code>, <code>"aaa"</code>, <code>"aaaa"</code>，但不匹配 <code>"a"</code>或 <code>"aaaaa"</code>。</td>
</tr>
</tbody>
</table>
<h3 id="4分组和选择元字符">4.分组和选择元字符</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>元字符</strong></td>
<td><strong>用途</strong></td>
<td><strong>示例</strong></td>
</tr>
<tr>
<td><code>()</code></td>
<td>定义分组，用于捕获或控制优先级。</td>
<td><code>/(ab)+/</code>匹配 <code>"ababab"</code>中的 <code>"ababab"</code>；捕获 <code>"ab"</code>。</td>
</tr>
<tr>
<td><code>(?:)</code></td>
<td>定义非捕获分组，仅用于逻辑分组。</td>
<td><code>/(?:ab)+/</code>匹配 <code>"ababab"</code>中的 <code>"ababab"</code>，但不捕获 <code>"ab"</code>。</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td>逻辑或，匹配任意一个模式。</td>
</tr>
</tbody>
</table>
<h3 id="5特殊元字符转义">5.特殊元字符转义</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>元字符</strong></td>
<td><strong>用途</strong></td>
<td><strong>示例</strong></td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义字符，用于匹配元字符的字面值。</td>
<td><code>/a\*b/</code>匹配 <code>"a*b"</code>，但不匹配 <code>"ab"</code>。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>匹配换行符。</td>
<td><code>/a\nb/</code>匹配字符串 <code>"a\nb"</code>。</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>匹配制表符。</td>
<td><code>/a\tb/</code>匹配字符串 <code>"a\tb"</code>。</td>
</tr>
</tbody>
</table>
<h3 id="6字符集合和范围">6.字符集合和范围</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>元字符</strong></td>
<td><strong>用途</strong></td>
<td><strong>示例</strong></td>
</tr>
<tr>
<td><code>[abc]</code></td>
<td>匹配字符集合中的任意一个字符。</td>
<td><code>/[abc]/</code>匹配 <code>"a"</code>, <code>"b"</code>, <code>"c"</code>，但不匹配 <code>"d"</code>。</td>
</tr>
<tr>
<td><code>[^abc]</code></td>
<td>匹配不在集合中的任意字符。</td>
<td><code>/[^abc]/</code>匹配 <code>"d"</code>, <code>"e"</code>，但不匹配 <code>"a"</code>, <code>"b"</code>, <code>"c"</code>。</td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td>匹配字符范围内的任意字符。</td>
<td><code>/[a-z]/</code>匹配 <code>"a"</code>到 <code>"z"</code>中的任意小写字母。</td>
</tr>
<tr>
<td><code>[^a-z]</code></td>
<td>匹配不在范围内的任意字符。</td>
<td><code>/[^a-z]/</code>匹配小写字母以外的字符。</td>
</tr>
</tbody>
</table>
<h3 id="7断言元字符">7.断言元字符</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>元字符</strong></td>
<td><strong>用途</strong></td>
<td><strong>示例</strong></td>
</tr>
<tr>
<td><code>(?=...)</code></td>
<td>正向先行断言：匹配后面跟随某模式的字符串。</td>
<td><code>/a(?=b)/</code>匹配 <code>"ab"</code>中的 <code>"a"</code>，但不匹配 <code>"ac"</code>。</td>
</tr>
<tr>
<td><code>(?!...)</code></td>
<td>负向先行断言：匹配后面不跟随某模式的字符串。</td>
<td><code>/a(?!b)/</code>匹配 <code>"ac"</code>中的 <code>"a"</code>，但不匹配 <code>"ab"</code>。</td>
</tr>
<tr>
<td><code>(?&lt;=...)</code></td>
<td>正向后行断言：匹配前面有某模式的字符串（ES2018）。</td>
<td><code>/(?&lt;=a)b/</code>匹配 <code>"ab"</code>中的 <code>"b"</code>，但不匹配 <code>"cb"</code>。</td>
</tr>
<tr>
<td><code>(?&lt;!...)</code></td>
<td>负向后行断言：匹配前面没有某模式的字符串（ES2018）。</td>
<td><code>/(?&lt;!a)b/</code>匹配 <code>"cb"</code>中的 <code>"b"</code>，但不匹配 <code>"ab"</code>。</td>
</tr>
</tbody>
</table>
<p>要匹配上面这些字符本身，必须使用反斜杠来转义：</p>
<pre><code>// 匹配第一个"bat"或"cat"，忽略大小写
let pattern1 = /[bc]at/i;
// 匹配第一个"[bc]at"，忽略大小写
let pattern2 = /\[bc\]at/i;
// 匹配所有以"at"结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;
// 匹配所有".at"，忽略大小写
let pattern4 = /\.at/gi;
</code></pre>
<h2 id="regexp-构造函数">RegExp 构造函数</h2>
<p>构造函数形式：</p>
<pre><code>new RegExp(pattern, flags)
// 示例：
new RegExp('ab+c', 'i')
</code></pre>
<p>注意事项：</p>
<ul>
<li>转义字符：构造函数中的模式需作为字符串传递，反斜杠需双重转义。</li>
<li>动态构建：构造函数适合动态生成正则表达式（如拼接变量）。</li>
<li>修饰符覆盖：若第一个参数是正则对象，第二个参数会覆盖其修饰符。</li>
</ul>
<h2 id="regexp-实例属性">RegExp 实例属性</h2>
<p>RegeExp 实例拥有提供有关模式各方面信息的属性。</p>
<p>修饰符相关（只读布尔值）：</p>
<ul>
<li><code>.global</code>（g）：是否全局匹配。</li>
<li><code>.ignoreCase</code>（i）：是否忽略大小写。</li>
<li><code>.multiline</code>（m）：是否多行模式。</li>
<li><code>.dotAll</code>（s）：是否允许.匹配换行符（ES6+）。</li>
<li><code>.unicode</code>（u）：是否启用Unicode模式（ES6+）。</li>
<li><code>.sticky</code>（y）：是否粘性匹配（ES6+）。</li>
</ul>
<p>其他属性：</p>
<ul>
<li><code>.source</code>：正则表达式的模式文本（如 <code>/abc/</code> 的 source 是 "abc"）。</li>
<li><code>.flags</code>：所有修饰符的字符串（如 <code>/abc/gi</code> 的 flags 是 "gi"）。</li>
<li><code>.lastIndex</code>：下次匹配的起始位置（仅在 g 或 y 模式下生效）。</li>
</ul>
<h2 id="regexp-实例方法">RegExp 实例方法</h2>
<h3 id="test">test()</h3>
<p>检测字符串是否匹配，返回布尔值。</p>
<p>若正则启用 <code>g/y</code>，每次调用会更新 <code>.lastIndex</code>。</p>
<pre><code>const regex = /a/g;
const str = 'abc';
regex.test(str); // true（lastIndex 变为 1）
regex.test(str); // false（从索引 1 开始无匹配，lastIndex 重置为 0）
</code></pre>
<h3 id="exec">exec()</h3>
<p>返回匹配结果的数组（无匹配时返回 <code>null</code>）。</p>
<ul>
<li>数组包含完整匹配、捕获组、<code>index</code>（匹配位置）和 <code>input</code>（原始字符串）。</li>
<li>启用 <code>g/y</code> 时，重复调用可遍历所有匹配，因为每次匹配会从更新后的 <code>lastIndex</code> 开始。</li>
</ul>
<pre><code>const regex = /a(b)(c)/d;
const result = regex.exec('abc');
console.log(result[0]);    // 'abc'（完整匹配）
console.log(result[1]);    // 'b'（第一个捕获组）
console.log(result.index); // 0（匹配位置）
console.log(result.indices); // [[0,3], [1,2], [2,3]]（匹配的索引，需'd'标志）
</code></pre>
<h2 id="regexp-构造函数属性">RegExp 构造函数属性</h2>
<p>RegExp 的静态属性，保存最近一次匹配的上下文（慎用，可能引发全局状态问题）。</p>
<p>每个属性都有一个全名和一个简写。常用属性：</p>
<ul>
<li><code>RegExp.input</code>（<code>RegExp.$_</code>）：最近一次被匹配的字符串。</li>
<li><code>RegExp.lastMatch</code>（<code>RegExp['$&amp;']</code>）：最近一次匹配的文本。</li>
<li><code>RegExp.lastParen</code>（<code>RegExp['$+']</code>）：最近一次匹配的最后一个捕获组。</li>
<li><code>RegExp.leftContext</code>（<code>RegExp['$</code>']`）：匹配文本左侧的字符串。</li>
<li><code>RegExp.rightContext</code>（<code>RegExp["$'"]</code>）：匹配文本右侧的字符串。</li>
<li><code>RegExp.$1</code>~<code>RegExp.$9</code>：第 1 到第 9 个捕获组的内容。</li>
</ul>
<pre><code>const regex = /(\d+)-(\d+)/;
regex.test('123-456');
console.log(RegExp.$1);        // '123'
console.log(RegExp.lastMatch); // '123-456'
console.log(RegExp.leftContext); // ''（匹配在字符串开头）
</code></pre>
<p><strong>RegExp 构造函数的所有属性都没有任何 Web 标准出处，因此不要在生产环境中使用它们</strong>。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.19022561035763888" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-20 13:43">2025-02-19 14:10</span>&nbsp;
<a href="https://www.cnblogs.com/dawnkylin">dawnkylin</a>&nbsp;
阅读(<span id="post_view_count">6</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18723992" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18723992);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18723992', targetLink: 'https://www.cnblogs.com/dawnkylin/p/18723992', title: 'JavaScript RegExp 正则表达式' })">举报</a>
</div>
        