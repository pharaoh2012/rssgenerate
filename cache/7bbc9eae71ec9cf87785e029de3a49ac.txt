
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vigourice/p/18573140" title="发布于 2024-11-27 21:18">
    <span role="heading" aria-level="2">命令行应用开发初学者指南：脚手架篇、UI 库和交互工具</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在日常的前端开发工作中，我们经常依赖各种命令行工具来提高效率和代码质量。例如，<code>create-react-app</code> 和 <code>eslint</code> 等工具不仅简化了项目的初始化过程，还能自动执行代码检查和格式化任务。当我们使用这些工具时，它们通常会通过一系列互动式的问答来收集必要的信息，从而根据我们的选择进行相应的配置和安装。</p>
<p>以 <code>eslint</code> 工具为例（如下图所示），当你首次运行 <code>eslint --init</code> 命令时，它会引导你完成一系列选择题，包括你使用的框架（如 <code>React</code>、<code>Vue.js</code> 或其他），以及其他配置选项。通过这种方式，<code>eslint</code> 能够为你生成一个最适合项目需求的配置文件。</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202411/1408181-20241127210040266-545722499.png" alt="" loading="lazy"></p>
<p>本篇文章将介绍在开发命令行工具过程中常用的第三方库。这些库主要分为三类：</p>
<ul>
<li>
<p><strong>脚手架框架</strong>：用于解析命令行参数，例如 <code>eslint --init</code> 中的 --init。常用的脚手架框架有 <code>yargs</code> 和 <code>command</code>。</p>
</li>
<li>
<p><strong>命令行输出美化库</strong>：基于 <code>ANSI Escape</code> 规范，用于对命令行输出进行颜色和样式美化。常用的美化库有 <code>chalk</code> 和 <code>ora</code>。</p>
</li>
<li>
<p><strong>交互式命令行库</strong>：用于创建交互式的命令行界面，例如 <code>eslint</code> 初始化过程中会提出的问答，如 "Which framework does your project use?"。常用的交互式命令行库有 <code>inquirer</code>。</p>
</li>
</ul>
<h1 id="脚手架框架">脚手架框架</h1>
<p>首先，让我们简单回顾一下 <code>Node.js</code> 脚手架的开发流程：</p>
<ul>
<li><strong>创建 npm 项目</strong>：使用 <code>npm init</code> 命令创建一个新的 npm 项目，并填写相关项目信息。</li>
<li><strong>创建脚手架入口文件</strong>：在项目根目录下创建一个入口文件，例如 index.js，并在文件顶部添加 <code>#!/usr/bin/env node</code> 以便将其识别为可执行文件。</li>
<li><strong>配置 package.json</strong>：在 <code>package.json</code> 文件中添加 <code>bin</code> 属性，指定脚手架的入口文件路径。</li>
<li><strong>添加 npm link</strong>：使用 <code>npm link</code> 命令将项目链接到全局环境中，这样就可以在本地通过短指令访问脚手架。</li>
</ul>
<p>详细的创建及实现功能逻辑可以参考文章<a href="https://www.cnblogs.com/vigourice/p/18538586" target="_blank">《Node.js 构建命令行工具：实现 ls 命令的 -a 和 -l 选项》</a></p>
<p>例如，假设我们创建了一个名为 <code>ice-cli</code> 的项目，并在其中添加了 <code>--init</code> 指令的执行逻辑。那么，我们如何知道用户输入了这项指令呢？这就需要我们在项目中解析命令行参数。</p>
<h2 id="自行解析参数">自行解析参数</h2>
<p>在 <code>Node.js</code> 中，我们可以利用内置的 <code>process</code> 对象来解析命令行参数。具体来说，可以在入口文件 <code>index.js</code> 中执行以下代码：</p>
<pre><code class="language-javascript">const argv = require("process").argv;
console.log("argv", argv);
</code></pre>
<p>当用户在命令行中输入 <code>ice-cli create project --help</code> 这一长串指令后，通过 <code>process.argv</code> 获取到的是一个数组。数组的第一个元素代表 <code>Node.js</code> 的执行路径，第二个元素代表当前指令文件的路径，从第三个元素开始则是用户输入的内容。</p>
<p>例如，对于命令 ice-cli create project --help，process.argv 的输出可能如下所示：</p>
<pre><code class="language-javascript">[
    '/usr/local/bin/node', // Node.js 执行路径
    '/usr/local/lib/node_modules/ice-cli/index.js', // 当前指令文件路径
    'create', // 用户输入的第一个参数
    'project', // 用户输入的第二个参数
    '--help' // 用户输入的第三个参数
]
</code></pre>
<p>拿到用户输入的内容后，我们需要对其进行进一步的拆分和处理。用户输入的内容通常包括 <strong>命令（command）</strong> 和 <strong>选项（options）</strong>。例如，在命令<code> webpack config ./webpack.config.js</code> 中，<code>config</code> 是命令，<code>./webpack.config.js</code> 是命令后面的参数；而在命令 <code>webpack --help</code> 中，<code>--help</code> 是选项。</p>
<p>通过解析 <code>process.argv</code> 数组，我们可以提取出命令和选项，并根据它们执行相应的逻辑。例如：</p>
<pre><code class="language-javascript">const command = argv[2]; &nbsp;// 获取命令
const args = argv.slice(3); &nbsp;// 获取命令后面的参数

if (command === 'create') {
&nbsp; if (args.includes('--help')) {
&nbsp; &nbsp; console.log('Usage: ice-cli create &lt;project-name&gt;');
&nbsp; } else {
&nbsp; &nbsp; const projectName = args[0];
&nbsp; &nbsp; console.log(`Creating project ${projectName}...`);
&nbsp; }
}
</code></pre>
<p>在日常开发中，我们通常不会自己去解析命令行参数，因为这涉及到大量的边界情况和错误处理。使用社区广泛认可的第三方库可以更加高效和严谨。其中，<code>yargs</code> 和 <code>commander</code> 是两个非常优秀的推荐库。</p>
<h2 id="yargs">yargs</h2>
<p><code>yargs</code> 是一个功能强大且易于使用的命令行参数解析库。它提供了丰富的 API，可以帮助你轻松地解析命令和选项，并生成详细的帮助信息。</p>
<h3 id="安装-yargs">安装 yargs</h3>
<p>首先，通过 npm 安装 <code>yargs</code>：</p>
<pre><code class="language-javascript">npm install yargs
</code></pre>
<h3 id="实现---help-和---version-功能">实现 --help 和 --version 功能</h3>
<p>通过简单的代码就可以实现 <code>--help</code> 和 <code>--version</code> 功能：</p>
<pre><code class="language-javascript">const yargs = require("yargs/yargs");
const { hideBin } = require("yargs/helpers");
const arg = hideBin(process.argv);
yargs(arg).argv;
</code></pre>
<p>运行 <code>ice-cli --help</code> ，结果如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202411/1408181-20241127210054598-1394987870.png" alt="" loading="lazy"></p>
<h3 id="常用属性">常用属性</h3>
<p><code>yargs</code> 采用链式调用的方式为命令设置属性。以下是一些常用的属性：</p>
<ul>
<li><strong>usage()</strong> ：在输入 --help 时会显示的提示信息。</li>
<li><strong>demandCommand()</strong> ：最少要输入的命令数量，以及当没有输入命令时的提示。</li>
<li><strong>recommendCommands()</strong> ：如果输入的指令不完整，会给出最近似命令的提示，例如：“Did you mean xx?”</li>
<li><strong>strict()</strong> ：严格模式，输入错误命令时会给出提示。</li>
<li><strong>alias()</strong> ：为指令取别名。</li>
<li><strong>options()</strong> ：定义多个全局选项，在任何场景都可以访问到。</li>
<li><strong>option()</strong> ：定义单个全局选项，在任何场景都可以访问到。</li>
<li><strong>group()</strong> ：将一些命令聚合到一个分类中。</li>
<li><strong>command()</strong> ：定义指令。</li>
<li><strong>epilogue()</strong> ：定义结尾信息。</li>
</ul>
<h3 id="示例代码">示例代码</h3>
<p>将上述命令组合起来，示例如下：</p>
<pre><code class="language-javascript">const yargs = require("yargs/yargs");
const { hideBin } = require("yargs/helpers");
const arg = hideBin(process.argv);
const cli = yargs(arg);
cli
&nbsp; .usage("Usage: ice-ls [command] &lt;options&gt;")
&nbsp; .demandCommand(
&nbsp; &nbsp; 1,
&nbsp; &nbsp; "A command is required. Pass --help to see all avaiable commands and options."
&nbsp; )
&nbsp; .recommendCommands()
&nbsp; .strict()
&nbsp; .alias("h", "help")
&nbsp; .options({
&nbsp; &nbsp; debug: {
&nbsp; &nbsp; &nbsp; type: "boolean",
&nbsp; &nbsp; &nbsp; describe: "Bootstarap debug mode",
&nbsp; &nbsp; &nbsp; alias: "d",
&nbsp; &nbsp; },
&nbsp; })
&nbsp; .group(["debug"], "Dev options:")
&nbsp; .command({
&nbsp; &nbsp; command: "list",
&nbsp; &nbsp; aliases: ["ls", "la", "ll"],
&nbsp; &nbsp; describe: "List total packages",
&nbsp; &nbsp; builder: (argv) =&gt; {
&nbsp; &nbsp; &nbsp; console.log("builder", argv);
&nbsp; &nbsp; },
&nbsp; &nbsp; handler: (argv) =&gt; {
&nbsp; &nbsp; &nbsp; console.log("handler", argv);
&nbsp; &nbsp; },
&nbsp; })
&nbsp; .epilogue("You own footer description").argv;
</code></pre>
<p>当执行 <code>ice-ls</code>  命令时，输出如下：</p>
<ul>
<li>第一行出现 <code>usage</code> 函数配置的提示：Usage: ice-ls [command] <options>。</options></li>
<li>接着是 <code>command</code> 函数配置的指令 list，以及它的别名 ls, la, ll。</li>
<li>然后是通过 <code>group</code> 函数分组的 Dev options。</li>
<li>下面是 <code>yargs</code> 默认提供的选项 --version 和 --help。</li>
<li>接着是 <code>epilogue</code> 函数配置的尾部描述。</li>
<li>最后一行是 <code>demandCommand</code> 提示： A command is required. Pass --help to see all avaiable commands and options。因为执行命令 ice-ls 的时候没有提供具体指令。</li>
</ul>
<p>执行 <code>ice-cli list</code> 和 <code>ice-ls list --debug</code>，此时程序进入 <code>command</code> 函数中，执行 <code>builder</code> 函数 和 <code>handler</code> 函数，可以在这里编写实际的功能逻辑。</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202411/1408181-20241127210106950-1412351925.png" alt="" loading="lazy"></p>
<h2 id="commander">commander</h2>
<p><code>commander</code> 也是一个功能强大的命令行参数解析库，但它在使用方式和 <code>API</code> 设计上和 <code>yargs</code> 有一些差异。</p>
<h3 id="安装-commander">安装 commander</h3>
<p>首先，通过 npm 安装 <code>commander</code>：</p>
<pre><code class="language-javascript">npm install commander
</code></pre>
<h3 id="实现---help-和---version-功能-1">实现 --help 和 --version 功能</h3>
<p><code>commander</code> 通过简单的配置就可以生成 <code>usage</code> 提示以及 <code>--help</code> 和 <code>--version</code> 功能。</p>
<pre><code class="language-javascript">const commander = require("commander");
const pkg = require("../package.json");
const program = new commander.Command();
program
&nbsp; .name(Object.keys(pkg.bin)[0])
&nbsp; .usage("&lt;command&gt; [options]")
&nbsp; .version(pkg.version);

program.parse(process.argv);
</code></pre>
<p>执行上述代码后，运行 <code>ice-cli --help</code> 的输出如下所示：</p>
<pre><code class="language-javascript">Usage: ice-cli &lt;command&gt; [options]

Options:
&nbsp; -V, --version&nbsp; output the version number
&nbsp; -h, --help&nbsp;&nbsp;&nbsp;&nbsp; display help for command
</code></pre>
<h3 id="注册指令">注册指令</h3>
<p><code>commander</code> 和 <code>yargs</code> 在注册指令的语法上有一些区别。<code>yargs</code> 使用链式调用，而 <code>commander</code> 注册指令后返回值并不是自身，因此不能通过链式调用来注册多个指令。</p>
<pre><code class="language-javascript">// 注册 clone 命令
program
&nbsp; .command("clone &lt;source&gt; [destination]")
&nbsp; .description("clone a repository")
&nbsp; .option("-f --force", "是否强制克隆")
&nbsp; .usage("[options]")
&nbsp; .action((source, destination, cmdObj) =&gt; {
&nbsp; &nbsp; console.log("do clone", source, destination);
&nbsp; });
  
// 劫持所有未定义的指令
program
&nbsp; .arguments("&lt;cmd&gt; [options]")
&nbsp; .description("test command", {
&nbsp; &nbsp; cmd: "command to run",
&nbsp; &nbsp; options: "options for command",
&nbsp; })
&nbsp; .action((cmd, options) =&gt; {
&nbsp; &nbsp; console.log(cmd, options);
&nbsp; });  
</code></pre>
<p>当执行 <code>ice-cli clone a b</code> 时，输出为 "do clone a b"。当执行 <code>ice-cli create c</code> 时，输出为 "create c"。</p>
<h3 id="注册子命令">注册子命令</h3>
<p><code>commander</code> 注册子命令的方式也非常简单。以下是一个示例：</p>
<pre><code class="language-javascript">const service = new commander.Command("service");
service
&nbsp; .command("start [port]")
&nbsp; .description("start service at some port")
&nbsp; .action((port) =&gt; {
&nbsp; &nbsp; console.log('&gt;&gt;&gt;service start', port)
&nbsp; });
service
&nbsp; .command("stop")
&nbsp; .description("stop service")
&nbsp; .action(() =&gt; {
&nbsp; &nbsp; console.log('&gt;&gt;&gt;service stop')
&nbsp; });
</code></pre>
<p>当执行 <code>ice-cli service start 8000</code> 时，会输出 "&gt;&gt;&gt;service start 8000"。当执行 <code>ice-cli service stop</code> 时，会输出 "&gt;&gt;&gt;service stop"。</p>
<p><code>yargs</code> 和 <code>commander</code> 解析命令行参数，生成帮助信息，并注册命令。它们提供了强大的命令行接口构建能力，使得命令行工具更加灵活和易用。</p>
<h1 id="命令行输出美化库">命令行输出美化库</h1>
<p>在进行命令行交互时，经常需要对某些内容加粗、加字体颜色，以区分用户选中的内容和需要重点关注的问题。为了实现这些效果，存在一个命令行渲染标准，称为 <code>ANSI escape code</code>。此外，还有一些成熟的第三方库，如 <code>chalk</code> 和 <code>ora</code>，可以帮助我们更方便地实现这些功能。</p>
<h2 id="ansi-escape-code">ANSI escape code</h2>
<p><code>ANSI escape code</code> 是一种用于控制终端输出的标准。通过特定的编码序列，可以在命令行中实现颜色、加粗等效果。</p>
<h3 id="示例">示例</h3>
<p>在 bin 文件夹下创建 ansi.js 文件，文件中定义如下代码：</p>
<pre><code class="language-javascript">console.log("\x1B[31mThis text is red\x1B[0m");
</code></pre>
<p>通过 <code>node</code> 执行该 JS 文件，显示的是红色文本，内容为 "This text is red"。如图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202411/1408181-20241127210120922-527147714.png" alt="" loading="lazy"></p>
<h3 id="编码解析">编码解析</h3>
<p>即使我们没有借助任何第三方库，仅通过一行文本就能实现命令行中的颜色和样式变化。这一行看似“乱码”的文本实际上是由 <code>ANSI Escape Codes</code> 组成的。下面是对这些字符的详细拆解：</p>
<ul>
<li><strong>\x1B</strong>：这是转义字符，表示 ASCII 值为 27 的字符，也常表示为 ESC。它是所有 ANSI Escape Codes 的前缀。</li>
<li><strong>[</strong>：这是一个分隔符，表示接下来是一个控制序列。</li>
<li><strong>31</strong>：这是一个数字代码，表示设置前景色为红色。</li>
<li><strong>m</strong>：这是一个终止符，表示控制序列的结束。</li>
<li><strong>\x1B[0m</strong>：重置所有文本属性，包括颜色和样式。</li>
</ul>
<h3 id="查找期望的样式">查找期望的样式</h3>
<p>要找到期望的样式，可以在 <a href="https://handwiki.org/wiki/ANSI_escape_code" target="_blank" rel="noopener nofollow">ansi escape code 官网</a> 查找。例如，31 代表红色前景色，41 代表红色背景色。</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202411/1408181-20241127210129967-1658440314.png" alt="" loading="lazy"></p>
<p>虽然可以直接使用 <code>ANSI Escape Codes</code> 来实现颜色和样式变化，但在实际开发中这样做会非常繁琐。你需要手动定义转义字符、分隔符，还要查找每个颜色对应的编码。幸运的是，已经有成熟的第三方库可以帮助我们解决这些问题，例如 <code>chalk</code> 和 <code>ora</code>。</p>
<h2 id="chalk">chalk</h2>
<p><code>chalk</code> 是一个用于颜色渲染的库，其语法非常简单，通过方法名就能知道其用途。常见的方法包括：</p>
<ul>
<li><code>rgb(r, g, b)</code>：定义自定义颜色。</li>
<li><code>blue</code>：设置蓝色字体。</li>
<li><code>bold</code>：设置字体加粗。</li>
<li><code>green</code>：设置绿色字体。</li>
<li><code>underline</code>：设置下划线。</li>
</ul>
<p>这些方法名与 CSS 中的样式名称相似，使得使用起来非常直观。<code>chalk</code> 支持多种使用形式，包括直接使用、拼接、链式调用、传入多个参数和嵌套调用。</p>
<h3 id="安装">安装</h3>
<p>首先通过 npm 安装 <code>chalk</code></p>
<pre><code class="language-javascript">npm install chalk
</code></pre>
<h3 id="基本使用">基本使用</h3>
<p><code>chalk</code> 是以 <code>ES module</code> 方式实现的，需要通过 <code>import</code> 方式引入。如果希望在 Node.js 环境中运行，可以将文件后缀名定义为 <code>.mjs</code>。</p>
<p>例如以下代码：</p>
<pre><code class="language-javascript">import chalk from "chalk";

// 直接使用
console.log("hello chalk");
// 定义自定义颜色
console.log(chalk.rgb(255, 0, 0)("hello nodejs"));
// 拼接不同样式
console.log(chalk.blue.bold("hello ") + chalk.green("world"));
// 使用十六进制颜色
console.log(chalk.hex("#ff0000")("it is a nice day"));
// 链式调用和嵌套调用
console.log(
&nbsp; chalk.green(
&nbsp; &nbsp; "I am a green line " +
&nbsp; &nbsp; chalk.blue.underline.bold("with a blue substring") +
&nbsp; &nbsp; " that becomes green again!"
&nbsp; )
);
</code></pre>
<p>执行上述代码后，命令行中的输出效果如下所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202411/1408181-20241127210142361-762860526.png" alt="" loading="lazy"></p>
<h2 id="ora">ora</h2>
<p><code>ora</code> 是一个用于显示加载动画的库，非常适合在命令行应用中显示进度和状态。它以 <code>ES module</code> 方式导出，需要定义 <code>.mjs</code> 文件。</p>
<h3 id="安装-1">安装</h3>
<p>首先通过 npm 安装 <code>ora</code>：</p>
<pre><code class="language-javascript">npm install ora
</code></pre>
<h3 id="基本使用-1">基本使用</h3>
<p><code>ora</code> 在使用时需要手动调用开始和结束方法。以下是一个简单的示例，显示一个加载动画：</p>
<pre><code class="language-javascript">import ora from "ora";
const spinner = ora({
&nbsp; text: "loading",
&nbsp; spinner: "dots",
}).start();
</code></pre>
<p>执行上述代码后，命令行中会显示一个持续的加载动画，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202411/1408181-20241127210152107-1534737066.png" alt="" loading="lazy"></p>
<h3 id="自定义属性">自定义属性</h3>
<p><code>ora</code> 还支持定义其他属性，如加载动画效果、颜色、前缀文本等。</p>
<p>属性说明：</p>
<ul>
<li><strong>text</strong>：初始加载文本。</li>
<li><strong>spinner</strong>：加载动画效果，可以是一个预定义的字符串（如 dots、line 等）或自定义对象。</li>
<li><strong>color</strong>：加载动画的颜色。</li>
<li><strong>prefixText</strong>：加载文本的前缀。</li>
<li><strong>start()</strong>：启动加载动画。</li>
<li><strong>stop()</strong>：停止加载动画。</li>
<li><strong>succeed(message)</strong>：停止加载动画并显示成功消息。</li>
<li><strong>fail(message)</strong>：停止加载动画并显示失败消息。</li>
<li><strong>warn(message)</strong>：停止加载动画并显示警告消息。</li>
<li><strong>info(message)</strong>：停止加载动画并显示信息消息。</li>
</ul>
<p>以下是一个更复杂的示例，展示了如何动态更新加载文本并最终停止加载动画：</p>
<pre><code class="language-javascript">import ora from "ora";
const spinner = ora({
&nbsp; text: "loading",
&nbsp; spinner: "dots",
}).start();

// 设置加载颜色和前缀文本
spinner.color = "red";
spinner.prefixText = "download ora:";

let percent = 0;
let task = setInterval(() =&gt; {
&nbsp; percent += 10;
&nbsp; spinner.text = "Loading..." + percent + "%";
&nbsp; if (percent === 100) {
&nbsp; &nbsp; spinner.stop();
&nbsp; &nbsp; spinner.succeed("download success");
&nbsp; &nbsp; clearInterval(task);
&nbsp; }
}, 1000);
</code></pre>
<p>按以上逻辑，执行过程的中间态如下所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202411/1408181-20241127210205962-814217610.png" alt="" loading="lazy"></p>
<h1 id="交互式命令行">交互式命令行</h1>
<p>在命令行应用中，经常会涉及到一些交互逻辑，例如在 <code>eslint</code> 初始化过程中会询问用户当前使用的框架是 <code>React</code>、<code>Vue</code> 还是其他框架。用户可以通过键盘的上下左右键和回车进行选择。<code>inquirer</code> 就是这样一个用于命令行交互的第三方库。</p>
<h2 id="inquirer">inquirer</h2>
<h3 id="安装-2">安装</h3>
<p><code>inquirer</code> 是一个强大的命令行交互库，可以轻松地创建用户友好的命令行界面。</p>
<pre><code class="language-javascript">npm install inquirer
</code></pre>
<h3 id="基本使用-2">基本使用</h3>
<p>以下是一个简单的示例，展示了如何使用 <code>inquirer</code> 创建一个列表选择：</p>
<pre><code class="language-javascript">import inquirer from "inquirer";

inquirer
&nbsp; .prompt([
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; type: "list",
&nbsp; &nbsp; &nbsp; name: "language",
&nbsp; &nbsp; &nbsp; message: "language",
&nbsp; &nbsp; &nbsp; choices: [
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: 1,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: "react",
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: 2,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: "vue",
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: 3,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: "angular",
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; ],

&nbsp; &nbsp; },
&nbsp; ])
&nbsp; .then((res) =&gt; {
&nbsp; &nbsp; console.log("anwser", res);
&nbsp; });
</code></pre>
<p>执行上述代码后，命令行中会出现一个选择列表，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202411/1408181-20241127210245479-727142151.png" alt="" loading="lazy"></p>
<h3 id="多种交互类型">多种交互类型</h3>
<p><code>inquirer</code> 支持多种交互类型，不仅限于列表选择，还可以输入文本、密码、多选等。<br>
以下是一个示例，展示了多种类型的交互问题：</p>
<pre><code class="language-javascript">
import inquirer from "inquirer";
inquirer
&nbsp; .prompt([
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; type: "input",
&nbsp; &nbsp; &nbsp; name: "yourName",
&nbsp; &nbsp; &nbsp; message: "Your name",
&nbsp; &nbsp; },
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; type: "list",
&nbsp; &nbsp; &nbsp; name: "language",
&nbsp; &nbsp; &nbsp; message: "language",
&nbsp; &nbsp; &nbsp; choices: [
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: 1,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: "react",
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: 2,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: "vue",
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: 3,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: "angular",
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; ],
&nbsp; &nbsp; },
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; type: "expand",
&nbsp; &nbsp; &nbsp; name: "color",
&nbsp; &nbsp; &nbsp; message: "color",
&nbsp; &nbsp; &nbsp; choices: [
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key: "R",
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: "red",
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key: "G",
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: "green",
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key: "B",
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: "blue",
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; ],
&nbsp; &nbsp; },
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; type: "checkbox",
&nbsp; &nbsp; &nbsp; name: "fruits",
&nbsp; &nbsp; &nbsp; message: "fruits",
&nbsp; &nbsp; &nbsp; choices: [
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: 1,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: "apple",
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: 2,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: "banana",
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value: 3,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: "orange",
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; ],
&nbsp; &nbsp; },
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; type: "password",
&nbsp; &nbsp; &nbsp; name: "password",
&nbsp; &nbsp; &nbsp; message: "password",
&nbsp; &nbsp; },
&nbsp; ])
&nbsp; .then((res) =&gt; {
&nbsp; &nbsp; console.log("anwser", res);
&nbsp; });
</code></pre>
<p>执行上述代码后，命令行中会依次显示多个交互问题，最终，所有的用户输入都会在 <code>then</code> 方法中统一获取，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1408181/202411/1408181-20241127210226197-1032849989.png" alt="" loading="lazy"></p>
<p>通过 <code>inquirer</code>，你可以轻松地在命令行应用中实现各种交互逻辑。其丰富的交互类型和灵活的校验机制使得 <code>inquirer</code> 成为一个非常实用的命令行交互库。</p>
<p>通过结合这些工具和库，可以轻松地构建出功能强大、用户体验良好的命令行应用。</p>
<p>如果你对前端工程化有兴趣，或者想了解更多相关的内容，欢迎查看我的其他文章，这些内容将持续更新，希望能给你带来更多的灵感和技术分享~</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="25.73670179183449" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-11-27 21:19">2024-11-27 21:18</span>&nbsp;
<a href="https://www.cnblogs.com/vigourice">一颗冰淇淋</a>&nbsp;
阅读(<span id="post_view_count">262</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18573140" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18573140);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18573140', targetLink: 'https://www.cnblogs.com/vigourice/p/18573140', title: '命令行应用开发初学者指南：脚手架篇、UI 库和交互工具' })">举报</a>
</div>
	