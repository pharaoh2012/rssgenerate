
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sowler/p/18672064" title="发布于 2025-01-16 09:13">
    <span role="heading" aria-level="2">部署简单的单节点k8s</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="1kubernetes简介">1、Kubernetes简介</h1>
<p>Kubernetes，简称K8s，是用8代替名字中间的8个字符“ubernete”而成的缩写。Kubernetes是Google开源的一个容器编排引擎，用于自动部署、扩展和管理容器化应用程序， 现在由Cloud Native Computing Foundation (CNCF) 维护。</p>
<p><strong>主要特性：</strong></p>
<ul>
<li>自动化部署和复制</li>
<li>自动扩缩容</li>
<li>负载均衡</li>
<li>自我修复</li>
<li>服务发现和配置管理</li>
</ul>
<p>官网：<a href="https://kubernetes.io/zh-cn/" target="_blank" rel="noopener nofollow">https://kubernetes.io/zh-cn/</a></p>
<p>Github开源地址：<a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener nofollow">https://github.com/kubernetes/kubernetes</a></p>
<h1 id="2kubernetes安装方式">2、Kubernetes安装方式</h1>
<p>我们可以通过官网文档查看k8s的几种安装方式。文档地址：<a href="https://kubernetes.io/zh-cn/docs/tasks/tools/" target="_blank" rel="noopener nofollow">https://kubernetes.io/zh-cn/docs/tasks/tools/</a></p>
<ul>
<li><strong>kubeadm</strong>：官方推荐的快速部署工具</li>
<li><strong>二进制包</strong>：所有组件都是二进制文件，灵活性高，比较麻烦</li>
<li><strong>minikube</strong>：本地单节点测试环境</li>
<li><strong>kind</strong>：使用Docker容器运行本地Kubernetes集群，将Kubernetes所需要的所有组件全部部署在一个Docker容器中，可以很方便的搭建Kubernetes集群</li>
</ul>
<p>根据调查，二进制包虽然提供了很大的灵活性，但因为配置复杂度高，通常只会被少数有特殊需求的场景采用。目前使用最多的安装方式为：使用<code>kubeadm</code>进行安装和使用<code>minikube</code>进行安装 ,<code>kubeadm</code>主要用于搭建生产环境集群，而<code>minikube</code>主要用于个人学习本地开发环境安装。<code>kind</code>只有在少数资源不够的环境下才会使用。</p>
<p><strong>以下为<code>minikube</code>和<code>kubeadm</code>这两种安装方式的不同点进行对比：</strong></p>
<p><strong>安装和启动方式不同：</strong></p>
<ul>
<li><strong>MiniKube安装</strong>：安装<code>Minikube</code>相对简单，可以通过下载安装包使用<code>Minikube</code>程序进行安装，只需运行<code>minikube start</code>命令即可‌，然后就可以部署应用程序，扩容和管理集群。</li>
<li><strong>kubeadm安装：</strong> 安装<code>Kubernetes</code>需要更多的步骤，使用<code>kubeadm</code>、<code>kubelet</code>、<code>kubectl</code>三个工具进行管理安装，部署<code>Kubernetes</code>集群，一主二从。然后部署应用程序，扩容和管理集群。</li>
</ul>
<p><strong>用途不同：</strong></p>
<ul>
<li><strong>Minikube‌：</strong> <code>Minikube</code>是一个轻量级的<code>Kubernetes</code>集群，主要用于在本地开发和测试。它通过虚拟化技术在一个单独的虚拟化实例中运行<code>Kubernetes</code>控制平面组件，使得我们可以在本地环境中模拟<code>Kubernetes</code>集群，从而进行开发和调试‌。</li>
<li><strong>kubeadm：</strong>  <code>Kubernetes</code>是一个强大的容器编排平台，用于在生产环境中部署和管理大规模的容器化应用程序。它支持多节点集群，能够处理更复杂的部署需求和更大的负载‌。</li>
</ul>
<p><strong>适用场景不同：</strong></p>
<ul>
<li>‌<strong>Minikube‌：</strong> 适用于开发者和测试人员，在本地环境中快速搭建和测试<code>Kubernetes</code>应用，方便进行开发和调试‌</li>
<li><strong>kubeadm：</strong>  适用于生产环境，能够处理大规模的容器部署和管理任务，支持多节点集群，适合在云平台或数据中心部署‌</li>
</ul>
<p><strong>总结：</strong></p>
<p>通过上面可以看出，<code>Minikube</code>是一个用于在本地快速部署<code>Kubernetes</code>集群的工具，比较适用于开发和测试环境的使用，而<code>kubeadm</code>是一个用于生产环境的容器编排使用，具有强大且复杂的功能。</p>
<h1 id="3安装docker">3、安装Docker</h1>
<p>需要保证服务器已经安装<code>Docker</code>，这里不在描述，如果不清楚可以查看以下文章：</p>
<p><a href="https://www.cnblogs.com/sowler/p/18228732" target="_blank">https://www.cnblogs.com/sowler/p/18228732</a></p>
<p><strong>通过上面文章安装成功后，需要更新 Cgroup Driver 为systemd</strong></p>
<pre><code class="language-sh"># Docker 在默认情况下使用的 Cgroup Driver 为 cgroupfs
# docker info 查看  Cgroup Driver 属性
Cgroup Driver: cgroupfs

# 在/etc/docker 目录下 daemon.json文件, 添加配置 exec-opts 属性
"exec-opts": ["native.cgroupdriver=systemd"]

# 重新启动docker
systemctl daemon-reload
systemctl restart docker

# 再次执行 docker info 查看  Cgroup Driver 属性
Cgroup Driver: systemd
</code></pre>
<h1 id="4安装harbor">4、安装Harbor</h1>
<p>Harbor是Docker存储镜像的私有化仓库，有时候因为网络问题连接不上<code>Docker Hub</code> 镜像仓库，可以搭建私有化仓库，从私有仓库进行获取。不清楚搭建可以查看以下文章：</p>
<p><a href="https://www.cnblogs.com/sowler/p/18242819" target="_blank">https://www.cnblogs.com/sowler/p/18242819</a></p>
<p>如果不想搭建私有化仓库也可以，需要配置<code>Docker</code>获取的镜像源地址，配置为一些开源的镜像源地址。虽说因为国内污点严重问题各大厂商关闭了镜像源地址，但是还是可以找到一些可以访问<code>Docker Hub</code>的镜像源的。以下地址亲测有效：</p>
<pre><code class="language-sh"># 在/etc/docker 目录下创建 daemon.json文件,配置 registry-mirrors 属性
{
  "registry-mirrors": [
    "https://docker.m.daocloud.io", 
    "https://dockerproxy.com",
    "https://docker.mirrors.ustc.edu.cn",
    "https://docker.nju.edu.cn",
    "https://docker.hpcloud.cloud",
    "https://docker.m.daocloud.io",
    "https://docker.unsee.tech",
    "https://docker.1panel.live",
    "http://mirrors.ustc.edu.cn",
    "https://docker.chenby.cn",
    "http://mirror.azure.cn",
    "https://dockerpull.org",
    "https://dockerhub.icu",
    "https://hub.rat.dev"]
}
</code></pre>
<h1 id="5kubernetes安装">5、Kubernetes安装</h1>
<h2 id="51minikube安装">5.1、Minikube安装</h2>
<p><strong>介绍：</strong></p>
<p><code>Minikube</code>是一个工具，用于在单个节点上部署一个本地的Kubernetes集群。这对于开发者在本地开发环境进行Kubernetes应用测试和调试非常有用。它能够在个人计算机上启动一个轻量级的虚拟机或容器，并在这个环境中部署一个完整的Kubernetes集群，包括API服务器、etcd、kubelet等核心组件。</p>
<p>Minikube 使用文档：<a href="https://minikube.sigs.k8s.io/docs/" target="_blank" rel="noopener nofollow">https://minikube.sigs.k8s.io/docs/</a></p>
<p>Github开源地址：<a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener nofollow">https://github.com/kubernetes/minikube</a></p>
<p>安装包下载：<a href="https://minikube.sigs.k8s.io/docs/start/?arch=%2Fwindows%2Fx86-64%2Fstable%2F.exe+download" target="_blank" rel="noopener nofollow">https://minikube.sigs.k8s.io/docs/start/?arch=%2Fwindows%2Fx86-64%2Fstable%2F.exe+download</a></p>
<p>使用文档：<a href="https://kubernetes.io/zh-cn/docs/tutorials/hello-minikube/" target="_blank" rel="noopener nofollow">https://kubernetes.io/zh-cn/docs/tutorials/hello-minikube/</a></p>
<p><strong>启动和停止集群：</strong></p>
<p><strong>启动命令：</strong></p>
<pre><code class="language-shell">minikube start --driver=docker
</code></pre>
<p><strong>停止：</strong></p>
<pre><code class="language-shell">minikube stop
</code></pre>
<p>当停止集群后，所有的容器和服务都会停止运行，但集群的配置和存储的数据（如果有持久化存储配置）会保留。</p>
<p><strong>删除集群：</strong></p>
<pre><code class="language-shell">minikube delete
</code></pre>
<p>使用该命令可以删除整个Minikube集群。这将清除所有与集群相关的资源，包括虚拟机、容器镜像等。如果需要重新创建集群，需要再次运行minikube start命令。</p>
<h2 id="52二进制安装">5.2、二进制安装</h2>
<p>二进制文件下载地址：<a href="https://kubernetes.io/releases/download/#binaries" target="_blank" rel="noopener nofollow">https://kubernetes.io/releases/download/#binaries</a></p>
<p>使用二进制安装<code>k8s</code>相对来说比较麻烦，需要自己配置一些相关参数和启动脚本。本次不使用该方法配置。感兴趣的朋友可以在网上找一些相关文章进行安装。</p>
<h2 id="53kubeadm安装">5.3、Kubeadm安装</h2>
<h3 id="531介绍">5.3.1、介绍</h3>
<p>前面已经提到了，通过 <code>kubeadm</code> 进行安装，需要安装<code>kubeadm</code>、<code>kubelet</code>和<code>kubectl</code>三个控件，以下是相关控件的作用介绍：</p>
<ul>
<li><strong>Kubeadm：</strong> 用于快速部署<code>Kubernetes</code>集群的官方工具，主要功能：集群初始化节点加入删除、证书管理、组件升级</li>
<li><strong>kubectl：</strong><code>kubectl </code>是 <code>Kubernetes</code> 的命令行工具，可以通过它与 <code>Kubernetes</code> 集群进行交互，执行各种操作，例如部署应用、管理资源（如Pods、Services、Deployments等）、 查看集群状态以及调试问题等。它是与<code>Kubernetes API server</code>通信的主要方式，允许用户控制和配置集群中的各个组件。</li>
<li><strong>Kubelet：</strong><code>Kubelet</code> 是运行在每个<code>Kubernetes</code>节点上的代理服务，是<code>Kubernetes</code>集群的核心组件之一。它的主要职责是确保该节点上的<code>Pod</code>按照<code>Kubernetes API Server</code>指定的状态正确运行。<code>Kubelet</code>负责接收来自<code>API Server</code>的指令，创建、监控和管理<code>Pod</code>及其容器，还负责健康检查、生命周期管理以及与容器运行时进行交互以执行具体容器操作。kubelet就相当于是守护进程，<code>Kubernetes</code>会自动管理，不需要我们做多余的操作。</li>
</ul>
<h3 id="532通过yum安装">5.3.2、通过yum安装</h3>
<p>通过<code>yum</code>配置国内阿里云开源的<code>k8s</code>镜像进行部署是相对来说比较简单的，本篇文章使用<code>yum</code>进行安装。</p>
<p><strong>安装前准备工作：检查服务器</strong></p>
<pre><code class="language-sh"># 查看防火墙状态
 systemctl status firewalld
# 停止、禁用防火墙
 systemctl stop firewalld
 systemctl disable firewalld
 
 # 禁用 SELinux
 vim /etc/selinux/config
 # 设置 disabled
 SELINUX=disabled
 
# 如果配置了交换内存，需要关闭 Swap
[root@linux-k8s ~]# free -mh
              total        used        free      shared  buff/cache   available
Mem:           3.6G        298M        1.7G        8.9M        1.6G        3.0G
Swap:            0B          0B          0B
# 查看fstab
cat /etc/fstab 
# 删除或注释追加的内容
/opt/swapdata swap swap defaults 0 0
</code></pre>
<p><strong>配置加载内核模块</strong></p>
<pre><code class="language-sh"># 设置iptables和相关网络配置确保容器网络的正确性

cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf
br_netfilter
EOF
</code></pre>
<p>添加该配置文件确保在系统启动时加载<code>br_netfilter</code>内核模块。<code>br_netfilter</code> 模块是 <code>Kubernetes </code>中处理桥接网络流量的关键模块。<code>Kubernetes</code>网络模型通常需要通过桥接（bridge）来连接容器和主机网络，<code>br_netfilter </code>模块使得这些桥接流量能够被<code>iptables</code>规则处理。容器网络通常使用<code>Linux</code>桥接来进行通信，如果没有这个模块，容器和主机之间的网络流量就不能经过 <code>iptables </code>规则处理，可能会导致网络隔离和通信问题。因此，启用 <code>br_netfilter </code>让 <code>Linux </code>桥接流量能够经过 iptables 规则进行过滤和管理。</p>
<p><strong>设置iptables</strong></p>
<pre><code class="language-sh"># 开启桥接流量的 iptables 处理

cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF 
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1 
EOF

# net.bridge.bridge-nf-call-ip6tables：是否将桥接的 IPv6 流量传递给 ip6tables
# net.bridge.bridge-nf-call-iptables：是否将桥接的 IPv4 流量传递给 iptables
# 作用： 这些设置指示 Linux 内核在处理桥接（如容器网络）的 IPv4 和 IPv6 流量时，将流量传递给 iptables 来进行进一步的处理
# 为什么需要：Kubernetes 使用 iptables 来进行网络地址转换（NAT）和流量控制。如果这些参数没有启用，Kubernetes 的网络策略、Pod 网络之间的通信和其他流量控制规则可能无法生效，因为桥接流量不会经过 iptables 规则。启用这些设置可以确保容器间的流量会被正确地处理，确保网络策略得以实施。
</code></pre>
<p>Kubernetes 集群通常使用 Linux 网络桥接（如 docker0）和 iptables 来管理容器的网络流量。通过加载 br_netfilter 内核模块，并启用桥接流量经过 iptables 的处理，可以确保容器的网络流量能够被适当的规则过滤和路由。这是 Kubernetes 网络模型正常工作的关键步骤，特别是在涉及到多节点、Pod 网络隔离和网络策略时。这些配置确保 Kubernetes 的网络组件（如 CNI 插件）能够正确地实现容器之间的网络通信，并且能够按需进行流量控制和隔离。</p>
<p><strong>配置Yum安装k8s镜像源</strong></p>
<pre><code class="language-sh"># 设置yum安装k8s镜像源为阿里云
cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF 
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
</code></pre>
<p><strong>安装Kubeadm、Kubelet、Kubectl</strong></p>
<pre><code class="language-sh"># 通过yum安装指定版本的控件
yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9
# 输出以下信息安装完成
Installed:
  kubeadm.x86_64 0:1.20.9-0                             kubectl.x86_64 0:1.20.9-0                             kubelet.x86_64 0:1.20.9-0                            

Dependency Installed:
  kubernetes-cni.x86_64 0:1.2.0-0                                                                                                                                   
Complete!

# 安装成功后，查看安装版本，提示没有该命令
[root@linux-k8s ~]# kubeadm version
-bash: kubeadm: command not found

# 使用yum下载后，提示没有该命令，把yum加入环境变量
# 编辑.bashrc
vim /root/.bashrc
# 添加以下信息
export PATH=$PATH:/usr/bin/yum
# 重新加载
source /root/.bashrc

# 再次查看安装版本
[root@linux-k8s ~]# kubeadm version
kubeadm version: &amp;version.Info{Major:"1", Minor:"20", GitVersion:"v1.20.9", GitCommit:"7a576bc3935a6b555e33346fd73ad77c925e9e4a", GitTreeState:"clean", BuildDate:"2021-07-15T21:00:30Z", GoVersion:"go1.15.14", Compiler:"gc", Platform:"linux/amd64"}
[root@linux-k8s ~]# kubectl version
Client Version: version.Info{Major:"1", Minor:"20", GitVersion:"v1.20.9", GitCommit:"7a576bc3935a6b555e33346fd73ad77c925e9e4a", GitTreeState:"clean", BuildDate:"2021-07-15T21:01:38Z", GoVersion:"go1.15.14", Compiler:"gc", Platform:"linux/amd64"}
The connection to the server localhost:8080 was refused - did you specify the right host or port?
</code></pre>
<p><strong>Kubeadm 初始化</strong></p>
<pre><code class="language-sh">kubeadm init --apiserver-advertise-address=10.0.4.16 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.20.9  --service-cidr=172.16.0.0/16  --pod-network-cidr=172.17.0.1/16

--apiserver-advertise-address=10.0.4.16 是主节点的IP地址，确保其他节点能够通过该地址访问API服务器，如果为公网地址需要控制台开放2379 2389 6443端口

--image-repository registry.aliyuncs.com/google_containers 指定了容器镜像的仓库地址，Kubernetes默认使用k8s.gcr.io作为镜像仓库，由于无法访问使用了阿里云的镜像仓库

--kubernetes-version v1.20.9 安装的版本，避免版本不匹配引发潜在的问题，使用特定版本确保在集群中运行的所有组件都是兼容的。

--service-cidr=172.16.0.0/16 集群中的service服务（如 ClusterIP 类型的服务）分配的地址池, 表示服务IP会从172.16.0.1到172.16.255.254之间的地址分配

--pod-network-cidr=172.17.0.1/16 设置Pod网络的CIDR地址池,所有Pods将会使用的IP地址范围,表示Pod网络会使用172.17.0.1到172.17.255.254范围的IP地址。注意：地址池是用于Pod内部通信的，需要与选择的CNI插件相兼容，常见的CNI插件如Calico、Flannel会使用该地址池为Pod分配IP地址，确保Flannel网络插件的配置与此CIDR地址池一致。

# service-cidr和pod-network-cidr是配置service、pod网段设置，可以随意配置，不冲突即可
</code></pre>
<p><strong>初始化报错</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/2661519/202501/2661519-20250115110048133-148937081.webp" alt="" loading="lazy"></p>
<p>执行以下命令解决</p>
<pre><code class="language-sh">yum install -y conntrack
# conntrack是Linux内核的一部分，用于跟踪网络连接的状态。Kubernetes使用它来实现网络策略和连接跟踪等功能,如果没有安装conntrack，则 Kubernetes初始化会失败

# 验证 conntrack 是否安装成功
conntrack -L
</code></pre>
<p><strong>去除linux-servertwo警告</strong></p>
<pre><code class="language-sh"># 查看当前主机名：
hostname
# 如果需要更改主机名，执行：
hostnamectl set-hostname linux-servertwo 
# 修改/etc/hosts 加入地址映射：
10.0.4.16  linux-servertwo

# 测试是否加入成功：
[root@linux-servertwo ~]# ping linux-servertwo
PING linux-servertwo (10.0.4.16) 56(84) bytes of data.
64 bytes from linux-servertwo (10.0.4.16): icmp_seq=1 ttl=64 time=0.035 ms
64 bytes from linux-servertwo (10.0.4.16): icmp_seq=2 ttl=64 time=0.044 ms
^C
--- linux-servertwo ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
</code></pre>
<p><strong>重置kubeadm重新初始化</strong></p>
<pre><code class="language-sh"># 重置
kubeadm reset -f

#再次执行
[root@linux-servertwo ~]# kubeadm init --apiserver-advertise-address=10.0.4.16 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.20.9  --service-cidr=172.16.0.0/16  --pod-network-cidr=172.17.0.1/16
[init] Using Kubernetes version: v1.20.9
[preflight] Running pre-flight checks
        [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 26.1.3. Latest validated version: 19.03
error execution phase preflight: [preflight] Some fatal errors occurred:
        [ERROR FileContent--proc-sys-net-ipv4-ip_forward]: /proc/sys/net/ipv4/ip_forward contents are not set to 1
[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`
To see the stack trace of this error execute with --v=5 or higher

# 解决以上问题：
# 永久启用 IP 转发，编辑 /etc/sysctl.conf 文件，添加或修改以下行：
net.ipv4.ip_forward = 1
#然后运行以下命令以应用更改：
sudo sysctl -p


# 再次初始化，初始化成功
[root@linux-servertwo ~]# kubeadm init --apiserver-advertise-address=10.0.4.16 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.20.9  --service-cidr=172.16.0.0/16  --pod-network-cidr=172.17.0.1/16
[init] Using Kubernetes version: v1.20.9
......
[addons] Applied essential addon: CoreDNS
[addons] Applied essential addon: kube-proxy

Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

Alternatively, if you are the root user, you can run:

  export KUBECONFIG=/etc/kubernetes/admin.conf

You should now deploy a pod network to the cluster.
Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 10.0.4.16:6443 --token no9c55.flvu76gcqgk7xqtb \
    --discovery-token-ca-cert-hash sha256:97bc27e3bb67d3d0b7adfca65c934a140ac2c16708bed62f9c49fbd9332cec41 

</code></pre>
<p><strong>Kubectl设置，Kubeadm初始化成功后控制台会打印这些指令命令，执行以下命令：</strong></p>
<pre><code class="language-sh">  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<p><strong>如果集群部署，其它工作节点需要执行join命令加入该节点，由于本次是单节点运行，不需要执行加入命令。</strong></p>
<pre><code class="language-sh">kubeadm join 10.0.4.16:6443 --token no9c55.flvu76gcqgk7xqtb \
    --discovery-token-ca-cert-hash sha256:97bc27e3bb67d3d0b7adfca65c934a140ac2c16708bed62f9c49fbd9332cec41 
# 该命令初始化成功后控制台会打印，仅工作节点执行

# 如果后面忘记了join执行命令，可以在主节点执行以下命令重新生成
kubeadm token create --print-join-command
</code></pre>
<p><strong>查看节点</strong></p>
<pre><code class="language-sh">[root@linux-servertwo ~]# kubectl get nodes
NAME              STATUS     ROLES                  AGE   VERSION
linux-servertwo   NotReady   control-plane,master   13m   v1.20.9
</code></pre>
<p><strong>验证集群状态</strong></p>
<pre><code class="language-sh"># kubectl get cs
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2661519/202501/2661519-20250115110048207-1079597139.webp" alt="" loading="lazy"></p>
<p>出现该报错是因为是<code>/etc/kubernetes/manifests/</code>下的<code>kube-controller-manager.yaml</code>和<code>kube-scheduler.yaml</code>设置的默认端口是<code>0</code>导致的，注释掉对应的<code>port</code>即可。</p>
<pre><code class="language-sh"># 首先进入 manifests
cd /etc/kubernetes/manifests
# 编辑 kube-controller-manager.yaml
vim kube-controller-manager.yaml
# --port=0的作用是禁用kube-controller-manager启动HTTP服务。这种做法可以提高安全性，防止暴露不必要的端点。注释 - --port=0后， 启动HTTP服务，会降低安全性。
 spec:
  containers:
  - command:
    - kube-controller-manager
    - --allocate-node-cidrs=true
    - --authentication-kubeconfig=/etc/kubernetes/controller-manager.conf
    - --authorization-kubeconfig=/etc/kubernetes/controller-manager.conf
    - --bind-address=127.0.0.1
    - --client-ca-file=/etc/kubernetes/pki/ca.crt
    - --cluster-cidr=172.17.0.1/16
    - --cluster-name=kubernetes
    - --cluster-signing-cert-file=/etc/kubernetes/pki/ca.crt
    - --cluster-signing-key-file=/etc/kubernetes/pki/ca.key
    - --controllers=*,bootstrapsigner,tokencleaner
    - --kubeconfig=/etc/kubernetes/controller-manager.conf
    - --leader-elect=true
#    - --port=0
    - --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt
    - --root-ca-file=/etc/kubernetes/pki/ca.crt
    - --service-account-private-key-file=/etc/kubernetes/pki/sa.key
    - --service-cluster-ip-range=172.16.0.0/16
    - --use-service-account-credentials=true

#  编辑 kube-scheduler.yaml
vim kube-scheduler.yaml
#  注释 - --port=0
spec:
  containers:
  - command:
    - kube-scheduler
    - --authentication-kubeconfig=/etc/kubernetes/scheduler.conf
    - --authorization-kubeconfig=/etc/kubernetes/scheduler.conf
    - --bind-address=127.0.0.1
    - --kubeconfig=/etc/kubernetes/scheduler.conf
    - --leader-elect=true
#    - --port=0

# 再次查看集群状态
[root@linux-servertwo manifests]# kubectl get cs
Warning: v1 ComponentStatus is deprecated in v1.19+
NAME                 STATUS    MESSAGE             ERROR
controller-manager   Healthy   ok                  
scheduler            Healthy   ok                  
etcd-0               Healthy   {"health":"true"}  
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2661519/202501/2661519-20250115110048189-1211163989.webp" alt="" loading="lazy"></p>
<p><strong>去除master节点的污点</strong></p>
<p><code>Kubernetes</code>集群的<code>Master</code>节点是十分重要的，一个高可用的<code>Kubernetes</code>集群一般会存在3个以上的<code>master</code>节点，为了保证<code>master</code>节点的稳定性，一般不推荐将业务的<code>Pod</code>调度到<code>master</code>节点上，本文使用单机部署，所以需要去除<code>master</code>节点的污点。<code>Kubernetes</code>中默认<code>master</code>节点是不能调度任何<code>pod</code>的，如果我们要想单节点使用<code>k8s</code>，需要提前将主节点污点去除，官网污点相关的说明：<a href="https://kubernetes.io/zh-cn/docs/reference/kubectl/generated/kubectl_taint/" target="_blank" rel="noopener nofollow">kubectl taint | Kubernetes</a>: <a href="https://kubernetes.io/zh-cn/docs/reference/kubectl/generated/kubectl_taint/" target="_blank" rel="noopener nofollow">https://kubernetes.io/zh-cn/docs/reference/kubectl/generated/kubectl_taint/</a></p>
<pre><code class="language-sh">#执行该命令去除master污点
kubectl taint nodes --all node-role.kubernetes.io/master-


# 设置污点
kubectl taint nodes &lt;node-name&gt; key1=value1:NoSchedule
# 去除污点
kubectl taint nodes &lt;node-name&gt; key1:NoSchedule-

# 查看所有节点
[root@linux-servertwo manifests]# kubectl get nodes
NAME              STATUS     ROLES                  AGE   VERSION
linux-servertwo   NotReady   control-plane,master   75m   v1.20.9
# 查看节点详情：可以查看到节点设置的污点信息 Taints: 属性
kubectl describe node linux-servertwo
</code></pre>
<h1 id="6安装网络插件cni">6、安装网络插件（CNI）</h1>
<p>Kubernetes网络插件，通常被称为CNI（Container Network Interface），用于在Kubernetes集群中提供容器之间的网络连接和通信功能。CNI 插件是 Kubernetes网络架构的一个核心部分，它负责为Pod 分配网络地址、处理网络流量以及为容器提供网络隔离。Flannel和Calico是两种常用的网络插件，它们各自具有不同的特点和应用场景，他们的作用是让集群中的不同节点主机创建的Docker容器都具有全集群唯一的虚拟IP地址，从而使得不同节点上的容器能够获得同属一个内网且不重复的IP地址。</p>
<h2 id="61flannel的使用场景">6.1、Flannel的使用场景</h2>
<p>Flannel是一个简单易用的CNI插件，主要聚焦于为Kubernetes提供基本的容器网络功能。它的设计目标是为小到中等规模的集群提供一种轻量级的网络解决方案。Flannel 适用于以下场景：</p>
<ul>
<li><strong>小型或中型集群或开发/测试环境：</strong>Flannel通常适用于规模较小、网络拓扑相对简单的集群。它比较轻量，不需要复杂的配置。适合运行在一个不需要复杂网络策略的小型或中型Kubernetes集群。特别适合开发、测试和实验环境。</li>
<li><strong>没有复杂网络策略要求的环境：</strong>Flannel不提供复杂的网络策略功能，它的主要目标是为Pod提供基本的IP地址分配和通信能力。对于不需要对网络流量进行细粒度控制的环境，Flannel是一个非常简单且易于配置的网络方案。</li>
<li><strong>低资源消耗的集群：</strong>Flannel配置和管理相对简单，资源消耗较低。它使用VXLAN或UDP作为网络后端，通常适合资源受限的环境。对于资源有限的环境，如边缘计算、单机部署或开发/测试集群，Flannel 的资源消耗较少，能够满足基本的网络需求。</li>
<li><strong>没有高性能需求的场景：</strong>Flannel 的网络性能通常不如 Calico 或 Cilium，因为它使用的是一种简单的网络隧道技术（如 VXLAN），适合对网络性能要求不高的环境。对于对网络延迟和吞吐量要求不高的应用，Flannel 是一个合适的选择。</li>
<li><strong>临时或实验性集群：</strong>Flannel 可以用来支持那些临时搭建、没有高网络需求的集群环境，例如实验性项目或 POC（概念验证）集群。</li>
</ul>
<h2 id="62calico的使用场景">6.2、Calico的使用场景</h2>
<p>Calico是一个功能强大的CNI插件，它不仅提供基本的容器网络功能，还支持更复杂的网络策略和高级功能，如IP路由、网络安全、流量控制和负载均衡等。Calico 适用于对网络性能、安全性和可扩展性有较高要求的场景。以下是Calico的典型使用场景：</p>
<ul>
<li><strong>大规模集群或多集群环境：</strong>Calico 支持大规模集群的高性能网络通信，支持跨多个数据中心或云平台的网络连接。它采用高效的路由技术（如 BGP 和 IP-in-IP），可以应对大规模和复杂的网络环境。如果部署的Kubernetes集群是大规模的，或者需要跨多个数据中心或云区域部署，Calico 由于其高可扩展性和支持跨节点的路由，适用于这种大规模的集群管理。</li>
<li><strong>需要复杂网络策略和流量控制的环境：</strong>Calico 提供强大的网络策略功能，可以定义细粒度的访问控制规则，控制不同 Pod 或命名空间之间的流量。这对于有高安全性要求的应用尤为重要。如果需要部署一个严格的网络安全控制 Kubernetes 集群，或应用需要按照访问控制列表（ACL）进行网络隔离和流量管理，Calico 是一个非常合适的选择。它允许你实现基于 IP、端口、命名空间等层级的精确控制。</li>
<li><strong>需要高网络性能的场景：</strong>Calico 基于 IP 路由的网络架构通常比 Flannel 更高效，尤其是在大规模集群中。它支持 BGP（边界网关协议），提供快速的路由功能和高吞吐量。对于需要低延迟、高吞吐量网络性能的应用（如大规模分布式数据库、大数据分析平台等），Calico 提供了更优的性能，适用于需要高网络性能的生产环境。</li>
<li><strong>云原生和微服务架构：</strong>Calico 提供对云原生应用、微服务架构的良好支持，尤其是在管理复杂的服务网格、服务发现、负载均衡等方面有很大优势。在构建基于微服务的云原生应用时，Calico 的网络策略、流量管理功能以及对服务网格（如 Istio）的支持，可以帮助更好地管理和保护集群中的流量。</li>
<li><strong>混合云或多云环境：</strong>Calico 允许在不同的云环境（如 AWS、GCP、Azure 等）之间建立虚拟网络，支持跨云网络通信，并能有效管理跨云的网络流量。如果需要部署 Kubernetes 集群在一个混合云或多云环境，需要跨不同云平台的 Kubernetes 集群进行通信，Calico 可以帮助你实现网络跨平台的统一管理。</li>
<li><strong>需要高可用性和弹性网络的场景：</strong>Calico 通过支持 BGP 动态路由和其他冗余机制，提高了网络的可靠性和弹性。它能够自动应对节点故障和网络变化，确保集群网络的高可用性。对于需要高可用性和自动化恢复的企业级应用或生产环境，Calico 的高可用网络设计非常适合。</li>
<li><strong>Kubernetes 集群与虚拟机混合部署</strong>：通过Calico可以在Kubernetes环境中部署虚拟机，Calico 可以同时支持容器和虚拟机，适用于虚拟化和容器化混合的环境。</li>
</ul>
<h2 id="63flannel与calico的对比总结">6.3、Flannel与Calico的对比总结</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>Flannel</strong></th>
<th><strong>Calico</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>网络架构</strong></td>
<td>简单的 IP 分配和通信</td>
<td>高效的路由，支持 BGP</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>性能较低，适用于小规模集群</td>
<td>高性能，适用于大规模集群</td>
</tr>
<tr>
<td><strong>网络策略</strong></td>
<td>不支持复杂网络策略</td>
<td>强大的网络策略功能</td>
</tr>
<tr>
<td><strong>网络安全</strong></td>
<td>简单的网络隔离</td>
<td>强大的安全控制，支持 ACL 和安全组</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>适用于小型、中型集群</td>
<td>适用于大规模集群</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>小型集群、开发/测试、临时集群</td>
<td>大规模集群、企业级环境、混合云、多云环境</td>
</tr>
</tbody>
</table>
<p>所以通过以上应用功能对比，如果需要简单、轻量、易于配置的网络方案，适合小型集群、开发环境或者临时集群，可以使用 <strong>Flannel</strong>。如果需要高性能、大规模扩展能力以及复杂的网络策略，尤其是在生产环境中对安全性和网络隔离有严格要求的场景。使用<strong>Calico</strong>更加合适。</p>
<p><strong>总结：</strong></p>
<p>通过以上分析，由于本篇使用的是单节点部署，使用<strong>Flannel</strong>更为合适。</p>
<h2 id="64kube-flannel安装">6.4、kube-flannel安装</h2>
<p>Flannel官网：<a href="https://github.com/flannel-io/flannel#deploying-flannel-manually" target="_blank" rel="noopener nofollow">https://github.com/flannel-io/flannel#deploying-flannel-manually</a></p>
<p><strong>下载文件</strong></p>
<pre><code class="language-sh"> wget https://github.com/flannel-io/flannel/releases/download/v0.24.3/kube-flannel.yml
</code></pre>
<p><strong>更改网络</strong></p>
<pre><code class="language-sh"> # 修改下载的kube-flannel.yml文件
 vim kube-flannel.yml
 
 # 找到net-conf.json属性，配置Network和初始化的 kubeadm init  --pod-network-cidr=172.17.0.1/16 的IP一致，Backend.Type的类型为vxlan
 net-conf.json: |
    {
      "Network": "172.17.0.1/16",
      "Backend": {
        "Type": "vxlan"
      }
    }
</code></pre>
<p>当网络插件使用 VXLAN 类型时，它会在每个 Kubernetes 节点之间创建一个虚拟隧道，允许跨节点的 Pod 之间进行通信。具体来说，VXLAN 技术提供以下几个重要功能：</p>
<ul>
<li><strong>跨主机网络连接：</strong>VXLAN 允许 Kubernetes 集群中的 Pod 即使在不同物理主机上，也能直接通信。</li>
<li><strong>可扩展性：</strong>VXLAN 支持大规模的网络虚拟化，能够创建多达 16,777,216 个虚拟网络。</li>
<li><strong>网络隔离：</strong>每个 VXLAN 网络都有唯一的标识符（VNI），使得网络间相互隔离，不会干扰。</li>
</ul>
<p><strong>配置成功后，执行命令发布Flannel</strong></p>
<pre><code class="language-sh">[root@linux-servertwo kubernetes]# kubectl apply -f kube-flannel.yml
namespace/kube-flannel created
serviceaccount/flannel created
clusterrole.rbac.authorization.k8s.io/flannel created
clusterrolebinding.rbac.authorization.k8s.io/flannel created
configmap/kube-flannel-cfg created
daemonset.apps/kube-flannel-ds created
You have new mail in /var/spool/mail/root

# 查看是否发布成功，出现 Running 状态，说明 Flannel 插件安装成功
[root@linux-servertwo kubernetes]# kubectl get pods -n kube-flannel
NAME                    READY   STATUS    RESTARTS   AGE
kube-flannel-ds-fvzcp   1/1     Running   0          13s

# 查看节点状态 
[root@linux-servertwo kubernetes]# kubectl get nodes
NAME              STATUS   ROLES                  AGE   VERSION
linux-servertwo   Ready    control-plane,master   24h   v1.20.9
# 通过查看节点状态发现STATUS列表，由之前的 NotReady 变为 Ready 说明已经正常工作了
# Ready：表示该节点已经成功加入集群，且所有必需的组件正在运行中，能够正常调度Pods
# NotReady：表示该节点出现了问题，无法正常工作，可能是因为网络、系统故障或Kubernetes组件没有启动成功
</code></pre>
<p><strong>查看所有Pod是否启动成功</strong></p>
<pre><code class="language-sh"># 执行命令查看Pod启动情况：
kubectl get pod -n kube-system
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2661519/202501/2661519-20250115110048240-1296643007.webp" alt="" loading="lazy"></p>
<p>发现两个pod未启动，执行以下命令查看失败的原因（这里是第一次安装的时候会出现的问题，当进行第二次安装的时候没有出现该问题，可能当时是网络原因，如果查看Pod启动情况发现都启动成功了，可以不进行配置，这里只做下记录）</p>
<pre><code class="language-sh">kubectl describe pod coredns-7f89b7bc75-2k74p  -n kube-system
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2661519/202501/2661519-20250115110048217-594612795.webp" alt="" loading="lazy"></p>
<pre><code class="language-sh">networkPlugin cni failed to set up pod "coredns-7f89b7bc75-2k74p_kube-system" network: loadFlannelSubnetEnv failed: open /run/flannel/subnet.env：no such file or directory
</code></pre>
<p>Flannel 的配置文件通常包括子网配置文件（subnet.env），位于<code>/run/flannel/</code>目录下。如果文件缺失，可能是因为<code>Flannel</code>没有正确初始化。</p>
<pre><code class="language-sh"># 如果没有，可以创建一个subnet.env文件, 加入以下信息
[root@linux-servertwo kubernetes]# cat /run/flannel/subnet.env
FLANNEL_NETWORK=172.17.0.0/16
FLANNEL_SUBNET=172.17.0.1/24
FLANNEL_MTU=1450
FLANNEL_IPMASQ=true

#FLANNEL_NETWORK：指定整个网络范围。 代表的子网范围是 172.17.0.0 到 172.17.255.255
#FLANNEL_SUBNET：指定一个子网，该子网将被分配给 Flannel 网络插件。代表的子网范围是 172.17.0.0 到 172.17.0.255
#FLANNEL_MTU：指定网络的最大传输单元（默认为 1450 字节）。
#FLANNEL_IPMASQ：设置是否启用 IP 转发和网络地址转换（IP Masquerading），通常启用
</code></pre>
<p>配置成功，我们可以发现目前所有pod都已经启动了。</p>
<p><img src="https://img2024.cnblogs.com/blog/2661519/202501/2661519-20250115110048245-847440982.webp" alt="" loading="lazy"></p>
<p><strong>Kubenetes移除Flannel</strong></p>
<pre><code class="language-sh"># 删除 DaemonSet
kubectl delete daemonset kube-flannel-ds-fvzcp -n kube-flannel

# 删除 ConfigMap
kubectl delete configmap kube-flannel-ds-fvzcp -n kube-flannel

# 删除 ServiceAccount
kubectl delete serviceaccount flannel -n kube-flannel

# 验证 DaemonSet 是否已删除
kubectl get daemonset -n kube-flannel

# 验证 Pod 是否已删除
kubectl get pod -n kube-flannel
</code></pre>
<p><strong>确认所有Pod启动成功</strong></p>
<p>当安装成功<code>Flannel</code>后，最后需要再次确认下所安装的所有<code>Pod</code>是否全部启动成功，如果还有启动失败的<code>Pod</code>，在找其他方法去解决。</p>
<pre><code class="language-sh"># 执行以下命令查看所有命名空间的Pod运行情况
[root@linux-servertwo kubernetes]# kubectl get pod --all-namespaces
NAMESPACE      NAME                                      READY   STATUS    RESTARTS   AGE
kube-flannel   kube-flannel-ds-fvzcp                     1/1     Running   0          18h
kube-system    coredns-7f89b7bc75-5p49z                  1/1     Running   0          42h
kube-system    coredns-7f89b7bc75-6crzd                  1/1     Running   0          42h
kube-system    etcd-linux-servertwo                      1/1     Running   0          42h
kube-system    kube-apiserver-linux-servertwo            1/1     Running   0          42h
kube-system    kube-controller-manager-linux-servertwo   1/1     Running   0          42h
kube-system    kube-proxy-btbwc                          1/1     Running   0          42h
kube-system    kube-scheduler-linux-servertwo            1/1     Running   0          42h

# 可以以上输出可以发现所有Pod都已经启动成功了
# READY Pod 中容器的就绪状态 格式为：就绪容器数 / 总容器数 ，通过输出可以发现都已经准备就绪
# STATUS 为：Running，表示 Pod 处于运行状态。如果为：CrashLoopBackOff，表示该Pod中的容器因某些错误崩溃并且正进入重启循环
# RESTARTS  Pod 中容器的重启次数 显示为 0 说明容器没有重启，就表示启动成功了。如果经历了容器多次重启，可能说明它遇到了错误或其他问题。则会显示一个数字，表示重启的次数
</code></pre>
<h1 id="7部署kubernetes-dashboard">7、部署kubernetes-dashboard</h1>
<p><code>Kubernetes</code>安装部署成功后，接下来就安装我们的第一个<code>K8s</code>应用<code>kubernetes-dashboard</code>。<code>kubernetes-dashboard</code>是<code>K8s</code>官方推荐的图形化管理工具，它的作用是简化集群操作，适用于习惯于图形界面而非命令行的用户。<code>kubernetes-dashboard</code>是一个基于 Web 的用户界面，用于管理和监控 Kubernetes 集群中的应用程序，帮助用户查看集群的状态、管理应用程序资源、执行常见的管理操作等。</p>
<p>Github官网地址：<a href="https://github.com/kubernetes/dashboard" target="_blank" rel="noopener nofollow">https://github.com/kubernetes/dashboard</a></p>
<p><strong>查看版本兼容性</strong></p>
<p>找到和我们安装<code>k8s</code>的版本所兼容的版本</p>
<p><img src="https://img2024.cnblogs.com/blog/2661519/202501/2661519-20250115110048465-1947725721.webp" alt="" loading="lazy"></p>
<p>由于本次下载的是<code>1.20.9</code>，所以找到兼容该版本的<code>dashboard</code>进行下载，在<code>Linux</code>中执行以下命令下载上图中的版本。</p>
<pre><code class="language-sh">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.2.0/aio/deploy/recommended.yaml
</code></pre>
<p>默认<code>Dashboard</code>只能集群内部访问，修改<code>Service</code>为<code>NodePort</code>类型，暴露到外部：</p>
<pre><code class="language-sh"># 在spec中添加配置信息type: NodePort 在ports中加入 nodePort: 31001  # 新增
kind: Service
apiVersion: v1
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: kubernetes-dashboard
  namespace: kubernetes-dashboard
spec:
  type: NodePort  # 新增
  ports:
    - port: 443
      targetPort: 8443
      nodePort: 31001  # 新增
  selector:
    k8s-app: kubernetes-dashboard
</code></pre>
<p><strong>发布应用</strong></p>
<pre><code class="language-sh"># 部署应用
[root@linux-servertwo kubernetes]# kubectl apply -f recommended.yaml
namespace/kubernetes-dashboard created
serviceaccount/kubernetes-dashboard created
service/kubernetes-dashboard created
secret/kubernetes-dashboard-certs created
secret/kubernetes-dashboard-csrf created
secret/kubernetes-dashboard-key-holder created
configmap/kubernetes-dashboard-settings created
role.rbac.authorization.k8s.io/kubernetes-dashboard created
clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created
rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created
clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created
deployment.apps/kubernetes-dashboard created
service/dashboard-metrics-scraper created
deployment.apps/dashboard-metrics-scraper created

# 查看是否发布成功
[root@linux-servertwo kubernetes]# kubectl get pods -n kubernetes-dashboard
NAME                                         READY   STATUS    RESTARTS   AGE
dashboard-metrics-scraper-79c5968bdc-tl4gr   1/1     Running   0          37s
kubernetes-dashboard-9f9799597-2spkv         1/1     Running   0          37s
# 查看kubernetes-dashboard命名空间下的暴露端口
[root@linux-servertwo kubernetes]# kubectl get svc -A | grep kubernetes-dashboard
kubernetes-dashboard   dashboard-metrics-scraper   ClusterIP   172.16.130.109   &lt;none&gt;        8000/TCP                 3m35s
kubernetes-dashboard   kubernetes-dashboard        NodePort    172.16.240.39    &lt;none&gt;        443:31001/TCP            3m35s
</code></pre>
<p><strong>查看kubernetes-dashboard命名空间下更为详细的信息</strong></p>
<pre><code class="language-sh"># 查看kubernetes-dashboard命名空间下更为详细的信息
[root@linux-servertwo kubernetes]# kubectl get pod,svc -n kubernetes-dashboard -o wide
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2661519/202501/2661519-20250115110048443-1583855115.webp" alt="" loading="lazy"></p>
<p>通过以上查看，可以发现<code>kubernetes-dashboard </code> 部署成功了，接下来通过浏览器访问<code>31001</code>端口，查看是否可以访问成功。访问地址：<a href="http://NodeIP:31001" target="_blank" rel="noopener nofollow">http://NodeIP:31001</a></p>
<pre><code class="language-sh">Client sent an HTTP request to an HTTPS server.
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2661519/202501/2661519-20250115110048453-1763761079.webp" alt="" loading="lazy"></p>
<p>通过访问，浏览器页面报以上错误信息，根据提示加上<code>https://</code> 进行访问，地址：<a href="https://NodeIP:31001" target="_blank" rel="noopener nofollow">https://NodeIP:31001</a> ，再次访问</p>
<p><img src="https://img2024.cnblogs.com/blog/2661519/202501/2661519-20250115110048481-123429720.webp" alt="" loading="lazy"></p>
<p>通过查找发现谷歌的<code>Google Chrome</code>和微软的<code>Microsoft Edge</code>因为地址不安全，会拦截该地址，使用火狐浏览器<code>Firefox</code>可以访问。访问成功页面如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/2661519/202501/2661519-20250115110048527-1713397902.webp" alt="" loading="lazy"></p>
<p>通过登录页面可以看到，要想进入系统需要进行登录。登录系统需要输入<code>Token</code>信息，下面就来获取登录的<code>Token</code></p>
<p><strong>首先创建用户</strong></p>
<pre><code class="language-sh"># 执行：kubectl create serviceaccount dashboard-admin -n kubernetes-dashboard 创建 service account
[root@linux-servertwo kubernetes]# kubectl create serviceaccount dashboard-admin -n kubernetes-dashboard
serviceaccount/dashboard-admin created
</code></pre>
<p><strong>给创建的用户授权</strong></p>
<pre><code class="language-sh"># 执行： kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:dashboard-admin 绑定默认cluster-admin管理员集群角色
[root@linux-servertwo kubernetes]# kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:dashboard-admin
clusterrolebinding.rbac.authorization.k8s.io/dashboard-admin created
</code></pre>
<p><strong>获取用户Token</strong></p>
<pre><code class="language-sh"># 执行：kubectl get secrets -n kubernetes-dashboard | grep dashboard-admin
[root@linux-servertwo kubernetes]# kubectl get secrets -n kubernetes-dashboard | grep dashboard-admin
dashboard-admin-token-29nxl        kubernetes.io/service-account-token   3      5m41s

# 根据获取到的 dashboard-admin-token-29nxl 查看详情
[root@linux-servertwo kubernetes]# kubectl describe secrets dashboard-admin-token-29nxl -n kubernetes-dashboard
Name:         dashboard-admin-token-29nxl
Namespace:    kubernetes-dashboard
Labels:       &lt;none&gt;
Annotations:  kubernetes.io/service-account.name: dashboard-admin
              kubernetes.io/service-account.uid: 7d9a046c-c6dd-4dfa-affb-b76c1c079521

Type:  kubernetes.io/service-account-token

Data
====
namespace:  20 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6ImtZNmxMM2cyTnI2NHVmRGdtU19GbUEyNlhiRHg1THVFWXliZXl2NWQycHMifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4tMjlueGwiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiN2Q5YTA0NmMtYzZkZC00ZGZhLWFmZmItYjc2YzFjMDc5NTIxIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmVybmV0ZXMtZGFzaGJvYXJkOmRhc2hib2FyZC1hZG1pbiJ9.NBRUjyHXD6zCeiboJP946fOJfWn2dVtC4n7VvfzUH805g4EgaNFM2I4ADN5UUGdfLnKaO71MG1JESYemh1SSkdG8jg7yXWioiSl7pAhZUnhJYNAOgiE-nHA01yCISTTR30CL3OCjx8lkRLPxTRz31DMlqxC8cy4ToPD4iqyDrZOYlZWkGtuFf8SBz-xm4T5SUKvPvl0y8P1ThZw6uD1AhXmCZvH2KveLPm2S_kjoCC3aR5ElcaeU-jbjqcIudxSdLjzLSj11M6jYSc-7hY7zAVYiZF3dCGFDkej3j3eZWPt2lPwjoWSpUdJRqK_eAQMN2wot4l0SpHG0pOS1USNxxw
ca.crt:     1066 bytes
</code></pre>
<p><strong>复制token到输入框</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/2661519/202501/2661519-20250115110048442-739484168.webp" alt="" loading="lazy"></p>
<p>点击登录，登录成功进入首页面。</p>
<p><img src="https://img2024.cnblogs.com/blog/2661519/202501/2661519-20250115110048446-487987532.webp" alt="" loading="lazy"></p>
<h1 id="8总结">8、总结</h1>
<p>关于<code>Kubernetes</code>的安装介绍到这里就结束了，虽然安装的过程中有点小曲折，但是还算是正常启动成功了。相对于搭建集群的<code>K8s</code>，使用单节点安装确实方便了许多，非常适合新手去学习<code>k8s</code></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.16444155851851852" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-16 10:23">2025-01-16 09:13</span>&nbsp;
<a href="https://www.cnblogs.com/sowler">sowler</a>&nbsp;
阅读(<span id="post_view_count">155</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18672064" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18672064);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18672064', targetLink: 'https://www.cnblogs.com/sowler/p/18672064', title: '部署简单的单节点k8s' })">举报</a>
</div>
        