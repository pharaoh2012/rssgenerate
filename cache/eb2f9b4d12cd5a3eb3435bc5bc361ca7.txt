
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19061005" title="发布于 2025-08-27 14:59">
    <span role="heading" aria-level="2">【渲染流水线】[输出阶段]-[双缓冲机制]以UnityURP为例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250827150348799-2104102233.png" alt="【渲染流水线】[输出阶段]-[双缓冲机制]以UnityURP为例" class="desc_img">
        Unity URP中的双缓冲技术解析 双缓冲技术是图形渲染中解决画面闪烁和撕裂的关键机制。在Unity URP中，该技术通过SwapBufferSystem类实现，包含m_A和m_B两个缓冲区交替使用。URP对双缓冲进行了系统化封装，相比早期内置管线更高效。实现原理包括：1)创建两个渲染目标作为帧缓冲；2)通过描述符控制内存分配；3)与VSync信号同步防止撕裂。示例代码展示了在后处理效果、自定义渲染系统和多相机渲染中的应用，如使用临时渲染目标实现效果叠加，以及多相机平滑切换。双缓冲机制的优化使URP能够提
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<ul>
<li>最终将处理结果写入颜色/深度/模板缓冲区</li>
<li>可独立控制各通道写入权限‌</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<h1 id="双缓冲机制介绍"><strong>双缓冲机制介绍</strong></h1>
<p>双缓冲(Double Buffer)是一种图形渲染中的常用技术，通过使用两个缓冲区(前台缓冲区和后台缓冲区)来解决图形渲染过程中的闪烁和撕裂问题。在Unity URP中，双缓冲机制主要用于管理渲染目标，确保渲染过程的平滑进行。</p>
<p>双缓冲的核心原理是：一个缓冲区用于当前显示的帧(前台缓冲区)，另一个缓冲区用于绘制新帧(后台缓冲区)。当后台缓冲区完成绘制后，系统会执行交换操作，将两个缓冲区瞬时交换。现代GPU通常使用三重缓冲等多缓冲技术来进一步优化性能。</p>
<h1 id="历史发展流程"><strong>历史发展流程</strong></h1>
<p>双缓冲技术最早应用于图形显示领域，用于解决屏幕刷新和图形绘制之间的同步问题。在Unity引擎中，双缓冲机制随着渲染管线的演进不断优化：</p>
<ul>
<li>‌<strong>内置渲染管线时期</strong>‌：Unity早期版本使用内置渲染管线，双缓冲主要通过命令缓冲区(CommandBuffer)实现，开发者可以手动管理渲染目标的切换。</li>
<li>‌<strong>可编程渲染管线(SRP)引入</strong>‌：Unity 2018版本引入可编程渲染管线概念，为双缓冲提供了更灵活的接口。</li>
<li>‌<strong>URP成熟期</strong>‌：在URP(Universal Render Pipeline)中，双缓冲机制被系统化封装，形成了SwapBufferSystem等高级抽象，优化了后处理流程。</li>
</ul>
<h1 id="内置管线与urp中的双缓冲变量"><strong>内置管线与URP中的双缓冲变量</strong></h1>
<h2 id="内置管线中的双缓冲变量"><strong>内置管线中的双缓冲变量</strong></h2>
<p>在内置渲染管线中，双缓冲主要通过以下变量和机制实现：</p>
<ul>
<li><code>CommandBuffer</code>：存储一系列渲染指令的容器，可用于设置渲染目标</li>
<li><code>RenderTexture</code>：临时渲染纹理，常被用作后台缓冲区</li>
<li><code>BuiltinRenderTextureType</code>：内置纹理类型，包括<code>CurrentActive</code>和<code>CameraTarget</code>等</li>
</ul>
<h1 id="urp中的双缓冲变量"><strong>URP中的双缓冲变量</strong></h1>
<p>URP对双缓冲机制进行了更高级的封装，主要涉及以下变量和类：</p>
<ul>
<li><code>SwapBufferSystem</code>：URP中的双缓冲系统实现，包含<code>m_A</code>和<code>m_B</code>两个<code>SwapBuffer</code>结构体</li>
<li><code>RenderTargetHandle</code>：URP中表示渲染目标的句柄</li>
<li><code>ScriptableRenderPass</code>：渲染通道基类，包含设置渲染目标的接口</li>
<li><code>UniversalRenderer</code>：URP默认渲染器，管理双缓冲的初始化和交换</li>
</ul>
<h1 id="底层原理解析"><strong>底层原理解析</strong></h1>
<h2 id="底层实现核心类与变量"><strong>底层实现核心类与变量</strong></h2>
<p>在Unity URP中，双缓冲机制主要通过<code>SwapBufferSystem</code>类实现，该类包含两个关键变量<code>m_A</code>和<code>m_B</code>，分别代表前后缓冲区。具体实现位于<code>UniversalRenderer</code>类中，作为渲染目标管理系统的核心组件。</p>
<h3 id="主要实现细节">主要实现细节</h3>
<ul>
<li><code>SwapBuffer</code>结构体：包含<code>name</code>(缓冲区名称)和<code>rt</code>(RenderTexture)两个字段</li>
<li><code>SwapBufferSystem</code>类：管理两个<code>SwapBuffer</code>实例的交换逻辑</li>
<li><code>UniversalRenderer</code>类：初始化并控制双缓冲系统的生命周期</li>
</ul>
<h2 id="缓冲区创建">‌<strong>缓冲区创建</strong>‌</h2>
<ul>
<li>在<code>UniversalRenderer</code>的<code>Setup</code>方法中创建两个渲染目标，这些目标实际上是纹理支持的帧缓冲。</li>
</ul>
<h2 id="描述符控制">‌<strong>描述符控制</strong>‌</h2>
<ul>
<li>通过<code>cameraTargetDescriptor</code>参数描述渲染目标的内存分配方式，可以在<code>AddRenderPasses</code>阶段修改这些参数来"劫持"渲染目标。</li>
</ul>
<h2 id="交换机制">‌<strong>交换机制</strong>‌</h2>
<ul>
<li>URP使用<code>SwapBufferSystem</code>维护两个渲染目标缓冲区(<code>m_A</code>和<code>m_B</code>)，在渲染过程中交替使用，避免中间环节的重复拷贝。</li>
</ul>
<h2 id="同步控制">‌<strong>同步控制</strong>‌</h2>
<ul>
<li>双缓冲与VSync信号配合工作，确保缓冲区交换与屏幕刷新同步，防止画面撕裂.</li>
</ul>
<h1 id="双缓冲机制urp示例"><strong>双缓冲机制URP示例</strong></h1>
<h2 id="后处理效果双缓冲实现"><strong>后处理效果双缓冲实现</strong></h2>
<ul>
<li>
<p>PostProcessFeature.cs</p>
<p>后处理效果中如何使用临时渲染目标实现双缓冲交换，避免直接修改原始帧缓冲导致的问题</p>
<pre><code class="language-csharp">using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class CustomPostProcessPass : ScriptableRenderPass
{
    private Material m_Material;
    private RenderTargetHandle m_TemporaryColorTexture;
    private RenderTargetHandle m_CameraColorTexture;
    
    public CustomPostProcessPass(Material material)
    {
        m_Material = material;
        m_TemporaryColorTexture.Init("_TemporaryColorTexture");
    }

    public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
    {
        cmd.GetTemporaryRT(m_TemporaryColorTexture.id, cameraTextureDescriptor);
    }

    public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
    {
        CommandBuffer cmd = CommandBufferPool.Get("Custom Post Processing");
        
        // 双缓冲交换
        Blit(cmd, m_CameraColorTexture.Identifier(), 
            m_TemporaryColorTexture.Identifier(), m_Material);
        Blit(cmd, m_TemporaryColorTexture.Identifier(), 
            m_CameraColorTexture.Identifier());
            
        context.ExecuteCommandBuffer(cmd);
        CommandBufferPool.Release(cmd);
    }

    public override void FrameCleanup(CommandBuffer cmd)
    {
        cmd.ReleaseTemporaryRT(m_TemporaryColorTexture.id);
    }
}
</code></pre>
</li>
</ul>
<h2 id="自定义渲染目标双缓冲系统"><strong>自定义渲染目标双缓冲系统</strong></h2>
<ul>
<li>
<p>CustomBufferSystem.cs</p>
<p>实现了一个简单的双缓冲系统示例，可用于需要多帧数据累积的效果如运动模糊</p>
<pre><code class="language-csharp">
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class CustomBufferSystem
{
    private RenderTargetHandle[] m_Buffers = new RenderTargetHandle[2];
    private int m_CurrentBufferIndex = 0;
    
    public void Initialize(string name)
    {
        m_Buffers[0].Init(name + "_Buffer0");
        m_Buffers[1].Init(name + "_Buffer1");
    }

    public RenderTargetHandle GetCurrentBuffer()
    {
        return m_Buffers[m_CurrentBufferIndex];
    }

    public RenderTargetHandle GetNextBuffer()
    {
        return m_Buffers[(m_CurrentBufferIndex + 1) % 2];
    }

    public void Swap()
    {
        m_CurrentBufferIndex = (m_CurrentBufferIndex + 1) % 2;
    }

    public void Dispose(CommandBuffer cmd)
    {
        cmd.ReleaseTemporaryRT(m_Buffers[0].id);
        cmd.ReleaseTemporaryRT(m_Buffers[1].id);
    }
}
</code></pre>
</li>
</ul>
<h2 id="urp多相机渲染双缓冲同步"><strong>URP多相机渲染双缓冲同步</strong></h2>
<ul>
<li>
<p>MultiCameraRenderer.cs</p>
<p>多相机渲染场景中如何使用双缓冲机制实现平滑的相机切换效果</p>
<pre><code class="language-csharp">using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class MultiCameraRenderer : MonoBehaviour
{
    public Camera[] cameras;
    private RenderTexture[] buffers = new RenderTexture[2];
    private int currentBufferIndex = 0;
    
    void Start()
    {
        buffers[0] = new RenderTexture(Screen.width, Screen.height, 24);
        buffers[1] = new RenderTexture(Screen.width, Screen.height, 24);
    }

    void Update()
    {
        var renderer = (UniversalRenderPipelineAsset)GraphicsSettings.currentRenderPipeline;
        
        // 渲染到后台缓冲区
        int nextBufferIndex = (currentBufferIndex + 1) % 2;
        cameras[0].targetTexture = buffers[nextBufferIndex];
        
        // 交换缓冲区
        currentBufferIndex = nextBufferIndex;
        
        // 显示当前缓冲区
        Graphics.Blit(buffers[currentBufferIndex], null as RenderTexture);
    }
}
</code></pre>
</li>
</ul>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.003472222222222222" data-date-updated="2025-08-27 15:04">2025-08-27 14:59</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19061005);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19061005', targetLink: 'https://www.cnblogs.com/SmalBox/p/19061005', title: '【渲染流水线】[输出阶段]-[双缓冲机制]以UnityURP为例' })">举报</a>
</div>
        