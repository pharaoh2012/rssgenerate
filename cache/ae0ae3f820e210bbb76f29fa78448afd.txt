
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/liyongqiang-cc/p/18624782" title="发布于 2025-01-10 09:57">
    <span role="heading" aria-level="2">控制反转（Inversion of Control，IoC）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>依赖注入（Dependency Injection，DI）和控制反转（Inversion of Control，IoC）是软件工程中两个相关但不同的概念。它们都旨在提高代码的模块化、可维护性和可测试性，但它们的侧重点和实现方式有所不同。</p>
</blockquote>
<h2 id="控制反转inversion-of-controlioc">控制反转（Inversion of Control，IoC）</h2>
<p><strong>定义：</strong><br>
控制反转是一种设计原则，它将对象的创建和依赖关系的管理从对象本身转移到外部容器或框架中。简单来说，IoC 是一种思想，它将控制权从应用程序代码中反转到框架或容器中。</p>
<p><strong>核心思想：</strong></p>
<ul>
<li>传统的编程方式中，对象的创建和依赖关系的管理通常由对象本身负责。例如，一个对象 A 需要使用对象 B，那么对象 A 会直接创建对象 B 的实例。</li>
<li>在 IoC 中，对象的创建和依赖关系的管理被反转，由外部容器或框架来负责。对象 A 不再直接创建对象 B，而是通过容器或框架来获取对象 B 的实例。</li>
</ul>
<p><strong>举例说明：</strong><br>
假设我们有一个 <code>Car</code> 类，它依赖于 <code>Engine</code> 类。在传统的编程方式中，<code>Car</code> 类可能会直接创建 <code>Engine</code> 类的实例：</p>
<pre><code>public&nbsp;class&nbsp;Car
{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Engine&nbsp;_engine;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_engine&nbsp;=&nbsp;new&nbsp;Engine();&nbsp;&nbsp;//&nbsp;Car&nbsp;类直接创建&nbsp;Engine&nbsp;实例
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Start()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_engine.Start();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<p>在 IoC 中，<code>Car</code> 类不再直接创建 <code>Engine</code> 实例，而是通过外部容器或框架来获取 <code>Engine</code> 实例：</p>
<pre><code>public&nbsp;class&nbsp;Car&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Engine&nbsp;engine;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Car(Engine&nbsp;engine)&nbsp;{&nbsp;&nbsp;//&nbsp;通过构造函数注入&nbsp;Engine&nbsp;实例
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.engine&nbsp;=&nbsp;engine;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;start()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;engine.start();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<p>在这个例子中，<code>Car</code> 类不再负责创建 <code>Engine</code> 实例，而是通过构造函数从外部获取 <code>Engine</code> 实例。这就是控制反转的思想。</p>
<h2 id="依赖注入dependency-injectiondi">依赖注入（Dependency Injection，DI）</h2>
<p><strong>定义：</strong><br>
依赖注入是实现控制反转的一种具体方式。它通过将依赖对象注入到需要它们的对象中，来实现对象之间的解耦。</p>
<p><strong>核心思想：</strong></p>
<ul>
<li>依赖注入是一种技术，它通过构造函数、属性或方法参数等方式，将依赖对象注入到需要它们的对象中。</li>
<li>依赖注入使得对象之间的依赖关系更加灵活，便于测试和维护。</li>
</ul>
<p><strong>依赖注入的三种常见方式：</strong></p>
<h3 id="1-构造函数注入constructor-injection">1. 构造函数注入（Constructor Injection）</h3>
<h4 id="定义"><strong>定义：</strong></h4>
<p>构造函数注入是通过构造函数将依赖对象注入到目标对象中。这是最常见和推荐的方式，因为它使得依赖关系在对象创建时明确可见。</p>
<h4 id="特点"><strong>特点：</strong></h4>
<ul>
<li>依赖关系在对象创建时被注入。</li>
<li>目标对象的依赖关系在构造函数中声明，使得依赖关系清晰可见。</li>
<li>适用于必须的依赖项。</li>
</ul>
<pre><code>//&nbsp;定义接口
public&nbsp;interface&nbsp;IMyDependency
{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;PerformTask();
}

//&nbsp;实现接口
public&nbsp;class&nbsp;MyDependency&nbsp;:&nbsp;IMyDependency
{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;PerformTask()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Task&nbsp;performed.");
&nbsp;&nbsp;&nbsp;&nbsp;}
}

//&nbsp;使用构造函数注入
public&nbsp;class&nbsp;MyService
{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;readonly&nbsp;IMyDependency&nbsp;_myDependency;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;MyService(IMyDependency&nbsp;myDependency)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_myDependency&nbsp;=&nbsp;myDependency;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;DoWork()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_myDependency.PerformTask();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h3 id="2-属性注入setter-injection"><strong>2. 属性注入（Setter Injection）</strong></h3>
<h4 id="定义-1"><strong>定义：</strong></h4>
<p>属性注入是通过属性（或 setter 方法）将依赖对象注入到目标对象中。这种方式适用于可选的依赖项，即目标对象可以在没有依赖项的情况下正常工作。</p>
<h4 id="特点-1"><strong>特点：</strong></h4>
<ul>
<li>依赖关系通过属性或 setter 方法注入。</li>
<li>适用于可选的依赖项。</li>
<li>依赖关系不是在对象创建时注入，而是在对象创建后通过属性设置。</li>
</ul>
<pre><code>//&nbsp;定义接口和实现类同上

//&nbsp;使用属性注入
public&nbsp;class&nbsp;MyService
{
&nbsp;&nbsp;&nbsp;&nbsp;[Microsoft.Extensions.DependencyInjection.Inject]
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;IMyDependency&nbsp;MyDependency&nbsp;{&nbsp;get;&nbsp;set;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;DoWork()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyDependency.PerformTask();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h3 id="3-方法注入method-injection"><strong>3. 方法注入（Method Injection）</strong></h3>
<h4 id="定义-2"><strong>定义：</strong></h4>
<p>方法注入是通过方法参数将依赖对象注入到目标对象中。这种方式适用于依赖关系仅在特定方法中使用的情况。</p>
<h4 id="特点-2"><strong>特点：</strong></h4>
<ul>
<li>依赖关系通过方法参数注入。</li>
<li>适用于依赖关系仅在特定方法中使用的情况。</li>
<li>依赖关系的作用范围仅限于该方法。</li>
</ul>
<pre><code>//&nbsp;定义接口和实现类同上

//&nbsp;使用方法注入
public&nbsp;class&nbsp;MyService
{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;DoWork(IMyDependency&nbsp;myDependency)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myDependency.PerformTask();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h3 id="依赖注入di的优势">依赖注入（DI）的优势</h3>
<p>使用控制反转（IoC）和依赖注入（DI）的主要好处包括：</p>
<ol>
<li><strong>松耦合：</strong> 实现对象之间的解耦，提高代码的灵活性。</li>
<li><strong>可测试性：</strong> 通过依赖注入，可以轻松编写单元测试。</li>
<li><strong>可维护性：</strong> 代码更加清晰和易于维护。</li>
<li><strong>可扩展性：</strong> 系统更容易扩展和修改。</li>
<li><strong>集中管理依赖关系：</strong> 依赖关系在应用程序的启动阶段集中配置。</li>
<li><strong>提高代码的可读性和可理解性：</strong> 依赖关系显式声明，减少隐藏依赖。</li>
</ol>
<h2 id="总结">总结</h2>
<ul>
<li><strong>控制反转（IoC）</strong> 是一种设计原则，它将对象的创建和依赖关系的管理从对象本身转移到外部容器或框架中。IoC 是一种思想，它可以通过多种方式实现，包括依赖注入、服务定位器模式等。</li>
<li><strong>依赖注入（DI）</strong> 是实现控制反转的一种具体方式，它通过将依赖对象注入到需要它们的对象中，来实现对象之间的解耦。</li>
</ul>
<p>简单来说，IoC 是一个更广泛的概念，而 DI 是实现 IoC 的一种具体技术。通过使用 IoC 和 DI，我们可以编写更加模块化、可维护和可测试的代码，从而提高软件的质量和开发效率。<br>
<img src="https://img2024.cnblogs.com/blog/2063798/202501/2063798-20250110100424672-255135453.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4318432325752315" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-10 10:05">2025-01-10 09:57</span>&nbsp;
<a href="https://www.cnblogs.com/liyongqiang-cc">代码拾光</a>&nbsp;
阅读(<span id="post_view_count">136</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18624782" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18624782);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18624782', targetLink: 'https://www.cnblogs.com/liyongqiang-cc/p/18624782', title: '控制反转（Inversion of Control，IoC）' })">举报</a>
</div>
        