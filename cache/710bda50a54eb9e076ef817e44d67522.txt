
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Atserckcn/p/18717103" title="发布于 2025-02-15 16:14">
    <span role="heading" aria-level="2">分块</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="分块">分块</h2>
<p>特点：一种优雅的暴力，大段维护，小段朴素。</p>
<p>假设我们有一个长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(a\)</span>。</p>
<p>需要我们维护区间修改和区间查询等操作。</p>
<p>那么朴素算法就不用说了，如果是万能的线段树还行。但是线段树码量过大，容易出bug。</p>
<p><img src="https://pic1.imgdb.cn/item/67b00d18d0e0a243d4ff85fd.jpg" alt="" loading="lazy"></p>
<p>这个时候就得用到分块的思想。</p>
<h3 id="分块思想">分块思想：</h3>
<p>对于需要维护的数组 <span class="math inline">\(a\)</span>，将其分为 <span class="math inline">\(num\)</span> 块，每一块块长为 <span class="math inline">\(block\)</span>，然后对每一块进行维护，最后求解。</p>
<p>那么这个 <span class="math inline">\(block\)</span> 是多少好呢？</p>
<p>根据均值不等式，当 <span class="math inline">\(\frac{n}{block}=block\)</span>，即当 <span class="math inline">\(block=\sqrt{n}\)</span> 时最优，单次修改为 <span class="math inline">\(O(\sqrt{n})\)</span>。</p>
<p>显然有些情况下，<span class="math inline">\(n\mod block \neq 0\)</span>，即分完会有剩下的元素。那么很显然可以将块数 <span class="math inline">\(+1\)</span>，就当作是新建一块。</p>
<h3 id="对于每个块的维护">对于每个块的维护</h3>
<p>可以建立一个结构体来存放每一个快。</p>
<p>内存块的左端点、右端点、区间和。如果题目中有区间修改，那么类似的，放一个懒标记进去，表示该区间所有数都要加上多少。</p>
<p>对于第 <span class="math inline">\(i\)</span> 块 <span class="math inline">\((\forall\ 1\le i\le num)\)</span>：</p>
<p>左端点 <span class="math inline">\(=(i-1)\lfloor{\sqrt{n}}\rfloor+1\)</span>，右端点是 <span class="math inline">\(\min (i\lfloor{\sqrt{n}}\rfloor,n)\)</span>。因为有可能 <span class="math inline">\(n\mod block \neq 0\)</span>。</p>
<p>下面就是一个例子：</p>
<p><img src="https://pic1.imgdb.cn/item/67b01582d0e0a243d4ff88ca.png" alt="" loading="lazy"></p>
<p>其中：</p>
<p></p><div class="math display">\[(1\le i \le n)
\\ 
l_i=\left\{1,5,9,13,17\right\}
\\ 
r_i=\left\{4,8,12,16,17\right\}
\]</div><p></p><p>对于每个下标 <span class="math inline">\(i\)</span>，用 <span class="math inline">\(belong_i\)</span> 表示第 <span class="math inline">\(i\)</span> 号元素属于第 <span class="math inline">\(belong_i\)</span> 块。</p>
<h3 id="操作维护">操作维护</h3>
<p>设 <span class="math inline">\(l,r\)</span> 分别是增加区间的左右端点，增加 <span class="math inline">\(d\)</span>。</p>
<p>若 <span class="math inline">\(belong_l=belong_r\)</span>，即在同一个块中：</p>
<p>将所有的 <span class="math inline">\(a_i\)</span> 加上 <span class="math inline">\(d\)</span>，再将 <span class="math inline">\(sum_i\leftarrow sum_i+d(r-l+1)\)</span>。（<strong>小段朴素</strong>）</p>
<p>否则，设 <span class="math inline">\(belong_l=q,belong_r=p\)</span>：</p>
<p>对于区间 <span class="math inline">\([l,r_q]\)</span>​​，用同一个块中的方法进行维护。</p>
<p>即维护下图的区间 <span class="math inline">\([2,4]\)</span>。</p>
<p><img src="https://pic1.imgdb.cn/item/67b044c2d0e0a243d4ff935d.png" alt="" loading="lazy"></p>
<p>同理，也可以维护区间 <span class="math inline">\([l_p,r]\)</span>，即上图区间 <span class="math inline">\([13,14]\)</span>。</p>
<p>现在我们已经解决了区间 <span class="math inline">\([2,4]\)</span> 和 <span class="math inline">\([13,14]\)</span>，还剩下在两个区间中间的区间 <span class="math inline">\([5,8]\)</span> 和 <span class="math inline">\([9,12]\)</span>。</p>
<p>显然 <span class="math inline">\([5,8]\)</span> 和 <span class="math inline">\([9,12]\)</span> 是两个块，就将块的懒标记全部加上 <span class="math inline">\(d\)</span> 即可。</p>
<p>若不用懒标记，像小区间那样的朴素维护，很容易时间就超了。</p>
<h3 id="代码部分">代码部分</h3>
<p>例题：<a href="https://www.luogu.com.cn/problem/P3374" target="_blank" rel="noopener nofollow">P3374 【模板】树状数组 1</a>。</p>
<p>一个块的元素：</p>
<pre><code class="language-cpp">struct NODE{
		ljl l,r,sum;
	}node[N];
</code></pre>
<p>建立块：</p>
<pre><code class="language-cpp">void build()
	{
		block=floor(sqrt(n));
		num=n/block;
		if(n%block!=0) ++num;//不能分为整块
		for(ljl i=1;i&lt;=num;++i)
		{
			node[i].l=(i-1)*block+1,node[i].r=min(i*block,n);//公式已说
			for(ljl j=node[i].l;j&lt;=node[i].r;++j)
				node[i].sum+=a[j];
		}
//		for(ljl i=1;i&lt;=num;++i)
//			cout&lt;&lt;node[i].l&lt;&lt;' '&lt;&lt;node[i].r&lt;&lt;" "&lt;&lt;node[i].sum&lt;&lt;'\n';
		for(ljl i=1;i&lt;=n;++i)
			belong[i]=(i-1)/block+1;
		return;
	}
</code></pre>
<p>单点修改：</p>
<pre><code class="language-cpp">void update(ljl x,ljl y)
	{
		a[x]+=y;
		node[belong[x]].sum+=y;
		return;
	}
</code></pre>
<p>区间查询：</p>
<pre><code class="language-cpp">ljl query(ljl l,ljl r)
	{
		ljl q=belong[l],p=belong[r];
		if(q==p)
		{
			ljl ans=0;
			for(ljl i=l;i&lt;=r;++i)
				ans+=a[i];
			return ans;
		}
		ljl ans=0;
		for(ljl i=l;i&lt;=node[q].r;++i)
			ans+=a[i];
		for(ljl i=q+1;i&lt;=p-1;++i)
			ans+=node[i].sum;
		for(ljl i=node[p].l;i&lt;=r;++i)
			ans+=a[i];
		return ans;
	}
</code></pre>
<p>完整代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ljl long long
const ljl N=5e5+5;
ljl n,m,a[N],block;
namespace BLOCK{
	struct NODE{
		ljl l,r,sum;
	}node[N];
	ljl belong[N],num;
	void build()
	{
		block=floor(sqrt(n));
		num=n/block;
		if(n%block!=0) ++num;
		for(ljl i=1;i&lt;=num;++i)
		{
			node[i].l=(i-1)*block+1,node[i].r=min(i*block,n);
			for(ljl j=node[i].l;j&lt;=node[i].r;++j)
				node[i].sum+=a[j];
		}
//		for(ljl i=1;i&lt;=num;++i)
//			cout&lt;&lt;node[i].l&lt;&lt;' '&lt;&lt;node[i].r&lt;&lt;" "&lt;&lt;node[i].sum&lt;&lt;'\n';
		for(ljl i=1;i&lt;=n;++i)
			belong[i]=(i-1)/block+1;
		return;
	}
	void update(ljl x,ljl y)
	{
		a[x]+=y;
		node[belong[x]].sum+=y;
		return;
	}
	ljl query(ljl l,ljl r)
	{
		ljl q=belong[l],p=belong[r];
		if(q==p)
		{
			ljl ans=0;
			for(ljl i=l;i&lt;=r;++i)
				ans+=a[i];
			return ans;
		}
		ljl ans=0;
		for(ljl i=l;i&lt;=node[q].r;++i)
			ans+=a[i];
		for(ljl i=q+1;i&lt;=p-1;++i)
			ans+=node[i].sum;
		for(ljl i=node[p].l;i&lt;=r;++i)
			ans+=a[i];
		return ans;
	}
}
using namespace BLOCK;
int main(){
	ios::sync_with_stdio(0);
	cin&gt;&gt;n&gt;&gt;m;
	for(ljl i=1;i&lt;=n;++i)
		cin&gt;&gt;a[i];
	build();
//	for(ljl i=1;i&lt;=n;++i)
//		cout&lt;&lt;belong[i]&lt;&lt;' ';
//	cout&lt;&lt;"\n";
	while(m--)
	{
		ljl op,x,y;
		cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;
		if(op==1)
			update(x,y);
		else
		{
			cout&lt;&lt;query(x,y)&lt;&lt;'\n';
		}
//		cout&lt;&lt;"--------------\n";
//		for(ljl i=1;i&lt;=num;++i)
//			cout&lt;&lt;node[i].l&lt;&lt;" "&lt;&lt;node[i].r&lt;&lt;" "&lt;&lt;node[i].sum&lt;&lt;'\n';
//		cout&lt;&lt;"----------------\n";
	}
	return 0;
}
</code></pre>
<p>例题二：<a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener nofollow">P3372 【模板】线段树 1</a>。</p>
<p>因为上一题仅仅是单点修改，过于简单。</p>
<p>所以上强度：</p>
<p>本题需要区间修改和区间查询，具体看代码：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ljl long long
const ljl N=1e5+5,BLOCKS=1e3+5;
ljl n,a[N],q,l,r,v;
namespace BLOCK{
	struct NODE{
		ljl l,r,sum,lz;
	}node[BLOCKS];
	ljl belong[N],num,block;
	void build()//建块
	{
		block=(ljl)sqrt(n);
		num=n/block;
		if(n%block)++num;
		for(ljl i=1;i&lt;=num;++i)
		{
			node[i].l=(i-1)*block+1,node[i].r=min(i*block,n);
			for(ljl j=node[i].l;j&lt;=node[i].r;++j)
				node[i].sum+=a[j];
		}
		for(ljl i=1;i&lt;=n;++i)
			belong[i]=(i-1)/block+1;
		return;
	}
	void change_part(ljl id,ljl l,ljl r)//对于是一个块内的区间修改
	{
		for(ljl i=l;i&lt;=r;++i)
			a[i]+=v;
		node[id].sum+=v*(r-l+1);
	}
	void change(ljl l,ljl r)//询问的区间修改
	{
		ljl q=belong[l],p=belong[r];
		if(q==p)
		{
			change_part(q,l,r);return;
		}
		change_part(q,l,node[q].r);//按照上文讲过的方法实现即可
		change_part(p,node[p].l,r);
		for(ljl i=q+1;i&lt;p;++i)
			node[i].lz+=v;//这里是懒标记
		return;
	}
	ljl query_part(ljl id,ljl l,ljl r)
	{
		ljl ans=0;
		for(ljl i=l;i&lt;=r;++i)
			ans=ans+(a[i]+node[id].lz);
		return ans;
	}
	ljl query(ljl l,ljl r)
	{
		ljl q=belong[l],p=belong[r];
		if(q==p)
			return query_part(q,l,r);
		ljl ans=0;
		ans+=query_part(q,l,node[q].r);
		ans+=query_part(p,node[p].l,r);
		for(ljl i=q+1;i&lt;p;++i)
			ans=ans+node[i].sum+(node[i].r-node[i].l+1)*node[i].lz;
		return ans;		
	}
}
using namespace BLOCK;
int main(){
	ios::sync_with_stdio(0);
	cin&gt;&gt;n&gt;&gt;q;
	for(ljl i=1;i&lt;=n;++i)
		cin&gt;&gt;a[i];
	build();
	while(q--)
	{
		ljl op;
		cin&gt;&gt;op;
		if(op==1)
		{
			cin&gt;&gt;l&gt;&gt;r&gt;&gt;v;
			change(l,r);
		}
		else
		{
			cin&gt;&gt;l&gt;&gt;r;
			cout&lt;&lt;query(l,r)&lt;&lt;'\n';
		}
	}
	return 0;
}
</code></pre>
<h3 id="线段树和分块的比较">线段树和分块的比较：</h3>
<p>线段树1：</p>
<table>
<thead>
<tr>
<th></th>
<th>时间</th>
<th>空间</th>
<th>代码长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>分块</td>
<td>974ms</td>
<td>1.98MB</td>
<td>1.48KB</td>
</tr>
<tr>
<td>线段树</td>
<td>297ms</td>
<td>11.19MB</td>
<td>1.67KB</td>
</tr>
</tbody>
</table>
<p>树状数组1：</p>
<table>
<thead>
<tr>
<th></th>
<th>时间</th>
<th>空间</th>
<th>代码长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>分块</td>
<td>1.34s</td>
<td>9.55MB</td>
<td>1.40KB</td>
</tr>
<tr>
<td>树状数组</td>
<td>521ms</td>
<td>4.23MB</td>
<td>554B</td>
</tr>
</tbody>
</table>
<p>虽然分块不如线段树或树状数组，但是在不熟练他们俩的情况下可以使用分块，反正能A。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0015980557650462962" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-15 16:14">2025-02-15 16:14</span>&nbsp;
<a href="https://www.cnblogs.com/Atserckcn">Atserckcn</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18717103" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18717103);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18717103', targetLink: 'https://www.cnblogs.com/Atserckcn/p/18717103', title: '分块' })">举报</a>
</div>
        