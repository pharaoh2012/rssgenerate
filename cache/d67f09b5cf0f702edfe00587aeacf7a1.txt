
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fanliang11/p/18879298" title="发布于 2025-05-15 23:40">
    <span role="heading" aria-level="2">基于凯亚物联网平台优化内存和性能</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2>一、前言&nbsp;</h2>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为 surging 的版本都是基于dotnetty ，因为停更加上性能上的不稳定，让我和客户都很烦心，后面打算修改源码，但是我看了源码发现buffer,EventLoop内部封装都不是很好，很难进行修改，为了节约时间后面在github找到spannetty，然后下载源码，替换之后的引用发现性能上有了很大的进步，视频直播推流不卡顿，但是发现还是有内存泄漏的问题，然后通过dump文件修正了问题，然后我把网关访问的 JSON编解码组件由原来的Json.net 改成了system.text.json， 然后明天发布凯亚物联网测试版本提供下载，等后面做完北向输出将发布正式版本</p>
<p>HttpFlv:<a href="http://117.72.121.2:281/httpflv.html" rel="noopener nofollow" target="_blank">http://117.72.121.2:281/httpflv.html</a>&nbsp; <a target="_blank">（黑衣人）</a></p>
<p>&nbsp;HttpFlv:<a href="http://117.72.121.2:281/httpflv1.html" rel="noopener nofollow" target="_blank">http://117.72.121.2:281/httpflv1.html&nbsp;</a> <a target="_blank">（大红包）</a></p>
<p>rtmp:<a target="_blank">rtmp://117.72.121.2:76/live1/livestream2&nbsp;&nbsp; （黑衣人）</a></p>
<p>rtmp:<a target="_blank">rtmp://117.72.121.2:76/live1/livestream3&nbsp;&nbsp; （大红包）</a></p>
<p>&nbsp; 凯亚 (Kayak) 是什么?</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 凯亚(Kayak)是基于.NET6.0软件环境下的surging微服务引擎进行开发的, 平台包含了微服务和物联网平台。支持异步和响应式编程开发，功能包含了物模型,设备,产品,网络组件的统一管理和微服务平台下的注册中心，服务路由，模块，中间服务等管理。还有多协议适配(TCP,MQTT,UDP,CoAP,HTTP,Grpc,websocket,rtmp,httpflv,webservice,等),通过灵活多样的配置适配能够接入不同厂家不同协议等设备。并且通过设备告警,消息通知,数据可视化等功能。能够让你能快速建立起微服务物联网平台系统。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; 凯亚物联网平台：<a href="http://117.72.121.2:3100" rel="noopener nofollow" target="_blank">http://117.72.121.2:3100</a>（用户名：fanly&nbsp; 密码：123456）</p>
<p>&nbsp; &nbsp; 链路跟踪Skywalking V8:<a href="http://117.72.121.2:8080/" rel="noopener nofollow" target="_blank">http://117.72.121.2:8080/</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; surging 微服务引擎开源地址：<a href="https://github.com/fanliang11/surging" rel="noopener nofollow" target="_blank">https://github.com/fanliang11/surging</a>（后面surging 会移动到<a href="https://github.com/microsurging/" rel="noopener nofollow" target="_blank">microsurging</a>进行维护）</p>
<p>&nbsp;</p>
<h2>二、dump分析</h2>
<p>有了vs 就不需要什么windbg了，可视化界面寻找托管内存对象一目了然，首先看下dump 文件分析</p>
<p><strong>全部托管对象</strong></p>
<p>从托管对象来看，除了autofac, object[] ，byte[]，ArrayPool都很可疑，然后我们先来看看object[]，byte[]是什么玩意</p>
<p><img src="https://img2024.cnblogs.com/blog/192878/202505/192878-20250515230140812-666114575.png" alt="" loading="lazy"></p>
<p>&nbsp;看object[] 里面还有ArrayPool，这让我有怀疑对象了</p>
<p><img src="https://img2024.cnblogs.com/blog/192878/202505/192878-20250515230605614-1253210593.png" alt="" loading="lazy"></p>
<p>&nbsp;看byte[] 里面还有ArrayPool,在我印象当中，surging 只有httpkestrel 文件上传下载功能的时候，在StreamCopyOperation类中使用过，其它一概也没有使用，对于ArrayPool&lt;byte&gt;.Shared.Rent获取的buffer，我后面都&nbsp;ArrayPool&lt;byte&gt;.Shared.Return掉了啊。是不是dotnetty 出现的问题呢？然后我全局寻找到了，在ArrayPooled和ArrayPooledByteBuffer文件下buffer 没有return 还回去</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/192878/202505/192878-20250515230248519-1669024717.png" alt="" loading="lazy"></p>
<p>&nbsp;ArrayPooledByteBuffer文件</p>
<p><img src="https://img2024.cnblogs.com/blog/192878/202505/192878-20250515232135468-2115175815.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>ArrayPooled文件，这里没引用，应该没有对象调用，关键还是ArrayPooledByteBuffer</p>
<p><img src="https://img2024.cnblogs.com/blog/192878/202505/192878-20250515232119255-1657856615.png" alt="" loading="lazy"></p>
<p>&nbsp;还有DotNetty.Transport.Libuv.Native.Tcp 关闭的时候导致内存增加没有释放，因为是非托管资源，需要调用uv_close和强制垃圾回收 </p>
<h2>三、优化编解码</h2>
<p>因为surging 是支持通过接口代理和routepath 两种方式访问，因为网关在调用runtime时是不知道调用类型，所以传递返回的都是object ，所以内容必然是json&nbsp; 对象，所以必然需要JSON编解码组件，之前是Json.net ，后换成了system.text.json</p>
<p><img src="https://img2024.cnblogs.com/blog/192878/202505/192878-20250515232910287-1249388887.png" alt="" loading="lazy"></p>
<p>&nbsp;然后在httpkestrel的HttpMessageListener 类中，bodyParams也缓存了sytem.text.json ,以为解码返回的是object, 所以必然要写转换，object 转换代码如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> JsonElementJsonConverter : System.Text.Json.Serialization.JsonConverter&lt;<span style="color: rgba(0, 0, 255, 1)">object</span>&gt;<span style="color: rgba(0, 0, 0, 1)">
{
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">string</span> DateTimeFormat = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">yyyy-MM-dd HH:mm:ss</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">;

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">override</span> <span style="color: rgba(0, 0, 255, 1)">object</span> Read(<span style="color: rgba(0, 0, 255, 1)">ref</span><span style="color: rgba(0, 0, 0, 1)"> Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (reader.TokenType == JsonTokenType.String &amp;&amp; DateTime.TryParseExact(reader.GetString(), DateTimeFormat, CultureInfo.InvariantCulture, DateTimeStyles.None, <span style="color: rgba(0, 0, 255, 1)">out</span><span style="color: rgba(0, 0, 0, 1)"> DateTime dateTime))
        { 
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> dateTime;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">if</span>(reader.TokenType==<span style="color: rgba(0, 0, 0, 1)">JsonTokenType.String)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> reader.GetString();
        }

        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (reader.TokenType ==<span style="color: rgba(0, 0, 0, 1)"> JsonTokenType.Number)
        {
            </span><span style="color: rgba(0, 0, 255, 1)">var</span> num =<span style="color: rgba(0, 0, 0, 1)"> reader.GetDecimal();
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> num;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> JsonElement.ParseValue(<span style="color: rgba(0, 0, 255, 1)">ref</span><span style="color: rgba(0, 0, 0, 1)"> reader);
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">override</span> <span style="color: rgba(0, 0, 255, 1)">void</span> Write(Utf8JsonWriter writer, <span style="color: rgba(0, 0, 255, 1)">object</span><span style="color: rgba(0, 0, 0, 1)"> value, JsonSerializerOptions options)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">var</span> jsonEl =<span style="color: rgba(0, 0, 0, 1)"> (JsonElement)value;
        writer.WriteStringValue(jsonEl.ValueKind.ToString(DateTimeFormat));
    }
}</span></pre>
</div>
<p><span style="color: rgba(0, 0, 0, 1)">JsonOption</span> 代码</p>
<div class="cnblogs_code">
<pre> <span style="color: rgba(0, 0, 255, 1)">public</span>  <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> JsonOption
 {
     </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> JsonSerializerOptions SerializeOptions { <span style="color: rgba(0, 0, 255, 1)">get</span>; <span style="color: rgba(0, 0, 255, 1)">set</span>; } = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> JsonSerializerOptions()
     { 
         WriteIndented </span>= <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">,
         Converters </span>= { <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> JsonElementJsonConverter() }

     };
 }</span></pre>
</div>
<p>修改的代码如下图所示</p>
<p><img src="https://img2024.cnblogs.com/blog/192878/202505/192878-20250515233744800-1179046352.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.02645994945486111" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-15 23:41">2025-05-15 23:40</span>&nbsp;
<a href="https://www.cnblogs.com/fanliang11">fanly11</a>&nbsp;
阅读(<span id="post_view_count">3</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18879298);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18879298', targetLink: 'https://www.cnblogs.com/fanliang11/p/18879298', title: '基于凯亚物联网平台优化内存和性能' })">举报</a>
</div>
        