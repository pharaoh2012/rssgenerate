
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18725070" title="发布于 2025-02-19 19:30">
    <span role="heading" aria-level="2">JUC并发—7.AQS源码分析三</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="1" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="2"><strong>1.等待多线程完成的CountDownLatch介绍</strong></p>
<p data-track="3"><strong>2.CountDownLatch.await()方法源码</strong></p>
<p data-track="4"><strong>3.CountDownLatch.coutDown()方法源码</strong></p>
<p data-track="5"><strong>4.CountDownLatch总结</strong></p>
<p data-track="6"><strong>5.控制并发线程数的Semaphore介绍</strong></p>
<p data-track="7"><strong>6.Semaphore的令牌获取过程</strong></p>
<p data-track="8"><strong>7.Semaphore的令牌释放过程</strong></p>
<p data-track="9"><strong>8.同步屏障CyclicBarrier介绍</strong></p>
<p data-track="10"><strong>9.CyclicBarrier的await()方法源码</strong></p>
<p data-track="11"><strong>10.使用CountDownLatch等待注册的完成</strong></p>
<p data-track="12"><strong>11.使用CyclicBarrier将工作任务多线程分而治之</strong></p>
<p data-track="13"><strong>12.使用CyclicBarrier聚合服务接口的返回结果</strong></p>
<p data-track="14"><strong>13.使用Semaphore等待指定数量线程完成任务</strong></p>
<p data-track="15">&nbsp;</p>
<p data-track="16">volatile、synchronized、CAS、AQS、读写锁、锁优化和锁故障、并发集合、线程池、同步组件</p>
<p data-track="17">&nbsp;</p>
<p data-track="18"><strong>1.等待多线程完成的CountDownLatch</strong></p>
<p data-track="19"><strong>(1)CountDownLatch的简介</strong></p>
<p data-track="20"><strong>(2)CountDownLatch的应用</strong></p>
<p data-track="21"><strong>(3)CountDownLatch的例子</strong></p>
<p data-track="22">&nbsp;</p>
<p data-track="23"><strong>(1)CountDownLatch的简介</strong></p>
<p data-track="24">CountDownLatch允许一个或多个线程等待其他线程完成操作。CountDownLatch提供了两个核心方法，分别是await()方法和countDown()方法。CountDownLatch.await()方法让调用线程进行阻塞进入等待状态，CountDownLatch.countDown()方法用于对计数器进行递减。</p>
<p data-track="25">&nbsp;</p>
<p data-track="26">CountDownLatch在构造时需要传入一个正整数作为计数器初始值。线程每调用一次countDown()方法，都会对该计数器减一。当计数器为0时，会唤醒所有执行await()方法时被阻塞的线程。</p>
<p data-track="27">&nbsp;</p>
<p data-track="28"><strong>(2)CountDownLatch的应用</strong></p>
<p data-track="29"><strong>应用一：</strong></p>
<p data-track="30">使用多线程去解析一个Excel里多个sheet的数据，每个线程解析一个sheet里的数据，等所有sheet解析完再提示处理完成。此时便可以使用CountDownLatch来实现，当然可以使用Thread.join()方法。</p>
<p data-track="31">&nbsp;</p>
<p data-track="32">注意：Thread.join()方法是基于wait()和notify()来实现的。在main线程里开启一个线程A，main线程如果执行了线程A的join()方法，那么就会导致main线程被阻塞，main线程会等待线程A执行完毕才会继续往下执行。</p>
<p data-track="33">&nbsp;</p>
<p data-track="34"><strong>应用二：</strong></p>
<p data-track="35">微服务注册中心的register-client，为了在注册线程执行成功后，才发送心跳。可以使用CountDownLatch，当然也可以使用Thread.join()方法。</p>
<p data-track="36">&nbsp;</p>
<p data-track="37"><strong>应用三：</strong></p>
<p data-track="38">可以通过CountDownLatch实现类似并发的效果。把CountDownLatch的计数器设置为1，然后让1000个线程调用await()方法。当1000个线程初始化完成后，在main线程调用countDown()让计数器归零。这样这1000个线程就会在一个for()循环中，依次被唤醒。</p>
<p data-track="39">&nbsp;</p>
<p data-track="40"><strong>(3)CountDownLatch的例子</strong></p>
<pre class="highlighter-hljs"><code>public class CountDownLatchDemo {
    public static void main(String[] args) throws Exception {
        final CountDownLatch latch = new CountDownLatch(2);
        new Thread() {
            public void run() {
                try {
                    Thread.sleep(1000);
                    System.out.println("线程1开始执行，休眠2秒...");
                    Thread.sleep(1000);

                    System.out.println("线程1准备执行countDown操作...");
                    latch.countDown();

                    System.out.println("线程1完成执行countDown操作...");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }.start();

        new Thread() {
            public void run() {
                try {
                    Thread.sleep(1000);
                    System.out.println("线程2开始执行，休眠2秒...");
                    Thread.sleep(1000);

                    System.out.println("线程2准备执行countDown操作...");
                    latch.countDown();

                    System.out.println("线程2完成执行countDown操作...");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }.start();

        System.out.println("main线程准备执行countDownLatch的await操作，将会同步阻塞等待...");
        latch.await();
        System.out.println("所有线程都完成countDown操作，结束同步阻塞等待...");
    }
}</code></pre>
<p data-track="42">&nbsp;</p>
<p data-track="43"><strong>2.CountDownLatch.await()方法源码</strong></p>
<p data-track="44"><strong>(1)CountDownLatch.await()方法的阻塞流程</strong></p>
<p data-track="45"><strong>(2)CountDownLatch.await()方法的唤醒流程</strong></p>
<p data-track="46"><strong>(3)CountDownLatch.await()方法的阻塞总结</strong></p>
<p data-track="47">&nbsp;</p>
<p data-track="48"><strong>(1)CountDownLatch.await()方法的阻塞流程</strong></p>
<p data-track="49">CountDownLatch是基于AQS中的共享锁来实现的。从CountDownLatch的构造方法可知，CountDownLatch的count就是AQS的state。</p>
<p data-track="50">&nbsp;</p>
<p data-track="51">调用CountDownLatch的await()方法时，会先调用AQS的acquireSharedInterruptibly()模版方法，然后会调用CountDownLatch的内部类Sync实现的tryAcquireShared()方法。tryAcquireShared()方法会判断state的值是否为0，如果为0，才返回1，否则返回-1。</p>
<p data-track="52">&nbsp;</p>
<p data-track="53">当调用CountDownLatch内部类Sync的tryAcquireShared()方法获得的返回值是-1时，才会调用AQS的doAcquireSharedInterruptibly()方法，将当前线程封装成Node结点加入等待队列，然后挂起当前线程进行阻塞。</p>
<pre class="highlighter-hljs"><code>//A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.
public class CountDownLatch {
    private final Sync sync;
    
    public CountDownLatch(int count) {
        if (count &lt; 0) {
            throw new IllegalArgumentException("count &lt; 0");
        }
        this.sync = new Sync(count);
    }
    
    //Synchronization control For CountDownLatch.
    //Uses AQS state to represent count.
    private static final class Sync extends AbstractQueuedSynchronizer {
        Sync(int count) {
            setState(count);
        }
        
        int getCount() {
            return getState();
        }
        
        protected int tryAcquireShared(int acquires) {
            return (getState() == 0) ? 1 : -1;
        }
        
        protected boolean tryReleaseShared(int releases) {
            //Decrement count; signal when transition to zero
            for (;;) {
                int c = getState();
                if (c == 0) {
                    return false;
                }
                int nextc = c-1;
                if (compareAndSetState(c, nextc)) {
                    return nextc == 0;
                }
            }
        }
    }
    
    //Causes the current thread to wait until the latch has counted down to zero, 
    //unless the thread is Thread#interrupt interrupted.
    public void await() throws InterruptedException {
        //执行AQS的acquireSharedInterruptibly()方法
        sync.acquireSharedInterruptibly(1);
    }
    ...
}

public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
    ...
    //Acquires in shared mode, aborting if interrupted.
    //Implemented by first checking interrupt status, then invoking at least once #tryAcquireShared, returning on success.
    //Otherwise the thread is queued, possibly repeatedly blocking and unblocking,
    //invoking #tryAcquireShared until success or the thread is interrupted.
    public final void acquireSharedInterruptibly(int arg) throws InterruptedException {
        if (Thread.interrupted()) {
            throw new InterruptedException();
        }
        //执行CountDownLatch的内部类Sync实现的tryAcquireShared()方法，抢占共享锁
        if (tryAcquireShared(arg) &lt; 0) {
            //执行AQS的doAcquireSharedInterruptibly()方法
            doAcquireSharedInterruptibly(arg);
        }
    }
    
    //Acquires in shared interruptible mode.
    private void doAcquireSharedInterruptibly(int arg) throws InterruptedException {
        final Node node = addWaiter(Node.SHARED);//封装当前线程为Shared类型的Node结点
        boolean failed = true;
        try {
            //第一次循环r = -1，所以会执行AQS的shouldParkAfterFailedAcquire()方法
            //将node结点的有效前驱结点的状态设置为SIGNAL
            for (;;) {
                final Node p = node.predecessor();//node结点的前驱结点
                if (p == head) {
                    int r = tryAcquireShared(arg);
                    if (r &gt;= 0) {
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        failed = false;
                        return;
                    }
                }
                //执行shouldParkAfterFailedAcquire()方法设置node结点的前驱结点的状态为SIGNAL
                //执行parkAndCheckInterrupt()方法挂起当前线程
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) {
                    throw new InterruptedException();
                }
            }
        } finally {
            if (failed) {
                cancelAcquire(node);
            }
        }
    }
    
    //Checks and updates status for a node that failed to acquire.
    //Returns true if thread should block. This is the main signal control in all acquire loops.
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL) {
            //This node has already set status asking a release to signal it, so it can safely park.
            return true;
        }
        if (ws &gt; 0) {
            //Predecessor was cancelled. Skip over predecessors and indicate retry.
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &gt; 0);
            pred.next = node;
        } else {
            //waitStatus must be 0 or PROPAGATE.  
            //Indicate that we need a signal, but don't park yet.  
            //Caller will need to retry to make sure it cannot acquire before parking.
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
    
    //设置头结点和唤醒后续线程
    //Sets head of queue, and checks if successor may be waiting in shared mode, 
    //if so propagating if either propagate &gt; 0 or PROPAGATE status was set.
    private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head;
        setHead(node);//将node结点设置为头结点
        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) {
            Node s = node.next;
            if (s == null || s.isShared()) {
                doReleaseShared();
            }
        }
    }
    
    private void setHead(Node node) {
        head = node;
        node.thread = null;
        node.prev = null;
    }
    ...
}</code></pre>
<p data-track="55"><strong>(2)CountDownLatch.await()方法的唤醒流程</strong></p>
<p data-track="56">调用await()方法时，首先会将当前线程封装成Node结点并添加到等待队列中，然后在执行第一次for循环时会设置该Node结点的前驱结点状态为SIGNAL，接着在执行第二次for循环时才会将当前线程进行挂起阻塞。</p>
<p data-track="57">&nbsp;</p>
<p data-track="58">当该线程后续被唤醒时，该线程又会进入下一次for循环。如果该线程对应的node结点的前驱结点是等待队列的头结点且state值已为0，那么就执行AQS的setHeadAndPropagate()方法设置头结点 + 唤醒后续线程。</p>
<p data-track="59">&nbsp;</p>
<p data-track="60">其中setHeadAndPropagate()方法有两个工作(设置头结点 + 唤醒传递)：</p>
<p data-track="61">工作一：设置当前被唤醒线程对应的结点为头结点</p>
<p data-track="62">工作二：当满足如下这两个条件的时候需要调用doReleaseShared()方法唤醒后续的线程</p>
<p data-track="63">条件一：propagate &gt; 0，表示当前是共享锁，需要进行唤醒传递</p>
<p data-track="64">条件二：s.isShared()判断当前结点为共享模式</p>
<p data-track="65">&nbsp;</p>
<p data-track="66">CountDownLatch的实现中会在以下两个场景调用doReleaseShared()方法：</p>
<p data-track="67">场景一：state为1时调用的countDown()方法会调用doReleaseShared()方法</p>
<p data-track="68">场景二：当阻塞的线程被唤醒时，会调用setHeadAndPropagate()方法，进而调用doReleaseShared()方法，这样可以提升唤醒共享结点的速度</p>
<p data-track="69">&nbsp;</p>
<p data-track="70"><strong>(3)CountDownLatch.await()方法的阻塞总结</strong></p>
<p data-track="71">只要state != 0，就会进行如下处理：</p>
<p data-track="72">一.将当前线程封装成一个Node结点，然后添加到AQS的等待队列中</p>
<p data-track="73">二.调用LockSupport.park()方法，挂起当前线程</p>
<p data-track="74">&nbsp;</p>
<p data-track="75"><strong>3.CountDownLatch.coutDown()方法源码</strong></p>
<p data-track="76"><strong>(1)CountDownLatch.coutDown()的唤醒流程</strong></p>
<p data-track="77"><strong>(2)CountDownLatch.tryReleaseShared()</strong></p>
<p data-track="78"><strong>(3)AQS的doReleaseShared()方法</strong></p>
<p data-track="79">&nbsp;</p>
<p data-track="80"><strong>(1)CountDownLatch.coutDown()的唤醒流程</strong></p>
<p data-track="81">调用CountDownLatch的countDown()方法时，会先调用AQS的releaseShared()模版方法，然后会执行CountDownLatch的内部类Sync实现的tryReleaseShared()方法。</p>
<p data-track="82">&nbsp;</p>
<p data-track="83">如果tryReleaseShared()方法返回true，则执行AQS的doReleaseShared()方法，通过AQS的doReleaseShared()方法唤醒共享锁模式下的等待队列中的线程。</p>
<pre class="highlighter-hljs"><code>//A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.
public class CountDownLatch {
    private final Sync sync;
    
    public CountDownLatch(int count) {
        if (count &lt; 0) {
            throw new IllegalArgumentException("count &lt; 0");
        }
        this.sync = new Sync(count);
    }
    
    //Synchronization control For CountDownLatch.
    //Uses AQS state to represent count.
    private static final class Sync extends AbstractQueuedSynchronizer {
        Sync(int count) {
            setState(count);
        }
        
        int getCount() {
            return getState();
        }
        
        protected int tryAcquireShared(int acquires) {
            return (getState() == 0) ? 1 : -1;
        }
        
        protected boolean tryReleaseShared(int releases) {
            //Decrement count; signal when transition to zero
            for (;;) {
                int c = getState();
                if (c == 0) {
                    return false;
                }
                int nextc = c-1;
                if (compareAndSetState(c, nextc)) {
                    return nextc == 0;
                }
            }
        }
    }
           
    //Decrements the count of the latch, releasing all waiting threads if the count reaches zero.
    public void countDown() {
        //执行AQS的releaseShared()方法
        sync.releaseShared(1);
    }
    ...
}

public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
    ...
    //Releases in shared mode.  
    //Implemented by unblocking one or more threads if #tryReleaseShared returns true.
    public final boolean releaseShared(int arg) {
        //执行CountDownLatch的内部类Sync实现的tryReleaseShared()方法，释放共享锁
        if (tryReleaseShared(arg)) {
            //执行AQS的doReleaseShared()方法
            doReleaseShared();
            return true;
        }
        return false;
    }
    
    //Release action for shared mode -- signals successor and ensures propagation. 
    //Note: For exclusive mode, release just amounts to calling unparkSuccessor of head if it needs signal.
    private void doReleaseShared() {
        for (;;) {
            //每次循环时头结点都会发生变化
            //因为调用unparkSuccessor()方法会唤醒doAcquireSharedInterruptibly()方法中阻塞的线程
            //然后阻塞的线程会在执行setHeadAndPropagate()方法时通过setHead()修改头结点
            Node h = head;//获取最新的头结点
            if (h != null &amp;&amp; h != tail) {//等待队列中存在挂起线程的结点
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {//头结点的状态正常，表示对应的线程可以被唤醒
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) {
                        continue;//loop to recheck cases
                    }
                    //唤醒头结点的后继结点
                    //唤醒的线程会在doAcquireSharedInterruptibly()方法中执行setHeadAndPropagate()方法修改头结点
                    unparkSuccessor(h);
                } else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) {
                    //如果ws = 0表示初始状态，则修改结点为PROPAGATE状态
                    continue;//loop on failed CAS
                }
            }
            if (h == head) {//判断头结点是否有变化
                break;//loop if head changed
            }
        }
    }
    
    //Wakes up node's successor, if one exists.
    private void unparkSuccessor(Node node) {
        int ws = node.waitStatus;
        if (ws &lt; 0) {
            compareAndSetWaitStatus(node, ws, 0);
        }

        Node s = node.next;
        if (s == null || s.waitStatus &gt; 0) {
            s = null;
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) {
                if (t.waitStatus &lt;= 0) {
                    s = t;
                }
            }
        }
        if (s != null) {
            LockSupport.unpark(s.thread);
        }
    }
    ...
}</code></pre>
<p data-track="85"><strong>(2)CountDownLatch.tryReleaseShared()</strong></p>
<p data-track="86">从tryReleaseShared()方法可知：每次countDown()其实就是把AQS的state值减1，然后通过CAS更新state值。如果CAS设置成功，那么就判断当前state值是否为0。如果是0那么就返回true，如果不是0那么就返回false。返回true的时候会调用AQS的doReleaseShared()方法，唤醒等待队列中的线程。</p>
<p data-track="87">&nbsp;</p>
<p data-track="88"><strong>(3)AQS的doReleaseShared()方法</strong></p>
<p data-track="89">该方法要从AQS的等待队列中唤醒头结点的后继结点，需要满足：</p>
<p data-track="90">条件一：等待队列中要存在挂起线程的结点(h != null &amp;&amp; h != tail)</p>
<p data-track="91">条件二：等待队列的头结点的状态正常(h.waitStatus = Node.SIGNAL)</p>
<p data-track="92">&nbsp;</p>
<p data-track="93">在共享锁模式下，state为0时需要通过唤醒传递把所有挂起的线程都唤醒。首先doReleaseShared()方法会通过for(;;)进行自旋操作，每次循环都会通过Node h = head来获取等待队列中最新的头结点，然后通过if (h == head)来判断等待队列中的头结点是否发生变化。如果没有变化，则退出自旋。</p>
<p data-track="94">&nbsp;</p>
<p data-track="95">注意：在共享锁模式下，被unparkSuccessor()唤醒的等待队列中的线程，会继续在在doAcquireSharedInterruptibly()方法中，执行setHeadAndPropagate()方法修改头结点，从而实现唤醒传递。</p>
<p data-track="96">&nbsp;</p>
<p data-track="97"><strong>4.CountDownLatch总结</strong></p>
<p data-track="98">假设有两个线程A和B，分别调用了CountDownLatch的await()方法，此时state所表示的计数器不为0。所以线程A和B会被封装成SHARED类型的结点，并添加到AQS的等待队列中。</p>
<p data-track="99">&nbsp;</p>
<p data-track="100">当线程C调用CountDownLatch的coutDown()方法后，如果state被递减到0，那么就会调用doReleaseShared()方法唤醒等待队列中的线程。然后被唤醒的线程会继续调用setHeadAndPropagate()方法实现唤醒传递，从而继续在doReleaseShared()方法中唤醒所有在等待队列中的被阻塞的线程。</p>
<p data-track="101">&nbsp;</p>
<p data-track="102"><strong>5.控制并发线程数的Semaphore介绍</strong></p>
<p data-track="103"><strong>(1)Semaphore的作用</strong></p>
<p data-track="104"><strong>(2)Semaphore的方法</strong></p>
<p data-track="105"><strong>(3)Semaphore原理分析</strong></p>
<p data-track="106">&nbsp;</p>
<p data-track="107"><strong>(1)Semaphore的作用</strong></p>
<p data-track="108">Semaphore信号量用来控制同时访问特定资源的线程数量，有两核心方法。</p>
<p data-track="109">方法一：acquire()方法，获取一个令牌</p>
<p data-track="110">方法二：release()方法，释放一个令牌</p>
<p data-track="111">&nbsp;</p>
<p data-track="112">多个线程访问某限制访问流量的资源时，可先调用acquire()获取访问令牌。如果能够正常获得，则表示允许访问。如果令牌不够，则会阻塞当前线程。当某个获得令牌的线程通过release()方法释放一个令牌后，被阻塞在acquire()方法的线程就有机会获得这个释放的令牌。</p>
<pre class="highlighter-hljs"><code>public class SemaphoreDemo {
    public static void main(String[] args) throws InterruptedException {
        Semaphore semaphore = new Semaphore(10, true);//初始化10个资源，使用公平锁 
        semaphore.acquire();//每次获取一个资源，如果获取不到，线程就会阻塞
        semaphore.release();//释放一个资源
    }
}</code></pre>
<p data-track="114"><strong>(2)Semaphore的方法</strong></p>
<p data-track="115">Semaphore实际上并没有一个真实的令牌发给线程，Semaphore只是对一个可分配数量进行计数维护，或者说进行许可证管理。Semaphore可以在公共资源有限的场景下实现流量控制，如数据库连接。</p>
<pre class="highlighter-hljs"><code>一.Semaphore(permits, fair)：permits表示令牌数，fair表示公平性
二.acquire(permits)：获取指定数量的令牌，如果数量不足则阻塞当前线程
三.tryAcquire(permits)：尝试获取指定数量的令牌，此过程是非阻塞的，成功返回true，失败返回false 
四.release(permits)：释放指定数量的令牌
五.drainPermits()：当前线程获得剩下的所有令牌
六.hasQueuedThread()：判断当前Semaphore实例上是否存在等待令牌的线程</code></pre>
<p data-track="117"><strong>(3)Semaphore原理分析</strong></p>
<p data-track="118">Semaphore也是基于AQS中的共享锁来实现的。在创建Semaphore实例时传递的参数permits，其实就是AQS中的state属性。每次调用Semaphore的acquire()方法，都会对state值进行递减。</p>
<p data-track="119">&nbsp;</p>
<p data-track="120">所以从根本上说，Semaphore是通过重写AQS的两个方法来实现的：</p>
<p data-track="121">方法一：tryAcquireShared()，抢占共享锁</p>
<p data-track="122">方法二：tryReleaseShared()，释放共享锁</p>
<pre class="highlighter-hljs"><code>public class Semaphore implements java.io.Serializable {
    private final Sync sync;
    
    //Creates a Semaphore with the given number of permits and nonfair fairness setting.
    public Semaphore(int permits) {
        sync = new NonfairSync(permits);
    }
    
    static final class NonfairSync extends Sync {
        NonfairSync(int permits) {
            super(permits);
        }
        
        protected int tryAcquireShared(int acquires) {
            return nonfairTryAcquireShared(acquires);
        }
    }
    
    //Acquires a permit from this semaphore, blocking until one is available, 
    //or the thread is Thread#interrupt interrupted.
    public void acquire() throws InterruptedException {
        //执行AQS的模版方法acquireSharedInterruptibly()
        sync.acquireSharedInterruptibly(1);
    }
    
    //Releases a permit, returning it to the semaphore.
    public void release() {
        //执行AQS的模版方法releaseShared()
        sync.releaseShared(1);
    }
    
    //Synchronization implementation for semaphore.  
    //Uses AQS state to represent permits. Subclassed into fair and nonfair versions.
    abstract static class Sync extends AbstractQueuedSynchronizer {
        Sync(int permits) {
            //设置state的值为传入的令牌数
            setState(permits);
        }
        
        final int getPermits() {
            return getState();
        }
        
        final int nonfairTryAcquireShared(int acquires) {
            for (;;) {
                int available = getState();
                int remaining = available - acquires;
                if (remaining &lt; 0 || compareAndSetState(available, remaining)) {
                    return remaining;
                }
            }
        }
        
        protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                int current = getState();
                int next = current + releases;
                if (next &lt; current) {
                    throw new Error("Maximum permit count exceeded");
                }
                if (compareAndSetState(current, next)) {
                    return true;
                }
            }
        }
        ...
    }
    ...
}

public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
    ...
    //Acquires in shared mode, aborting if interrupted.
    //Implemented by first checking interrupt status, then invoking at least once #tryAcquireShared, returning on success.
    //Otherwise the thread is queued, possibly repeatedly blocking and unblocking,
    //invoking #tryAcquireShared until success or the thread is interrupted.
    public final void acquireSharedInterruptibly(int arg) throws InterruptedException {
        if (Thread.interrupted()) {
            throw new InterruptedException();
        }
        
        //执行Semaphore的内部类Sync的子类实现的tryAcquireShared()方法，抢占共享锁
        if (tryAcquireShared(arg) &lt; 0) {
            //执行AQS的doAcquireSharedInterruptibly()方法
            doAcquireSharedInterruptibly(arg);
        }
    }
    
    //Releases in shared mode.  
    //Implemented by unblocking one or more threads if #tryReleaseShared returns true.
    public final boolean releaseShared(int arg) {
        //执行Semaphore的内部类Sync实现的tryReleaseShared()方法，释放共享锁
        if (tryReleaseShared(arg)) {
            //执行AQS的doReleaseShared()方法
            doReleaseShared();
            return true;
        }
        return false;
    }
    ...
}</code></pre>
<p data-track="124">&nbsp;</p>
<p data-track="125"><strong>6.Semaphore的令牌获取过程</strong></p>
<p data-track="126"><strong>(1)Semaphore的令牌获取过程</strong></p>
<p data-track="127"><strong>(2)Semaphore的公平策略</strong></p>
<p data-track="128"><strong>(3)Semaphore的非公平策略</strong></p>
<p data-track="129"><strong>(4)tryAcquireShared()后的处理</strong></p>
<p data-track="130">&nbsp;</p>
<p data-track="131"><strong>(1)Semaphore的令牌获取过程</strong></p>
<p data-track="132">在调用Semaphore的acquire()方法获取令牌时：首先会执行AQS的模版方法acquireSharedInterruptibly()，然后执行Sync子类实现的tryAcquireShared()方法来抢占锁。如果抢占锁失败，则执行AQS的doAcquireSharedInterruptibly()方法。该方法会将当前线程封装成Node结点并加入等待队列，然后挂起线程。</p>
<p data-track="133">&nbsp;</p>
<p data-track="134"><strong>(2)Semaphore的公平策略</strong></p>
<p data-track="135">在执行Sync子类FairSync的tryAcquireShared()方法尝试获取令牌时，先通过AQS的hasQueuedPredecessors()判断是否已有线程在等待队列中。如果已经有线程在等待队列中，那么当前线程获取令牌就必然失败。否则，就递减state的值 + 判断state是否小于0 + CAS设置state的值。</p>
<p data-track="136">&nbsp;</p>
<p data-track="137"><strong>(3)Semaphore的非公平策略</strong></p>
<p data-track="138">在执行Sync子类NonfairSync的tryAcquireShared()方法尝试获取令牌时，则会直接执行Sync的nonfairTryAcquireShared()方法来获取令牌，也就是递减state的值 + 判断state是否小于0 + CAS设置state的值。</p>
<p data-track="139">&nbsp;</p>
<p data-track="140"><strong>(4)tryAcquireShared()后的处理</strong></p>
<p data-track="141">不管公平策略还是非公平策略，对应的tryAcquireShared()方法都是通过自旋来抢占令牌(CAS设置state)，直到令牌数不够时才会让tryAcquireShared()方法返回小于0的数值。然后触发执行AQS的doAcquireSharedInterruptibly()方法，该方法会将当前线程封装成Node结点并加入等待队列，然后挂起线程。</p>
<pre class="highlighter-hljs"><code>public class Semaphore implements java.io.Serializable {
    private final Sync sync;
    
    //Creates a Semaphore with the given number of permits and nonfair fairness setting.
    public Semaphore(int permits) {
        sync = new NonfairSync(permits);
    }
    
    static final class NonfairSync extends Sync {
        NonfairSync(int permits) {
            super(permits);
        }
        
        //以非公平锁的方式获取令牌
        protected int tryAcquireShared(int acquires) {
            //执行Sync的nonfairTryAcquireShared()方法
            return nonfairTryAcquireShared(acquires);
        }
    }
    
    static final class FairSync extends Sync {
        FairSync(int permits) {
            super(permits);
        }
        
        //以公平锁的方式获取令牌
        protected int tryAcquireShared(int acquires) {
            for (;;) {
                //如果已经有线程在等待队列中，那么就说明获取令牌必然失败
                if (hasQueuedPredecessors()) {
                    return -1;
                }
                int available = getState();
                int remaining = available - acquires;
                if (remaining &lt; 0 || compareAndSetState(available, remaining)) {
                    return remaining;
                }
            }
        }
    }
    
    //Acquires a permit from this semaphore, blocking until one is available, 
    //or the thread is Thread#interrupt interrupted.
    public void acquire() throws InterruptedException {
        //执行AQS的模版方法acquireSharedInterruptibly()
        sync.acquireSharedInterruptibly(1);
    }
    
    //Synchronization implementation for semaphore.  
    //Uses AQS state to represent permits. Subclassed into fair and nonfair versions.
    abstract static class Sync extends AbstractQueuedSynchronizer {
        Sync(int permits) {
            //设置state的值为传入的令牌数
            setState(permits);
        }
        
        final int getPermits() {
            return getState();
        }
        
        final int nonfairTryAcquireShared(int acquires) {
            for (;;) {
                int available = getState();
                int remaining = available - acquires;
                if (remaining &lt; 0 || compareAndSetState(available, remaining)) {
                    return remaining;
                }
            }
        }
        ...
    }
    ...
}


public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
    ...
    //Acquires in shared mode, aborting if interrupted.
    //Implemented by first checking interrupt status, then invoking at least once #tryAcquireShared, returning on success.
    //Otherwise the thread is queued, possibly repeatedly blocking and unblocking,
    //invoking #tryAcquireShared until success or the thread is interrupted.
    public final void acquireSharedInterruptibly(int arg) throws InterruptedException {
        if (Thread.interrupted()) {
            throw new InterruptedException();
        }
        
        //执行Semaphore的内部类Sync的子类实现的tryAcquireShared()方法，抢占共享锁
        if (tryAcquireShared(arg) &lt; 0) {
            //执行AQS的doAcquireSharedInterruptibly()方法
            doAcquireSharedInterruptibly(arg);
        }
    }
    
    //Queries whether any threads have been waiting to acquire longer than the current thread.
    public final boolean hasQueuedPredecessors() {
        Node t = tail; // Read fields in reverse initialization order
        Node h = head;
        Node s;
        return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());
    }
    
    //Acquires in shared interruptible mode.
    private void doAcquireSharedInterruptibly(int arg) throws InterruptedException {
        final Node node = addWaiter(Node.SHARED);//封装当前线程为Shared类型的Node结点
        boolean failed = true;
        try {
            //第一次循环r = -1，所以会执行AQS的shouldParkAfterFailedAcquire()方法
            //将node结点的有效前驱结点的状态设置为SIGNAL
            for (;;) {
                final Node p = node.predecessor();//node结点的前驱结点
                if (p == head) {
                    int r = tryAcquireShared(arg);
                    if (r &gt;= 0) {
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        failed = false;
                        return;
                    }
                }
                //执行shouldParkAfterFailedAcquire()方法设置node结点的前驱结点的状态为SIGNAL
                //执行parkAndCheckInterrupt()方法挂起当前线程
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) {
                    throw new InterruptedException();
                }
            }
        } finally {
            if (failed) {
                cancelAcquire(node);
            }
        }
    }
    ...
}</code></pre>
<p data-track="143">&nbsp;</p>
<p data-track="144"><strong>7.Semaphore的令牌释放过程</strong></p>
<p data-track="145"><strong>(1)Semaphore的令牌释放过程</strong></p>
<p data-track="146"><strong>(2)Semaphore的令牌释放本质</strong></p>
<p data-track="147">&nbsp;</p>
<p data-track="148"><strong>(1)Semaphore的令牌释放过程</strong></p>
<p data-track="149">在调用Semaphore的release()方法去释放令牌时：首先会执行AQS的模版方法releaseShared()，然后执行Sync实现的tryReleaseShared()方法来释放锁(累加state值)。如果释放锁成功，则执行AQS的doReleaseShared()方法去唤醒线程。</p>
<p data-track="150">&nbsp;</p>
<p data-track="151"><strong>(2)Semaphore的令牌释放本质</strong></p>
<p data-track="152">Semaphore的release()方法释放令牌的本质就是对state字段进行累加，然后唤醒等待队列头结点的后继结点 + 唤醒传递来唤醒等待的线程。</p>
<p data-track="153">&nbsp;</p>
<p data-track="154">注意：并非一定要执行acquire()方法的线程才能调用release()方法，任意一个线程都可以调用release()方法，也可以通过reducePermits()方法来减少令牌数。</p>
<pre class="highlighter-hljs"><code>public class Semaphore implements java.io.Serializable {
    private final Sync sync;
    
    //Creates a Semaphore with the given number of permits and nonfair fairness setting.
    public Semaphore(int permits) {
        sync = new NonfairSync(permits);
    }
    
    //Releases a permit, returning it to the semaphore.
    public void release() {
        //执行AQS的模版方法releaseShared()
        sync.releaseShared(1);
    }
    
    //Synchronization implementation for semaphore.  
    //Uses AQS state to represent permits. Subclassed into fair and nonfair versions.
    abstract static class Sync extends AbstractQueuedSynchronizer {
        Sync(int permits) {
            //设置state的值为传入的令牌数
            setState(permits);
        }
        
        //尝试释放锁，也就是对state值进行累加
        protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                int current = getState();
                int next = current + releases;
                if (next &lt; current) {
                    throw new Error("Maximum permit count exceeded");
                }
                if (compareAndSetState(current, next)) {
                    return true;
                }
            }
        }
        ...
    }
    ...
}


public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
    ...    
    //Releases in shared mode.  
    //Implemented by unblocking one or more threads if #tryReleaseShared returns true.
    public final boolean releaseShared(int arg) {
        //执行Semaphore的内部类Sync实现的tryReleaseShared()方法，释放共享锁
        if (tryReleaseShared(arg)) {
            //执行AQS的doReleaseShared()方法，唤醒等待队列中的线程
            doReleaseShared();
            return true;
        }
        return false;
    }
    
    //Release action for shared mode -- signals successor and ensures propagation. 
    //Note: For exclusive mode, release just amounts to calling unparkSuccessor of head if it needs signal.
    private void doReleaseShared() {
        for (;;) {
            //每次循环时头结点都会发生变化
            //因为调用unparkSuccessor()方法会唤醒doAcquireSharedInterruptibly()方法中阻塞的线程
            //然后阻塞的线程会在执行setHeadAndPropagate()方法时通过setHead()修改头结点
            Node h = head;//获取最新的头结点
            if (h != null &amp;&amp; h != tail) {//等待队列中存在挂起线程的结点
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {//头结点的状态正常，表示对应的线程可以被唤醒
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) {
                        continue;//loop to recheck cases
                    }
                    //唤醒头结点的后继结点
                    //唤醒的线程会在doAcquireSharedInterruptibly()方法中执行setHeadAndPropagate()方法修改头结点
                    unparkSuccessor(h);
                } else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) {
                    //如果ws = 0表示初始状态，则修改结点为PROPAGATE状态
                    continue;//loop on failed CAS
                }
            }
            if (h == head) {//判断头结点是否有变化
                break;//loop if head changed
            }
        }
    }
    
    //Wakes up node's successor, if one exists.
    private void unparkSuccessor(Node node) {
        int ws = node.waitStatus;
        if (ws &lt; 0) {
            compareAndSetWaitStatus(node, ws, 0);
        }

        Node s = node.next;
        if (s == null || s.waitStatus &gt; 0) {
            s = null;
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) {
                if (t.waitStatus &lt;= 0) {
                    s = t;
                }
            }
        }
        if (s != null) {
            LockSupport.unpark(s.thread);
        }
    }
    ...
}</code></pre>
<p data-track="156">&nbsp;</p>
<p data-track="157"><strong>8.同步屏障CyclicBarrier介绍</strong></p>
<p data-track="158"><strong>(1)CyclicBarrier的作用</strong></p>
<p data-track="159"><strong>(2)CyclicBarrier的基本原理</strong></p>
<p data-track="160">&nbsp;</p>
<p data-track="161"><strong>(1)CyclicBarrier的作用</strong></p>
<p data-track="162">CyclicBarrier的字面意思就是可循环使用的屏障。CyclicBarrier的主要作用就是让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时屏障才会打开，接着才让所有被屏障拦截的线程一起继续往下执行。线程进入屏障是通过CyclicBarrier的await()方法来实现的。</p>
<p data-track="163">&nbsp;</p>
<p data-track="164"><strong>(2)CyclicBarrier的基本原理</strong></p>
<p data-track="165">假设有3个线程在运行中都会调用CyclicBarrier的await()方法，而每个线程从开始执行到执行await()方法所用时间可能不一样，最终当执行时间最长的线程到达屏障时，会唤醒其他较早到达屏障的线程继续往下执行。</p>
<p data-track="166">&nbsp;</p>
<p data-track="167">CyclicBarrier包含两个层面的意思：</p>
<p data-track="168">一是Barrier屏障点，线程调用await()方法都会阻塞在屏障点，直到所有线程都到达屏障点后再放行。</p>
<p data-track="169">二是Cyclic循环，当所有线程通过当前屏障点后，又可以进入下一轮的屏障点进行等待，可以不断循环。</p>
<p data-track="170">&nbsp;</p>
<p data-track="171"><strong>9.CyclicBarrier的await()方法源码</strong></p>
<p data-track="172"><strong>(1)CyclicBarrier的成员变量</strong></p>
<p data-track="173"><strong>(2)CyclicBarrier的await()方法源码</strong></p>
<p data-track="174"><strong>(3)CountDownLatch和CyclicBarrier对比</strong></p>
<p data-track="175">&nbsp;</p>
<p data-track="176"><strong>(1)CyclicBarrier的成员变量</strong></p>
<pre class="highlighter-hljs"><code>//A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.  
//CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. 
//The barrier is called cyclic because it can be re-used after the waiting threads are released.
public class CyclicBarrier {
    ...
    private static class Generation {
        boolean broken = false;
    }
    
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition trip = lock.newCondition();//用于线程之间相互唤醒
    private final int parties;//参与的线程数量
    private int count;//初始值是parties，每调用一次await()就减1
    private final Runnable barrierCommand;//回调任务
    private Generation generation = new Generation();
    ...
}</code></pre>
<p data-track="178">CyclicBarrier是基于ReentrantLock + Condition来实现的。</p>
<p data-track="179">&nbsp;</p>
<p data-track="180">parties表示每次要求到达屏障点的线程数，只有到达屏障点的线程数满足指定的parties数量，所有线程才会被唤醒。</p>
<p data-track="181">&nbsp;</p>
<p data-track="182">count是一个初始值为parties的计数器，每个线程调用await()方法会对count减1，当count为0时会唤醒所有线程，并且结束当前的屏障周期generation，然后所有线程进入下一个屏障周期，而且count会恢复成parties。</p>
<p data-track="183">&nbsp;</p>
<p data-track="184"><strong>(2)CyclicBarrier的await()方法源码</strong></p>
<p data-track="185">线程调用CyclicBarrier的await()方法时，会触发调用CyclicBarrier的dowait()方法。</p>
<p data-track="186">&nbsp;</p>
<p data-track="187">CyclicBarrier的dowait()方法会对count计数器进行递减。如果count递减到0，则会调用CyclicBarrier的nextGeneration()唤醒所有线程，同时如果异步回调任务barrierCommand不为空，则会执行该任务。如果count还没递减到0，则调用Condition的await()方法阻塞当前线程。</p>
<p data-track="188">&nbsp;</p>
<p data-track="189">被阻塞的线程，除了会被CyclicBarrier的nextGeneration()方法唤醒外，还会被Thread的interrupt()方法唤醒、被中断异常唤醒，而这些唤醒会调用CyclicBarrier的breakBarrier()方法。</p>
<p data-track="190">&nbsp;</p>
<p data-track="191">在CyclicBarrier的nextGeneration()方法和CyclicBarrier的breakBarrier()方法中，都会通过Condition的signalAll()方法唤醒所有被阻塞等待的线程。</p>
<pre class="highlighter-hljs"><code>//A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.  
//CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. 
//The barrier is called cyclic because it can be re-used after the waiting threads are released.
public class CyclicBarrier {
    ...
    private static class Generation {
        boolean broken = false;//用来标记屏障是否被中断
    }
    
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition trip = lock.newCondition();//用于线程之间相互唤醒
    private final int parties;//参与的线程数量
    private int count;//初始值是parties，每调用一次await()就减1
    private final Runnable barrierCommand;//回调任务
    private Generation generation = new Generation();
    
    public CyclicBarrier(int parties, Runnable barrierAction) {
        if (parties &lt;= 0) throw new IllegalArgumentException();
        this.parties = parties;
        this.count = parties;
        this.barrierCommand = barrierAction;
    }

    public CyclicBarrier(int parties) {
        this(parties, null);
    }

    //Waits until all #getParties have invoked await on this barrier.
    public int await() throws InterruptedException, BrokenBarrierException {
        try {
            //执行CyclicBarrier的dowait()方法
            return dowait(false, 0L);
        } catch (TimeoutException toe) {
            throw new Error(toe);
        }
    }
    
    //Main barrier code, covering the various policies.
    private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException {
        final ReentrantLock lock = this.lock;
        lock.lock();//使用Condition需要先获取锁
        try {
            //获取当前的generation
            final Generation g = generation;
            //确认当前generation的barrier是否有效，如果generation的broken为true，则抛出屏障中断异常
            if (g.broken) {
                throw new BrokenBarrierException();
            }
            if (Thread.interrupted()) {
                breakBarrier();
                throw new InterruptedException();
            }
            //统计已经到达当前generation的线程数量
            int index = --count;
            //如果index为0，则表示所有线程都到达了屏障点
            if (index == 0) {
                boolean ranAction = false;
                try {
                    final Runnable command = barrierCommand;
                    if (command != null) {
                        //触发回调
                        command.run();
                    }
                    ranAction = true;
                    //执行nextGeneration()方法唤醒所有线程，同时进入下一个屏障周期
                    nextGeneration();
                    return 0;
                } finally {
                    if (!ranAction) {
                        breakBarrier();
                    }
                }
            }
            //loop until tripped, broken, interrupted, or timed out
            //如果index &gt; 0，则阻塞当前线程
            for (;;) {
                try {
                    if (!timed) {
                        //通过Condition的await()方法，在阻塞当前线程的同时释放锁
                        //这样其他线程就能获取到锁执行上面的index = --count
                        trip.await();
                    } else if (nanos &gt; 0L) {
                        nanos = trip.awaitNanos(nanos);
                    }
                } catch (InterruptedException ie) {
                    if (g == generation &amp;&amp; ! g.broken) {
                        breakBarrier();
                        throw ie;
                    } else {
                        Thread.currentThread().interrupt();
                    }
                }
                if (g.broken) {
                    throw new BrokenBarrierException();
                }
                if (g != generation) {
                    return index;
                }
                if (timed &amp;&amp; nanos &lt;= 0L) {
                    //中断屏障，设置generation.broken为true
                    breakBarrier();
                    throw new TimeoutException();
                }
            }
        } finally {
            lock.unlock();
        }
    }
    
    //Updates state on barrier trip and wakes up everyone.
    //Called only while holding lock.
    private void nextGeneration() {
        //通过Condition的signalAll()唤醒所有等待的线程
        trip.signalAll();
        //还原count
        count = parties;
        //进入新的generation
        generation = new Generation();
    }
    
    //Sets current barrier generation as broken and wakes up everyone.
    //Called only while holding lock.
    private void breakBarrier() {
        generation.broken = true;
        count = parties;
        //通过Condition的signalAll()唤醒所有等待的线程
        trip.signalAll();
    }
    ...
}</code></pre>
<p data-track="193"><strong>(3)CountDownLatch和CyclicBarrier对比</strong></p>
<p data-track="194">一.CyclicBarrier可以被重用、可以响应中断</p>
<p data-track="195">二.CountDownLatch的计数器只能使用一次，但可以通过reset()方法重置</p>
<p data-track="196">&nbsp;</p>
<p data-track="197"><strong>10.使用CountDownLatch等待注册的完成</strong></p>
<p data-track="198">Hadoop HDFS(分布式存储系统)的NameNode分为主备两个节点，各个DataNode在启动时都会向两个NameNode进行注册，此时就可以使用CountDownLatch等待向主备节点注册的完成。</p>
<pre class="highlighter-hljs"><code>//DataNode启动类
public class DataNode {
    //是否还在运行
    private volatile Boolean shouldRun;
  
    //负责和一组NameNode(主NameNode + 备NameNode)通信的组件
    private NameNodeGroupOfferService offerService;
    
    //初始化DataNode
    private void initialize() {
        this.shouldRun = true;
        this.offerService = new NameNodeGroupOfferService();
        this.offerService.start();  
    }
    
    //运行DataNode
    private void run() {
        try {
            while(shouldRun) {
                Thread.sleep(10000);  
            }   
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
  
    public static void main(String[] args) {
        DataNode datanode = new DataNode();
        datanode.initialize();
        datanode.run(); 
    }
}


//负责某个NameNode进行通信的线程组件
public class NameNodeServiceActor {
    //向某个NameNode进行注册
    public void register(CountDownLatch latch) {
        Thread registerThread = new RegisterThread(latch);
        registerThread.start(); 
    }
    
    //负责注册的线程，传入一个CountDownLatch
    class RegisterThread extends Thread {
        CountDownLatch latch;
      
        public RegisterThread(CountDownLatch latch) {
            this.latch = latch;
        }
      
        @Override
        public void run() {
            try {
                //发送rpc接口调用请求到NameNode去进行注册
                System.out.println("发送请求到NameNode进行注册...");
                Thread.sleep(1000);  
                latch.countDown();  
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

//负责跟一组NameNode(主NameNode + 备NameNode)进行通信的线程组件
public class NameNodeGroupOfferService {
    //负责跟NameNode主节点通信的ServiceActor组件
    private NameNodeServiceActor activeServiceActor;
  
    //负责跟NameNode备节点通信的ServiceActor组件
    private NameNodeServiceActor standbyServiceActor;
    
    //构造函数
    public NameNodeGroupOfferService() {
        this.activeServiceActor = new NameNodeServiceActor();
        this.standbyServiceActor = new NameNodeServiceActor();
    }
    
    //启动OfferService组件
    public void start() {
        //直接使用两个ServiceActor组件分别向主备两个NameNode节点进行注册
        register();
    }
    
    //向主备两个NameNode节点进行注册
    private void register() {
        try {
            CountDownLatch latch = new CountDownLatch(2);  
            this.activeServiceActor.register(latch); 
            this.standbyServiceActor.register(latch); 
            latch.await();//阻塞等待主备都完成注册
            System.out.println("主备NameNode全部注册完毕...");
        } catch (Exception e) {
            e.printStackTrace();  
        }
    }
}</code></pre>
<p data-track="200">&nbsp;</p>
<p data-track="201"><strong>11.使用CyclicBarrier将工作任务多线程分而治之</strong></p>
<pre class="highlighter-hljs"><code>//输出结果：
//线程1执行自己的一部分工作...
//线程2执行自己的一部分工作...
//线程3执行自己的一部分工作...
//所有线程都完成自己的任务，可以合并结果了...
//最终结果合并完成，线程3可以退出...
//最终结果合并完成，线程1可以退出...
//最终结果合并完成，线程2可以退出...
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        final CyclicBarrier barrier = new CyclicBarrier(3, new Runnable() {
            public void run() {
                System.out.println("所有线程都完成自己的任务，可以合并结果了...");
            }
        });
        new Thread() {
            public void run() {
                try {
                    System.out.println("线程1执行自己的一部分工作...");
                    barrier.await();
                    System.out.println("最终结果合并完成，线程1可以退出...");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }.start();
        new Thread() {
            public void run() {
                try {
                    System.out.println("线程2执行自己的一部分工作...");
                    barrier.await();
                    System.out.println("最终结果合并完成，线程2可以退出...");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }.start();
        new Thread() {
            public void run() {
                try {
                    System.out.println("线程3执行自己的一部分工作...");
                    barrier.await();
                    System.out.println("最终结果合并完成，线程3可以退出...");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }.start();
    }
}</code></pre>
<p data-track="203">&nbsp;</p>
<p data-track="204"><strong>12.使用CyclicBarrier聚合服务接口的返回结果</strong></p>
<p data-track="205">当然也可以使用CountDownLatch来实现聚合服务接口的返回结果；</p>
<pre class="highlighter-hljs"><code>public class ApiServiceDemo {
    public Map&lt;String, Object&gt; queryOrders() throws Exception {
        final List&lt;Object&gt; results = new ArrayList&lt;Object&gt;();
        final Map&lt;String, Object&gt; map = new ConcurrentHashMap&lt;String, Object&gt;();
        CyclicBarrier barrier = new CyclicBarrier(3, new Runnable() {
            @Override
            public void run() {
                map.put("price", results.get(0));   
                map.put("order", results.get(1)); 
                map.put("stats", results.get(2));  
            }
        });
        //请求价格接口
        new Thread() {
            public void run() {
                try {
                    System.out.println("请求价格服务..."); 
                    Thread.sleep(1000);  
                    results.add(new Object());    
                    barrier.await();
                } catch (Exception e) {
                    e.printStackTrace();  
                } 
            };
        }.start();
        //请求订单接口
        new Thread() {
            public void run() {
                try {
                    System.out.println("请求订单服务..."); 
                    Thread.sleep(1000);  
                    results.add(new Object());    
                    barrier.await();
                } catch (Exception e) {
                    e.printStackTrace();  
                } 
            };
        }.start();
        //请求统计接口
        new Thread() {
            public void run() {
                try {
                    System.out.println("请求订单统计服务..."); 
                    Thread.sleep(1000);  
                    results.add(new Object());    
                    barrier.await();
                } catch (Exception e) {
                    e.printStackTrace();  
                } 
            };
        }.start();
        while(map.size() &lt; 3) {
            Thread.sleep(100);  
        }
        return map;
    }
}</code></pre>
<p data-track="207">&nbsp;</p>
<p data-track="208"><strong>13.使用Semaphore等待指定数量线程完成任务</strong></p>
<p data-track="209">可以通过Semaphore实现等待指定数量的线程完成任务才往下执行。</p>
<pre class="highlighter-hljs"><code>//输出结果如下：
//线程2执行一个计算任务
//等待1个线程完成任务即可...
//线程1执行一个计算任务
public class SemaphoreDemo {
    public static void main(String[] args) throws Exception {
        final Semaphore semaphore = new Semaphore(0);
        new Thread() {
            public void run() {
                try {
                    Thread.sleep(2000);
                    System.out.println("线程1执行一个计算任务");
                    semaphore.release();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }.start();

        new Thread() {
            public void run() {
                try {
                    Thread.sleep(1000);
                    System.out.println("线程2执行一个计算任务");
                    semaphore.release();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }.start();

        semaphore.acquire(1);
        System.out.println("等待1个线程完成任务即可...");
    }
}</code></pre>
<p data-track="210">&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.037240122346064816" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-19 19:31">2025-02-19 19:30</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">5</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18725070" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18725070);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18725070', targetLink: 'https://www.cnblogs.com/mjunz/p/18725070', title: 'JUC并发—7.AQS源码分析三' })">举报</a>
</div>
        