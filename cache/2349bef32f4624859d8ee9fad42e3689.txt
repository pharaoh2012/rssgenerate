
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Easun-Dongyang/p/19026812" title="发布于 2025-08-07 15:26">
    <span role="heading" aria-level="2">ZYNQ linux上使用 USB CDC ACM</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="一usb-cdc-acm介绍">一、USB CDC ACM介绍</h1>
<p>USB CDC ACM 是 USB 通信设备类(CDC)中的一个子类，它提供了一种通过 USB 接口实现虚拟串行通信的标准方法。</p>
<h2 id="1-基本概念">1. 基本概念</h2>
<p>CDC ACM 是 USB 规范中定义的一种设备类协议，它模拟传统的串行端口通信，提供双向数据传输通道，支持控制信号（如 RTS/CTS、DTR/DSR 等，是 USB 转串口设备的常用实现方式。</p>
<h2 id="2-主要特点">2. 主要特点</h2>
<p>标准化：遵循 USB-IF 定义的 CDC 规范</p>
<p>兼容性：大多数操作系统内置驱动支持</p>
<p>灵活性：可以在不同硬件平台上实现</p>
<p>多功能：支持数据和控制通道分离</p>
<h2 id="3-技术架构">3. 技术架构</h2>
<p>CDC ACM 包含两个主要接口：</p>
<h3 id="31-通信接口communication-interface">3.1 通信接口(Communication Interface)</h3>
<p>管理设备控制和状态</p>
<p>包含中断端点(Interrupt Endpoint)</p>
<p>处理线路编码、控制信号等</p>
<h3 id="32-数据接口data-interface">3.2 数据接口(Data Interface)</h3>
<p>处理实际数据传输</p>
<p>包含批量输入和输出端点(Bulk In/Out Endpoints)</p>
<p>实现数据流传输</p>
<h1 id="二-linux-usb-gadget驱动框架">二、 Linux-USB Gadget驱动框架</h1>
<p>在ZYNQ等ARM板卡上移植好linux内核后，就可以通过linux USB Gadget驱动框架实现USB CDC类。</p>
<p>USB Gadget 框架是 Linux 内核中实现 USB 设备功能的子系统，它允许嵌入式设备作为 USB 从设备(Peripheral)与主机通信。</p>
<p>在 ZYNQ 7000系列SOC上，存在两个USB2.0接口，支持USB HOST和USB OTG。</p>
<p>笔者板卡（正点原子 ZYNQ7035）上的 USB HOST 接口与 USB OTG 接口（也称 USB Slave 接口）共用了YNQ PS 端的 USB0 接口，所以在正常情况下，USB HOST 和 USB OTG 不能同时工作，所</p>
<p>以在 Z100 底板上有一组跳线帽端子 J15 用于控制 USB HOST 和 USB OTG 哪个接口工作。</p>
<p>对于USB OTG 接口工作：</p>
<p>需要通过两个跳线帽将 J15 端子的 DN 与 SN 相连、DP 与 SP 相连，注意先连接 DN 与SN。</p>
<h1 id="三vivado工程配置">三、vivado工程配置</h1>
<p>在block design中，添加ZYNQ7 PS后使能USB0接口，并选择对应的MIO接口：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3539410/202508/3539410-20250807144333152-2010187430.png" class="lazyload"><br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3539410/202508/3539410-20250807144414484-168726788.png" class="lazyload"><br>
设置完成后，重新生成xsa文件。</p>
<h1 id="四设备树配置">四、设备树配置</h1>
<p>在vivado中使能USB0配置后，在PCW.dtsi设备树文件中关于usb0的节点status 属性就被设置为"okay"了，</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3539410/202508/3539410-20250807144710096-112022849.png" class="lazyload"></p>
<p>所以由此可以知道，其实 pcw.dtsi 文件中已经使能了 usb0，但是目前还是不能使用 usb0的，还需要为 usb0 节点添加一下属性内容，打开 arch/arm/boot/dts/system-user.dtsi 设备树文件，</p>
<p>添加相关内容。首先需要在 system-user.dtsi 设备树根节点下添加一个 usb_phy0 节点，用于描述 USB phy相关信息，如下所示：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3539410/202508/3539410-20250807144929244-2140906849.png" class="lazyload"></p>
<p>其中，dr_mode可以是OTG，也可以为peripheral</p>
<p>system-user.dtsi 设备树文件修改完成之后，保存退出！然后在内核源码根文件目录下执行下面这条命令编译设备树文件：</p>
<p><code>make dtbs</code></p>
<p>将编译得到的 system-top.dtb 文件重命名为 system.dtb，将 system.dtb 文件拷贝到开发板SD 启动卡的第一个分区，替换掉就的设备树文件。</p>
<h1 id="五内核配置">五、内核配置</h1>
<p>USB 的HOST在linux内核中是默认配置的，但是CDC是没有默认开启的，因此需要配置内核相关配置。</p>
<p>在内核源码根文件夹下执行：</p>
<p><code>make menuconfig</code><br>
配置路径为：<br>
Device Drivers ---&gt;<br>
[<em>] USB support ---&gt;<br>
&lt;</em>&gt; USB Gadget Support ---&gt;<br>
&lt;*&gt; USB Gadget precomposed configurations ---&gt;<br>
勾选以下配置：<br>
<img alt="20250807-145703" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3539410/202508/3539410-20250807145752400-382564257.jpg" class="lazyload"></p>
<p><img alt="20250807-145717" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3539410/202508/3539410-20250807145826764-513535300.jpg" class="lazyload"></p>
<p>配置好后， save 并退出，重新编译下内核：</p>
<p><code>make -j8</code><br>
编译成功后会在arch/arm/boot下生成zImage内核镜像，将该文件拷贝至U盘的vfat分区（boot）。</p>
<p>同时会生成相关驱动，目录如下：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3539410/202508/3539410-20250807150249063-1618003424.png" class="lazyload"><br>
将以下驱动拷贝至vfat分区目录下：</p>
<p><code>g_serial.ko, libcomposite.ko, usb_f_acm.ko, usb_f_obex.ko, usb_f_serial.ko, u_serial.ko.</code></p>
<p>并启动Linux,按顺序加载前面生成的驱动模块：出现以下信息代表驱动挂载成功了：</p>
<p><img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3539410/202508/3539410-20250807150838492-933761958.png" class="lazyload"></p>
<p>此时打开设备文件发现多了/dev/ttyGS0设备，这个就是虚拟的串口设备。<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3539410/202508/3539410-20250807150950062-861617286.png" class="lazyload"></p>
<h1 id="六读写测试">六、读写测试</h1>
<p>将板卡上的usb slave接口链接电脑，这时候在windows的设备管理器中发现这个USB设备：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3539410/202508/3539410-20250807151141412-249179796.png" class="lazyload"></p>
<h2 id="61-终端写">6.1 终端写</h2>
<p>在电脑上通过串口工具（如xcom）打开该设备，并在ZYNQ终端中输入发送测试命令：<br>
echo hello，this is usb cdc acm device &gt; /dev/ttyGS0`</p>
<p>在串口工具成功接收到该信息：<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3539410/202508/3539410-20250807151516178-1211014313.png" class="lazyload"></p>
<h2 id="62-终端读">6.2 终端读</h2>
<p>在ZYNQ终端通过cat监听该USB的接收信息，在串口工具，发送任意字符，并勾选发送新行（这里笔者猜测是终端的内核缓冲区机制，\n会让内核接收的信息刷新出来）。否则可能不会在终端打印出来<br>
<img alt="image" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3539410/202508/3539410-20250807152545902-1347084814.png" class="lazyload"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-07 15:27">2025-08-07 15:26</span>&nbsp;
<a href="https://www.cnblogs.com/Easun-Dongyang">羊的第七章</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19026812);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19026812', targetLink: 'https://www.cnblogs.com/Easun-Dongyang/p/19026812', title: 'ZYNQ linux上使用 USB CDC ACM' })">举报</a>
</div>
        