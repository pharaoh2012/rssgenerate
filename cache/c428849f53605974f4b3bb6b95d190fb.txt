
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/one966/p/18637558" title="发布于 2024-12-28 15:42">
    <span role="heading" aria-level="2">多播委托</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div class="lake-content">
<p id="u951605d6" class="ne-p">&nbsp;</p>
<h2 id="e4568847"><span class="ne-text">引言</span></h2>
<p id="uab782497" class="ne-p"><span class="ne-text">在 C# 中，委托（Delegate）是一种类型安全的函数指针，允许将方法作为参数传递。多播委托（Multicast Delegate）则是可以调用多个方法的委托实例。本文将详细介绍多播委托的概念、使用场景以及如何在实际开发中应用多播委托。</span></p>
<h2 id="bbd761f2"><span class="ne-text">什么是委托？</span></h2>
<h3 id="953fc003"><span class="ne-text">委托的基本概念</span></h3>
<p id="ub058a1cf" class="ne-p"><span class="ne-text">委托是 C# 中的一种类型，它封装了对具有特定参数列表和返回类型的静态或实例方法的引用。通过委托，你可以将方法作为参数传递给其他方法，从而实现回调机制。</span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">// 定义一个委托类型
public delegate void MyDelegate(string message);

// 定义两个符合委托签名的方法
public void Method1(string message)
{
    Console.WriteLine("Method1: " + message);
}

public void Method2(string message)
{
    Console.WriteLine("Method2: " + message);
}
</pre>
</div>
<p>　</p>
<h3 id="7da477d7"><span class="ne-text">创建和使用委托实例</span></h3>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">public class Program
{
    public static void Main()
    {
        // 创建委托实例并绑定方法
        MyDelegate del = new MyDelegate(Method1);
        
        // 调用委托
        del("Hello, World!");
    }
}
</pre>
</div>
<p>　　</p>
<h2 id="d2d16ff6"><span class="ne-text">什么是多播委托？</span></h2>
<h3 id="734cb3d5"><span class="ne-text">多播委托的概念</span></h3>
<p id="u7c33fb42" class="ne-p"><span class="ne-text">多播委托是指可以调用多个方法的委托实例。当调用多播委托时，它会依次调用所有绑定的方法。C# 中的所有委托都是多播委托，即使它们只绑定了一个方法。</span></p>
<h3 id="af2d3cfc"><span class="ne-text">创建多播委托</span></h3>
<p id="uf57b3d77" class="ne-p"><span class="ne-text">可以通过<span class="ne-text"> <code class="ne-code"><span class="ne-text">+</span></code><span class="ne-text"> <span class="ne-text">操作符将多个方法绑定到同一个委托实例上，形成多播委托。</span></span></span></span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">public class Program
{
    public static void Main()
    {
        // 创建委托实例并绑定第一个方法
        MyDelegate del = new MyDelegate(Method1);
        
        // 使用 + 操作符添加第二个方法
        del += new MyDelegate(Method2);
        
        // 调用多播委托
        del("Hello, World!");
    }
}</pre>
</div>
<h3 id="b86f2306"><span class="ne-text">输出结果</span></h3>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">Method1: Hello, World!
Method2: Hello, World!
</pre>
</div>
<p>　　</p>
<pre class="ne-codeblock language-plain" data-language="plain"><code>&nbsp;</code></pre>
<h2 id="51b96597"><span class="ne-text">多播委托的特性</span></h2>
<h3 id="f0623668"><span class="ne-text">方法调用顺序</span></h3>
<p id="u2ec1c5e5" class="ne-p"><span class="ne-text">多播委托中的方法按它们被添加的顺序依次调用。如果需要改变调用顺序，可以通过重新组合委托实例来实现。</span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">public class Program
{
    public static void Main()
    {
        MyDelegate del1 = new MyDelegate(Method1);
        MyDelegate del2 = new MyDelegate(Method2);
        
        // 组合委托实例
        MyDelegate combinedDel = del2 + del1;
        
        // 调用组合后的委托
        combinedDel("Hello, World!");
    }
}</pre>
</div>
<h3 id="6ea5c1d9"><span class="ne-text">移除方法</span></h3>
<p id="u4ba8005b" class="ne-p"><span class="ne-text">可以通过<span class="ne-text"> <code class="ne-code"><span class="ne-text">-</span></code><span class="ne-text"> <span class="ne-text">操作符从多播委托中移除某个方法。</span></span></span></span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">public class Program
{
    public static void Main()
    {
        MyDelegate del = new MyDelegate(Method1) + new MyDelegate(Method2);
        
        // 移除 Method1
        del -= new MyDelegate(Method1);
        
        // 调用委托
        del("Hello, World!");
    }
}
</pre>
</div>
<p>　</p>
<h3 id="bb25466d"><span class="ne-text">空委托检查</span></h3>
<p id="u2fc08caf" class="ne-p"><span class="ne-text">在调用多播委托之前，最好检查其是否为<span class="ne-text"> <code class="ne-code"><span class="ne-text">null</span></code><span class="ne-text">，以避免空引用异常。</span></span></span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">public class Program
{
    public static void Main()
    {
        MyDelegate del = null;
        
        // 检查委托是否为 null
        if (del != null)
        {
            del("Hello, World!");
        }
        else
        {
            Console.WriteLine("No methods to invoke.");
        }
    }
}</pre>
</div>
<h2 id="9287c424"><span class="ne-text">多播委托的应用场景</span></h2>
<h3 id="fc47a070"><span class="ne-text">事件处理</span></h3>
<p id="ucd3a8124" class="ne-p"><span class="ne-text">多播委托最常见的应用场景之一是事件处理。C# 的事件机制基于多播委托，允许多个订阅者响应同一事件。</span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">using System;

public class Publisher
{
    // 定义事件
    public event EventHandler&lt;MyEventArgs&gt; MyEvent;

    // 触发事件的方法
    public void TriggerEvent()
    {
        OnMyEvent(new MyEventArgs { Message = "Event Triggered" });
    }

    // 保护方法用于触发事件
    protected virtual void OnMyEvent(MyEventArgs e)
    {
        MyEvent?.Invoke(this, e);
    }
}

public class Subscriber
{
    public void HandleEvent(object sender, MyEventArgs e)
    {
        Console.WriteLine($"Subscriber received: {e.Message}");
    }
}

public class MyEventArgs : EventArgs
{
    public string Message { get; set; }
}

public class Program
{
    public static void Main()
    {
        var publisher = new Publisher();
        var subscriber1 = new Subscriber();
        var subscriber2 = new Subscriber();

        // 订阅事件
        publisher.MyEvent += subscriber1.HandleEvent;
        publisher.MyEvent += subscriber2.HandleEvent;

        // 触发事件
        publisher.TriggerEvent();
    }
}
</pre>
</div>
<p>　　</p>
<pre class="ne-codeblock language-plain" data-language="plain"><code>&nbsp;</code></pre>
<h3 id="eb63c10e"><span class="ne-text">日志记录</span></h3>
<p id="u83d12512" class="ne-p"><span class="ne-text">多播委托也可以用于日志记录系统，允许多个日志记录器同时处理日志消息。</span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">public delegate void Logger(string message);

public class FileLogger
{
    public void LogToFile(string message)
    {
        Console.WriteLine($"Logged to file: {message}");
    }
}

public class ConsoleLogger
{
    public void LogToConsole(string message)
    {
        Console.WriteLine($"Logged to console: {message}");
    }
}

public class Program
{
    public static void Main()
    {
        Logger logger = new Logger(new FileLogger().LogToFile);
        logger += new Logger(new ConsoleLogger().LogToConsole);

        logger("This is a log message.");
    }
}
</pre>
</div>
<p>　　</p>
<h3 id="517b4ad6"><span class="ne-text">所有委托都是<span class="ne-text"> <code class="ne-code"><span class="ne-text">MulticastDelegate</span></code><span class="ne-text"> <span class="ne-text">吗？</span></span></span></span></h3>
<p id="u457946be" class="ne-p"><span class="ne-text">在 C# 中，<span class="ne-text">所有委托类型实际上都继承自<span class="ne-text"> <code class="ne-code"><span class="ne-text">MulticastDelegate</span></code><span class="ne-text"> <span class="ne-text">类<span class="ne-text">。这意味着从技术上讲，所有的委托实例都可以被视为多播委托（Multicast Delegate），即使它们只绑定了一个方法。然而，这并不意味着每个委托实例都会实际绑定多个方法。</span></span></span></span></span></span></p>
<h4 id="9a3cfebd"><span class="ne-text">1.<span class="ne-text"> <span class="ne-text">委托的底层实现</span></span></span></h4>
<p id="uc33e43d3" class="ne-p"><span class="ne-text">C# 的委托是基于<span class="ne-text"> <code class="ne-code"><span class="ne-text">System.MulticastDelegate</span></code><span class="ne-text"> <span class="ne-text">类实现的。<code class="ne-code"><span class="ne-text">MulticastDelegate</span></code><span class="ne-text"> <span class="ne-text">继承自<span class="ne-text"> <code class="ne-code"><span class="ne-text">System.Delegate</span></code><span class="ne-text">，并添加了对多播支持的功能。因此，任何通过<span class="ne-text"> <code class="ne-code"><span class="ne-text">delegate</span></code><span class="ne-text"> <span class="ne-text">关键字定义的委托类型，其实例都可以包含多个方法调用列表（即调用链）。</span></span></span></span></span></span></span></span></span></span></span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">public delegate void MyDelegate(string message);
</pre>
</div>
<p>　　</p>
<p id="u2c31905f" class="ne-p"><span class="ne-text">上述代码定义了一个名为<span class="ne-text"> <code class="ne-code"><span class="ne-text">MyDelegate</span></code><span class="ne-text"> <span class="ne-text">的委托类型，它实际上继承自<span class="ne-text"> <code class="ne-code"><span class="ne-text">MulticastDelegate</span></code><span class="ne-text">。</span></span></span></span></span></span></p>
<h4 id="4786d1b5"><span class="ne-text">2.<span class="ne-text"> <span class="ne-text">单播委托 vs 多播委托</span></span></span></h4>
<ul class="ne-ul" data-index-type="true">
<li id="u0c56030b" data-lake-index-type="true"><span class="ne-text">单播委托<span class="ne-text">：当一个委托实例只绑定一个方法时，我们通常称之为单播委托。虽然它是<span class="ne-text"> <code class="ne-code"><span class="ne-text">MulticastDelegate</span></code><span class="ne-text"> <span class="ne-text">的实例，但它的调用链中只有一个方法。</span></span></span></span></span></li>
</ul>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">MyDelegate del = new MyDelegate(Method1);</pre>
</div>
<ul class="ne-ul" data-index-type="true">
<li id="u51930c1c" data-lake-index-type="true"><span class="ne-text">多播委托<span class="ne-text">：当一个委托实例绑定多个方法时，我们称之为多播委托。这些方法会按顺序依次调用。</span></span></li>
</ul>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">MyDelegate del = new MyDelegate(Method1) + new MyDelegate(Method2);</pre>
</div>
<h4 id="44b34b88"><span class="ne-text">3.<span class="ne-text"> <span class="ne-text">为什么说所有委托都是<span class="ne-text"> <code class="ne-code"><span class="ne-text">MulticastDelegate</span></code><span class="ne-text">？</span></span></span></span></span></h4>
<p id="ue7ffc902" class="ne-p"><span class="ne-text">从类层次结构的角度来看，所有委托类型都继承自<span class="ne-text"> <code class="ne-code"><span class="ne-text">MulticastDelegate</span></code><span class="ne-text">，因此它们具备多播的能力。但这并不意味着每个委托实例都会实际使用这一能力。你可以选择性地将多个方法绑定到一个委托实例上，也可以只绑定一个方法。</span></span></span></p>
<h4 id="5cf2148e"><span class="ne-text">4.<span class="ne-text"> <span class="ne-text">验证委托类型</span></span></span></h4>
<p id="u3fea957b" class="ne-p"><span class="ne-text">你可以通过反射来验证这一点：</span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">using System;

public class Program
{
    public static void Main()
    {
        // 定义一个委托类型
        public delegate void MyDelegate(string message);

        // 创建委托实例
        MyDelegate del = new MyDelegate(Method1);

        // 检查委托类型
        Console.WriteLine(del.GetType().BaseType);  // 输出: System.MulticastDelegate
    }

    public static void Method1(string message)
    {
        Console.WriteLine("Method1: " + message);
    }
}
</pre>
</div>
<p>　　</p>
<p id="u369e7a3e" class="ne-p"><span class="ne-text">输出结果：</span></p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:true;">System.MulticastDelegate
</pre>
</div>
<p>　　</p>
<h4 id="0cd99f59"><span class="ne-text">5.<span class="ne-text"> <span class="ne-text">总结</span></span></span></h4>
<ul class="ne-ul" data-index-type="true">
<li id="u7da4c3f8" data-lake-index-type="true"><span class="ne-text">所有委托类型都继承自<span class="ne-text"> <code class="ne-code"><span class="ne-text">MulticastDelegate</span></code><span class="ne-text">，因此理论上所有委托实例都可以作为多播委托使用。</span></span></span></li>
<li id="u917c313c" data-lake-index-type="true"><span class="ne-text">实际使用中<span class="ne-text">，委托实例可以是单播或多播，取决于你是否将多个方法绑定到同一个委托实例上。</span></span></li>
<li id="udf8ac9fc" data-lake-index-type="true"><span class="ne-text">灵活性<span class="ne-text">：这种设计提供了极大的灵活性，允许你在需要时轻松扩展委托的功能，而无需改变委托类型的定义。</span></span></li>
</ul>
<h2 id="25f9c7fa"><span class="ne-text">总结</span></h2>
<p id="u471348c6" class="ne-p"><span class="ne-text">多播委托是 C# 中一种强大的功能，允许你将多个方法绑定到同一个委托实例上，并按顺序调用这些方法。它们广泛应用于事件处理、日志记录等场景，简化了代码逻辑并提高了灵活性。通过本文的介绍，希望你能更好地理解和应用多播委托，提升你的 C# 编程技能。</span></p>
<p id="u36e8c640" class="ne-p"><span class="ne-text">&nbsp;</span></p>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="7.02432315875" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-28 15:43">2024-12-28 15:42</span>&nbsp;
<a href="https://www.cnblogs.com/one966">一半春风</a>&nbsp;
阅读(<span id="post_view_count">76</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18637558" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18637558);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18637558', targetLink: 'https://www.cnblogs.com/one966/p/18637558', title: '多播委托' })">举报</a>
</div>
        