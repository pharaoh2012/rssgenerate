
		<div class="posthead">
			<h2>
				<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/jionsoft/p/18675990" title="发布于 2025-01-17 00:57">
    <span role="heading" aria-level="2">.net工作流elsa-触发器</span>
    

</a>

			</h2>
 			Posted on 
<span id="post-date" data-last-update-days="1.3943713550590278" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-17 01:11">2025-01-17 00:57</span>&nbsp;
<a href="https://www.cnblogs.com/jionsoft">变形精怪</a>&nbsp;
阅读(<span id="post_view_count">383</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18675990" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18675990);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18675990', targetLink: 'https://www.cnblogs.com/jionsoft/p/18675990', title: '.net工作流elsa-触发器' })">举报</a>

			
			
		</div>
		<div class="postbody"><div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1 id="section">必备知识</h1>
<p id="pragma-line-1">触发器会用到书签和调度，这个在我的另外两篇文章中有分析。</p>
<h1 id="section-1"><a id="pragma-line-3"></a>什么是触发器</h1>
<p id="pragma-line-4">可以直接调用流程引擎的IWorkflowRuntime获取IWorkflowClient，然后调用它的CreateAndRunInstanceAsync来启动一个全新的流程。</p>
<p id="pragma-line-6">也可以让流程引擎监听一个事件，当事件触发时，自动创建并执行（或借助书签恢复）一个流程实例，这就是触发器。<br>比如 定义一个触发器，当指定文件变化时，自动启动一个指定的流程。 再比如 定义一个触发器，每隔5分钟自动触发执行某个流程。</p>
<h1 id="section-2"><a id="pragma-line-10"></a>在流程定义中配置触发器</h1>
<p id="pragma-line-11">elsa提供代码或可视化设计器的方式定义流程，由于触发器仅仅是一个特殊的Activity，所以一样的，通过代码或在设计器拖拽触发器到流程定义中即可。</p>
<p id="pragma-line-13">不同类型的触发器需要配置不同参数，<br>如：elsa内置的StartAt，它表示在指定时间点自动触发执行，所以需要设置它的DateTime，表示在这个时间点自动触发<br>再比如：HttpEndpoint是另一个elsa内置的触发器，它监听到指定请求时自动触发，所以需要配置它的 监听地址、Http方法、是否做授权判断等等属性。</p>
<h1 id="section-3"><a id="pragma-line-17"></a>触发器存储（索引化）</h1>
<p id="pragma-line-18">触发器都是定义在流程定义中的，且一个流程定义中，可能有多个相同或不同类型的触发器， 从所有流程定义中把触发器都抽取出来，单独存储到一个列表中，当系统启动时，或别的情况需要访问整个系统中的触发器配置时，可以直接从这个列表中快速获取触发器， 这比每次都遍历所有流程定义，再从中抽取触发器更快，这就是触发器索引化，如果你用的ef配置为elsa的持久化，那么它会存储在Triggers表中</p>
<p id="pragma-line-22">触发器索引化器由ITriggerIndexer接口表示，默认实现是TriggerIndexer，它就提供保存、删除、获取触发器的功能。 它在保存时会根据流程或流程定义，获取里面定义的触发器列表，然后调用其GetTriggerPayloadsAsync方法，获取触发器配置时的参数，这个参数通常是根据触发器属性生成的， 比较特别的是某些触发器中，GetTriggerPayloadsAsync会返回多个payload，这会导致触发器索引列表中存储多个记录，比如内置触发器HttpEndpoint，会根据用户配置的多个Http方法， 返回多个数据，如果你配置了GET POST，触发器索引列表会存储对应的两条记录，将来外部请求同一个url地址时，无论是get 还是post，HttpEndpoint这个节点都会被执行。</p>
<p id="pragma-line-27">流程定义变动后发布流程时，或直接刷新流程定义时，或其它情况，总之流程定义变化后，都会调用ITriggerIndexer重新生产并保存触发器，保存后会触发WorkflowTriggersIndexed事件。</p>
<p id="pragma-line-29">所以索引器还起到一个奇怪的作用，就是让我们在流程定义中配置触发器相关参数，而配合触发器的外部监听功能可以通过从持久化获取，或从事件参数中 获得 触发器的配置数据，从而控制监听逻辑。</p>
<h1 id="section-4"><a id="pragma-line-31"></a>触发器外部的监听部分</h1>
<p id="pragma-line-32">监听这件事并不是定义在触发器节点内部的，而是外部配合的，比如HttpEndpont触发器，监听是单独的asp.net core 中间件来实现的，但这个中间件应该依赖我们配置流程时给HttpEndpont触发器定义的参数。</p>
<p id="pragma-line-34">配合HttpPoint触发的外部部分有个UpdateRouteTable，它监听WorkflowTriggersIndexed，并根据事件参数获取监听的地址，进而配置路由。另外asp.net core中间件中还可以直接从持久化中获取触发器， 进而访问器payload中的触发器配置参数，并根据这些参数控制此中间件的执行流程。</p>
<p id="pragma-line-37">而配合定时器相关触发器Timer StartAt Cron等的外部分是ScheduleWorkflows，它也监听WorkflowTriggersIndexed事件，在事件处理中，调用elsa调度器安排后台作业来，以实现到指定时间后让触发器执行。</p>
<h1 id="section-5"><a id="pragma-line-39"></a>触发器节点被执行</h1>
<p id="pragma-line-40">触发器是特殊的Activity，假如有个流程：A → B → C，其中B是触发器，当前流程可能并不是因为B的外部监听触发此流程的执行，可能是A执行后，流转到B，导致B的ExecuteAsync被执行。<br>ActivityExecutionContext.IsTriggerOfWorkflow就是用来判断这种情况的，若当前流程就是自己这个节点触发的，则为true，否则为false<br>所以触发器执行时ExecuteAsync方法中通常需要判断这两种情况。</p>
<h1 id="httpendpoint"><a id="pragma-line-44"></a>内置HttpEndpoint触发器分析</h1>
<p id="pragma-line-45">这里分析下内置的HttpEndpoint触发器，但仅关注触发器的原理部分，以帮助我们更深刻地理解触发器的工作原理。 它定义在Elsa.Http模块中，它继承至<code>Trigger&lt;HttpRequest&gt;</code></p>
<h2 id="section-6"><a id="pragma-line-48"></a>与触发器相关输入参数</h2>
<table id="pragma-line-50">
<thead>
<tr id="pragma-line-50"><th id="pragma-line-50">参数名</th><th id="pragma-line-50">描述</th></tr>

</thead>
<tbody>
<tr id="pragma-line-52">
<td id="pragma-line-52">SupportedMethods</td>
<td id="pragma-line-52">监听哪些http方法，可选值："GET", "POST", "PUT", "HEAD", "DELETE"</td>

</tr>
<tr id="pragma-line-53">
<td id="pragma-line-53">Authorize</td>
<td id="pragma-line-53">监听的地址被请求时，是否做权限判断</td>

</tr>
<tr id="pragma-line-54">
<td id="pragma-line-54">Policy</td>
<td id="pragma-line-54">权限判断用的策略名称</td>

</tr>
<tr id="pragma-line-55">
<td id="pragma-line-55">Path</td>
<td id="pragma-line-55">监听的url地址</td>

</tr>
<tr id="pragma-line-56">
<td id="pragma-line-56">RequestTimeout</td>
<td id="pragma-line-56">请求超时设置</td>

</tr>
<tr id="pragma-line-57">
<td id="pragma-line-57">RequestSizeLimit</td>
<td id="pragma-line-57">请求体大小限制</td>

</tr>

</tbody>

</table>
<h2 id="httpendpoint.gettriggerpayloads"><a id="pragma-line-59"></a>HttpEndpoint.GetTriggerPayloads</h2>
<p id="pragma-line-60">核心源码：</p>
<pre><code id="pragma-line-61">    protected override IEnumerable&lt;object&gt; GetTriggerPayloads(TriggerIndexingContext context) =&gt; GetBookmarkPayloads(context.ExpressionExecutionContext);

    private IEnumerable&lt;object&gt; GetBookmarkPayloads(ExpressionExecutionContext context)
    {
        // Generate bookmark data for path and selected methods.
        var normalizedRoute = context.Get(Path)!.NormalizeRoute();
        var methods = SupportedMethods.GetOrDefault(context) ?? new List&lt;string&gt; { HttpMethods.Get };
        var authorize = Authorize.GetOrDefault(context);
        var policy = Policy.GetOrDefault(context);
        var requestTimeout = RequestTimeout.GetOrDefault(context);
        var requestSizeLimit = RequestSizeLimit.GetOrDefault(context);

        //根据http请求方法，返回多个数据，会在触发器索引列表中创建多条记录
        return methods
            .Select(x =&gt; new HttpEndpointBookmarkPayload(normalizedRoute, x.ToLowerInvariant(), authorize, policy, requestTimeout, requestSizeLimit))
            .Cast&lt;object&gt;()
            .ToArray();
    }
</code></pre>
<p id="pragma-line-81">在所在流程被发布时，会调用GetTriggerPayloads方法，而它会返回上述输入参数，这些输入参数最终被保存到数据库中，还会触发WorkflowTriggersIndexed事件，这些监听相关的 参数还会保存到这个事件的参数中。</p>
<p id="pragma-line-84">这个方法会根据配置的SupportedMethods返回一个或多个对象，最终导致触发器索引列表中出现多条对应记录。</p>
<h2 id="updateroutetable"><a id="pragma-line-86"></a>UpdateRouteTable</h2>
<p id="pragma-line-87">它监听WorkflowTriggersIndexed事件，从事件参数中获取Path，然后更新elsa路由表</p>
<pre><code id="pragma-line-88">public class UpdateRouteTable(IRouteTableUpdater routeTableUpdater, IOptions&lt;HttpActivityOptions&gt; options) :
    INotificationHandler&lt;WorkflowTriggersIndexed&gt;,
    INotificationHandler&lt;WorkflowBookmarksIndexed&gt;
{
    /// &lt;inheritdoc /&gt;
    public async Task HandleAsync(WorkflowTriggersIndexed notification, CancellationToken cancellationToken)
    {
        routeTableUpdater.RemoveRoutes(notification.IndexedWorkflowTriggers.RemovedTriggers);
        await routeTableUpdater.AddRoutesAsync(notification.IndexedWorkflowTriggers.AddedTriggers, cancellationToken);
        await routeTableUpdater.AddRoutesAsync(notification.IndexedWorkflowTriggers.UnchangedTriggers, cancellationToken);
    }
</code></pre>
<h2 id="httpworkflowsmiddleware"><a id="pragma-line-102"></a>HttpWorkflowsMiddleware</h2>
<p id="pragma-line-103">elsa http endpoint监听中间件，直接看注释吧</p>
<pre><code id="pragma-line-104">public async Task InvokeAsync(HttpContext httpContext, IServiceProvider serviceProvider)
    {
        //当前请求路径
        var path = GetPath(httpContext);
        //根据elsa路由表匹配路由数据
        var matchingPath = GetMatchingRoute(serviceProvider, path).Route;
        //配置elsa时，HttpActivityOptions中指定的基础地址
        var basePath = options.Value.BasePath?.ToString().NormalizeRoute();

        //若请求地址连elsa配置的基础地址都不匹配，则直接执行下个中间件，说明没见听到触发器定义的要求
        // If the request path does not match the configured base path to handle workflows, then skip.
        if (!string.IsNullOrWhiteSpace(basePath))
        {
            if (!path.StartsWith(basePath, StringComparison.OrdinalIgnoreCase))
            {
                await next(httpContext);
                return;
            }

            // Strip the base path.
            matchingPath = matchingPath[basePath.Length..];
        }

        matchingPath = matchingPath.NormalizeRoute();

        var input = new Dictionary&lt;string, object&gt;
        {
            [HttpEndpoint.HttpContextInputKey] = true,
            [HttpEndpoint.RequestPathInputKey] = path.NormalizeRoute()
        };

        var cancellationToken = httpContext.RequestAborted;
        var request = httpContext.Request;
        var method = request.Method.ToLowerInvariant();
        var httpWorkflowLookupService = serviceProvider.GetRequiredService&lt;IHttpWorkflowLookupService&gt;();
        var workflowInstanceId = await GetWorkflowInstanceIdAsync(serviceProvider, httpContext, cancellationToken);
        var correlationId = await GetCorrelationIdAsync(serviceProvider, httpContext, cancellationToken);
        //根据请求路径 http方法 和 HttpEndpoint计算hash值
        var bookmarkHash = ComputeBookmarkHash(serviceProvider, matchingPath, method);
        //根据上面的hash值，从存储中获取匹配的工作流及其触发器列表
        var lookupResult = await httpWorkflowLookupService.FindWorkflowAsync(bookmarkHash, cancellationToken);

        if (lookupResult != null)
        {
            //若找到了流程，且里面仅包含一个与当前请求匹配的触发器，则说了匹配上了，执行流程，否则报错

            var triggers = lookupResult.Triggers;

            if (triggers.Count &gt; 1)
            {
                //报错
                await HandleMultipleWorkflowsFoundAsync(httpContext, () =&gt; triggers.Select(x =&gt; new
                {
                    x.WorkflowDefinitionId
                }), cancellationToken);
                return;
            }

            var trigger = triggers.FirstOrDefault();
            if (trigger != null)
            {
                var workflowGraph = lookupResult.WorkflowGraph!;
                //执行流程中触发器所在节点
                await StartWorkflowAsync(httpContext, trigger, workflowGraph, input, workflowInstanceId, correlationId);
                return;
            }
        }

        //若触发器节点已经执行过，也就是之前从其它节点流转过去的，那次触发器节点被执行时会创建书签的，则直接根据书签恢复执行
        var bookmarks = await FindBookmarksAsync(serviceProvider, bookmarkHash, workflowInstanceId, correlationId, cancellationToken).ToList();
        //若找到多个匹配的，报错
        if (bookmarks.Count &gt; 1)
        {
            await HandleMultipleWorkflowsFoundAsync(httpContext, () =&gt; bookmarks.Select(x =&gt; new
            {
                x.WorkflowInstanceId
            }), cancellationToken);
            return;
        }

        var bookmark = bookmarks.SingleOrDefault();

        if (bookmark != null)
        {
            //恢复书签执行
            await ResumeWorkflowAsync(httpContext, bookmark, input, correlationId);
            return;
        }

        // 如果基础地址都匹配上了，却没找到对应的流程，则抛出404错误
        if (basePath != null)
        {
            await httpContext.Response.SendNotFoundAsync(cancellation: cancellationToken);
            return;
        }

        // If no base path was configured, the request should be handled by subsequent middlewares. 
        await next(httpContext);
    }
</code></pre>
<h2 id="httpendpoint.executeasync"><a id="pragma-line-206"></a>HttpEndpoint.ExecuteAsync</h2>
<p id="pragma-line-207">若前面的中间件匹配上当前触发器节点</p>
<pre><code id="pragma-line-208">    protected override async ValueTask ExecuteAsync(ActivityExecutionContext context)
    {
        var path = Path.Get(context);

        if (path.Contains("//"))
            throw new RoutePatternException(path, "Path cannot contain double slashes (//)");
        //如果本次执行不是由当前HttpEndpoint自己触发的，比如在当前节点前另一个触发器执行了此流程，但是节点流转到这里来了。
        if (!context.IsTriggerOfWorkflow())
        {
            //则直接创建书签卡住流程，等到匹配的http请求被HttpWorkflowsMiddleware流转到这里时，OnResumeAsync将被执行
            context.CreateBookmarks(GetBookmarkPayloads(context.ExpressionExecutionContext), includeActivityInstanceId: false, callback: OnResumeAsync);
            return;
        }
        //否则，说明当前流程的执行，就是这里配置的触发器触发的。
        var httpContextAccessor = context.GetRequiredService&lt;IHttpContextAccessor&gt;();
        var httpContext = httpContextAccessor.HttpContext;
        //触发器也是activity，它可能直接被执行，而不是被http请求执行，则需要等待传统的书签请求来恢复OnResumeAsync
        if (httpContext == null)
        {
            // We're executing in a non-HTTP context (e.g. in a virtual actor).
            // Create a bookmark to allow the invoker to export the state and resume execution from there.
            context.CreateBookmark(OnResumeAsync, BookmarkMetadata.HttpCrossBoundary);
            return;
        }
        //否则说明当前流程的触发器就是自己，并且被http请求触发了
        await HandleRequestAsync(context, httpContext);
    }
</code></pre>
<h2 id="httpendpoint.onresumeasync"><a id="pragma-line-238"></a>HttpEndpoint.OnResumeAsync</h2>
<p id="pragma-line-239">无论时HttpWorkflowsMiddleware匹配上，通过书签恢复流程执行；还是走的传统的书签恢复，都会执行这里。</p>
<pre><code id="pragma-line-240">    private async ValueTask OnResumeAsync(ActivityExecutionContext context)
    {
        var httpContextAccessor = context.GetRequiredService&lt;IHttpContextAccessor&gt;();
        var httpContext = httpContextAccessor.HttpContext;
        //在恢复执行时，可能并不是http请求恢复的，可能是直接调用书签恢复的
        if (httpContext == null)
        {
            // We're executing in a non-HTTP context (e.g. in a virtual actor).
            // Create a bookmark to allow the invoker to export the state and resume execution from there.
            context.CreateBookmark(OnResumeAsync, BookmarkMetadata.HttpCrossBoundary);
            return;
        }
        //处理http请求
        await HandleRequestAsync(context, httpContext);
    }
</code></pre>
<h1 id="section-7"><a id="pragma-line-258"></a>触发器调度</h1>
<p id="pragma-line-259">有几个跟时间相关的内置触发器：Cron、StartAt、Timer，它们使用elsa的工作流调度框架，在后台作业中，根据设置的时间规则，触发执行流程。</p>
<h2 id="itriggerscheduler"><a id="pragma-line-261"></a>触发器调度器ITriggerScheduler</h2>
<p id="pragma-line-262">ITriggerScheduler它定义两个方法，调度触发器、注销触发器调度。 默认实现DefaultTriggerScheduler，它使用elsa的流程调度器，实现在后台作业中实现流程安排。 值得注意的是，它们在触发时，DefaultTriggerScheduler总是创建新的流程实例。核心源码如下：</p>
<pre><code id="pragma-line-265">public async Task ScheduleAsync(IEnumerable&lt;StoredTrigger&gt; triggers, CancellationToken cancellationToken = default)
    {
        var triggerList = triggers.ToList();
        var timerTriggers = triggerList.Filter&lt;Activities.Timer&gt;();
        var startAtTriggers = triggerList.Filter&lt;StartAt&gt;();
        var cronTriggers = triggerList.Filter&lt;Cron&gt;();
        var now = systemClock.UtcNow;

        // Schedule each Timer trigger.
        foreach (var trigger in timerTriggers)
        {
            var (startAt, interval) = trigger.GetPayload&lt;TimerTriggerPayload&gt;();
            var input = new { StartAt = startAt, Interval = interval }.ToDictionary();
            //安排流程作业时，要求创建新的流程实例
            var request = new ScheduleNewWorkflowInstanceRequest
            {
                WorkflowDefinitionHandle = WorkflowDefinitionHandle.ByDefinitionVersionId(trigger.WorkflowDefinitionVersionId),
                TriggerActivityId = trigger.ActivityId,
                Input = input
            };
            await workflowScheduler.ScheduleRecurringAsync(trigger.Id, request, startAt, interval, cancellationToken);
        }

        // Schedule each StartAt trigger.
        foreach (var trigger in startAtTriggers)
        {
            var executeAt = trigger.GetPayload&lt;StartAtPayload&gt;().ExecuteAt;
            
            // If the trigger is in the past, log info and skip scheduling.
            if (executeAt &lt; now)
            {
                logger.LogInformation("StartAt trigger is in the past. TriggerId: {TriggerId}. ExecuteAt: {ExecuteAt}. Skipping scheduling", trigger.Id, executeAt);
                continue;
            }
            
            var input = new { ExecuteAt = executeAt }.ToDictionary();
            //安排流程作业时，要求创建新的流程实例
            var request = new ScheduleNewWorkflowInstanceRequest
            {
                WorkflowDefinitionHandle = WorkflowDefinitionHandle.ByDefinitionVersionId(trigger.WorkflowDefinitionVersionId),
                TriggerActivityId = trigger.ActivityId,
                Input = input
            };

            await workflowScheduler.ScheduleAtAsync(trigger.Id, request, executeAt, cancellationToken);
        }

        // Schedule each Cron trigger.
        foreach (var trigger in cronTriggers)
        {
            var payload = trigger.GetPayload&lt;CronTriggerPayload&gt;();
            var cronExpression = payload.CronExpression;

            if (string.IsNullOrWhiteSpace(cronExpression))
            {
                logger.LogWarning("Cron expression is empty. TriggerId: {TriggerId}. Skipping scheduling of this trigger", trigger.Id);
                continue;
            }
            
            var input = new { CronExpression = cronExpression }.ToDictionary();
            //安排流程作业时，要求创建新的流程实例
            var request = new ScheduleNewWorkflowInstanceRequest
            {
                WorkflowDefinitionHandle = WorkflowDefinitionHandle.ByDefinitionVersionId(trigger.WorkflowDefinitionVersionId),
                TriggerActivityId = trigger.ActivityId,
                Input = input
            };
            try
            {
                await workflowScheduler.ScheduleCronAsync(trigger.Id, request, cronExpression, cancellationToken);
            }
            catch (FormatException ex)
            {
                logger.LogWarning(ex, "Cron expression format error. CronExpression: {CronExpression}", cronExpression);
            }
        }
    }
</code></pre>
<p id="pragma-line-345">ScheduleWorkflows监听触发器变动事件，并进行触发器调度。</p>
<pre><code id="pragma-line-346">public class ScheduleWorkflows : INotificationHandler&lt;WorkflowTriggersIndexed&gt;, INotificationHandler&lt;WorkflowBookmarksIndexed&gt;
{
    //...其它代码
    public async Task HandleAsync(WorkflowTriggersIndexed notification, CancellationToken cancellationToken)
    {
        //注销之前的后台作业
        await _triggerScheduler.UnscheduleAsync(notification.IndexedWorkflowTriggers.RemovedTriggers, cancellationToken);
        //使用后台作业，在指定时间点恢复触发器所在节点
        await _triggerScheduler.ScheduleAsync(notification.IndexedWorkflowTriggers.AddedTriggers, cancellationToken);
    }
</code></pre>
<h2 id="startat"><a id="pragma-line-358"></a>以StartAt触发器为例</h2>
<p id="pragma-line-359">这个相对简单，发布流程时触发触发器所以变更事件</p>
<pre><code id="pragma-line-360">    protected override object GetTriggerPayload(TriggerIndexingContext context)
    {
        //从输入参数中获取payload
        var executeAt = context.ExpressionExecutionContext.Get(DateTime);
        //返回，以供触发器调度器访问
        return new StartAtPayload(executeAt);
    }

    /// &lt;inheritdoc /&gt;
    protected override async ValueTask ExecuteAsync(ActivityExecutionContext context)
    {
        //若当前流程的执行，正是当前触发器导致执行的，则直接完成，因为此时是时间到了，当前方法第二次被执行。
        if (context.IsTriggerOfWorkflow())
        {
            await context.CompleteActivityAsync();
            return;
        }

        //否则说明是另一个触发器导致流程执行，并流转到这里，这个时候应该去调度任务。
        //从输入参数中获取指定的触发时间
        var executeAt = context.ExpressionExecutionContext.Get(DateTime);
        var clock = context.ExpressionExecutionContext.GetRequiredService&lt;ISystemClock&gt;();
        var now = clock.UtcNow;
        var logger = context.GetRequiredService&lt;ILogger&lt;StartAt&gt;&gt;();

        context.JournalData.Add("Executed At", now);
        
        if (executeAt &lt;= now)
        {
            logger.LogDebug("Scheduled trigger time lies in the past ('{Delta}'). Completing immediately", now - executeAt);
            await context.CompleteActivityAsync();
            return;
        }
        //书签持久化中间件会保存书签，并触发事件，事件处理器会调度此书签，并用到这个参数
        var payload = new StartAtPayload(executeAt);
        //书签持久化中间件会保存书签，并且触发书签变更事件，进而事件处理器调度书签去安排任务
        //书签调度器会根据类型StartAtPayload去做调度
        //关于调度需要看单独的章节。
        context.CreateBookmark(payload);
    }</code></pre>
</div>
<div class="clear"></div>
</div>
	