
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Imageshop/p/19025343" title="发布于 2025-08-06 16:30">
    <span role="heading" aria-level="2">[快速阅读十一] 伊拉克团队的TAGC（低光增强效果）算法实现。</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        这篇来自伊拉克团队的论文提出了一个简单却有效的低光图像增强算法TAGC，无需训练数据就能实现媲美深度学习的效果，效果惊艳不错。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>　　原论文信息如下：</p>
<p>　　 论文标题: Tuning adaptive gamma correction (TAGC) for enhancing images in low light</p>
<p>　　发表日期: 2025年07月</p>
<p>　　作者: Ghufran Alhamzawi, Alfoudi Ali Saeed, Suha Mohammed Hadi等</p>
<p>　　发表单位: University of Al-Qadisiyah, University of Information Technology and Communications等</p>
<p>　　原文链接:</p>
<p>　　　　<a href="http://arxiv.org/pdf/2507.19574v1" target="_blank" rel="noopener nofollow">http://arxiv.org/pdf/2507.19574v1</a>=</p>
<p>　　AGC的核心思想非常巧妙：它通过分析图像的亮度分布，自动计算出最适合的伽马校正参数。整个过程完全自动化，不需要任何人工干预。具体来说，它分为四个步骤：</p>
<p><strong>　　　　1. 计算亮度因子(L)</strong>根据人眼对不同颜色的敏感度，给RGB三个通道赋予不同权重。</p>
<p>　　　　　　　　　　　　<img src="https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160448778-2126148724.png" alt="image" loading="lazy"></p>
<p><strong>　　　　2. 计算平均颜色因子(μ)</strong>取RGB三个通道的平均值，作为整体颜色基准。</p>
<p>　　　　　　　　　　　　　　<img src="https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160510127-403364297.png" alt="image" loading="lazy"></p>
<p><strong>　　　　3. 计算自适应伽马系数(γ)</strong>结合亮度因子和平均颜色因子，动态调整伽马值。</p>
<p>　　　　　　　　　　　<img src="https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160527887-234765531.png" alt="image" loading="lazy"></p>
<p><strong>　　　　4. 应用自适应伽马校正</strong>使用计算出的伽马值对图像进行增强处理。</p>
<p>&nbsp;　　　　　　　　　　<img src="https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160546843-1026003141.png" alt="image" loading="lazy"></p>
<p>　　以上都是针对单个像素处理的。</p>
<p>　　这个算法弄成代码也不是很复杂的，分享如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">void</span> IM_TAGC_Enhancement(unsigned <span style="color: rgba(0, 0, 255, 1)">char</span> *Src, unsigned <span style="color: rgba(0, 0, 255, 1)">char</span> *Dest, <span style="color: rgba(0, 0, 255, 1)">int</span> Width, <span style="color: rgba(0, 0, 255, 1)">int</span> Height, <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> Stride)
{
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> Channel = Stride /<span style="color: rgba(0, 0, 0, 1)"> Width;
    </span><span style="color: rgba(0, 0, 255, 1)">float</span> Inv255 = <span style="color: rgba(128, 0, 128, 1)">1.0f</span> / <span style="color: rgba(128, 0, 128, 1)">255</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (Channel == <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> Y = <span style="color: rgba(128, 0, 128, 1)">0</span>; Y &lt; Height; Y++<span style="color: rgba(0, 0, 0, 1)">)
        {
            unsigned </span><span style="color: rgba(0, 0, 255, 1)">char</span> *LinePS = Src + Y *<span style="color: rgba(0, 0, 0, 1)"> Stride;
            unsigned </span><span style="color: rgba(0, 0, 255, 1)">char</span> *LinePD = Dest + Y *<span style="color: rgba(0, 0, 0, 1)"> Stride;
            </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> X = <span style="color: rgba(128, 0, 128, 1)">0</span>; X &lt; Width; X++<span style="color: rgba(0, 0, 0, 1)">)
            {
                </span><span style="color: rgba(0, 0, 255, 1)">float</span> Blue = LinePS[<span style="color: rgba(128, 0, 128, 1)">0</span>] *<span style="color: rgba(0, 0, 0, 1)"> Inv255;
                </span><span style="color: rgba(0, 0, 255, 1)">float</span> Green = LinePS[<span style="color: rgba(128, 0, 128, 1)">1</span>] *<span style="color: rgba(0, 0, 0, 1)"> Inv255;
                </span><span style="color: rgba(0, 0, 255, 1)">float</span> Red = LinePS[<span style="color: rgba(128, 0, 128, 1)">2</span>] *<span style="color: rgba(0, 0, 0, 1)"> Inv255;
                </span><span style="color: rgba(0, 0, 255, 1)">float</span> L = <span style="color: rgba(128, 0, 128, 1)">0.2126f</span> * Red + <span style="color: rgba(128, 0, 128, 1)">0.7152</span> * Green + <span style="color: rgba(128, 0, 128, 1)">0.0722</span> *<span style="color: rgba(0, 0, 0, 1)"> Blue;
                </span><span style="color: rgba(0, 0, 255, 1)">float</span> A = (Blue + Green + Red) / <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">;
                </span><span style="color: rgba(0, 0, 255, 1)">float</span> Gamma = <span style="color: rgba(128, 0, 128, 1)">5.0f</span> + (<span style="color: rgba(128, 0, 128, 1)">0.5f</span> - L) * (<span style="color: rgba(128, 0, 128, 1)">1</span> - A) - <span style="color: rgba(128, 0, 128, 1)">2</span> *<span style="color: rgba(0, 0, 0, 1)"> L;
                LinePD[</span><span style="color: rgba(128, 0, 128, 1)">0</span>] = ClampToByte((<span style="color: rgba(0, 0, 255, 1)">int</span>)(powf(Blue, <span style="color: rgba(128, 0, 128, 1)">2</span> / Gamma) * <span style="color: rgba(128, 0, 128, 1)">255</span> + <span style="color: rgba(128, 0, 128, 1)">0.4999999f</span><span style="color: rgba(0, 0, 0, 1)">));
                LinePD[</span><span style="color: rgba(128, 0, 128, 1)">1</span>] = ClampToByte((<span style="color: rgba(0, 0, 255, 1)">int</span>)(powf(Green, <span style="color: rgba(128, 0, 128, 1)">2</span> / Gamma) * <span style="color: rgba(128, 0, 128, 1)">255</span> + <span style="color: rgba(128, 0, 128, 1)">0.4999999f</span><span style="color: rgba(0, 0, 0, 1)">));
                LinePD[</span><span style="color: rgba(128, 0, 128, 1)">2</span>] = ClampToByte((<span style="color: rgba(0, 0, 255, 1)">int</span>)(powf(Red, <span style="color: rgba(128, 0, 128, 1)">2</span> / Gamma) * <span style="color: rgba(128, 0, 128, 1)">255</span> + <span style="color: rgba(128, 0, 128, 1)">0.4999999f</span><span style="color: rgba(0, 0, 0, 1)">));
                LinePS </span>+= <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">;
                LinePD </span>+= <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">;
            }
        }
    }
}</span></pre>
</div>
<p>　　效果吗，确实能做到作者论文里的效果的，说明作者是没有作假的。</p>
<p>　<img src="https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160854531-1033299728.jpg" alt="微信图片_20250806160826" width="600" loading="lazy">&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<img src="https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160902056-49755058.jpg" alt="微信图片_20250806160832" width="600" loading="lazy"></p>
<p>&nbsp;&nbsp;<img src="https://img2024.cnblogs.com/blog/349293/202508/349293-20250806160911300-816814483.png" alt="微信图片_20250806160835" width="600" loading="lazy">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="https://img2024.cnblogs.com/blog/349293/202508/349293-20250806161033058-1103527801.png" alt="微信图片_20250806160834" width="600" loading="lazy"></p>
<p>　　不过对有些图像的处理效果就还是有点灰蒙蒙的，整体对比度不高。&nbsp;</p>
<p>　　至于算法的速度并不像有些文章里说的可以满足4K视频实时增强的，虽然上面提供的代码只是示意代码，可以进行大量的优化，但是最后的pow函数是个非常耗时的过程，而且似乎没有设么好的办法去避免这个计算，不算前面文章那个pow(x,1.5)可以转换为x * sqrt(x)。</p>
<p>　　不过这个点和我一样还在研究传统算法的，又是伊拉克的团队，这份精神还是值得表扬的。</p>
<p>&nbsp;　　Demo下载地址：<a href="https://files.cnblogs.com/files/Imageshop/TAGC.rar?t=1754469391&amp;download=true" target="_blank">https://files.cnblogs.com/files/Imageshop/TAGC.rar?t=1754469391&amp;download=true</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.00625" data-date-updated="2025-08-06 16:39">2025-08-06 16:30</span>&nbsp;
<a href="https://www.cnblogs.com/Imageshop">Imageshop</a>&nbsp;
阅读(<span id="post_view_count">179</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19025343);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19025343', targetLink: 'https://www.cnblogs.com/imageshop/p/19025343', title: '[快速阅读十一] 伊拉克团队的TAGC（低光增强效果）算法实现。' })">举报</a>
</div>
        