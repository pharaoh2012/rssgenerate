
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tshaaa/p/18734925" title="发布于 2025-02-24 21:20">
    <span role="heading" aria-level="2">Normalizing flow 流模型 | CS236深度生成模型Lec8学习笔记</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        CS236深度生成模型 Lec8的刷课总结/刷课笔记，内容是normalizing flow 流模型。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<ul>
<li>主要参考资料：<a href="https://deepgenerativemodels.github.io/syllabus.html" target="_blank" rel="noopener nofollow">Stanford University CS236: Deep Generative Models</a> Lec8.</li>
</ul>
<p>这篇blog基本上是CS236 Lec8的刷课总结/刷课笔记。</p>
<h1 id="vae">VAE</h1>
<p>这一节回顾生成模型的一般框架和VAE方法。</p>
<p><img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211545258-1934186550.png" alt="image" loading="lazy"></p>
<p>生成模型问题的一般框架，一般有三个组件：</p>
<ul>
<li><span class="math inline">\(P_{data}\)</span>：数据的真实分布。</li>
<li><span class="math inline">\(P_\theta\)</span>：由<span class="math inline">\(\theta\)</span>参数化的模型族，用于近似真实分布。</li>
<li><span class="math inline">\(d(P_{data},P_\theta)\)</span>：某种衡量“距离”的指标，比如KL散度。</li>
</ul>
<p>生成模型的训练目标，就是尝试最小化<span class="math inline">\(d(P_{data},P_\theta)\)</span>。</p>
<p>下面是VAE的概率图，及其特点：<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211556773-1247107205.png" alt="image" loading="lazy"></p>
<ul>
<li>是隐变量生成模型。</li>
<li>隐变量<span class="math inline">\(z\)</span>服从一个简单的先验分布，比如高斯分布<span class="math inline">\(p(z) = \mathcal N(0, I)\)</span>.</li>
<li>用神经网络建模似然函数<span class="math inline">\(p(x\mid z;\theta)= \mathcal N(\mu_\theta, \sigma_\theta)\)</span>，于是得到Evidence <span class="math inline">\(p(x;\theta) = \int p(x\mid z;\theta) p(z)\text{d}z\)</span>. 这就是VAE的model family.</li>
<li>VAE中，衡量距离的指标是KL散度，也就是使用极大似然训练 (最小化KL散度和极大似然学习的关系，可以参见<a href="https://deepgenerativemodels.github.io/assets/slides/cs236_lecture4.pdf" target="_blank" rel="noopener nofollow">cs236_lecture4.pdf</a>)</li>
</ul>
<p>应用难点在于：极大似然训练需要max evidence，需要积分，intractable.</p>
<p>VAE中结合了变分推断的方法，近似出了后验概率<span class="math inline">\(q(z\mid x)\)</span>，然后就有了Encoder-Decoder的结构<span class="math inline">\(x^i\to q(z;f_\lambda(x^i)) \to z \to P(X\mid z;\theta) \to \bar x^i\)</span>，就避免了intractable的积分。</p>
<blockquote>
<p>VAE详细内容可以参考我的旧文章：<a href="https://www.cnblogs.com/tshaaa/p/18651129" target="_blank">变分推断(VI)、随机梯度变分推断(SGVI/SGVB)、变分自编码器(VAE)串讲 - 伊犁纯流莱 - 博客园</a>；或者参考课程的前几节：<a href="https://deepgenerativemodels.github.io/syllabus.html" target="_blank" rel="noopener nofollow">Stanford University CS236: Deep Generative Models</a> lec5, 6</p>
</blockquote>
<h1 id="normalizing-flow-model">Normalizing flow model</h1>
<p>有点像VAE。也是隐变量模型，而且在训练的时候也是用KL散度来衡量模型输出分布和真实分布的“距离”。下面就是flow model的概率图。</p>
<p><img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211622648-358090550.png" alt="image" loading="lazy"></p>
<p>其中<span class="math inline">\(z\)</span>仍然服从一个简单分布，满足：</p>
<ol>
<li><span class="math inline">\(z\)</span>和<span class="math inline">\(x\)</span>是<strong>连续变量</strong>，并且具有<strong>相同的维度</strong>。</li>
<li>从<span class="math inline">\(z\)</span>到<span class="math inline">\(x\)</span>的变换是一个<strong>确定性的可逆变换</strong>。假设<span class="math inline">\(X=f_\theta(Z)\)</span>，<span class="math inline">\(Z = f^{-1}_\theta(X)\)</span>.</li>
</ol>
<p>根据以下定理，只需要计算等式右边，很容易就可以计算出evidence：<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211631111-1285546904.png" alt="image" loading="lazy"></p>
<p>根据行列式性质，也可以用正映射对应矩阵的Jacobian的行列式：<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211642201-501488859.png" alt="image" loading="lazy"></p>
<p>为何右边容易计算？</p>
<ol>
<li><span class="math inline">\(p_Z\)</span>是简单分布，可以直接evaluate。</li>
<li>假设映射可逆，所以<span class="math inline">\(f^{-1}(x)\)</span>也容易算。</li>
<li>暂且假定Jacobian矩阵的行列式也容易计算 (后面会说原因)。</li>
</ol>
<p>Evidence容易算，就可以很方便使用极大似然学习。这就是flow model的核心思想。</p>
<h1 id="flow-model的学习和推断">Flow model的学习和推断</h1>
<p><img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211650343-934133352.png" alt="image" loading="lazy"></p>
<ol>
<li>学习：由于变换可逆，根据change of variable，极大似然学习会很方便。</li>
<li>采样/生成：直接从简单分布<span class="math inline">\(p(z)\)</span>采样，然后变换得到样本。</li>
<li>隐变量表示：对数据进行逆变换，得到隐变量表示。</li>
</ol>
<h1 id="如何构造可逆变换">如何构造可逆变换</h1>
<p>这一部分解决两个问题：</p>
<ol>
<li>如何构造表示能力足够的可逆变换 (model family足够大)，因为我们希望模型<span class="math inline">\(p_\theta(x)\)</span>足够表示数据原本的分布。</li>
<li>计算变换矩阵的Jacobian行列式复杂度<span class="math inline">\(O(n^3)\)</span>，是否可以通过构造可逆变换来简化复杂度。</li>
</ol>
<h2 id="flow-of-transformation">Flow of transformation</h2>
<p>针对第一个问题，可以合成多个<strong>结构相同的简单变换</strong>，构造一个<strong>复杂的可逆变换</strong>。实现上就是用多层的网络，每层结构相同、参数不同。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211700444-1706401905.png" alt="image" loading="lazy"></p>
<p>合成之后，计算过程也不难：<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211706938-302759805.png" alt="image" loading="lazy"></p>
<ul>
<li>合成多个结构相同，参数不同的变换。</li>
<li>最后行列式计算可以拆成连乘的形式。</li>
</ul>
<h2 id="triangular-jacobian">Triangular Jacobian</h2>
<p>针对第二个问题，可以尝试构造出一个上三角或者下三角形式的变换矩阵，计算行列式就只需要将对角元素相乘，复杂度降低为<span class="math inline">\(O(n)\)</span>。</p>
<p>假设<span class="math inline">\(x_i\)</span>和<span class="math inline">\(z_i\)</span>表示第<span class="math inline">\(i\)</span>个维度，要构造下三角的可逆变换，我们希望<span class="math inline">\(x_i = f_i(z)\)</span>只依赖于<span class="math inline">\(z\)</span>的前<span class="math inline">\(i\)</span>个维度 (就像自回归模型)：<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211715290-1221333187.png" alt="image" loading="lazy"></p>
<h1 id="example">Example</h1>
<p><strong>单个层</strong>的可逆变换应该如何构造，这一部分简单介绍几种具体的构造方法。</p>
<h2 id="nice-nonlinear-independent-components-estimation">NICE (Nonlinear Independent Components Estimation)</h2>
<p>NICE中的可逆变换组成：</p>
<ol>
<li>堆叠的Additive coupling layers</li>
<li>最后接的一层Rescaling layers</li>
</ol>
<p>以下给出了Additive coupling layers和Rescaling layers的细节，很容易就可以看出它们都满足：变换可逆和Jacobian行列式容易计算的特点。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211728786-165491731.png" alt="image" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211735579-1043802340.png" alt="image" loading="lazy"></p>
<h2 id="real-nvp-non-volume-preserving-extension-of-nice">Real-NVP (Non-volume preserving extension of NICE)</h2>
<p>相对于NICE，在计算<span class="math inline">\(x_{d+1:n}\)</span>时，隐变量<span class="math inline">\(z_{d+1:n}\)</span>多乘了一个缩放因子。其逆变换和Jacobian行列式仍然容易计算。而且生成效果比NICE好了不少。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211743483-980788367.png" alt="image" loading="lazy"></p>
<h2 id="maf-masked-autoregressive-flow">MAF (Masked Autoregressive Flow)</h2>
<p>考虑一个高斯自回归模型（根据链式法则，按照某个顺序对<span class="math inline">\(p(x)\)</span>进行因子分解），假定每个因子对应的概率分布都用高斯分布建模，高斯分布的均值和方差都用神经网络建模。</p>
<p>Remark：理解自回归模型的一个简单例子。把一张图片的每个像素看作是<span class="math inline">\(x_i\)</span>，每个像素的分布都可以由之前出现过的像素推断出来，对应链式法则的每个因子<span class="math inline">\(p(x_i\mid x_{&lt;i})=\mathcal N(\mu_i(x_{&lt;i}),\sigma_i^2(x_{&lt;i}))\)</span>.</p>
<p>从自回归模型采样的过程，总体上可以看作是从服从简单分布的隐变量<span class="math inline">\(z\)</span>变换到<span class="math inline">\(x\)</span>的过程。具体来说，就是将以下两个步骤当做整体来看：</p>
<ol>
<li>简单分布采样：先从<span class="math inline">\(\mathcal N(0,1)\)</span>中采样出<span class="math inline">\(z_{1...n}\)</span>.</li>
<li>链式生成：对于每个<span class="math inline">\(x_i\)</span>，根据重参数化技巧有<span class="math inline">\(x_i = \text{exp}(\alpha_i)z_i+\mu_i\)</span>，然后在通过神经网络计算<span class="math inline">\(x_{i+1}\)</span>的均值和方差，即<span class="math inline">\(\mu_{i+1}(x_{&lt;i})\)</span>和<span class="math inline">\(\alpha_{i+1}(x_{&lt;i})\)</span>。直到生成整个<span class="math inline">\(x\)</span>。</li>
</ol>
<p>这就是自回归模型 as 流模型的思想。可以结合ppt食用。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211753514-1500869045.png" alt="image" loading="lazy"></p>
<p>MAF的正变换过程，因为需要序列生成，所以速度会慢一些。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211759136-733844686.png" alt="image" loading="lazy"></p>
<ul>
<li>MAF的逆变换过程可以并行进行，比如使用MADE。也就是说，计算<span class="math inline">\(p(z)\)</span>很快，根据change of variable，计算<span class="math inline">\(p(x)\)</span>也快，所以做极大似然训练也较快。（这里的"快"都是相对于后面讲的IAF）</li>
<li>另外，因为是自回归模型，Jacobian天然就是三角形的，容易计算行列式。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211807848-914303788.png" alt="image" loading="lazy"></li>
</ul>
<p>Remark：MADE在这门课<a href="https://deepgenerativemodels.github.io/syllabus.html" target="_blank" rel="noopener nofollow">Stanford University CS236: Deep Generative Models</a>的lec 3有介绍，在这里就只需要知道：输入<span class="math inline">\(x_{1...n}\)</span>之后，MADE能够并行计算出自回归模型每个因子对应高斯分布的均值和方差就行。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211821380-1623480215.png" alt="image" loading="lazy"></p>
<h2 id="iaf-inverse-autoregressive-flow">IAF (Inverse Autoregressive Flow)</h2>
<p>再考虑自回归模型，只不过这次认为隐变量<span class="math inline">\(z\)</span>是自回归而且需要序列生成的，这样就得到了IAF。</p>
<p>IAF特点和MAF恰好相反。</p>
<ul>
<li>正变换(<span class="math inline">\(z\to x\)</span>)可以并行进行，也就是说模型生成样本的速度是较快的。</li>
<li>逆变换(<span class="math inline">\(x\to z\)</span>)需要序列生成，也就是说要计算<span class="math inline">\(p(x)\)</span>比较慢，训练会较慢。</li>
<li>值得注意的一点是，如果样本<span class="math inline">\(\hat x\)</span>是由IAF自己生成的 (而不是来自真实分布)，由于我们可以把生成<span class="math inline">\(\hat x\)</span>用的采样<span class="math inline">\(z\)</span>记录下来，所以逆变换<span class="math inline">\(\hat x \to z\)</span>可以并行进行，就较快了。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211830313-384221046.png" alt="image" loading="lazy"></li>
</ul>
<h2 id="parallel-wavenet">Parallel Wavenet</h2>
<p>博主博主，这个MAF和IAF确实不错，但缺点还是太明显了，有没有训练和生成样本速度都快的自回归流模型推荐一下嘛？有的有的，Parallel wavenet。</p>
<p>Parallel wavenet结合了MAF和IAF的优势，概括来说就是：</p>
<ul>
<li>MAF训练快，就直接训练MAF模型，但是不用它来做生成，而是把它作为训练IAF的教师模型。</li>
<li>前面说IAF对自己生成的样本<span class="math inline">\(\hat x\)</span>做逆变换的速度较快，于是利用这一点，设计了新的loss <span class="math inline">\(D_{KL}(IAF,MAF)= \mathbb E_{x\sim s}[\log IAF(x) - \log MAF(x)]\)</span>。使用训练好的教师模型MAF，再结合这个loss来训练IAF，避免了IAF对真实分布的样本<span class="math inline">\(x\)</span>做逆变换 (需要序列进行的慢速操作)。</li>
<li>最后做样本生成的时候，上IAF就可以了。</li>
</ul>
<p>详情食用ppt。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211840479-621657261.png" alt="image" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211846914-383461217.png" alt="image" loading="lazy"></p>
<h2 id="mintnet">MintNet</h2>
<p>一种利用掩码卷积来构造可逆分布的方法，略。详情参考课程。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211853498-195517510.png" alt="image" loading="lazy"></p>
<h2 id="gaussianization-flows">Gaussianization Flows</h2>
<p>我们之前训练流模型的思路，都是最小化真实分布和模型表示分布的KL散度，是还有另一种角度。根据下面的推导，我们可以知道，只要让真实样本点经过逆变换之后，得到的样本分布接近高斯分布 （即我们假定的隐变量简单先验分布），同样可以达到训练的目标。</p>
<p>所以问题转化成了，如何设计一个可逆的变换，使得真实数据的分布经过变换之后，能够变成高斯分布。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211904627-1655013522.png" alt="image" loading="lazy"></p>
<p>考虑只有一维的样本，利用两次inverse CDF trick，就可以得到能够高斯化数据的变换。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211914273-1591996123.png" alt="image" loading="lazy"></p>
<p>Remark：inverse CDF是一种从分布中采样的方法（和重要性采样、拒绝采样是一类东西），表达式如ppt所示，就是<span class="math inline">\(x = F^{-1}_{data}(U)\)</span>。从CDF图上来思考，就是在y轴上 (范围是<span class="math inline">\([0,1]\)</span>)随机取一个点，然后平行往右对应到曲线上的一点，再竖直往下对应到x轴上一点，这个点就是采到的样本。</p>
<p>但是对于多维的样本来说，每个维度各自是高斯分布不代表联合分布是高斯分布。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211933577-1517903085.png" alt="image" loading="lazy"></p>
<p>于是在高斯化之后，还需要加入旋转变换。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224211940135-143487204.png" alt="image" loading="lazy"></p>
<p>重复高斯化和旋转两个操作 (多个简单可逆变换合并成一个复杂的可逆变换)，最终可以把数据高斯化。<br>
<img src="https://img2024.cnblogs.com/blog/2568389/202502/2568389-20250224212000405-18439925.png" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.033806533563657405" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-24 21:28">2025-02-24 21:20</span>&nbsp;
<a href="https://www.cnblogs.com/tshaaa">伊犁纯流莱</a>&nbsp;
阅读(<span id="post_view_count">20</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18734925" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18734925);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18734925', targetLink: 'https://www.cnblogs.com/tshaaa/p/18734925', title: 'Normalizing flow 流模型 | CS236深度生成模型Lec8学习笔记' })">举报</a>
</div>
        