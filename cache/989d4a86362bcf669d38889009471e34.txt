
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tyysoft/p/18712138" title="发布于 2025-02-12 21:04">
    <span role="heading" aria-level="2">大人，时代变了！ 赶快把自有业务的本地AI“模型”训练起来！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>&nbsp;</p>

<p>&nbsp;</p>

<div class="container-fluid">
<div class="row flex-xl-nowrap">
<div id="post-content" class="col-12 col-md-9 col-xl-10 py-md-3 pl-md-5 bd-content">
<div id="vx-content" class="vx-constrain-image-width line-numbers">
<h1 id="1-大人，时代变了！-赶快把自有业务的本地ai“模型”训练起来！" class="source-line" data-source-line="1">1 大人，时代变了！ 赶快把自有业务的本地AI“模型”训练起来！</h1>
<h2 id="1.1-背景" class="source-line" data-source-line="2">1.1 背景</h2>
<p class="source-line" data-source-line="3">  目前<code>AI</code>已经大行其道，<code>chatGPT</code>、<code>DeepSeek</code>等如雨后春笋般涌现出来，笔者做为一个<code>守旧派</code>和<code>顽固派</code>，一直认为AI只是雕虫小技，根本没有办法和人写的代码相提并论，在chatGPT已经大火几年之后仍然一直无动于衷，只是在最近才慢慢使用了<code>豆包</code>查点资料，然后再接触<code>Kimi</code>、<code>DeepSeek</code>等AI工具和模型。</p>
<p class="source-line" data-source-line="5">  使用AI的<strong>对话问答模式</strong>，相对原来的搜索引擎，得到的结果更精练， 不会像百度、必应之类的搜索引擎，搜索到结果后还要逐页去人工筛选，<span style="color: rgba(0, 0, 255, 1)">AI的回答就是干干净净你要的东西</span>，这比搜索引擎效率高太多了！<br>  提要求让AI生成些小的<strong>代码片段</strong>，如：“<code>给我写一个vbs获取文件扩展名的函数</code>”，生成的代码质量也非常不错，直接拿来就能用，<strong>连测试代码也一并写好</strong>！</p>
<p class="source-line" data-source-line="8"><strong>总结一句话</strong>：<span style="color: rgba(255, 0, 0, 1)"><strong>大人，时代变了，现在投降是代价最小的时候！</strong></span></p>
<p class="source-line" data-source-line="10">问题来了：目前这些AI工具，都是<code>基于通用模型</code>， 如果用来<code>做一些其他业务场景</code>的事，效果就不会太好，<code>此时就需要训练自己的本地模型了</code>！</p>
<p class="source-line" data-source-line="12">注意：在训练自己的本地模型前，请首先有一个概念，<span style="color: rgba(255, 0, 0, 1)">如果没有充足的硬件资源，请不要尝试在本地部署DeepSeek-R1模型</span>，该模型至少需要60G的显存，GPU也是NVidia H100规格的，且是<span style="color: rgba(255, 0, 0, 1)">多卡分布式</span>！</p>
<p class="source-line" data-source-line="14"><strong>使用<span style="color: rgba(0, 0, 255, 1)">线上+线下协作</span>的方式，可能是<span style="color: rgba(0, 0, 255, 1)">普通人训练自己业务场景的最优选择</span>！</strong></p>
<h2 id="1.2-准备工作" class="source-line" data-source-line="16">1.2 准备工作</h2>
<ol>
<li class="source-line" data-source-line="17">
<p class="source-line" data-source-line="17"><strong>注册硅基流动账号</strong>： <a href="https://cloud.siliconflow.cn/i/46A7o0CE" rel="noopener nofollow">硅基流动注册</a><br><img src="https://img2024.cnblogs.com/blog/3366088/202502/3366088-20250212210411595-1842162402.png" alt="" class="vx-image-view-image" width="450"></p>
</li>
<li class="source-line" data-source-line="20">
<p class="source-line" data-source-line="20"><strong>下载<code>CherryStudio</code></strong>：<a href="https://docs.cherry-ai.com/cherrystudio/download" rel="noopener nofollow">下载CherryStudio</a><br>注：目前常用的AI客户端只有<code>CherryStudio</code>工具的知识库支持训练本地素材</p>
</li>
</ol>
<h2 id="1.3-训练本地知识库" class="source-line" data-source-line="23">1.3 训练本地知识库</h2>
<p class="source-line" data-source-line="24">  比如：作者偶尔会写点<code>EverEdit的宏脚本</code>(js语法)，由于EverEdit有自己的API，所以AI必须先学习EverEdit的API。</p>
<h3 id="1.3.1-在cherrystudio中配置密钥" class="source-line" data-source-line="25">1.3.1 在<code>CherryStudio</code>中配置密钥</h3>
<p class="source-line" data-source-line="26">  配置<code>密钥</code>是为了能够让<code>CherryStudio</code>使用AI供应商(这里是<code>硅基流动</code>)的模型</p>
<ol>
<li class="source-line" data-source-line="27">
<p class="source-line" data-source-line="27">步骤1：在<code>siliconflow</code>网站登录后，拷贝自己的<code>密钥</code>，如下图所示：<br><img src="https://img2024.cnblogs.com/blog/3366088/202502/3366088-20250212210411344-80097496.png" alt="" class="vx-image-view-image" width="600"></p>
</li>
<li class="source-line" data-source-line="30">
<p class="source-line" data-source-line="30">步骤2：在<code>CherryStudio</code>中配置密钥，如下图所示：<br><img src="https://img2024.cnblogs.com/blog/3366088/202502/3366088-20250212210411626-2034160265.png" alt="" class="vx-image-view-image" width="1000"></p>
</li>
</ol>
<h3 id="1.3.2-在cherrystudio中训练本地知识库" class="source-line" data-source-line="33">1.3.2 在<code>CherryStudio</code>中训练本地知识库</h3>
<p class="source-line" data-source-line="34">  训练本地知识库的目的：将<code>自有业务</code>知识消化成知识库，结合在线AI(如：DeepSeek)，以解答<code>自有业务</code>领域的问题，而避免投入大量硬件训练完整的专有本地模型。<br>  比如：我偶尔要写<code>EverEdit</code>宏脚本，因此我要训练关于<code>EverEdit</code>的API的本地知识库。</p>
<ol>
<li class="source-line" data-source-line="37">
<p class="source-line" data-source-line="37"><strong>在<code>CherryStudio</code>中新建本地知识库，如下图所示：</strong><br><img src="https://img2024.cnblogs.com/blog/3366088/202502/3366088-20250212210411279-1230578801.png" alt="" class="vx-image-view-image" width="800"></p>
</li>
<li class="source-line" data-source-line="40">
<p class="source-line" data-source-line="40"><strong>将自有业务相关的文档丢到<code>知识库</code>中进行<code>消化</code>(近似动作)，如下图所示：</strong><br><img src="https://img2024.cnblogs.com/blog/3366088/202502/3366088-20250212210411628-1840601445.png" alt="" class="vx-image-view-image" width="800"><br>  消化完成后，会出现绿色的“√”符号</p>
</li>
</ol>
<h3 id="1.3.3-在cherrystudio中使用本地知识库(自有业务)和deepseek在线模型生成自有业务相关代码或答案" class="source-line" data-source-line="44">1.3.3 在<code>CherryStudio</code>中使用本地知识库(自有业务)和<code>DeepSeek</code>在线模型生成自有业务相关代码或答案</h3>
<ol>
<li class="source-line" data-source-line="45"><strong>打开知识库开关，并选择本地知识库，如下图所示：</strong><br>在<code>CherryStudio</code>的导航栏选择“助手”按钮，切换到<code>助手</code>模式<br><img src="https://img2024.cnblogs.com/blog/3366088/202502/3366088-20250212210411594-933125958.png" alt="" class="vx-image-view-image" width="400"></li>
</ol>
<p class="source-line" data-source-line="49">在界面的底部聊天窗口中选择<code>本地知识库</code><br><img src="https://img2024.cnblogs.com/blog/3366088/202502/3366088-20250212210411256-1681219233.png" alt="" class="vx-image-view-image" width="700"></p>
<ol start="2">
<li class="source-line" data-source-line="52">
<p class="source-line" data-source-line="52"><strong>提出问题并解答，如下图所示</strong>：</p>
<ol>
<li class="source-line" data-source-line="53"><strong>用户提出问题让AI解答</strong><br><img src="https://img2024.cnblogs.com/blog/3366088/202502/3366088-20250212210411327-300745169.png" alt="" class="vx-image-view-image" width="800"></li>
<li class="source-line" data-source-line="55"><strong>出现问题，让AI修正</strong><br><img src="https://img2024.cnblogs.com/blog/3366088/202502/3366088-20250212210411608-90125397.png" alt="" class="vx-image-view-image" width="800"></li>
<li class="source-line" data-source-line="57"><strong>还有问题，继续让AI修正</strong><br><img src="https://img2024.cnblogs.com/blog/3366088/202502/3366088-20250212210411609-436610687.png" alt="" class="vx-image-view-image" width="800"><br>注：后面还有很多让AI修正的步骤，这里不一一列举。</li>
<li class="source-line" data-source-line="60"><strong>最终AI生成的代码</strong></li>
</ol>
<div class="code-toolbar">
<pre class="language-js line-numbers highlighter-hljs"><code>// 获取当前文档对象
var doc = App.ActiveDoc;

// 获取文档内容
var text = doc.Text;

// 获取用户输入的分隔符，默认使用“,”
var delimiter = App.ShowInputBox("请输入分隔符（默认按','分隔）：", "分隔符输入");
if (!delimiter) {
    delimiter = ",";
}

// 获取制表符宽度
var tabWidth = doc.TabStop;

// 按换行符拆分文档内容
var lines = text.split("\n");
var columns = [];
for (var i = 0; i &lt; lines.length; i++) {
    columns.push(lines[i].split(delimiter));
}

// 计算字符串的显示宽度（中文字符占2，中文符号“和”占1，英文字符占1，Tab键按制表符宽度计算）
function getDisplayWidth(str) {
    var width = 0;
    for (var i = 0; i &lt; str.length; i++) {
        var char = str.charAt(i); // 使用 str.charAt(i) 获取字符
        if (char === "\t") {
            // 计算 Tab 宽度，对齐到下一个制表符位置 [^1]
            width += tabWidth - (width % tabWidth);
        } else if (char === "“" || char === "”") {
            width += 1; // 中文符号“和”占1个宽度
        } else {
            var charCode = str.charCodeAt(i);
            if (charCode &gt;= 0 &amp;&amp; charCode &lt;= 127) {
                width += 1; // 英文字符或半角字符
            } else {
                width += 2; // 中文字符或全角字符
            }
        }
    }
    return width;
}

// 计算每列的最大显示宽度
var maxWidths = [];
for (var i = 0; i &lt; columns.length; i++) {
    for (var j = 0; j &lt; columns[i].length; j++) {
        var width = getDisplayWidth(columns[i][j]);
        if (!maxWidths[j] || width &gt; maxWidths[j]) {
            maxWidths[j] = width;
        }
    }
}

// 生成对齐后的文本（在分隔符后面多填充1个空格）
var alignedText = "";
for (var i = 0; i &lt; columns.length; i++) {
    for (var j = 0; j &lt; columns[i].length; j++) {
        var cell = columns[i][j];
        // 添加单元格内容
        alignedText += cell;
        // 在分隔符后面填充空格（多填充1个空格）
        if (j &lt; columns[i].length - 1) {
            var cellWidth = getDisplayWidth(cell);
            var padding = "";
            for (var k = 0; k &lt; maxWidths[j] - cellWidth; k++) {
                padding += " ";
            }
            alignedText += delimiter + " " + padding; // 分隔符后多填充1个空格
        }
    }
    if (i &lt; columns.length - 1) {
        alignedText += "\n";
    }
}

// 将对齐后的内容写回文档
doc.Text = alignedText;</code></pre>
</div>
<ol start="5">
<li class="source-line" data-source-line="144"><strong>脚本执行后的效果</strong><br>对齐前：<br><img src="https://img2024.cnblogs.com/blog/3366088/202502/3366088-20250212210411307-166764918.png" alt="" class="vx-image-view-image" width="800"><br>脚本执行列对齐后：<br><img src="https://img2024.cnblogs.com/blog/3366088/202502/3366088-20250212210411612-562440103.png" alt="" class="vx-image-view-image" width="800"></li>
</ol>
<p class="source-line" data-source-line="150"><span style="color: rgba(0, 0, 255, 1)"><strong>哇！是不是很整齐！这都是AI自己写的脚本哦！</strong></span></p>
</li>
</ol>
<hr>
<p class="source-line" data-source-line="153">作者声明：本文用于记录和分享作者的学习心得，可能有部分文字或示例来源自豆包AI，由于本人水平有限，难免存在表达错误，欢迎留言交流和指教！<br>Copyright © 2022~2025 All rights reserved.</p>
</div>
</div>
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04822675208333333" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-12 21:05">2025-02-12 21:04</span>&nbsp;
<a href="https://www.cnblogs.com/tyysoft">tyysoft</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18712138" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18712138);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18712138', targetLink: 'https://www.cnblogs.com/tyysoft/p/18712138', title: '大人，时代变了！ 赶快把自有业务的本地AI“模型”训练起来！' })">举报</a>
</div>
        