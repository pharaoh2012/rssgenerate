
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cikiss/p/18730406" title="发布于 2025-02-21 23:08">
    <span role="heading" aria-level="2">图解MySQL【日志】——Binlog</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="binlogbinary-log归档日志">Binlog（Binary Log，归档日志）</h1>
<h2 id="为什么需要-binlog">为什么需要 Binlog？</h2>
<ul>
<li>Binlog 是 MySQL 中的二进制日志，用于记录数据库的所有写操作（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 等）</li>
</ul>
<h3 id="1-主从复制">1. 主从复制</h3>
<ul>
<li><strong>作用</strong>：是 MySQL 主从复制的核心，主库将 Binlog 发送给从库，从库重放这些操作以保持数据同步。</li>
<li><strong>场景</strong>：读写分离、负载均衡和高可用性。</li>
</ul>
<hr>
<h3 id="2-数据恢复">2. 数据恢复</h3>
<ul>
<li><strong>作用</strong>：Binlog 记录了所有写操作，可用于数据丢失时或误操作时恢复数据。</li>
<li><strong>场景</strong>：通过回放 Binlog，可将数据库恢复到特点时间点或事务点。</li>
</ul>
<hr>
<h3 id="3-审计">3. 审计</h3>
<ul>
<li><strong>作用</strong>：Binlog 记录了所有写操作的详细信息，可用于审计数据库变更。</li>
<li><strong>场景</strong>：追踪数据变更历史，满足合规要求。</li>
</ul>
<hr>
<h3 id="4-增量备份只备份从上次备份以来发生变化的数据">4. 增量备份（只备份从上次备份以来发生变化的数据）</h3>
<ul>
<li><strong>作用</strong>：Binlog 用于增量备份，减少备份时间和存储空间。</li>
<li><strong>场景</strong>：定期备份 Binlog，结合全量备份实现高校数据恢复。</li>
</ul>
<hr>
<h3 id="5-数据同步">5. 数据同步</h3>
<ul>
<li><strong>作用</strong>：Binlog可用于将数据同步到其他系统，如数据仓库或缓存。</li>
<li><strong>场景</strong>：保持不同系统间的数据一致性。</li>
</ul>
<hr>
<h2 id="binlog-是什么">Binlog 是什么？</h2>
<h3 id="1-适用对象">1. 适用对象</h3>
<ul>
<li>Binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可使用。</li>
</ul>
<hr>
<h3 id="2-binlog-的内容记录逻辑操作">2. Binlog 的内容（记录逻辑操作）</h3>
<ul>
<li><strong>事件类型</strong>：如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>DDL</code>（如 <code>CREATE TABLE</code>）等。</li>
<li><strong>操作数据</strong>：受影响的行数据（旧值和新值）。</li>
<li><strong>事务信息</strong>：事务的开始和提交时间、事务 ID 等。</li>
<li><strong>时间戳</strong>：操作发生的时间。</li>
</ul>
<hr>
<h3 id="3-binlog-的格式">3. Binlog 的格式</h3>
<h4 id="statement-based基于语句">Statement-Based（基于语句）</h4>
<ul>
<li>记录实际的 SQL 语句（逻辑操作）。</li>
<li>优点：日志文件小，记录简单。</li>
<li>缺点：动态函数不一致问题（如 <code>UUID()</code>、<code>NOW()</code>等），导致主从不一致。</li>
</ul>
<hr>
<h4 id="row-based基于行">Row-Based（基于行）</h4>
<ul>
<li>记录每一行数据的变更（旧值和新值）。</li>
<li>优点：数据一致性高，适合复杂操作。</li>
<li>缺点：日志文件较大。</li>
</ul>
<hr>
<h4 id="mixed默认混合模式">Mixed【默认】（混合模式）</h4>
<ul>
<li>根据情况进行选择，自动切换到另外两种模式。</li>
<li>平衡了数据一致性与日志大小。</li>
</ul>
<hr>
<h3 id="4-binlog-的写入方式">4. Binlog 的写入方式</h3>
<h4 id="追加写">追加写</h4>
<ul>
<li>写满一个文件，就创建一个新文件继续写，不会覆盖之前的记录，保存的是全量日志。</li>
</ul>
<h4 id="对比-redo-log-的循环写为什么-binlog-采用追加写">对比 Redo Log 的循环写，为什么 Binlog 采用追加写？</h4>
<ul>
<li>Redo Log 目的保证<strong>事务持久性</strong>和<strong>崩溃恢复</strong>，只记录未写入磁盘的数据和物理日志，是<strong>事务级别的写入</strong>，已经刷入磁盘的数据不进行擦除会浪费空间。</li>
<li>Binlog 的目的是<strong>主从复制和备份恢复</strong>，是<strong>语句（或行）级别的写入</strong>，采用追加写，追加写的方式<strong>保证了日志的持续性和历史性</strong>，不会因为日志满了而覆盖掉有用的数据。用户通常需要依赖Binlog来回溯数据库的操作历史。</li>
</ul>
<hr>
<h2 id="binlog-实现主从复制">Binlog 实现主从复制</h2>
<p>MySQL 的主从复制依赖于 Binlog，即记录 MySQL 上所有变化并以二进制形式保存在磁盘上，复制的过程是将 Binlog 中的数据从主库传输到从库上。且这个过程一般是异步的——主库上执行事务操作的线程不会等待复制 Binlog 的线程同步完成。</p>
<p>在完成主从复制后，就可以实现主写从读的模式了，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。<img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/dd2b07fe48954a9b9c08253bf49b705a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1740236848&amp;x-orig-sign=8xefLFy7HRRv0rSXAn5%2BS3%2FzlQ8%3D" alt="" loading="lazy"></p>
<h3 id="1-binlog-主从复制过程">1. Binlog 主从复制过程</h3>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/3ba838f498554958896419051eb1783c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1740236848&amp;x-orig-sign=EQgEZexnZzd1FpKPMTNY6rb2sbc%3D" alt="" loading="lazy"></p>
<h4 id="11-写入-binlog">1.1. 写入 Binlog</h4>
<ul>
<li>主库写 Binlog 日志，并以两阶段提交的方式提交事务，并更新本地缓存。</li>
<li><strong>详细过程</strong>：MySQL 主库在收到客户端提交事务的请求后，先写入 Binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li>
</ul>
<hr>
<h4 id="12-同步-binlog">1.2. 同步 Binlog</h4>
<ul>
<li>把 Binlog 复制到所有从库中，每个从库把 Binlog 写到暂存日志中。</li>
<li><strong>详细过程</strong>：从库创建一个特定的 I/O 线程，连接主库的 <code>log dump</code> 线程，来接收主库的 Binlog 日志，再把 Binlog 信息写入 Relay Log 的中继日志里，再返回给主库“复制成功”的响应。</li>
</ul>
<hr>
<h4 id="13-回放-binlog">1.3. 回放 Binlog</h4>
<ul>
<li>回放 Binlog，并更新存储引擎中的数据。</li>
<li><strong>详细过程</strong>：从库创建一个用于回放 Binlog 的线程，去读 Relay Log 中继日志，然后回放 Binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li>
</ul>
<hr>
<h3 id="2-从库是不是越多越好">2. 从库是不是越多越好？</h3>
<ul>
<li>不是的，从库的数量增加，从库连接的 I/O 线程也会增加，<strong>主库也要创建同样多的</strong> <code>log dump</code> <strong>线程处理复制的请求，对主库资源消耗增高，同时也受限于主库的网络带宽</strong>。</li>
<li>所以实际中，1 个主库一般跟 2~3 个从库（1 主 2 从 1 备），即一主多从 MySQL 集群结构。</li>
</ul>
<hr>
<h3 id="3-mysql-主从复制模型">3. MySQL 主从复制模型</h3>
<h4 id="31-同步复制">3.1. 同步复制</h4>
<ul>
<li>MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果，在实际项目中基本不用。</li>
<li><strong>缺点</strong>：性能差；可用性差——主库和所有从库任何一个数据库出问题，都会影响业务。</li>
</ul>
<hr>
<h4 id="32-异步复制默认模型">3.2. 异步复制（默认模型）</h4>
<ul>
<li>MySQL 主库提交事务的线程并不会等待 Binlog 同步到各从库，就返回客户端。</li>
<li><strong>缺点</strong>：一旦主库宕机，数据就会丢失。</li>
</ul>
<hr>
<h4 id="33-半同步复制mysql-57-以后">3.3. 半同步复制（MySQL 5.7 以后）</h4>
<ul>
<li>介于同步与异步复制之间，事务线程不用等待所有从库复制成功响应，只要一部分复制成功响应就可以返回客户端结果。</li>
<li><strong>优点</strong>：兼顾了同步与异步复制的优点，即使主库宕机，至少有一个从库有最新的数据，且性能也很好。</li>
</ul>
<hr>
<h2 id="binlog-持久化过程">Binlog 持久化过程</h2>
<h3 id="1-binlog-cache">1. Binlog Cache</h3>
<ul>
<li><strong>Binlog Cache—线程缓冲区</strong>：MySQL 给每个线程分配一片内存区域用于缓冲 Binlog，即 Binlog Cache，参数 <code>binlog_cache_size</code> 用于控制单个线程内 Binlog Cache 所占内存的大小，若超过了这个参数，则暂存到磁盘中。</li>
<li><strong>先写入 Binlog Cache</strong>：事务执行时，先将日志写到 Binlog Cache（Server 层的 cache），事务提交时，再将 Binlog Cache 写到 Binlog 文件中。</li>
<li><strong>事务的串行执行</strong>：当一个线程开始执行一个新事务（通过 <code>BEGIN</code> 或 <code>START TRANSACTION</code>）时，MySQL 会确保该线程之前的事务（如果有）已经提交或回滚。也就是说，一个线程不能同时并行执行多个事务。</li>
<li><strong>Binlog 的写入原子性</strong>：由于一个线程在同一时间只能处理一个事务，因此该事务的 Binlog 日志必须保证一次性完整写入，而不能拆分为多个，即 Binlog 需要保证事务的原子性：一个事务的所有操作要么全部生效，要么全部不生效。如果不保证 Binlog 的原子性，从库在重放时，可能会将拆分后的日志当作多个独立的事务执行，破坏了主库事务的原子性。</li>
</ul>
<hr>
<h3 id="2-持久化过程">2. 持久化过程</h3>
<p>每个线程将缓冲在 Binlog Cache 中的日志文件，最终写到同一个 Binlog 文件。</p>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/47bf10ade99841c799589b4353a10fca~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1740236848&amp;x-orig-sign=N7IO8n5I9TWUceqFBW1KbmjbKSY%3D" alt="" loading="lazy"></p>
<ul>
<li><code>write</code>：将日志写入到 Binlog 文件（OS 中的 page cache 中），但未持久化到磁盘，因为不涉及磁盘 I/O 操作，write 的写入速度很快。</li>
<li><code>fsync</code>：将数据持久化到磁盘中，因涉及磁盘 I/O 操作，写入较慢，故频繁 <code>fsync</code> 会导致磁盘 I/O 升高。</li>
</ul>
<hr>
<h3 id="3-sync_binlog-参数控制-mysql-的-binlog-刷盘频率">3. <code>sync_binlog</code> 参数——控制 MySQL 的 Binlog 刷盘频率</h3>
<ul>
<li><strong>= 0 时（默认）</strong> ：每次提交事务时，只 <code>write</code>，不 <code>fsync</code>，后续由 OS 择机将数据持久化到磁盘。</li>
</ul>

<ul>
<li>
<ul>
<li>性能：最好。</li>
<li>风险：最大，一旦发生异常重启，还未持久化到磁盘中的数据就会全部丢失。</li>
</ul>
</li>
</ul>

<ul>
<li><strong>= 1 时</strong>：每次提交事务时，先 <code>write</code>，后马上执行 <code>fsync</code>。</li>
</ul>

<ul>
<li>
<ul>
<li>性能：最差。</li>
<li>风险：最小，即使异常重启，最多丢失一个事务的 Binlog。</li>
</ul>
</li>
</ul>

<ul>
<li><strong>= N（N &gt; 1）时</strong>：每次提交事务时，都 <code>write</code>，积累 N 个事务后再 <code>fsync</code>。</li>
</ul>

<ul>
<li>
<ul>
<li>性能与风险都适中，可以根据系统进行特定配置，一般的设置范围： 100 ~ 1000。</li>
</ul>
</li>
</ul>
<hr>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4111053570914352" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-21 23:08">2025-02-21 23:08</span>&nbsp;
<a href="https://www.cnblogs.com/cikiss">SlackClimb</a>&nbsp;
阅读(<span id="post_view_count">18</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18730406" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18730406);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18730406', targetLink: 'https://www.cnblogs.com/cikiss/p/18730406', title: '图解MySQL【日志】——Binlog' })">举报</a>
</div>
        