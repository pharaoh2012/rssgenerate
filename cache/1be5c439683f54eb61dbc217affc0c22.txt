
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zpcdbky/p/18837914" title="发布于 2025-06-02 18:15">
    <span role="heading" aria-level="2">虚函数表里有什么？（四）——虚拟继承</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文首先以简单虚拟继承为例，向读者展示了在虚继承条件下，即使没有虚函数，也会存在虚函数表，用来记录 this 指针调整、动态类型转换等所需的信息。接下来，以菱形继承为例，详细介绍了VTT以及的construction vtable，深入探讨了该结构存在的原因以及在对象构造/析构中的作用。最后，详细讲解了虚析构函数、构造函数、 vbase_offset 和 vcall_offset 等与虚继承相关的虚表条目。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>简单虚拟继承</h1>
<p>示例代码如下：</p>
<div class="cnblogs_code">
<pre>#include &lt;iostream&gt;

<span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> VBase
{
    </span><span style="color: rgba(0, 0, 255, 1)">void</span> zoo() { std::cout &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">VBase::zoo()\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> vb_data = <span style="color: rgba(128, 0, 128, 1)">100</span><span style="color: rgba(0, 0, 0, 1)">;
};

</span><span style="color: rgba(0, 0, 255, 1)">struct</span> Derived : <span style="color: rgba(0, 0, 255, 1)">virtual</span> <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> VBase
{
    </span><span style="color: rgba(0, 0, 255, 1)">void</span> foo() { std::cout &lt;&lt; <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Derived::foo()\n</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">; }
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> d_data = <span style="color: rgba(128, 0, 128, 1)">200</span><span style="color: rgba(0, 0, 0, 1)">;
};

</span><span style="color: rgba(0, 0, 255, 1)">int</span> main(<span style="color: rgba(0, 0, 255, 1)">int</span> argc, <span style="color: rgba(0, 0, 255, 1)">char</span> *<span style="color: rgba(0, 0, 0, 1)">argv[])
{
    Derived d;
    d.foo();
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<p>上面的代码中，并没有虚函数，那么，编译器会为它生成vtable吗？<a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:8,positionColumn:1,positionLineNumber:8,selectionStartColumn:1,selectionStartLineNumber:8,startColumn:1,startLineNumber:8),source:'%23include+%3Ciostream%3E%0A%0Astruct+VBase%0A%7B%0A++++void+zoo()+%7B+std::cout+%3C%3C+%22VBase::zoo()%5Cn%22%3B+%7D%0A++++int+vb_data+%3D+100%3B%0A%7D%3B%0A%0Astruct+Derived+:+virtual+public+VBase%0A%7B%0A++++void+foo()+%7B+std::cout+%3C%3C+%22Derived::foo()%5Cn%22%3B+%7D%0A++++int+d_data+%3D+200%3B%0A%7D%3B%0A%0Aint+main(int+argc,+char+*argv%5B%5D)%0A%7B%0A++++Derived+d%3B%0A++++d.foo()%3B%0A++++return+0%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g142,filters:(b:'0',binary:'1',binaryObject:'1',commentOnly:'0',debugCalls:'1',demangle:'0',directives:'0',execute:'0',intel:'1',libraryCode:'0',trim:'1',verboseDemangling:'0'),flagsViewOpen:'1',fontScale:13,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!(),options:'-g+-O2+-fno-inline',overrides:!(),selection:(endColumn:27,endLineNumber:22,positionColumn:27,positionLineNumber:22,selectionStartColumn:27,selectionStartLineNumber:22,startColumn:27,startLineNumber:22),source:1),l:'5',n:'0',o:'+x86-64+gcc+14.2+(Editor+%231)',t:'0')),k:50,l:'4',m:81.27009646302251,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compilerName:'x86-64+clang+17.0.1',editorid:1,fontScale:14,fontUsePx:'0',j:1,wrap:'1'),l:'5',n:'0',o:'Output+of+x86-64+gcc+14.2+(Compiler+%231)',t:'0')),header:(),l:'4',m:18.72990353697749,n:'0',o:'',s:0,t:'0')),k:50,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4" target="_blank" rel="noopener nofollow">Compilerr Explorer</a>直观地给出了答案。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202504/642223-20250417232232837-1017362501.png" alt="" loading="lazy"></p>
<p>既然连虚函数都没有，那要vtable还有什么用呢？为了搞懂这个问题，我们先来看看对象和vtable的内存布局，以及vtable中都有什么。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202504/642223-20250427235722288-721995858.png" alt="" style="width: 800px; height: auto"></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ▲ 图1 简单虚拟继承下，对象和vtable的内存布局</p>
<h2>vbase_offset</h2>
<p>接下来，我们考虑下面的代码：</p>
<div class="cnblogs_code">
<pre>Derived *pd = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Derived;
pd</span>-&gt;<span style="color: rgba(0, 0, 0, 1)">zoo();
</span><span style="color: rgba(0, 0, 255, 1)">delete</span> pd;</pre>
</div>
<p>因为&nbsp;<span class="cnblogs_code">zoo</span>&nbsp;是虚基类VBase的函数，通过指向派生类对象的指针&nbsp;<span class="cnblogs_code">pd</span>&nbsp;调用时，就需要调整&nbsp;<span class="cnblogs_code">this</span>&nbsp;指针，让我们来看看对应的汇编代码：</p>
<div class="cnblogs_code">
<pre>movq    -<span style="color: rgba(128, 0, 128, 1)">24</span>(%rbp), %rax  <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> -24(%rbp)里存放的是pd指针，即上图中的0x7fffffffdf60</span>
movq    (%rax), %rax     <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 指针解引用，得到对象的前8字节内容，即vtable for Derived+24，即上图中的0x555555557d58</span>
subq    $<span style="color: rgba(128, 0, 128, 1)">24</span>, %rax        <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 虚函数表地址减去24，得到指向vbase offset的指针，即上图的0x555555557d40</span>
movq    (%rax), %rax     <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 解引用，得到vbase offset的值，即上图的12</span>
movq    %rax, %rdx       <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 将vbase offset存到rdx</span>
movq    -<span style="color: rgba(128, 0, 128, 1)">24</span>(%rbp), %rax  <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 再次取出对象首地址，即this指针，存入rax</span>
addq    %rdx, %rax       <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 即 this = this + vbase_offset = 0x7fffffffdf60 + 12 = 0x7fffffffdf6c，调整this指针，使this指针指向虚基类子对象VBase</span>
movq    %rax, %rdi       <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 新的this指针存入rdi，作为调用VBase::zoo()的参数</span>
<span style="color: rgba(0, 0, 255, 1)">call</span>    <span style="color: rgba(0, 128, 128, 1)">VBase:</span>:zoo()</pre>
</div>
<p>&nbsp;</p>
<p>也就是说，当我们需要通过派生类对象访问虚基类子对象的时候，需要通过两者之间的偏移，来调整&nbsp;<span class="cnblogs_code">this</span>&nbsp;指针，这个偏移量保存在派生类的虚函数表中，即&nbsp;<span class="cnblogs_code">vbase_offset</span>&nbsp;。那么，为什么当存在虚基类时，就需要&nbsp;<span class="cnblogs_code">vbase_offset</span>&nbsp;呢？我们在后文中揭晓答案。</p>
<h2>VTT</h2>
<p>通常，vptr指向vtable中第一个虚函数，但本例中，没有虚函数，因此vptr实际上指向了vtable的外部（vtable中一共有3个条目，vptr指向了偏移量为24的位置，正好是vtable的下方）。本例中，&nbsp;<span class="cnblogs_code">0x555555557d58</span>&nbsp;（即vptr指向的位置）实际指向了一个名为VTT（Virtual Table Table）的结构，顾名思义，该结构中的每一个条目都是一个指向vtable的指针，即vptr。本例中，VTT中只有一个条目，就是&nbsp;<span class="cnblogs_code">vtable for Derived + 24</span>&nbsp;。这里有一点绕，我们再来捋一下。由于没有虚函数，因此vptr指向了vtable的外部，这恰好<sup>[1]</sup>是VTT，确切说是VTT中的第一个条目的位置。而本例中，VTT中有且仅有一个条目，就是指向&nbsp;<span class="cnblogs_code">Derived</span>&nbsp;的虚表的vptr。因此，出现了vptr指向的内容就是vptr本身（address和value都是&nbsp;<span class="cnblogs_code">0x555555557d58</span>&nbsp;）的现象。关于VTT的作用（为什么需要VTT？），光靠本例还不能很好地说明，等到后文讲到菱形继承时，再为大家详细解释。</p>
<h2>__vmi_class_type_info成员解释</h2>
<p>让我们再来看一下本例中&nbsp;<span class="cnblogs_code">__vmi_class_type_info</span>&nbsp;的成员，不了解&nbsp;<span class="cnblogs_code">__vmi_class_type_info</span>&nbsp;的读者，可以先去上篇文章学习相关的基础知识。这里仅讲解笔者认为需要重点关注的、和之前取值不一样的成员。</p>
<h3>__flags &amp; __base_count</h3>
<p><span class="cnblogs_code">__flags</span>&nbsp;：本例中，既没有重复的基类（对应&nbsp;<span class="cnblogs_code">__non_diamond_repeat_mask = 0x1</span>&nbsp;），又不是菱形继承（对应&nbsp;<span class="cnblogs_code">__diamond_shaped_mask = 0x2</span>&nbsp;），因此&nbsp;<span class="cnblogs_code">__flags</span>&nbsp;是0。</p>
<p><span class="cnblogs_code">__base_count</span>&nbsp;：本例中，只有一个直接基类，因此&nbsp;<span class="cnblogs_code">__base_count</span>&nbsp;等于1。</p>
<h3>__base_class_type_info::offset_flags&nbsp;</h3>
<p>Itanium C++ ABI对此的解释是</p>
<blockquote>
<p>All but the lower 8 bits of&nbsp;<code>__offset_flags</code>&nbsp;are a signed offset. For a non-virtual base, this is the offset in the object of the base subobject. For a virtual base, this is the offset in the virtual table of the virtual base offset for the virtual base referenced (negative).</p>
</blockquote>
<p>即&nbsp;<span class="cnblogs_code">__offset_flags</span>&nbsp;中除低8 bit以外的部分，是一个偏移量。对于非虚基类而言，表示该基类子对象在完整对象中的偏移；对于虚基类而言，表示&nbsp;<span class="cnblogs_code">vtable_offset</span>&nbsp;的地址相对于vptr的偏移量（这个偏移量是一个负数）。如图1，本例中，&nbsp;<span class="cnblogs_code">vtable_offset</span>&nbsp;的地址是&nbsp;<span class="cnblogs_code">0x555555557d40</span>&nbsp;，vptr是&nbsp;<span class="cnblogs_code">0x555555557d58</span>&nbsp;，即&nbsp;<span class="cnblogs_code">vtable_offset</span>&nbsp;相对vptr的偏移量是&nbsp;<span class="cnblogs_code">0x555555557d40 - 0x555555557d58 = -24</span>&nbsp;。而&nbsp;<span class="cnblogs_code">__offset_flags</span>&nbsp;的值是&nbsp;<span class="cnblogs_code">0xffffffffffffe803</span>&nbsp;，&nbsp;<span class="cnblogs_code">0xffffffffffffe803 &gt;&gt; 8 = 0xffffffffffffe8</span>&nbsp;，正好是-24的补码表示。</p>
<p><span class="cnblogs_code">__offset_flags</span>&nbsp;的低8 bit表示flags，本例中，基类&nbsp;<span class="cnblogs_code">VBase</span>&nbsp;既是虚基类（对应&nbsp;<span class="cnblogs_code">__virtual_mask = 0x1</span>&nbsp;），又是public基类（对应&nbsp;<span class="cnblogs_code">__public_mask = 0x2</span>&nbsp;），因此&nbsp;<span class="cnblogs_code">__offset_flags</span>&nbsp;的低8 bit是&nbsp;<span class="cnblogs_code">0x03</span>&nbsp;（&nbsp;<span class="cnblogs_code">__virtual_msat | __public_mask</span>&nbsp;）。</p>
<h2>为什么需要虚函数表？</h2>
<p>现在我们知道了，当存在虚基类时，即使没有虚函数，我们也需要在虚函数表中记录必要的信息以供运行时使用，比如通过派生类对象访问虚基类子对象时所需的&nbsp;<span class="cnblogs_code">vbase_offset</span>&nbsp;，动态类型转换（&nbsp;<span class="cnblogs_code">dynamic_cast</span>&nbsp;）时所需的&nbsp;<span class="cnblogs_code">typeinfo</span>&nbsp;等。</p>
<h1>菱形继承</h1>
<p>示例代码如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> GrandParent
{
</span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
    GrandParent() {}
    </span><span style="color: rgba(0, 0, 255, 1)">virtual</span> ~<span style="color: rgba(0, 0, 0, 1)">GrandParent() {}
    </span><span style="color: rgba(0, 0, 255, 1)">virtual</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> foo() {}
    </span><span style="color: rgba(0, 0, 255, 1)">virtual</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> zoo() {}
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> grandparent_data = <span style="color: rgba(128, 0, 128, 1)">100</span><span style="color: rgba(0, 0, 0, 1)">;
};

</span><span style="color: rgba(0, 0, 255, 1)">class</span> Parent1 : <span style="color: rgba(0, 0, 255, 1)">virtual</span> <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> GrandParent
{
</span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
    Parent1() {}
    </span><span style="color: rgba(0, 0, 255, 1)">virtual</span> ~<span style="color: rgba(0, 0, 0, 1)">Parent1() {}
    </span><span style="color: rgba(0, 0, 255, 1)">virtual</span> <span style="color: rgba(0, 0, 255, 1)">void</span> foo() <span style="color: rgba(0, 0, 255, 1)">override</span><span style="color: rgba(0, 0, 0, 1)"> {}
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> parent1_data = <span style="color: rgba(128, 0, 128, 1)">200</span><span style="color: rgba(0, 0, 0, 1)">;
};

</span><span style="color: rgba(0, 0, 255, 1)">class</span> Parent2 : <span style="color: rgba(0, 0, 255, 1)">virtual</span> <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> GrandParent
{
</span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
    Parent2() {}
    </span><span style="color: rgba(0, 0, 255, 1)">virtual</span> ~<span style="color: rgba(0, 0, 0, 1)">Parent2() {}
    </span><span style="color: rgba(0, 0, 255, 1)">virtual</span> <span style="color: rgba(0, 0, 255, 1)">void</span> zoo() <span style="color: rgba(0, 0, 255, 1)">override</span><span style="color: rgba(0, 0, 0, 1)"> {}
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> parent2_data = <span style="color: rgba(128, 0, 128, 1)">300</span><span style="color: rgba(0, 0, 0, 1)">;
};

</span><span style="color: rgba(0, 0, 255, 1)">class</span> Child : <span style="color: rgba(0, 0, 255, 1)">public</span> Parent1, <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> Parent2
{
</span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
    Child() {}
    </span><span style="color: rgba(0, 0, 255, 1)">virtual</span> ~<span style="color: rgba(0, 0, 0, 1)">Child() {}
    </span><span style="color: rgba(0, 0, 255, 1)">int</span> child_data = <span style="color: rgba(128, 0, 128, 1)">400</span><span style="color: rgba(0, 0, 0, 1)">;
};

</span><span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> main()
{
    Child </span>*p_child = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Child;
    Parent1 </span>*p_parent1_sub =<span style="color: rgba(0, 0, 0, 1)"> p_child;
    GrandParent </span>*p_gp1 =<span style="color: rgba(0, 0, 0, 1)"> p_parent1_sub;
    p_gp1</span>-&gt;<span style="color: rgba(0, 0, 0, 1)">foo();

    Parent1 </span>*p_parent1 = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Parent1;
    GrandParent </span>*p_gp2 =<span style="color: rgba(0, 0, 0, 1)"> p_parent1;
    p_gp2</span>-&gt;<span style="color: rgba(0, 0, 0, 1)">foo();

    </span><span style="color: rgba(0, 0, 255, 1)">delete</span><span style="color: rgba(0, 0, 0, 1)"> p_child;
    </span><span style="color: rgba(0, 0, 255, 1)">delete</span><span style="color: rgba(0, 0, 0, 1)"> p_parent1;
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<h2>为什么需要VTT？</h2>
<p>前文已经提到过VTT，它是一个列表，表中的每一项都是一个虚表指针。该表在对象的构造/析构过程中发挥了重要作用。本文将以&nbsp;<span class="cnblogs_code">Child</span>&nbsp;类对象的构造过程为例，探究为什么需要VTT。不过在此之前，我们先给出VTT及其指向的vtable的内存布局。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202505/642223-20250531130257718-1624311700.png" alt="" style="width: 1000px; height: auto"></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ▲ 图2 VTT及vtable的内存布局</p>
<p>上图中，cod表示complete object destructor，dd表示deleting destructor，这两种析构函数的区别在之前的文章中已详细说明，此处不再赘述。</p>
<h3>从构造过程看VTT作用</h3>
<h4>step1：构造虚基类子对象</h4>
<p>从下面的汇编代码可以看出，程序首先为完整对象&nbsp;<span class="cnblogs_code">Child</span>&nbsp;分配了内存，并在分配的内存中构造了虚基类&nbsp;<span class="cnblogs_code">GrandParent</span>&nbsp;的对象。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">main:</span><span style="color: rgba(0, 0, 0, 1)">
       pushq   %rbp
       movl    $</span><span style="color: rgba(128, 0, 128, 1)">48</span>, %edi    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> operator new的参数，分配48字节内存</span>
<span style="color: rgba(0, 0, 0, 1)">       pushq   %rbx
       subq    $</span><span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">, %rsp
       </span><span style="color: rgba(0, 0, 255, 1)">call</span>    operator new(unsigned long)    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 分配内存</span>
       movq    %rax, %rbp    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> new返回的指针存入%rbp</span>
       movq    %rax, %rdi    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> new返回的指针存入%rbp，作为参数调用Child::Child()</span>
       <span style="color: rgba(0, 0, 255, 1)">call</span>    <span style="color: rgba(0, 128, 128, 1)">Child:</span><span style="color: rgba(0, 0, 0, 1)">:Child() [complete object constructor]

</span><span style="color: rgba(0, 128, 128, 1)">Child:</span><span style="color: rgba(0, 0, 0, 1)">:Child() [complete object constructor]:
       pushq   %rbx
       movq    %rdi, %rbx        </span><span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> %rdi保存的是new返回的地址，也是Child对象的首地址</span>
       leaq    <span style="color: rgba(128, 0, 128, 1)">32</span>(%rdi), %rdi    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 首地址偏移32字节，作为参数调用虚基类构造函数</span>
       <span style="color: rgba(0, 0, 255, 1)">call</span>    <span style="color: rgba(0, 128, 128, 1)">GrandParent:</span><span style="color: rgba(0, 0, 0, 1)">:GrandParent() [base object constructor]

</span><span style="color: rgba(0, 128, 128, 1)">GrandParent:</span><span style="color: rgba(0, 0, 0, 1)">:GrandParent() [base object constructor]:
       movq    $vtable for GrandParent+</span><span style="color: rgba(128, 0, 128, 1)">16</span>, (%rdi)    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 设置虚表指针</span>
       movl    $<span style="color: rgba(128, 0, 128, 1)">100</span>, <span style="color: rgba(128, 0, 128, 1)">8</span>(%rdi)                         <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 设置数据成员</span>
       <span style="color: rgba(0, 0, 255, 1)">ret</span></pre>
</div>
<p>构造完成后，内存布局如下所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202505/642223-20250531000752826-1284973917.png" alt="" style="width: 1000px; height: auto"></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ▲ 图3 虚基类子对象及其vtable的内存布局</p>
<h4>step2：构造基类Parent1子对象</h4>
<p><a name="code_1"></a>前面的文章中讲到，在构造过程中，当前正在构造谁，谁就是“临时的”完整对象，整个对象的类型就是谁，因此，虚函数指针会不断调整。但跟之前不同的是，这里使用了construction vtable这种特殊的vtable。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">Child:</span><span style="color: rgba(0, 0, 0, 1)">:Child() [complete object constructor]:
       pushq   %rbx
       movq    %rdi, %rbx        </span><span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> %rdi保存的是new返回的地址，也是Child对象的首地址</span>
       leaq    <span style="color: rgba(128, 0, 128, 1)">32</span>(%rdi), %rdi    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 首地址偏移32字节，作为参数调用虚基类构造函数</span>
       <span style="color: rgba(0, 0, 255, 1)">call</span>    <span style="color: rgba(0, 128, 128, 1)">GrandParent:</span><span style="color: rgba(0, 0, 0, 1)">:GrandParent() [base object constructor]
=&gt;     movq    %rbx, %rdi        </span><span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 将Child对象首地址作为调用Parent1::Parent1()的第1个参数，即this指针</span>
       movl    $VTT for Child+<span style="color: rgba(128, 0, 128, 1)">8</span>, %esi    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 将VTT中第2个条目的地址作为调用Parent1::Parent1()的第2个参数</span>
       <span style="color: rgba(0, 0, 255, 1)">call</span>    <span style="color: rgba(0, 128, 128, 1)">Parent1:</span><span style="color: rgba(0, 0, 0, 1)">:Parent1() [base object constructor]

</span><span style="color: rgba(0, 128, 128, 1)">Parent1:</span><span style="color: rgba(0, 0, 0, 1)">:Parent1() [base object constructor]:
       movq    (%rsi), %rax       </span><span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 将VTT中第2个条目的内容（即虚表指针construction vtable for Parent1-in-Child+24，简称虚指针1）存入%rax</span>
       movq    <span style="color: rgba(128, 0, 128, 1)">8</span>(%rsi), %rdx      <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 将VTT中第3个条目的内容（即虚表指针construction vtable for Parent1-in-Child+88，简称虚指针2）存入%rax</span>
       movq    %rax, (%rdi)       <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 将虚指针1设置到this指针指向的内存，作为Parent1的虚表指针</span>
       movq    -<span style="color: rgba(128, 0, 128, 1)">24</span>(%rax), %rax    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 虚指针1向上偏移24字节，取对应内容（即vbase_offset），存入%rax</span>
       movq    %rdx, (%rdi,%rax)  <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> %rdi表示Parent1对象的首地址，%rax表示vbase_offset，两者相加，即为虚基类子对象GrandParent的地址，此句将虚指针2设置为虚基类的虚表指针</span>
       movl    $<span style="color: rgba(128, 0, 128, 1)">200</span>, <span style="color: rgba(128, 0, 128, 1)">8</span>(%rdi)      <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 设置Parent1的数据成员 </span>
       <span style="color: rgba(0, 0, 255, 1)">ret</span></pre>
</div>
<p>构造完成后，内存布局如下所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202505/642223-20250531130328869-2112155574.png" alt="" style="width: 1000px; height: auto"></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;▲ 图4 &nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;作为基类子对象时，对象和Construction vtable的内存布局</p>
<p>为什么不能直接使用&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;的vtable呢？我们不妨先看一下&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;作为完整对象时，对象和vtable的内存布局。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202505/642223-20250531130344256-328393852.png" alt="" style="width: 1000px; height: auto"></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ▲ 图5 &nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;作为完整对象时，对象和vtable的内存布局</p>
<p>可见，同样是&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;对象，但作为基类子对象（图4）和作为完整对象（图5）相比，整体的内存布局是不一样的，即虚基类子对象&nbsp;<span class="cnblogs_code">GrandParent</span>&nbsp;与&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;对象的偏移量是不一样的。图4中，因为需要预留16字节给&nbsp;<span class="cnblogs_code">Parent2</span>&nbsp;对象，所以&nbsp;<span class="cnblogs_code">GrantParent</span>&nbsp;和&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;离得更远。反映到vtable上，就是与偏移相关的条目，如&nbsp;<span class="cnblogs_code">vbase_offset</span>&nbsp;和&nbsp;<span class="cnblogs_code">vcall_offset</span>&nbsp;，值会不一样，图4中是32和-32，图5中是16和-16。因此，如果图5中直接使用了&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;的vtable，在基类子对象&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;和虚基类子对象&nbsp;<span class="cnblogs_code">GrandParent</span>&nbsp;相互转换时（即&nbsp;<span class="cnblogs_code">this</span>&nbsp;指针的调整），就会因使用了错误的偏移量而出错。</p>
<p>综上，按C++标准规定，构造到&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;时，&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;就是“完整对象”，应当使用&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;的vtable。但这个“完整对象”的内存布局，和真正的完整对象的内存布局，还可能不一样，差别在虚基类子对象的偏移上。若直接使用&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;的vtable，偏移量相关的条目，就会与实际情况对不上。因此，就需要准备一张“临时”的vtable，在里面填上正确的偏移量，供构造时使用，这就是所谓的construction vtable。另外，这些构造过程中使用的vtable的地址，被统一保存到了另一个表里，即VTT。还需说明的是，VTT及construction vtable，不仅在对象构造过程中会被使用，在对象析构过程中，也会被使用，因为析构是构造的逆过程。关于VTT，<a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-ctor-general" target="_blank" rel="noopener nofollow">Itanium C++ ABI</a>的描述如下：</p>
<blockquote>
<p dir="auto">To ensure that the virtual table pointers are set to the appropriate virtual tables during proper base class construction, a table of virtual table pointers, called the VTT, which holds the addresses of construction and non-construction virtual tables is generated for the complete class.&nbsp;&nbsp;The constructor for the complete class passes to each proper base class constructor a pointer to the appropriate place in the VTT where the proper base class constructor can find its set of virtual tables. Construction virtual tables are used in a similar way during the execution of proper base class destructors.</p>
</blockquote>
<p>除了使用construction vtable外，对象的构造过程与上篇文章讲到的并无差别，本文不再赘述。</p>
<h2>vtable条目解析</h2>
<p>上文给出了虚继承条件下的vtable，包括construction vtable，但并未深入其中的各个条目，现在，让我们来一探究竟。</p>
<h3>construction vtable里的虚析构函数指针为什么是0？</h3>
<p>细心的读者可能观察到了，在construction vtable中，虚析构函数的地址是0，即虚析构函数被禁掉了。关于这一点，C++标准并没有明确的规定，而是GCC编译器独有的行为，比如，Clang编译器就没有这个行为。GCC这么做的原因，笔者猜测，可能是为了防止基类子对象被重复析构。比如，在构造&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;时，调用了&nbsp;<span class="cnblogs_code">~Parent1()</span>&nbsp;（当然，在构造函数里调用析构函数，本身就是十分奇怪的，正常不会这么用，但话说回来，C++并没有禁止这么用），这样，虚基类&nbsp;<span class="cnblogs_code">GrandParet</span>&nbsp;的虚函数也会被调用，虚基类也会被析构。等到构造&nbsp;<span class="cnblogs_code">Parent2</span>&nbsp;时，&nbsp;<span class="cnblogs_code">~Parent2()</span>&nbsp;也可能被调用，这样，&nbsp;<span class="cnblogs_code">GrandParent</span>&nbsp;会再次被析构，这样就会出现double free的问题。当然，这只是笔者的一个猜测，如果读者有其它的观点，欢迎不吝赐教。</p>
<h3>vbase_offset的作用</h3>
<p>考虑下面的代码：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> main()
{
    Child </span>*p_child = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Child;
    Parent1 </span>*p_parent1_sub =<span style="color: rgba(0, 0, 0, 1)"> p_child;
    GrandParent </span>*p_gp1 = p_parent1_sub; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Parent1作为Child的基类子对象，转为虚基类GrandParent</span>
    p_gp1-&gt;<span style="color: rgba(0, 0, 0, 1)">foo();

    Parent1 </span>*p_parent1 = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Parent1;
    GrandParent </span>*p_gp2 = p_parent1;     <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Parent1作为Child的基类子对象，转为虚基类GrandParent</span>
<span style="color: rgba(0, 0, 0, 1)">
    p_gp2</span>-&gt;<span style="color: rgba(0, 0, 0, 1)">foo();

    </span><span style="color: rgba(0, 0, 255, 1)">delete</span><span style="color: rgba(0, 0, 0, 1)"> p_child;
    </span><span style="color: rgba(0, 0, 255, 1)">delete</span><span style="color: rgba(0, 0, 0, 1)"> p_parent1;
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<p>当拿到一个&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;类型的指针时，程序并不知道这个指针指向的是一个完整的&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;对象，还是某个其它对象的基类子对象。而从图4和图5我们了解到，同样是&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;对象，但作为基类子对象和完整对象时，到虚基类对象的距离是不一样的。因此，在向虚基类子对象转换时，是不能使用一个固定的偏移量的，而是需要一个“随机应变”的偏移量，这正是保存在vtable中的&nbsp;<span class="cnblogs_code">vbase_offset</span>&nbsp;。<br>让我们通过汇编代码探究一下，当派生类指针/引用向基类指针/引用转换时，是如何利用&nbsp;<span class="cnblogs_code">vbase_offset</span>&nbsp;调整指针值的。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">main:</span><span style="color: rgba(0, 0, 0, 1)">
    pushq   %rbp
    movl    $</span><span style="color: rgba(128, 0, 128, 1)">48</span>, %edi  <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 需要分配的内存大小</span>
<span style="color: rgba(0, 0, 0, 1)">    pushq   %rbx
    subq    $</span><span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">, %rsp

    </span><span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 建议配合图6来理解下面的代码</span>
    <span style="color: rgba(0, 0, 255, 1)">call</span>    operator new(unsigned long) <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 分配48字节内存</span>
    movq    %rax, %rbp <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 分配的内存的首地址存入%rbp和%rdi</span>
<span style="color: rgba(0, 0, 0, 1)">    movq    %rax, %rdi
    </span><span style="color: rgba(0, 0, 255, 1)">call</span>    <span style="color: rgba(0, 128, 128, 1)">Child:</span>:Child() [complete object constructor]  <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 构造Child对象</span>
    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 因为Parent1子对象的首地址和Child对象的首地址是一样的，因此，</span>
    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> Parent1 *p_parent1_sub = p_child; 一句不需要调整指针，在-O2优化级别下，</span>
    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 没有生成汇编代码。下面的代码，是 Parent1* 向 GrandParent* 转换的汇编代码</span>
    movq    <span style="color: rgba(128, 0, 128, 1)">0</span>(%rbp), %rax   <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 在对象首地址处取出虚表指针，存入%rax</span>
    movq    -<span style="color: rgba(128, 0, 128, 1)">24</span>(%rax), %rdi <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 虚表指针向上偏移24字节，正好指向vbase_offset，将vbase_offset的值（这里是32）存入%rdi</span>
    addq    %rbp, %rdi      <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 这里相当于%rdi = %rbp + %rdi = Parent1子对象首地址 + vbase_offset(32)，因此得到的是虚基类子对象GrandParent的首地址</span>
    movq    (%rdi), %rax    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 从首地址取出GrandParent的虚表指针</span>
    <span style="color: rgba(0, 0, 255, 1)">call</span>    *<span style="color: rgba(128, 0, 128, 1)">16</span>(%rax)       <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 虚表指针加16，正是virtual trunk to Parent1::foo()条目的地址，</span>
                            <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 取出该地址处的值，正是virtual trunk to Parent1::foo()的地址，调用该函数</span>
    
    <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 建议配合图5来理解下面的代码</span>
    movl    $<span style="color: rgba(128, 0, 128, 1)">32</span><span style="color: rgba(0, 0, 0, 1)">, %edi
    </span><span style="color: rgba(0, 0, 255, 1)">call</span>    operator new(unsigned long) <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 为构造Parent1对象，先分配32字节</span>
    movq    %rax, %rbx  <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 分配的内存的首地址存入%rbp和%rdi</span>
<span style="color: rgba(0, 0, 0, 1)">    movq    %rax, %rdi
    </span><span style="color: rgba(0, 0, 255, 1)">call</span>    <span style="color: rgba(0, 128, 128, 1)">Parent1:</span>:Parent1() [complete object constructor] <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 构造对象</span>
    movq    (%rbx), %rax     <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 在对象首地址处取出虚表指针，存入%rax</span>
    movq    -<span style="color: rgba(128, 0, 128, 1)">24</span>(%rax), %rdi  <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 虚表指针向上偏移24字节，正好指向vbase_offset，将vbase_offset的值（这里是16）存入%rdi</span>
    addq    %rbx, %rdi       <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 这几句和上面相同，不再赘述</span>
<span style="color: rgba(0, 0, 0, 1)">    movq    (%rdi), %rax
    </span><span style="color: rgba(0, 0, 255, 1)">call</span>    *<span style="color: rgba(128, 0, 128, 1)">16</span>(%rax)</pre>
</div>
<p>下面给出&nbsp;<span class="cnblogs_code">Child</span>&nbsp;对象及其vtable的内存布局，方便读者对照着理解上面的汇编代码。</p>
<p><img src="https://img2024.cnblogs.com/blog/642223/202505/642223-20250531212427062-1061714590.png" alt="" style="width: 1000px; height: auto"></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;▲ 图6 &nbsp;<span class="cnblogs_code">Child</span>&nbsp;对象及其vtable的内存布局</p>
<h3>两种constructor</h3>
<p>在上文中，一共出现了两种构造函数，&nbsp;<span class="cnblogs_code">complete object constructor</span>&nbsp;和&nbsp;<span class="cnblogs_code">base object constructor</span>&nbsp;。顾名思义，&nbsp;<span class="cnblogs_code">complete object constructor</span>&nbsp;用来构造完整对象，它不仅会构造自己，还会构造其基类；而&nbsp;<span class="cnblogs_code">base object constructor</span>&nbsp;是在&nbsp;<span class="cnblogs_code">complete object constructor</span>&nbsp;中被调用的，用来构造基类子对象（base object）。</p>
<p>当&nbsp;<span class="cnblogs_code">complete object constructor</span>&nbsp;调用&nbsp;<span class="cnblogs_code">base object constructor</span>&nbsp;时，会传递两个参数，第一个是指向基类子对象的this指针，第二个是基类子对象vptr的地址（注意是vptr的地址而不是vptr），这个地址就是VTT中的某个条目。在&nbsp;<span class="cnblogs_code">base object constructor</span>&nbsp;中，会使用第二个参数为基类子对象设置虚表指针，还会使用第二个参数寻址虚基类的vptr，为虚基类子对象设置虚表指针。</p>
<p>以上过程，在上文的<a href="#code_1" rel="noopener nofollow">代码</a>中得到了完整的体现，读者可以配合代码来加深理解。</p>
<h3>vcall_offset详解</h3>
<p>考虑下面的代码：</p>
<div class="cnblogs_code">
<pre>Child *p_child = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Child;
Parent1 </span>*p_parent1_sub =<span style="color: rgba(0, 0, 0, 1)"> p_child;
GrandParent </span>*p_gp1 =<span style="color: rgba(0, 0, 0, 1)"> p_parent1_sub;
p_gp1</span>-&gt;foo();</pre>
</div>
<p>由于&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;重写了&nbsp;<span class="cnblogs_code">GrandParent</span>&nbsp;的虚函数，根据C++多态特性，这里应该调用&nbsp;<span class="cnblogs_code">Parent1::foo()</span>&nbsp;，但此时&nbsp;<span class="cnblogs_code">this</span>&nbsp;指向的是虚基类子对象&nbsp;<span class="cnblogs_code">GrandParent</span>&nbsp;，并不是&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;，因此需要先调整&nbsp;<span class="cnblogs_code">this</span>&nbsp;指针再调用正确的函数，那么，谁来做这件事情？怎么做？答案是&nbsp;<span class="cnblogs_code">virtual trunk to Parent1::foo()</span>&nbsp;函数利用&nbsp;<span class="cnblogs_code">vcall_base</span>&nbsp;来做。让我们通过汇编代码一探究竟。</p>
<div class="cnblogs_code">
<pre>virtual thunk to <span style="color: rgba(0, 128, 128, 1)">Parent1:</span><span style="color: rgba(0, 0, 0, 1)">:foo():
    movq    (%rdi), %r10      </span><span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> %rdi指向虚基类子对象，这里是取出虚基类的虚表指针，存入%r10</span>
    addq    -<span style="color: rgba(128, 0, 128, 1)">32</span>(%r10), %rdi   <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> 如图6，虚表指针减32，正好是foo()函数对应的vcall_offset</span>
    <span style="color: rgba(0, 0, 255, 1)">jmp</span>     .LTHUNK2          <span style="color: rgba(0, 128, 0, 1)">;</span><span style="color: rgba(0, 128, 0, 1)"> .LTHUNK2是Parent1::foo()的别名</span></pre>
</div>
<p>现在我们知道了，由派生类访问基类，靠的是&nbsp;<span class="cnblogs_code">vbase_offset</span>&nbsp;，由基类访问派生类，靠的是&nbsp;<span class="cnblogs_code">vcall_offset</span>&nbsp;。</p>
<p>具体地，以图6为例：</p>
<p>1. &nbsp;<span class="cnblogs_code">vcall_offset</span>&nbsp;存在于虚基类的vtable中。<br>2. 与虚基类中的虚函数一一对应，每个虚函数对应一个&nbsp;<span class="cnblogs_code">vcall_offset</span>&nbsp;，只有一个例外——两个虚析构函数对应一个&nbsp;<span class="cnblogs_code">vcall_offset</span>&nbsp;。<br>3. &nbsp;<span class="cnblogs_code">vbase_offset</span>&nbsp;在vtable中的排列顺序，与虚函数的排列顺序正好相反。以图6为例，从低地址到高地址，虚函数排布依次是两个&nbsp;<span class="cnblogs_code">virtual trunk to Child::~Child()</span>&nbsp;、&nbsp;<span class="cnblogs_code">virtual trunk to Parent1::foo()</span>&nbsp;、&nbsp;<span class="cnblogs_code">virtual trunk to Parent2::zoo()</span>&nbsp;，与此相对，&nbsp;<span class="cnblogs_code">vcall_offset</span>&nbsp;的排布依次对应&nbsp;<span class="cnblogs_code">virtual trunk to Parent2::zoo()</span>&nbsp;、&nbsp;<span class="cnblogs_code">virtual trunk to Parent1::foo()</span>&nbsp;、两个&nbsp;<span class="cnblogs_code">virtual trunk to Child::~Child()</span>&nbsp;。</p>
<p>为什么需要多个&nbsp;<span class="cnblogs_code">vcall_offset</span>&nbsp;？因为重写各个虚函数的派生类可能是不一样的，&nbsp;<span class="cnblogs_code">this</span>&nbsp;指针需要调整到不同的派生类，偏移量也是不一样的。例如，对于虚析构函数，根据多态性，应该调用完整类型&nbsp;<span class="cnblogs_code">Child</span>&nbsp;的析构函数，因此&nbsp;<span class="cnblogs_code">this</span>&nbsp;指针应该偏移-32以便指向完整类型；对于&nbsp;<span class="cnblogs_code">foo()</span>&nbsp;，因为被&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;重写了，所以&nbsp;<span class="cnblogs_code">this</span>&nbsp;指针需要指针&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;子对象，偏移量也是-32；对于&nbsp;<span class="cnblogs_code">zoo()</span>&nbsp;，因为被&nbsp;<span class="cnblogs_code">Parent2</span>&nbsp;重写了，所以&nbsp;<span class="cnblogs_code">this</span>&nbsp;指针需要指向&nbsp;<span class="cnblogs_code">Parent2</span>&nbsp;子对象，偏移量就变成了-16。</p>
<p>特别的，如图5所示，当&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;作为完整对象时，由于&nbsp;<span class="cnblogs_code">Parent1</span>&nbsp;并没有重写&nbsp;<span class="cnblogs_code">zoo()</span>&nbsp;，因此调用的仍然是&nbsp;<span class="cnblogs_code">GrandParent::zoo()</span>&nbsp;，不需要调整&nbsp;<span class="cnblogs_code">this</span>&nbsp;指针，因此&nbsp;<span class="cnblogs_code">vcall_offset</span>&nbsp;条目被置0。</p>
<p>有读者可能要问了，如果&nbsp;<span class="cnblogs_code">Parent2</span>&nbsp;也重写了&nbsp;<span class="cnblogs_code">foo()</span>&nbsp;，结果会怎么样呢？结果会编译报错。因为会产生歧义，编译器不允许这么做。读者可以自行试验。</p>
<h1>总结</h1>
<p>本文首先以简单虚拟继承为例，向读者展示了在虚继承条件下，即使没有虚函数，也会存在虚函数表，用来记录&nbsp;<span class="cnblogs_code">this</span>&nbsp;指针调整、动态类型转换等所需的信息。接下来，以菱形继承为例，详细介绍了VTT以及的construction vtable，深入探讨了该结构存在的原因以及在对象构造/析构中的作用。最后，详细讲解了虚析构函数、构造函数、&nbsp;<span class="cnblogs_code">vbase_offset</span>&nbsp;和&nbsp;<span class="cnblogs_code">vcall_offset</span>&nbsp;等与虚继承相关的虚表条目。</p>
<p>由于在下才疏学浅，能力有限，错误疏漏之处在所难免，恳请广大读者批评指正，您的批评是在下前进的不竭动力。</p>
<h1>


备注</h1>
<p>[1] 之所以说是“恰好”，是因此编译器将内存程序运行的结构紧凑排布，恰好将VTT排在了&nbsp;<span class="cnblogs_code">Derived</span>&nbsp;的vtable的后面。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.25325381554050924" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-02 18:15">2025-06-02 18:15</span>&nbsp;
<a href="https://www.cnblogs.com/zpcdbky">同勉共进</a>&nbsp;
阅读(<span id="post_view_count">22</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18837914);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18837914', targetLink: 'https://www.cnblogs.com/zpcdbky/p/18837914', title: '虚函数表里有什么？（四）——虚拟继承' })">举报</a>
</div>
        