
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/liyongqiang-cc/p/18664420" title="发布于 2025-02-28 17:16">
    <span role="heading" aria-level="2">Refit 原理解析：从初识到实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在现代的分布式系统和微服务架构中，HTTP API 调用是不可或缺的一部分。为了简化 HTTP 请求的构建和解析，我们可以使用 <strong>Refit</strong> 这个强大的库。Refit 通过将 HTTP API 抽象为接口，使得调用远程服务变得非常简单和直观。</p>
<h3 id="1-初识-refit">1. 初识 Refit</h3>
<p>Refit 是一个用于 .NET 的类型安全的 REST 客户端库。它允许你通过定义一个接口来描述 HTTP API，并自动生成实现代码。Refit 的核心思想是将 HTTP API 调用抽象为接口方法，开发者只需要定义接口，Refit 会自动处理 HTTP 请求的构建、发送和响应的解析。</p>
<p><strong>定义一个简单的 API 接口</strong></p>
<pre><code>public&nbsp;interface&nbsp;IUserRefitApi
{
&nbsp;&nbsp;&nbsp;&nbsp;[Get("/users/{id}")]
&nbsp;&nbsp;&nbsp;&nbsp;Task&lt;User&gt;&nbsp;GetUserAsync(int&nbsp;id);
}
</code></pre>
<p>在这个例子中，<code>IUserRefitApi</code> 接口描述了一个获取用户信息的 API。Refit 会根据接口定义自动生成 HTTP 请求代码。</p>
<h3 id="2-refit-的作用">2. Refit 的作用</h3>
<p>Refit 的主要作用是<strong>简化 HTTP API 的调用</strong>。具体来说，Refit 可以帮助开发者：</p>
<ol>
<li>1. <strong>减少样板代码</strong>：不需要手动创建 <code>HttpClient</code>、构建请求、解析响应。</li>
<li>2. <strong>提高代码可读性</strong>：通过接口定义 API，代码更加清晰和易于理解。</li>
<li>3. <strong>增强类型安全</strong>：编译器会检查接口定义和返回值类型，减少运行时错误。</li>
<li>4. <strong>支持异步操作</strong>：所有方法都支持 <code>async/await</code>，适合现代异步编程模式。</li>
<li>5. <strong>灵活的配置</strong>：支持自定义序列化、添加请求头、处理错误等。</li>
</ol>
<h3 id="3-refit-的原理">3. Refit 的原理</h3>
<p>Refit 的工作原理可以分为以下几个步骤：</p>
<h4 id="31-接口解析">3.1 接口解析</h4>
<p>Refit 通过反射解析接口定义，提取出 HTTP 方法（如 <code>[Get]</code>、<code>[Post]</code>）、路径、参数等信息。</p>
<ul>
<li>• <strong>HTTP 方法</strong>：通过注解（如 <code>[Get]</code>、<code>[Post]</code>）指定。</li>
<li>• <strong>路径</strong>：注解中的路径可以包含占位符（如 <code>{username}</code>），这些占位符会被方法的参数替换。</li>
<li>• <strong>参数</strong>：方法的参数可以绑定到路径、查询字符串、请求体等。</li>
</ul>
<h4 id="32-请求构建">3.2 请求构建</h4>
<p>Refit 根据接口定义构建 HTTP 请求。它会将方法的参数绑定到请求的路径、查询字符串、请求体等。</p>
<ul>
<li>• <strong>路径参数</strong>：通过占位符替换。</li>
<li>• <strong>查询参数</strong>：通过 <code>[Query]</code> 注解指定。</li>
<li>• <strong>请求体</strong>：通过 <code>[Body]</code> 注解指定。</li>
</ul>
<h4 id="33-请求发送">3.3 请求发送</h4>
<p>Refit 使用 <code>HttpClient</code> 发送 HTTP 请求。它会将构建好的请求发送到指定的 API 端点。</p>
<h4 id="34-响应解析">3.4 响应解析</h4>
<p>Refit 接收 HTTP 响应，并将其反序列化为方法的返回类型。默认情况下，Refit 使用 <code>System.Text.Json</code> 进行反序列化。</p>
<h4 id="35-异常处理">3.5 异常处理</h4>
<p>如果 HTTP 请求失败（如返回 4xx 或 5xx 状态码），Refit 会抛出 <code>ApiException</code>，开发者可以捕获并处理这些异常。</p>
<h3 id="4-refit-的使用场景">4. Refit 的使用场景</h3>
<p>Refit 适用于以下场景：</p>
<ol>
<li>1. <strong>调用 RESTful API</strong>：
<ul>
<li>• 当你需要与外部服务（如第三方 API）进行通信时，Refit 可以简化 HTTP 请求的构建和解析。</li>
</ul>
</li>
<li>2. <strong>微服务架构</strong>：
<ul>
<li>• 在微服务架构中，服务之间通常通过 HTTP 进行通信。Refit 可以帮助你快速创建类型安全的客户端，减少手动编写 HTTP 请求代码的工作量。</li>
</ul>
</li>
<li>3. <strong>移动应用和后端通信</strong>：
<ul>
<li>• 在移动应用中，Refit 可以用于与后端服务进行通信，简化网络请求的逻辑。</li>
</ul>
</li>
<li>4. <strong>快速开发</strong>：
<ul>
<li>• 当你需要快速测试或集成一个 API 时，Refit 可以让你在几分钟内完成 API 调用代码的编写。</li>
</ul>
</li>
<li>5. <strong>需要强类型支持的场景</strong>：
<ul>
<li>• Refit 提供了强类型的 API 调用方式，避免了手动解析 JSON 或处理字符串的麻烦。</li>
</ul>
</li>
</ol>
<h3 id="5项目实践">5.项目实践</h3>
<h4 id="51-安装-refit">5.1 安装 Refit</h4>
<p>安装 Refit 的 NuGet 包：</p>
<pre><code>dotnet&nbsp;add&nbsp;package&nbsp;Refit.HttpClientFactory
</code></pre>
<p>我们这里安装的是<code>Refit.HttpClientFactory</code>包，<code>Refit</code> 和 <code>Refit.HttpClientFactory</code> 是 Refit 库的两个不同部分，它们的作用和使用场景有所不同。</p>
<p><code>Refit</code> 和 <code>Refit.HttpClientFactory</code>大致区别如下：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Refit 核心库</strong></th>
<th><strong>Refit.HttpClientFactory</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>依赖</strong></td>
<td>直接依赖 <code>HttpClient</code></td>
<td>依赖 <code>HttpClientFactory</code></td>
</tr>
<tr>
<td><strong>生命周期管理</strong></td>
<td>需要手动管理 <code>HttpClient</code></td>
<td></td>
</tr>
<tr>
<td>生命周期</td>
<td>由 <code>HttpClientFactory</code>自动管理</td>
<td></td>
</tr>
<tr>
<td><strong>依赖注入支持</strong></td>
<td>不支持直接依赖注入</td>
<td>支持依赖注入</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单的控制台应用或手动管理</td>
<td></td>
</tr>
<tr>
<td><code>HttpClient</code></td>
<td>ASP.NET Core 或其他依赖注入的应用</td>
<td></td>
</tr>
<tr>
<td><strong>配置灵活性</strong></td>
<td>需要手动配置 <code>HttpClient</code></td>
<td>可以通过 <code>HttpClientFactory</code>配置</td>
</tr>
</tbody>
</table>
<p>在 ASP.NET Core 中使用 Refit，推荐使用 <code>Refit.HttpClientFactory</code>，因为它与 <code>HttpClientFactory</code> 集成得更好，能够更灵活地配置和管理 <code>HttpClient</code>。</p>
<h4 id="52-定义-api-接口">5.2 定义 API 接口</h4>
<p>在项目中定义一个接口来描述你要调用的外部 API。我们将使用 <code>/users</code> 相关的端点。</p>
<pre><code>using&nbsp;System.Collections.Generic;
using&nbsp;System.Threading.Tasks;
using&nbsp;Refit;

public&nbsp;interface&nbsp;IUserRefitApi
{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取所有用户
&nbsp;&nbsp;&nbsp;&nbsp;[Get("/users")]
&nbsp;&nbsp;&nbsp;&nbsp;Task&lt;List&lt;User&gt;&gt;&nbsp;GetUsersAsync();

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取单个用户
&nbsp;&nbsp;&nbsp;&nbsp;[Get("/users/{id}")]
&nbsp;&nbsp;&nbsp;&nbsp;Task&lt;User&gt;&nbsp;GetUserAsync(int&nbsp;id);

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;创建新用户
&nbsp;&nbsp;&nbsp;&nbsp;[Post("/users")]
&nbsp;&nbsp;&nbsp;&nbsp;Task&lt;User&gt;&nbsp;CreateUserAsync([Body]&nbsp;User&nbsp;user);

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;更新用户
&nbsp;&nbsp;&nbsp;&nbsp;[Put("/users/{id}")]
&nbsp;&nbsp;&nbsp;&nbsp;Task&lt;User&gt;&nbsp;UpdateUserAsync(int&nbsp;id,&nbsp;[Body]&nbsp;User&nbsp;user);

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;删除用户
&nbsp;&nbsp;&nbsp;&nbsp;[Delete("/users/{id}")]
&nbsp;&nbsp;&nbsp;&nbsp;Task&nbsp;DeleteUserAsync(int&nbsp;id);
}
</code></pre>
<h4 id="53-注册-refit-客户端">5.3 注册 Refit 客户端</h4>
<p>在 <code>Program.cs</code> 中注册 Refit 客户端。你可以使用 <code>HttpClientFactory</code> 来管理 <code>HttpClient</code> 的生命周期。</p>
<pre><code>using&nbsp;Microsoft.Extensions.DependencyInjection;
using&nbsp;Refit;

var&nbsp;builder&nbsp;=&nbsp;WebApplication.CreateBuilder(args);

//&nbsp;添加&nbsp;Refit&nbsp;客户端
builder.Services.AddRefitClient&lt;IUserRefitApi&gt;()
&nbsp;&nbsp;&nbsp;&nbsp;.ConfigureHttpClient(c&nbsp;=&gt;&nbsp;c.BaseAddress&nbsp;=&nbsp;new&nbsp;Uri("https://******"));

var&nbsp;app&nbsp;=&nbsp;builder.Build();

//&nbsp;配置中间件和路由
app.MapControllers();

app.Run();
</code></pre>
<h4 id="54-在控制器中使用-refit-客户端">5.4 在控制器中使用 Refit 客户端</h4>
<p>在 Web API 的控制器中注入 Refit 客户端，并调用外部 API。</p>
<pre><code>using&nbsp;Microsoft.AspNetCore.Mvc;
using&nbsp;System.Threading.Tasks;

[ApiController]
[Route("api/[controller]")]
public&nbsp;class&nbsp;UsersController&nbsp;:&nbsp;ControllerBase
{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;readonly&nbsp;IUserRefitApi&nbsp;_userRefitApi;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;UsersController(IUserRefitApi&nbsp;userRefitApi)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_userRefitApi&nbsp;=&nbsp;userRefitApi;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取所有用户
&nbsp;&nbsp;&nbsp;&nbsp;[HttpGet]
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;async&nbsp;Task&lt;IActionResult&gt;&nbsp;GetUsers()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;users&nbsp;=&nbsp;await&nbsp;_userRefitApi.GetUsersAsync();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Ok(users);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;获取单个用户
&nbsp;&nbsp;&nbsp;&nbsp;[HttpGet("{id}")]
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;async&nbsp;Task&lt;IActionResult&gt;&nbsp;GetUser(int&nbsp;id)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;user&nbsp;=&nbsp;await&nbsp;_userRefitApi.GetUserAsync(id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Ok(user);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;创建新用户
&nbsp;&nbsp;&nbsp;&nbsp;[HttpPost]
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;async&nbsp;Task&lt;IActionResult&gt;&nbsp;CreateUser([FromBody]&nbsp;User&nbsp;user)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;createdUser&nbsp;=&nbsp;await&nbsp;_userRefitApi.CreateUserAsync(user);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Ok(createdUser);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;更新用户
&nbsp;&nbsp;&nbsp;&nbsp;[HttpPut("{id}")]
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;async&nbsp;Task&lt;IActionResult&gt;&nbsp;UpdateUser(int&nbsp;id,&nbsp;[FromBody]&nbsp;User&nbsp;user)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;updatedUser&nbsp;=&nbsp;await&nbsp;_userRefitApi.UpdateUserAsync(id,&nbsp;user);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Ok(updatedUser);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;删除用户
&nbsp;&nbsp;&nbsp;&nbsp;[HttpDelete("{id}")]
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;async&nbsp;Task&lt;IActionResult&gt;&nbsp;DeleteUser(int&nbsp;id)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;_userRefitApi.DeleteUserAsync(id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NoContent();
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<h3 id="6-扩展功能">6. 扩展功能</h3>
<h4 id="61-添加请求头">6.1 添加请求头</h4>
<p>可以通过 <code>[Headers]</code> 注解为接口或方法添加请求头：</p>
<pre><code>[Headers("Authorization:&nbsp;Bearer&nbsp;TOKEN")]
public&nbsp;interface&nbsp;IUserRefitApi
{
&nbsp;&nbsp;&nbsp;[Get("/users")]
&nbsp;&nbsp;&nbsp;Task&lt;List&lt;User&gt;&gt;&nbsp;GetUsersAsync();
}
</code></pre>
<h4 id="62-自定义序列化">6.2 自定义序列化</h4>
<p>可以通过 <code>RefitSettings</code> 自定义序列化行为：</p>
<pre><code>builder.Services.AddRefitClient&lt;IUserRefitApi&gt;(new&nbsp;RefitSettings
{
&nbsp;&nbsp;&nbsp;&nbsp;ContentSerializer&nbsp;=&nbsp;new&nbsp;NewtonsoftJsonContentSerializer()
&nbsp;&nbsp;&nbsp;&nbsp;})
&nbsp;&nbsp;&nbsp;&nbsp;.ConfigureHttpClient(c&nbsp;=&gt;&nbsp;c.BaseAddress&nbsp;=&nbsp;new&nbsp;Uri("https://******"));
</code></pre>
<h4 id="63-文件上传">6.3 文件上传</h4>
<p>Refit 支持文件上传。可以使用 <code>[Multipart]</code> 注解：</p>
<pre><code>public&nbsp;interface&nbsp;IFileApi
{
&nbsp;&nbsp;&nbsp;&nbsp;[Multipart]
&nbsp;&nbsp;&nbsp;&nbsp;[Post("/upload")]
&nbsp;&nbsp;&nbsp;&nbsp;Task&nbsp;UploadFileAsync([AliasAs("file")]&nbsp;StreamPart&nbsp;file);
}
</code></pre>
<h3 id="7-总结">7. 总结</h3>
<p>在 .NET Core Web API 中使用 Refit 可以极大地简化对外部 HTTP API 的调用。通过定义接口和注解，Refit 可以自动生成 HTTP 请求代码，并通过 <code>HttpClientFactory</code> 管理 <code>HttpClient</code> 的生命周期。无论是调用第三方 API 还是实现微服务通信，Refit 都是一个非常实用的工具。<br>
<img src="https://img2024.cnblogs.com/blog/2063798/202502/2063798-20250228171750806-156834464.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04063222165277778" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-28 17:18">2025-02-28 17:16</span>&nbsp;
<a href="https://www.cnblogs.com/liyongqiang-cc">代码拾光</a>&nbsp;
阅读(<span id="post_view_count">16</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18664420" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18664420);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18664420', targetLink: 'https://www.cnblogs.com/liyongqiang-cc/p/18664420', title: 'Refit 原理解析：从初识到实践' })">举报</a>
</div>
        