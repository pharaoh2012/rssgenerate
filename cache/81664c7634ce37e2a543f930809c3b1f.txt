
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/1747176348mi/p/18623758" title="发布于 2024-12-23 20:39">
    <span role="heading" aria-level="2">第36次ccf-csp题解（思维）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<ul>
<li>
<blockquote>
<p>比赛链接 <a href="https://sim.csp.thusaac.com/contest/36/home" target="_blank" rel="noopener nofollow">https://sim.csp.thusaac.com/contest/36/home</a></p>
</blockquote>
</li>
</ul>
<p> </p>
<ul>
<li>
<blockquote>
<p>比赛感受</p>
</blockquote>
</li>
</ul>
<p>这会刚打完上海icpc，比起区域赛的题，这个简单太多了。<br>
感受还不错，写的很顺手。除了第3题，其他3题都是一发过。<br>
刷题得长期刷。<br>
 </p>
<p> <br>
<img src="https://img2024.cnblogs.com/blog/3466055/202412/3466055-20241223132749783-538930337.png" alt="" loading="lazy"><br>
 <br>
 <br>
&nbsp;<br>
&nbsp;</p>
<ul>
<li>
<blockquote>
<p>A题 移动</p>
</blockquote>
</li>
</ul>
<p> </p>
<p>题意：f : y+1 ;   b : y-1 ;   l : x-1 ;   r : x+1<br>
 <br>
&nbsp;<br>
一个简单的模拟，若当前操作使机器人移出场地，那么使机器人移回来就好<br>
 </p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
void ooo(int x){
    cout&lt;&lt;x&lt;&lt;'\n';
}
signed main()
{
    int n, k;cin&gt;&gt;n&gt;&gt;k;
    for(int i=1;i&lt;=k;i++){
        int x, y;cin&gt;&gt;x&gt;&gt;y;
        string s;cin&gt;&gt;s;
        int len=s.size();
        for(int j=0;j&lt;len;j++){
            if(s[j]=='f')y+=1;
            else if(s[j]=='b')y-=1;
            else if(s[j]=='l')x-=1;
            else x+=1;

            if(y&gt;n)y--;
            if(y&lt;1)y++;
            if(x&gt;n)x--;
            if(x&lt;1)x++;
        }
        cout&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;'\n';
    }
    return 0;
}

</code></pre>
<p> </p>
<ul>
<li>
<blockquote>
<p>B题 梦境巡查</p>
</blockquote>
</li>
</ul>
<p> </p>
<p>这个题不算太难，有点思维，对码力要求不高。</p>
<p>  </p>
<p>它假设当bi为0时求初始时要带的最小补给。</p>
<p>关键在于怎样维护bi=0时，全程中所拥有补给的最小量（为负数表示还需要多少补给）
所以就是一个单点修改，以bi为分界处，维护前半段和后半段最小值，对两段最小值取最小值，为负数则取绝对值，为非负数则为0。</p>
 
 
<p><img src="https://img2024.cnblogs.com/blog/3466055/202412/3466055-20241223142520436-1013043504.jpg" alt="" loading="lazy"></p>
<p> </p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int xmmm=2e5+10;
int a[xmmm], b[xmmm];
int c[xmmm];
int sum[xmmm];
int pmi[xmmm], lmi[xmmm];
int ans[xmmm];
void ooo(int x){
    cout&lt;&lt;x&lt;&lt;'\n';
}
signed main()
{
    int n;cin&gt;&gt;n;
    for(int i=0;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        c[i*2+1]=0-a[i];
    }
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;b[i];
        c[i*2]=b[i];
    }
    pmi[0]=lmi[2*n+2]=0-1e10;
    for(int i=1;i&lt;=2*n+1;i++){
        sum[i]=sum[i-1]+c[i];
    }
    for(int i=1;i&lt;=2*n+1;i++){
        if(i==1)pmi[i]=sum[i];
        else pmi[i]=min(pmi[i-1], sum[i]);
    }
    for(int i=2*n+1;i&gt;=1;i--){
        if(i==2*n+1)lmi[i]=sum[i];
        else lmi[i]=min(lmi[i+1], sum[i]);
    }
    for(int i=1;i&lt;=n;i++){
        int pos=i*2;
        int t1=pmi[pos-1];
        int t2=lmi[pos]-b[i];
        ans[i]=min(t1, t2);
    }
    for(int i=1;i&lt;=n;i++){
        if(ans[i]&lt;0)cout&lt;&lt;0-ans[i]&lt;&lt;' ';
        else cout&lt;&lt;0&lt;&lt;' ';
    }
    return 0;
}
/*

3
5 5 5 5
0 100 0

3
 9 4 6 2
9 4 6
*/

</code></pre>
<p> </p>
<ul>
<li>
<blockquote>
<p>D题 跳房子</p>
</blockquote>
</li>
</ul>
<p>这个题感觉还没有C题难。<br>
这其实是一个很简单的图遍历的问题<br>
建完边还是只有一个前驱的这种，简单版的迪杰斯特拉。<br>
处理出b数组，每个点只入队列一次。<br>
 </p>
<p><img src="https://img2024.cnblogs.com/blog/3466055/202412/3466055-20241223145649343-19681653.png" alt="" loading="lazy"></p>
<p> </p>
<p><img src="https://img2024.cnblogs.com/blog/3466055/202412/3466055-20241223145729093-1099311156.jpg" alt="" loading="lazy"></p>
<p> </p>
<pre><code>#include &lt;bits/stdc++.h&gt;
//#define int long long
using namespace std;
void ooo(int x){
    cout&lt;&lt;x&lt;&lt;'\n';
}
struct p{
    int id, num;
};
const int xmmm=2e5+10;
int a[xmmm], b[xmmm], k[xmmm];
int dis[xmmm];
bool vis[xmmm];
signed main()
{
    int n;cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        b[i]=i-a[i];
    }
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;k[i];
    int pos=0;
    queue&lt;p&gt;q;
    //q.clear();
    q.push(p{1, 0});
    int ans=-1;
    while(!q.empty()){
        p t=q.front();q.pop();
        if(vis[t.id])continue;
        vis[t.id]=1;
        if(t.id==n){
            ans=t.num;break;
        }
        int x=t.id;
        if(x+k[x]&lt;=pos)continue;
        if(x+k[x]&gt;=n){
            q.push(p{n, t.num+1});
            continue;
        }
        for(int i=max(pos+1, x+1);i&lt;=min(n, x+k[x]);i++){
            q.push(p{b[i], t.num+1});
        }
        pos=max(pos, x+k[x]);
    }
    cout&lt;&lt;ans&lt;&lt;'\n';
    return 0;
}
/*

5
0 1 2 3 0
3 4 4 10 15

10
0 1 1 1 1 3 1 0 3 0
2 4 5 4 1 4 1 3 5 3
*/

</code></pre>
<p> </p>
<ul>
<li>
<blockquote>
<p>C题 缓存模拟</p>
</blockquote>
</li>
</ul>
<p> <br>
一个大模拟按他的要求来就好了，详细的可以看注释<br>
 </p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define int long long

using namespace std;
const int xxx=3e5;
const int xx=7e4;
int head[xxx],nnum[xxx];

// m组里有多少个
struct p{
    int x, y;
};
vector&lt;p&gt;ans;
void ooo(int x){
    cout&lt;&lt;x&lt;&lt;'\n';
};
struct node {
    int id, num;
    bool operator&lt;(const node &amp;a)const {return a.num&lt;num;}
};
priority_queue&lt;node&gt;qq[xx];
unordered_map&lt;int, int&gt;a, vis; // 位置//是否修改
signed main()
{

    int n, m, q;cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;
    for(int i=1;i&lt;=q;i++){
        int x, y;cin&gt;&gt;x&gt;&gt;y;
        if(a[y]){ / /判断是否命中
            int pos=(y / n ) %m;
            head[pos]++;
            qq[pos].push(node{y, head[pos]});
            a[y]=head[pos];
            if(x==0)x=x;
            else {
                vis[y]=1; //判断是否改写
            }
        }
        else {
            int pos=( y / n )%m; //位置
            if(nnum[pos]==n){ //如果已经满了
                while(!qq[pos].empty()){
                    node tt=qq[pos].top();qq[pos].pop();
                    if(a[tt.id]!=tt.num)continue;
                    if(vis[tt.id]){
                        //cout&lt;&lt;"pos"&lt;&lt;tt.id&lt;&lt;' '&lt;&lt;tt.num&lt;&lt;' '&lt;&lt;a[tt.id]&lt;&lt;'\n';
                        ans.push_back(p{(int)1, tt.id});
                        vis[tt.id]=0;
                    }
                    head[pos]++;
                    a[y]=head[pos];
                    if(x)vis[y]=1;
                    qq[pos].push(node{y, head[pos]});
                    ans.push_back(p{(int)0, y});
                    a[tt.id]=0;break;
                }
            }
            else {
                head[pos]++;
                a[y]=head[pos];
                nnum[pos]++;
                qq[pos].push(node{y, head[pos]});
                if(x)vis[y]=1;
                ans.push_back(p{(int)0, y});
            }
        }
    }
    int len=ans.size();
    for(int i=0;i&lt;len;i++){
        cout&lt;&lt;ans[i].x&lt;&lt;' '&lt;&lt;ans[i].y&lt;&lt;'\n';
    }
    return 0;
}
/*

4 8 8
0 0
0 1
1 2
0 1
1 0
0 32
1 33
0 34


1 1 3
1 0
1 1
0 2
*/

</code></pre>
<p> </p>
<p> </p>
<ul>
<li>
<blockquote>
<p>自我总结</p>
</blockquote>
</li>
</ul>
<p>这次写题的顺序是1243，再写一点点。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.060357058859953704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-23 20:50">2024-12-23 20:39</span>&nbsp;
<a href="https://www.cnblogs.com/1747176348mi">devoteeing</a>&nbsp;
阅读(<span id="post_view_count">16</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18623758" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18623758);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18623758', targetLink: 'https://www.cnblogs.com/1747176348mi/p/18623758', title: '第36次ccf-csp题解（思维）' })">举报</a>
</div>
        