
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangxincheng/p/18869380" title="发布于 2025-05-10 11:01">
    <span role="heading" aria-level="2">Linux系列：聊一聊 SystemV 下的进程间共享内存</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景">一：背景</h2>
<h3 id="1-讲故事">1. 讲故事</h3>
<p>昨天在分析一个 linux 的 dump 时，看到了这么一话警告，参考如下：</p>
<pre><code class="language-C#">
0:000&gt; !eeheap -gc
*** WARNING: Unable to verify timestamp for SYSV10cf21d1 (deleted)

</code></pre>
<p>对，就是上面的 <code>SYSV10cf21d1</code>，拆分一下为 <code>System V + 10cf21d1</code> ，前者的<code>System V</code>表示共享内存机制，后面的 <code>10cf21d1</code> 表示共享内存中用到的唯一键key，所以这表示当前的 .net 程序直接或者间接的使用了 <code>System V</code>的进程间共享内存，我对 Linux 不是特别熟悉，所以稍微研究了下就有了这篇文章。</p>
<h2 id="二system-v-研究">二：System V 研究</h2>
<h3 id="1-什么是进程间通信">1. 什么是进程间通信</h3>
<p>其实在 Linux 中有很多中方式进行 IPC（进程间通信），我用大模型帮我做了一下汇总，截图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250510110109373-536924602.png" alt="" loading="lazy"></p>
<p>现如今Linux使用最多的还是 <code>POSIX</code> 标准，而 <code>System V</code> 相对来说比较老，为了研究我们写一个小例子观察下基本实现。</p>
<h3 id="2-system-v-的一个小例子">2. System V 的一个小例子</h3>
<p>为了能够实现进程间通信，开启两个进程（writer，reader）端，一个是往共享内存写入，一个从共享内存中读取，画个简图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250510110109392-1981046030.png" alt="" loading="lazy"></p>
<p>接下来在内存段的首位置设置<code>控制flag</code>，后面跟着传输的 <code>content</code> 内容，然后创建一个key与申请的内存段进行绑定，参考代码如下：</p>
<p>1）writer.c</p>
<pre><code class="language-C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;unistd.h&gt;

#define SHM_SIZE 1024 // 共享内存段大小

int main()
{
    key_t key;
    int shmid;
    char *shm_ptr;

    // 生成key值 - 使用当前目录和项目ID
    if ((key = ftok(".", 'x')) == -1)
    {
        perror("ftok");
        exit(1);
    }

    // 创建共享内存段
    if ((shmid = shmget(key, SHM_SIZE, IPC_CREAT | 0666)) == -1)
    {
        perror("shmget");
        exit(1);
    }

    // 附加到共享内存
    if ((shm_ptr = shmat(shmid, NULL, 0)) == (void *)-1)
    {
        perror("shmat");
        exit(1);
    }

    printf("Writer: 连接到共享内存段 %d\n", shmid);

    // 第一个字节作为标志位，其余部分存储数据
    char *flag_ptr = shm_ptr;
    char *data_ptr = shm_ptr + 1;

    // 初始化标志位
    *flag_ptr = 0;

    // 写入数据到共享内存
    char message[] = "Hello from writer process!";
    strncpy(data_ptr, message, sizeof(message));

    // 设置标志位表示数据已准备好
    *flag_ptr = 1;

    printf("Writer: 已写入消息: \"%s\"\n", message);

    // 等待读取进程完成
    printf("Writer: 等待读取进程确认...\n");
    while (*flag_ptr != 2)
    {
        sleep(1);
    }

    // 分离共享内存
    if (shmdt(shm_ptr) == -1)
    {
        perror("shmdt");
        exit(1);
    }

    // 删除共享内存段
    if (shmctl(shmid, IPC_RMID, NULL) == -1)
    {
        perror("shmctl");
        exit(1);
    }

    printf("Writer: 完成\n");

    return 0;
}

</code></pre>
<p>接下来就是 gcc 编译并运行，参考如下：</p>
<pre><code class="language-shell">
root@ubuntu2404:/data2# gcc -g writer.c -o writer
root@ubuntu2404:/data2# ls   
writer  writer.c
root@ubuntu2404:/data2# ./writer
Writer: 连接到共享内存段 2
Writer: 已写入消息: "Hello from writer process!"
Writer: 等待读取进程确认...

</code></pre>
<p>从输出看已经将 <code>"Hello from writer process!"</code> 写到了共享内存，接下来可以用 <code>ipcs -m</code> 观察共享内存段列表，以及虚拟地址段。</p>
<pre><code class="language-C#">
root@ubuntu2404:/proc# ipcs -m  

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status      
0x78030002 3          root       666        1024       1         

root@ubuntu2404:/proc# ps -ef | grep writer 
root        7711    7593  0 10:41 pts/1    00:00:00 ./writer
root        7714    7618  0 10:41 pts/2    00:00:00 grep --color=auto writer              

root@ubuntu2404:/proc# cat /proc/7711/maps
5b412c9bc000-5b412c9bd000 r--p 00000000 08:03 1966088                    /data2/writer
5b412c9bd000-5b412c9be000 r-xp 00001000 08:03 1966088                    /data2/writer
5b412c9be000-5b412c9bf000 r--p 00002000 08:03 1966088                    /data2/writer
5b412c9bf000-5b412c9c0000 r--p 00002000 08:03 1966088                    /data2/writer
5b412c9c0000-5b412c9c1000 rw-p 00003000 08:03 1966088                    /data2/writer
5b415ad13000-5b415ad34000 rw-p 00000000 00:00 0                          [heap]
...
7c755ce80000-7c755ce81000 rw-s 00000000 00:01 3                          /SYSV78030002 (deleted)
...
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
root@ubuntu2404:/proc# 

</code></pre>
<p>上面输出的 <code>/SYSV78030002 (deleted)</code> 便是，哈哈，现在回头看这句 <code>WARNING: Unable to verify timestamp for SYSV10cf21d1 (deleted)</code> 是不是豁然开朗啦。。。</p>
<p>接下来继续聊，另一个进程要想读取共享内存，需要通过同名的key寻找，即下面的 shmget 方法。</p>
<p>2）reader.c</p>
<pre><code class="language-C">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;unistd.h&gt;

#define SHM_SIZE 1024 // 共享内存段大小

int main()
{
    key_t key;
    int shmid;
    char *shm_ptr;

    // 生成相同的key值
    if ((key = ftok(".", 'x')) == -1)
    {
        perror("ftok");
        exit(1);
    }

    // 获取共享内存段
    if ((shmid = shmget(key, SHM_SIZE, 0666)) == -1)
    {
        perror("shmget");
        exit(1);
    }

    // 附加到共享内存
    if ((shm_ptr = shmat(shmid, NULL, 0)) == (void *)-1)
    {
        perror("shmat");
        exit(1);
    }

    printf("Reader: 连接到共享内存段 %d\n", shmid);

    // 第一个字节是标志位，其余是数据
    char *flag_ptr = shm_ptr;
    char *data_ptr = shm_ptr + 1;

    // 等待数据准备好
    printf("Reader: 等待数据...\n");
    while (*flag_ptr != 1)
    {
        sleep(1);
    }

    // 读取数据
    printf("Reader: 接收到消息: \"%s\"\n", data_ptr);

    // 通知写入进程已完成读取
    *flag_ptr = 2;

    // 分离共享内存
    if (shmdt(shm_ptr) == -1)
    {
        perror("shmdt");
        exit(1);
    }

    printf("Reader: 完成\n");

    return 0;
}

</code></pre>
<p>如果有朋友对绑定逻辑(shmget)的底层感兴趣，可以观察 Linux 中的 ipcget_public 方法，其中的 rhashtable_lookup_fast 便是。</p>
<pre><code class="language-C">
static int ipcget_public(struct ipc_namespace *ns, struct ipc_ids *ids,
		const struct ipc_ops *ops, struct ipc_params *params)
{
	struct kern_ipc_perm *ipcp;
	int flg = params-&gt;flg;
	int err;

	/*
	 * Take the lock as a writer since we are potentially going to add
	 * a new entry + read locks are not "upgradable"
	 */
	down_write(&amp;ids-&gt;rwsem);
	ipcp = ipc_findkey(ids, params-&gt;key);
    ...
}

static struct kern_ipc_perm *ipc_findkey(struct ipc_ids *ids, key_t key)
{
	struct kern_ipc_perm *ipcp;

	ipcp = rhashtable_lookup_fast(&amp;ids-&gt;key_ht, &amp;key,
					      ipc_kht_params);
	if (!ipcp)
		return NULL;

	rcu_read_lock();
	ipc_lock_object(ipcp);
	return ipcp;
}

</code></pre>
<p>最后就是相同方式的编译运行，截一张图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250510110109360-1244472766.png" alt="" loading="lazy"></p>
<h2 id="三总结">三：总结</h2>
<p>哈哈，dump分析之旅就是这样，在分析中不断的学习新知识，再用新知识指导dump分析，就这样的不断的螺旋迭代，乐此不疲。<br>
<img src="https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_210929020104最新消息优惠促销公众号关注二维码.jpg" width="700" height="300" alt="图片名称" align="center"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.21977145787384259" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-10 11:02">2025-05-10 11:01</span>&nbsp;
<a href="https://www.cnblogs.com/huangxincheng">一线码农</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18869380);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18869380', targetLink: 'https://www.cnblogs.com/huangxincheng/p/18869380', title: 'Linux系列：聊一聊 SystemV 下的进程间共享内存' })">举报</a>
</div>
        