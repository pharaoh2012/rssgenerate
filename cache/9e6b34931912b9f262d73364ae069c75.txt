
            <div class="postcontent">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>　　<span style="color: rgba(128, 0, 0, 1)">提问词：【我想在一个dotnet core 8项目中使用 Blazor Hybric 技术，同时构建一个MAUI Project（A，打包到手机端），和一个Auto Render Model 的WebApp Project（W，发布到服务器），我想将两者都用到的Razor文件抽出来作为一个CommonPage中间Project（C，被A和W引用），W中既需要有webAssembly的渲染方式也需要SSR的渲染方式，因为A项目中用到的razor页面肯定是Client(WebAssembly)的渲染方式，我的问题是：C项目中每个Razor页面的RenderModel是否还需要区分为多种方式，还是说只需要设置成webAssembly的方式就可以了，ssr所需的页面组件单独在W里设置？】</span></p>
<p>　　deepseek思考过程：</p>
<p>　　<span style="background-color: rgba(204, 255, 255, 1)">嗯，用户的问题是关于在Blazor Hybrid项目中共享Razor组件，同时支持MAUI和WebApp项目，其中WebApp需要同时使用WebAssembly和SSR。他们想知道在公共项目C中，是否需要为每个Razor页面区分不同的渲染模式，还是只需要用WebAssembly模式，然后在Web项目W中单独处理SSR的部分。</span></p>
<ul>
<li class="ba94db8a"><span style="background-color: rgba(204, 255, 255, 1)">首先，我需要回忆Blazor的不同渲染模式。Blazor WebAssembly是客户端渲染，SSR则是服务端渲染，而Blazor Hybrid在MAUI中可能使用WebView来呈现组件。公共项目C中的Razor组件需要被MAUI和Web项目共享，所以可能需要考虑兼容性。</span></li>
<li class="ba94db8a"><span style="background-color: rgba(204, 255, 255, 1)">接下来，用户提到Web项目W需要同时支持WebAssembly和SSR，这意味着某些页面可能需要两种渲染模式。但公共组件C被A和W引用，而A（MAUI）使用的是WebAssembly渲染模式。这时候可能需要确认在公共项目中设置渲染模式是否会影响不同项目的使用。</span></li>
<li class="ba94db8a"><span style="background-color: rgba(204, 255, 255, 1)">根据Blazor的文档，从.NET 8开始，组件可以定义渲染模式，比如使用@rendermode指令。如果公共组件C中的页面设置为WebAssembly，那么在SSR环境下可能无法直接使用，除非进行适配。或者，可能需要在W项目中覆盖或调整这些渲染模式。</span></li>
<li class="ba94db8a"><span style="background-color: rgba(204, 255, 255, 1)">可能的解决方案是，公共项目C中的组件不指定渲染模式，或者设置为自动（Auto），这样在Web项目W中可以根据需要设置为WebAssembly或SSR。而MAUI项目A可能默认使用WebAssembly模式，因此不需要特别设置。</span></li>
<li class="ba94db8a"><span style="background-color: rgba(204, 255, 255, 1)">同时，需要考虑组件是否依赖于特定渲染模式的功能。例如，如果组件使用了只能在WebAssembly中运行的JS互操作，那么在SSR中可能会有问题。因此，公共组件需要保持中立，避免依赖特定模式的功能，或者在W项目中通过条件编译或其他方式处理差异。</span></li>
<li class="ba94db8a"><span style="background-color: rgba(204, 255, 255, 1)">另外，Web项目W可能需要将部分组件单独设置为SSR，这时候可以在W项目中创建新的组件，继承或引用公共组件，并添加相应的渲染模式。这样公共组件保持通用，而特定渲染模式的调整在各自项目中处理。</span></li>
<li class="ba94db8a"><span style="background-color: rgba(204, 255, 255, 1)">总结来说，公共项目C中的组件应尽量保持渲染模式中立，或者默认设置为适用于所有目标环境的模式（如WebAssembly），然后在需要不同渲染模式的项目中，通过覆盖或指定模式来调整。这样既保持组件的可重用性，又允许各项目根据需求进行定制。</span></li>
</ul>
<p class="ba94db8a">　　<strong>最终它给了我七个策略设计方案，惊艳到我，故在此记录下来：</strong></p>
<hr>
<h3>1. 公共组件库（Project C）的设计原则</h3>
<p>&nbsp;</p>
<ul>
<li><strong>不硬编码渲染模式</strong>：在共享的 Razor 组件中不要使用&nbsp;<code>@rendermode</code>&nbsp;指令或硬编码&nbsp;<code>RenderMode</code>，保持渲染模式的中立性</li>
</ul>
<p>&nbsp;</p>
<ul>
<li class="_mce_tagged_br"><strong>依赖注入兼容</strong>：避免在组件中直接依赖&nbsp;<code>HttpContext</code>&nbsp;等仅 SSR 可用的服务</li>
<li class="_mce_tagged_br"><strong>条件编译处理平台差异</strong>：用&nbsp;<code>#if MAUI</code>&nbsp;和&nbsp;<code>#if WEB</code>&nbsp;隔离平台特定逻辑</li>
</ul>
<div class="md-code-block">
<div class="cnblogs_code">
<pre>@* SharedComponent.razor *<span style="color: rgba(0, 0, 0, 1)">@
@{
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> isMobile = 
　　<span style="color: rgba(0, 0, 255, 1)">#if</span> MAUI
        <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
　　</span><span style="color: rgba(0, 0, 255, 1)">#else</span>
        <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
　　</span><span style="color: rgba(0, 0, 255, 1)">#endif</span><span style="color: rgba(0, 0, 0, 1)">
}
@if (isMobile)
{
    </span>&lt;MobileOnlyFeature /&gt;<span style="color: rgba(0, 0, 0, 1)">
}</span></pre>
</div>
</div>
<h3>2. MAUI 项目（Project A）配置</h3>
<ul>
<li>
<p><strong>强制指定渲染模式</strong>：在&nbsp;<code>_Imports.razor</code>&nbsp;中添加全局模式声明</p>
</li>
</ul>
<div class="md-code-block">
<div class="md-code-block-banner-wrap">
<div class="md-code-block-banner">
<div class="md-code-block-infostring">
<div class="cnblogs_code">
<pre>@rendermode RenderMode.InteractiveWebAssembly</pre>
</div>
</div>
</div>
</div>
</div>
<h3>3. Web 项目（Project W）的渲染模式策略</h3>
<ul>
<li>
<p><strong>创建渲染模式包装组件</strong>：在 Web 项目中创建适配层</p>
</li>
</ul>
<div class="md-code-block">
<div class="md-code-block-banner-wrap">
<div class="md-code-block-banner">
<div class="md-code-block-infostring">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Web/Components/SSRWrapper.razor</span>
<span style="color: rgba(0, 0, 0, 1)">@inherits SharedComponent
@rendermode RenderMode.InteractiveServer

</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Web/Components/WASMWrapper.razor </span>
<span style="color: rgba(0, 0, 0, 1)">@inherits SharedComponent
@rendermode RenderMode.InteractiveWebAssembly</span></pre>
</div>
</div>
</div>
</div>
</div>
<ul>
<li>
<p><strong>动态模式选择</strong>：在路由配置中根据条件切换</p>
</li>
</ul>
<div class="md-code-block">
<div class="cnblogs_code">
<pre>@page <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/dynamic-page</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
@if (isSSR)
{
    </span>&lt;SSRWrapper /&gt;<span style="color: rgba(0, 0, 0, 1)">
}
</span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
{
    </span>&lt;WASMWrapper /&gt;<span style="color: rgba(0, 0, 0, 1)">
}

@code {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">bool</span> isSSR = <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)"> 根据请求判断是否需要 SSR </span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
</div>
<h3>4. 构建配置优化</h3>
<p>在公共组件库的&nbsp;<code>.csproj</code>&nbsp;中配置多目标框架：</p>
<div class="md-code-block">
<div class="md-code-block-footer">
<div class="ds-icon">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">TargetFrameworks</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>net8.0-android;net8.0-ios;net8.0-maccatalyst;net8.0<span style="color: rgba(0, 0, 255, 1)">&lt;/</span><span style="color: rgba(128, 0, 0, 1)">TargetFrameworks</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>
<span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">SupportedPlatform </span><span style="color: rgba(255, 0, 0, 1)">Condition</span><span style="color: rgba(0, 0, 255, 1)">="'$(TargetFramework)' == 'net8.0'"</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span>browser<span style="color: rgba(0, 0, 255, 1)">&lt;/</span><span style="color: rgba(128, 0, 0, 1)">SupportedPlatform</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span></pre>
</div>
</div>
运行 HTML</div>
</div>
<h3>5. 服务注册策略</h3>
<p>在共享库中定义接口，各平台实现：</p>
<div class="md-code-block">
<div class="md-code-block-banner-wrap">
<div class="md-code-block-banner">
<div class="md-code-block-infostring">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">// Shared
public interface IPlatformService
{
    Task</span><span style="color: rgba(0, 0, 255, 1)">&lt;</span><span style="color: rgba(128, 0, 0, 1)">string</span><span style="color: rgba(0, 0, 255, 1)">&gt;</span><span style="color: rgba(0, 0, 0, 1)"> GetPlatformInfo();
}

// MAUI
public class MauiService : IPlatformService { ... }

// Web
public class WebService : IPlatformService { ... }</span></pre>
</div>
</div>
</div>
</div>
</div>
<h3>6. 性能优化手段</h3>
<ul>
<li>
<p><strong>Tree Shaking</strong>：在公共库中使用&nbsp;<code>[DynamicDependency]</code>&nbsp;特性</p>
</li>
</ul>
<div class="cnblogs_code">
<pre>[DynamicDependency(DynamicallyAccessedMemberTypes.All, <span style="color: rgba(0, 0, 255, 1)">typeof</span><span style="color: rgba(0, 0, 0, 1)">(MobileOnlyComponent))]
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span> SharedComponent : ComponentBase</pre>
</div>
<h3 style="margin-left: 30px">7. 调试方案</h3>
<p style="margin-left: 30px">在&nbsp;<code>.vscode/launch.json</code>&nbsp;中配置组合调试：</p>
<div class="md-code-block">
<div class="cnblogs_code">
<pre>{
    "configurations": [
        {
            "name": "Debug MAUI + Web",
            "type": "blazorwasm",
            "request": "launch",
            "browser": "edge",
            "hotReload": true,
            "projects": [
                "ProjectA.csproj",
                "ProjectW.csproj"
            ]
        }
    ]
}</pre>
</div>
</div>
<p style="margin-left: 30px">这种架构的关键点在于：</p>
<ol start="1">
<li style="list-style-type: none"><ol>
<li>
<p>公共组件保持渲染模式不可知</p>
</li>
<li>
<p>各消费项目通过包装组件和构建配置控制最终渲染方式</p>
</li>
<li>
<p>通过条件编译和接口隔离平台特定逻辑</p>
</li>
<li>
<p>利用现代 .NET 的多目标框架特性实现代码最大复用</p>
</li>
</ol></li>
</ol>
<p style="margin-left: 30px">对于需要 SSR 和 WASM 同时存在的页面，建议在 Web 项目中创建路由代理组件：</p>
<div class="cnblogs_code">
<pre>@page <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/hybrid-page</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
@rendermode RenderMode.InteractiveAuto

</span>&lt;SharedComponent @rendermode=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">currentMode</span><span style="color: rgba(128, 0, 0, 1)">"</span> /&gt;<span style="color: rgba(0, 0, 0, 1)">

@code {
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> IComponentRenderMode currentMode =&gt;<span style="color: rgba(0, 0, 0, 1)"> 
        ShouldUseSSR() </span>?<span style="color: rgba(0, 0, 0, 1)"> RenderMode.InteractiveServer : RenderMode.InteractiveWebAssembly;
}</span></pre>
</div>
<p style="margin-left: 30px">这种方案比简单分离渲染模式更灵活，可以：</p>
<ul>
<li>根据设备类型自动切换</li>
</ul>
<ul>
<li class="_mce_tagged_br">实现渐进式增强（先 SSR 再水合）</li>
</ul>
<ul>
<li class="_mce_tagged_br">支持 A/B 测试不同渲染模式</li>
</ul>
<p style="margin-left: 30px">最后建议在解决方案中添加架构测试：</p>
<div class="md-code-block">
<div class="md-code-block-banner-wrap">
<div class="md-code-block-banner">
<div class="md-code-block-infostring">
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">[Test]
</span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> SharedComponents_ShouldNotReferenceRenderingSpecificServices()
{
    </span><span style="color: rgba(0, 0, 255, 1)">var</span> sharedAssembly = <span style="color: rgba(0, 0, 255, 1)">typeof</span><span style="color: rgba(0, 0, 0, 1)">(SharedComponent).Assembly;
    
    Assert.That(sharedAssembly.GetTypes()
        .SelectMany(t </span>=&gt;<span style="color: rgba(0, 0, 0, 1)"> t.GetMethods())
        .Where(m </span>=&gt;<span style="color: rgba(0, 0, 0, 1)"> m.GetParameters()
            .Any(p </span>=&gt; p.ParameterType == <span style="color: rgba(0, 0, 255, 1)">typeof</span><span style="color: rgba(0, 0, 0, 1)">(HttpContext))),
        Is.Empty);
}<br></span></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="itemdesc">
                发表于 
<span id="post-date" data-last-update-days="6.532155460695602" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-12 20:16">2025-02-12 20:16</span>&nbsp;
<a href="https://www.cnblogs.com/WonderFu">WonderFu</a>&nbsp;
阅读(<span id="post_view_count">83</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18712077" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18712077);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18712077', targetLink: 'https://www.cnblogs.com/WonderFu/p/18712077', title: 'deepseek关于【Blazor Hybrid + MAUI + Web 的混合架构中，共享 Razor 组件的渲染模式】的回答' })">举报</a>

            </div>
        