<!----> <meta itemprop="headline" content="2025前端社招最新面试题汇总- 场景题篇"> <meta itemprop="keywords" content="前端,JavaScript"> <meta itemprop="datePublished" content="2025-04-17T09:02:04.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="工七度"> <meta itemprop="url" content="https://juejin.cn/user/2321770730492120"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2025前端社招最新面试题汇总- 场景题篇
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2321770730492120/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    工七度
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-04-17T09:02:04.000Z" title="Thu Apr 17 2025 09:02:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-04-17
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    4,266
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><ul>
<li><a href="https://juejin.cn/spost/7493964577257619507" target="_blank" title="https://juejin.cn/spost/7493964577257619507">vue篇</a></li>
<li><a href="https://juejin.cn/spost/7493975686639140918" target="_blank" title="https://juejin.cn/spost/7493975686639140918">js篇</a></li>
<li><a href="https://juejin.cn/spost/7494100337173069843" target="_blank" title="https://juejin.cn/spost/7494100337173069843">手写题篇</a></li>
<li><a href="https://juejin.cn/post/7493912833992589323" target="_blank" title="https://juejin.cn/post/7493912833992589323">场景题篇</a></li>
<li><a href="https://juejin.cn/post/7494086736390553611" target="_blank" title="https://juejin.cn/post/7494086736390553611">工程篇</a></li>
<li><a href="https://juejin.cn/post/7493909446185517093" target="_blank" title="https://juejin.cn/post/7493909446185517093">ts篇</a></li>
<li><a href="https://juejin.cn/spost/7494078158218018843" target="_blank" title="https://juejin.cn/spost/7494078158218018843">css篇</a></li>
<li><a href="https://juejin.cn/spost/7494078158218035227" target="_blank" title="https://juejin.cn/spost/7494078158218035227">浏览器篇</a></li>
</ul>
<h2 data-id="heading-0">1. pdf预览</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1.href</span>
&lt;a href=<span class="hljs-string">'a.pdf'</span> target=<span class="hljs-string">"_blank"</span>&gt;

<span class="hljs-comment">// 2.window</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">'a.pdf'</span>,<span class="hljs-string">'_blank'</span>)
</code></pre>
<p>3.  <strong>使用 PDF.js</strong></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fmozilla.github.io%2Fpdf.js%2F" target="_blank" title="https://link.juejin.cn/?target=https%3A%2F%2Fmozilla.github.io%2Fpdf.js%2F">PDF.js</a>是一个由 Mozilla 开发的开源库，它使用 HTML5 Canvas 来渲染 PDF 文件。PDF.js 提供了广泛的 API 来实现 PDF 的加载、渲染、缩放、打印等功能。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 引入pdf.js和pdf.worker.js --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/path/to/pdf.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/path/to/pdf.worker.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-comment">&lt;!-- PDF容器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pdf-container"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 初始化PDF.js</span>
  pdfjsLib.<span class="hljs-title function_">getDocument</span>(<span class="hljs-string">"/path/to/your/document.pdf"</span>).<span class="hljs-property">promise</span>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">pdfDoc</span>) {
    <span class="hljs-comment">// 获取第一页</span>
    pdfDoc.<span class="hljs-title function_">getPage</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">page</span>) {
      <span class="hljs-comment">// 设置视口和比例</span>
      <span class="hljs-keyword">var</span> scale = <span class="hljs-number">1.5</span>;
      <span class="hljs-keyword">var</span> viewport = page.<span class="hljs-title function_">getViewport</span>({ <span class="hljs-attr">scale</span>: scale });

      <span class="hljs-comment">// 准备用于渲染的Canvas</span>
      <span class="hljs-keyword">var</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"canvas"</span>);
      <span class="hljs-keyword">var</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">"2d"</span>);
      canvas.<span class="hljs-property">height</span> = viewport.<span class="hljs-property">height</span>;
      canvas.<span class="hljs-property">width</span> = viewport.<span class="hljs-property">width</span>;

      <span class="hljs-comment">// 将Canvas添加到DOM中</span>
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"pdf-container"</span>).<span class="hljs-title function_">appendChild</span>(canvas);

      <span class="hljs-comment">// 通过Canvas渲染PDF页面</span>
      <span class="hljs-keyword">var</span> renderContext = {
        <span class="hljs-attr">canvasContext</span>: ctx,
        <span class="hljs-attr">viewport</span>: viewport,
      };
      page.<span class="hljs-title function_">render</span>(renderContext);
    });
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p><strong>使用第三方服务</strong></p>
<p>也可以使用第三方服务如 Google Docs Viewer 来预览 PDF。这种方法的优点是容易实现，但依赖于外部服务。</p>
<pre><code class="hljs language-ini" lang="ini">&lt;iframe
  <span class="hljs-attr">src</span>=<span class="hljs-string">"http://docs.google.com/gview?url=http://path.to/your/document.pdf&amp;embedded=true"</span>
  <span class="hljs-attr">style</span>=<span class="hljs-string">"width:600px; height:500px;"</span>
  <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"0"</span>
&gt;&lt;/iframe&gt;
</code></pre>
<p>其中，将<code>http://path.to/your/document.pdf</code>替换为你的 PDF 文件的真实 URL。</p>
<h2 data-id="heading-1">2. 日志监控问题：可有办法将请求的调用源码地址包括代码行数也上报上去？</h2>
<h5 data-id="heading-2">2.1.1. 源码映射(Source Maps)</h5>
<p>SourceMap 主要用于<strong>调试目的</strong>，让开发者能够在压缩或转译后的代码中<strong>追踪到原始代码</strong>。</p>
<p>webpack中 配置 <code>devtool: 'source-map'</code>后，</p>
<p>在编译过程中，会生成一个 <code>.map</code> 文件，一般用于代码调试和错误监控。</p>
<ul>
<li>包含了源代码、编译后的代码、以及它们之间的映射关系。</li>
<li>编译后的文件通常会在文件末尾添加一个注释，指向 SourceMap文件的位置。</li>
</ul>

<ul>
<li>
<ul>
<li><code>// # sourceMappingURL=example.js.map</code></li>
</ul>
</li>
</ul>

<ul>
<li>当在浏览器开发者工具调试时，浏览器会读取这行注释并加载对应的 SourceMap 文件</li>
</ul>
<p>报错时，点击跳转。即使运行的是编译后的代码，也能够追溯到原始源代码的具体位置，而不是处理经过转换或压缩后的代码，从而提高了调试效率。</p>
<h5 data-id="heading-3">2.1.2. 自定义错误日志逻辑</h5>
<p>使用try .. catch 自定义报错逻辑，便于错误的追踪。</p>
<h2 data-id="heading-4">3. 用户线上问题的解决</h2>
<p>首先看是否是突然性大量用户受到影响，如果是可能是上线新功能影响，则应该立即回退，降低影响范围</p>
<p>然后再处理问题。复现问题-判断是前端还是后端问题。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f9cd703b0fda47329a7c00ebbc75f185~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5bel5LiD5bqm:q75.awebp?rk3s=f64ab15b&amp;x-expires=1750345942&amp;x-signature=op%2FKBuogZ9wRj1sZLkh2fz3TIZU%3D" alt="" loading="lazy"></p>
<ul>
<li>浏览器缓存</li>
<li>插件影响</li>
<li>网络问题</li>
<li>浏览器版本问题</li>
<li>问题解决后需要进行复盘。</li>
</ul>
<h2 data-id="heading-5">4. 大文件上传</h2>
<ul>
<li>前端上传大文件时使用 file.slice 将文件切片，并发上传多个切片（有标号， Blob 对象），最后发送一个合并的请求通知</li>
<li>使用formData 上传文件</li>
</ul>

<ul>
<li>
<ul>
<li>将分块后的 Blob 对象封装到<code>FormData</code>中，以便通过 HTTP 请求发送。<code>FormData</code>对象提供了一种简单的方式来构造一个包含表单数据的对象，并且可以直接作为<code>fetch</code>或<code>axios</code>请求的<code>body</code>参数。</li>
</ul>
</li>
</ul>

<ul>
<li>服务端合并切片</li>
</ul>

<ul>
<li>
<ul>
<li>切片上传可以将上传成功的切片通过localstorage保存，再 继续上传失败的内容</li>
</ul>
</li>
</ul>

<ul>
<li>服务端接收切片并存储，收到合并请求后使用流将切片合并到最终文件</li>
<li>原生 XMLHttpRequest 的 upload.onprogress 对切片上传进度的监听</li>
<li>使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度</li>
</ul>

<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">"handleFileChange"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleUpload"</span>&gt;</span>upload<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
​
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 切片大小</span>
<span class="hljs-comment">// the chunk size</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SIZE</span> = <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">data</span>: <span class="hljs-function">() =&gt;</span> ({
    <span class="hljs-attr">container</span>: {
      <span class="hljs-attr">file</span>: <span class="hljs-literal">null</span>
    }，
    <span class="hljs-attr">data</span>: []
  }),
  <span class="hljs-attr">methods</span>: {
     <span class="hljs-title function_">handleFileChange</span>(<span class="hljs-params">e</span>) {
      <span class="hljs-keyword">const</span> [file] = e.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>;
      <span class="hljs-keyword">if</span> (!file) <span class="hljs-keyword">return</span>;
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-title function_">data</span>());
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">file</span> = file;
    },
    <span class="hljs-comment">// 生成文件切片</span>
+    <span class="hljs-title function_">createFileChunk</span>(<span class="hljs-params">file, size = SIZE</span>) {
+     <span class="hljs-keyword">const</span> fileChunkList = [];
+      <span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>;
+      <span class="hljs-keyword">while</span> (cur &lt; file.<span class="hljs-property">size</span>) {
+        fileChunkList.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">file</span>: file.<span class="hljs-title function_">slice</span>(cur, cur + size) });
+        cur += size;
+      }
+      <span class="hljs-keyword">return</span> fileChunkList;
+    },
+   <span class="hljs-comment">// 上传切片</span>
+    <span class="hljs-keyword">async</span> <span class="hljs-title function_">uploadChunks</span>(<span class="hljs-params"></span>) {
+      <span class="hljs-keyword">const</span> requestList = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>
+        .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">{ chunk，hash }</span>) =&gt;</span> {
+          <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();
+          formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">"chunk"</span>, chunk);
+          formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">"hash"</span>, hash);
+          formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">"filename"</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">file</span>.<span class="hljs-property">name</span>);
+          <span class="hljs-keyword">return</span> { formData };
+        })
+        .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">{ formData }</span>) =&gt;</span>
+          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>({
+            <span class="hljs-attr">url</span>: <span class="hljs-string">"http://localhost:3000"</span>,
+            <span class="hljs-attr">data</span>: formData
+          })
+        );
+      <span class="hljs-comment">// 并发请求</span>
+      <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(requestList); 
+    },
+    <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleUpload</span>(<span class="hljs-params"></span>) {
+      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">file</span>) <span class="hljs-keyword">return</span>;
+      <span class="hljs-keyword">const</span> fileChunkList = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createFileChunk</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">file</span>);
+      <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = fileChunkList.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">{ file }，index</span>) =&gt;</span> ({
+        <span class="hljs-attr">chunk</span>: file,
+        <span class="hljs-comment">// 文件名 + 数组下标</span>
+        <span class="hljs-attr">hash</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">file</span>.<span class="hljs-property">name</span> + <span class="hljs-string">"-"</span> + index
+      }));
+      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">uploadChunks</span>();
+    }
  <span class="hljs-comment">// 合并切片</span>
+     <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">mergeRequest</span>();
    },
+    <span class="hljs-keyword">async</span> <span class="hljs-title function_">mergeRequest</span>(<span class="hljs-params"></span>) {
+      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>({
+        <span class="hljs-attr">url</span>: <span class="hljs-string">"http://localhost:3000/merge"</span>,
+        <span class="hljs-attr">headers</span>: {
+          <span class="hljs-string">"content-type"</span>: <span class="hljs-string">"application/json"</span>
+        },
+        <span class="hljs-attr">data</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
+          <span class="hljs-attr">filename</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">file</span>.<span class="hljs-property">name</span>
+        })
+      });
+    },    
  }
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h2 data-id="heading-6">5. 文本点开收起展开</h2>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"textContainer"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-overflow"</span>&gt;</span>
        这是一段可能很长的文本，我们希望在一开始时只显示部分，点击“展开”按钮后显示全部内容，再次点击则“收起”文本。
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"toggleButton"</span>&gt;</span>展开<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'toggleButton'</span>);
        button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'textContainer'</span>);
            <span class="hljs-keyword">if</span> (button.<span class="hljs-property">textContent</span> === <span class="hljs-string">'展开'</span>) {
                button.<span class="hljs-property">textContent</span> = <span class="hljs-string">'收起'</span>;
                container.<span class="hljs-property">style</span>.<span class="hljs-property">whiteSpace</span> = <span class="hljs-string">'normal'</span>
            } <span class="hljs-keyword">else</span> {
                button.<span class="hljs-property">textContent</span> = <span class="hljs-string">'展开'</span>;
                container.<span class="hljs-property">style</span>.<span class="hljs-property">whiteSpace</span> = <span class="hljs-string">'nowrap'</span>
            }

        })
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-class">.text-overflow</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;
            <span class="hljs-attribute">overflow</span>: hidden;
            <span class="hljs-attribute">text-overflow</span>: ellipsis;
            <span class="hljs-attribute">white-space</span>: nowrap
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h2 data-id="heading-7">6. 富文本划线获取</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'mouseup'</span>,<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> selection = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getSelection</span>()
  <span class="hljs-keyword">if</span>(selection) {
    <span class="hljs-keyword">const</span> res = selection.<span class="hljs-title function_">toString</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)
  }
})
</code></pre>
<h2 data-id="heading-8">7. 鼠标拖拽</h2>
<p>实现鼠标拖拽功能通常涉及到监听和处理鼠标事件，比如：<code>mousedown</code>、<code>mousemove</code>和<code>mouseup</code>事件。</p>
<pre><code class="hljs language-ini" lang="ini">&lt;button <span class="hljs-attr">id</span>=<span class="hljs-string">"toggleButton"</span>&gt;展开&lt;/button&gt;
    &lt;script&gt;
        const <span class="hljs-attr">button</span> = document.getElementById(<span class="hljs-string">"toggleButton"</span>)
        <span class="hljs-attr">button.style.cursor</span> = <span class="hljs-string">'pointer'</span>
        <span class="hljs-attr">button.style.position</span> = <span class="hljs-string">'absolute'</span>

        let <span class="hljs-attr">dist</span> = {
            x: 0,
            y: 0
        }

        let <span class="hljs-attr">isdraggable</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
        button.addEventListener('mousedown', (e) =&gt; {
            <span class="hljs-attr">isdraggable</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
            <span class="hljs-attr">dist.x</span> = e.pageX - button.<span class="hljs-literal">off</span>setLeft<span class="hljs-comment">;</span>
            <span class="hljs-attr">dist.y</span> = e.pageY - button.<span class="hljs-literal">off</span>setTop<span class="hljs-comment">;</span>

        })
        button.addEventListener('mousemove', (e) =&gt; {
            if (isdraggable) {
                <span class="hljs-attr">button.style.left</span> = e.pageX - dist.x + <span class="hljs-string">'px'</span>
                <span class="hljs-attr">button.style.top</span> = e.pageY - dist.y + <span class="hljs-string">'px'</span>
            }

        })

        button.addEventListener('mouseup', (e) =&gt; {
            if (isdraggable) {
                <span class="hljs-attr">isdraggable</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
                <span class="hljs-attr">dist.x</span> = <span class="hljs-number">0</span>
                <span class="hljs-attr">dist.y</span> = <span class="hljs-number">0</span>
            }
        })
    &lt;/script&gt;
</code></pre>
<h2 data-id="heading-9">8. 要统计全站每一个静态资源（如图片、JS 脚本、CSS 样式表等）的加载耗时</h2>
<ul>
<li><strong>使用</strong> <code>PerformanceObserver</code> <strong>：</strong> 创建一个 <code>PerformanceObserver</code> 实例来监听资源加载事件，能够实时收集性能数据，而且对性能影响较小。</li>
<li><strong>过滤静态资源类型：</strong> 通过检查 <code>initiatorType</code> 属性，筛选出静态资源（例如 <code>img</code>、<code>script</code>、<code>css</code> 等）的加载事件。</li>
<li><strong>计算和展示耗时：</strong> 对每个静态资源的加载耗时进行计算并展示。资源的耗时可以通过 <code>duration</code> 属性直接获取。</li>
</ul>

<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建性能观察者实例来监听资源加载事件</span>
<span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> entries = list.<span class="hljs-title function_">getEntries</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entries) {
    <span class="hljs-comment">// 过滤静态资源类型</span>
    <span class="hljs-keyword">if</span> ([<span class="hljs-string">"img"</span>, <span class="hljs-string">"script"</span>, <span class="hljs-string">"css"</span>, <span class="hljs-string">"link"</span>].<span class="hljs-title function_">includes</span>(entry.<span class="hljs-property">initiatorType</span>)) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`资源 <span class="hljs-subst">${entry.name}</span> 类型 <span class="hljs-subst">${entry.initiatorType}</span> 耗时：<span class="hljs-subst">${entry.duration.toFixed(<span class="hljs-number">2</span>)}</span> 毫秒`</span>);
    }
  }
});

<span class="hljs-comment">// 开始观察 Resource Timing 类型的性能条目</span>
observer.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">entryTypes</span>: [<span class="hljs-string">"resource"</span>] });
</code></pre>
<h2 data-id="heading-10">9. 如何防止前端接口重复发送</h2>
<p>1、提交按钮点击后增加loading, 防止重复点击</p>
<p>2、节流或防抖</p>
<p>3、使用缓存</p>
<p>对于一些数据不经常变化的请求，例如用户信息、配置数据等，可以将请求的结果缓存起来。下一次请求相同的资源时，先从缓存中读取数据，如果缓存有效，则无需再发起新的网络请求。</p>
<h2 data-id="heading-11">10. 一次性渲染十万条数据</h2>
<h3 data-id="heading-12">10.1. 全部渲染-卡死</h3>
<p>这种方法虽然实现起来简单直接，但由于它在一个循环中创建并添加了所有列表项至<code>DOM树</code>，因此在执行过程中，浏览器需要等待<code>JavaScript</code>完全执行完毕才能开始渲染页面。当数据量非常大（例如本例中的100,000个列表项）时，这种大量的<code>DOM操作</code>会导致浏览器的渲染队列积压大量工作，从而引发页面的回流与重绘，浏览器无法进行任何渲染操作，导致了所谓的“阻塞”渲染。</p>
<h3 data-id="heading-13">10.2. setTimeout分批渲染 或 <code>requestAnimationFrame</code></h3>
<p>为了避免一次性操作引起浏览器卡顿，我们可以使用<code>setTimeout</code>将创建和添加操作分散到多个时间点，每次只渲染一<strong>部分</strong>数据。</p>
<pre><code class="hljs language-ini" lang="ini">let <span class="hljs-attr">ul</span>=document.getElementById(<span class="hljs-string">'container'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">total</span>=<span class="hljs-number">100000</span>
let <span class="hljs-attr">once</span>= <span class="hljs-number">20</span>
let <span class="hljs-attr">page</span>=total/<span class="hljs-literal">on</span>ce
let <span class="hljs-attr">index</span>=<span class="hljs-number">0</span>

function loop(curTotal,curIndex){
  let <span class="hljs-attr">pageCount</span>=Math.min(<span class="hljs-literal">on</span>ce,curTotal)
  setTimeout(()=&gt;{
    for(let <span class="hljs-attr">i</span>=<span class="hljs-number">0</span><span class="hljs-comment">;i&lt;pageCount;i++){</span>
      let <span class="hljs-attr">li</span>=document.createElement(<span class="hljs-string">'li'</span>)<span class="hljs-comment">;</span>
      <span class="hljs-attr">li.innerText</span>=curIndex+i+<span class="hljs-string">':'</span>(Math.random()*total)
      ul.appendChild(li)
    }
    loop(curTotal-pageCount,curIndex+pageCount)
  })
}
loop(total,index)
</code></pre>
<p>这里就是把浏览器渲染时的压力分摊给了<code>js引擎</code>，<code>js引擎</code>是单线程工作的，先执行同步，异步，然后浏览器渲染，再宏任务，这里就很好的利用了这一点，把渲染的任务分批执行，减轻了浏览器一次要渲染大量数据造成的渲染“阻塞”，也很好的解决了<code>数据过多</code>时可能造成页面卡顿或白屏的问题,</p>
<p>使用 <code>requestAnimationFrame</code> 替代 <code>setTimeout</code>，将数据拆分为每帧处理 20-50 条，避免主线程阻塞。相比 <code>setTimeout</code>，帧率更稳定且与浏览器渲染周期同步‌</p>
<h3 data-id="heading-14">10.3. 分页实现渲染</h3>
<h3 data-id="heading-15">10.4. 虚拟列表</h3>
<p><code>虚拟列表</code>其实是按需显示的一种实现，即只对<code>可见区域</code>进行渲染，对<code>非可见区域</code>中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"listWrapper"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-wrapper"</span> @<span class="hljs-attr">scroll</span>=<span class="hljs-string">"handleScroll"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"visible-items"</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"{ transform: `translateY(${startIndex * itemHeight}px)` }"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in visibleItems"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-item"</span>&gt;</span>
        {{ item.text }}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">items</span>: [<span class="hljs-comment">/* 假设这里是你的大数据列表 */</span>],
      <span class="hljs-attr">itemHeight</span>: <span class="hljs-number">50</span>, <span class="hljs-comment">// 假设每个列表项的高度是固定的</span>
      <span class="hljs-attr">startIndex</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 当前可视区域的起始索引</span>
      <span class="hljs-attr">visibleCount</span>: <span class="hljs-number">10</span> <span class="hljs-comment">// 可视区域内同时显示的列表项数量</span>
    };
  },
  <span class="hljs-attr">computed</span>: {
    <span class="hljs-title function_">endIndex</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleCount</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>);
    },
    <span class="hljs-title function_">visibleItems</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">endIndex</span>);
    }
  },
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-title function_">handleScroll</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">const</span> scrollTop = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">listWrapper</span>.<span class="hljs-property">scrollTop</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(scrollTop / <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemHeight</span>);
    }
  }
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.list-wrapper</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>; <span class="hljs-comment">/* 设定滚动容器的高度 */</span>
  <span class="hljs-attribute">overflow-y</span>: auto; <span class="hljs-comment">/* 允许垂直滚动 */</span>
  <span class="hljs-attribute">position</span>: relative;
}
<span class="hljs-selector-class">.list-item</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>; <span class="hljs-comment">/* 与data中的itemHeight保持一致 */</span>
  <span class="hljs-comment">/* 其他样式 */</span>
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<h2 data-id="heading-16">11. 如何判断用户设备</h2>
<ul>
<li>
<p>用户代理字符串包含了浏览器类型、版本、操作系统等信息，可以通过分析这些信息来大致判断用户的设备类型。<code>navigator.userAgent</code> 属性用于获取用户代理字符串。</p>
</li>
<li>
<p>使用window.innerWidth 检测视口宽度</p>
</li>
</ul>
<h2 data-id="heading-17">12. IntersectionObserver + scrollIntoView 实现电梯导航</h2>
<p><a href="https://juejin.cn/post/7399982698846404649" target="_blank" title="https://juejin.cn/post/7399982698846404649">juejin.cn/post/739998…</a></p>
<p>电梯导航也被称为锚点导航</p>
<ul>
<li>当点击锚点元素时，页面内相应标记的元素滚动到视口。 scrollIntoView</li>
<li>页面内元素滚动时相应锚点也会高亮。IntersectionObserver</li>
</ul>

<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 点击锚点跳转</span>
<span class="hljs-keyword">let</span> rightBox = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.rightBox'</span>)
  rightBox.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) {
    <span class="hljs-keyword">let</span> target = e.<span class="hljs-property">target</span> || e.<span class="hljs-property">srcElement</span>;
    <span class="hljs-keyword">if</span> (target &amp;&amp; !target.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">'rightBox'</span>)) {
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.'</span> + target.<span class="hljs-property">className</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'Li'</span>, <span class="hljs-string">''</span>)).<span class="hljs-title function_">scrollIntoView</span>({
        <span class="hljs-attr">behavior</span>: <span class="hljs-string">'smooth'</span>,
        <span class="hljs-attr">block</span>: <span class="hljs-string">'center'</span>
      })
    }
  }, <span class="hljs-literal">false</span>)
<span class="hljs-comment">// 页面滚动时，对应锚点样式改变</span>
<span class="hljs-comment">// 也可以使用计算el.offsetTop &lt; window.innerHeight + document.documentElement.scrollTop判断</span>
<span class="hljs-comment">// 是否进入视口</span>
<span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">entries</span>) {
  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> {
    <span class="hljs-keyword">let</span> target = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.'</span> + entry.<span class="hljs-property">target</span>.<span class="hljs-property">className</span> + <span class="hljs-string">'Li'</span>)
    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) { <span class="hljs-comment">// 出现在检测区域内</span>
      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'li'</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
        <span class="hljs-keyword">if</span>(el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">'active'</span>)){
          el.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">'active'</span>)
        }
      })
      <span class="hljs-keyword">if</span> (!target.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">'active'</span>)) {
        target.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'active'</span>)
      }
    }
  })
}, {
  <span class="hljs-attr">threshold</span>: <span class="hljs-number">1</span>
})

<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'div'</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> {
  observer.<span class="hljs-title function_">observe</span>(el)
})
</code></pre>
<h2 data-id="heading-18">13. 退出浏览器之间， 发送积压的埋点数据请求</h2>
<ul>
<li>fecth的 keepalive属性</li>
<li><code>navigator.sendBeacon()</code></li>
</ul>
<p><code>navigator.sendBeacon()</code> 方法允许你在浏览器会话结束时异步地向服务器发送小量数据。这个方法的设计初衷就是为了解决上述问题。<code>sendBeacon()</code> 在大多数现代浏览器中得到支持，并且其异步特性意味着它不会阻塞页面卸载或影响用户体验。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"beforeunload"</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
  <span class="hljs-keyword">var</span> data = {
    <span class="hljs-comment">/* 收集的埋点数据 */</span>
  };
  <span class="hljs-keyword">var</span> beaconUrl = <span class="hljs-string">"https://yourserver.com/path"</span>; <span class="hljs-comment">// 你的服务器接收端点</span>

  navigator.<span class="hljs-title function_">sendBeacon</span>(beaconUrl, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));
});
</code></pre>
<p><code>fetch()</code> API 的 <code>keepalive</code> 选项是另一个选择。这个选项允许你发送一个保持存活状态的请求，即使用户已经离开页面。但是，需要注意的是，使用 <code>keepalive</code> 选项发送的请求有大小限制（大约为 64KB）。</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">window</span><span class="hljs-selector-class">.addEventListener</span>(<span class="hljs-string">"beforeunload"</span>, function (event) {
  <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">data</span> = {
    <span class="hljs-comment">/* 收集的埋点数据 */</span>
  };
  var beaconUrl = <span class="hljs-string">"https://yourserver.com/path"</span>; <span class="hljs-comment">// 你的服务器接收端点</span>

  <span class="hljs-built_in">fetch</span>(beaconUrl, {
    <span class="hljs-attribute">method</span>: <span class="hljs-string">"POST"</span>,
    <span class="hljs-attribute">body</span>: JSON.<span class="hljs-built_in">stringify</span>(data),
    <span class="hljs-attribute">headers</span>: {
      <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>,
    },
    <span class="hljs-attribute">keepalive</span>: true, <span class="hljs-comment">// 保持请求存活</span>
  });
});
</code></pre>
<h2 data-id="heading-19">14. 代码打印</h2>
<pre><code class="hljs language-ini" lang="ini">const { <span class="hljs-attr">a</span> = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span> } = { a: <span class="hljs-string">''</span>, b: undefined, c: null }<span class="hljs-comment">;</span>
// 只有设置为undefined的时候或者没有这个属性的时候才使用默认值
console.log(a, b, c)<span class="hljs-comment">; //    2， null </span>


// 考察运符号优先级和 加法
// const <span class="hljs-attr">result</span> = undefined || (<span class="hljs-number">1</span> + undefined) || <span class="hljs-number">2</span><span class="hljs-comment">;</span>
// undefined转换成数字是NaN, 1+<span class="hljs-attr">NaN</span> = NaN
//  const <span class="hljs-attr">result</span> = undefined || NaN || <span class="hljs-number">2</span><span class="hljs-comment">;</span>
// 最终输出2
const <span class="hljs-attr">result</span> = undefined || <span class="hljs-number">1</span> + undefined || <span class="hljs-number">2</span><span class="hljs-comment">;</span>

console.log(result)<span class="hljs-comment">; </span>
</code></pre>
<h2 data-id="heading-20">15. 多核处理任务</h2>
<p>多核环境下的性能优化需求和JavaScript特性，可采用Web Workers结合时间分片技术实现非阻塞定时任务处理。以下是基于JavaScript类的实现方案</p>
<pre><code class="hljs language-ini" lang="ini"> // worker.js
<span class="hljs-attr">self.onMessage</span> = (data) =&gt; {
    const <span class="hljs-attr">start</span> = Date.now()
    while (Date.now() - start &lt; 100) {
        continue
    }
    self.postMessage(data)
}
// main

class MultTask {
    constructor(<span class="hljs-attr">concurrency</span> = <span class="hljs-number">4</span>) {
        <span class="hljs-attr">this.workersPool</span> = []<span class="hljs-comment">;</span>
        <span class="hljs-attr">this.taskQueue</span> = []<span class="hljs-comment">;</span>
        for (let <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; concurrency; i++) {</span>
            const <span class="hljs-attr">worker</span> = new Worker(<span class="hljs-string">'worker.js'</span>)<span class="hljs-comment">;</span>
            <span class="hljs-attr">worker.onmessage</span> = (data) =&gt; this.<span class="hljs-comment">#handleResult(data, worker)</span>
            <span class="hljs-attr">worker.task</span> = null<span class="hljs-comment">;</span>
            this.workersPool.push(worker)
        }
    }

    addTask(input) {
        return new Promise((resolve, reject) =&gt; {
            const <span class="hljs-attr">task</span> = {
                id: Date.now(),
                input,
                resolve,
            }
            this.taskQueue.push(task)
            this.<span class="hljs-comment">#run()</span>
        })
    }

    <span class="hljs-comment">#run() {</span>
        if (!this.taskQueue.length) return<span class="hljs-comment">;</span>
        const <span class="hljs-attr">availWorker</span> = this.workersPool.find(item =&gt; !item.busy)
        if (!availWorker) return<span class="hljs-comment">;</span>
        <span class="hljs-attr">availWorker.busy</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
        const <span class="hljs-attr">task</span> = this.taskQueue.shift()<span class="hljs-comment">;</span>
        <span class="hljs-attr">availWorker.task</span> = task<span class="hljs-comment">;</span>

        availWorker.postMessage({
            id: task.id,
            input: task.input
        })
    }

    <span class="hljs-comment">#handleResult(data, worker) {</span>
        <span class="hljs-attr">worker.busy</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>
        worker.task.resolve(data)<span class="hljs-comment">;</span>
        <span class="hljs-attr">worker.task</span> = null<span class="hljs-comment">;</span>
        this.<span class="hljs-comment">#run()</span>
    }
}

// 使用实例
const <span class="hljs-attr">processor</span> = new MultTask(<span class="hljs-number">3</span>)
setInterval(() =&gt; {
    processor.addTask(Math.random()).then(<span class="hljs-attr">res</span> =&gt; console.log(res))
}, 40)
</code></pre>
<h2 data-id="heading-21">16. 浏览器环境下幂级计算的优化方案</h2>
<p>快速幂运算 + webworker 结合</p>
<p><strong>快速幂算法</strong>‌<br>
通过二进制分解指数，将计算复杂度从 O(n) 优化至 O(log n)，减少乘法次数。例如计算 a15 时，分解为 a8×a4×a2×a1，仅需 4 次乘法而非 14 次‌</p>
<pre><code class="hljs language-scss" lang="scss">
<span class="hljs-comment">// worker.js</span>
<span class="hljs-comment">// // 分解为子问题计算,递归</span>
function <span class="hljs-built_in">fast</span>(a, n) {
  if (n === <span class="hljs-number">0</span>) return <span class="hljs-number">1</span>;

  <span class="hljs-built_in">if</span>(n &lt; <span class="hljs-number">0</span>) return <span class="hljs-number">1</span> / <span class="hljs-built_in">fast</span>(a, -n);
  
  const half = <span class="hljs-built_in">fast</span>(a, Math.floor(n / <span class="hljs-number">2</span>));
  return n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? half * half : half * half * a
}

self<span class="hljs-selector-class">.onmessage</span> = (a,n) =&gt; {
  const res = <span class="hljs-built_in">fastPower</span>(a,n)
  self<span class="hljs-selector-class">.postmessage</span>(res)
}

<span class="hljs-comment">// main</span>
const worker = new <span class="hljs-built_in">Worker</span>(./worker.js)
worker<span class="hljs-selector-class">.postmessage</span>(<span class="hljs-number">2</span>,<span class="hljs-number">15</span>)
worker<span class="hljs-selector-class">.onmessage</span> = (res) =&gt; {
  console<span class="hljs-selector-class">.log</span>(res)
}
</code></pre></div></div>