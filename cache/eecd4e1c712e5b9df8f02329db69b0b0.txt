<!----> <meta itemprop="headline" content="三行代码完成国际化适配，别等错过了才后悔没收藏！"> <meta itemprop="keywords" content="前端,JavaScript,Babel"> <meta itemprop="datePublished" content="2025-03-11T01:12:53.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="德莱厄斯"> <meta itemprop="url" content="https://juejin.cn/user/3919115686512942"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-6156bb58="">
            三行代码完成国际化适配，别等错过了才后悔没收藏！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-6156bb58=""><div class="author-info-box" data-v-6156bb58=""><div class="author-name" data-v-6156bb58=""><a href="/user/3919115686512942/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-6156bb58=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    德莱厄斯
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-6156bb58=""><time datetime="2025-03-11T01:12:53.000Z" title="Tue Mar 11 2025 01:12:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-6156bb58="">
                    2025-03-11
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-6156bb58=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-6156bb58=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-6156bb58=""></circle></svg> <span class="views-count" data-v-6156bb58="">
                    5,186
                  </span> <span class="read-time" data-v-6156bb58=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-6156bb58=""><rect width="16" height="16" fill="none" data-v-6156bb58=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-6156bb58=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-6156bb58=""></path></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-6156bb58=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-6156bb58=""><div class="article-viewer markdown-body result"><h2 data-id="heading-0">前言</h2>
<p>国际化适配一直以来都是一个棘手的问题，尤其是在项目一开始没有考虑的情况下，我们需要修改大量源码，使用类似于 <code>${t.xxx}</code> 的占位符去一一修改我们已经写好的文字（如最耳熟能详的vue-i18n）。这个工程量在项目后期是巨大的，令人无法接受的。</p>
<p>目前，网上有五花八门的国际化方案，但是大部分都只解决了基础问题——能用，但是都存在这个痛点——太麻烦了。</p>
<p>好，那么有没有一款插件，让我们不用自己动手做这件事呢？</p>
<h2 data-id="heading-1">有的兄弟有的</h2>
<h3 data-id="heading-2">auto-i18n-translation-plugins 简介</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwenps" target="_blank" title="https://github.com/wenps" ref="nofollow noopener noreferrer">wenps</a>/<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwenps%2Fauto-i18n-translation-plugins" target="_blank" title="https://github.com/wenps/auto-i18n-translation-plugins" ref="nofollow noopener noreferrer">auto-i18n-translation-plugins</a> 正是这样一款通用插件</p>
<p>它最少只需要三行参数，像这样：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">i18nPlugin</span> = <span class="hljs-title function_ invoke__">vitePluginsAutoI18n</span>({ &nbsp; 
 &nbsp; <span class="hljs-attr">&nbsp;targetLangList</span>: [<span class="hljs-string">'en'</span>, <span class="hljs-string">'ko'</span>, <span class="hljs-string">'ja'</span>],
 &nbsp; <span class="hljs-attr">&nbsp;translator</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">YoudaoTranslator</span>({ &nbsp; &nbsp; 
 &nbsp; &nbsp; &nbsp; <span class="hljs-attr">&nbsp;appId</span>: <span class="hljs-string">'4xxxx9xxxx66fef'</span>,
 &nbsp; &nbsp; &nbsp; <span class="hljs-attr">&nbsp;appKey</span>: <span class="hljs-string">'ONIxxxxGRxxxxw7UM730xxxxmB3j'</span>
 &nbsp;  })
})
</code></pre>
<p>然后，在 vite 的 plugins 中填入 <code>i18nPlugin</code> 即可。</p>
<p>像这样：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
​
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
 &nbsp; &nbsp;<span class="hljs-attr">resolve</span>: {},
 &nbsp; &nbsp;<span class="hljs-attr">plugins</span>: [i18nPlugin] <span class="hljs-comment">//上面的对象</span>
})
</code></pre>
<p>当插件运行成功后，会生成最终的语言包，在根目录下的 lang 文件夹，然后我们需要在入口处引入，以 vue 为例，在 main.ts 中引入</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// main.ts</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'../lang/index'</span>
</code></pre>
<p>即可。</p>
<p>插件将在 localStorage 中获取到当前语言，所以切换语言时你只需：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'lang'</span>, value) <span class="hljs-comment">// 你在 targetLangList 参数中传入的字符串，如 'en'</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>()
</code></pre>
<p>当然，此插件同样支持 webpack、rollup</p>
<h3 data-id="heading-3">安装</h3>
<pre><code class="hljs language-arduino" lang="arduino">pnpm i vite-<span class="hljs-keyword">auto</span>-i18n-plugin -D
</code></pre>

<pre><code class="hljs language-arduino" lang="arduino">pnpm i webpack-<span class="hljs-keyword">auto</span>-i18n-plugin -D
</code></pre>
<p>上面提到 YoudaoTranslator ，你需要申请自己的有道翻译 api key，或者使用代理使用免费的谷歌翻译（详见插件 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwenps%2Fauto-i18n-translation-plugins%3Ftab%3Dreadme-ov-file%23using-google-translator-default" target="_blank" title="https://github.com/wenps/auto-i18n-translation-plugins?tab=readme-ov-file#using-google-translator-default" ref="nofollow noopener noreferrer">readme.md</a>）。</p>
<p>有道翻译 api 申请地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fai.youdao.com%2Fproduct-fanyi-text.s" target="_blank" title="https://ai.youdao.com/product-fanyi-text.s" ref="nofollow noopener noreferrer">ai.youdao.com/product-fan…</a></p>
<h3 data-id="heading-4">优点</h3>
<p>此插件的和目前市面上的插件的根本区别在于，将翻译、文本替换这两步都自动化了，翻译是前置执行的，而替换过程是在构建过程中发生的，对于使用者来说是不可见且无需关心的，使用之后，项目中的任何文本都无需改动，且插件也不会去修改我们的代码，看起来<strong>一切如旧！妙哉</strong>。</p>
<p>对于传统方式来说，使用此插件之后，工作量将降低 90% 以上。</p>
<p>由于机器翻译可能对于特定语境存在偏差，所以翻译可能不是 100% 准确，这时候我们可以手动去修改少量的翻译文本产物。</p>
<p>插件成功运行后，将在根目录下生成一个 <code>lang</code> 文件夹，<code>lang/index.json</code> 就是生成后的翻译。</p>
<blockquote>
<p>tip: 由于 vite 的运行机制，使用 vite 时，需要先执行 npm run build，这样可以节省 api 用量。</p>
</blockquote>
<p>它大概长这样：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"qylb2"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"zh-cn"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"首页"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"en"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Home page"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"ko"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"첫 페이지"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"ja"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"トップページです"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"dud62"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"zh-cn"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"产品"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"en"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"product"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"ko"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"제품"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"ja"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"製品です"</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"ea9n2"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"zh-cn"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"关于"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"en"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"With regard to"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"ko"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"관"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"ja"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"についてです"</span>
    <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><code>qylb2</code> 等 key 值是源文本的一个 hash，只要源文本不变，就不会重新翻译，所以我们可以自由修改语言的翻译结果，而不会使插件自动重新翻译。</p>
<p>当此文件内容不全，或源文本发生改变（hash发生改变），插件会在构建阶段重新补全（增量）。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/22e5cbdc9cc94aeeaf9ced90952b57dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5b636I6x5Y6E5pav:q75.awebp?rk3s=f64ab15b&amp;x-expires=1746007709&amp;x-signature=d42r9WZvB%2BPqzarZ0qbL6YmKyMQ%3D" alt="autoi18in.svg" loading="lazy"></p>
<p>auto-i18n-translation-plugins 已加入 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAuto-Plugin" target="_blank" title="https://github.com/Auto-Plugin" ref="nofollow noopener noreferrer">auto-plugin 开源联盟</a> ，我们致力于打造足够 auto 的 JS 插件。</p>
<p>作者是 <a href="https://juejin.cn/user/4301712026763790" target="_blank" title="https://juejin.cn/user/4301712026763790">@wenps</a> , Github主页：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwenps" target="_blank" title="https://github.com/wenps" ref="nofollow noopener noreferrer">github.com/wenps</a></p>
<p>项目Github链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwenps%2Fauto-i18n-translation-plugins" target="_blank" title="https://github.com/wenps/auto-i18n-translation-plugins" ref="nofollow noopener noreferrer">github.com/wenps/auto-…</a></p>
<p>为了让兄弟们用插件时足够放心，接下来，将讲解 auto-i18n-translation-plugins 的具体原理，你也可以点击上方链接亲自阅读源码。</p>
<h2 data-id="heading-5">auto-i18n-translation-plugins 原理解析</h2>
<blockquote>
<p>本章由作者 <a href="https://juejin.cn/user/4301712026763790" target="_blank" title="https://juejin.cn/user/4301712026763790">@wenps</a> 亲自编写，内容十分硬核，不想看的同学可以直接跳到文末查看示例。</p>
</blockquote>
<h3 data-id="heading-6">它是如何找到要翻译的文本的？</h3>
<hr>
<p>在开始讨论如何定位需要翻译的文本前，我们首先需要理解 Babel 的核心机制。Babel 是一款 JavaScript 编译工具，它能够通过以下流程将代码转化为可操作的中间表示：</p>
<hr>
<h4 data-id="heading-7"><strong>文案标记</strong></h4>
<ol start="0">
<li>
<p><strong>解析（Parse）</strong> Babel 将输入的 JavaScript 代码解析为<strong>抽象语法树（AST）</strong> ，将代码结构分解为层级清晰的节点（Node）。例如，字符串字面量、模板字符串、JSX 元素等会转换为对应的 AST 节点类型（如 <code>StringLiteral</code>, <code>TemplateLiteral</code>, <code>JSXText</code>）以中文为例，一般中文就会出现在这些<code>StringLiteral</code>, <code>TemplateLiteral</code>, <code>JSXText</code>ast节点中，因此处理这些节点即可。</p>
</li>
<li>
<p><strong>转换（Transform）</strong> 通过 <code>Babel.transform</code> 方法对来源语言可能出现的<code>StringLiteral</code>, <code>TemplateLiteral</code>, <code>JSXText</code>等AST节点进行深度遍历，通过这种手段去扫描目标文案：</p>
<ul>
<li><strong>定位目标文本</strong>：遍历 AST，筛选出<code>StringLiteral</code>, <code>TemplateLiteral</code>, <code>JSXText</code>等AST节点，如果来源语言是中文，那就匹配当前节点的值当前是否符合中文的正则，符合就往下走；</li>
<li><strong>过滤无需翻译的内容</strong>：排除路径引用（<code>import '/path'</code>）、对象键名（<code>{ key: 'value' }</code>）、注释等非内容文本；</li>
<li><strong>标记文本</strong>：如果存在符合来源语言的正则，又不属于无需翻译的内容，就会对需要翻译的文本生成唯一哈希（为了保证不会出现重复翻译），并将其替换为翻译函数调用（如 <code>$t('哈希值', '原始文本')</code>）。</li>
<li>全部文件遍历完之后，文案的标记就完成了</li>
</ul>
</li>
<li>
<p><strong>代码生成（Generate）</strong> 将修改后的 AST 转换回 JavaScript 代码，最终输出包含翻译标记的源文件。</p>
</li>
</ol>
<hr>
<h4 data-id="heading-8"><strong>文案收集</strong></h4>
<p>标记完之后还需要去将标记的文案和hash收集起来，因此我们会先生成一个全局变量，这里有两个方案：</p>
<ol start="0">
<li>
<p><strong>遍历时同步收集</strong></p>
<ul>
<li><strong>流程</strong>：在遍历 AST 标记文本时，将哈希值和原始文本实时<strong>存储到全局对象</strong>。</li>
<li><strong>优点</strong>：仅需遍历一次，节省时间；</li>
</ul>
</li>
<li>
<p><strong>分步处理</strong></p>
<ul>
<li>
<p><strong>流程</strong>：</p>
<ol start="0">
<li><strong>首次遍历</strong>：将文本替换为 <code>$t</code> 调用，不存储数据；</li>
<li><strong>二次遍历</strong>：专门收集所有 <code>$t</code> 调用中的参数（哈希和文本）<strong>存储到全局对象</strong>。</li>
</ol>
</li>
<li>
<p><strong>优点</strong>：逻辑分离清晰，避免副作用；</p>
</li>
</ul>
</li>
</ol>
<p>目前我们这里使用的就是方案二，<strong>完成这一步之后所有的待翻译文字就已经被存储到了全局对象中，接下来我们需要将这些文案进行翻译即可。</strong></p>
<hr>
<h4 data-id="heading-9"><strong>文案收集举例</strong></h4>
<p>原始代码：</p>
<pre><code class="hljs language-arduino" lang="arduino">&lt;Div&gt;按钮文字&lt;/Div&gt;
<span class="hljs-type">const</span> message = <span class="hljs-string">'系统提示'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'styles.css'</span>; <span class="hljs-comment">// 路径无需翻译</span>
</code></pre>
<p>经 Babel 插件处理后输出：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-title function_ invoke__">_c</span>(<span class="hljs-string">'div'</span>, [<span class="hljs-variable">$t</span>(<span class="hljs-string">'f8b7a1d'</span>, <span class="hljs-string">'按钮文字'</span>)]);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">message</span> = <span class="hljs-variable">$t</span>(<span class="hljs-string">'2e3c9a7'</span>, <span class="hljs-string">'系统提示'</span>);
import <span class="hljs-string">'styles.css'</span>; <span class="hljs-comment">// 路径未被修改</span>
</code></pre>
<p>最终遍历函数，读取hash和文字，并收集的全局对象中，就会得到一个映射表：</p>
<pre><code class="hljs language-css" lang="css">{
  f8b7a1d: <span class="hljs-string">'按钮文字'</span>,
  <span class="hljs-number">2</span>e3c9a7: <span class="hljs-string">'系统提示'</span>
}
</code></pre>
<p>到这一步就完成了目标文案的函数转换和收集。</p>
<hr>
<p>通过这一机制，开发者无需手动标记文本，Babel 能够自动化识别和准备需要翻译的内容，同时确保结构化代码的准确性。</p>
<hr>
<h3 data-id="heading-10">它是如何进行翻译的？</h3>
<p>在上面的描述中我们已经通过babel 完成文案的收集了，那我们怎么完成翻译呢？主要分成两步。</p>
<p>这里我做了两个翻译器（class），它们负责接收用户参数，以及进行接下来的操作。</p>
<h4 data-id="heading-11">第一步：实例化翻译器</h4>
<p>插件默认暴露了两个可用的翻译器类和一个翻译器基类，可用的翻译器类分别包括有道翻译器类和谷歌翻译器类，这两个类实例化即可使用，实例化代码如下：</p>
<p>有道翻译：（强烈推荐有道翻译）</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">new</span> <span class="hljs-built_in">YoudaoTranslator</span>({     
	appId: <span class="hljs-string">'4xxxx9xxxx66fef'</span>,
	appKey: <span class="hljs-string">'ONIxxxxGRxxxxw7UM730xxxxmB3j'</span>
})
</code></pre>
<p>谷歌翻译：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">new</span> <span class="hljs-string">GoogleTranslator({</span>
  <span class="hljs-attr">proxyOption:</span> { <span class="hljs-string">//</span> <span class="hljs-string">国内使用需要配置代理</span>
    <span class="hljs-attr">host:</span> <span class="hljs-string">'127.0.0.1'</span>,
    <span class="hljs-attr">port:</span> <span class="hljs-number">8899</span>,
    <span class="hljs-attr">headers:</span> {
      <span class="hljs-attr">'User-Agent':</span> <span class="hljs-string">'Node'</span>
    }
  }
<span class="hljs-string">})</span>
</code></pre>
<p>通过内置的<code>translate</code>函数进行翻译。</p>
<p>谷歌翻译和有道翻译都是继承于翻译器基类：</p>
<p><code>Translator</code> 是一个封装翻译功能的核心类，用于通过配置好的翻译 API（如机器翻译服务）将文本从源语言转换为目标语言。其设计目标是<strong>标准化翻译调用流程</strong>、<strong>管理 API 请求频率</strong>并提供<strong>错误处理机制</strong>。（更详细内容可以去看github源码，有相关的类型标识）</p>
<p><strong><code>Translator</code></strong> 源码</p>
<pre><code class="hljs language-typescript" lang="typescript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Translator</span> {
    <span class="hljs-keyword">protected</span> <span class="hljs-attr">option</span>: <span class="hljs-title class_">TranslatorOption</span>

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">option: TranslatorOption</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">option</span> = option
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">option</span>.<span class="hljs-property">interval</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">option</span>.<span class="hljs-property">fetchMethod</span> = <span class="hljs-title function_">interval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">option</span>.<span class="hljs-property">fetchMethod</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">option</span>.<span class="hljs-property">interval</span>)
        }
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">getErrorMessage</span>(<span class="hljs-params">error: <span class="hljs-built_in">unknown</span></span>) {
        <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>) {
            <span class="hljs-keyword">return</span> error.<span class="hljs-property">message</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">String</span>(error)
        }
    }

    <span class="hljs-keyword">async</span> <span class="hljs-title function_">translate</span>(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, fromKey: <span class="hljs-built_in">string</span>, toKey: <span class="hljs-built_in">string</span></span>) {
        <span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>
        <span class="hljs-keyword">try</span> {
            result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">option</span>.<span class="hljs-title function_">fetchMethod</span>(text, fromKey, toKey)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-keyword">const</span> name = <span class="hljs-variable language_">this</span>.<span class="hljs-property">option</span>.<span class="hljs-property">name</span>
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(
                <span class="hljs-string">`翻译api<span class="hljs-subst">${name ? <span class="hljs-string">`【<span class="hljs-subst">${name}</span>】`</span> : <span class="hljs-string">''</span>}</span>请求异常：<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.getErrorMessage(error)}</span>`</span>
            )
        }
        <span class="hljs-keyword">return</span> result
    }
}
</code></pre>
<blockquote>
<p>所以，好像你也可以做一个自定义的 CustomTranslator</p>
</blockquote>
<h4 data-id="heading-12">第二步：翻译目标语言</h4>
<p>实例化翻译器之后就需要对我们扫描出来的文案进行翻译了，下面是具体的步骤</p>
<hr>
<h5 data-id="heading-13"><strong>1. 找出需要翻译的新文案</strong></h5>
<ul>
<li>
<p><strong>第一步</strong>：读取两份数据：</p>
<ul>
<li><strong>全局对象</strong>：代码中所有文案生成的全局对象（比如 <code>"hash1" →"确定"， "hash2" → "你好"</code>）。</li>
<li><strong>已翻译的旧文件（运行插件的时候会生成一个index.json, 里面存放的就是旧的翻译内容）</strong> ：之前翻译好的结果（比如 hash1 的中英文都有了，但 hash2 还没翻译）。</li>
</ul>
</li>
<li>
<p><strong>筛选规则</strong>：找出旧文件中<strong>没有翻译过</strong>的文案（如 hash2 的“你好”需要翻译成英文等）并将这个没翻译的重新存储在一个<strong>临时对象</strong>中。</p>
</li>
</ul>
<blockquote>
<pre><code class="hljs language-css" lang="css">{
	hash2: 你好
}
</code></pre>
</blockquote>
<hr>
<h5 data-id="heading-14"><strong>2. 合并文案方便一次性翻译</strong></h5>
<ul>
<li>
<p><strong>操作</strong>：通过key去读取临时对象，把需要翻译的原文用符号 <code>\n┋┋┋\n</code> 连起来，变成一个长文本。</p>
<ul>
<li>
<p><strong>例子</strong>：</p>
<ul>
<li>
<p>原始文案列表： <code>["你好", "欢迎来到系统"]</code></p>
</li>
<li>
<p>合并后的长文本：</p>
<pre><code class="hljs">你好\n┋┋┋\n欢迎来到系统  
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>为什么这么做？</strong> ：把多个短文案合并成一个长文本，可以一次批量翻译，减少多次调用翻译接口的时间，而且通过 key 去读取，可以保证顺序的一致性，因为 key 不会变。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 data-id="heading-15"><strong>3. 分语言翻译并拆分结果</strong></h5>
<ul>
<li>
<p><strong>步骤</strong>：</p>
<ol start="0">
<li>
<p><strong>选择目标语言</strong>：比如要翻译成英文、韩语。</p>
</li>
<li>
<p><strong>逐个翻译</strong>：</p>
<ul>
<li>
<p>对合并后的长文本调用翻译器实例的翻译函数，设置语言参数（如英文、韩语）。</p>
</li>
<li>
<p><strong>结果示例</strong>：</p>
<ul>
<li>英文翻译 → <code>Hello\n┋┋┋\nWelcome to the system</code></li>
<li>韩语翻译 → <code>안녕하세요\n┋┋┋\n시스템에 오신 것을 환영합니다</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>拆分结果</strong>：根据 <code>\n┋┋┋\n</code> 符号，把翻译后的文本切回一个个单独文案。例如：</p>
<ul>
<li>英文结果 → <code>[ "Hello", "Welcome..." ]</code></li>
<li>韩语结果 → <code>[ "안녕하세요", ... ]</code> <strong>值得注意的时候此时的数组顺序，和我们生成的临时对象变量key的顺序是一致的</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h5 data-id="heading-16"><strong>4. 匹配原文顺序，更新翻译映射表</strong></h5>
<ul>
<li>
<p><strong>关键点</strong>：</p>
<ul>
<li>
<p>因为合并时保持了原文档的顺序（如按哈希值 <code>hash2</code>排列），拆分后的翻译结果也能按顺序对应原文。</p>
</li>
<li>
<p><strong>操作</strong>：</p>
<ol start="0">
<li>
<p>新建临时存储对象，把翻译结果按哈希值归类。例如：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>  
  <span class="hljs-attr">"hash2"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>  
    <span class="hljs-attr">"zh"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"你好"</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 原文（不翻译）  </span>
    <span class="hljs-attr">"en"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Hello"</span><span class="hljs-punctuation">,</span>   <span class="hljs-comment">// 新翻译的英文  </span>
    <span class="hljs-attr">"ko"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"안녕하세요"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 新翻译的韩语  </span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>  
  ...  
<span class="hljs-punctuation">}</span>  
</code></pre>
</li>
<li>
<p><strong>合并到旧文件</strong>：把临时对象中的新翻译内容，追加到已有的映射表中。</p>
<ul>
<li>
<p><strong>最终效果</strong>：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>  
  <span class="hljs-attr">"hash1"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"zh"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"确定"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"en"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Confirm"</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 已有的旧数据  </span>
  <span class="hljs-attr">"hash2"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"zh"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"你好"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"en"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Hello"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"ko"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"안녕하세요"</span> <span class="hljs-punctuation">}</span> <span class="hljs-comment">// 新增翻译  </span>
<span class="hljs-punctuation">}</span>  
</code></pre>
<p>3.<strong>合并完之后重新写入</strong></p>
</li>
</ul>
</li>
</ol>
<ul>
<li>将合并完之后的对象重新写入到配置文件中即可，完成文案的翻译</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>通过这种流程，新增文案会自动被翻译并整合到文件里，同时保证已翻译的内容不受影响，整个过程就像“把碎片拼成整张画 → 一起翻译 → 再分开展示”一样简单。</p>
<h3 data-id="heading-17">它是如何处理新增的语言和增量文案？</h3>
<hr>
<h4 data-id="heading-18">新加语言</h4>
<p>当需要新增目标语言（如从「中→英」扩展为「中→英→韩」），<strong>无需手动编辑映射表</strong>：</p>
<p>插件启动时会自动检查<strong>当前配置语言列表</strong>（如 <code>zh, en, ko</code>）与<strong>映射表内已有语言</strong>（如存在 <code>zh</code> 和 <code>en</code>）。若发现<strong>新增语言未初始化</strong>（如 <code>ko</code>），则触发自动补全流程——</p>
<p><strong>具体步骤</strong>：</p>
<ol start="0">
<li>
<p><strong>提取源语言文案</strong>：直接从映射表中拉取<strong>原始语言</strong>（如中文）的所有纯文本内容（如 <code>"确定"，"韩文"</code>）。</p>
</li>
<li>
<p><strong>批量翻译新增语言</strong>：通过合并符 <code>\n┇┇┇\n</code> 拼接原始语言,(如<code>确定\n┇┇┇\n韩文</code>)，将文案统一翻译为目标语言（如韩语 <code>확인\n┇┇┇\n한글</code>），重新按照合并符 <code>\n┇┇┇\n</code>进行切割，就可以得到新增语言的翻译如：<code>확인</code>, <code>한글</code>。</p>
</li>
<li>
<p><strong>追加语言数据</strong>：将新翻译结果<strong>直接写入映射表</strong>对应位置，例如：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"确认按钮"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>  
  <span class="hljs-attr">"zh"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"确定"</span><span class="hljs-punctuation">,</span>  
  <span class="hljs-attr">"en"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Confirm"</span><span class="hljs-punctuation">,</span>  
  <span class="hljs-attr">"ko"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"확인"</span>  
<span class="hljs-punctuation">}</span>  
</code></pre>
</li>
</ol>
<p>此过程完全自动化，开发者只需在配置中添加目标语言代码，插件即可无缝扩展语言包，无需手动维护映射表或担忧变量错位问题。</p>
<h4 data-id="heading-19">新加文案</h4>
<ul>
<li>每次代码编译时，插件会扫描所有文本（如 <code>"新按钮"</code>），自动生成翻译函数调用（如 <code>$t('哈希', '新按钮')</code>）。</li>
<li>这一过程<strong>完全无感</strong>，开发者无需手动标注新文案。</li>
</ul>
<hr>
<ul>
<li>
<p>插件将新文本的<strong>哈希值</strong>与<strong>原始内容</strong>写入全局映射表时，会先判断该哈希是否已存在：</p>
<ul>
<li><strong>若不存在</strong>：追加新条目（如 <code>"哈希": "新按钮"</code>）。</li>
<li><strong>若已存在</strong>：跳过写入，避免覆盖已有翻译记录。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>
<p>在翻译阶段，插件会比对：</p>
<ul>
<li>当前代码中的<strong>全局映射表</strong>（存储文本和hash的全局变量）</li>
<li>已有翻译配置文件（ <code>index.json</code>）。</li>
</ul>
</li>
<li>
<p><strong>自动筛选出未翻译的新增文案</strong>，仅对它们触发翻译流程。</p>
</li>
<li>
<p>然后对翻译结果进行切割，并重新写入到翻译配置文件中。</p>
</li>
</ul>
<hr>
<p><strong>示例场景</strong></p>
<blockquote>
<p><strong>原始映射表</strong></p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
	<span class="hljs-attr">"确定按钮hash"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"zh"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"确定"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"en"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Confirm"</span> <span class="hljs-punctuation">}</span>  
<span class="hljs-punctuation">}</span>
</code></pre>
<p><strong>新增代码文案</strong>：<code>&lt;button&gt;重置&lt;/button&gt;</code> <strong>插件动作</strong>：</p>
<ol start="0">
<li>自动生成 <code>$t('新哈希', '重置')</code>。</li>
<li>更新映射表：</li>
</ol>

<pre><code class="hljs language-json" lang="json">  <span class="hljs-punctuation">{</span>
	<span class="hljs-attr">"新哈希"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"zh"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"重置"</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 中文自动填充，其他语言待翻译  </span>
  <span class="hljs-punctuation">}</span>
</code></pre>
<p>3.  <strong>翻译提示</strong>：只需补充英文 <code>"Reset"</code>、日文 <code>"リセット"</code> 等，无需处理已存在的“确定”按钮。</p>
</blockquote>
<hr>
<p>通过以上分步设计，开发者可专注于代码开发，翻译工作仅聚焦于真正新增的内容。</p>
<hr>
<h3 data-id="heading-20">它如何使结果回显到页面上的？</h3>
<p>通过上面的内容我们已经成功的将待翻译的文本转换成了翻译函数调用, 并且通过翻译实例将待翻译的文本进行了翻译，那么接下来我们需要将翻译的结果回显到页面上。</p>
<p>不妨看看编译后的内容长什么样：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-title function_ invoke__">_c</span>(<span class="hljs-string">'div'</span>, [<span class="hljs-variable">$t</span>(<span class="hljs-string">'f8b7a1d'</span>, <span class="hljs-string">'按钮文字'</span>)]);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">message</span> = <span class="hljs-variable">$t</span>(<span class="hljs-string">'2e3c9a7'</span>, <span class="hljs-string">'系统提示'</span>);
import <span class="hljs-string">'styles.css'</span>; <span class="hljs-comment">// 路径未被修改</span>
</code></pre>
<p>因此为了使其回显到页面上，我们需要做的就是将<strong>全局的$t实现即可</strong>。</p>
<p>下面通过源码来介绍：（这个文件要在项目首行引入）</p>
<pre><code class="hljs language-javascript" lang="javascript">	<span class="hljs-comment">// 导入插件生成的国际化JSON文件</span>
    <span class="hljs-keyword">import</span> langJSON <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.json'</span>
    (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 定义翻译函数</span>
    <span class="hljs-keyword">let</span> $t = <span class="hljs-keyword">function</span> (<span class="hljs-params">key, val, nameSpace</span>) {
      <span class="hljs-comment">// 获取指定命名空间下的语言包</span>
      <span class="hljs-keyword">const</span> langPackage = $t[nameSpace];
      <span class="hljs-comment">// 返回翻译结果，如果不存在则返回默认值</span>
      <span class="hljs-keyword">return</span> (langPackage || {})[key] || val;
    };
    <span class="hljs-comment">// 定义设置语言包的方法</span>
    $t.<span class="hljs-property">locale</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">locale, nameSpace</span>) {
      <span class="hljs-comment">// 将指定命名空间下的语言包设置为传入的locale</span>
      $t[nameSpace] = locale || {};
    };
    <span class="hljs-comment">// 将翻译函数挂载到window对象上，如果已经存在则使用已有的</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">$t</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">$t</span> || $t;
    <span class="hljs-comment">// 将简单翻译函数挂载到window对象上</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">$$t</span> = $$t;
    <span class="hljs-comment">// 定义从JSON文件中获取指定键的语言对象的方法</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">_getJSONKey</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">key, insertJSONObj = <span class="hljs-literal">undefined</span></span>) {
        <span class="hljs-comment">// 获取JSON对象</span>
        <span class="hljs-keyword">const</span> <span class="hljs-title class_">JSON</span>Obj = insertJSONObj;
        <span class="hljs-comment">// 初始化语言对象</span>
        <span class="hljs-keyword">const</span> langObj = {};
        <span class="hljs-comment">// 遍历JSON对象的所有键</span>
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-title class_">JSON</span>Obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
            <span class="hljs-comment">// 将每个语言的对应键值添加到语言对象中</span>
            langObj[value] = <span class="hljs-title class_">JSON</span>Obj[value][key];
        });
        <span class="hljs-comment">// 返回语言对象</span>
        <span class="hljs-keyword">return</span> langObj;
    };
    })();
    <span class="hljs-comment">// 定义语言映射对象</span>
    <span class="hljs-keyword">const</span> langMap = {
		<span class="hljs-comment">// 根据插件的配置来生成语言map</span>
        <span class="hljs-string">'en'</span>: <span class="hljs-variable language_">window</span>?.<span class="hljs-property">lang</span>?.<span class="hljs-property">en</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">_getJSONKey</span>(<span class="hljs-string">'en'</span>, langJSON),
		<span class="hljs-string">'ko'</span>: <span class="hljs-variable language_">window</span>?.<span class="hljs-property">lang</span>?.<span class="hljs-property">ko</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">_getJSONKey</span>(<span class="hljs-string">'ko'</span>, langJSON),
		<span class="hljs-string">'zhcn'</span>: <span class="hljs-variable language_">window</span>?.<span class="hljs-property">lang</span>?.<span class="hljs-property">zhcn</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">_getJSONKey</span>(<span class="hljs-string">'zhcn'</span>, langJSON)
    };
    <span class="hljs-comment">// 从本地存储中获取当前语言，如果不存在则使用源语言</span>
    <span class="hljs-keyword">const</span> lang = <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'lang'</span>) || <span class="hljs-string">'zhcn'</span>;
    <span class="hljs-comment">// 根据当前语言设置翻译函数的语言包</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">$t</span>.<span class="hljs-title function_">locale</span>(langMap[lang], <span class="hljs-string">'lang'</span>);
  
</code></pre>
<p>通过阅读上面的代码可以看到，为了回显到页面上，我们会导入生成的翻译json，通过<code>window.$t.locale(langMap[lang], 'lang')</code>将对应的语言包设置到翻译函数上，这样就可以在页面上使用$t函数进行翻译了。</p>
<h3 data-id="heading-21">它为什么不用影响现有代码？</h3>
<p>插件基于编译时<strong>AST语法树分析</strong>实现无感化改造：在代码构建阶段，通过解析源代码的抽象语法树（AST），精准定位需翻译的文本内容，智能替换为指定翻译函数（如 <code>$t('哈希','原始文本')</code>）。 同时，该过程会<strong>动态归集</strong>所有需翻译的文案数据，生成映射表（index.json）。这一处理完全运行于构建流程之中，既<strong>不修改源代码文件的原始结构</strong>，也不会对运行期JavaScript逻辑产生任何干扰，确保开发与生产环境的稳定性。</p>
<pre><code class="hljs language-bash" lang="bash">(例如对 `&lt;div&gt;文本&lt;/div&gt;` 自动转译为 `<span class="hljs-variable">$t</span>(<span class="hljs-string">'hash'</span>,<span class="hljs-string">'文本'</span>)`，但原始源代码文件保持不变，开发调试时仍可直接查看原生字符串内容)
</code></pre>
<h3 data-id="heading-22">它为什么可以兼容全部前端框架？</h3>
<hr>
<p><code>auto-i18n-translation-plugins</code> 的设计建立在<strong>框架无关的后期处理</strong>原则之上。由于所有前端框架（如 Vue、React、Svelte 等）<strong>最终都会将其自定义语法（模板、组件、JSX 等）编译为标准 JavaScript 代码</strong>，而该插件的文本提取与翻译函数替换逻辑<strong>被明确置于构建流程的最后阶段执行</strong>。这一策略的核心在于：</p>
<ul>
<li>开发者框架的各类<strong>解析和编译操作</strong>（如 Vue 的模板编译、React 的 JSX 转义）均在插件运行前完成；</li>
<li>插件直接处理<strong>最终的纯 JavaScript 代码</strong>，无需理解具体框架的内部语法或结构；</li>
<li>只要确保插件在构建管线的<strong>最后阶段生效</strong>（如 Webpack 的 <code>loader</code> 排序、Vite 的 <code>plugin</code> 配置顺序），即可兼容所有符合标准编译流程的前端框架。</li>
</ul>
<p><strong>效果</strong>： 开发者只需将插件配置为构建流程的收尾环节，即可<strong>无感支持 Vue + TS、React + SWC、纯 JS 项目等任意技术栈</strong>，无需为不同框架单独配置适配层。</p>
<hr>
<h2 data-id="heading-23">仓库地址和案例</h2>
<p>Github：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwenps" target="_blank" title="https://github.com/wenps" ref="nofollow noopener noreferrer">wenps</a>/<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwenps%2Fauto-i18n-translation-plugins" target="_blank" title="https://github.com/wenps/auto-i18n-translation-plugins" ref="nofollow noopener noreferrer">auto-i18n-translation-plugins</a></p>
<p>NPM vite 版: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fvite-auto-i18n-plugin" target="_blank" title="https://www.npmjs.com/package/vite-auto-i18n-plugin" ref="nofollow noopener noreferrer">www.npmjs.com/package/vit…</a></p>
<p>NPM webpack 版：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-auto-i18n-plugin%3FactiveTab%3Dreadme" target="_blank" title="https://www.npmjs.com/package/webpack-auto-i18n-plugin?activeTab=readme" ref="nofollow noopener noreferrer">www.npmjs.com/package/web…</a></p>
<p>案例：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwenps%2Fauto-i18n-translation-plugins%2Ftree%2Fmain%2Fexample" target="_blank" title="https://github.com/wenps/auto-i18n-translation-plugins/tree/main/example" ref="nofollow noopener noreferrer">github.com/wenps/auto-…</a></p>
<h3 data-id="heading-24">TODO</h3>
<ul>
<li>ssr 全自动支持，目前需要手动适配</li>
<li>自动引入 lang/index.js</li>
</ul></div></div>