
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/v-fan/p/18843188" title="发布于 2025-04-23 17:58">
    <span role="heading" aria-level="2">一文详解银河麒麟配置容器运行时及gVisor(runsc)、Kata(runv)详细指南</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="容器运行时介绍">容器运行时介绍</h1>
<h2 id="容器运行时核心概念与分类">容器运行时核心概念与分类</h2>
<p>容器运行时（Container Runtime）是管理容器生命周期（创建、启动、停止、删除）和资源隔离的核心组件，通过与操作系统内核协作实现容器化环境。根据功能层级和技术实现，容器运行时可分为以下三类。</p>
<h3 id="高层运行时high-level-runtime">高层运行时（High-Level Runtime）</h3>
<p><strong>作用</strong>：</p>
<p>高层运行时主要负责<strong>镜像管理</strong>（如下载、解压、转换镜像）、容器生命周期管理（如创建、启动、停止容器）、存储和网络配置等高级功能。它为容器运行提供基础环境准备，并将镜像转换为低层运行时所需的文件系统和配置。</p>
<p><strong>核心特点</strong>：</p>
<ul>
<li>提供镜像仓库交互、镜像层解压等能力。</li>
<li>集成容器编排系统（如Kubernetes），提供标准化的API接口。</li>
<li>通常与低层运行时配合使用，形成完整的容器管理链。</li>
</ul>
<p><strong>代表产品与技术</strong>：</p>
<ol>
<li>
<p><strong>Docker Engine</strong></p>
<p><strong>特点</strong>：包含高层运行时（Dockerd）和低层运行时（runc），提供完整的容器生态（如镜像构建、网络配置）。但因多层封装导致复杂性较高，逐渐被替代</p>
<p><strong>应用场景</strong>：用于应用、镜像测试，或小规模容器管理</p>
</li>
<li>
<p><strong>Containerd</strong></p>
<p><strong>特点</strong>：由Docker分离出的轻量级运行时，专注于核心功能，性能高且稳定。支持OCI标准，与Kubernetes深度集成，已成为Kubernetes默认运行时之一</p>
<p><strong>应用场景</strong>：生产环境、大规模容器集群管理</p>
</li>
<li>
<p><strong>CRI-O</strong></p>
<p><strong>特点</strong>：专为Kubernetes设计的轻量级运行时，符合CRI（容器运行时接口）规范。直接调用低层运行时（如runc），简化与Kubernetes的集成，资源消耗低</p>
<p><strong>应用场景</strong>：Kubernetes环境中替代Docker，适合需要精简架构的场景。</p>
</li>
</ol>
<h3 id="低层运行时low-level-runtime">低层运行时（Low-Level Runtime）</h3>
<p><strong>作用</strong>：</p>
<p>低层运行时直接与宿主机操作系统交互，负责<strong>容器进程的隔离与执行</strong>，包括设置Linux Namespace、Cgroups资源限制、文件系统挂载等底层操作。它是实际启动容器进程的核心组件。</p>
<p><strong>核心特点</strong>：</p>
<ul>
<li>轻量级，仅关注进程隔离和资源控制。</li>
<li>遵循OCI（开放容器标准）规范，提供标准化接口</li>
</ul>
<p><strong>代表产品与技术</strong>：</p>
<ol>
<li>
<p><strong>runc</strong></p>
<p><strong>特点</strong>：最广泛使用的低层运行时，基于Namespace和Cgroups实现容器隔离。作为Docker和Containerd的默认执行引擎，启动速度快但安全性较低（共享内核）。</p>
<p><strong>应用场景</strong>：通用容器场景，需高性能但隔离要求不高的环境</p>
</li>
<li>
<p><strong>runv（Kata Containers/Firecracker）</strong></p>
<p><strong>特点</strong>：基于虚拟化技术（如KVM），通过轻量级虚拟机（MicroVM）实现强隔离。适合多租户和高安全需求场景，但启动速度较慢（约100ms）</p>
<p><strong>应用场景</strong>：金融、云服务等需要严格安全隔离的环境</p>
</li>
<li>
<p><strong>runsc（gVisor）</strong></p>
<p><strong>特点</strong>：通过拦截系统调用实现沙箱化隔离，安全性介于runc和runv之间。资源消耗低，但兼容性受限（部分系统调用不支持）</p>
<p><strong>应用场景</strong>：对安全有中等要求的容器化应用，如公有云多租户服务。</p>
</li>
</ol>
<h3 id="沙盒虚拟化运行时sandboxed-runtime">沙盒/虚拟化运行时（Sandboxed Runtime）</h3>
<p><strong>作用</strong>：</p>
<p>通过虚拟化或沙盒技术增强安全性，适用于多租户和高敏感场景。</p>
<p><strong>代表产品与技术</strong>：</p>
<ol>
<li>
<p><strong>Kata Containers</strong></p>
<p><strong>特点</strong>：通过轻量级虚拟机（MicroVM）实现容器隔离，每个容器运行在独立的虚拟机内核中，避免了共享宿主机内核的安全风险。这种设计可防御容器逃逸攻击，尤其适用于金融、医疗等对数据隐私要求极高的场景。例如，其与英特尔 VT 技术结合，实现了网络、I/O 和内存的硬件级隔离</p>
</li>
<li>
<p><strong>gVisor</strong></p>
<p><strong>特点</strong>：通过用户空间实现的“沙箱内核”（Sentry）拦截容器系统调用，减少了攻击面。其内核功能由 Go 语言实现，内存安全特性降低了漏洞风险，且无需依赖硬件虚拟化技术，资源消耗低于传统虚拟机</p>
</li>
</ol>
<h3 id="与kubernetes协作">与Kubernetes协作</h3>
<p>Kubernetes通过<strong>容器运行时接口（CRI）</strong>统一管理不同运行时，典型流程如下：</p>
<ol>
<li><strong>kubelet</strong>接收Pod创建请求，通过CRI接口调用高层运行时（如containerd）。</li>
<li><strong>高层运行时</strong>拉取镜像并解压为rootfs，生成容器配置（config.json）。</li>
<li><strong>低层运行时</strong>（如runc）根据配置启动容器进程，设置Namespace和Cgroups。</li>
<li><strong>安全沙箱运行时</strong>（如Kata）通过虚拟化层隔离容器，提供额外安全保护。</li>
</ol>
<h3 id="运行时总结">运行时总结</h3>
<table>
<thead>
<tr>
<th style="text-align: center"><strong>运行时类型</strong></th>
<th style="text-align: center"><strong>代表工具</strong></th>
<th style="text-align: center"><strong>优势</strong></th>
<th style="text-align: center"><strong>局限性</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">高层运行时</td>
<td style="text-align: center">Docker</td>
<td style="text-align: center">轻量、功能丰富</td>
<td style="text-align: center">性能较低，安全性风险</td>
</tr>
<tr>
<td style="text-align: center">高层运行时</td>
<td style="text-align: center">Containerd</td>
<td style="text-align: center">轻量、高性能、Kubernetes原生支持</td>
<td style="text-align: center">功能相对基础，需搭配其他工具</td>
</tr>
<tr>
<td style="text-align: center">高层运行时</td>
<td style="text-align: center">CRI-O</td>
<td style="text-align: center">专为Kubernetes优化，资源消耗低</td>
<td style="text-align: center">社区生态较新，生产实践较少</td>
</tr>
<tr>
<td style="text-align: center">低层运行时</td>
<td style="text-align: center">runc</td>
<td style="text-align: center">启动快、资源占用低</td>
<td style="text-align: center">共享内核，隔离性弱</td>
</tr>
<tr>
<td style="text-align: center">低层运行时</td>
<td style="text-align: center">runv（Kata）</td>
<td style="text-align: center">强隔离（虚拟机级）</td>
<td style="text-align: center">启动速度慢，资源消耗高</td>
</tr>
<tr>
<td style="text-align: center">低层运行时</td>
<td style="text-align: center">runsc（gVisor）</td>
<td style="text-align: center">沙箱化安全，轻量</td>
<td style="text-align: center">系统调用兼容性有限</td>
</tr>
</tbody>
</table>
<h1 id="容器运行时应用">容器运行时应用</h1>
<p>上文介绍完概念，那么这些个底层运行时如何在生产中与高层运行时配合使用呢？</p>
<p>下文以docker、containerd、gVisor、Kata为例来演示，以及和kubernetes的配置使用。</p>
<h2 id="运行时部署">运行时部署</h2>
<p>本示例中所有部署均采取二进制方式来演示。</p>
<h3 id="系统环境及组件版本介绍">系统环境及组件版本介绍</h3>
<h4 id="系统环境">系统环境</h4>
<pre><code class="language-bash"># nkvers 
############## Kylin Linux Version #################
Release:
Kylin Linux Advanced Server Release V10 (Trading)

Kernel:
4.19.90-89.15.v2401.ky10.x86_64

Build:
Kylin Linux Advanced Server
Release V10 SP3 2403/(Trading)-x86_64-Build03/20240813
#################################################
</code></pre>
<h4 id="组件版本介绍">组件版本介绍</h4>
<table>
<thead>
<tr>
<th style="text-align: center">服务名称</th>
<th style="text-align: center">版本</th>
<th style="text-align: center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">Docker</td>
<td style="text-align: center">27.5.1</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">Containerd</td>
<td style="text-align: center">1.7.25</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">runsc</td>
<td style="text-align: center">release-20250331.0</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">containerd-shim-runsc-v1</td>
<td style="text-align: center">1.6.36</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">kata-runtime</td>
<td style="text-align: center">3.1.3</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">containerd-shim-kata-v2</td>
<td style="text-align: center">1.6.8</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">Kubernetes</td>
<td style="text-align: center">1.33.0</td>
<td style="text-align: center"></td>
</tr>
</tbody>
</table>
<h3 id="containerd运行时部署">containerd运行时部署</h3>
<p>二进制包下载地址：<a href="https://github.com/containerd/containerd/releases" target="_blank" rel="noopener nofollow">https://github.com/containerd/containerd/releases</a></p>
<h4 id="下载安装">下载安装</h4>
<pre><code class="language-bash">wget https://github.com/containerd/containerd/releases/download/v2.0.4/containerd-2.0.4-linux-amd64.tar.gz
tar xf containerd-2.0.4-linux-amd64.tar.gz &amp;&amp; mv ./bin/* /usr/bin/
</code></pre>
<h4 id="配置systemd">配置systemd</h4>
<p>vim /etc/systemd/system/containerd.service</p>
<pre><code class="language-bash">[Unit]
Description=Containerd Container Runtime
Documentation=https://containerd.io
After=network.target local-fs.target

[Service]
ExecStartPre=-/sbin/modprobe overlay
ExecStart=/usr/bin/containerd
Delegate=yes
KillMode=process
Restart=always
RestartSec=5
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity                                                                                                            
TasksMax=infinity

[Install]
WantedBy=multi-user.target
</code></pre>
<pre><code class="language-bash">systemctl daemon-reload
# 启动并设置开机自启
systemctl enable --now containerd.service
</code></pre>
<h3 id="docker运行时部署">docker运行时部署</h3>
<p>二进制包下载地址：<a href="https://download.docker.com/linux/static/stable/x86_64/" target="_blank" rel="noopener nofollow">https://download.docker.com/linux/static/stable/x86_64/</a></p>
<h4 id="下载安装-1">下载安装</h4>
<pre><code class="language-bash">wget https://download.docker.com/linux/static/stable/x86_64/docker-27.5.1.tgz
tar xf docker-27.5.1.tgz
# 这里除去containerd  containerd-shim-runc-v2  ctr三个containerd的文件，其他均mv至/usr/bin/下即可
cd docker &amp;&amp; mv docker* runc /usr/bin/
</code></pre>
<h4 id="配置systemd-1">配置systemd</h4>
<p>vim /etc/systemd/system/docker.service</p>
<pre><code class="language-bash">[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target firewalld.service
Wants=network-online.target

[Service]
Type=notify
ExecStart=/usr/bin/dockerd --containerd=/run/containerd/containerd.sock
ExecReload=/bin/kill -s HUP $MAINPID
TimeoutStartSec=0
Restart=on-failure
StartLimitBurst=3
StartLimitInterval=60s
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
TasksMax=infinity
Delegate=yes
KillMode=process

[Install]
WantedBy=multi-user.target
</code></pre>
<blockquote>
<p>--containerd=/run/containerd/containerd.sock，指定containerd sock路径，因为直接复用了上一步自己部署的containerd，并没有使用docker包中自带的containerd服务，所以需要加此配置，这也验证了docker是要调用containerd来实现自己的功能的。</p>
</blockquote>
<pre><code class="language-bash">systemctl daemon-reload
# 启动并设置开机自启
systemctl enable --now docker.service
</code></pre>
<h3 id="runsc-gvisor运行时配置">runsc-gVisor运行时配置</h3>
<p>官方部署文档：<a href="https://gvisor.dev/docs/user_guide/install/" target="_blank" rel="noopener nofollow">https://gvisor.dev/docs/user_guide/install/</a></p>
<h4 id="下载安装-2">下载安装</h4>
<p>vim install_gvisor.sh</p>
<pre><code class="language-bash">(
  set -e
  ARCH=$(uname -m)
  URL=https://storage.googleapis.com/gvisor/releases/release/latest/${ARCH}
  wget ${URL}/runsc ${URL}/runsc.sha512 \
    ${URL}/containerd-shim-runsc-v1 ${URL}/containerd-shim-runsc-v1.sha512
  sha512sum -c runsc.sha512 \
    -c containerd-shim-runsc-v1.sha512
  rm -f *.sha512
  chmod a+rx runsc containerd-shim-runsc-v1
  sudo mv runsc containerd-shim-runsc-v1 /usr/local/bin
)
</code></pre>
<p>保存执行</p>
<pre><code class="language-bash">chmod +x install_gvisor.sh &amp;&amp; ./install_gvisor.sh
</code></pre>
<h3 id="kata-containers运行时部署">kata-containers运行时部署</h3>
<p>二进制包下载地址：<a href="https://github.com/kata-containers/kata-containers/releases" target="_blank" rel="noopener nofollow">https://github.com/kata-containers/kata-containers/releases</a></p>
<h4 id="下载安装-3">下载安装</h4>
<p>目前kata-containers最新版本为3.15.0，由于银河麒麟v10的自带glibc版本=2.28版本，新版本的kata需要glibc&gt;2.34版本，银河麒麟升级glibc是一个较麻烦的动作，故此安装非最新版本。</p>
<p>kata-containers v3.12.0即可满足glibc的版本问题，但安装<strong>kata-static-3.12.0</strong>后，虽然检查运行环境能够通过，但在实际使用containerd创建kata运行时容器时，却一直报连接超时的问题，containerd及kata详细报错如下：</p>
<pre><code class="language-bash">level=info arch=amd64 arguments="\"features\"" commit=39bf10875b4f321d05e6e6a97bd5f0e62ad37993 name=kata-runtime pid=1048 source=runtime version=3.12.0
level=error msg="Invalid command \"features\"" arch=amd64 name=kata-runtime pid=1048 source=runtime
level=info msg="loaded configuration" arch=amd64 file=/opt/kata/share/defaults/kata-containers/configuration-qemu.toml format=TOML name=kata-runtime pid=2129 source=katautils
level=info msg="IOMMUPlatform is disabled by default." arch=amd64 name=kata-runtime pid=2129 source=katautils
level=info arch=amd64 arguments="\"features\"" commit=39bf10875b4f321d05e6e6a97bd5f0e62ad37993 name=kata-runtime pid=2129 source=runtime version=3.12.0
level=error msg="Invalid command \"features\"" arch=amd64 name=kata-runtime pid=2129 source=runtime
level=warning msg="Could not add /dev/mshv to the devices cgroup" name=containerd-shim-v2 pid=2674 sandbox=hello-wrold source=cgroups
level=error msg="qemu-system-x86_64: -chardev socket,id=char-33b63cf7ea0559ba,path=/run/vc/vm/hello-wrold/vhost-fs.sock: Failed to connect to '/run/vc/vm/hello-wrold/vhost-fs.sock': Connection refused" name=containerd-shim-v2 pid=2674 qemuPid=2688 sandbox=hello-wrold source=virtcontainers/hypervisor subsystem=qemu
</code></pre>
<p>通过查看GitHub issue发现，出现此报错大概率是qemu-system-x86_64和virtiofsd的版本太高，不适配导致的，具体版本如下：</p>
<pre><code class="language-bash"># ./qemu-system-x86_64 -version 
QEMU emulator version 9.1.2 (kata-static)
Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers

# ./virtiofsd -V
virtiofsd 1.8.0
</code></pre>
<p>所以最终安装<strong>kata-static-3.1.3</strong>版本：</p>
<pre><code class="language-bash">wget https://github.com/kata-containers/kata-containers/releases/download/3.1.3/kata-static-3.1.3-x86_64.tar.xz
tar xf kata-static-3.1.3-x86_64.tar.xz &amp;&amp; mv ./opt/kata /opt/
</code></pre>
<h4 id="检查运行环境">检查运行环境</h4>
<pre><code class="language-bash"># /opt/kata/bin/kata-runtime check
WARN[0000] Not running network checks as super user      arch=amd64 name=kata-runtime pid=1673 source=runtime                 
System is capable of running Kata Containers                                                                                  
System can currently create Kata Containers  
</code></pre>
<p>若报错类似以下信息：</p>
<pre><code class="language-bash"># kata-runtime check                                                                                
WARN[0000] Not running network checks as super user      arch=amd64 name=kata-runtime pid=3133 source=runtime                 
ERRO[0000] CPU property not found                        arch=amd64 description="Virtualization support" name=svm pid=3133 sou
rce=runtime type=flag                                                                                                         
WARN[0000] modprobe insert module failed                 arch=amd64 error="exit status 1" module=kvm_amd name=kata-runtime out
put="modprobe: ERROR: could not insert 'kvm_amd': Operation not supported\n" pid=3133 source=runtime                          
ERRO[0000] kernel property kvm_amd not found             arch=amd64 description="AMD KVM" name=kvm_amd pid=3133 source=runtime
 type=module                                                                                                                  
ERRO[0000] ERROR: System is not capable of running Kata Containers  arch=amd64 name=kata-runtime pid=3133 source=runtime      
ERROR: System is not capable of running Kata Containers 
</code></pre>
<p>需要打开硬件虚拟化功能，我这里是Virtual Box，执行以下操作即可：</p>
<p>关闭虚拟机，打开硬件虚拟化功能：</p>
<p><img src="/home/kylinos/.config/Typora/typora-user-images/image-20250408143346554.png" alt="image-20250408143346554" loading="lazy"></p>
<p>VMware也是一样的操作，在设置中配置即可。</p>
<h4 id="配置环境变量">配置环境变量</h4>
<p>vim ~/.bashrc</p>
<pre><code class="language-bash">export KATA_PATH=/opt/kata/bin/:/opt/kata/libexec/                                                                            
export PATH=$PATH:$KATA_PATH
</code></pre>
<blockquote>
<p>追加以上信息</p>
</blockquote>
<pre><code class="language-bash">source ~/.bashrc
</code></pre>
<h4 id="配置软连接">配置软连接</h4>
<pre><code class="language-bash"># ln -sv /opt/kata/bin/kata-runtime /usr/local/bin/
'/usr/local/bin/kata-runtime' -&gt; '/opt/kata/bin/kata-runtime'

# ln -sv /opt/kata/bin/containerd-shim-kata-v2 /usr/local/bin/
'/usr/local/bin/containerd-shim-kata-v2' -&gt; '/opt/kata/bin/containerd-shim-kata-v2'
</code></pre>
<blockquote>
<p>这一步是因为后续使用--runtime io.containerd.kata.v2指定runtime时需要</p>
</blockquote>
<p>至此，四种运行时均已部署完毕，k8s部署过程此文档不再赘述，可参考之前的<a href="https://www.cnblogs.com/v-fan/p/14676879.html" target="_blank">博文</a>，或者直接参考官网<a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/" target="_blank" rel="noopener nofollow">部署文档</a>进行部署。</p>
<p>下文开始配合使用底层、高层运行时。</p>
<h2 id="运行时的应用">运行时的应用</h2>
<h3 id="docker配置runsc和kata运行时">docker配置runsc和kata运行时</h3>
<h4 id="配置docker识别runsc运行时">配置docker识别runsc运行时</h4>
<pre><code class="language-bash">/usr/local/bin/runsc install
</code></pre>
<p>执行完毕后，/etc/docker/daemon.json会生成以下配置：</p>
<pre><code class="language-bash">    "runtimes": {
        "runsc": {
            "path": "/usr/local/bin/runsc"
        }
    }
</code></pre>
<p>重新加载docker：</p>
<pre><code class="language-bash"> systemctl reload docker
</code></pre>
<p>查看是否识别runsc：</p>
<pre><code class="language-bash"># docker info | grep Runtimes
 Runtimes: io.containerd.runc.v2 runc runsc
</code></pre>
<h4 id="配置docker识别kata运行时">配置docker识别kata运行时</h4>
<p>vim /etc/docker/daemon.json</p>
<pre><code class="language-bash">    "runtimes": {
        "runsc": {
            "path": "/usr/local/bin/runsc"
        },
        "kata-runtime": {
            "path": "/opt/kata/bin/kata-runtime"
        }
    }
</code></pre>
<p>重新加载docker：</p>
<pre><code class="language-bash">systemctl reload docker.service
</code></pre>
<p>查看是否识别kata：</p>
<pre><code class="language-bash"># docker info | grep Runtimes
 Runtimes: io.containerd.runc.v2 kata-runtime runc runsc
</code></pre>
<h4 id="为docker临时指定低层运行时运行容器">为docker临时指定低层运行时运行容器</h4>
<pre><code class="language-bash"># 临时使用runsc启动容器
docker run -dit --rm --name test-runsc --runtime=runsc nginx

# 临时使用kata启动容器
docker run -dit --rm --name=test-kata --runtime=kata-runtime nginx
</code></pre>
<p>查看容器Runtime：</p>
<pre><code class="language-bash"># docker inspect test-runsc | grep Runtime 
            "Runtime": "runsc",

# docker inspect test-kata | grep Runtime 
            "Runtime": "kata-runtime",
</code></pre>
<p>但是在基于kata运行时创建容器时，出现了以下报错：</p>
<pre><code class="language-bash"># docker run -dit --rm --name=test-kata --runtime=kata-runtime nginx
db6e291450f6c57519b8e87f179a63dd0760d9d07ced84ec2c540f96595a0b91
docker: Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: Invalid command "create": unknown.
</code></pre>
<p>通过GitHub的issue排查到，报次错的问题大概率为kata的docker不兼容的问题导致的，参考链接：</p>
<pre><code class="language-markdown">https://github.com/kata-containers/runtime/issues/3038
https://github.com/kata-containers/kata-containers/issues/10223
</code></pre>
<p>但是这个issue提及的是kata2.x版本，本文已经在使用kata3.x版本。</p>
<p>我已经在issue末尾跟评了，暂时还没有收到回复，所以是什么原因导致的，暂时不得而知。</p>
<h4 id="为docker指定默认低层运行时">为docker指定默认低层运行时</h4>
<p>vim /etc/docker/daemon.json</p>
<pre><code class="language-bash">    "runtimes": {
        "runsc": {
            "path": "/usr/local/bin/runsc"
        },
        "kata-runtime": {
            "path": "/opt/kata/bin/kata-runtime"
        }
    },
    "default-runtime": "runsc"  //默认运行时配置
</code></pre>
<p>重新加载配置，查看结果：</p>
<pre><code class="language-bash"># systemctl reload docker.service 
# docker info | grep Runtime 
 Runtimes: io.containerd.runc.v2 kata-runtime runc runsc
 Default Runtime: runsc
</code></pre>
<h3 id="containerd配置runsc和kata运行时">containerd配置runsc和kata运行时</h3>
<h4 id="安装配置crictlnerctl">安装配置crictl/nerctl</h4>
<p>官网地址：<a href="https://github.com/containerd/containerd/blob/main/docs/getting-started.md#interacting-with-containerd-via-cli" target="_blank" rel="noopener nofollow">https://github.com/containerd/containerd/blob/main/docs/getting-started.md#interacting-with-containerd-via-cli</a></p>
<pre><code class="language-bash">wget https://github.com/containerd/nerdctl/releases/download/v2.0.4/nerdctl-2.0.4-linux-amd64.tar.gz
tar xf nerdctl-2.0.4-linux-amd64.tar.gz -C /usr/local/bin/
</code></pre>
<pre><code class="language-bash">wget https://github.com/kubernetes-sigs/cri-tools/releases/download/v1.32.0/crictl-v1.32.0-linux-amd64.tar.gz
tar xf crictl-v1.32.0-linux-amd64.tar.gz -C /usr/local/bin/

cat &gt;/etc/crictl.yaml &lt;&lt;EOF
untime-endpoint: unix:///run/containerd/containerd.sock
image-endpoint: unix:///run/containerd/containerd.sock
timeout: 10
debug: true
pull-image-on-create: false
EOF
</code></pre>
<p>添加补全：</p>
<pre><code class="language-bash">echo 'source &lt;(nerdctl completion bash)' &gt;&gt; /etc/bashrc
echo 'source &lt;(crictl completion bash)' &gt;&gt; /etc/bashrc
nerdctl completion bash
crictl completion bash
source /etc/bashrc
</code></pre>
<h4 id="配置containerd识别runsckata运行时">配置containerd识别runsc、kata运行时</h4>
<p><strong>gVisor官方文档：</strong><a href="https://gvisor.dev/docs/user_guide/containerd/quick_start/" target="_blank" rel="noopener nofollow">https://gvisor.dev/docs/user_guide/containerd/quick_start/</a></p>
<p><strong>kata官方文档</strong>：<a href="https://github.com/kata-containers/kata-containers/blob/main/docs/how-to/containerd-kata.md#configuration" target="_blank" rel="noopener nofollow">https://github.com/kata-containers/kata-containers/blob/main/docs/how-to/containerd-kata.md#configuration</a></p>
<p>生成containerd配置文件：</p>
<pre><code class="language-bash">mkdir /etc/containerd/
containerd config default &gt; /etc/containerd/config.toml
</code></pre>
<p>修改config.toml，如果<strong>containerd版本&gt;2.0</strong>则应该是：</p>
<p>vim /etc/containerd/config.toml</p>
<pre><code class="language-bash">    [plugins.'io.containerd.cri.v1.runtime'.containerd]
# 默认runtime
      default_runtime_name = 'runc'
# runc
      [plugins.'io.containerd.cri.v1.runtime'.containerd.runtimes]
        [plugins.'io.containerd.cri.v1.runtime'.containerd.runtimes.runc]
          runtime_type = 'io.containerd.runc.v2'
          sandboxer = 'podsandbox'
          io_type = ''

          [plugins.'io.containerd.cri.v1.runtime'.containerd.runtimes.runc.options]
            BinaryName = ''
# kata-runtime
        [plugins.'io.containerd.cri.v1.runtime'.containerd.runtimes.kata-runtime]
          runtime_type = "io.containerd.kata.v2"
          [plugins.'io.containerd.cri.v1.runtime'.containerd.runtimes.kata-runtime.options]
            BinaryName = "/opt/kata/bin/containerd-shim-kata-v2"
# runsc
        [plugins.'io.containerd.cri.v1.runtime'.containerd.runtimes.runsc]
          runtime_type = "io.containerd.runsc.v1"
          [plugins.'io.containerd.cri.v1.runtime'.containerd.runtimes.runsc.options]
            BinaryName = "/usr/local/bin/runsc"
</code></pre>
<p>如果是<strong>containerd&lt;2.0</strong>则为：</p>
<p>vim /etc/containerd/config.toml</p>
<pre><code class="language-bash">    [plugins."io.containerd.grpc.v1.cri".containerd]
# 默认运行时
      default_runtime_name = "runc"

      [plugins."io.containerd.grpc.v1.cri".containerd.runtimes]
# runc
        [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
          runtime_type = "io.containerd.runc.v2"

          [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
            BinaryName = ""
# runsc
        [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runsc]
          runtime_type = "io.containerd.runsc.v1"
          [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runsc.options]
            BinaryName = "/usr/local/bin/runsc"
# kata-runtime
        [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.kata-runtime]
          runtime_type = "io.containerd.kata.v2"
          [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.kata-runtime.options]
            BinaryName = "/opt/kata/bin/containerd-shim-kata-v2"
</code></pre>
<p>配置完毕，重启containerd：</p>
<pre><code class="language-bash">systemctl restart containerd.service 
</code></pre>
<p>验证是否加载运行时：</p>
<pre><code class="language-bash"># crictl info 
     "runtimes": {
        "kata": {
          "options": {
            "BinaryName": "/opt/kata/bin/containerd-shim-kata-v2"
          },
          "runtimeType": "io.containerd.kata.v2",
          "sandboxMode": "podsandbox",
          "snapshotter": ""
        },
        "runc": {
          "ContainerAnnotations": [],
          },
        },
        "runsc": {
          "options": {
            "BinaryName": "/usr/local/bin/runsc"
          },
        }
</code></pre>
<h4 id="为containerd指定低层运行时运行容器">为containerd指定低层运行时运行容器</h4>
<p><strong>修改默认运行时：</strong></p>
<p>vim  /etc/containerd/config.toml</p>
<pre><code class="language-bash">    [plugins.'io.containerd.cri.v1.runtime'.containerd]
      default_runtime_name = 'runsc'
</code></pre>
<pre><code class="language-bash">systemctl restart containerd.service 
</code></pre>
<p><strong>临时指定并运行：</strong></p>
<p>runsc：</p>
<pre><code class="language-bash">ctr i pull docker.io/library/nginx:latest
ctr run --runtime io.containerd.runsc.v1 -t --rm docker.io/library/nginx:latest nginx-runsc
</code></pre>
<p>kata-runtime：</p>
<pre><code class="language-bash">ctr run --runtime io.containerd.kata.v2 -t --rm docker.io/library/nginx:latest nginx-kata
</code></pre>
<p><strong>查看容器runtime：</strong></p>
<pre><code class="language-bash"># ctr c ls 
CONTAINER      IMAGE                             RUNTIME                   
nginx-kata     docker.io/library/nginx:latest    io.containerd.kata.v2     
nginx-runsc    docker.io/library/nginx:latest    io.containerd.runsc.v1
</code></pre>
<p><strong>内核对比：</strong></p>
<pre><code class="language-bash"># nerdctl exec -it nginx-kata uname -r 
5.19.2
# nerdctl exec -it nginx-runsc uname -r 
4.4.0

## 宿主机内核
# uname -r 
4.19.90-89.15.v2401.ky10.x86_64
</code></pre>
<h3 id="kubernetes配置runsc和kata运行时">Kubernetes配置runsc和kata运行时</h3>
<p><strong>gVisor官方文档：</strong><a href="https://gvisor.dev/docs/user_guide/containerd/quick_start/" target="_blank" rel="noopener nofollow">https://gvisor.dev/docs/user_guide/containerd/quick_start/</a></p>
<p><strong>kata官方文档：</strong><a href="https://github.com/kata-containers/kata-containers/blob/main/docs/how-to/how-to-use-k8s-with-containerd-and-kata.md" target="_blank" rel="noopener nofollow">https://github.com/kata-containers/kata-containers/blob/main/docs/how-to/how-to-use-k8s-with-containerd-and-kata.md</a></p>
<p>本文档不再演示k8s部署过程，可参考博主其他博文或直接参考k8s官方文档进行部署。</p>
<p>在使用k8s创建runsc和kata容器时，前提条件是containerd已经配置好runsc和kata的runtime，也就是以上<code>containerd配置runsc和kata运行时</code>的步骤。</p>
<h4 id="配置kubelet-以使用-containerd">配置Kubelet 以使用 containerd</h4>
<p>在kubernetes v1.24之后，默认的运行时就是containerd，可以再次检查一遍，如不是，需修改。</p>
<pre><code class="language-bash"># sudo mkdir -p  /etc/systemd/system/kubelet.service.d/
# cat &lt;&lt; EOF | sudo tee  /etc/systemd/system/kubelet.service.d/0-containerd.conf
[Service]                                                 
Environment="KUBELET_EXTRA_ARGS=--container-runtime=remote --runtime-request-timeout=15m --container-runtime-endpoint=unix:///run/containerd/containerd.sock"
EOF
</code></pre>
<p>如修改，需重新加载：</p>
<pre><code class="language-bash"># sudo systemctl daemon-reload
</code></pre>
<h4 id="配置http代理可选">配置HTTP代理（可选）</h4>
<p>如果使用代理，请使用以下脚本为 docker、Kubelet 和 containerd 配置代理：</p>
<pre><code class="language-bash"># 配置环境变量
services="
kubelet
containerd
docker
"

# 编辑配置文件
for service in ${services}; do

    service_dir="/etc/systemd/system/${service}.service.d/"
    sudo mkdir -p ${service_dir}

    cat &lt;&lt; EOF | sudo tee "${service_dir}/proxy.conf"
[Service]
Environment="HTTP_PROXY=${http_proxy}"
Environment="HTTPS_PROXY=${https_proxy}"
Environment="NO_PROXY=${no_proxy}"
EOF
done

# 重新加载systemd
systemctl daemon-reload
</code></pre>
<h4 id="配置runtimeclass">配置RuntimeClass</h4>
<p>默认情况下，所有 Pod 都使用 containerd 中配置的默认运行时创建。从 Kubernetes v1.12 开始，用户可以使用RuntimeClass。</p>
<p>runsc：</p>
<pre><code class="language-bash">cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: gvisor
handler: runsc
EOF
</code></pre>
<p>kata：</p>
<pre><code class="language-bash">cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: kata
handler: kata-runtime
EOF
</code></pre>
<p>查看RuntimeClass：</p>
<pre><code class="language-bash">kubectl get RuntimeClass
</code></pre>
<h4 id="指定runtimeclass创建pod">指定RuntimeClass创建Pod</h4>
<p>runsc：</p>
<pre><code class="language-bash">cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: nginx-gvisor
spec:
  # 指定运行时
  runtimeClassName: gvisor
  containers:
  - name: nginx
    image: nginx
EOF
</code></pre>
<p>kata：</p>
<pre><code class="language-bash">cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: nginx-gvisor
spec:
  # 指定运行时
  runtimeClassName: kata
  containers:
  - name: nginx
    image: nginx
EOF
</code></pre>
<h4 id="检查-pod-是否正在运行">检查 Pod 是否正在运行</h4>
<pre><code class="language-bash"># kubectl get pods
# ctr c ls
</code></pre>
<h1 id="结语">结语</h1>
<p>以上就是对常用的高层、底层运行时的介绍以及基于银河麒麟操作系统的操作演示，容器技术和国产操作系统都在如火如荼的发展，两者不可避免的会擦起火花，尽管国内信创行业正在高速的发展，但是无可避免的会出现很多使用问题。遇到问题，面对问题，解决问题，这也是我们每个技术人“享受”的过程。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.34971081375347224" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-23 17:59">2025-04-23 17:58</span>&nbsp;
<a href="https://www.cnblogs.com/v-fan">塔克拉玛攻城狮</a>&nbsp;
阅读(<span id="post_view_count">14</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18843188);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18843188', targetLink: 'https://www.cnblogs.com/v-fan/p/18843188', title: '一文详解银河麒麟配置容器运行时及gVisor(runsc)、Kata(runv)详细指南' })">举报</a>
</div>
        