
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/javadaydayup/p/19054021" title="发布于 2025-08-23 09:24">
    <span role="heading" aria-level="2">Spring把「手动」的复杂裹成了「自动」的温柔</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1878162/202508/1878162-20250823092427294-1463545668.png" alt="Spring把「手动」的复杂裹成了「自动」的温柔" class="desc_img">
        想知道是怎么Spring把「手动」的复杂裹成了「自动」的温柔么?本文将带你从源码角度分析Spring是如何实现自动配置某些类的。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="案例">案例</h2>
<p><strong>案例一：@EnableXXX注解使用</strong><br>
在一个 Spring MVC 项目，通过给配置类加上一个 <code>@EnableWebMvc</code> 注解，加上之后 Spring 就会注册 Spring MVC 的一系列组件，包括：HandlerMapping，HandlerAdapter，ViewResolver 等。</p>
<p><strong>案例二：Spring Boot自动配置</strong><br>
在一个 Spring Boot应用中会有 <code>@SpringBootApplication</code> 注解修饰启动类，当引入 spring-boot-starter-web 依赖之后，Spring 也会自动地注册 Spring MVC 的一系列组件。</p>
<p>那 Spring 中是如何实现自动注册的能力的呢？先说结论：<br>
Spring 中提供了 <code>@Import</code> 注解可以引入一个配置类或者是配置类的选择器。</p>
<p>当使用一般的 <code>@EnableXXX</code> 注解时实际上是通过 <code>@Import</code> 注解引入了预先定义好的配置类，它会配置一些指定的 Bean 来实现对应的功能。</p>
<p>当使用 Spring Boot 的自动配置功能时实际上是通过 <code>@Import</code> 注解引入了一个配置类的选择器，它会读取配置文件中配置的所有配置类，然后判断该配置类的条件是否满足，如果满足，则引入，否则，则不引入，从而实现自动配置某些功能。</p>
<h2 id="源码分析">源码分析</h2>
<h3 id="enablexxx注解实现原理">@EnableXXX注解实现原理</h3>
<p>先看一下 <code>@EnableWebMvc</code> 注解，该注解上通过 <code>@Import</code> 注解引用了一个 <code>DelegatingWebMvcConfiguration</code> 配置类，它上面有 <code>@Configuration</code> 注解修饰。代码如下：</p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc {
}

@Configuration(proxyBeanMethods = false)  
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
}
</code></pre>
<p>在 <code>DelegatingWebMvcConfiguration</code> 这个配置类的父类 <code>WebMvcConfigurationSupport</code> 中定义了很多由 <code>@Bean</code> 注解修饰的方法，这些就是 Spring 会注册的 Spring MVC 组件类。代码如下：</p>
<pre><code class="language-java">public class WebMvcConfigurationSupport implements ApplicationContextAware, ServletContextAware {
    // 定义HandlerMapping组件Bean
    @Bean
    @SuppressWarnings("deprecation")
    public RequestMappingHandlerMapping requestMappingHandlerMapping(
            @Qualifier("mvcContentNegotiationManager") ContentNegotiationManager contentNegotiationManager,
            @Qualifier("mvcConversionService") FormattingConversionService conversionService,
            @Qualifier("mvcResourceUrlProvider") ResourceUrlProvider resourceUrlProvider) {

        // 省略代码
    }

    // 定义HandlerAdapter组件Bean
    @Bean
    public RequestMappingHandlerAdapter requestMappingHandlerAdapter(
            @Qualifier("mvcContentNegotiationManager") ContentNegotiationManager contentNegotiationManager,
            @Qualifier("mvcConversionService") FormattingConversionService conversionService,
            @Qualifier("mvcValidator") Validator validator) {

        // 省略代码
    }

    // 定义ViewResolver组件Bean
    @Bean
    public ViewResolver mvcViewResolver(
            @Qualifier("mvcContentNegotiationManager") ContentNegotiationManager contentNegotiationManager) {
        
        // 省略代码
    }
}
</code></pre>
<p>在<a href="https://mp.weixin.qq.com/s/dYv_MJ5NuTTz2izpLp_u1A" target="_blank" rel="noopener nofollow">3 个案例看透 Spring @Component 扫描：从普通应用到 Spring Boot</a>文章中介绍了 Spring 中如何从 <code>@Configuration</code> 注解修饰的配置类的包扫描路径取扫描 Bean 的。主要是在<code>ConfigurationClassParser</code>&nbsp;的&nbsp;<code>doProcessConfigurationClass()</code>&nbsp;方法中实现的，而对 <code>@Import</code> 注解引用的类也是在该方法中实现的。代码如下：</p>
<pre><code class="language-java">@Nullable
protected final SourceClass doProcessConfigurationClass(
    ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)
    throws IOException {

    // 省略代码

	// 这里处理@Import注解
    // Process any @Import annotations
    processImports(configClass, sourceClass, getImports(sourceClass), filter, true);

    // 省略代码

	// 这里处理@Bean注解修饰的方法
    // Process individual @Bean methods
    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
    for (MethodMetadata methodMetadata : beanMethods) {
        if (methodMetadata.isAnnotated("kotlin.jvm.JvmStatic") &amp;&amp; !methodMetadata.isStatic()) {
            continue;
        }
        // 添加到配置类中
        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
    }

    // 省略代码

    // No superclass -&gt; processing is complete
    return null;
}
</code></pre>
<p>在处理 <code>@Import</code> 注解引用的且是 <code>@Configuration</code> 注解修饰的类时，把它当作配置类，递归调用解析配置类的方法 <code>processConfigurationClass()</code>，然后又进入到 <code>doProcessConfigurationClass()</code> 中，解析该类上 <code>@Bean</code> 注解修饰的方法添加到配置类中 。代码如下：</p>
<pre><code class="language-java">private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
    Collection&lt;SourceClass&gt; importCandidates, Predicate&lt;String&gt; filter, boolean checkForCircularImports) {
    // 省略代码

    if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) {
        // 省略代码
    }
    else {
        this.importStack.push(configClass);
        try {
            for (SourceClass candidate : importCandidates) {
				// 省略代码

                // 处理@Configuration注解修饰的类，就是去把它当作配置类继续解析它的配置
                this.importStack.registerImport(
                            currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
                processConfigurationClass(candidate.asConfigClass(configClass), filter);
            }
        } finally {
            this.importStack.pop();
        }
    }
}
</code></pre>
<p>具体把配置类中的 Bean 方法解析为 Bean 定义则是在 <code>ConfigurationClassPostProcessor</code> 的 <code>processConfigBeanDefinitions()</code> 中调用 <code>ConfigurationClassBeanDefinitionReader</code> 的 <code>loadBeanDefinitionsForBeanMethod()</code> 方法实现的。代码如下：</p>
<pre><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
    // 省略代码

    // Parse each @Configuration class
    ConfigurationClassParser parser = new ConfigurationClassParser(
            this.metadataReaderFactory, this.problemReporter, this.environment,
            this.resourceLoader, this.componentScanBeanNameGenerator, registry);

    Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
    Set&lt;ConfigurationClass&gt; alreadyParsed = CollectionUtils.newHashSet(configCandidates.size());
    do {
	    // 省略代码
        parser.parse(candidates);
        parser.validate();

		// 省略代码

        // 这里调用loadBeanDefinitionsForBeanMethod()解析并注册Bean定义
        this.reader.loadBeanDefinitions(configClasses);
        
        // 省略代码
    }
    while (!candidates.isEmpty());

    // 省略代码
}
</code></pre>
<p>然后在 <code>ConfigurationClassBeanDefinitionReader</code> 的 <code>loadBeanDefinitionsForBeanMethod()</code> 方法中从 <code>@Bean</code> 注解中获取 <code>initMethod</code>，<code>destroyMethod</code> 这些信息，然后注册 Bean 定义。代码如下：</p>
<pre><code class="language-java">private void loadBeanDefinitionsForConfigurationClass(
    ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {

    // 省略代码
    
    for (BeanMethod beanMethod : configClass.getBeanMethods()) {
        loadBeanDefinitionsForBeanMethod(beanMethod);
    }
    
    // 省略代码
}

private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {
    ConfigurationClass configClass = beanMethod.getConfigurationClass();
    MethodMetadata metadata = beanMethod.getMetadata();
    String methodName = metadata.getMethodName();

    // 省略代码
    ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata, beanName);

    String initMethodName = bean.getString("initMethod");
    if (StringUtils.hasText(initMethodName)) {
        beanDef.setInitMethodName(initMethodName);
    }

    String destroyMethodName = bean.getString("destroyMethod");
    beanDef.setDestroyMethodName(destroyMethodName);

	// 注册Bean定义
    this.registry.registerBeanDefinition(beanName, beanDefToRegister);
}
</code></pre>
<h3 id="spring-boot-自动配置原理">Spring Boot 自动配置原理</h3>
<p>对于一个 Spring Boot 应用上的 <code>@SpringBootApplication</code> 注解是一个组合注解，它上面有 <code>@EnableAutoConfiguration</code> 注解修饰，而这个注解则是实现自动配置的关键。代码如下：</p>
<pre><code class="language-java">@Target(ElementType.TYPE)  
@Retention(RetentionPolicy.RUNTIME)  
@Documented  
@Inherited  
@SpringBootConfiguration  
@EnableAutoConfiguration  
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),  
       @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })  
public @interface SpringBootApplication {}
</code></pre>
<p><code>@EnableAutoConfiguration</code> 注解和上面的 <code>@EnableWebMvc</code> 注解类似也是通过 <code>@Import</code> 注解引入了一个类 <code>AutoConfigurationImportSelector</code>，但是这个类却没有 <code>@Configuration</code> 注解修饰，而是实现了 <code>ImportSelector</code> 接口。代码如下：</p>
<pre><code class="language-java">@Target(ElementType.TYPE)  
@Retention(RetentionPolicy.RUNTIME)  
@Documented  
@Inherited  
@AutoConfigurationPackage  
@Import(AutoConfigurationImportSelector.class)  
public @interface EnableAutoConfiguration {}

public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware,  
       ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {}
</code></pre>
<p>在上面的 <code>ConfigurationClassParser</code> 类的 <code>processImports()</code> 方法中有一个分支就是判断 <code>@Import</code> 注解引入的类是不是 <code>DeferredImportSelector</code> 接口，如果是则会调用 <code>DeferredImportSelectorHandler</code> 的 <code>handle()</code> 方法进行处理。代码如下：</p>
<pre><code class="language-java">private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,
    Collection&lt;SourceClass&gt; importCandidates, Predicate&lt;String&gt; filter, boolean checkForCircularImports) {

    if (importCandidates.isEmpty()) {
        return;
    }

    if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) {
        this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));
    }
    else {
        this.importStack.push(configClass);
        try {
            for (SourceClass candidate : importCandidates) {
                if (selector instanceof DeferredImportSelector deferredImportSelector) {  
					    // 调用deferredImportSelectorHandler的handle()方法
					    this.deferredImportSelectorHandler.handle(configClass, deferredImportSelector);  
					}
            }
        } finally {
            this.importStack.pop();
        }
    }
}
</code></pre>
<p>而 <code>DeferredImportSelectorHandler</code> 的 <code>handle</code> 方法只是先把当前类加入到自己的 <code>deferredImportSelectors</code> 属性中。代码如下：</p>
<pre><code class="language-java">private class DeferredImportSelectorHandler {
    @Nullable
    private List&lt;DeferredImportSelectorHolder&gt; deferredImportSelectors = new ArrayList&lt;&gt;();

    void handle(ConfigurationClass configClass, DeferredImportSelector importSelector) {
        DeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(configClass, importSelector);
        if (this.deferredImportSelectors == null) {
            DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler();
            handler.register(holder);
            handler.processGroupImports();
        }
        else {
            this.deferredImportSelectors.add(holder);
        }
    }
}
</code></pre>
<p>最后在 <code>ConfigurationClassParser</code> 的 <code>parse()</code> 方法最后调用它的 <code>process()</code> 方法。在 <code>DeferredImportSelectorHandler</code> 的 <code>process()</code> 方法中又调用了 <code>DeferredImportSelectorHolder</code> 的 <code>processGroupImport()</code> 方法。代码如下：</p>
<pre><code class="language-java">public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {
    // 省略代码

    this.deferredImportSelectorHandler.process();
}

void handle(ConfigurationClass configClass, DeferredImportSelector importSelector) {
    DeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(configClass, importSelector);
    if (this.deferredImportSelectors == null) {
        DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler();
        handler.register(holder);
        handler.processGroupImports();
    }
    else {
        this.deferredImportSelectors.add(holder);
    }
}

private class DeferredImportSelectorGroupingHandler {
    @SuppressWarnings("NullAway")
    void processGroupImports() {
        for (DeferredImportSelectorGrouping grouping : this.groupings.values()) {
            Predicate&lt;String&gt; filter = grouping.getCandidateFilter();
            // 调用getImports()方法获取到配置类，然后在递归调用processImports()方法
            grouping.getImports().forEach(entry -&gt; {
                ConfigurationClass configurationClass = this.configurationClasses.get(entry.getMetadata());
                try {
                    processImports(configurationClass, asSourceClass(configurationClass, filter),
                            Collections.singleton(asSourceClass(entry.getImportClassName(), filter)),
                            filter, false);
                }
                // 省略代码
            });
        }
    }
}
</code></pre>
<p>然后调用到了 <code>AutoConfigurationGroup</code> 的 <code>process()</code> 方法，在该方法中会调用 <code>AutoConfigurationImportSelector</code> 的 <code>getAutoConfigurationEntry()</code> 方法，这个里这个类就是通过 <code>@EnableAutoConfiguration</code> 引入的类了。代码如下：</p>
<pre><code class="language-java">private static final class AutoConfigurationGroup
    implements DeferredImportSelector.Group, BeanClassLoaderAware, BeanFactoryAware, ResourceLoaderAware {
    @Override
    public void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) {
        // 省略代码
        
        // 调用AutoConfigurationImportSelector的getAutoConfigurationEntry()方法
        AutoConfigurationEntry autoConfigurationEntry = autoConfigurationImportSelector
            .getAutoConfigurationEntry(annotationMetadata);
            
        this.autoConfigurationEntries.add(autoConfigurationEntry);
        for (String importClassName : autoConfigurationEntry.getConfigurations()) {
            this.entries.putIfAbsent(importClassName, annotationMetadata);
        }
    }
}
</code></pre>
<p>在 <code>AutoConfigurationImportSelector</code> 的 <code>getAutoConfigurationEntry()</code> 方法调用 <code>ImportCandidates</code> 读取默认值为 <code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件中列举的配置类，然后过滤掉不满足条件的配置类，过滤的方式可以是判断 CLASSPATH 路径下某些类是否存在。代码如下：</p>
<pre><code class="language-java">AutoConfigurationImportSelector{
        protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
        // 省略代码
        
        // 获取所有配置类
        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);
        
        // 过滤掉不满足条件的配置类
        configurations = getConfigurationClassFilter().filter(configurations);
        fireAutoConfigurationImportEvents(configurations, exclusions);
        return new AutoConfigurationEntry(configurations, exclusions);
    }

    protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
        ImportCandidates importCandidates = ImportCandidates.load(this.autoConfigurationAnnotation,
                getBeanClassLoader());
        return configurations;
    }
}

public final class ImportCandidates implements Iterable&lt;String&gt; {

    private static final String LOCATION = "META-INF/spring/%s.imports";
    
    public static ImportCandidates load(Class&lt;?&gt; annotation, ClassLoader classLoader) {
        ClassLoader classLoaderToUse = decideClassloader(classLoader);
        // 这里就是配置类所在文件，默认是org.springframework.boot.autoconfigure.AutoConfiguration.imports
        String location = String.format(LOCATION, annotation.getName());
        Enumeration&lt;URL&gt; urls = findUrlsInClasspath(classLoaderToUse, location);
        List&lt;String&gt; importCandidates = new ArrayList&lt;&gt;();
        while (urls.hasMoreElements()) {
            URL url = urls.nextElement();
            importCandidates.addAll(readCandidateConfigurations(url));
        }
        return new ImportCandidates(importCandidates);
    }
}

</code></pre>
<p><code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件中内容如下：<br>
<img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20250822235014.png" alt="image.png" loading="lazy"></p>
<p>这里以 <code>WebMvcAutoConfiguration</code> 配置类为例，它要不被过滤掉的条件是 CLASSPATH 路径下存在 <code>Servlet</code>, <code>DispatcherServlet</code>, <code>WebMvcConfigurer</code> 这些类，即这些类存在则会解析 <code>WebMvcAutoConfiguration</code> 配置类配置的 Bean，从而实现 Spring MVC 组件的 Bean 的注册。代码如下：</p>
<pre><code class="language-java">@AutoConfiguration(after = { DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,  
       ValidationAutoConfiguration.class })  
@ConditionalOnWebApplication(type = Type.SERVLET)  
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })  
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)  
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)  
@ImportRuntimeHints(WebResourcesRuntimeHints.class)  
public class WebMvcAutoConfiguration {}
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    欢迎大家关注我的公众号【javadaydayup】
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-23 09:25">2025-08-23 09:24</span>&nbsp;
<a href="https://www.cnblogs.com/javadaydayup">javadaydayup</a>&nbsp;
阅读(<span id="post_view_count">58</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19054021);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19054021', targetLink: 'https://www.cnblogs.com/javadaydayup/p/19054021', title: 'Spring把「手动」的复杂裹成了「自动」的温柔' })">举报</a>
</div>
        