
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fiveyobody/p/19008494/go-goroutine-gmp" title="发布于 2025-07-28 10:52">
    <span role="heading" aria-level="2">Go 原理之 GMP 并发调度模型</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        Go 原理之 GMP 并发调度模型
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一go-的协程-goroutine">一、Go 的协程 goroutine</h2>
<p>go 的特性：协程（goroutine），goroutine 是 go 自己实现的、为了解决线程的性能问题，goroutine 协程是用户态的，由 go runtime 创建和销毁，没有内核消耗，线程是内核态的，与操作系统相关，创建和销毁成本较高。</p>
<p>goroutine 提高 cpu 的利用率，解决了高消耗的CPU调度，用户态的轻量级的线程，约4k</p>
<p>这也是 go 为什么性能那么好的原因，而 go 实现  goroutine 协程的原理：GMP 调度模型</p>
<h2 id="二gmp-调度模型">二、GMP 调度模型</h2>
<p><img alt="GMP 调度模型" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250728105120947-753016041.png" class="lazyload"></p>
<ul>
<li>
<p><strong>G：</strong></p>
<p>goroutine 协程，go runtime 包自己实现的一种数据结构，存储执行时唯一的内存栈信息</p>
</li>
<li>
<p><strong>P：</strong></p>
<p>processor 处理器，go runtime 包实现的调度器，主要用来并发调度 goroutine 协程的启动、执行、等待、暂停、销毁等生命周期</p>
</li>
<li>
<p><strong>M：</strong></p>
<p>thread 线程，就是我们平时理解的线程，如果你不理解什么是线程，请参考文章 <a href="https://blog.fiveyoboy.com/articles/process-thread-goroutine" target="_blank" rel="noopener nofollow">进程线程协程的概念和区别</a></p>
</li>
</ul>
<p>那么 go 的协程 goroutine 是如何实现以及调度执行的过程是什么样子的呢？</p>
<p>比如我们使用 go 开启一个协程:</p>
<pre><code class="language-go">go func(){
    // 开启协程，处理逻辑
}()
</code></pre>
<p>'go func()'经历了哪些过程</p>
<ul>
<li>
<ol>
<li>通过 'go func()' 创建一个 goroutine（数据结构，有个唯一 gid，以及内存栈信息），这里称为：G</li>
</ol>
</li>
<li>
<ol start="2">
<li>有两个存储 G 的队列（本地P队列，全局队列），新创建的 G 会优先加入本地 P 队列中，如果满了就会保存在全局队列中</li>
</ol>
</li>
<li>
<ol start="3">
<li>G 最终会通过 P 调度运行在 M 中，MP 是组合（一个M必须持有一个P，M：P=1：1）</li>
</ol>
</li>
<li>
<ol start="4">
<li>
<p>M 会从 P 的队列中弹出一个可执行的 G 来执行，如果没有，则会从全局队列中获取，</p>
<p>全局队列也没有，则会从其他 MP 队列中偷取一个 G执行，从其他 P 偷的方式称为 work stealing</p>
</li>
</ol>
</li>
<li>
<ol start="5">
<li>一个 M 调度 G 执行是一个循环过程</li>
</ol>
</li>
<li>
<ol start="6">
<li>当 M 执行 G 过程中发生 systemCall 阻塞，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除(detach)，此时 P 会和 M 解绑即 hand off，然后再创建/从休眠队列中取一个 M 来服务这个 P</li>
</ol>
<ul>
<li>
<p>系统调用（如文件IO）阻塞（同步）：阻塞MG，M与P解绑</p>
</li>
<li>
<p>网络 IO 调用阻塞（异步）：G 移动到NetPoller，M 继续执行 P 中的 G</p>
</li>
<li>
<p>mutex/chan阻塞（异步）：G 移动到 chan 的等待队列中，M 继续执行 P 中的 G</p>
</li>
</ul>
</li>
<li>
<ol start="7">
<li>当 M 系统调用结束后进入休眠/销毁状态，这个 G 会尝试获取一个空闲的 P 执行，如果没有，这个 G 会放入全局队列</li>
</ol>
</li>
</ul>
<p><img alt="GMP 调度过程" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250728105120853-1460192549.png" class="lazyload"></p>
<p><img alt="GMP 调度完整流程" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250728105119730-1404872050.png" class="lazyload"></p>
<p>M 每隔约 10ms 会切换一个 G，被切换的 G 会重新回到本地P队列</p>
<p>如果在 Goroutine 去执行一个 sleep 操作，导致 M 被阻塞了。Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以强占的标识符，别的 Goroutine 就可以抢先进来执行。</p>
<h2 id="三m0--g0-的启动">三、M0 &amp; G0 的启动</h2>
<p>go 启动的时候，默认会启动 M0 线程 和 G0 协程</p>
<p>M0：编号为 0 的主线程</p>
<p>GO：编号为 0 的主协程</p>
<p><img alt="go 的启动" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250728105120340-458885922.png" class="lazyload"></p>
<h2 id="四-协程-goroutine-的调度策略">四、 协程 goroutine 的调度策略</h2>
<ul>
<li>
<p><strong>队列轮转：</strong></p>
<p>P 会周期性的将G调度到M中执行，执行一段时间后，保存上下文，将 G 放到队列尾部，然后从队列中再取出一个G进行调度</p>
<p>除此之外，P还会周期性的查看全局队列是否有G等待调度到M中执行</p>
</li>
<li>
<p><strong>系统调度：</strong></p>
<p>当 G0 即将进入系统调用时，M0 将释放 P，进而某个空闲的 M1 获取 P，继续执行 P 队列中剩下的 G。</p>
<p>M1 的来源有可能是 M 的缓存池，也可能是新建的</p>
<p>当 G0 系统调用结束后，如果有空闲的P，则获取一个P，继续执行 G0。如果没有，则将 G0 放入全局队列，等待被其他的 P 调度。然后 M0 将进入缓存池睡眠</p>
</li>
<li>
<p><strong>抢占式调度：</strong></p>
<p>sysmon 监控协程，如果 g 运行时间过长 <code>10 ms</code>，那会发送信号给到 m，g 会被挂起，m继续执行 p 中的 g，防止其他 g 被饿死</p>
</li>
</ul>
<h2 id="五协程的生命周期">五、协程的生命周期</h2>
<p>创建、等待（调用 gopark 进入等待状态）、唤醒执行（调用 goready 唤醒等待的 g 执行）、销毁</p>
<h2 id="五gmp-的数量">五、GMP 的数量</h2>
<p>G 的初始化大小是 2-4 k，具体数量由内存决定，</p>
<p>P 的数量由用户设置的 GoMAXPROCS 决定，等于CPU的核心数，但是不论 GoMAXPROCS 设置为多大，P 的储存G的数量最大为 256</p>
<p>M 默认限制 10000</p>
<h2 id="常见问题">常见问题</h2>
<h3 id="1-golang-为什么要创建-goroutine-协程">1. Golang 为什么要创建 goroutine 协程</h3>
<p>轻量：1.大小只有 2-4 k，用户级线程，减少了内核态切换创建的开销</p>
<p>操作系统中虽然已经有了多线程、多进程来解决高并发的问题，但是在当今互联网海量高并发场景下，对性能的要求也越来越苛刻，大量的进程/线程会出现内存占用高、CPU消耗多的问题，很多服务的改造与重构也是为了降本增效。</p>
<p>一个进程可以关联多个线程，线程之间会共享进程的一些资源，比如内存地址空间、打开的文件、进程基础信息等，每个线程也都会有自己的栈以及寄存器信息等，线程相比进程更加轻量，而协程相对线程更加轻量，多个协程会关联到一个线程，协程之间会共享线程的一些信息，每个协程也会有自己的栈空间，所以也会更加轻量级。从进程到线程再到协程，其实是一个不断共享，减少切换成本的过程。</p>
<p><strong>Golang 使用协程主要有以下几个原因：</strong></p>
<p>●&nbsp;大小</p>
<p>协程大概是2-4k，线程大概是1m</p>
<p>●&nbsp;创建、切换和销毁</p>
<p>协程是用户态的，由 runtime 创建和销毁，没有内核消耗，线程是内核态的，与操作系统相关，创建和销毁成本较高</p>
<h3 id="2-什么是-csp-并发模型">2. 什么是 CSP 并发模型？</h3>
<p><strong>CSP 并发模型：不要以共享内存的方式来通信，而以通信的方式来共享内存</strong></p>
<p>go 实现 CSP 并发模式是通过： goroutine + chan</p>
<h3 id="3-g-调度执行中断是如何恢复的">3. G 调度执行中断是如何恢复的？</h3>
<p>G 是一个数据结构，存储上下文堆栈信息</p>
<p>中断的时候将寄存器里的栈信息，保存到自己的 G 对象（sudog）里面。当再次轮到自己执行时，将自己保存的栈信息复制到寄存器里面，这样就接着上次之后运行了。</p>
<h3 id="4-当-g-阻塞时gmp-会发生什么">4. 当 G 阻塞时，g、m、p 会发生什么</h3>
<p>G 的状态会从运行态变为阻塞态，放入 P 等待队列</p>
<p>M 会从该 Goroutine 所在的 P 中分离出来，转而执行其他 Goroutine</p>
<p>P 会从该 Goroutine 所在的 M 中分离出来，将该 Goroutine 放入等待队列中，并从空闲的 M 队列中取出一个 M，将其绑定到该 P 上</p>
<h3 id="5-runtime-是什么">5. runtime 是什么？</h3>
<p>golang 底层的基础设施：</p>
<ul>
<li>
<p>GPM 的创建和调度</p>
</li>
<li>
<p>内存分配</p>
</li>
<li>
<p>GC</p>
</li>
<li>
<p>内置函数如 map，chan，slice，反射的实现等</p>
</li>
<li>
<p>pprof，trace，CGO</p>
</li>
<li>
<p>操作系统以及 CPU 的一些封装</p>
</li>
<li>
<p>....</p>
</li>
</ul>
<p>基本上就是 go 的底层所在了</p>
<p><img alt="go runtime" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250728105120855-1426825468.png" class="lazyload"></p>
<h3 id="6-怎么启动第一个-goroutine">6. 怎么启动第一个 goroutine?</h3>
<p>main 启动函数会默认启动 G0 协程</p>
<h3 id="7-go-的协程为什么那么好与线程的区别">7. Go 的协程为什么那么好，与线程的区别</h3>
<p>●&nbsp;大小</p>
<p>协程大概是 2k-4k，线程大概是1m</p>
<p>●&nbsp;创建、切换和销毁</p>
<p>协程是用户态的，由runtime创建和销毁，没有内核消耗，线程是内核态的，与操作系统相关，创建和销毁成本较高</p>
<p>提高cpu的利用率，解决了高消耗的CPU调度，用户态的轻量级的线程，约4k</p>
<p>减少了内核切换成本，操作系统分为用户态和内核态(表示操作系统底层)</p>
<p><img alt="线程和线程的区别" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250728105121039-672346178.png" class="lazyload"></p>
<h3 id="8-线程与协程的区别">8. 线程与协程的区别</h3>
<p>一个线程有多个协程，协程是用户态的轻量级的线程，非抢占式的，由用户控制，没有内核切换的开销</p>
<p><strong>原文地址</strong></p>
<p><a href="https://blog.fiveyoboy.com/articles/go-goroutine-gmp" target="_blank" rel="noopener nofollow">Go 原理之 GMP 并发调度模型</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-28 10:52">2025-07-28 10:52</span>&nbsp;
<a href="https://www.cnblogs.com/fiveyobody">五岁小孩</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19008494);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19008494', targetLink: 'https://www.cnblogs.com/fiveyobody/p/19008494/go-goroutine-gmp', title: 'Go 原理之 GMP 并发调度模型' })">举报</a>
</div>
        