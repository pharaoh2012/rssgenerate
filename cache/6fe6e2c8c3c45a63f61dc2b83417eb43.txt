
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ishoulgodo/p/18704966" title="发布于 2025-02-08 18:26">
    <span role="heading" aria-level="2">4种比常见的线程池和线程同步买票问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h4 id="线程池">线程池</h4>
<p>所谓的线程池:其实就是线程对象的容器。<br>
可以根据需要，在启动时，创建1个或者多个线程对象。<br>
java中有4种比较常见的线程池。<br>
1.固定数量的线程对象。<br>
2.根据需求动态创建线程：动态创建线程:根据需求来创建线程的个数，会自动给我们分配合适的线程个数来完成任务。<br>
3.单一线程。<br>
4.定时调度线程。</p>
<h4 id="固定数量的线程对象">固定数量的线程对象</h4>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202502/1972489-20250208182952953-1254357100.jpg" alt="" loading="lazy"></p>
<p>通过上面的图片，我们可以看见创建了3个线程对象。<br>
最初：user1提交了一个任务submit1，此时这3个线程对象都是空闲。都是可以去执行的。<br>
我们这里为了好理解，交给了T1(当然T2,T3也是可以的)去执行。<br>
此时就空闲了2个线程(T2，T3)，T1在执行submit1<br>
然后user2也提交了一个任务submit2,我们交给了T2去执行，此时空闲了T3。<br>
然后user3也提交了一个任务submit3,我们交给了T3去执行。<br>
此时没有空闲的了。T1,T2，T3都在干活。<br>
然后来了一个user4，它也提交给了一个任务submit4。<br>
这个时候3个线程对象都在忙，submit4这个任务只有等待T1或T2或T3谁先完成手上的工作。<br>
假设是T3已经完成了submit3的任务，submit4这个任务由T3开始干活。<br>
如果后面又来了一个user5，提交了submit5。<br>
submit5这个任务只有等待T1或T2或T3谁先完成手上的工作。<br>
假设是T2已经完成了submit2的任务，submit5这个任务由T2开始干活。<br>
以此类推...,这个就是线程池对象帮我们实现的功能。</p>
<h4 id="创建固定数量的线程对象执行多个任务看线程池对象时如何分配任务的">创建固定数量的线程对象执行多个任务,看线程池对象时如何分配任务的。</h4>
<pre><code class="language-java">package part;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Java01 {
    public static void main(String[] args) {
       // 创建固定数量的线程对象
        // ExecutorService是线程服务对象，这里我创建了3个线程对象
        ExecutorService executor = Executors.newFixedThreadPool(3);
        //我提交5次，看下线程对象的执行情况，他是如何分配任务的
        for (int i = 0; i &lt; 5; i++) {
            //提交任务，这里我写的是一个匿名类
            executor.submit(new Runnable() {
                // 重写了run方法
                @Override
                public void run() {
//                    名称:pool-1-thread-1
//                    名称:pool-1-thread-3
//                    名称:pool-1-thread-2
//                    名称:pool-1-thread-3
//                    名称:pool-1-thread-1
//                    我们发现 线程 pool-1-thread-1和pool-1-thread-3 执行了2次任务，线程pool-1-thread-2执行了1次任务
                    System.out.println("名称:"+ Thread.currentThread().getName());
                }
            });
        }
    }
}
</code></pre>
<h4 id="根据需求动态创建线程">根据需求动态创建线程</h4>
<pre><code class="language-java">package part;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Java01 {
    public static void main(String[] args) {
        // 根据需求动态创建线程
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 5; i++) {
            // 提交任务，这里我写的是一个匿名类
            executor.submit(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName());
                }
            });
        }
    }
}
//pool-1-thread-2
//pool-1-thread-4
//pool-1-thread-1
//pool-1-thread-3
//pool-1-thread-5
// 我们创建了5个线程
</code></pre>
<h4 id="根据需求动态创建线程-1">根据需求动态创建线程</h4>
<pre><code class="language-java">package part;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Java01 {
    public static void main(String[] args) {
        // 根据需求动态创建线程
        ExecutorService executor = Executors.newCachedThreadPool();
        // 这里循环5次，有5个线程，等会看下有几个线程，按理说：有几个线程，就会产生几个线程
        for (int i = 0; i &lt; 20; i++) {
            // 提交任务，这里我写的是一个匿名类
            executor.submit(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName());
                }
            });
        }
    }
}
//pool-1-thread-1
//pool-1-thread-4
//pool-1-thread-5
//pool-1-thread-6
//pool-1-thread-3
//pool-1-thread-8
//pool-1-thread-12
//pool-1-thread-2
//pool-1-thread-10
//pool-1-thread-4
//pool-1-thread-13
//pool-1-thread-14
//pool-1-thread-9
//pool-1-thread-7
//pool-1-thread-15
//pool-1-thread-4
//pool-1-thread-10
//pool-1-thread-13
//pool-1-thread-6
//pool-1-thread-11
// 我们发现 线程 pool-1-thread-4 干了3次活。 线程pool-1-thread-10干了2次活。
// 动态创建线程:根据需求来创建线程的个数，会自动给我们分配合适的线程个数来完成任务
</code></pre>
<h4 id="单一线程">单一线程</h4>
<pre><code class="language-java">package part;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Java01 {
    public static void main(String[] args) {
        // 单一线程
        ExecutorService executor = Executors.newSingleThreadExecutor();
        // 虽然创建了3个线程需要主要，但是我只有1个线程，执行完一个在继续下一个线程
        for (int i = 0; i &lt; 3; i++) {
            executor.submit(new Runnable(){
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName());
                }
            });
        }
    }
}
//pool-1-thread-1
//pool-1-thread-1
//pool-1-thread-1
// 输出来的都是：pool-1-thread-1。说明这个线程干了3次活。
</code></pre>
<h4 id="线程同步synchronized">线程同步:synchronized</h4>
<p>synchronized 是一个同步关键字，使用synchronized修饰的方法。<br>
只能一个一个的访问(A访问完了之后，B才能进来),同步操作。<br>
synchronized 它还可以修饰代码块，称之为同步代码块。<br>
使用 synchronized 修饰的类型，变成了同步，访问效率低。<br>
Hashtable类型的就是同步修饰的。因此访问效率低。<br>
语法：<br>
synchronized (用于同步的对象){<br>
处理逻辑<br>
}</p>
<h4 id="线程异步出现的问题">线程异步出现的问题</h4>
<p>现在我们来模拟用户买票的行为。<br>
假设现在有3张票，3个用户来买，我们等下会发生写什么？</p>
<pre><code class="language-java">package part;

public class Java01 {
  public static void main(String[] args) {
    // Hashtable类型的就是同步修饰的。访问修饰的效率低。
    // synchronized 是一个同步关键字,它还可以修饰代码块，称之为同步代码块
    // 多个线程访问同步方法，只能一个一个的访问(A访问完了之后，B才能进来),同步操作
    TicketSeller user1 = new TicketSeller();
    for (int i=0;i&lt;4;i++){
      int userId = i + 1;
      new Thread(new Runnable() {
        @Override
        public void run() {
          // 为啥这里不能直接使用变量i ???
          user1.sellTicket("用户" + userId);
          System.out.println();
        }
      }).start();
    }
  }
}

class TicketSeller {
  private int tickets = 3; // 假设有3张票  synchronized
  public   void sellTicket(String name) {
    if (tickets &gt; 0) {
      --tickets;
      try {
        // 模拟买票花费的时候
        Thread.sleep(100);
      } catch (InterruptedException e) {
        throw new RuntimeException(e);
      }
      System.out.println(name+ "买了1张，现在还剩下: " + tickets);
    } else {
      System.out.println("没有票拉");
    }
  }
}
</code></pre>
<p>我们发信买了一张票之后，就输出无票了。<br>
原因是：线程是异步的。在某个时刻大家都抢到了。<br>
<img src="https://img2024.cnblogs.com/blog/1972489/202502/1972489-20250208182527926-1226413309.png" alt="" loading="lazy"></p>
<h4 id="使用同步-synchronized-来解决这个问题">使用同步 synchronized 来解决这个问题</h4>
<pre><code class="language-java">package part;

public class Java01 {
    public static void main(String[] args) {
        // Hashtable类型的就是同步修饰的。访问修饰的效率低。
        // synchronized 是一个同步关键字,它还可以修饰代码块，称之为同步代码块
        // 多个线程访问同步方法，只能一个一个的访问(A访问完了之后，B才能进来),同步操作
        TicketSeller user1 = new TicketSeller();
        for (int i=0;i&lt;10;i++){
            int userId = i + 1;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    // 为啥这里不能直接使用变量i ???
                    user1.sellTicket("用户" + userId);
                    System.out.println();
                }
            }).start();
        }
    }
}

class TicketSeller {
    private int tickets = 3; // 假设有3张票
    public  void sellTicket(String name) {
        if (tickets &gt; 0) {
            --tickets;
            System.out.println(name+ "买了1张，现在还剩下: " + tickets);
        } else {
            System.out.println("没有票拉");
        }
    }
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1972489/202502/1972489-20250208182534948-1742715424.png" alt="" loading="lazy"></p>
<h4 id="为什么在匿名内部类里不能直接使用外部的循环变量i">为什么在匿名内部类里不能直接使用外部的循环变量i</h4>
<pre><code class="language-java">public class Java01 {
    public static void main(String[] args) {
        TicketSeller user1 = new TicketSeller();
        for (int i=0;i&lt;10;i++){
            int userId = i + 1;
            new Thread(new Runnable() {
                @Override
                public void run() {
                    // 为啥这里不能直接使用变量 i ?
                    // 报错提示：Variable 'i' is accessed from within inner class, needs to be final or effectively final
                    user1.sellTicket("用户" + i);
                    System.out.println();
                }
            }).start();
        }
    }
}
</code></pre>
<p>原因：首先在匿名内部类中，比如这里的Runnable实现。<br>
如果它访问了外部方法的局部变量，那么这个变量必须是final或者等效final的。<br>
也就是说，变量在初始化之后不能被修改。<br>
原来的代码中，循环变量i在每次迭代的时候都会被改变。<br>
上面从0增加到3。这时候如果直接在内部类里使用i，因为i的值在变化，就会导致问题。<br>
解决办法:新增一个变量，每次迭代的时候，这新变量都是一个最新的值，且每次迭代中新变量都是独立的。<br>
也就是说：我们这里把i的值赋给了一个新的局部变量userId。每次循环迭代的时候，这个userId都是一个新变量。<br>
且每个迭代中的userId都是独立的，所以每个内部类实例都会有自己的userId，这个值在创建的时候被赋值之后就不再改变(也就是等效final了)<br>
这样每个线程都能正确获取到对应的userId，而不会受到后续循环改变i的影响了。</p>
<h4 id="启动线程链式调用">启动线程链式调用</h4>
<pre><code>Thread t1 = new Thread(new Runnable() {
    @Override
    public void run() {
        user1.sellTicket("用户1");
    }
});
// 要执行线程中的代码，需要执行start方法哈
t1.start();
等价与下面的代码
new Thread(new Runnable() {
    @Override
    public void run() {
        user1.sellTicket("用户1");
    }
}).start();
</code></pre>
<h4 id="使用lambda简化代码">使用Lambda简化代码</h4>
<p>Lambda表达式是一种匿名函数，可以作为参数传递或存储在变量中。</p>
<pre><code>for (int i=0;i&lt;4;i++){
    int userId = i + 1;
    new Thread(new Runnable() {
        @Override
        public void run() {
            user1.sellTicket("用户" + userId);
        }
    }).start();
}
</code></pre>
<pre><code>for (int i = 0; i &lt; 4; i++) {
    int userId = i + 1;
    // ()-&gt; {} 等价 new Runnable() { @Override public void run() { user1.sellTicket("用户" + userId); } }
    new Thread(() -&gt; {
        user1.sellTicket("用户" + userId);
    }).start();
}
</code></pre>
<h4 id="尾声">尾声</h4>
<p>准备开始学习java了。<br>
今天学习的第八天，每天都会发文章，我要卷起来。<br>
请小伙伴们监督我，奥利给</p>

</div>
<div id="MySignature" role="contentinfo">
    <div style="width:818px;background:#f5f5f5; padding: 10px 10px 10px 10px; border: 1px dashed rgb(224, 224, 224); font-family: 微软雅黑; font-size: 13px;">
		    <div style="padding:10px">
		        作者：<a href="https://www.cnblogs.com/ishoulgodo/" target="_blank">流年少年</a> <br>
		        出处：<a href="https://www.cnblogs.com/ishoulgodo/">https://www.cnblogs.com/ishoulgodo/</a> <br>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
		        <p>如果觉得这篇文章对你有小小的帮助的话，记得在右下角点个“推荐”哦，或者关注博主，在此感谢！</p>
		        <p> 万水千山总是情，打赏5毛买辣条行不行，所以如果你心情还比较高兴，也是可以扫码打赏博主(っ•̀ω•́)っ✎⁾⁾！</p>
                        <p> 想问问题，打赏了卑微的博主，求求你备注一下的扣扣或者微信；这样我好联系你；(っ•̀ω•́)っ✎⁾⁾！</p>
				<div style="display: flex;">
					<div style="margin-right: 100px;text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_201214043958支付宝收款码.jpg?a=1607924145179">
						<div>
							支付宝
						</div>
					</div>
					<div style="text-align: center;">
						<img src="//images.cnblogs.com/cnblogs_com/IwishIcould/1900124/t_20121604194271E6E296CCB71A007F4E22073D5EB64A.jpg">
						<div>微信</div>
					</div>
				</div>
		        本文版权归作者所有，欢迎转载，未经作者同意须保留此段声明，在文章页面明显位置给出原文连接 <br>
		        如果文中有什么错误，欢迎指出。以免更多的人被误导。 <br>
		    </div>
		</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07697965376273148" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-08 18:32">2025-02-08 18:26</span>&nbsp;
<a href="https://www.cnblogs.com/ishoulgodo">何人陪我共长生</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18704966" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18704966);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18704966', targetLink: 'https://www.cnblogs.com/ishoulgodo/p/18704966', title: '4种比常见的线程池和线程同步买票问题' })">举报</a>
</div>
        