
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/orlion/p/18667930" title="发布于 2025-01-13 09:37">
    <span role="heading" aria-level="2">Mysql身份认证过程</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="背景">背景</h1>
<p>最近有一些<a href="https://github.com/Orlion/hersql" target="_blank" rel="noopener nofollow">hersql</a>的用户希望能支持mysql的<code>caching_sha2_password</code>认证方式，<code>caching_sha2_password</code>与常用的<code>mysql_native_password</code>认证过程差异还是比较大的，因此抽空研究了一下<code>caching_sha2_password</code>身份认证过程，并为<code>hersql</code>支持了<code>caching_sha2_password</code>的能力</p>
<blockquote>
<p>hersql是我开源的一款通过http隧道来代理mysql的工具，可以通过http服务来穿透内网的mysql server，地址：<a href="https://github.com/Orlion/hersql" target="_blank" rel="noopener nofollow">github.com/Orlion/hersql</a></p>
</blockquote>
<h1 id="mysql身份认证过程">mysql身份认证过程</h1>
<p><img src="https://s2.loli.net/2025/01/08/aj65q2uoBmbzvig.png" alt="image.png" loading="lazy"></p>
<p>Client与Server建立TCP连接后，Server返回<code>Initial Handshake Packet</code>，这个包中会携带Server默认的认证方式，因为此时还不清楚登录用户是谁，所以是无法返回准确的认证方式的。</p>
<blockquote>
<p>mysql8.0这个值默认值为<code>caching_sha2_password</code>，低版本为<code>mysql_native_password</code></p>
</blockquote>
<p>Client会先以Server返回的认证方式对密码进行加密，然后通过<code>Handshake Response Packet</code>发送给Server，这一轮交互完成后接下来会存在三种case:</p>
<ol>
<li>认证失败。比如密码错误。</li>
<li>认证成功。成功建立了连接，接下来可以进行命令通信。</li>
<li>返回AuthMoreData包，这时又分为两种情况：
<ul>
<li>包第二个字节 = 0x03，随后是一个正常的 OK 数据包，这是当用户的密码已在Server缓存中并且身份验证已成功时的情况，这种称之为<code>“fast” authentication</code>。</li>
<li>包第二个字节 = 0x04，这意味着需要更多数据才能完成身份验证，在使用<code>caching_sha2_password </code>认证方式时，这意味着用户密码不在Server缓存中，Server要求Client发送用户的完整密码，这就是所谓的<code>“full” authentication</code>。这时Client需要用Server的公钥对密码进行加密然后再次发送给Server。</li>
</ul>
</li>
<li>返回<code>auth switch”</code>包。Server收到<code>Handshake Response Packet</code>后会查询登录用户的认证方式，如果首次认证使用的认证方式与用户指定的认证方式不同，需要进行切换，会在<code>auth switch</code>包中携带准确的认证方式。接下来Client要用Server返回的这个准确的认证方式重新发起一轮认证请求。</li>
</ol>
<h1 id="mysql_native_password">mysql_native_password</h1>
<blockquote>
<p>mysql_native_password 身份验证插件从 MySQL 8.0.34 开始已弃用，在 MySQL 8.4 中默认禁用，并从 MySQL 9.0.0 开始删除。</p>
</blockquote>
<p>用户密码存储在<code>mysql.user</code>的<code>authentication_string</code>字段中。在<code>mysql_native_password</code>认证方式下Server端存储的用户密码为原始密码经过两个sha1后的哈希值，没有经过加盐，因此相同的密码存储的值是相同的。</p>
<h2 id="通讯过程简析">通讯过程简析</h2>
<p>Server端会在<code>Initial Handshake Packet</code>返回一个随机数，Client收到之后首先与Server相同的对原始密码进行两次sha1，然后把Server返回的随机数加到摘要中，最终进行一个异或运算，得到最终的认证字符串：</p>
<pre><code>// Hash password using 4.1+ method (SHA1)
func scramblePassword(scramble []byte, password string) []byte {
	if len(password) == 0 {
		return nil
	}

	// stage1Hash = SHA1(password)
	crypt := sha1.New()
	crypt.Write([]byte(password))
	stage1 := crypt.Sum(nil)

	// scrambleHash = SHA1(scramble + SHA1(stage1Hash))
	// inner Hash
	crypt.Reset()
	crypt.Write(stage1)
	hash := crypt.Sum(nil)

	// outer Hash
	crypt.Reset()
	crypt.Write(scramble)
	crypt.Write(hash)
	scramble = crypt.Sum(nil)

	// token = scrambleHash XOR stage1Hash
	for i := range scramble {
		scramble[i] ^= stage1[i]
	}
	return scramble
}
</code></pre>
<p>Client通过<code>Handshake Response Packet</code>发送给Server，Server采用与Client相同的算法生成认证字符串，如果两端生成的一致则说明密码正确，认证通过。</p>
<h1 id="caching_sha2_password">caching_sha2_password</h1>
<p>这种认证方式下存储在<code>mysql.user</code>的<code>authentication_string</code>字段中值为：</p>
<p><img src="https://static001.geekbang.org/infoq/dc/dcf28fff9a311aa215b0457f954661c6.png" alt="image.png" loading="lazy"></p>
<p>即利用盐值进行5000轮SHA256哈希。</p>
<h2 id="通讯过程简析-1">通讯过程简析</h2>
<p>同样Server端会先返回一个随机数，Client生成认证字符串的算法为<code>XOR(SHA256(password), SHA256(SHA256(SHA256(password)), scramble))</code>。Server端收到<code>Handshake Response Packet</code>之后首先会检查<code>username/SHA256(SHA256(user_password)) </code>是否与缓存匹配，如果匹配则认证成功。如果没有匹配的缓存则则要求Client通过SSL连接或者RSA公钥对密码进行加密后再次发送给Server端，Server解密后获取到密码明文然后得到哈希值判断密码是否正确。</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.19717240783449075" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-13 09:38">2025-01-13 09:37</span>&nbsp;
<a href="https://www.cnblogs.com/orlion">orlion</a>&nbsp;
阅读(<span id="post_view_count">20</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18667930" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18667930);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18667930', targetLink: 'https://www.cnblogs.com/orlion/p/18667930', title: 'Mysql身份认证过程' })">举报</a>
</div>
	