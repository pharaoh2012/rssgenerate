
    <a name="top"></a>
    <h2><a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zwwhnly/p/18851001" title="发布于 2025-04-28 09:34">
    <span role="heading" aria-level="2">聊聊@Autowired与@Resource的区别</span>
    

</a>
</h2>
    <small>
<span id="post-date" data-last-update-days="0.2077848351064815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-28 09:34">2025-04-28 09:34</span>&nbsp;
<a href="https://www.cnblogs.com/zwwhnly">申城异乡人</a>&nbsp;
阅读(<span id="post_view_count">131</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18851001);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18851001', targetLink: 'https://www.cnblogs.com/zwwhnly/p/18851001', title: '聊聊@Autowired与@Resource的区别' })">举报</a>
</small>
    <div class="entry">
            <div id="cnblogs_post_description" style="display: none">
        
        @Autowired与@Resource的区别。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-前言">1. 前言</h2>
<p>从事过很多家公司，见过很多项目，发现<code>@Autowired</code>和<code>@Resource</code>的使用都是一样的乱，</p>
<p>一个项目中有使用<code>@Autowired</code>的，有使用<code>@Resource</code>的，</p>
<p>甚至有的类中一会儿使用<code>@Autowired</code>，一会儿使用<code>@Resource</code>，虽然不影响业务功能的实现，但看起来真的是杂乱无章。</p>
<p>本篇博客主要讲解这2个注解之间的区别。</p>
<h2 id="2-来源不同">2. 来源不同</h2>
<p><code>@Autowired</code>是Spring框架的注解。</p>
<p><code>@Resource</code>是Java的注解（来自于JSR-250），由Spring框架兼容支持。</p>
<blockquote>
<p>说明：JSR是Java Specification Requests的缩写，意思是Java规范提案。</p>
</blockquote>
<h2 id="3-依赖查找顺序不同">3. 依赖查找顺序不同</h2>
<p><code>@Autowired</code>先根据类型查找，如果存在多个Bean，再根据名称查找。</p>
<p><code>@Resource</code>先根据名称查找，如果查找不到，再根据类型查找。</p>
<h3 id="31-验证autowired先根据类型查找再根据名称查找">3.1 验证@Autowired先根据类型查找，再根据名称查找</h3>
<p>首先，新建接口：</p>
<pre><code class="language-java">public interface NotificationService {
    void send();
}
</code></pre>
<p>然后新建第一个实现类：</p>
<pre><code class="language-java">import org.springframework.stereotype.Service;

@Service
public class EmailService implements NotificationService {
    @Override
    public void send() {
        System.out.println("发送邮件通知");
    }
}
</code></pre>
<p>接着新建第二个实现类：</p>
<pre><code class="language-java">import org.springframework.stereotype.Service;

@Service
public class SmsService implements NotificationService {
    @Override
    public void send() {
        System.out.println("发送短信通知");
    }
}
</code></pre>
<p>最后新建Controller，并使用<code>@Autowired</code>来注入NotificationService：</p>
<pre><code class="language-java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;

@RestController("/dependency/injection/test")
public class NotificationController {
    @Autowired
    private NotificationService notificationService;
}
</code></pre>
<p>此时启动项目，会抛出<code>org.springframework.beans.factory.NoUniqueBeanDefinitionException</code>异常，</p>
<p>原因是因为有2个NotificationService类型的Bean，Spring不确定注入哪一个Bean，这也证明<code>@Autowired</code>默认是先根据类型查找。</p>
<p>有三种解决方案可以解决该问题，</p>
<p>第一种解决方案是使用<code>@Primary</code>注解：</p>
<pre><code class="language-java">import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

@Service
@Primary
public class EmailService implements NotificationService {
    @Override
    public void send() {
        System.out.println("发送邮件通知");
    }
}
</code></pre>
<p><strong>说明：如果有多个同类型的Bean，Spring会优先使用<code>@Primary</code>注解标记的Bean。</strong></p>
<p>第二种解决方案是修改字段名称：</p>
<pre><code class="language-java">@Autowired
private NotificationService emailService;
</code></pre>
<p>第三种解决方案是使用<code>@Qualifier</code>注解：</p>
<pre><code class="language-java">@Autowired
@Qualifier("emailService")
private NotificationService notificationService;
</code></pre>
<p>第二种解决方案和第三种解决方案证明<code>@Autowired</code>是根据名称查找的，</p>
<p>两者的区别是第二种解决方案是按字段名称查找的（隐式），第三种解决方案是按指定的名称查找的（显式）。</p>
<h3 id="32-验证resource先根据名称查找再根据类型查找">3.2 验证@Resource先根据名称查找，再根据类型查找</h3>
<p>首先，新建接口：</p>
<pre><code class="language-java">public interface NotificationService {
    void send();
}
</code></pre>
<p>然后新建第一个类（<strong>注意事项：不是实现类</strong>）：</p>
<pre><code class="language-java">import org.springframework.stereotype.Service;

@Service
public class EmailService {
    public void send() {
        System.out.println("发送邮件通知");
    }
}
</code></pre>
<p>接着新建第二个类（<strong>注意事项：是实现类</strong>）：</p>
<pre><code class="language-java">import org.springframework.stereotype.Service;

@Service
public class SmsService implements NotificationService {
    @Override
    public void send() {
        System.out.println("发送短信通知");
    }
}
</code></pre>
<p>最后新建Controller，并使用<code>@Resource</code>来注入NotificationService：</p>
<pre><code class="language-java">import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;

@RestController("/dependency/injection/test")
public class NotificationController {
    @Resource
    private NotificationService emailService;
}
</code></pre>
<p>此时启动项目，会抛出<code>org.springframework.beans.factory.BeanNotOfRequiredTypeException</code>异常，</p>
<p>原因是因为按字段名称查找到的EmailService Bean，不是NotificationService类型，这也证明<code>@Resource</code>默认是先根据名称查找。</p>
<p>有两种解决方案可以解决该问题，</p>
<p>第一种解决方案是显式指定Bean名称：</p>
<pre><code class="language-java">@Resource(name = "smsService")
private NotificationService emailService;
</code></pre>
<p>第二种解决方案是修改字段名称：</p>
<pre><code class="language-java">@Resource
private NotificationService notificationService;
</code></pre>
<p>第二种解决方案能注入成功，也证明<code>@Resource</code>是根据类型查找的，</p>
<p>此时因为NotificationService只有一个实现类SmsService，所以直接注入成功，</p>
<p>如果将EmailService也改为NotificationService的实现类：</p>
<pre><code class="language-java">import org.springframework.stereotype.Service;

@Service
public class EmailService implements NotificationService {
    @Override
    public void send() {
        System.out.println("发送邮件通知");
    }
}
</code></pre>
<p>那么启动项目，会抛出<code>org.springframework.beans.factory.NoUniqueBeanDefinitionException</code>异常。</p>
<h2 id="4-参数不同">4. 参数不同</h2>
<p><code>@Autowired</code>只有1个required参数，<code>@Resource</code>有name、type等7个参数。</p>
<h3 id="41-autowired的参数">4.1 @Autowired的参数</h3>
<p><code>@Autowired</code>只有1个参数，如下所示：</p>
<pre><code class="language-java">public @interface Autowired {
    boolean required() default true;
}
</code></pre>
<p>默认情况下，<code>@Autowired</code>要求依赖必须存在，可以通过<code>required = false</code>设置为可选。</p>
<pre><code class="language-java">@Autowired(required = false)
private NotificationService notificationService;
</code></pre>
<h3 id="42-resource的参数">4.2 @Resource的参数</h3>
<p><code>@Resource</code>有7个参数，如下所示：</p>
<pre><code class="language-java">public @interface Resource {
    String name() default "";

    String lookup() default "";

    Class&lt;?&gt; type() default java.lang.Object.class;

    enum AuthenticationType {
            CONTAINER,
            APPLICATION
    }

    AuthenticationType authenticationType() default AuthenticationType.CONTAINER;

    boolean shareable() default true;

    String mappedName() default "";

    String description() default "";
}
</code></pre>
<p>默认情况下，<code>@Resource</code>先根据字段名查找Bean，可以通过name参数显式指定名称，通过type参数显式指定类型。</p>
<pre><code class="language-java">@Resource(name = "emailService", type = NotificationService.class)
private NotificationService notificationService;
</code></pre>
<h2 id="5-支持的依赖注入方式不同">5. 支持的依赖注入方式不同</h2>
<p><code>@Autowired</code>支持字段注入、Setter方法注入和构造函数注入。</p>
<p><code>@Resource</code>支持字段注入、Setter方法注入，不支持构造函数注入。</p>
<h3 id="51-autowired支持的依赖注入方式">5.1 @Autowired支持的依赖注入方式</h3>
<p>1)字段注入：</p>
<pre><code class="language-java">@RestController("/dependency/injection/test")
public class NotificationController {
    @Autowired
    private NotificationService notificationService;
}
</code></pre>
<p><strong>这种方式不推荐使用，但在实际项目中使用的最多。</strong></p>
<p>2)Setter方法注入：</p>
<pre><code class="language-java">@RestController("/dependency/injection/test")
public class NotificationController {
    private NotificationService notificationService;

    @Autowired
    private void setNotificationService(NotificationService notificationService) {
        this.notificationService = notificationService;
    }
}
</code></pre>
<p>3)构造函数注入</p>
<pre><code class="language-java">@RestController("/dependency/injection/test")
public class NotificationController {
    private final NotificationService notificationService;

    public NotificationController(NotificationService notificationService) {
        this.notificationService = notificationService;
    }
}
</code></pre>
<p><strong>这种方式是Spring官方推荐的首选方式。</strong></p>
<h3 id="52-resource支持的依赖注入方式">5.2 @Resource支持的依赖注入方式</h3>
<p>1)字段注入：</p>
<pre><code class="language-java">@RestController("/dependency/injection/test")
public class NotificationController {
	@Resource
    private NotificationService notificationService;
}
</code></pre>
<p>2)Setter方法注入：</p>
<pre><code class="language-java">@RestController("/dependency/injection/test")
public class NotificationController {
    private NotificationService notificationService;

	@Resource
    private void setNotificationService(NotificationService notificationService) {
        this.notificationService = notificationService;
    }
}
</code></pre>
<p><code>@Resource</code>不支持构造函数注入，如果在构造函数上使用<code>@Resource</code>注解，IDEA会提示：</p>
<p>'@Resource' not applicable to constructor。</p>
<h2 id="6-总结">6. 总结</h2>
<p><code>@Autowired</code>和<code>@Resource</code>都是用来实现依赖注入的注解，但两者之间是有区别的，主要有以下4点：</p>
<ol>
<li>
<p>来源不同</p>
<blockquote>
<p><code>@Autowired</code>是Spring框架的注解。</p>
<p><code>@Resource</code>是Java的注解（来自于JSR-250），由Spring框架兼容支持。</p>
</blockquote>
</li>
<li>
<p>依赖查找顺序不同</p>
<blockquote>
<p><code>@Autowired</code>先根据类型查找，如果存在多个Bean，再根据名称查找。</p>
<p><code>@Resource</code>先根据名称查找，如果查找不到，再根据类型查找。</p>
</blockquote>
</li>
<li>
<p>参数不同</p>
<blockquote>
<p><code>@Autowired</code>只有1个required参数，<code>@Resource</code>有name、type等7个参数。</p>
</blockquote>
</li>
<li>
<p>支持的依赖注入方式不同</p>
<blockquote>
<p><code>@Autowired</code>支持字段注入、Setter方法注入和构造函数注入。</p>
<p><code>@Resource</code>支持字段注入、Setter方法注入，不支持构造函数注入。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>文章持续更新，欢迎关注微信公众号「申城异乡人」第一时间阅读！</p>
</blockquote>

</div>
<div class="clear"></div>

        <div class="clear"></div>
        
</div>
    <ul class="postmetadata">
        <vc:categories-tags blog-app="zwwhnly" blog-id="121761" post-id="18851001"></vc:categories-tags>
    </ul>
