
            <div class="postcontent">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="java-锁升级机制详解">Java 锁升级机制详解</h1>
<h3 id="引言">引言</h3>
<p>最近有个三年左右的兄弟面试java 被问到这样一道经典的八股文面试题： 你讲讲java里面的锁升级？ 他感觉回答的不是很好，然后回去找资料学习了一波，然后下面是他输出的文章，希望对找工作的其他朋友也有些帮助。</p>
<h2 id="1-概述"><strong>1. 概述</strong></h2>
<p>Java 的锁升级机制是 JVM 在 JDK 1.6 后引入的重要优化策略，目的是在多线程环境下平衡 <strong>线程安全</strong> 与 <strong>性能开销</strong>。通过动态调整锁的复杂度，JVM 根据竞争强度逐步升级锁的状态，避免在低竞争场景下使用高成本的重量级锁。</p>
<h2 id="2-锁类型及特点"><strong>2. 锁类型及特点</strong></h2>
<table>
<thead>
<tr>
<th><strong>锁类型</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>性能开销</strong></th>
<th><strong>核心机制</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无锁（Unlocked）</strong></td>
<td>无线程竞争</td>
<td>极低</td>
<td>直接通过 CAS 操作尝试获取锁。</td>
</tr>
<tr>
<td><strong>偏向锁（Biased Locking）</strong></td>
<td>单线程重复访问（无竞争）</td>
<td>极低</td>
<td>对象头记录偏向线程 ID，后续同一线程无需竞争，直接获取锁。</td>
</tr>
<tr>
<td><strong>轻量级锁（Lightweight Lock）</strong></td>
<td>低竞争（多个线程交替访问）</td>
<td>中等</td>
<td>通过 CAS 自旋尝试获取锁，避免操作系统级别的阻塞。</td>
</tr>
<tr>
<td><strong>重量级锁（Heavyweight Lock）</strong></td>
<td>高竞争（长时间阻塞或高并发）</td>
<td>高</td>
<td>依赖操作系统互斥量（Mutex），线程被挂起并排队等待。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="3-锁升级的过程"><strong>3. 锁升级的过程</strong></h2>
<p>锁升级路径为：<strong>无锁 → 偏向锁 → 轻量级锁 → 重量级锁</strong>，且 <strong>不可逆</strong>（只能升级，不能降级）。</p>
<h3 id="31-无锁--偏向锁"><strong>3.1 无锁 → 偏向锁</strong></h3>
<ul>
<li><strong>触发条件</strong>：第一个线程访问同步代码块时。</li>
<li><strong>过程</strong>：
<ol>
<li>JVM 通过 CAS 操作将对象头的 <code>Mark Word</code> 标记为偏向锁。</li>
<li>记录当前线程 ID 和偏向时间戳。</li>
<li>后续同一线程再次访问时，直接通过比对线程 ID 获取锁（无需 CAS 操作）。</li>
</ol>
</li>
</ul>
<h3 id="32-偏向锁--轻量级锁"><strong>3.2 偏向锁 → 轻量级锁</strong></h3>
<ul>
<li><strong>触发条件</strong>：第二个线程尝试获取同一锁（出现竞争）。</li>
<li><strong>过程</strong>：
<ol>
<li>偏向锁失效，JVM 撤销偏向锁（可能触发 STW，Stop-The-World）。</li>
<li>线程通过自旋（Spin）和 CAS 操作尝试获取锁。</li>
<li>若自旋成功，则升级为轻量级锁；否则继续自旋或升级为重量级锁。</li>
</ol>
</li>
</ul>
<h3 id="33-轻量级锁--重量级锁"><strong>3.3 轻量级锁 → 重量级锁</strong></h3>
<ul>
<li><strong>触发条件</strong>：
<ul>
<li>自旋次数超过阈值（默认 10 次，可通过 <code>-XX:PreBlockSpin</code> 调整）。</li>
<li>多个线程同时竞争锁（如第三个线程加入竞争）。</li>
</ul>
</li>
<li><strong>过程</strong>：
<ol>
<li>JVM 将锁升级为重量级锁，对象头指向监视器（Monitor）。</li>
<li>线程进入操作系统内核态的阻塞队列，等待调度器唤醒。</li>
<li>未获取锁的线程通过 <code>ObjectMonitor</code> 等待唤醒。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="4-锁升级的优缺点"><strong>4. 锁升级的优缺点</strong></h2>
<h3 id="41-优点"><strong>4.1 优点</strong></h3>
<ol>
<li><strong>减少无竞争场景的开销</strong>：偏向锁和轻量级锁避免了频繁的 CAS 和上下文切换。</li>
<li><strong>动态适配竞争强度</strong>：在低竞争时保持高性能，在高竞争时保证线程安全。</li>
</ol>
<h3 id="42-缺点"><strong>4.2 缺点</strong></h3>
<ol>
<li><strong>偏向锁撤销开销</strong>：当其他线程竞争时，撤销偏向锁会导致 STW，影响性能。</li>
<li><strong>重量级锁的高开销</strong>：在高竞争场景下，频繁的线程阻塞/唤醒会显著降低性能。</li>
</ol>
<hr>
<h2 id="5-锁升级的优化策略"><strong>5. 锁升级的优化策略</strong></h2>
<h3 id="51-减少锁持有时间"><strong>5.1 减少锁持有时间</strong></h3>
<ul>
<li><strong>优化方向</strong>：缩短同步代码块的执行时间，降低锁的竞争概率。</li>
<li><strong>示例</strong>：<pre><code class="language-java">// 不推荐：锁持有时间过长
synchronized (lock) {
    // 复杂计算或 IO 操作
}

// 推荐：仅在关键代码块加锁
int result = doSomeComputation(); // 非同步操作
synchronized (lock) {
    sharedVariable = result;
}
</code></pre>
</li>
</ul>
<h3 id="52-使用分段锁segment-locking"><strong>5.2 使用分段锁（Segment Locking）</strong></h3>
<ul>
<li><strong>优化方向</strong>：将一个大锁拆分为多个小锁，减少锁的竞争范围。</li>
<li><strong>示例</strong>：<code>ConcurrentHashMap</code> 使用分段锁（JDK 8 后改为 CAS + synchronized）。</li>
</ul>
<h3 id="53-禁用偏向锁"><strong>5.3 禁用偏向锁</strong></h3>
<ul>
<li><strong>适用场景</strong>：频繁切换线程的场景（如高并发服务）。</li>
<li><strong>JVM 参数</strong>：<pre><code class="language-bash">-XX:-UseBiasedLocking  # 禁用偏向锁
</code></pre>
</li>
</ul>
<h3 id="54-调整自旋次数"><strong>5.4 调整自旋次数</strong></h3>
<ul>
<li><strong>适用场景</strong>：轻量级锁的自旋可能因 CPU 空闲而浪费资源。</li>
<li><strong>JVM 参数</strong>：<pre><code class="language-bash">-XX:PreBlockSpin=5  # 设置自旋次数为 5
</code></pre>
</li>
</ul>
<hr>
<h2 id="6-代码示例"><strong>6. 代码示例</strong></h2>
<pre><code class="language-java">public class LockUpgradeExample {
    private final Object lock = new Object();

    public void performTask() {
        synchronized (lock) {
            // 同步代码块
        }
    }

    public static void main(String[] args) {
        LockUpgradeExample example = new LockUpgradeExample();
        Thread t1 = new Thread(example::performTask);
        Thread t2 = new Thread(example::performTask);

        t1.start(); // 初始为偏向锁（t1）
        t2.start(); // 触发偏向锁撤销，升级为轻量级锁
    }
}
</code></pre>
<hr>
<h2 id="7-关键-jvm-参数"><strong>7. 关键 JVM 参数</strong></h2>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-XX:+UseBiasedLocking</code></td>
<td>开启/关闭偏向锁（默认开启，Java 15+ 默认关闭）。</td>
</tr>
<tr>
<td><code>-XX:BiasedLockingStartupDelay=0</code></td>
<td>立即启用偏向锁（避免延迟）。</td>
</tr>
<tr>
<td><code>-XX:PreBlockSpin</code></td>
<td>设置轻量级锁自旋次数（默认 10）。</td>
</tr>
<tr>
<td><code>-XX:-UseSpinning</code></td>
<td>关闭自旋锁（强制进入重量级锁）。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="8-总结"><strong>8. 总结</strong></h2>
<ul>
<li><strong>锁升级是 JVM 自动管理的机制</strong>，开发者无需手动干预，但理解其原理有助于优化并发性能。</li>
<li><strong>偏向锁适合单线程场景</strong>，轻量级锁适合低竞争场景，重量级锁适合高竞争场景。</li>
<li><strong>锁升级不可逆</strong>，一旦升级到重量级锁，后续操作将始终使用重量级锁。</li>
</ul>
<p>通过合理设计代码（如减少锁粒度、避免过早膨胀到重量级锁），可以最大化 Java 的并发性能。</p>
<hr>

</div>
<div class="clear"></div>

            </div>
            <div class="itemdesc">
                发表于 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-13 17:15">2025-06-13 17:14</span>&nbsp;
<a href="https://www.cnblogs.com/root429">java金融</a>&nbsp;
阅读(<span id="post_view_count">75</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18927414);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18927414', targetLink: 'https://www.cnblogs.com/root429/p/18927414', title: 'Java 锁升级机制详解' })">举报</a>

            </div>
        