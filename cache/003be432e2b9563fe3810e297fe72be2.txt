
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cjdty/p/18957368" title="发布于 2025-06-30 10:59">
    <span role="heading" aria-level="2">Python添加windows资源管理器上下文菜单 无条目限制</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>目前开发一个项目<a href="https://github.com/x1ntt/pychee6" target="_blank" rel="noopener nofollow">x1ntt/pychee6</a>需要在资源管理器的上下文菜单中插入命令，于是调查了一下python能用的库。</p>
<p>目前来说，最好用的库是<code>Context_ment</code> ，接口设计简单，使用方便，同时还兼容Linux系统；再者就是通过使用<code>COM</code>的方式让资源管理器主动调用<code>Python</code>脚本。这种方案条目限制比较宽松，能有几百个条目，使用上也会更自由一点（<s>繁琐</s>）。</p>
<h1 id="context_menu">Context_menu</h1>
<p>项目地址：<a href="https://github.com/saleguas/context_menu" target="_blank" rel="noopener nofollow">saleguas/context_menu: 💻 A Python library to create and deploy cross-platform native context menus. 💻</a></p>
<p>其基本原理是通过修改注册表来实现在资源管理器中添加条目，但是当条目超过16个的时候，多出来的部分不会显示。我猜这个是因为早期电脑性能不好，如果条目过多，上下文菜单需要很久才能弹出来，所以有这个限制（xp时代）。</p>
<p>具体使用例子可以看项目Readme，如果需要中文例子，可以看：<a href="https://blog.csdn.net/gitblog_00011/article/details/139895694" target="_blank" rel="noopener nofollow">Python跨平台上下文菜单库 —— <code>context_menu</code> 使用指南-CSDN博客</a></p>
<p>如果只是为了实现在上下文菜单中添加一两个命令，那么这个库就是最好的选择，忽略下面吧。</p>
<h1 id="com方案的实现">COM方案的实现</h1>
<p>但是我的需求需要实现将<code>lychee</code>中的所有相册结构映射到上下文菜单中，数量会非常多，所以只能使用这个方案。具体可以看我的<a href="https://github.com/x1ntt/pychee6_cm" target="_blank" rel="noopener nofollow">x1ntt/pychee6_cm</a>项目。</p>
<p>找了很久，没有一个现成的库实现<code>COM</code>方案来做这件事，但是我找到了一个例子代码：<a href="https://github.com/winterTTr/py-tools/tree/master/ShellExtension" target="_blank" rel="noopener nofollow">py-tools/ShellExtension at master · winterTTr/py-tools</a> （具体见<code>shell_extension.py</code>文件）。</p>
<p>这个例子是基于<code>pywin32</code>库实现的，它是<code>python2</code>编写的，可以交给<code>AI</code>改写为<code>Python3</code>。</p>
<h2 id="简述com">简述COM</h2>
<blockquote>
<p><code>COM</code>技术是微软公司制定的一种Windows平台下的软件模块复用技术。借助于COM技术，用户可以编写一些具有特定接口的软件模块（称为COM组件 ），它们可以以dll或exe的形式注册到Windows系统中来对外公开自己，其它的应用程序则可以借助于Windows提供的API来调用这些组件，从而在整个系统范围内实现了软件模块的复用 <a href="https://blog.csdn.net/qq_40628925/article/details/118097146" target="_blank" rel="noopener nofollow">COM开发指南（1）—COM技术概述-CSDN博客</a></p>
</blockquote>
<p>如果不打算深究这个技术，可以简单理解成<code>server</code>和<code>client</code>的关系。通过<code>windows api</code>实现一个<code>server</code>，同时实现一些接口，然后给<code>server</code>分配一个<code>GUID</code>，<code>client</code>就能根据<code>GUID</code>连接到<code>server</code>。至此，双方通过约定好的接口通信即可。</p>
<p>可以在<a href="https://timgolden.me.uk/pywin32-docs/com_objects.html" target="_blank" rel="noopener nofollow">com_objects</a>找到<code>pywin32</code>实现的一些<code>com</code>接口。</p>
<p>要实现修改资源管理器上下文的功能，我们需要关注<code>PyIShellExtInit</code>和<code>PyIContextMenu</code>这两个接口</p>
<h2 id="一个添加上下文菜单的例子">一个添加上下文菜单的例子</h2>
<p>这里以我的<a href="https://github.com/x1ntt/pychee6_cm" target="_blank" rel="noopener nofollow">x1ntt/pychee6_cm: 用于注册pychee.cli到windows资源管理的上下文菜单</a> 项目作为例子。</p>
<p><code>src</code>目录中有如下文件</p>
<table>
<thead>
<tr>
<th>代码文件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>reg.py</td>
<td>代码逻辑，实现com组件</td>
</tr>
<tr>
<td>register.bat</td>
<td>将reg.py中实现的组件注册到注册表</td>
</tr>
<tr>
<td>unregister.bat</td>
<td>取消注册</td>
</tr>
<tr>
<td>debug_register.bat</td>
<td>启用调试模式的注册，输出调试信息到调试窗口</td>
</tr>
<tr>
<td>open_trace_window.bat</td>
<td>打开调试窗口，本质是运行了<code>site-packages\win32\lib\win32traceutil.py</code> 需要调整为正确路径</td>
</tr>
<tr>
<td>restart_explorer.bat</td>
<td>重启资源管理器</td>
</tr>
</tbody>
</table>
<p>修改过<code>reg.py</code>文件后，必须通过<code>restart_explorer.bat</code>重启资源管理器代码才会生效，<strong>重新注册不会生效</strong>。</p>
<h2 id="例子解析">例子解析</h2>
<p>见<code>pychee6_cm</code>项目的<code>reg.py</code>文件</p>
<h3 id="将类注册到注册表">将类注册到注册表</h3>
<pre><code class="language-python">from win32com.server import register
register.UseCommandLine(ShellExtension,
                         finalize_register=DllRegisterServer,
                         finalize_unregister=DllUnregisterServer)
</code></pre>
<p>导入<code>win32com.server</code>，将注册<code>ShellExtension</code>类，同时指定注册和取消注册时的回调函数。</p>
<p><code>DllRegisterServer</code>函数将<code>clsid</code>(其实就是上面说的GUID)，写进注册表，告诉资源管理器出现如下情况时调用<code>clsid</code>对应的<code>com</code>组件</p>
<table>
<thead>
<tr>
<th>注册表路径</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*\\shellex\\ContextMenuHandlers\\</code></td>
<td>任意文件右键</td>
</tr>
<tr>
<td><code>directory\\shellex\\ContextMenuHandlers\\</code></td>
<td>文件夹右键</td>
</tr>
<tr>
<td><code>directory\\background\\shellex\\ContextMenuHandlers\\</code></td>
<td>进入文件夹后右键空白处</td>
</tr>
<tr>
<td><code>Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved</code></td>
<td>告知资源管理器使用这个组件</td>
</tr>
</tbody>
</table>
<h3 id="shellextension">ShellExtension</h3>
<p>这个就是实现的<code>com</code>组件，需要关注的重点是:</p>
<ul>
<li>
<p><code>_reg_clsid_</code>就是组件的唯一<code>id</code>也就是写进注册表的值，资源管理器通过这个值找到组件，可以通过任意方式得到诸如<code>{7C15377B-26A0-4582-A594-12F95CABD4A2}</code>的值（GUID）。</p>
</li>
<li>
<p><code>_com_interfaces_</code>表明该组件实现了什么接口，提供了什么功能，例如例子中提供了<code>IID_IShellExtInit</code>和<code>IID_IContextMenu</code>（详细文档<a href="https://timgolden.me.uk/pywin32-docs/PyIShellExtInit.html" target="_blank" rel="noopener nofollow">PyIShellExtInit Object</a>、<a href="https://timgolden.me.uk/pywin32-docs/PyIContextMenu.html" target="_blank" rel="noopener nofollow">PyIContextMenu Object</a>）</p>
</li>
</ul>
<p>接下来实现两个接口对应的几个函数即可</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>归属接口</th>
<th>调用时机及含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Initialize</td>
<td>IID_IShellExtInit</td>
<td>点击右键时，用于获取待操作的目录或选中的文件</td>
</tr>
<tr>
<td>QueryContextMenu</td>
<td>IID_IContextMenu</td>
<td>点击右键时，用于提供菜单条目，在这里编辑菜单</td>
</tr>
<tr>
<td>InvokeCommand</td>
<td>IID_IContextMenu</td>
<td>点击具体条目时，调用对应的命令</td>
</tr>
<tr>
<td>GetCommandString</td>
<td>IID_IContextMenu</td>
<td>检索上下文菜单选项的动词或帮助文本</td>
</tr>
</tbody>
</table>
<p>通过<code>debug_register.bat</code>注册之后，右键打开菜单，应该能在调试窗口中看到上面函数被调用。</p>
<h4 id="initialize">Initialize</h4>
<p>获取上下文菜单需要操作的目标（菜单上下文）</p>
<h4 id="querycontextmenu">QueryContextMenu</h4>
<p>方法中使用<code>win32gui.InsertMenu</code>函数构建菜单，这里需要注意的一点是<code>QueryContextMenu</code>参数中提供的<code>idCmdFirst, idCmdLast</code>两个参数，指定了<code>InsertMenu</code>的<code>idCmd</code>取值范围，如果超过这个范围，可能会导致混乱（具体我也不知道会发生什么），所以这个方案其实<strong>还是有条目数量限制的</strong>。</p>
<p>至于<code>InsertMenu</code>函数的参数含义，可以看这里：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-insertmenuw" target="_blank" rel="noopener nofollow">InsertMenuW 函数 （winuser.h） - Win32 apps | Microsoft Learn</a>。因为<code>pywin32</code>本身是对<code>windows api</code>的封装，所以直接参考其开发手册应该没有问题。</p>
<h4 id="invokecommand">InvokeCommand</h4>
<p>参数传递的<code>verb</code>参数用来标记用户执行了那个条目，我本来以为这是<code>idCmd</code>的作用，但实际上<code>verb</code>只是个索引，它表示执行你插入的第几个菜单条目。</p>
<h4 id="getcommandstring">GetCommandString</h4>
<p>我不知道它的作用是什么，目前没看出来实际作用。</p>
<hr>
<p>最终实现的效果<br>
<img src="https://img2024.cnblogs.com/blog/1236187/202506/1236187-20250630105806949-1410936195.gif" alt="lychee_cm" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-30 11:00">2025-06-30 10:59</span>&nbsp;
<a href="https://www.cnblogs.com/cjdty">Startu</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18957368);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18957368', targetLink: 'https://www.cnblogs.com/cjdty/p/18957368', title: 'Python添加windows资源管理器上下文菜单 无条目限制' })">举报</a>
</div>
        