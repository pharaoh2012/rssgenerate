
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18806897" title="发布于 2025-04-02 22:34">
    <span role="heading" aria-level="2">zk基础—3.集群与核心参数</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="4" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="5"><strong>1.zk单机模式是如何启动的</strong></p>
<p data-track="6"><strong>2.zk集群是如何部署和启动的</strong></p>
<p data-track="7"><strong>3.zk集群部署要用什么样配置的机器</strong></p>
<p data-track="8"><strong>4.如何合理设置zk的JVM参数以及内存大小</strong></p>
<p data-track="9"><strong>5.zk配置的核心参数之tickTime、dataDir和dataLogDir</strong></p>
<p data-track="10"><strong>6.影响Leader与Follower组成集群的两个核心参数之initLimit和syncLimit</strong></p>
<p data-track="11"><strong>7.zk什么时候进行数据快照(snapCount = 10000)</strong></p>
<p data-track="12"><strong>8.一台机器上最多能启动多少个zk客户端(maxClientCnxns = 60)</strong></p>
<p data-track="13"><strong>9.一个znode中最多能存储多少数据量(jute.maxbuffer = 1M)</strong></p>
<p data-track="14"><strong>10.运行时的Leader与Follower会通过2888和3888端口进行通信</strong></p>
<p data-track="15"><strong>11.事务日志和数据快照是如何进行定时清理的</strong></p>
<p data-track="16"><strong>12.在2PC阶段写入的事务日志也有丢失的风险</strong></p>
<p data-track="17"><strong>13.Leader相关的两个参数之leaderServers和cnxTimeout</strong></p>
<p data-track="18"><strong>14.zk提供给运维使用的命令说明</strong></p>
<p data-track="19">&nbsp;</p>
<p data-track="20"><strong>1.zk单机模式是如何启动的</strong></p>
<p data-track="21">下面先通过bin/zkServer.sh脚本来启动单机模式的zk，然后再通过bin/zkCli.sh脚本 + 2181端口连接到zk。</p>
<pre class="highlighter-hljs"><code>$ cd zookeeper
$ sudo bin/zkServer.sh start
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /Users/demo/Documents/zookeeper/bin/../conf/zoo.cfg
Starting zookeeper ... STARTED

$ ps -ef |grep java
$ sudo bin/zkCli.sh
/usr/bin/java
Connecting to localhost:2181
[zk: localhost:2181(CONNECTED) 0] ls /
[zookeeper]</code></pre>
<p data-track="23">&nbsp;</p>
<p data-track="24"><strong>2.zk集群是如何部署和启动的</strong></p>
<p data-track="25">要部署zk集群，可以准备三台机器，每台机器上部署一个zk进程。每台机器上的zk配置文件添加如下内容，让每个节点感知集群中有几台机器。</p>
<pre class="highlighter-hljs"><code>server.1=zookeeper01:2888:3888
server.2=zookeeper02:2888:3888
server.3=zookeeper03:2888:3888</code></pre>
<p data-track="27">zk集群的每个节点都有一个ID编号，需要在指定的dataDir目录下创建一个myid文件，把该zk节点的ID编号写在里面。</p>
<p data-track="28">&nbsp;</p>
<p data-track="29">zk的端口号分为2888和3888。其中3888是用来进行Leader选举的，2888是用来进行数据同步的。</p>
<p data-track="30">&nbsp;</p>
<p data-track="31"><strong>3.zk集群部署要用什么样配置的机器</strong></p>
<p data-track="32">zk属于基础架构类的中间件系统，一般部署的机器比较少(通常3-5台)，但不建议用太普通的配置。部署zk、Kafka、Hbase、HDFS等的机器，所需要的配置都是比较高的。</p>
<p data-track="33">&nbsp;</p>
<p data-track="34">4核8G的机器，每秒可以抗1000并发。</p>
<p data-track="35">8核16G的机器，每秒可以抗几千并发。</p>
<p data-track="36">16核32G的机器，每秒可以抗上万或几万并发。</p>
<p data-track="37">&nbsp;</p>
<p data-track="38">一般采用3台机器(8核16G/16核32G + SSD固态硬盘)来部署一个zk集群，三台这种机器的小集群每秒可以抗十几万的并发。</p>
<p data-track="39">&nbsp;</p>
<p data-track="40">比如3台16核32G的机器：1个Leader + 2个Follower。其中，Leader主要负责写，每秒可以抗几万写并发。Follower负责读，每秒可以抗5万~10万读并发。</p>
<p data-track="41">&nbsp;</p>
<p data-track="42">虽然写QPS无法线性的扩展，但读QPS可通过Observer节点来扩展。设置Observer节点很简单，只需修改配置强制要求其角色是Observer，不能是Leader或Follower即可。</p>
<p data-track="43">&nbsp;</p>
<p data-track="44"><strong>4.如何合理设置zk的JVM参数及内存大小</strong></p>
<p data-track="45">zk本身是用Java写的，是基于JVM虚拟机来运行的。启动zk就是启动一个JVM进程，JVM进程里面会执行zk的全部代码，所以需要合理设置JVM的三大参数。</p>
<p data-track="46">&nbsp;</p>
<p data-track="47"><strong>一.首先分配各块内存区域的大小</strong></p>
<p data-track="48">包括堆内存、栈内存、Metaspace区域的内存，根据机器内存去设置。比如机器有16G的内存，堆内存可分配10G，栈内存可分配每个线程的栈1MB，Metaspace区域可以分配512MB。</p>
<p data-track="49">&nbsp;</p>
<p data-track="50"><strong>二.然后设置垃圾回收器</strong></p>
<p data-track="51">通常Java应用的新生代 + 老年代的垃圾回收器会设置为ParNew + CMS，但大内存机器不建议使用这个组合，建议使用G1垃圾回收器。</p>
<p data-track="52">&nbsp;</p>
<p data-track="53"><strong>三.JVM启动前要加入一些参数</strong></p>
<p data-track="54">比如GC日志要写入哪个目录中，发生OOM时要自动dump内存快照出来放哪个目录去。</p>
<p data-track="55">&nbsp;</p>
<p data-track="56">当这三大JVM参数都合理设置好之后，就可以启动zk并开始使用了。在各种情况下以及一些运气高峰期，还要使用jstat观察一下zk的JVM情况：包括新生代的对象增长速率 + YGC的频率 + 老年代增长速率 + FGC的频率。如果GC有问题，就要进行GC调优，合理优化JVM参数。如果有监控系统，需要对zk运行时的JVM的情况进行监控。</p>
<p data-track="57">&nbsp;</p>
<p data-track="58"><strong>5.zk配置的核心参数之tickTime、dataDir和dataLogDir</strong></p>
<p data-track="59">正式启动zk之前，还需要配置zk的一些参数：</p>
<pre class="highlighter-hljs"><code>$ cat conf/zoo.cfg</code></pre>
<p data-track="61"><strong>(1)tickTime</strong></p>
<p data-track="62">tickTime的默认值是2000ms，表示zk里的最小时间单位。其他的一些参数就会以这个tickTime为基准来进行设置，比如有的参数就是tickTime * 2。</p>
<p data-track="63">&nbsp;</p>
<p data-track="64"><strong>(2)dataDir</strong></p>
<p data-track="65">用来存放zk里的数据快照。zk里会存储很多数据，在磁盘里会有一份内存数据的快照，这样zk停机重启后才能恢复之前的数据。</p>
<p data-track="66">&nbsp;</p>
<p data-track="67"><strong>(3)dataLogDir</strong></p>
<p data-track="68">写数据时有2PC机制，首先会写Proposal提议，也就是事务日志。每台机器会将事务日志写入到本地磁盘。所以如果使用SSD固态硬盘，可以提升写性能。</p>
<p data-track="69">&nbsp;</p>
<p data-track="70"><strong>6.影响Leader与Follower组成集群的两个核心参数之initLimit和syncLimit</strong></p>
<p data-track="71"><strong>(1)initLimit</strong></p>
<p data-track="72">initLimit的默认值是10，意思是10 * tickTime，即20s。表示Leader在启动后会等待Follower跟自己建立连接，最长等待时间是20s。所以在20s内Follower必须要跟Leader建立连接，否则Leader就不等Follower，直接进入消息广播模式，对外提供服务了。如果zk里存储的数据量比较大，Follower恢复数据需要的时间比较长，此时就可调大该参数。</p>
<p data-track="73">&nbsp;</p>
<p data-track="74"><strong>(2)syncLimit</strong></p>
<p data-track="75">syncLimit的默认值是5，意思是5 * tickTime，即10s。Leader会向Follower发起心跳检测，如果超过10s没有心跳响应，Leader就会把这个Follower给踢除出去。</p>
<p data-track="76">&nbsp;</p>
<p data-track="77"><strong>7.zk什么时候进行数据快照(snapCount = 10000)</strong></p>
<p data-track="78">zk里的数据分成两份：一份是磁盘上的事务日志(dataLogDir)，一份是内存里的数据。</p>
<p data-track="79">&nbsp;</p>
<p data-track="80">理论上两份数据是一致的。即使Follower宕机，也只丢失内存里的数据，磁盘上的事务日志是存在的。即使Follower没收到事务日志就宕机，也可以重启后找Leader同步数据。</p>
<p data-track="81">&nbsp;</p>
<p data-track="82">比如zk在磁盘里有一份事务日志，它启动后应该如何重建内存里的数据？难道把事务日志进行回放？重新执行每条事务日志到内存里去吗？</p>
<p data-track="83">&nbsp;</p>
<p data-track="84">所以zk会有一个数据快照机制，每次执行一定数量的事务后，就会把内存里的数据存储到dataDir目录中，作为zk当前的一个数据快照。</p>
<p data-track="85">&nbsp;</p>
<p data-track="86">比如现在事务日志里有1000个事务，已经把1000个事务对应的内存数据写入到dataDir里作为一个数据快照了。此后继续写数据写到事务日志里有1032个事务时，zk进行重启。zk重启时就可以把包含1000个事务的快照直接加载到内存里，然后把1000之后的32个事务，在内存里回放一遍，即可恢复重启前的数据。</p>
<p data-track="87">&nbsp;</p>
<p data-track="88">对应的参数是snapCount，默认是10万个事务存储一次快照。表示的是如果没到10万条事务zk就重启了，那么此时是没有数据快照的，也就是10万条事务以内不需要快照。</p>
<p data-track="89">&nbsp;</p>
<p data-track="90"><strong>8.一台机器上最多能启动多少个zk客户端(maxClientCnxns = 60)</strong></p>
<p data-track="91">一台机器可以创建多少个zk客户端，可以跟zk服务端建立多少个连接？这是有限制的，默认最多60个，也就是zk服务端最多只允许一台机器和它建立60个连接，但可通过maxClientCnxns参数来设置。</p>
<p data-track="92">&nbsp;</p>
<p data-track="93">如果开发时不注意没有使用单例模式，每次请求都创建一个zk客户端建立连接进行通信，然后再销毁zk客户端。当多个并发请求一起连接zk时，就会导致一台机器上有很多zk客户端，可能最终导致这台机器发出的zk请求被zk服务端拒绝。</p>
<p data-track="94">&nbsp;</p>
<p data-track="95"><strong>9.一个znode中最多能存储多少数据量(jute.maxbuffer = 1M)</strong></p>
<p data-track="96">一个znode中最多能存储的数据量由参数jute.maxbuffer设定，默认是1M。对应的数值是1048575，单位bytes，换算成M就是1M。一般建议不要在一个znode中存储过多数据量，几百个字节～几百K即可。</p>
<p data-track="97">&nbsp;</p>
<p data-track="98"><strong>10.运行时的Leader与Follower会通过2888和3888端口进行通信</strong></p>
<p data-track="99">3888端口，用于在集群恢复模式时进行Leader选举投票。2888端口，用于在Leader和Follower之间进行数据同步和运行时通信。</p>
<p data-track="100">&nbsp;</p>
<p data-track="101"><strong>11.事务日志和数据快照是如何进行定时清理的</strong></p>
<p data-track="102">zk在不停的运行，事务日志会越来越多，但不可能是无限多的，所以zk会切割出多个事务日志文件。每次执行一次数据快照时，都会有一个独立的数据快照文件。最后zk的磁盘上会存在多个事务日志文件，多个数据快照文件。</p>
<p data-track="103">&nbsp;</p>
<p data-track="104">默认是没有开启定时清理数据文件的功能，所以应该按如下配置进行开启。这样每隔1小时会让zk在后台自动清理多余的事务日志文件和数据快照文件，而且最多保存3个文件。</p>
<pre class="highlighter-hljs"><code>autopurge.purgeInterval=1
autopurge.snapRetainCount=3</code></pre>
<p data-track="106">&nbsp;</p>
<p data-track="107"><strong>12.在2PC阶段写入的事务日志也有丢失的风险</strong></p>
<p data-track="108">事务进行Commit提交时，有没有日志丢失的风险？是有的。在2PC的第一个阶段，Proposal提议时各机器会把事务日志写入磁盘时，一般会写入OS Cache。在2PC的第二个阶段，Commit提交时才会强制把写的事务日志fsync到磁盘上。</p>
<p data-track="109">&nbsp;</p>
<p data-track="110">因此，参数"forceSync: yes"指的就是：在Commit提交时，会强制把OS Cache中的事务日志fsync到磁盘上去。</p>
<p data-track="111">&nbsp;</p>
<p data-track="112">在Commit提交时，最好将OS Cache中的事务日志fsync到磁盘上。否则如果机器挂了，那么就有可能丢失OS Cache里还没刷入磁盘的事务日志数据。</p>
<p data-track="113">&nbsp;</p>
<p data-track="114">虽然zk在处理写请求时，会涉及到多台机器往磁盘写事务日志。但是由于写事务日志是顺序写磁盘，这与随机写内存的性能差不多，所以性能也很高。而且写事务日志一开始就是往OS Cache里写的，所以性能就可以更高了。</p>
<p data-track="115">&nbsp;</p>
<p data-track="116"><strong>13.Leader相关的两个参数之leaderServers和cnxTimeout</strong></p>
<p data-track="117"><strong>(1)参数leaderServers，默认值是yes</strong></p>
<p data-track="118">表示Leader是否接收客户端的连接，所有写请求由Follower转发给Leader，Leader只接收Follower转发的写请求。</p>
<p data-track="119">&nbsp;</p>
<p data-track="120"><strong>(2)参数cnxTimeout，默认5000</strong></p>
<p data-track="121">在进行Leader选举时，各个机器会基于3888端口建立TCP长连接，在这个过程中建立TCP连接的超时时间默认是5000毫秒。</p>
<p data-track="122">&nbsp;</p>
<p data-track="123">一般来说，在启动zk集群之前，首先需要在zoo.cfg配置文件里设置好参数，比如设置zk集群server.1、server.2的信息，设置dataDir、dataLogDir的目录，开启自动清理数据文件等。然后再使用zkServer.sh命令，分别启动Leader和Follower等多个节点。</p>
<p data-track="124">&nbsp;</p>
<p data-track="125"><strong>14.zk提供给运维使用的命令说明</strong></p>
<p data-track="126"><strong>(1)服务端常用命令</strong></p>
<p data-track="127"><strong>(2)客户端常用命令</strong></p>
<p data-track="128"><strong>(3)ACL命令常用命令</strong></p>
<p data-track="129"><strong>(4)常用四字命令</strong></p>
<p data-track="130"><strong>(5)zk日志可视化</strong></p>
<p data-track="131">&nbsp;</p>
<p data-track="132"><strong>(1)服务端常用命令</strong></p>
<p data-track="133">在准备好相应的配置之后，可以直接通过zkServer.sh这个脚本进行服务的相关操作：</p>
<pre class="highlighter-hljs"><code>启动zk服务:         sh bin/zkServer.sh start
查看zk服务状态:      sh bin/zkServer.sh status
停止zk服务:         sh bin/zkServer.sh stop
重启zk服务:         sh bin/zkServer.sh restart</code></pre>
<p data-track="135"><strong>(2)客户端常用命令</strong></p>
<p data-track="136">可以使用zkCli.sh -server 127.0.0.1:2181尝试连接到zk服务。连接成功后，系统会输出zk的相关环境以及配置信息。</p>
<p data-track="137">&nbsp;</p>
<p data-track="138">命令行工具的一些简单操作如下：</p>
<pre class="highlighter-hljs"><code>一.显示根目录下文件： ls /
使用ls命令来查看当前zk中所包含的内容；

二.显示根目录下文件： ls2 /
查看当前节点数据并能看到更新次数等数据；

三.创建文件并设置初始内容：create /zk "test"
创建一个新的znode节点"zk"以及与它关联的字符串；
[-e] [-s] (-e 临时节点)(-s 顺序节点)

四.获取文件内容： get /zk
确认ZNode是否包含我们所创建的字符串，[watch](watch监听)；

五.修改文件内容：set /zk "zkbak"
对zk所关联的字符串进行设置；

六.删除文件： delete /zk
将刚才创建的ZNode删除，如果存在子节点删除失败；

七.递归删除：rmr或者deleteall  /zk
将刚才创建的ZNode删除，子节点同时删除；

八.退出客户端： quit；帮助命令： help</code></pre>
<p data-track="140">不能创建同名的节点：</p>
<pre class="highlighter-hljs"><code>[zk: 127.0.0.1:2181(CONNECTED) 0] create /node1 value
Created /node1
[zk: 127.0.0.1:2181(CONNECTED) 1] ls /
[aaa, node1, zookeeper]
[zk: 127.0.0.1:2181(CONNECTED) 2] create /node1 value 
Node already exists: /node1</code></pre>
<p data-track="142">创建临时节点使用-e：</p>
<pre class="highlighter-hljs"><code>[zk: 127.0.0.1:2181(CONNECTED) 5] create -e /node3 value
Created /node3
[zk: 127.0.0.1:2181(CONNECTED) 7] ls /
[aaa, node1, node2, node3, zookeeper]</code></pre>
<p data-track="144">创建完临时节点node3后退出客户端与服务端连接，然后客户端重新再连接服务端，再执行ls查看，发现node3已经不见了。</p>
<pre class="highlighter-hljs"><code>[zk: 127.0.0.1:2181(CONNECTED) 8] quit
$ ./zkCli.sh -server 127.0.0.1:2181
[zk: 127.0.0.1:2181(CONNECTED) 0] ls /
[aaa, node1, node2, zookeeper]</code></pre>
<p data-track="146">不管是持久节点还是临时节点，一旦创建完一个节点后，再重复创建同名节点都是不成功的。</p>
<pre class="highlighter-hljs"><code>[zk: 127.0.0.1:2181(CONNECTED) 0] ls /
[aaa, node1, node2, zookeeper]
[zk: 127.0.0.1:2181(CONNECTED) 1] create /seqnode abc
Created /seqnode
[zk: 127.0.0.1:2181(CONNECTED) 2] create /seqnode abc
Node already exists: /seqnode

[zk: 127.0.0.1:2181(CONNECTED) 3] create -e /nodee aaa
Created /nodee
[zk: 127.0.0.1:2181(CONNECTED) 4] create -e /nodee aaa
Node already exists: /nodee</code></pre>
<p data-track="148">创建顺序节点使用-s，可以重复创建"同名"的顺序节点(命令行看起来同名而已，但实际不是同名的)。</p>
<pre class="highlighter-hljs"><code>[zk: 127.0.0.1:2181(CONNECTED) 6] create -e -s /nodes aaa
Created /nodes0000000007
[zk: 127.0.0.1:2181(CONNECTED) 7] create -e -s /nodes aaa
Created /nodes0000000008</code></pre>
<p data-track="150">修改节点内容使用set命令：</p>
<pre class="highlighter-hljs"><code>[zk: 127.0.0.1:2181(CONNECTED) 9] get /aaa
ccc
[zk: 127.0.0.1:2181(CONNECTED) 10] stat /aaa
cZxid = 0x2
ctime = Wed Feb 09 16:01:50 CST 2022
mZxid = 0x5
mtime = Wed Feb 09 16:03:01 CST 2022
pZxid = 0x8
cversion = 2
dataVersion = 2
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 3
numChildren = 2
[zk: 127.0.0.1:2181(CONNECTED) 11] set /aaa ccc
[zk: 127.0.0.1:2181(CONNECTED) 12] get /aaa
ccc
[zk: 127.0.0.1:2181(CONNECTED) 13] stat /aaa
cZxid = 0x2
ctime = Wed Feb 09 16:01:50 CST 2022
mZxid = 0x17
mtime = Wed Feb 09 16:53:46 CST 2022
pZxid = 0x8
cversion = 2
dataVersion = 3
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 3
numChildren = 2</code></pre>
<p data-track="152">删除节点使用delete(不能删有子节点的)或者deleteall(可以进行递归删除)：</p>
<pre class="highlighter-hljs"><code>[zk: 127.0.0.1:2181(CONNECTED) 21] delete /aaa
Node not empty: /aaa
[zk: 127.0.0.1:2181(CONNECTED) 22] ls /aaa
[aaa_1, aaa_2]
[zk: 127.0.0.1:2181(CONNECTED) 23] delete /aaa/aaa_1
[zk: 127.0.0.1:2181(CONNECTED) 24] ls /aaa
[aaa_2]
[zk: 127.0.0.1:2181(CONNECTED) 25] delete /aaa
Node not empty: /aaa
[zk: 127.0.0.1:2181(CONNECTED) 26] rmr /aaa
The command 'rmr' has been deprecated. Please use 'deleteall' instead.</code></pre>
<p data-track="154"><strong>(3)ACL命令常用命令</strong></p>
<p data-track="155">zk的ACL分三个维度：scheme、id、permission，通常表示为：scheme:id:permission。其中schema代表授权策略，id代表用户，permission代表权限。</p>
<pre class="highlighter-hljs"><code>[zk: 127.0.0.1:2181(CONNECTED) 1] getAcl /seqnode
'world,'anyone
: cdrwa</code></pre>
<p data-track="157"><strong>一.Scheme(授权策略)</strong></p>
<pre class="highlighter-hljs"><code>world：默认方式，相当于全世界都能访问；
auth：代表已经认证通过的用户，这里的密码是明文；
digest：即用户名:密码这种方式认证，这也是业务系统中最常用的；
ip：使用IP地址认证；</code></pre>
<p data-track="159"><strong>二.id(用户)</strong></p>
<p data-track="160">id是验证模式，不同的scheme，id的值也不一样；</p>
<pre class="highlighter-hljs"><code>scheme为auth时：id为username:password，这里的密码是明文
scheme为digest时：id为username:BASE64(SHA1(password))
scheme为ip时：id为客户端的ip地址
scheme为world时：id为anyone</code></pre>
<p data-track="162"><strong>三.Permission(权限)</strong></p>
<p data-track="163">CREATE、READ、WRITE、DELETE、ADMIN，也就是增、删、改、查、管理权限，这5种权限简写为crwda(即：每个单词的首字符缩写)。</p>
<pre class="highlighter-hljs"><code>CREATE(c)：创建子节点的权限；
DELETE(d)：删除节点的权限；
READ(r)：读取节点数据的权限；
WRITE(w)：修改节点数据的权限；
ADMIN(a)：设置子节点权限的权限；</code></pre>
<p data-track="165"><strong>四.ACL命令</strong></p>
<p data-track="166"><strong>命令1：getAcl</strong></p>
<p data-track="167">获取指定节点的ACL信息：</p>
<pre class="highlighter-hljs"><code>create /testDir/testAcl deer  # 创建一个子节点
getAcl /testDir/testAcl      # 获取该节点的acl权限信息
[zk: 127.0.0.1:2181(CONNECTED) 1] create /testDir testDir
Created /testDir
[zk: 127.0.0.1:2181(CONNECTED) 2] create /testDir/testAcl deer
Created /testDir/testAcl
[zk: 127.0.0.1:2181(CONNECTED) 3] getAcl /testDir/testAcl
'world,'anyone
: cdrwa</code></pre>
<p data-track="169"><strong>命令2：setAcl</strong></p>
<p data-track="170">设置指定节点的ACL信息：</p>
<pre class="highlighter-hljs"><code>setAcl /testDir/testAcl world:anyone:crwa   # 设置该节点的acl权限
getAcl /testDir/testAcl   # 获取该节点的acl权限信息，成功后，该节点就少了d权限
create /testDir/testAcl/xyz xyz-data   # 创建子节点
delete /testDir/testAcl/xyz    # 由于没有d权限，所以提示无法删除

[zk: 127.0.0.1:2181(CONNECTED) 3] getAcl /testDir/testAcl
'world,'anyone
: cdrwa
[zk: 127.0.0.1:2181(CONNECTED) 4] setAcl /testDir/testAcl world:anyone:crwa
[zk: 127.0.0.1:2181(CONNECTED) 5] getAcl /testDir/testAcl
'world,'anyone
: crwa
[zk: 127.0.0.1:2181(CONNECTED) 6] create /testDir/testAcl/xyz xyz-data
Created /testDir/testAcl/xyz
[zk: 127.0.0.1:2181(CONNECTED) 7] delete /testDir/testAcl/xyz
Authentication is not valid : /testDir/testAcl/xyz</code></pre>
<p data-track="172"><strong>命令3：addauth</strong></p>
<p data-track="173">注册会话授权信息。如果给ZNode设置权限了，后面退出客户端，则重新登录时需再次注册授权才能有ZNode权限。</p>
<pre class="highlighter-hljs"><code>//Scheme的auth
addauth digest user1:123456                      # 需要先添加一个用户
setAcl /testDir/testAcl auth:user1:123456:crwa     # 然后才可以拿着这个用户去设置权限
getAcl /testDir/testAcl                # 密码是以密文的形式存储的
create /testDir/testAcl/testa aaa   
delete /testDir/testAcl/testa             # 由于没有d权限，所以提示无法删除

[zk: 127.0.0.1:2181(CONNECTED) 8] addauth digest user1:123456
[zk: 127.0.0.1:2181(CONNECTED) 9] setAcl /testDir/testAcl auth:user1:123456:crwa
[zk: 127.0.0.1:2181(CONNECTED) 10] getAcl /testDir/testAcl
'digest,'user1:HYGa7IZRm2PUBFiFFu8xY2pPP/s=
: crwa
[zk: 127.0.0.1:2181(CONNECTED) 11] create /testDir/testAcl/testa aaa
Created /testDir/testAcl/testa
[zk: 127.0.0.1:2181(CONNECTED) 12] delete /testDir/testAcl/testa
Authentication is not valid : /testDir/testAcl/testa</code></pre>
<p data-track="175">退出客户端后：</p>
<pre class="highlighter-hljs"><code>ls /testDir/testAcl  #没有权限无法访问
create /testDir/testAcl/testb bbb #没有权限无法访问
addauth digest user1:123456  # 重新新增权限后可以访问了，相当于给当前用户增加了一个user1而且密码是123456

[zk: 127.0.0.1:2181(CONNECTED) 13] quit
$ ./zkCli.sh -server 127.0.0.1:2181
[zk: 127.0.0.1:2181(CONNECTED) 0]
[zk: 127.0.0.1:2181(CONNECTED) 0] ls /testDir/testAcl
Authentication is not valid : /testDir/testAcl
[zk: 127.0.0.1:2181(CONNECTED) 1] create /testDir/testAcl/testb bbb
Authentication is not valid : /testDir/testAcl/testb
[zk: 127.0.0.1:2181(CONNECTED) 2] addauth digest user1:123456
[zk: 127.0.0.1:2181(CONNECTED) 3] ls /testDir/testAcl
[testa, xyz]
[zk: 127.0.0.1:2181(CONNECTED) 4] create /testDir/testAcl/testb bbb
Created /testDir/testAcl/testb</code></pre>
<p data-track="177">auth与digest的区别就是：前者使用明文密码进行登录，后者使用密文密码进行登录。</p>
<pre class="highlighter-hljs"><code>create /testDir/testDigest  data
addauth digest user1:123456         # 增加用户
setAcl /testDir/testDigest digest:user1:HYGa7IZRm2PUBFiFFu8xY2pPP/s=:crwa  # 使用digest来设置权限
setAcl /testDir/testAcl auth:user1:123456:crwa                   # 使用auth来设置权限</code></pre>
<p data-track="179">注意：这里如果使用明文，会导致该znode不可访问。通过明文获得密文：使用zk的类DigestAuthenticationProvider。</p>
<pre class="highlighter-hljs"><code>$ java -Djava.ext.dirs=/Users/demo/Documents/apache-zookeeper-3.5.9-bin/lib -cp /Users/juntaowong/Documents/apache-zookeeper-3.5.9-bin/lib/zookeeper-3.5.9.jar org.apache.zookeeper.server.auth.DigestAuthenticationProvider deer:123456
deer:123456-&gt;deer:UwPiSoSNChqcQfSgAat6bc3IzwQ=</code></pre>
<p data-track="181"><strong>命令4：ACL命令行ip</strong></p>
<pre class="highlighter-hljs"><code>create  /testDir/testIp data
setAcl  /testDir/testIp ip:192.168.30.10:cdrwa
getAcl  /testDir/testIp</code></pre>
<p data-track="183"><strong>命令5：ACL启用super权限</strong></p>
<p data-track="184">setAcl权限时只设置了r权限，导致节点无法删除：</p>
<pre class="highlighter-hljs"><code>create /enjoy1/node1  enjoy
setAcl /enjoy1  world:anyone:r</code></pre>
<p data-track="186">这时无论是delete还是rmr都没有权限删除，解决方式就是启用super权限：</p>
<pre class="highlighter-hljs"><code>步骤1：使用DigestAuthenticationProvider.generateDigest("super:admin"); 获得密码
步骤2：修改zkServer启动脚本增加："-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs="
步骤3：启动客户端用管理员登陆：addauth digest super:admin</code></pre>
<p data-track="188"><strong>(4)常用四字命令</strong></p>
<p data-track="189">zk支持某些特定的四字命令字母结合nc与其的交互，这样可以用来获取zk服务的当前状态及相关信息，也就是通过telnet或nc向zk提交相应的命令。</p>
<pre class="highlighter-hljs"><code>echo stat | nc 127.0.0.1 2181，来查看哪个节点被选择作为follower或者leader；
echo ruok | nc 127.0.0.1 2181，测试是否启动了该Server，若回复imok表示已经启动；
echo dump | nc 127.0.0.1 2181，列出未经处理的会话和临时节点；
echo kill | nc 127.0.0.1 2181，关掉server；
echo conf | nc 127.0.0.1 2181，输出相关服务配置的详细信息；
echo cons | nc 127.0.0.1 2181，列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息；
echo envi | nc 127.0.0.1 2181，输出关于服务环境的详细信息(区别于conf命令)；
echo reqs | nc 127.0.0.1 2181，列出未经处理的请求；
echo wchs | nc 127.0.0.1 2181，列出服务器watch的详细信息；
echo wchc | nc 127.0.0.1 2181，通过session列出服务器watch的详细信息，它的输出是一个与watch相关的会话的列表；
echo wchp | nc 127.0.0.1 2181，通过路径列出服务器watch的详细信息，它输出一个与session相关的路径；</code></pre>
<p data-track="191"><strong>(5)zk日志可视化</strong></p>
<p data-track="192">zk有两个非常重要的配置：一个是dataDir，里面存放的是快照数据。一个是dataLogDir，里面存放的是事务日志数据。可以通过以下方式使用zk的类LogFormatter来查看日志、使用zk的类SnapshotFormatter来查看快照：</p>
<pre class="highlighter-hljs"><code>$ java -cp /soft/zookeeper-3.4.12/zookeeper-3.4.12.jar:/soft/zookeeper-3.4.12/lib/slf4j-api-1.7.25.jar org.apache.zookeeper.server.LogFormatter log.1
$ java -cp /soft/zookeeper-3.4.12/zookeeper-3.4.12.jar:/soft/zookeeper-3.4.12/lib/slf4j-api-1.7.25.jar org.apache.zookeeper.server.SnapshotFormatter log.1</code></pre>
<p>&nbsp;</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.23806433519328704" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-02 22:34">2025-04-02 22:34</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">5</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18806897" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18806897);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18806897', targetLink: 'https://www.cnblogs.com/mjunz/p/18806897', title: 'zk基础—3.集群与核心参数' })">举报</a>
</div>
        