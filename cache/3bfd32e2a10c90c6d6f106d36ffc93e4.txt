
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/johnnyzen/p/18840230" title="发布于 2025-04-22 12:11">
    <span role="heading" aria-level="2">[设计模式/Java] 设计模式之门面模式(外观模式)【20】</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="概述--门面模式--外观模式--facade-pattern">概述 : 门面模式 := 外观模式 := Facade Pattern</h1>
<h2 id="产生背景">产生背景</h2>
<ul>
<li><strong>软件开发过程</strong>中，我们经常会遇到<strong>复杂系统</strong>，其中包含多个子系统和接口。在这种情况下，为了<strong>简化客户端的调用过程</strong>，<strong>提高代码的可维护性和可读性</strong>，我们可以使用门面模式。</li>
</ul>
<h2 id="模式定义">模式定义</h2>
<ul>
<li><strong>门面模式</strong>（<code>Facade Pattern</code>）也叫做<strong>外观模式</strong>，是一种<strong>结构型设计模式</strong>。</li>
</ul>
<blockquote>
<p>它提供一个<strong>统一的接口</strong>，封装了一个或多个子系统的复杂功能，并向客户端提供一个<strong>简单的调用方式</strong>。<br>
通过引入<strong>门面</strong>，<strong>客户端</strong>无需直接与<strong>子系统</strong>交互，而只需要通过<strong>门面</strong>来与<strong>子系统</strong>进行通信。</p>
</blockquote>
<h2 id="模式的组成">模式的组成</h2>
<ul>
<li><strong>门面</strong>（<code>Facade</code>）：门面角色是门面模式的核心，它封装了系统内部复杂子系统的接口，为客户端提供一个简单的高层接口。门面角色知道哪些子系统负责处理请求，并将请求转发给相应的子系统进行处理。</li>
<li><strong>子系统</strong>（<code>Subsystem</code>）：子系统角色是实际执行系统功能的组件。每个子系统都有自己的职责和行为，通过门面角色对外提供服务。</li>
<li><strong>客户端</strong>（<code>Client</code>）：客户端角色通过调用门面角色提供的高层接口来使用系统功能，而无需直接与子系统交互。</li>
</ul>
<blockquote>
<p>在<strong>门面模式</strong>中，<strong>门面角色</strong>充当了<strong>客户端</strong>和<strong>子系统</strong>之间的<strong>中介者</strong>，<strong>隐藏了子系统的复杂性</strong>，<strong>简化了客户端的调用过程</strong>。<br>
<strong>客户端</strong>只需要与<strong>门面角色</strong>进行交互，而不需要了解和处理<strong>子系统的具体细节</strong>。</p>
</blockquote>
<ul>
<li>【特别注意】</li>
</ul>
<blockquote>
<ul>
<li><strong>门面对象</strong>只是提供一个<strong>访问子系统的一个路径</strong>而已，它不应该也不能参与具体的业务逻辑；</li>
<li>否则，就会产生一个<strong>倒依赖</strong>的问题：<strong>子系统</strong>必须<strong>依赖门面</strong>才能被访问，这是设计上一个<strong>严重错误</strong>，不仅会违反了<strong>单一职责原则</strong>，同时也破坏了<strong>系统的封装性</strong>。</li>
</ul>
</blockquote>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>当一个系统有很多复杂的子系统时，可以使用<strong>门面模式</strong>将其封装起来，<strong>隐藏内部复杂性</strong>，简化客户端的调用。</li>
<li>当需要将<strong>客户端</strong>与<strong>复杂的子系统</strong>做<strong>解耦</strong>，降低系统之间的依赖时，可以使用<strong>门面模式</strong>。</li>
</ul>
<h2 id="模式特点">模式特点</h2>
<h3 id="优点">优点</h3>
<ul>
<li>简化客户端的调用过程，<strong>隐藏了子系统的复杂性</strong>，提供了一个统一的接口，客户端无需了解子系统的具体实现。</li>
<li>减少系统的相互依赖，<strong>解耦</strong>了客户端与子系统之间的依赖关系。</li>
<li>提高了代码的<strong>可维护性和可读性</strong>。</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li>门面模式可能会导致<strong>门面类变得庞大</strong>，<strong>承担过多的责任</strong>。</li>
<li>如果需要<strong>修改子系统的功能</strong>，可能需要<strong>修改门面类</strong>。</li>
</ul>
<h2 id="门面模式的优化">门面模式的优化</h2>
<blockquote>
<p>在实际应用中，我们可以对门面模式进行一些优化和扩展。以下是几个常见的优化实现方式：</p>
</blockquote>
<h3 id="子系统解耦">子系统解耦</h3>
<ul>
<li><strong>门面类</strong>可以通过<strong>委托</strong>来<strong>调用子系统</strong>的功能，而不是<strong>直接依赖</strong>于<strong>具体的子系统</strong>。</li>
</ul>
<blockquote>
<p>这样可以使得<strong>子系统</strong>能够<strong>独立演化</strong>，不受<strong>门面类</strong>的影响。</p>
</blockquote>
<pre><code class="language-java">// 门面类
class Facade {
    private SubSystemInterface subSystemA;
    private SubSystemInterface subSystemB;

    public Facade() {
        subSystemA = new ConcreteSubSystemA();
        subSystemB = new ConcreteSubSystemB();
    }

    // 提供给客户端的接口
    public void operation() {
        subSystemA.operation();
        subSystemB.operation();
    }
}

// 子系统接口
interface SubSystemInterface {
    void operation();
}

// 具体的子系统A
class ConcreteSubSystemA implements SubSystemInterface {
    public void operation() {
        // 实现具体的功能
    }
}

// 具体的子系统B
class ConcreteSubSystemB implements SubSystemInterface {
    public void operation() {
        // 实现具体的功能
    }
}
</code></pre>
<h3 id="多个门面类">多个门面类</h3>
<ul>
<li>当<strong>门面</strong>已经<strong>庞大到不能忍受的程度</strong>，<strong>承担过多的责任</strong>时，可以考虑使用<strong>多个门面类</strong>。</li>
<li><strong>每个门面类</strong>负责与<strong>特定的子系统</strong>交互，原则上建议<strong>按照功能拆分</strong></li>
</ul>
<blockquote>
<blockquote>
<p>比如，一个数据库操作的门面可以拆分为查询门面、删除门面、更新门面等。</p>
</blockquote>
</blockquote>
<pre><code class="language-java">// 子系统A的门面类
class SubSystemAFacade {
    private SubSystemA subSystemA;

    public SubSystemAFacade() {
        subSystemA = new SubSystemA();
    }

    // 提供给客户端的接口
    public void operation() {
        subSystemA.operationA();
    }
}

// 子系统B的门面类
class SubSystemBFacade {
    private SubSystemB subSystemB;

    public SubSystemBFacade() {
        subSystemB = new SubSystemB();
    }

    // 提供给客户端的接口
    public void operation() {
        subSystemB.operationB();
    }
}
</code></pre>
<blockquote>
<p>通过上述优化实现方式，我们能够灵活地应对不同的需求和场景，提高了系统的可扩展性和维护性。</p>
</blockquote>
<h3 id="门面嵌套">门面嵌套</h3>
<ul>
<li>假设我们有一个<strong>文件处理系统</strong>，其中包括3个子系统：</li>
</ul>
<blockquote>
<p>文件读取(FileReader)、文件写入(FileWriter)和文件压缩(FileCompressor)。</p>
</blockquote>
<ul>
<li>现在有2个模块来访问该子系统：</li>
</ul>
<blockquote>
<ul>
<li><strong>通用模块</strong>（GeneralModule）可以完整地访问所有业务逻辑，而<strong>受限模块</strong>（RestrictedModule）只能访问文件读取操作。</li>
</ul>
</blockquote>
<ul>
<li>在这种情况下，我们可以在<strong>门面</strong>外再<strong>嵌套门面</strong>来解决<strong>接口权限问题</strong>，以供不同的模块访问。</li>
</ul>
<pre><code class="language-java">// 子系统：文件读取
class FileReader {
    public void read(String filePath) {
        System.out.println("读取文件：" + filePath);
        // 具体的读取逻辑...
    }
}

// 子系统：文件写入
class FileWriter {
    public void write(String filePath, String content) {
        System.out.println("写入文件：" + filePath);
        // 具体的写入逻辑...
    }
}

// 子系统：文件压缩
class FileCompressor {
    public void compress(String filePath, String destinationPath) {
        System.out.println("压缩文件：" + filePath + " -&gt; " + destinationPath);
        // 具体的压缩逻辑...
    }
}

// 通用模块门面
class GeneralFacade {
    private FileReader fileReader;
    private FileWriter fileWriter;
    private FileCompressor fileCompressor;

    public GeneralFacade() {
        this.fileReader = new FileReader();
        this.fileWriter = new FileWriter();
        this.fileCompressor = new FileCompressor();
    }

    public void processFile(String filePath, String content, String destinationPath) {
        fileReader.read(filePath);
        fileWriter.write(filePath, content);
        fileCompressor.compress(filePath, destinationPath);
    }
    
    public void read(String filePath) {
        fileReader.read(filePath);
    }
    
}

// 受限模块门面
class RestrictedFacade {
    private GeneralFacade generalFacade = new GeneralFacade();
    
    public void readRestrictedFile(String filePath) {
        generalFacade.read(filePath);
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        GeneralFacade generalFacade = new GeneralFacade();
        generalFacade.processFile("file.txt", "Hello World!", "compressed.zip");

        RestrictedFacade restrictedFacade = new RestrictedFacade();
        restrictedFacade.readRestrictedFile("file.txt");
    }
}
</code></pre>
<ul>
<li>在上述示例中，我们使用了2个<strong>不同的门面</strong>：<code>GeneralFacade</code>和<code>RestrictedFacade</code>。</li>
</ul>
<blockquote>
<ul>
<li><code>GeneralFacade</code>提供了<strong>完整的访问子系统的方法</strong>（<code>processFile</code>）</li>
<li>而<code>RestrictedFacade</code>仅提供了<strong>受限的文件读取方法</strong>（<code>readRestrictedFile</code>）</li>
</ul>
</blockquote>
<blockquote>
<p>通过<strong>不同的门面对象</strong>，<strong>通用模块</strong>可以访问所有子系统功能，而<strong>受限模块</strong>只能访问特定的子系统功能。</p>
</blockquote>
<h1 id="案例实践">案例实践</h1>
<h2 id="case-门面模式的简单实现">CASE 门面模式的简单实现</h2>
<h3 id="subsystema--subsystemb">SubSystemA / SubSystemB</h3>
<ul>
<li>子系统A</li>
</ul>
<pre><code class="language-java">// 子系统A
public class SubSystemA {
    public void operationA() {
        System.out.println("子系统A的操作");
    }
}
</code></pre>
<ul>
<li>子系统B</li>
</ul>
<pre><code class="language-java">public class SubSystemB {
    public void operationB() {
        System.out.println("子系统B的操作");
    }
}
</code></pre>
<ul>
<li>子系统C</li>
</ul>
<pre><code class="language-java">public class SubSystemC {
    public void operationC() {
        System.out.println("子系统C的操作");
    }
}
</code></pre>
<h3 id="facade门面类">Facade/门面类</h3>
<pre><code class="language-java">public class Facade {
    private SubSystemA subSystemA;
    private SubSystemB subSystemB;
    private SubSystemC subSystemC;

    public Facade() {
        subSystemA = new SubSystemA();
        subSystemB = new SubSystemB();
        subSystemC = new SubSystemC();
    }

    // 提供简单的接口给客户端调用，隐藏了子系统的复杂性
    public void operation() {
        subSystemA.operationA();
        subSystemB.operationB();
        subSystemC.operationC();
    }
}
</code></pre>
<h2 id="case-电商系统">CASE 电商系统</h2>
<ul>
<li>场景描述：</li>
</ul>
<blockquote>
<p>假设我们的<strong>电子商务系统</strong>包含了<strong>订单管理</strong>、<strong>库存管理</strong>和<strong>支付管理</strong>等子系统。<br>
为了<strong>简化客户端的调用过程</strong>，我们可以使用<strong>门面模式</strong>来封装这些子系统，并提供一个统一的接口。</p>
</blockquote>
<h3 id="orderservice订单管理子系统">OrderService/订单管理子系统</h3>
<pre><code class="language-java">// 订单管理子系统
class OrderService {
    public void createOrder() {
        // 创建订单的具体实现
    }
}
</code></pre>
<h3 id="inventoryservice库存管理子系统">InventoryService/库存管理子系统</h3>
<pre><code class="language-java">// 库存管理子系统
class InventoryService {
    public void checkStock() {
        // 检查库存的具体实现
    }
}
</code></pre>
<h3 id="paymentservice支付管理子系统">PaymentService/支付管理子系统</h3>
<pre><code class="language-java">// 支付管理子系统
class PaymentService {
    public void makePayment() {
        // 支付的具体实现
    }
}
</code></pre>
<h3 id="ecommercefacade电子商务门面类">ECommerceFacade/电子商务门面类</h3>
<pre><code class="language-java">// 电子商务门面类
class ECommerceFacade {
    private OrderService orderService;
    private InventoryService inventoryService;
    private PaymentService paymentService;

    public ECommerceFacade() {
        orderService = new OrderService();
        inventoryService = new InventoryService();
        paymentService = new PaymentService();
    }

    // 提供给客户端的接口
    public void placeOrder() {
        orderService.createOrder();
        inventoryService.checkStock();
        paymentService.makePayment();
    }
}
</code></pre>
<ul>
<li>我们创建了一个<strong>电子商务门面类</strong>（ECommerceFacade），它封装了订单管理、库存管理和支付管理等子系统，并提供了一个<strong>简单的接口</strong>（<code>placeOrder</code>）供客户端调用。</li>
</ul>
<blockquote>
<p>这样，客户端只需要通过门面类来完成下单操作，而无需直接与子系统交互。</p>
</blockquote>
<h2 id="case-shape形状接口-与-shapemaker形状创建器外观类">CASE Shape(形状接口) 与 ShapeMaker(形状创建器外观类)</h2>
<h3 id="场景描述">场景描述</h3>
<ul>
<li>我们将创建一个 <code>Shape</code> 接口和实现了 <code>Shape</code> 接口的实体类。下一步是定义一个外观类 <code>ShapeMaker</code>。</li>
<li><code>ShapeMaker</code> 类使用实体类来代表用户对这些类的调用。</li>
<li><code>FacadePatternDemo</code> 类使用 <code>ShapeMaker</code> 类来显示结果。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202504/1173617-20250422104301338-1000639160.png" alt="" loading="lazy"></p>
<h3 id="shape-抽象接口">Shape ：抽象接口</h3>
<pre><code class="language-java">public interface Shape {
   void draw();
}
</code></pre>
<h3 id="rectangle--square-具体的接口实现类子系统">Rectangle / Square ：具体的接口实现类（子系统）</h3>
<ul>
<li>Rectangle</li>
</ul>
<pre><code class="language-java">public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Rectangle::draw()");
   }
}
</code></pre>
<ul>
<li>Square</li>
</ul>
<pre><code class="language-java">public class Square implements Shape {
   @Override
   public void draw() {
      System.out.println("Square::draw()");
   }
}
</code></pre>
<ul>
<li>Circle</li>
</ul>
<pre><code class="language-java">public class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println("Circle::draw()");
   }
}
</code></pre>
<h3 id="shapemaker外观类">ShapeMaker（外观类）</h3>
<pre><code class="language-java">public class ShapeMaker {
   private Shape circle;
   private Shape rectangle;
   private Shape square;
 
   public ShapeMaker() {
      circle = new Circle();
      rectangle = new Rectangle();
      square = new Square();
   }
 
   public void drawCircle(){
      circle.draw();
   }
   public void drawRectangle(){
      rectangle.draw();
   }
   public void drawSquare(){
      square.draw();
   }
}
</code></pre>
<h3 id="facadepatterndemo">FacadePatternDemo</h3>
<ul>
<li>使用该外观类画出各种类型的形状。</li>
</ul>
<pre><code class="language-java">public class FacadePatternDemo {
   public static void main(String[] args) {
      ShapeMaker shapeMaker = new ShapeMaker();
 
      shapeMaker.drawCircle();
      shapeMaker.drawRectangle();
      shapeMaker.drawSquare();      
   }
}
</code></pre>
<blockquote>
<p>out</p>
</blockquote>
<pre><code class="language-log">Circle::draw()
Rectangle::draw()
Square::draw()
</code></pre>
<h1 id="y-推荐文献">Y 推荐文献</h1>
<ul>
<li><a href="https://www.cnblogs.com/johnnyzen/p/17189752.html" target="_blank">设计模式之总述 - 博客园/千千寰宇</a></li>
</ul>
<h1 id="x-参考文献">X 参考文献</h1>
<ul>
<li><a href="https://www.runoob.com/design-pattern/facade-pattern.html" target="_blank" rel="noopener nofollow">外观模式 - 菜鸟教程</a></li>
<li><a href="https://blog.csdn.net/bookssea/article/details/136146725" target="_blank" rel="noopener nofollow">一文搞懂设计模式—门面模式 - CSDN</a></li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <div class="essaySuffix-box">
    <div class="essaySuffix-box-left" style=" margin: 6px auto; ">
        <img src="https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148" alt="QQ沟通交流群" onload="changeImg(this,200,100)">
    </div>
<div class="essaySuffix-box-right">
    <span class="essaySuffix-right-title">本文作者</span>：
        <strong><span><a href="https://github.com/Johnny-ZTSD" target="_blank">千千寰宇</a></span></strong>
    <br>
    <span style="font-weight: bold; white-space:nowrap;">本文链接</span>：
        <a href="https://www.cnblogs.com/johnnyzen" target="_blank" id="articleLinkElement"> https://www.cnblogs.com/johnnyzen</a>
    <br>
    <span class="essaySuffix-right-title">关于博文</span>：评论和私信会在第一时间回复，或<a href="https://msg.cnblogs.com/msg/send/johnnyzen" target="_blank">直接私信</a>我。
    <br>
    <span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a title="https://creativecommons.org/licenses/by-nc-nd/4.0/" href="http://blog.sina.com.cn/s/blog_896327b90102y6c6.html" alt="BY-NC-SA" target="_blank">BY-NC-SA</a> 
    许可协议。转载请注明出处！<br>
    <span class="essaySuffix-right-title">日常交流</span>：大数据与软件开发-QQ交流群: 774386015<strong>
        <span style="color: #ff0000; font-size: 12pt;">【<a id="post-up" onclick="votePost(getArticleNumber(),'Digg')" href="javascript:void(0);">入群二维码</a>】</span></strong>参见左下角。您的支持、鼓励<span style="color: #ff0000; font-size: 12pt;"></span>是博主技术写作的重要动力！
    <br>
</div>
<div style="clear: both;">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2405442314525463" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-22 12:32">2025-04-22 12:11</span>&nbsp;
<a href="https://www.cnblogs.com/johnnyzen">千千寰宇</a>&nbsp;
阅读(<span id="post_view_count">30</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18840230);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18840230', targetLink: 'https://www.cnblogs.com/johnnyzen/p/18840230', title: '[设计模式/Java] 设计模式之门面模式(外观模式)【20】' })">举报</a>
</div>
        