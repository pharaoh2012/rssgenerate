
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/feffery/p/18970945" title="发布于 2025-07-07 16:36">
    <span role="heading" aria-level="2">Python全栈应用开发利器Dash 3.x新版本介绍（3）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<center style="font-size: 18px; font-weight: bold; padding-top: 40px">更多Dash应用开发干货知识、案例，欢迎关注“玩转Dash”微信公众号👇</center>
<p><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250703190053776-1837084116.png" alt="image" loading="lazy"></p>
<p>大家好我是费老师，在前两期文章中，我们针对<code>Python</code>生态中<u>强大</u>且<u>灵活</u>的<em>全栈应用开发</em>框架<code>Dash</code>，介绍了其<code>3.x</code>新版本中的<em>部分</em>更新内容🧐：</p>
<ul>
<li><a href="https://www.cnblogs.com/feffery/p/18964220" target="_blank">Python全栈应用开发利器Dash 3.x新版本介绍（1）</a></li>
<li><a href="https://www.cnblogs.com/feffery/p/18965946" target="_blank">Python全栈应用开发利器Dash 3.x新版本介绍（2）</a></li>
</ul>
<p>而今天的文章中，我们将继续介绍<code>Dash</code>3.x新版本中的其他重磅💥新功能，今天要介绍的是新版本中对<em>异步编程</em>的新增支持。</p>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250707163228828-424032401.png" width="50%"></center>
<h2 id="dash应用开发新增异步编程支持">Dash应用开发新增异步编程支持</h2>
<p>从<code>3.1.0</code>版本开始，得益于底层依赖的<code>Flask</code>当前对<em>异步编程</em>较为稳定的支持，在<code>Dash</code>中我们可以编写异步函数形式的<em>服务端回调函数</em>。终端执行下面的命令，即可完成<em>额外异步依赖</em>的安装：</p>
<pre><code class="language-bash">pip install dash[async] -U
</code></pre>
<p>对于了解<code>Python</code>异步编程的朋友，可以将应用中相关的计算场景轻松改造为<em>异步形式</em>，从而大幅度<em>降低计算耗时</em>，下面我们举例演示：</p>
<h3 id="异步形式的回调函数">异步形式的回调函数</h3>
<p>针对<em>服务端回调函数</em>场景，为了进行直观<em>对比</em>，我们先来看一个<em>同步写法</em>下的示例应用：</p>
<pre><code class="language-python">import time
import dash
import random
from dash import html
import feffery_antd_components as fac
from dash.dependencies import Input, Output
from feffery_dash_utils.style_utils import style

app = dash.Dash(__name__)

app.layout = html.Div(
    [
        fac.AntdSpace(
            [
                fac.AntdButton(
                    "执行计算",
                    id="execute",
                    type="primary",
                    loadingChildren="计算中",
                ),
                fac.AntdText(id="result"),
            ]
        )
    ],
    style=style(padding=50),
)


def job():
    time.sleep(1)

    return random.randint(0, 100)


@app.callback(
    Output("result", "children"),
    Input("execute", "nClicks"),
    running=[[Input("execute", "loading"), True, False]],
    prevent_initial_call=True,
)
def sync_callback_demo(nClicks):
    start = time.time()

    # 模拟耗时计算任务过程
    results = [job() for _ in range(5)]

    return f"本次计算结果：{results}, 计算耗时：{round(time.time() - start, 2)} 秒"


if __name__ == "__main__":
    app.run(debug=True)
</code></pre>
<p>在对应的回调函数<code>sync_callback_demo()</code>中，我们调用了<em>5次</em>具有一定模拟计算耗时的<code>job()</code>函数，因此每次点击按钮执行计算后，都要耗时约<em>5秒</em>：</p>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250707163231326-1848551773.gif"></center>
<p>而在<code>3.1.0</code>版本之后的<code>Dash</code>中，我们可以使用<code>Python</code>中的异步编程相关写法，编写<em>异步形式</em>的回调函数，与前面同步形式示例做对比，异步形式示例代码如下：</p>
<pre><code class="language-python">import time
import dash
import random
import asyncio
from dash import html
import feffery_antd_components as fac
from dash.dependencies import Input, Output
from feffery_dash_utils.style_utils import style

app = dash.Dash(__name__)

app.layout = html.Div(
    [
        fac.AntdSpace(
            [
                fac.AntdButton(
                    "执行计算",
                    id="execute",
                    type="primary",
                    loadingChildren="计算中",
                ),
                fac.AntdText(id="result"),
            ]
        )
    ],
    style=style(padding=50),
)


async def async_job():
    await asyncio.sleep(1)

    return random.randint(0, 100)


@app.callback(
    Output("result", "children"),
    Input("execute", "nClicks"),
    running=[[Input("execute", "loading"), True, False]],
    prevent_initial_call=True,
)
async def async_callback_demo(nClicks):
    start = time.time()

    # 模拟耗时计算任务过程
    coros = [async_job() for _ in range(5)]
    results = await asyncio.gather(*coros)

    return f"本次计算结果：{results}, 计算耗时：{round(time.time() - start, 2)} 秒"


if __name__ == "__main__":
    app.run(debug=True)
</code></pre>
<p>因为利用<code>asyncio.gather()</code>进行多个异步函数的整合执行，所以同样的计算操作，耗时得到有效降低，只需要约<em>1秒</em>：</p>
<center><img src="https://img2024.cnblogs.com/blog/1344061/202507/1344061-20250707163234976-2002512202.gif"></center>
<p>基于这项新特性，我们就可以在相关场景下进行有效的异步改造，从而提升计算效率⚡。</p>
<p>篇幅有限，更多新版本<code>Dash</code>更新相关内容，接下来的数篇文章我们继续为大家盘点，敬请期待~</p>
<hr>
<p>以上就是本文的全部内容，对<code>Dash</code>应用开发感兴趣的朋友，欢迎添加微信号<code>CNFeffery</code>，备注“dash学习”加入我们的技术交流群，一起成长一起进步。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-07 16:37">2025-07-07 16:36</span>&nbsp;
<a href="https://www.cnblogs.com/feffery">费弗里</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18970945);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18970945', targetLink: 'https://www.cnblogs.com/feffery/p/18970945', title: 'Python全栈应用开发利器Dash 3.x新版本介绍（3）' })">举报</a>
</div>
        