
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/nmblr/p/18710510" title="发布于 2025-02-11 21:23">
    <span role="heading" aria-level="2">LangChain基础篇 (05)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="langchain-核心模块data-conneciton---document-transformers">LangChain 核心模块：Data Conneciton - Document Transformers</h1>
<p>一旦加载了文档，通常会希望对其进行转换以更好地适应您的应用程序。</p>
<p>最简单的例子是，您可能希望将长文档拆分为较小的块，以适应模型的上下文窗口。LangChain具有许多内置的文档转换器，可以轻松地拆分、合并、过滤和其他操作文档。</p>
<h2 id="text-splitters-文本分割器">Text Splitters 文本分割器</h2>
<p>当你想处理长篇文本时，有必要将文本分成块。听起来很简单，但这里存在着潜在的复杂性。理想情况下，你希望将语义相关的文本片段放在一起。</p>
<p>从高层次上看，文本分割器的工作原理如下：</p>
<ol>
<li>将文本分成小而有意义的块（通常是句子）。</li>
<li>开始将这些小块组合成较大的块，直到达到某个大小（通过某个函数进行测量）。</li>
<li>一旦达到该大小，使该块成为自己独立的一部分，并开始创建一个具有一定重叠（以保持上下文关系）的新文本块。</li>
</ol>
<p>这意味着您可以沿两个不同轴向定制您的文本分割器：</p>
<p><strong>1. 如何拆分文字</strong><br>
<strong>2. 如何测量块大小</strong></p>
<h3 id="使用-recursivecharactertextsplitter-文本分割器">使用 <code>RecursiveCharacterTextSplitter</code> 文本分割器</h3>
<p>该文本分割器接受一个字符列表作为参数，根据第一个字符进行切块，但如果任何切块太大，则会继续移动到下一个字符，并以此类推。默认情况下，它尝试进行切割的字符包括 <code>["\n\n", "\n", " ", ""]</code></p>
<p>除了控制可以进行切割的字符外，您还可以控制其他一些内容：</p>
<ul>
<li>length_function：用于计算切块长度的方法。默认只计算字符数，但通常在这里传递一个令牌计数器。</li>
<li>chunk_size：您的切块的最大大小（由长度函数测量）。</li>
<li>chunk_overlap：切块之间的最大重叠部分。保持一定程度的重叠可以使得各个切块之间保持连贯性（例如滑动窗口）。</li>
<li>add_start_index：是否在元数据中包含每个切块在原始文档中的起始位置。</li>
</ul>
<h1 id="langchain-核心模块data-conneciton---text-embedding-models">LangChain 核心模块：Data Conneciton - Text Embedding Models</h1>
<p>Embeddings类是一个专门用于与文本嵌入模型进行交互的类。有许多嵌入模型提供者（OpenAI、Cohere、Hugging Face等）-这个类旨在为所有这些提供者提供一个标准接口。</p>
<p>嵌入将一段文本创建成向量表示。这非常有用，因为它意味着我们可以在向量空间中思考文本，并且可以执行语义搜索等操作，在向量空间中寻找最相似的文本片段。</p>
<p>LangChain中基础的Embeddings类公开了两种方法：<strong>一种用于对文档进行嵌入，另一种用于对查询进行嵌入。</strong>前者输入多个文本，而后者输入单个文本。之所以将它们作为两个独立的方法，是因为某些嵌入提供者针对要搜索的文件和查询（搜索查询本身）具有不同的嵌入方法。</p>
<h2 id="使用-openaiembeddings-调用-openai-嵌入模型">使用 OpenAIEmbeddings 调用 OpenAI 嵌入模型</h2>
<h3 id="使用-embed_documents-方法嵌入文本列表">使用 embed_documents 方法嵌入文本列表</h3>
<pre><code>from langchain_openai import OpenAIEmbeddings
</code></pre>
<pre><code>embeddings_model = OpenAIEmbeddings()
</code></pre>
<pre><code>embeddings = embeddings_model.embed_documents(
    [
        "Hi there!",
        "Oh, hello!",
        "What's your name?",
        "My friends call me World",
        "Hello World!"
    ]
)
</code></pre>
<h3 id="使用-embed_query-方法嵌入问题">使用 embed_query 方法嵌入问题</h3>
<p>嵌入一段文本，以便与其他嵌入进行比较:</p>
<pre><code>embedded_query = embeddings_model.embed_query("What was the name mentioned in the conversation?")
</code></pre>
<h1 id="langchain-核心模块data-conneciton---vector-stores">LangChain 核心模块：Data Conneciton - Vector Stores</h1>
<p>存储和搜索非结构化数据最常见的方法之一是将其嵌入并存储生成的嵌入向量，然后在查询时将非结构化查询进行嵌入，并检索与嵌入查询“最相似”的嵌入向量。</p>
<p>向量存储库负责为您存储已经过嵌入处理的数据并执行向量搜索。</p>
<p>下面以 <code>Chroma</code> 为例展示功能和用法</p>
<pre><code>## 使用 Chroma 作为向量数据库，实现语义搜索
</code></pre>
<pre><code>from langchain.document_loaders import TextLoader
from langchain_openai import OpenAIEmbeddings
from langchain.text_splitter import CharacterTextSplitter
from langchain.vectorstores import Chroma

# 加载长文本
raw_documents = TextLoader('../tests/state_of_the_union.txt',encoding='utf-8').load()
</code></pre>
<pre><code># 实例化文本分割器
text_splitter = CharacterTextSplitter(chunk_size=200, chunk_overlap=0)
</code></pre>
<pre><code># 分割文本
documents = text_splitter.split_documents(raw_documents)
</code></pre>
<pre><code>embeddings_model = OpenAIEmbeddings()
</code></pre>
<pre><code># 将分割后的文本，使用 OpenAI 嵌入模型获取嵌入向量，并存储在 Chroma 中
db = Chroma.from_documents(documents, embeddings_model)
</code></pre>
<h4 id="使用文本进行语义相似度搜索">使用文本进行语义相似度搜索</h4>
<pre><code>query = "What did the president say about Ketanji Brown Jackson"
docs = db.similarity_search(query)
print(docs[0].page_content)
</code></pre>
<h3 id="使用嵌入向量进行语义相似度搜索">使用嵌入向量进行语义相似度搜索</h3>
<pre><code>embedding_vector = embeddings_model.embed_query(query)
docs = db.similarity_search_by_vector(embedding_vector)
print(docs[0].page_content)
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/nmblr/" target="_blank">nmblr</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/nmblr/p/18710510" target="_blank">https://www.cnblogs.com/nmblr/p/18710510</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03511585085185185" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-11 21:24">2025-02-11 21:23</span>&nbsp;
<a href="https://www.cnblogs.com/nmblr">nmblr</a>&nbsp;
阅读(<span id="post_view_count">1</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18710510" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18710510);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18710510', targetLink: 'https://www.cnblogs.com/nmblr/p/18710510', title: 'LangChain基础篇 (05)' })">举报</a>
</div>
        