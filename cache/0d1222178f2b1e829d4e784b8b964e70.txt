
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18842084" title="发布于 2025-04-23 07:43">
    <span role="heading" aria-level="2">开源项目YtyMark文本编辑器--UI界面相关功能（关于设计模式的实战运用）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>🙌<strong>开源项目地址</strong></p>
<blockquote>
<p>🌍 <a href="https://github.com/yuantingyue/YtyMark-java" target="_blank" rel="noopener nofollow">GitHub 开源地址（YtyMark-java）</a></p>
</blockquote>
<p>欢迎提交 PR、Issue、Star ⭐️！</p>
<h2 id="1-简述">📌1. 简述</h2>
<p>YtyMark-java项目分为两大模块：</p>
<ul>
<li>
<p>UI界面（ytyedit-mark）</p>
</li>
<li>
<p>markdown文本解析和渲染（ytymark）</p>
</li>
</ul>
<p>本文主要内容为<strong>UI界面</strong>相关功能。</p>
<p>关于markdown文本解析器UI界面的实现。在这整个流程中，如果通过设计模式实现高内聚低耦合，可重用，易于阅读，易于扩展，易于维护等。</p>
<pre><code>YtyMark-java
├── ytyedit-mark/
│   ├── src/
│   │   ├── main/
│   │   │   ├── java/
│   │   │   │   ├── editor/             # JavaFX UI 界面
│   │   │   │   ├── enums/              # Icon图标等
│   │   │   │   ├── utils/              # 资源读取等
│   │   │   │   ├── window/             # 自定义窗口（主窗口、弹框）
│   │   │   │   ├── RenderMarkdown      # 解析和渲染
│   │   │   │   ├── YtyEditApplication  # 主程序入口
│   │   │   └── resources/
│   │   │       └── css/                # 主题样式（CSS）
│   │   │       └── fonts/              # 字体集
│   │   │       └── images/             # 图片
│   ├── README.md
│   └── pom.xml
</code></pre>
<h2 id="2-javafx-用户界面">🧩2. JavaFX 用户界面</h2>
<p><strong>目标</strong>：为用户提供可视化的文本输入、实时预览、编辑、保存、导出（PDF/HTML)和主题切换等功能。</p>
<p><strong>使用到的设计模式</strong>：</p>
<ul>
<li>
<p><strong>工厂模式</strong>：<strong>样式的创建</strong>通过工厂模式来完成。</p>
</li>
<li>
<p><strong>策略模式</strong>：动态选择工具界面样式，完成UI界面的<strong>样式切换</strong>。</p>
</li>
<li>
<p><strong>观察者模式</strong>：识别到主题发生变化时执行<strong>重新渲染</strong>操作；样式切换后，渲染的文字样式也需要同步调整，再结合监听器（观察者模式）来实现主题变化后重新渲染文本内容，除此之外JavaFX使用了大量的监听器。</p>
</li>
<li>
<p><strong>单例模式</strong>：主题样式管理器统一管理全局样式，并提供统一访问入口。</p>
</li>
<li>
<p><strong>装饰模式</strong>：对自定义基础弹框做<strong>定制化的扩展</strong>，实现不同场景所需的弹框。</p>
</li>
<li>
<p><strong>命令模式</strong>：封装工具界面中的功能点及快捷键命令。</p>
</li>
<li>
<p><strong>备忘录模式</strong>：负责实现<strong>撤销</strong>和<strong>恢复</strong>功能，实现精细到单字符的撤销/恢复机制。</p>
</li>
</ul>
<h3 id="21-工厂模式">2.1. 工厂模式</h3>
<p>通过工厂创建样式，将默认的样式创建好，统一放入Map中保存，需要时直接从工厂中获取。</p>
<pre><code class="language-java">public class StyleFactory {
    private static final Map&lt;Key, Style&gt; STYLE_MAP = new HashMap&lt;&gt;();

    // 预先注册默认样式
    static {
        registerStyle(WindowType.MAIN_WINDOW, ThemeType.LIGHT, new MainWindowLightStyle());
        registerStyle(WindowType.MAIN_WINDOW, ThemeType.DARK, new MainWindowDarkStyle());
        registerStyle(WindowType.DIALOG_WINDOW, ThemeType.LIGHT, new DialogWindowLightStyle());
        registerStyle(WindowType.DIALOG_WINDOW, ThemeType.DARK, new DialogWindowDarkStyle());
    }

    public static void registerStyle(WindowType type, ThemeType theme, Style style) {
        STYLE_MAP.put(new Key(type, theme), style);
    }

    public static Style getStyle(WindowType type, ThemeType theme) {
        Style style = STYLE_MAP.get(new Key(type, theme));
        if (style == null) {
            throw new RuntimeException("窗口类型或主题类型不支持: " + type + " - " + theme);
        }
        return style;
    }

    ...
}
</code></pre>
<h3 id="22-策略模式">2.2. 策略模式</h3>
<p>动态选择工具界面样式，完成UI界面的<strong>样式切换</strong>。并支持对已有窗口样式的自由组合，比如深色的主窗口+浅色的弹框。</p>
<p>使用<code>setTheme(ThemeType)</code>方法可以快速切换已经搭配好的<strong>主题</strong>；使用<code>setStyle</code>可以灵活指定不同窗口的样式。</p>
<pre><code class="language-java">public class ThemeContext {
    ...

    // 设置样式
    public void setTheme(ThemeType theme) {
        WindowType[] values = WindowType.values();
        for (WindowType windowType : values) {
            this.themeManager.setStyle(windowType, theme);
        }
    }

    // 自定义设置不同窗体不同样式
    public void setStyle(WindowType type, ThemeType theme) {
        this.themeManager.setStyle(type, theme);
    }

    // 主题切换
    public void switchTheme() {
        // 清空之前的样式
        scene.getStylesheets().clear();
        this.themeManager.applyStyle(WindowType.MAIN_WINDOW, scene);
    }

}
</code></pre>
<h3 id="23-观察者模式和单例模式">2.3. 观察者模式和单例模式</h3>
<p>识别到主题发生变化时执行<strong>重新渲染</strong>操作。样式切换后，渲染的文字样式也需要同步调整，结合监听器（观察者模式）来实现主题变化后重新渲染文本内容，除此之外JavaFX使用了大量的监听器。</p>
<p>自定义的<strong>主题监听器</strong>接口：</p>
<pre><code class="language-java">public interface ThemeChangeListener {
    void onThemeChanged();
}
</code></pre>
<p>主题监听器将有<strong>主题管理类</strong>来统一管理，并结合<strong>单例模式</strong>，使得主题管理器全局唯一，并提供统一访问入口<code>ThemeManager.getInstance()</code>。</p>
<pre><code class="language-java">public class ThemeManager {

    private static ThemeManager instance;
    private final Map&lt;WindowType, Style&gt; currentStyles = new HashMap&lt;&gt;();
    private final List&lt;ThemeChangeListener&gt; listeners = new ArrayList&lt;&gt;();


    private ThemeManager() {
        // 默认主窗口白天模式，弹窗白色模式
        currentStyles.put(WindowType.MAIN_WINDOW, new MainWindowLightStyle());
        currentStyles.put(WindowType.DIALOG_WINDOW, new DialogWindowLightStyle());
    }

    public static ThemeManager getInstance() {
        if (instance == null) {
            instance = new ThemeManager();
        }
        return instance;
    }

    public void setStyle(WindowType type, ThemeType theme) {
        currentStyles.put(type, StyleFactory.getStyle(type, theme));
        // 通知所有观察者主题已变更
        this.notifyThemeChanged();
    }

    ...

    // 注册观察者
    public void addThemeChangeListener(ThemeChangeListener listener) {
        listeners.add(listener);
    }
    // 注销观察者
    public void removeThemeChangeListener(ThemeChangeListener listener) {
        listeners.remove(listener);
    }

    // 通知所有观察者
    private void notifyThemeChanged() {
        for (ThemeChangeListener listener : listeners) {
            listener.onThemeChanged();
        }
    }
}
</code></pre>
<p><strong>通用弹框</strong>和<strong>渲染处理类</strong>实现了监听器接口，在创建时注册到监听器中</p>
<pre><code class="language-java">public class GenericDialog implements ThemeChangeListener {

    public GenericDialog(Stage owner) {
        ...

        this.themeManager.addThemeChangeListener(this);

        ...
    }

    /**
     * 订阅主题样式变更，主题变更后自动切换弹窗样式
     */
    @Override
    public void onThemeChanged() {
        // 清空之前的样式
        dialogScene.getStylesheets().clear();
        themeManager.applyStyle(WindowType.DIALOG_WINDOW,dialogScene);
    }
}
</code></pre>
<p>渲染处理类监听相关源码</p>
<pre><code class="language-java">public class RenderMarkdown  implements ThemeChangeListener {
    public RenderMarkdown(Tab tab) {
        ...

        // 注册自己为 ThemeContext 的监听者
        ThemeManager.getInstance().addThemeChangeListener(this);

        ...
    }
    /**
     * 订阅主题样式变更，主题变更后自动重新渲染内容
     */
    @Override
    public void onThemeChanged() {
        // 主题变更后自动渲染
        renderMarkdown(null);
    }
}
</code></pre>
<h3 id="24-装饰模式">2.4. 装饰模式</h3>
<p>对自定义基础弹框做<strong>定制化的扩展</strong>，实现不同场景所需的弹框。弹框装饰类通过组合的方式，对通用弹框做定制化设置</p>
<pre><code class="language-java">public abstract class DialogDecorator {
    private GenericDialog dialog;

    public DialogDecorator(GenericDialog dialog) {
        this.dialog = dialog;
    }

    public void removeLogo(boolean flag){
        dialog.removeLogo(flag);
    }
    // 委托设置标题
    public void setTitle(String title) {
        dialog.setTitle(title);
    }

    // 委托设置主体内容
    public void setContent(Node content) {
        dialog.setContent(content);
    }

    // 委托添加内容
    public void addContent(Node node) {
        dialog.addContent(node);
    }

    // 委托设置底部按钮区域
    public void setFooter(Node node) {
        dialog.setFooter(node);
    }

    // 委托添加底部按钮
    public void addFooter(Node node) {
        dialog.addFooter(node);
    }

    // 显示并阻塞，返回用户操作结果
    public void showAndWait() {
        dialog.showAndWait();
    }

}
</code></pre>
<h3 id="25-命令模式和备忘录模式">2.5. 命令模式和备忘录模式</h3>
<p>封装工具界面中的功能点及快捷键命令。备忘录模式负责实现<strong>撤销</strong>和<strong>恢复</strong>功能，实现精细到单字符的撤销/恢复机制，主要涉及的类：管理文本状态<code>TextEditorOriginator</code>、管理撤销和恢复的栈<code>UndoRedoCaretaker</code>。</p>
<pre><code class="language-java">public class UndoRedoCaretaker {

    private Deque&lt;TextMemento&gt; undoStack = new ArrayDeque&lt;&gt;();
    private Deque&lt;TextMemento&gt; redoStack = new ArrayDeque&lt;&gt;();
    private TextEditorOriginator originator;
    private boolean isUndoRedo = false;
    private static final int MAX_HISTORY = 1000; // 最多保存 1000 步

    public UndoRedoCaretaker(TextEditorOriginator originator) {
        this.originator = originator;
        // 存入初始状态，确保撤销可用
        undoStack.push(originator.save());
    }

    // 保存
    public void saveState(String text, int caretPosition) {
       ...
    }

    // 撤销
    public void undo() {
        ...
    }
    // 恢复
    public void redo() {
        ...
    }
    public boolean isUndoRedo() {
        return isUndoRedo;
    }
    public void clear() {
        undoStack.clear();
        redoStack.clear();
    }

}
</code></pre>
<h2 id="-3-界面截图预览">📸 3. 界面截图预览</h2>
<h3 id="白天模式的截图">白天模式的截图：</h3>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202504/1209017-20250423074136627-1843893337.jpg" alt="image" loading="lazy"></p>
<h3 id="夜间模式的截图">夜间模式的截图：</h3>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202504/1209017-20250423074148456-936705160.jpg" alt="image" loading="lazy"></p>
<h2 id="️4-总结">✏️4. 总结</h2>
<p>YtyMark 编辑器界面UI相关功能，将多种设计模式融入到实际应用中，从实践中积累程序设计经验。</p>
<p>更多详细内容可以前往笔者微信公众号回复：<strong>设计模式</strong>，来获取，后续有关设计模式的新资料都可以从这个入口获取到。</p>
<ul>
<li>
<p><strong>秘籍1</strong>设计模式手册：《掌握设计模式：23种经典模式实践、选择、价值与思想》</p>
</li>
<li>
<p><strong>秘籍2</strong>练手项目：设计模式实战项目--markdown文本编辑器软件开发（<strong>已开源</strong>）</p>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202504/1209017-20250423074201108-336561464.gif" alt="image" loading="lazy"></p>
<p>查看往期设计模式文章的：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5NDM5NDM1NA==&amp;action=getalbum&amp;album_id=3572346739375538182#wechat_redirect" target="_blank" rel="noopener nofollow">设计模式</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>
<p>三连支持！！！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.19839573024537038" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-23 07:43">2025-04-23 07:43</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">48</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18842084);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18842084', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18842084', title: '开源项目YtyMark文本编辑器--UI界面相关功能（关于设计模式的实战运用）' })">举报</a>
</div>
        