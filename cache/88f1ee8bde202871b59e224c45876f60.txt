
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Tangtang1997/p/18623843" title="发布于 2024-12-23 14:06">
    <span role="heading" aria-level="2">在.NET Core中使用异步多线程高效率的处理大量数据的最佳实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#一引言" rel="noopener nofollow">一、引言</a></li><li><a href="#二假设场景" rel="noopener nofollow">二、假设场景</a></li><li><a href="#三解决方案" rel="noopener nofollow">三、解决方案</a></li><li><a href="#四示例代码" rel="noopener nofollow">四、示例代码</a></li></ul></div><p></p>
<h2 id="一引言">一、引言</h2>
<p>处理大量数据是一个常见的需求，传统的同步处理方式往往效率低下，尤其是在数据量非常大的情况下。本篇将介绍一种高效的多线程异步处理大数据量的方法，通过边处理边消费的方式，极大地提高了处理效率，并且减少了内存开销。这种解决方案只是实现这一需求的一种实践，并不排除还有其他方式可以实现。如果您有任何问题或建议，欢迎在评论区留言讨论。</p>
<h2 id="二假设场景">二、假设场景</h2>
<p>假设我们有一个需要处理大量图片文件的应用程序。每个图片文件都需要进行压缩、调整等复杂的计算和数据处理。由于图片文件数量庞大，如果按同步方式处理，不仅速度慢，而且会占用大量内存。为了解决这个问题，我们采用了多线程异步处理的方式。</p>
<h2 id="三解决方案">三、解决方案</h2>
<p>我们可以使用 .NET 的 <strong>异步编程模型</strong> 和 <a href="https://learn.microsoft.com/zh-cn/dotnet/core/extensions/channels" target="_blank" rel="noopener nofollow">Channel</a> 来实现生产者-消费者模式。生产者负责读取图片文件并将其写入到<code>Channel</code>中，消费者从<code>Channel</code>中读取图片文件并进行处理。通过这种方式，我们可以边读取边处理，极大地提高了处理效率。</p>
<p><strong>以下是解决问题的思路和方案：</strong></p>
<ol>
<li>定义生产者和消费者：
<ul>
<li>生产者负责读取图片文件，并将其写入到<code>Channel</code>中</li>
<li>消费者从<code>Channel</code>中读取图片文件，并对其进行处理（如压缩、调整大小等）</li>
</ul>
</li>
<li>使用<code>Channel</code>实现生产者-消费者模式：
<ul>
<li><code>Channel</code>是 .NET 提供的一种用于实现生产者-消费者模式的高效数据结构</li>
<li>生产者将数据写入<code>Channel</code>，消费者从<code>Channel</code>中读取数据</li>
</ul>
</li>
<li>并行处理：
<ul>
<li>使用<code>Task.Run</code>启动多个生产者和消费者任务，以实现并行处理</li>
<li>通过设置最大并行度来控制同时运行的任务数量</li>
</ul>
</li>
<li>异步编程：
<ul>
<li>使用<code>async</code>和<code>await</code>关键字实现异步编程，以避免阻塞线程。</li>
<li>异步编程可以提高应用程序的响应速度和吞吐量</li>
</ul>
</li>
</ol>
<p><strong>涉及技术点介绍：</strong></p>
<ul>
<li><code>Channel</code>：用于在生产者和消费者之间传递数据，支持高效的并发操作</li>
<li><code>Task</code>：用于启动并行任务，实现多线程处理</li>
<li><code>async/await</code>：用于实现异步编程，避免阻塞线程，提高应用程序的响应速度</li>
</ul>
<h2 id="四示例代码">四、示例代码</h2>
<p>以下是一个简单的示例代码，演示如何使用<code>Channel</code>实现生产者-消费者模式来处理图片文件：</p>
<pre><code class="language-csharp">using System.Threading.Channels;

var cts = new CancellationTokenSource();
// 假设有一组图片文件
var imageFiles = new List&lt;string&gt;
{
    // ...
};

var processor = new ImageProcessor(10, cts.Token);
await processor.ProcessAsync(imageFiles);

Console.ReadKey();

/// &lt;summary&gt;
/// 图片处理器
/// &lt;/summary&gt;
/// &lt;param name="maxDegreeOfParallelism"&gt;最大并行度&lt;/param&gt;
/// &lt;param name="cancellationToken"&gt;CancellationToken&lt;/param&gt;
public class ImageProcessor(int maxDegreeOfParallelism, CancellationToken cancellationToken)
{
    public async Task ProcessAsync(List&lt;string&gt; imageFiles)
    {
        // 创建一个无界的 Channel
        var channel = Channel.CreateUnbounded&lt;string&gt;();

        // 启动多个生产者任务
        var producerTasks = imageFiles.Select(imageFile =&gt; Task.Run(() =&gt; Producer(imageFile, channel.Writer), cancellationToken)).ToArray();

        // 启动多个消费者任务
        var consumerTasks = Enumerable.Range(0, maxDegreeOfParallelism)
            .Select(_ =&gt; Task.Run(() =&gt; Consumer(channel.Reader), cancellationToken))
            .ToArray();

        // 等待所有生产者任务完成
        await Task.WhenAll(producerTasks); 
        // 完成 Channel 的写入
        channel.Writer.Complete();
        // 等待所有消费者任务完成
        await Task.WhenAll(consumerTasks);
    }

    private async Task Producer(string imageFile, ChannelWriter&lt;string&gt; writer)
    {
        try
        {
            // 模拟读取图片文件
            await Task.Delay(100, cancellationToken);
            // 将图片文件路径写入 Channel
            await writer.WriteAsync(imageFile, cancellationToken);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Producer error: {ex.Message}");
        }
    }

    private async Task Consumer(ChannelReader&lt;string&gt; reader)
    {
        try
        {
            // 从 Channel 中读取数据并处理
            await foreach (var imageFile in reader.ReadAllAsync(cancellationToken))
            {
                // 模拟处理图片文件（如压缩、调整大小等）
                await Task.Delay(100, cancellationToken);
                Console.WriteLine($"Processed image file: {imageFile}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Consumer error: {ex.Message}");
        }
    }
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.027181316069444444" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-23 14:19">2024-12-23 14:06</span>&nbsp;
<a href="https://www.cnblogs.com/Tangtang1997">贾光辉</a>&nbsp;
阅读(<span id="post_view_count">32</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18623843" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18623843);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18623843', targetLink: 'https://www.cnblogs.com/Tangtang1997/p/18623843', title: '在.NET Core中使用异步多线程高效率的处理大量数据的最佳实践' })">举报</a>
</div>
        