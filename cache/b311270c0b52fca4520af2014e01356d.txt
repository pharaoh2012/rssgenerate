
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fiveyobody/p/19007998/go-pprof-record-1" title="发布于 2025-07-27 22:07">
    <span role="heading" aria-level="2">实操使用 go pprof 对生产环境进行性能分析（问题定位及代码优化）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        实操使用 go pprof 对生产环境进行性能分析（问题定位及代码优化）
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="简介">简介</h2>
<p>最近服务器有个小功能 go 进程 内存占用突然变得很高，正好使用 go pprof 实操进行性能分析排查解决</p>
<p><img alt="go pprof 排查性能" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250727220640520-1927129534.png" class="lazyload"></p>
<blockquote>
<p>这是个极小的服务，但是占用内存超过了 100MB，而且本身服务器内存就比较吃紧，因此尝试使用 pprof 进行性能分析，看看能不能优化到 50 MB 以内</p>
</blockquote>
<p>关于 pprof 的使用教程，请移步文章：<a href="https://blog.fiveyoboy.com/articles/go-pprof/" target="_blank" rel="noopener nofollow">Golang 性能分析神器 pprof 详解与实践（图文教程）</a></p>
<p>接下来使用 go pprof 进行实操性能分析排查</p>
<h2 id="一开启-pprof">一、开启 pprof</h2>
<p>在项目启动时开启 pprof</p>
<p>导包：_ "net/http/pprof"</p>
<p>启动：http.ListenAndServe(":30552", nil)</p>
<p>参考代码如下</p>
<pre><code class="language-go">import _ "net/http/pprof"
func StartPprof() {
    go func() {
        logs.Info(http.ListenAndServe(":30552", nil))
    }()
    // 查看哪些函数占用内存比较多
    // go tool pprof -http=localhost:8081 -seconds=10 http://0.0.0.0:30552/debug/pprof/heap # 内存堆栈分析
    // go tool pprof -http=localhost:8081 -seconds=10 http://0.0.0.0:30552/debug/pprof/allocs # 内存分配分析

    // 查看哪些函数占用耗时比较多
    // go tool pprof -http=localhost:8081 -seconds=60 http://0.0.0.0:30552/debug/pprof/profile  # 耗时分析

    // go tool pprof -http=localhost:8081 -seconds=60 http://0.0.0.0:30552/debug/pprof/goroutine  # 协程分析
    // go tool pprof -http=localhost:8081 -seconds=10 http://0.0.0.0:30552/debug/pprof/block  # 阻塞分析
    // go tool pprof -http=localhost:8081 -seconds=10 http://0.0.0.0:30552/debug/pprof/mutex  # 锁分析
}
func main(){
  ....
  StartPprof()
  err = router.Run(address)
    if err != nil {
        panic(err)
    }
  ....
}
</code></pre>
<h2 id="二内存堆栈分析">二、内存堆栈分析</h2>
<p>分析哪些函数一直在占用内存</p>
<h3 id="一问题分析">（一）问题分析</h3>
<pre><code class="language-bash">go tool pprof -http=0.0.0.0:8081 http://0.0.0.0:30552/debug/pprof/heap
</code></pre>
<blockquote>
<p>这里我没有加 -seconds ,表示采样数据为：进程启动以来的总数据， 具体参数的使用：<a href="https://blog.fiveyoboy.com/articles/go-pprof/#%E4%B8%89%E7%94%A8%E6%B3%95%E4%BA%8Cgo-tool-pprof%E6%8E%A8%E8%8D%90" target="_blank" rel="noopener nofollow">Golang 性能分析神器 pprof 详解与实践（图文教程）</a></p>
</blockquote>
<p>浏览器会自动打开：0.0.0.0:8081/ui</p>
<p>如下图<br>
<img alt="go 内存堆栈分析火焰图" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250727220640521-857484221.png" class="lazyload"></p>
<p>从图中可以看到：又红又粗的函数有：</p>
<ul>
<li>webdav(*memFile) Write</li>
</ul>
<p>通过箭头查看上下的调用链接，可以发现  swaggerFiles init 调用了此函数，通过搜索查看代码，分析服务中确实是使用了 gin-swagger，但是这个项目其实没必要</p>
<p>解决：注释掉这块代码</p>
<ul>
<li>embedFS</li>
</ul>
<p>同样通过箭头查看上下的调用链接，发现有个 base64Captcha 调用，这是因为服务使用了一个第三方的验证码生成的包 <code>github.com/mojocn/base64Captcha</code></p>
<p><code>embedFS</code> 很明显是加载了文件，通过查看代码发现确实是加载了 fonts 字体</p>
<p><img alt="pprof 内存堆栈优化分析" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250727220640594-1567184686.png" class="lazyload"></p>
<blockquote>
<p>加载的字体大概有 5.9MB</p>
</blockquote>
<p>解决：替换包，或者直接去掉验证码，我这里就选择一些比较轻量级的包做了替换</p>
<h3 id="二总结">（二）总结</h3>
<p>从火焰图上看，总体的内存堆栈不算太高，不过通过排查可以看到存在一些项目不需要的，但是有占用内存的函数/包，还是可以优化减少内存的占用，</p>
<p>通过以上的代码优化之后，重启并且观察一段时间后，内存确实稳定下降了一些</p>
<p><img alt="优化后的内存占用" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250727220640545-1853731299.png" class="lazyload"></p>
<h2 id="三内存分配分析">三、内存分配分析</h2>
<p>分析哪些函数一直在分配内存</p>
<p>内存分配比较多比较频繁的函数会导致内存突然飙高，内存分配不同于内存堆栈，内存堆栈是常驻内存，</p>
<p>具体区别请移步文章：<a href="https://blog.fiveyoboy.com/articles/go-pprof/#2-%E5%86%85%E5%AD%98%E5%A0%86%E6%A0%88%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener nofollow">Golang 性能分析神器 pprof 详解与实践（图文教程</a></p>
<h3 id="一问题分析-1">（一）问题分析</h3>
<pre><code class="language-bash">go tool pprof -http=0.0.0.0:8081 http://0.0.0.0:30552/debug/pprof/allocs
</code></pre>
<blockquote>
<p>浏览器会自动打开：0.0.0.0:8081/ui</p>
</blockquote>
<p>如下图</p>
<p><img alt="内存分配分析" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250727220640557-1092102431.png" class="lazyload"></p>
<blockquote>
<p>火焰图有点大，只截取了有问题的部分</p>
</blockquote>
<p>从图中可以看到：又红又粗的函数有：</p>
<ul>
<li>
<p>webdav(*memFile) Write + embedFS</p>
<p>这里看不出来这两个函数的调用，我们可以切换为 <code>top</code> 视图（左上角菜单 view 中），就可以看到完整文件位置。</p>
<p>解决：这个在上一步骤【内存堆栈分析】中就已经做了分析处理（注：代码发布后确实已修复）</p>
</li>
<li>
<p>DBUpdateCronTask</p>
<p>这里很有可能是索引没有生效，导致锁全表了</p>
<p>解决：通过对 update where 条件进行索引优化即可</p>
</li>
<li>
<p>go.Marshal</p>
<p>这里用 go 标准库的 json 序列化操作，看起来分配内存也不算太多，不过我们可以优化为第三方包，性能更佳</p>
<p>解决：全局替换包 <code>encoding/json</code> 为<code>github.com/json-iterator/go</code></p>
</li>
<li>
<p>fmt.Sprintf</p>
</li>
</ul>
<p>通过排查代码，发现 FmtContent 中使用 fmt.Sprintf ，并且做了大量字符串的拼接，</p>
<p>解决：字符串拼接优化为使用 ：strings.Builder</p>
<p>关于字符串拼接性能请移步文章：<a href="https://blog.fiveyoboy.com/articles/go-concat-string/" target="_blank" rel="noopener nofollow">Go语言字符串拼接性能对比与最佳实践 - 深度优化指南</a></p>
<h3 id="二总结-1">（二）总结</h3>
<p>从火焰图上看，总体的内存分配不算太高，不过仍然有优化空间</p>
<p>通过以上的代码优化之后，重启并且观察一段时间后，内存成功下降到了 50MB 以内</p>
<p><img alt="内存分配优化结果" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250727220640466-143845146.png" class="lazyload"></p>
<h2 id="四cpu-耗时分析">四、CPU 耗时分析</h2>
<p>这里从 top 可以看出其实并没有什么 CPU 飙高的情况，不过既然都优化了，就顺便看看哪些函数在占用吧</p>
<h3 id="一问题分析-2">（一）问题分析</h3>
<pre><code class="language-bash">go tool pprof -http=0.0.0.0:8081 http://0.0.0.0:30552/debug/pprof/profile
</code></pre>
<p>从火焰图上没看到什么耗时比较异常的函数</p>
<h3 id="二总结-2">（二）总结</h3>
<p>从 top 没看到CPU异常，火焰图也没有异常，如果存在异常，排查和优化的方法和前面内存的步骤是一样的</p>
<h2 id="五协程分析">五、协程分析</h2>
<p>分析程序开启的协程情况</p>
<h3 id="一问题分析-3">（一）问题分析</h3>
<p>浏览器直接打开以下命令</p>
<pre><code class="language-bash">http://0.0.0.0:30552/debug/pprof/goroutine?debug=1  # 协程总览
http://0.0.0.0:30552/debug/pprof/goroutine?debug=2  # 协程详情
</code></pre>
<p>界面展示说明如下：</p>
<p><img alt="pprof 协程分析" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250727220640451-714810198.png" class="lazyload"></p>
<p><img alt="pprof协程分析结果" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3419240/202507/3419240-20250727220640576-1357353420.png" class="lazyload"></p>
<p><strong>从上面界面的数据进行分析</strong>：</p>
<ol>
<li>
<p>协程总数量为：27（不算多，但是需要看下每个协程的堆栈情况）</p>
</li>
<li>
<p>从 debug=2 的信息中查看每个协程的情况，发现其他都是正常的，有 main、 pprof 、cron、业务等启动的协程</p>
<p>但是存在一个协程【44】：从堆栈上看，这并不是我服务所需的，通过查看这个堆栈定位到代码的地方，发现之前做链路追踪测试时确实导入这个  <code>go.opentelemetry.io</code>包</p>
<p>但是实际没有任何功能作用</p>
<p>解决：直接注释掉相关的代码和导包</p>
</li>
</ol>
<h3 id="二总结-3">（二）总结</h3>
<p>通过界面先查询协程数量是不是太多，过多可能存在泄漏的情况，再通过 debug=2 界面查看每个协程的执行情况，是否非业务所需但是仍旧执行/阻塞，</p>
<p>然后根据堆栈定位代码，然后优化即可</p>
<h2 id="总结">总结</h2>
<p>通过启动 pprof 服务，并且通过 go tool pprof 以及 pprof 内部提供的服务接口对 CPU、内存堆栈、内存分配、协程 等指标进行分析，定位问题函数，优化代码</p>
<p>定位问题函数时，优化后可以先本地做单元测试、压力测试、pprof 测试，具体步骤请查看文章：</p>
<p><a href="https://blog.fiveyoboy.com/articles/go-testing-benchmark/" target="_blank" rel="noopener nofollow">go 如何进行 Benchmark 基准测试</a></p>
<p><a href="https://blog.fiveyoboy.com/articles/go-pprof/" target="_blank" rel="noopener nofollow">Golang 性能分析神器 pprof 详解与实践（图文教程）</a></p>
<p><strong>原文地址</strong></p>
<p><a href="https://blog.fiveyoboy.com/articles/go-pprof-record-1" target="_blank" rel="noopener nofollow">实操使用 go pprof 对生产环境进行性能分析（问题定位及代码优化）</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-27 22:07">2025-07-27 22:07</span>&nbsp;
<a href="https://www.cnblogs.com/fiveyobody">五岁小孩</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19007998);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19007998', targetLink: 'https://www.cnblogs.com/fiveyobody/p/19007998/go-pprof-record-1', title: '实操使用 go pprof 对生产环境进行性能分析（问题定位及代码优化）' })">举报</a>
</div>
        