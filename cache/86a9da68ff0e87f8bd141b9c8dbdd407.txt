
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xiongze520/p/18877124" title="发布于 2025-05-15 16:53">
    <span role="heading" aria-level="2">开发实用小技巧：元组-轻量级数据容器的艺术</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1 data-pm-slice="1 1 []">前言</h1>
<blockquote>
<p data-pm-slice="1 1 []"><span style="color: rgba(0, 0, 0, 1); font-size: 15px; background-color: initial">本文系统性的覆盖了元组</span><span style="color: rgba(0, 0, 0, 1); font-size: 15px; background-color: initial">的完整知识体系，</span><span style="background-color: initial; color: rgba(0, 0, 0, 1); font-size: 15px">采用"基础概念→实战技巧→进阶场景"的结构说明，包含多个场景代码示例和性能优化建议。</span></p>
<p data-pm-slice="1 1 []"><span style="font-size: 15px; color: rgba(0, 0, 0, 1)">主要重点在于"<strong>解构运算符</strong>"和"<strong>模式匹配</strong>"这两个革命性特性，它们能显著提升代码可读性。</span></p>
<p data-pm-slice="1 1 []"><span style="font-size: 15px; color: rgba(0, 0, 0, 1)">建议临时数据交互、LINQ结果封装等场景优先使用元组，但对于长期稳定的数据结构，仍推荐使用正式类/结构体定义。</span></p>
<p data-pm-slice="1 1 []"><span style="font-size: 15px; color: rgba(0, 0, 0, 1)">下述代码示例均基于.NET 6验证通过，可直接用于生产环境。</span></p>
</blockquote>
<p>&nbsp;</p>
<h1 data-pm-slice="1 1 []">简单应用</h1>
<p><span style="font-size: 15px">对于一些简单场景，元组可以避免创建大量的DTO。</span></p>
<p data-pm-slice="1 3 []"><img src="https://img2024.cnblogs.com/blog/1093832/202505/1093832-20250515103448802-524041599.png" alt="" loading="lazy"></p>
<h1 data-pm-slice="1 1 []">元组的核心概念</h1>
<p data-pm-slice="1 1 []"><span style="font-size: 15px">元组(Tuple)是C# 7.0引入的革命性特性，本质是轻量级临时数据结构。与传统Tuple类不同，新式ValueTuple是值类型，具有更优性能。其核心价值体现在：</span></p>
<ol class="tight" data-tight="true">
<li>
<p><span style="font-size: 15px"><strong>临时数据聚合</strong>：无需定义临时类即可组合多个数据元素</span></p>
</li>
<li>
<p><span style="font-size: 15px"><strong>方法多返回值</strong>：突破单个返回值的限制</span></p>
</li>
<li>
<p><span style="font-size: 15px"><strong>模式匹配友好</strong>：与C#模式语法天然契合</span></p>
</li>
</ol>
<p data-pm-slice="1 1 []"><span style="font-size: 15px">基础声明示例</span></p>
<div class="cnblogs_code">
<pre> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 匿名元组（隐式命名）</span>
 <span style="color: rgba(0, 0, 255, 1)">var</span> implicitTuple = (<span style="color: rgba(128, 0, 128, 1)">100</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Hello</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">); 
 Console.WriteLine(implicitTuple.Item1);

 </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 命名元组（推荐方式）</span>
 <span style="color: rgba(0, 0, 255, 1)">var</span> namedTuple = (Id: <span style="color: rgba(128, 0, 128, 1)">100</span>, Message: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Hello</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
 Console.WriteLine(namedTuple.Message);</span></pre>
</div>
<h1><strong>关键性能指标</strong></h1>
<table>
<thead>
<tr><th>特性</th><th>System.Tuple（引用类型元组）</th><th>ValueTuple（值类型元组）</th><th>类实例（Class）</th><th>结构体（Struct）</th></tr>
</thead>
<tbody>
<tr>
<td>‌内存分配位置‌</td>
<td>堆</td>
<td>栈</td>
<td>堆</td>
<td>栈</td>
</tr>
<tr>
<td>‌内存占用‌</td>
<td>高（含对象头+引用开销）<span class="cos-tooltip cosd-citation">2</span></td>
<td>低（仅存储值）<span class="cos-tooltip cosd-citation">5</span></td>
<td>高</td>
<td>最低</td>
</tr>
<tr>
<td>‌创建耗时‌</td>
<td>100%（基准）</td>
<td>35%<span class="cos-tooltip cosd-citation"><br></span></td>
<td>110%</td>
<td>30%</td>
















</tr>
<tr>
<td>‌修改灵活性‌</td>
<td>❌不可变</td>
<td>✔️可变</td>
<td>✔️可变</td>
<td>✔️可变</td>
















</tr>
<tr>
<td>‌GC压力‌</td>
<td>高（触发GC回收）<span class="cos-tooltip cosd-citation">2</span></td>
<td>无</td>
<td>高</td>
<td>无</td>
















</tr>
<tr>
<td>‌元素访问速度‌</td>
<td>中（需解引用）</td>
<td>快（直接栈访问）<span class="cos-tooltip cosd-citation">8</span></td>
<td>中</td>
<td>最快</td>
















</tr>
<tr>
<td>‌多返回值场景‌</td>
<td>需手动解包ItemX</td>
<td>支持命名元素<span class="cos-tooltip cosd-citation">6</span></td>
<td>需自定义类型</td>
<td>需自定义类型</td>
















</tr>
<tr>
<td>‌适用场景‌</td>
<td>低频使用的数据聚合<span class="cos-tooltip cosd-citation">2</span></td>
<td>高频临时数据组合<span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId ">5<span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId ">8</span></span></span></span></td>
<td>复杂业务对象</td>
<td>小型高频操作数据</td>
















</tr>
















</tbody>















</table>
<p data-pm-slice="1 1 []">&nbsp;</p>
<h1 data-pm-slice="1 1 []">元组基础：更优雅的临时数据结构</h1>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 传统方式 vs 元组方式
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 旧式：out参数</span>
<span style="color: rgba(0, 0, 255, 1)">bool</span> TryParseOld(<span style="color: rgba(0, 0, 255, 1)">string</span> input, <span style="color: rgba(0, 0, 255, 1)">out</span> <span style="color: rgba(0, 0, 255, 1)">int</span> number, <span style="color: rgba(0, 0, 255, 1)">out</span> <span style="color: rgba(0, 0, 255, 1)">string</span> error) { <span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">...</span><span style="color: rgba(0, 128, 0, 1)">*/</span><span style="color: rgba(0, 0, 0, 1)"> }

</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 元组方式（直接在方法前面定义返回类型，由于原来的单一返回变为一组返回）</span>
(<span style="color: rgba(0, 0, 255, 1)">int</span> number, <span style="color: rgba(0, 0, 255, 1)">string</span> error) TryParseNew(<span style="color: rgba(0, 0, 255, 1)">string</span><span style="color: rgba(0, 0, 0, 1)"> input) 
{
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> (<span style="color: rgba(0, 0, 255, 1)">int</span>.Parse(input), <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">);
}</span></pre>
</div>
<p data-pm-slice="1 1 []"><strong>核心优势</strong>：避免创建临时DTO类，特别适合LINQ查询结果的临时封装：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">var</span> stats =<span style="color: rgba(0, 0, 0, 1)"> products
    .GroupBy(p </span>=&gt;<span style="color: rgba(0, 0, 0, 1)"> p.Category)
    .Select(g </span>=&gt; (Category: g.Key, Count: g.Count(), AvgPrice: g.Average(p =&gt; p.Price)));</pre>
</div>
<p><strong><span style="font-size: 15px">&nbsp;扩展应用</span></strong></p>
<p><img src="https://img2024.cnblogs.com/blog/1093832/202505/1093832-20250515103448802-524041599.png" alt="" loading="lazy"></p>
<h1 data-pm-slice="1 1 []">.NET Core中的性能优化技巧</h1>
<p data-pm-slice="1 1 [&quot;orderedList&quot;,{&quot;tight&quot;:true,&quot;start&quot;:1,&quot;type&quot;:null},&quot;listItem&quot;,{}]"><span style="font-size: 15px"><strong>结构体元组</strong>：ValueTuple默认是结构体，减少堆分配</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 比较引用元组和值元组</span>
Tuple&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>, <span style="color: rgba(0, 0, 255, 1)">int</span>&gt; refTuple = Tuple.Create(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">text</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 128, 1)">42</span>); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 堆分配</span>
ValueTuple&lt;<span style="color: rgba(0, 0, 255, 1)">string</span>, <span style="color: rgba(0, 0, 255, 1)">int</span>&gt; valTuple = (<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">text</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 128, 1)">42</span>);       <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 栈分配</span></pre>
</div>
<p data-pm-slice="1 1 [&quot;orderedList&quot;,{&quot;tight&quot;:true,&quot;start&quot;:2,&quot;type&quot;:null},&quot;listItem&quot;,{}]"><span style="font-size: 15px"><strong>解构黑科技</strong>：</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 类/结构体解构</span>
<span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Point
{
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> Deconstruct(<span style="color: rgba(0, 0, 255, 1)">out</span> <span style="color: rgba(0, 0, 255, 1)">int</span> x, <span style="color: rgba(0, 0, 255, 1)">out</span> <span style="color: rgba(0, 0, 255, 1)">int</span> y) =&gt; (x, y) =<span style="color: rgba(0, 0, 0, 1)"> (_x, _y);
}
</span><span style="color: rgba(0, 0, 255, 1)">var</span>(x, y) = <span style="color: rgba(0, 0, 255, 1)">new</span> Point(<span style="color: rgba(128, 0, 128, 1)">10</span>, <span style="color: rgba(128, 0, 128, 1)">20</span>);</pre>
</div>
<h1 data-pm-slice="1 1 []">实战模式：元组的7种高级用法</h1>
<h2 data-pm-slice="1 1 [&quot;orderedList&quot;,{&quot;tight&quot;:true,&quot;start&quot;:1,&quot;type&quot;:null},&quot;listItem&quot;,{}]"><span style="font-size: 15px">1、</span><strong>模式匹配增强</strong></h2>
<p data-pm-slice="1 1 [&quot;orderedList&quot;,{&quot;tight&quot;:true,&quot;start&quot;:1,&quot;type&quot;:null},&quot;listItem&quot;,{}]">从C# 7.0开始，你可以使用模式匹配来检查元组中的值。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">var</span> result = (statusCode: <span style="color: rgba(128, 0, 128, 1)">404</span>, message: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Not Found</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 0, 255, 1)">switch</span><span style="color: rgba(0, 0, 0, 1)"> (result)
{
    </span><span style="color: rgba(0, 0, 255, 1)">case</span> (<span style="color: rgba(128, 0, 128, 1)">200</span>, _): Console.WriteLine(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Success</span><span style="color: rgba(128, 0, 0, 1)">"</span>);<span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">case</span> (<span style="color: rgba(128, 0, 128, 1)">404</span>, <span style="color: rgba(0, 0, 255, 1)">var</span> msg): Console.WriteLine(msg); <span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<h2 data-pm-slice="1 1 [&quot;orderedList&quot;,{&quot;tight&quot;:true,&quot;start&quot;:2,&quot;type&quot;:null},&quot;listItem&quot;,{}]"><span style="font-size: 15px"><strong>2、</strong></span><strong><span style="font-size: 15px">作为方法的返回值</span></strong></h2>
<p data-pm-slice="1 1 [&quot;orderedList&quot;,{&quot;tight&quot;:true,&quot;start&quot;:2,&quot;type&quot;:null},&quot;listItem&quot;,{}]"><span style="font-size: 15px">元组非常适合作为函数的返回值，尤其是当你需要返回多个值时。</span></p>
<div class="cnblogs_code">
<pre>(<span style="color: rgba(0, 0, 255, 1)">string</span>, <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)">) GetPersonInfo()
{
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> (<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">熊泽</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
}
</span><span style="color: rgba(0, 0, 255, 1)">var</span> (name, age) =<span style="color: rgba(0, 0, 0, 1)"> GetPersonInfo();
Console.WriteLine(name); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出 熊泽</span></pre>
</div>
<h2><span style="font-size: 15px"><strong>3、</strong></span><span style="font-size: 15px"><strong>元组在LINQ查询中的应用</strong></span></h2>
<p><span style="font-size: 15px">在LINQ查询中，元组可以用来返回多个列。</span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">var</span> people = <span style="color: rgba(0, 0, 255, 1)">new</span> List&lt;(<span style="color: rgba(0, 0, 255, 1)">string</span> Name, <span style="color: rgba(0, 0, 255, 1)">int</span> Age)&gt; { (<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">熊泽</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 128, 1)">26</span>), (<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Xiongze</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 128, 1)">22</span><span style="color: rgba(0, 0, 0, 1)">) };
</span><span style="color: rgba(0, 0, 255, 1)">var</span> query = people.Where(p =&gt; p.Age &gt; <span style="color: rgba(128, 0, 128, 1)">25</span>).Select(p =&gt;<span style="color: rgba(0, 0, 0, 1)"> (p.Name, p.Age));
</span><span style="color: rgba(0, 0, 255, 1)">foreach</span> (<span style="color: rgba(0, 0, 255, 1)">var</span> person <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> query)
{
    Console.WriteLine($</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">{person.Name} is {person.Age} years old.</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
}</span></pre>
</div>
<h2><strong><span style="font-size: 15px">4、使用命名元组</span></strong></h2>
<p><span style="font-size: 15px">从C# 7.0开始，元组可以带有命名属性，这使得代码的可读性大大提高。</span></p>
<div class="cnblogs_code">
<pre> <span style="color: rgba(0, 0, 255, 1)">var</span> person = (Name: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">熊泽</span><span style="color: rgba(128, 0, 0, 1)">"</span>, Age: <span style="color: rgba(128, 0, 128, 1)">26</span>, Email: <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">1509802981@qq.com</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
 Console.WriteLine(person.Name); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出 熊泽</span></pre>
</div>
<h2><span style="font-size: 15px"><strong>5、元组解构</strong></span></h2>
<p><span style="font-size: 15px">元组解构允许你将元组的值直接赋值给变量。</span></p>
<div class="cnblogs_code">
<pre> <span style="color: rgba(0, 0, 255, 1)">var</span> person = (<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">熊泽</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 128, 1)">26</span>, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">1509802981@qq.com</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
 </span><span style="color: rgba(0, 0, 255, 1)">var</span> (name, age, email) =<span style="color: rgba(0, 0, 0, 1)"> person;
 Console.WriteLine(name); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出 熊泽</span></pre>
</div>
<h2><strong><span style="font-size: 15px">6、使用ValueTuple和Deconstruction（解构）扩展方法</span></strong></h2>
<p><span style="font-size: 15px">对于不支持命名元组的早期版本，可以使用<code class="dqa-code-span">ValueTuple</code>和扩展方法实现类似的功能。</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> TupleExtensions
{
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> Deconstruct&lt;T1, T2&gt;(<span style="color: rgba(0, 0, 255, 1)">this</span> (T1, T2) tuple, <span style="color: rgba(0, 0, 255, 1)">out</span> T1 item1, <span style="color: rgba(0, 0, 255, 1)">out</span><span style="color: rgba(0, 0, 0, 1)"> T2 item2)
    {
        item1 </span>=<span style="color: rgba(0, 0, 0, 1)"> tuple.Item1;
        item2 </span>=<span style="color: rgba(0, 0, 0, 1)"> tuple.Item2;
    }
}</span></pre>
</div>
<div class="cnblogs_code">
<pre> <span style="color: rgba(0, 0, 255, 1)">var</span> person = (<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">熊泽</span><span style="color: rgba(128, 0, 0, 1)">"</span>, <span style="color: rgba(128, 0, 128, 1)">26</span><span style="color: rgba(0, 0, 0, 1)">);
 (</span><span style="color: rgba(0, 0, 255, 1)">string</span> name, <span style="color: rgba(0, 0, 255, 1)">int</span> age) = person; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 使用扩展方法实现解构</span>
 Console.WriteLine(name); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出 熊泽</span></pre>
</div>
<h2><strong><span style="font-size: 15px">7、使用元组进行复杂数据结构的简化表示</span></strong></h2>
<p data-pm-slice="1 1 [&quot;orderedList&quot;,{&quot;tight&quot;:true,&quot;start&quot;:1,&quot;type&quot;:null},&quot;listItem&quot;,{}]"><span style="font-size: 15px">&nbsp;元组非常适合用于临时或简单的数据结构，特别是在需要快速组合几个值时。例如，在解析JSON或处理数据库查询结果时。</span></p>
<div class="cnblogs_code">
<pre> <span style="color: rgba(0, 0, 255, 1)">var</span> result = JsonConvert.DeserializeObject&lt;(<span style="color: rgba(0, 0, 255, 1)">string</span> Name, <span style="color: rgba(0, 0, 255, 1)">int</span> Age)&gt;(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">{\"Name\":\"熊泽\", \"Age\":26}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
 Console.WriteLine(result.Name); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 输出 熊泽</span></pre>
</div>
<h1 data-pm-slice="1 3 []">避坑指南</h1>
<ul class="tight" data-tight="true">
<li>
<p><strong>序列化限制</strong>：System.Text.Json需要配置转换器</p>
</li>
<li>
<p><strong>命名元组陷阱</strong>：编译后名称会丢失，运行时仅保留Item1/Item2</p>
</li>
<li>
<p><strong>版本兼容</strong>：.NET Standard 2.0需安装System.ValueTuple包</p>
</li>
</ul>
<h1 data-pm-slice="1 3 []">性能优化和应用场景建议</h1>
<p><span style="font-size: 18px"><strong>性能优化建议：</strong></span></p>
<ol class="tight" data-tight="true">
<li>
<p><span style="font-size: 16px">优先使用ValueTuple避免堆分配</span></p>
</li>
<li>
<p><span style="font-size: 16px">高频访问场景考虑缓存元组</span></p>
</li>
<li>
<p><span style="font-size: 16px">避免在热点路径中频繁创建新元组</span></p>
</li>
<li><span style="font-size: 16px">超过8个元素需嵌套元组，此时性能反而不如自定义结构体<span class="cos-tooltip cosd-citation">。</span></span></li>
<li><span style="font-size: 16px"><span class="cos-tooltip cosd-citation">当需要封装行为或长期存储时，类的可维护性更优。</span></span></li>
</ol>
<p><strong><span style="font-size: 18px">应用场景建议：</span></strong></p>
<table>
<thead>
<tr><th>数据结构</th><th>适用场景</th><th>性能优势点</th></tr>
</thead>
<tbody>
<tr>
<td>元组</td>
<td>配置参数传递、多返回值、数据记录存储</td>
<td>创建速度比类快 2.7 倍，内存占用低 18%&nbsp;<span><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><br></span></span></span></span></span></span></span></td>



















</tr>
<tr>
<td>动态数组</td>
<td>频繁增删元素、数据流处理</td>
<td>尾部插入时间复杂度 O(1)&nbsp;<span><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><br></span></span></span></span></td>



















</tr>
<tr>
<td>结构体/类</td>
<td>复杂业务对象、需要方法封装</td>
<td>字段命名访问比元组索引访问快 15%&nbsp;<span><span><span class="cos-tooltip cosd-citation"><span class="cosd-citation-citationId "><br></span></span></span></span></td>



















</tr>



















</tbody>



















</table>
<h3>&nbsp;</h3>
<p><span style="font-size: 16px"><strong>欢迎关注订阅微信公众号【熊泽有话说】，更多好玩易学知识等你来取</strong></span><br><span style="font-size: 16px"><strong>作者：熊泽-学习中的苦与乐<br><strong>公众号：熊泽有话说</strong></strong></span><br><span style="font-size: 16px"><strong>QQ群：<span style="color: rgba(255, 0, 0, 1)">711838388</span></strong></span><br><span style="font-size: 16px"><strong>出处：<a class="ng-star-inserted" href="https://www.cnblogs.com/xiongze520/p/18877124" rel="noopener" target="_blank">https://www.cnblogs.com/xiongze520/p/18866690</a></strong></span><br><span style="font-size: 16px"><strong>您可以随意转载、摘录，但请在文章内注明作者和原文链接。&nbsp;</strong>&nbsp;</span></p>
<p>&nbsp;</p>
<p><img src="https://img2020.cnblogs.com/blog/1093832/202108/1093832-20210823163948985-309495620.png" alt="" width="514" height="239" loading="lazy"></p>
<p>&nbsp;</p>
<div id="yy_trans_float_ball" style="position: fixed; z-index: 2147483647; width: 0; height: 0">&nbsp;</div>
<div id="yy_trans_float_ball" style="position: fixed; z-index: 2147483647; width: 0; height: 0">&nbsp;</div>
<div id="yy_trans_float_ball" style="position: fixed; z-index: 2147483647; width: 0; height: 0">&nbsp;</div>
</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/xiongze520/" target="_blank">熊泽-学习中的苦与乐</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/xiongze520/p/18877124" target="_blank">https://www.cnblogs.com/xiongze520/p/18877124</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7625826203275463" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-15 16:53">2025-05-15 16:53</span>&nbsp;
<a href="https://www.cnblogs.com/xiongze520">熊泽-学习中的苦与乐</a>&nbsp;
阅读(<span id="post_view_count">194</span>)&nbsp;
评论(<span id="post_comment_count">7</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18877124);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18877124', targetLink: 'https://www.cnblogs.com/xiongze520/p/18877124', title: '开发实用小技巧：元组-轻量级数据容器的艺术' })">举报</a>
</div>
        