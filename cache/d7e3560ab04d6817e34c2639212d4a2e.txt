
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/houxianzhou/p/18855007" title="发布于 2025-04-30 10:21">
    <span role="heading" aria-level="2">一行代码搞定防抖节流：JavaScript新特性解析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div id="page-content" class="rich_media_area_primary">
<div class="rich_media_area_primary_inner">
<div id="img-content" class="rich_media_wrp">
<div id="js_content" class="rich_media_content js_underline_content autoTypeSetting24psection">
<div class="cnblogs_code">
<pre></pre>
</div>
<p data-line="2" data-pm-slice="0 0 []"><span>防抖(Debounce)和节流(Throttle)是两种前端开发中常用的性能优化技术，尤其在处理高频触发事件如滚动、调整窗口大小、输入等场景中。传统实现这些功能需要编写复杂的函数，但随着JavaScript的发展，我们现在可以通过更简洁的方式实现这些功能。</span></p>
<h2 data-line="4"><span>传统实现方式回顾</span></h2>
<p data-line="6"><span>在深入新特性之前，让我们先回顾一下传统的防抖和节流实现方式：</span></p>
<h3 data-line="8"><span>传统防抖实现</span></h3>
<pre><code><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> debounce(fn, delay) {
let timer </span>= <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
returnfunction(...args) {
    </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (timer) clearTimeout(timer);
    timer </span>= setTimeout(() =&gt;<span style="color: rgba(0, 0, 0, 1)"> {
      fn.apply(</span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">, args);
    }, delay);
  };
}

</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 使用示例</span>
const handleSearch = debounce(<span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)">(e) {
console.log(</span>'搜索内容:'<span style="color: rgba(0, 0, 0, 1)">, e.target.value);
}, </span>300<span style="color: rgba(0, 0, 0, 1)">);

searchInput.addEventListener(</span>'input', handleSearch);</pre>
</div>
<p>&nbsp;</p>
<h3 data-line="29"><span>传统节流实现</span></h3>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)"> throttle(fn, delay) {
let lastTime </span>= 0<span style="color: rgba(0, 0, 0, 1)">;
returnfunction(...args) {
    const now </span>=<span style="color: rgba(0, 0, 0, 1)"> Date.now();
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (now - lastTime &gt;=<span style="color: rgba(0, 0, 0, 1)"> delay) {
      fn.apply(</span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">, args);
      lastTime </span>=<span style="color: rgba(0, 0, 0, 1)"> now;
    }
  };
}

</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 使用示例</span>
const handleScroll = throttle(<span style="color: rgba(0, 0, 255, 1)">function</span><span style="color: rgba(0, 0, 0, 1)">() {
console.log(</span>'页面滚动'<span style="color: rgba(0, 0, 0, 1)">);
}, </span>200<span style="color: rgba(0, 0, 0, 1)">);

window.addEventListener(</span>'scroll', handleScroll);</pre>
</div>
<p>&nbsp;</p>
<pre><code><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h2 data-line="51"><span>JavaScript新特性：函数装饰器</span></h2>
<br>
<p data-line="53"><span>ECMAScript的提案中引入了函数装饰器（Function Decorators），这是一种能够在不修改原始函数的情况下增强函数行为的语法。</span></p>
<blockquote>
<p><span>注意：截至2024年10月，函数装饰器仍处于TC39提案阶段，可能需要通过Babel或TypeScript等工具进行转译才能使用。</span></p>


</blockquote>
<h3 data-line="57"><span>利用装饰器实现一行防抖</span></h3>
<p><img src="https://img2024.cnblogs.com/blog/1161361/202504/1161361-20250430101730189-1659140303.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>


<br>
<h2 data-line="83"><span>现代化解决方案</span></h2>
<h3 data-line="85"><span>使用requestAnimationFrame实现的节流</span></h3>
<p data-line="87"><span>浏览器的<code><span>requestAnimationFrame</span></code><span>API可以帮助我们实现一行代码的节流效果：</span></span></p>
<p><img src="https://img2024.cnblogs.com/blog/1161361/202504/1161361-20250430101717024-1191130945.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>


<br>
<h3 data-line="108"><span>利用AbortController实现简洁防抖</span></h3>
<p><img src="https://img2024.cnblogs.com/blog/1161361/202504/1161361-20250430101658493-846388396.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>


<br>
<h2 data-line="137"><span>使用Web Streams API实现防抖节流</span></h2>
<p data-line="139"><span>随着Web Streams API的成熟，我们可以利用它实现更声明式的防抖和节流：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1161361/202504/1161361-20250430101545547-1814966776.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>


<br>
<h2 data-line="178"><span>第三方库的超简化方案</span></h2>
<p data-line="180"><span>如果您使用诸如Lodash、Underscore等工具库，防抖节流变得极其简单：</span></p>
<pre><code>// Lodash<span><br>import<span>&nbsp;{ debounce, throttle }&nbsp;from<span>&nbsp;'lodash'<span>;<span><br><span><br>// 一行防抖<span><br><span>element.addEventListener<span>('input'<span>, _.debounce<span>(handleInput,&nbsp;300<span>));<span><br><span><br>// 一行节流<span><br>window<span>.addEventListener<span>('scroll'<span>, _.throttle<span>(handleScroll,&nbsp;200<span>));<span><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<br>
<h2 data-line="193"><span>实际应用场景</span></h2>
<ol class="list-paddingleft-1">
<li>
<p>搜索输入框<span>：防抖可以避免用户每输入一个字符就发送请求</span></p>


</li>
<li>
<p>窗口调整<span>：节流可以限制布局重新计算的频率</span></p>


</li>
<li>
<p>无限滚动<span>：节流可以控制加载新内容的频率</span></p>


</li>
<li>
<p>游戏中的用户输入<span>：确保按键响应不会过于频繁</span></p>


</li>
<li>
<p>拖拽元素<span>：平滑拖拽效果而不造成性能问题</span></p>


</li>


</ol>
<h2 data-line="201"><span>性能比较</span></h2>
<table>
<thead>
<tr><th><span>实现方式</span></th><th><span>优点</span></th><th><span>缺点</span></th></tr>


</thead>
<tbody>
<tr>
<td><span>传统函数封装</span></td>
<td><span>兼容性好，灵活性高</span></td>
<td><span>代码冗长，需要手动管理</span></td>


</tr>
<tr>
<td><span>装饰器</span></td>
<td><span>语法简洁，声明式编程</span></td>
<td><span>兼容性问题，需要转译</span></td>


</tr>
<tr>
<td><span>requestAnimationFrame</span></td>
<td><span>与浏览器渲染周期同步，性能好</span></td>
<td><span>只适用于视觉相关操作</span></td>


</tr>
<tr>
<td><span>AbortController</span></td>
<td><span>清晰地管理取消机制</span></td>
<td><span>相对新的API，可能需要polyfill</span></td>


</tr>
<tr>
<td><span>Web Streams</span></td>
<td><span>声明式，功能强大</span></td>
<td><span>API复杂，兼容性有限</span></td>


</tr>
<tr>
<td><span>第三方库</span></td>
<td><span>简单，经过测试</span></td>
<td><span>增加项目依赖和体积</span></td>


</tr>


</tbody>


</table>
<p data-line="212"><span>JavaScript的发展让我们能够用越来越简洁的代码实现防抖和节流功能。根据项目需求和浏览器兼容性要求，可以选择最适合的实现方式。对于现代web应用，装饰器和最新的Web API提供了简洁优雅的解决方案；而对于需要广泛兼容的项目，传统实现或借助成熟的第三方库仍然是可靠的选择。</span></p>
<p data-line="214"><span>无论选择哪种方式，防抖和节流都是提升用户体验和应用性能的重要技术，值得每位前端开发者掌握。</span></p>
<div class="appmsg_card_context wx_profile_card wx-root wx_tap_card wx_card_root common-webchat">
<div class="wx_profile_card_inner">
<div class="wx_profile_card_bd">
<div class="wx_profile weui-flex">
<div class="wx_profile_hd">&nbsp;</div>
<div class="wx_profile_bd weui-flex weui-flex__item">
<div class="weui-flex__item">
<div class="wx_profile_nickname_wrp"><span id="js_a11y_wx_profile_nickname" class="wx_profile_nickname">&nbsp;</span></div>


</div>


</div>


</div>


</div>


</div>


</div>


</div>


</div>
<div id="content_bottom_area">
<div class="adv_keyword_bottom_modal" data-v-074c4d68="">&nbsp;</div>


</div>


</div>


</div>
<div class="rich_media_area_extra">
<div class="rich_media_area_extra_inner">
<div id="page_bottom_area" class="has_extra_cnt">&nbsp;</div>


</div>


</div>
</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/houxianzhou/" target="_blank">喆星高照</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/houxianzhou/p/18855007" target="_blank">https://www.cnblogs.com/houxianzhou/p/18855007</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.031164146377314815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-30 10:21">2025-04-30 10:21</span>&nbsp;
<a href="https://www.cnblogs.com/houxianzhou">喆星高照</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18855007);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18855007', targetLink: 'https://www.cnblogs.com/houxianzhou/p/18855007', title: '一行代码搞定防抖节流：JavaScript新特性解析' })">举报</a>
</div>
        