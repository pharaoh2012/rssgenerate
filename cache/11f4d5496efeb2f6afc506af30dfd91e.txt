
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aslanvon/p/18946910" title="发布于 2025-06-24 21:56">
    <span role="heading" aria-level="2">STL 容器</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>C++ STL（Standard Template Library）中主要提供了三大类通用容器，用于存储和管理不同类型和结构的数据。它们分别是：</p>
<h1 id="stl-容器总览">STL 容器总览</h1>
<table>
<thead>
<tr>
<th>容器类别</th>
<th>容器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>序列式容器</strong> (Sequence Containers)</td>
<td><code>vector</code>, <code>deque</code>, <code>list</code>, <code>forward_list</code>, <code>array</code></td>
<td>元素按插入顺序排列，类似数组</td>
</tr>
<tr>
<td><strong>关联式容器</strong> (Associative Containers)</td>
<td><code>set</code>, <code>map</code>, <code>multiset</code>, <code>multimap</code></td>
<td>自动排序，基于平衡树（红黑树）</td>
</tr>
<tr>
<td><strong>无序关联容器</strong> (Unordered Associative Containers)</td>
<td><code>unordered_set</code>, <code>unordered_map</code>, <code>unordered_multiset</code>, <code>unordered_multimap</code></td>
<td>无序哈希表，查找插入效率高</td>
</tr>
<tr>
<td><strong>容器适配器</strong> (Container Adapters)</td>
<td><code>stack</code>, <code>queue</code>, <code>priority_queue</code></td>
<td>封装其他容器，提供特定行为</td>
</tr>
</tbody>
</table>
<h1 id="序列式容器有顺序按位置存储">序列式容器（有顺序，按位置存储）</h1>
<table>
<thead>
<tr>
<th>容器名</th>
<th>特点</th>
<th>常见用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vector</code></td>
<td>动态数组，支持随机访问，尾部插入快</td>
<td>默认首选容器，替代 C 数组</td>
</tr>
<tr>
<td><code>deque</code></td>
<td>双端队列，支持首尾插入删除</td>
<td>双端栈、滚动窗口</td>
</tr>
<tr>
<td><code>list</code></td>
<td>双向链表，插入删除快，不能随机访问</td>
<td>频繁插入/删除位置稳定</td>
</tr>
<tr>
<td><code>forward_list</code></td>
<td>单向链表，内存更小（C++11）</td>
<td>内嵌链表、只需前向遍历</td>
</tr>
<tr>
<td><code>array</code></td>
<td>定长数组，封装 C 风格数组（C++11）</td>
<td>栈上存储，性能好，长度固定</td>
</tr>
</tbody>
</table>
<h2 id="一序列式容器特性对比速查表">一、序列式容器特性对比速查表</h2>
<table>
<thead>
<tr>
<th>特性维度</th>
<th><code>vector</code></th>
<th><code>array</code></th>
<th><code>deque</code></th>
<th><code>list</code></th>
<th><code>forward_list</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>底层结构</strong></td>
<td>动态数组（连续内存）</td>
<td>静态数组（连续内存）</td>
<td>分段数组</td>
<td>双向链表</td>
<td>单向链表</td>
</tr>
<tr>
<td><strong>大小可变</strong></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>✅ 是（无 <code>size()</code>）</td>
</tr>
<tr>
<td><strong>下标访问</strong> (<code>[]</code>, <code>at()</code>)</td>
<td>✅ 支持</td>
<td>✅ 支持</td>
<td>✅ 支持</td>
<td>❌ 不支持</td>
<td>❌ 不支持</td>
</tr>
<tr>
<td><strong>头部操作</strong> (<code>push_front</code>)</td>
<td>❌ 慢（需移动）</td>
<td>❌</td>
<td>✅ 高效</td>
<td>✅ 高效</td>
<td>✅ 高效</td>
</tr>
<tr>
<td><strong>尾部操作</strong> (<code>push_back</code>)</td>
<td>✅ 高效</td>
<td>❌</td>
<td>✅ 高效</td>
<td>✅ 高效</td>
<td>❌ 无此接口</td>
</tr>
<tr>
<td><strong>中间插入/删除</strong></td>
<td>❌ 慢（移动元素）</td>
<td>❌</td>
<td>⚠️ 中等偏慢</td>
<td>✅ 高效</td>
<td>✅ 但不方便</td>
</tr>
<tr>
<td><strong>空间管理函数</strong></td>
<td>✅ <code>reserve()</code>、<code>shrink_to_fit()</code></td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><strong>支持 <code>data()</code></strong></td>
<td>✅</td>
<td>✅</td>
<td>✅（C++17 起）</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><strong>支持 <code>size()</code></strong></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌（需手动计数）</td>
</tr>
<tr>
<td><strong>迭代器类型</strong></td>
<td>随机访问</td>
<td>随机访问</td>
<td>随机访问</td>
<td>双向</td>
<td>单向（forward only）</td>
</tr>
<tr>
<td><strong>STL算法兼容性</strong></td>
<td>✅ 全兼容</td>
<td>✅ 全兼容</td>
<td>✅ 全兼容</td>
<td>⚠️ 不能用 <code>std::sort()</code></td>
<td>同左</td>
</tr>
<tr>
<td><strong>稳定性</strong>（指针/引用稳定）</td>
<td>❌ 增删会失效</td>
<td>✅</td>
<td>❌</td>
<td>✅ 稳定</td>
<td>✅ 稳定</td>
</tr>
<tr>
<td><strong>排序支持</strong></td>
<td><code>std::sort()</code></td>
<td><code>std::sort()</code></td>
<td><code>std::sort()</code></td>
<td><code>.sort()</code>（成员函数）</td>
<td><code>.sort()</code></td>
</tr>
<tr>
<td><strong>内存分配位置</strong></td>
<td>堆</td>
<td>栈</td>
<td>堆（分段）</td>
<td>堆（节点）</td>
<td>堆（节点）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>随机访问、连续优化、频繁尾部插入</td>
<td>定长数组替代品、轻量</td>
<td>双端队列、滑动窗口</td>
<td>频繁中间修改</td>
<td>单向处理流、大量前插、轻量链表</td>
</tr>
</tbody>
</table>
<p><code>deque</code> 内存分块不支持空间管理函数，<code>vector</code> 是一片连续的内存，支持 <code>data()</code>、<code>reserve()</code>、<code>shrink_to_fit()</code> 等内存操作；</p>
<p><code>list</code> 和<code>forward_list</code>内部结构是链表，没有下标操作，链表自带排序api；</p>
<p><code>array</code> 在编译时就确定了大小，不能动态改变元素的数量，内存分配在栈上；</p>
<ul>
<li><code>vector</code>：适合连续内存优化，支持 <code>data()</code>、<code>reserve()</code>、<code>shrink_to_fit()</code> 等内存操作，尾部插入效率高，但头部和中间插入较慢。</li>
<li><code>array</code>：固定大小的轻量容器，栈上分配，支持下标访问和 <code>data()</code>，不支持任何动态操作。</li>
<li><code>deque</code>：支持头部和尾部插入操作，适合双端队列场景，但不支持空间管理函数，底层为分段内存结构。</li>
<li><code>list</code>：双向链表容器，适合频繁的中间插入和删除，元素地址稳定，但不支持下标访问，也不能用 <code>std::sort()</code>（需要用成员 <code>sort()</code>）。</li>
<li><code>forward_list</code>：单向链表容器，接口更轻量，不支持尾部插入和 <code>size()</code>，只能使用 <code>insert_after()</code> / <code>erase_after()</code> 等后置操作，适合嵌入式或轻量场景。</li>
</ul>
<h2 id="二共性-api-总结">二、<strong>共性 API 总结</strong></h2>
<p>几乎所有序列式容器都支持如下操作（但有些容器支持受限）：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>容器大小</td>
<td><code>size()</code></td>
<td>返回当前元素个数</td>
</tr>
<tr>
<td></td>
<td><code>empty()</code></td>
<td>是否为空</td>
</tr>
<tr>
<td></td>
<td><code>max_size()</code></td>
<td>可容纳最大元素数</td>
</tr>
<tr>
<td>元素访问</td>
<td><code>front()</code> / <code>back()</code></td>
<td>返回头/尾元素（不能用于 <code>forward_list</code> 的 <code>back()</code>）</td>
</tr>
<tr>
<td>迭代器</td>
<td><code>begin()</code> / <code>end()</code></td>
<td>常规迭代器</td>
</tr>
<tr>
<td></td>
<td><code>cbegin()</code> / <code>cend()</code></td>
<td>const 版本</td>
</tr>
<tr>
<td></td>
<td><code>rbegin()</code> / <code>rend()</code></td>
<td>反向迭代器</td>
</tr>
<tr>
<td>修改操作</td>
<td><code>insert()</code></td>
<td>插入元素（<code>forward_list</code> 仅支持 after）</td>
</tr>
<tr>
<td></td>
<td><code>erase()</code></td>
<td>删除元素（<code>forward_list</code> 仅支持 after）</td>
</tr>
<tr>
<td></td>
<td><code>push_back()</code> / <code>pop_back()</code></td>
<td>尾部插入/删除（<code>forward_list</code> 无）</td>
</tr>
<tr>
<td></td>
<td><code>push_front()</code> / <code>pop_front()</code></td>
<td>头部插入/删除（<code>vector</code> 无）</td>
</tr>
<tr>
<td></td>
<td><code>clear()</code></td>
<td>清空容器</td>
</tr>
<tr>
<td></td>
<td><code>resize()</code></td>
<td>改变大小</td>
</tr>
<tr>
<td>其他</td>
<td><code>swap()</code></td>
<td>交换两个容器</td>
</tr>
<tr>
<td></td>
<td><code>assign()</code></td>
<td>批量赋值（如指定区间或重复值）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="二每个容器详细-api--特性对比">二、每个容器详细 API + 特性对比</h2>
<hr>
<h3 id="1-vectort">1. <code>vector&lt;T&gt;</code></h3>
<pre><code class="language-cpp">#include &lt;vector&gt;
</code></pre>
<ul>
<li><code>std::vector</code> 是一个动态数组容器</li>
<li>元素<strong>连续存储</strong>，支持随机访问</li>
<li>尾部插入/删除效率高，插入中间位置效率较低</li>
</ul>
<hr>
<h4 id="stdvector-的常用构造函数构造函数"><code>std::vector</code> 的常用构造函数构造函数</h4>
<table>
<thead>
<tr>
<th>构造函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vector()</code></td>
<td>默认构造，空容器</td>
</tr>
<tr>
<td><code>vector(size_t n)</code></td>
<td>创建含 <code>n</code> 个默认值元素的容器</td>
</tr>
<tr>
<td><code>vector(size_t n, const T&amp; val)</code></td>
<td>创建含 <code>n</code> 个值为 <code>val</code> 的元素</td>
</tr>
<tr>
<td><code>vector(initializer_list&lt;T&gt;)</code></td>
<td>使用花括号初始化列表构造（C++11）</td>
</tr>
<tr>
<td><code>vector(iter1, iter2)</code></td>
<td>通过迭代器区间构造</td>
</tr>
<tr>
<td><code>vector(const vector&amp; other)</code></td>
<td>拷贝构造</td>
</tr>
<tr>
<td><code>vector(vector&amp;&amp; other)</code></td>
<td>移动构造（C++11）</td>
</tr>
</tbody>
</table>
<p>具体例子：</p>
<table>
<thead>
<tr>
<th>构造方式</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认构造</td>
<td><code>vector&lt;int&gt; v;</code></td>
<td>创建空容器</td>
</tr>
<tr>
<td>指定大小</td>
<td><code>vector&lt;int&gt; v(5);</code></td>
<td>创建 5 个默认元素（0）</td>
</tr>
<tr>
<td>指定大小和值</td>
<td><code>vector&lt;int&gt; v(3, 9);</code></td>
<td>创建 3 个值为 9 的元素</td>
</tr>
<tr>
<td>初始化列表</td>
<td><code>vector&lt;int&gt; v = {1, 2};</code></td>
<td>推荐用法，清晰直观</td>
</tr>
<tr>
<td>区间构造</td>
<td><code>vector&lt;int&gt; v(v2.begin(), v2.end());</code></td>
<td>从其他容器复制子区间</td>
</tr>
<tr>
<td>拷贝构造</td>
<td><code>vector&lt;int&gt; v(v2);</code></td>
<td>拷贝另一个 vector</td>
</tr>
<tr>
<td>移动构造</td>
<td><code>vector&lt;int&gt; v(std::move(v2));</code></td>
<td>高效转移所有权（C++11）</td>
</tr>
</tbody>
</table>
<p>示例代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    // 1. 默认构造
    std::vector&lt;int&gt; v1;
    std::cout &lt;&lt; "v1.size = " &lt;&lt; v1.size() &lt;&lt; "\n";

    // 2. 构造 n 个默认值元素
    std::vector&lt;int&gt; v2(5);
    std::cout &lt;&lt; "v2: ";
    for (int x : v2) std::cout &lt;&lt; x &lt;&lt; " ";  // 输出 0 0 0 0 0
    std::cout &lt;&lt; "\n";

    // 3. 构造 n 个指定值
    std::vector&lt;int&gt; v3(4, 7);  // 4 个 7
    std::cout &lt;&lt; "v3: ";
    for (int x : v3) std::cout &lt;&lt; x &lt;&lt; " ";  // 输出 7 7 7 7
    std::cout &lt;&lt; "\n";

    // 4. 使用初始化列表
    std::vector&lt;int&gt; v4 = {1, 2, 3, 4};
    std::cout &lt;&lt; "v4: ";
    for (int x : v4) std::cout &lt;&lt; x &lt;&lt; " ";  // 输出 1 2 3 4
    std::cout &lt;&lt; "\n";

    // 5. 通过迭代器范围构造（从 v4 拷贝前两个元素）
    std::vector&lt;int&gt; v5(v4.begin(), v4.begin() + 2);
    std::cout &lt;&lt; "v5: ";
    for (int x : v5) std::cout &lt;&lt; x &lt;&lt; " ";  // 输出 1 2
    std::cout &lt;&lt; "\n";

    // 6. 拷贝构造
    std::vector&lt;int&gt; v6 = v3;
    std::cout &lt;&lt; "v6: ";
    for (int x : v6) std::cout &lt;&lt; x &lt;&lt; " ";  // 输出 7 7 7 7
    std::cout &lt;&lt; "\n";

    // 7. 移动构造（C++11）
    std::vector&lt;int&gt; v7 = std::move(v6);
    std::cout &lt;&lt; "v7: ";
    for (int x : v7) std::cout &lt;&lt; x &lt;&lt; " ";  // 输出 7 7 7 7
    std::cout &lt;&lt; "\n";
}
</code></pre>
<h4 id="增插入操作">增（插入）操作</h4>
<ol>
<li><code>push_back(val)</code> — 在尾部插入一个元素</li>
</ol>
<pre><code class="language-cpp">std::vector&lt;int&gt; v;
v.push_back(10);
v.push_back(20);  // v = {10, 20}
</code></pre>
<ol start="2">
<li><code>insert(pos, val)</code> — 在指定位置插入一个元素</li>
</ol>
<pre><code class="language-cpp">auto it = v.begin();  // 指向第一个元素
v.insert(it + 1, 15); // 在索引1处插入 15：v = {10, 15, 20}
</code></pre>
<ol start="3">
<li><code>insert(pos, count, val)</code> — 插入多个相同元素</li>
</ol>
<pre><code class="language-cpp">v.insert(v.begin(), 3, 7); // v = {7, 7, 7, 10, 15, 20}
</code></pre>
<ol start="4">
<li><code>insert(pos, range_begin, range_end)</code> — 插入迭代器范围</li>
</ol>
<pre><code class="language-cpp">std::vector&lt;int&gt; other = {1, 2};
v.insert(v.end(), other.begin(), other.end());  // 尾部插入 1, 2
</code></pre>
<hr>
<h4 id="删删除操作">删（删除）操作</h4>
<ol>
<li><code>pop_back()</code> — 删除最后一个元素</li>
</ol>
<pre><code class="language-cpp">v.pop_back();  // 删除末尾元素 2
</code></pre>
<ol start="2">
<li><code>erase(pos)</code> — 删除指定位置的元素</li>
</ol>
<pre><code class="language-cpp">v.erase(v.begin() + 1);  // 删除索引1处元素
</code></pre>
<ol start="3">
<li><code>erase(begin, end)</code> — 删除范围内元素</li>
</ol>
<pre><code class="language-cpp">v.erase(v.begin(), v.begin() + 2);  // 删除前两个元素
</code></pre>
<ol start="4">
<li><code>clear()</code> — 清空所有元素</li>
</ol>
<pre><code class="language-cpp">v.clear();  // v.size() == 0
</code></pre>
<hr>
<h4 id="改修改操作">改（修改）操作</h4>
<ol>
<li>使用 <code>operator[]</code> 修改元素</li>
</ol>
<pre><code class="language-cpp">std::vector&lt;int&gt; v = {1, 2, 3};
v[1] = 10;  // v = {1, 10, 3}
</code></pre>
<ol start="2">
<li>使用 <code>at(index)</code>（带越界检查）</li>
</ol>
<pre><code class="language-cpp">v.at(2) = 99;  // v = {1, 10, 99}
</code></pre>
<p>⚠️ 如果越界，<code>at()</code> 会抛出 <code>std::out_of_range</code> 异常。</p>
<hr>
<h4 id="查访问操作">查（访问）操作</h4>
<ol>
<li>随机访问</li>
</ol>
<pre><code class="language-cpp">int x = v[0];
int y = v.at(1);  // 推荐安全版本
</code></pre>
<ol start="2">
<li>访问首尾元素</li>
</ol>
<pre><code class="language-cpp">int first = v.front();
int last = v.back();
</code></pre>
<ol start="3">
<li>遍历（推荐 range-for）</li>
</ol>
<pre><code class="language-cpp">for (int val : v) {
    std::cout &lt;&lt; val &lt;&lt; " ";
}
</code></pre>
<p>也可以用传统迭代器：</p>
<pre><code class="language-cpp">for (auto it = v.begin(); it != v.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";
}
</code></pre>
<hr>
<h4 id="其他操作">其他操作</h4>
<p><strong><code>resize(n)</code> — 修改容器大小</strong></p>
<pre><code class="language-cpp">v.resize(5);  // 增大到5个元素，自动补 0
v.resize(2);  // 缩小为2个元素
</code></pre>
<p><strong><code>reserve(capacity)</code> — 预分配内存（避免多次扩容）</strong></p>
<pre><code class="language-cpp">v.reserve(100);  // 分配100个元素空间，提高效率
</code></pre>
<p><strong><code>shrink_to_fit()</code> — 回收冗余空间</strong></p>
<p><code>vector::shrink_to_fit()</code> 是 C++11 引入的一个标准库成员函数，作用是：<strong>请求</strong>释放多余的内存容量，使 <code>vector</code> 的容量（capacity）收缩到与当前元素个数（size）相同，减少内存占用。</p>
<pre><code class="language-cpp">v.shrink_to_fit();
</code></pre>
<p><strong>data() 返回指向 <code>vector</code> 内部元素数组的指针</strong></p>
<p><code>std::vector::data()</code> 是一个成员函数，其作用是：<strong>返回指向 <code>vector</code> 内部元素数组的指针</strong>（也就是首元素的指针），你可以通过它访问底层的原始连续内存。</p>
<blockquote>
<p><code>data()</code> 给你一个 <strong><code>T\*</code> 指针</strong>，指向 <code>vector</code> 内部的连续数组。</p>
</blockquote>
<pre><code class="language-cpp">T* data();              // 返回可写指针（C++11 起）
const T* data() const;  // 返回只读指针
</code></pre>
<hr>
<p>示例</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; v = {1, 2, 3};

    int* ptr = v.data();

    ptr[1] = 42;  // 直接通过指针修改 vector 中的元素

    std::cout &lt;&lt; v[1] &lt;&lt; "\n";  // 输出 42
}
</code></pre>
<p>注意事项</p>
<ol>
<li><code>vector</code> 的元素是 <strong>连续的内存块</strong>，所以 <code>data()</code> 指针指向的是合法数组首地址。</li>
<li>如果 <code>vector</code> 是空的（<code>size() == 0</code>），返回的指针 <strong>不是 <code>nullptr</code>，但不能解引用</strong>。</li>
<li>若后续对 <code>vector</code> 执行了插入/删除/扩容操作，原 <code>data()</code> 返回的指针可能会<strong>失效</strong>。</li>
</ol>
<table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>v.data()</code></td>
<td>返回首元素地址指针</td>
<td>推荐方式，语义清晰</td>
</tr>
<tr>
<td><code>&amp;v[0]</code></td>
<td>同样返回首地址</td>
<td>C++03 常用，不安全（空 vector 会崩溃）</td>
</tr>
</tbody>
</table>
<h4 id="示例完整程序">示例完整程序</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; v;

    // 增
    v.push_back(1);
    v.push_back(2);
    v.insert(v.begin(), 0);      // 插入到开头
    v.insert(v.end(), 2, 99);    // 插入两个 99

    // 改
    v[1] = 100;        // 修改第 1 个元素
    v.at(2) = 200;

    // 查
    std::cout &lt;&lt; "Front: " &lt;&lt; v.front() &lt;&lt; ", Back: " &lt;&lt; v.back() &lt;&lt; "\n";

    std::cout &lt;&lt; "遍历：";
    for (int x : v) std::cout &lt;&lt; x &lt;&lt; " ";
    std::cout &lt;&lt; "\n";

    // 删
    v.pop_back();       // 删除最后一个 99
    v.erase(v.begin()); // 删除第一个元素
    v.clear();          // 清空

    std::cout &lt;&lt; "Size after clear: " &lt;&lt; v.size() &lt;&lt; "\n";
}
</code></pre>
<hr>
<h4 id="总结表格vector-增删改查-api">总结表格：vector 增删改查 API</h4>
<table>
<thead>
<tr>
<th>操作</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>增</td>
<td><code>push_back(val)</code></td>
<td>尾部插入</td>
</tr>
<tr>
<td></td>
<td><code>insert(pos, val)</code></td>
<td>指定位置插入</td>
</tr>
<tr>
<td>删</td>
<td><code>pop_back()</code></td>
<td>删除末尾元素</td>
</tr>
<tr>
<td></td>
<td><code>erase(pos)</code></td>
<td>删除指定元素</td>
</tr>
<tr>
<td></td>
<td><code>clear()</code></td>
<td>清空</td>
</tr>
<tr>
<td>改</td>
<td><code>v[i] = x</code>, <code>v.at(i)</code></td>
<td>修改第 i 个元素</td>
</tr>
<tr>
<td>查</td>
<td><code>v[i]</code>, <code>v.at(i)</code></td>
<td>访问第 i 个元素</td>
</tr>
<tr>
<td></td>
<td><code>front()</code>, <code>back()</code></td>
<td>首尾元素</td>
</tr>
<tr>
<td></td>
<td><code>begin()</code>, <code>end()</code></td>
<td>迭代器遍历</td>
</tr>
</tbody>
</table>
<h3 id="2-dequet">2. <code>deque&lt;T&gt;</code></h3>
<p><code>std::deque</code>（<strong>double-ended queue</strong>）是由<strong>多个连续的小块内存（称为块、block、buffer）*<em>构成的*</em>分段动态数组</strong>，这些小块由一个<strong>中央控制结构（map，通常是指针数组）*<em>统一管理，因此整体上*</em>不连续</strong>。<code>deque</code> 支持头部操作但不支持空间管理函数，<code>vector</code> 适合连续内存优化，支持 <code>data()</code>、<code>reserve()</code>、<code>shrink_to_fit()</code> 等内存操作。 <code>vector</code> 和 <code>deque</code> 在 <strong>API 层面上虽然大多数接口相同，但也存在以下几点</strong>显著差异**：</p>
<hr>
<h4 id="构造函数">构造函数</h4>
<p>与vector的构造函数很类似</p>
<table>
<thead>
<tr>
<th>构造函数形式</th>
<th>功能描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>deque()</code></td>
<td>默认构造，创建空容器</td>
<td><code>std::deque&lt;int&gt; dq;</code></td>
</tr>
<tr>
<td><code>deque(size_type n)</code></td>
<td>创建包含 <code>n</code> 个默认值元素的容器</td>
<td><code>std::deque&lt;int&gt; dq(5);</code></td>
</tr>
<tr>
<td><code>deque(size_type n, const T&amp; val)</code></td>
<td>创建包含 <code>n</code> 个值为 <code>val</code> 的元素</td>
<td><code>std::deque&lt;int&gt; dq(3, 42);</code></td>
</tr>
<tr>
<td><code>deque(InputIt first, InputIt last)</code></td>
<td>用迭代器区间 <code>[first, last)</code> 构造容器</td>
<td><code>std::deque&lt;int&gt; dq(vec.begin(), vec.end());</code></td>
</tr>
<tr>
<td><code>deque(const deque&amp; other)</code></td>
<td>拷贝构造函数，复制另一个容器</td>
<td><code>std::deque&lt;int&gt; dq2(dq1);</code></td>
</tr>
<tr>
<td><code>deque(deque&amp;&amp; other)</code> <em>(C++11)</em></td>
<td>移动构造函数，接管另一个容器资源</td>
<td><code>std::deque&lt;int&gt; dq2(std::move(dq1));</code></td>
</tr>
<tr>
<td><code>deque(std::initializer_list&lt;T&gt; ilist)</code> <em>(C++11)</em></td>
<td>使用初始化列表构造容器</td>
<td><code>std::deque&lt;int&gt; dq = {1, 2, 3};</code></td>
</tr>
</tbody>
</table>
<h4 id="与-vector-api-上的区别">与 vector API 上的区别</h4>
<table>
<thead>
<tr>
<th>功能类别</th>
<th><code>vector</code></th>
<th><code>deque</code></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>头部插入/删除</strong></td>
<td>❌ 无 <code>push_front</code> / <code>pop_front</code></td>
<td>✅ 有 <code>push_front</code> / <code>pop_front</code></td>
<td>这是最明显的区别之一</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>✅ <code>reserve()</code> / <code>capacity()</code> / <code>shrink_to_fit()</code></td>
<td>❌ 不支持这些函数</td>
<td><code>deque</code> 不暴露连续空间概念</td>
</tr>
<tr>
<td><strong>随机访问</strong></td>
<td>✅ <code>operator[]</code>, <code>at()</code></td>
<td>✅ 同样支持</td>
<td>接口一样，性能略有差别</td>
</tr>
<tr>
<td><strong>构造函数与赋值</strong></td>
<td>✅ 基本一致</td>
<td>✅ 基本一致</td>
<td>如构造、<code>assign()</code> 等均支持</td>
</tr>
<tr>
<td><strong>数据指针获取</strong></td>
<td>✅ <code>data()</code></td>
<td>⚠️ 无 <code>data()</code></td>
<td><code>deque</code> 元素非连续，无法获取底层指针</td>
</tr>
<tr>
<td><strong>空间大小控制</strong></td>
<td>✅ <code>capacity()</code> 表示分配空间大小</td>
<td>❌ 无此 API</td>
<td><code>deque</code> 内部是block链表，不存在 capacity</td>
</tr>
</tbody>
</table>
<h4 id="与-vector-内存结构-上的区别">与 vector 内存结构 上的区别</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>vector</code></th>
<th><code>deque</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>内存结构</td>
<td>一整块连续内存</td>
<td>多块分段内存（非连续）</td>
</tr>
<tr>
<td>指针访问</td>
<td><code>data()</code> 可用</td>
<td>无 <code>data()</code>（不能整体访问）</td>
</tr>
<tr>
<td>局部性（cache 命中）</td>
<td>优秀（线性）</td>
<td>较差（跨 block）</td>
</tr>
<tr>
<td>增长方式</td>
<td>一次性重新分配更大空间</td>
<td>增加新的 block</td>
</tr>
</tbody>
</table>
<h4 id="deque内部结构图简化示意">deque内部结构图（简化示意）</h4>
<pre><code>std::deque 内存布局示意：

        map（指针数组）
        ↓
  +-----+-----+-----+-----+
  |  →  |  →  |  →  |  →  |   ← 控制中心
  +-----+-----+-----+-----+
     ↓     ↓     ↓     ↓
   block  block block block
   [x x]  [x x] [x x] [x x] ← 实际元素在这些 block 中存储（固定大小）
</code></pre>
<ul>
<li>每个 block 通常存储 512~4096 字节左右（依元素类型大小决定）</li>
<li>当 deque 两端插入导致空间不足时，它会：
<ul>
<li>分配新 block（前/后扩展）</li>
<li>可能重新分配指针数组（map）</li>
</ul>
</li>
</ul>
<h4 id="实验验证deque-内存不连续">实验验证<code>deque</code> 内存不连续</h4>
<p>你可以验证 <code>deque</code> 是否连续：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;deque&gt;

int main() {
    std::deque&lt;int&gt; dq;

    // 插入较多元素，促使 deque 使用多个 block
    for (int i = 0; i &lt; 1000; ++i) {
        dq.push_back(i);
    }

    // 打印地址，并检测地址跳变
    const void* last_addr = nullptr;

    for (size_t i = 0; i &lt; dq.size(); ++i) {
        const void* addr = static_cast&lt;const void*&gt;(&amp;dq[i]);

        if (last_addr != nullptr) {
            // 判断是否连续（以 sizeof(int) 为步长）
            std::ptrdiff_t diff = static_cast&lt;const char*&gt;(addr) - static_cast&lt;const char*&gt;(last_addr);
            if (diff != sizeof(int)) {
                std::cout &lt;&lt; "⚠️  Address jump detected at i = " &lt;&lt; i
                          &lt;&lt; " (diff = " &lt;&lt; diff &lt;&lt; " bytes)\n";
            }
        }

        // 输出地址
        std::cout &lt;&lt; "dq[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; dq[i]
                  &lt;&lt; " | address: " &lt;&lt; addr &lt;&lt; "\n";

        last_addr = addr;
    }

    return 0;
}

</code></pre>
<h4 id="常用函数一览表">常用函数一览表</h4>
<table>
<thead>
<tr>
<th>类别</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>增</td>
<td><code>push_back(val)</code></td>
<td>尾部插入</td>
</tr>
<tr>
<td></td>
<td><code>push_front(val)</code></td>
<td>头部插入</td>
</tr>
<tr>
<td></td>
<td><code>insert(pos, val)</code></td>
<td>插入元素</td>
</tr>
<tr>
<td>删</td>
<td><code>pop_back()</code> / <code>pop_front()</code></td>
<td>删除尾/头元素</td>
</tr>
<tr>
<td></td>
<td><code>erase(pos)</code> / <code>clear()</code></td>
<td>删除指定位置 / 全部</td>
</tr>
<tr>
<td>改</td>
<td><code>dq[i] = x</code> / <code>dq.at(i)</code></td>
<td>修改第 i 个元素</td>
</tr>
<tr>
<td>查</td>
<td><code>dq[i]</code> / <code>at(i)</code> / <code>front()</code> / <code>back()</code></td>
<td>访问元素</td>
</tr>
<tr>
<td>其他</td>
<td><code>size()</code>, <code>empty()</code>, <code>begin()</code>, <code>end()</code></td>
<td>常规容器操作</td>
</tr>
</tbody>
</table>
<h2 id="3-listt">3. <code>list&lt;T&gt;</code></h2>
<p>虽然 <code>std::list</code> 和 <code>std::deque</code> 都支持<strong>双端插入和删除</strong>，但它们在<strong>底层结构、功能特性和 API 上存在一些明显区别</strong>。</p>
<blockquote>
<p><code>deque</code> 是 <strong>双端数组容器</strong>，支持随机访问；<br>
<code>list</code> 是 <strong>双向链表容器</strong>，支持常量时间的中间插入删除。</p>
</blockquote>
<hr>
<h4 id="构造函数-1">构造函数</h4>
<table>
<thead>
<tr>
<th>构造函数形式</th>
<th>功能描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>list()</code></td>
<td>默认构造，创建空链表容器</td>
<td><code>std::list&lt;int&gt; lst;</code></td>
</tr>
<tr>
<td><code>list(size_type n)</code></td>
<td>创建包含 <code>n</code> 个默认值元素的链表</td>
<td><code>std::list&lt;int&gt; lst(5);</code></td>
</tr>
<tr>
<td><code>list(size_type n, const T&amp; val)</code></td>
<td>创建包含 <code>n</code> 个值为 <code>val</code> 的元素</td>
<td><code>std::list&lt;int&gt; lst(3, 42);</code></td>
</tr>
<tr>
<td><code>list(InputIt first, InputIt last)</code></td>
<td>用迭代器区间 <code>[first, last)</code> 构造链表</td>
<td><code>std::list&lt;int&gt; lst(vec.begin(), vec.end());</code></td>
</tr>
<tr>
<td><code>list(const list&amp; other)</code></td>
<td>拷贝构造，复制另一个链表</td>
<td><code>std::list&lt;int&gt; lst2(lst1);</code></td>
</tr>
<tr>
<td><code>list(list&amp;&amp; other)</code> <em>(C++11)</em></td>
<td>移动构造，接管另一个链表资源</td>
<td><code>std::list&lt;int&gt; lst2(std::move(lst1));</code></td>
</tr>
<tr>
<td><code>list(std::initializer_list&lt;T&gt; ilist)</code> <em>(C++11)</em></td>
<td>初始化列表构造</td>
<td><code>std::list&lt;int&gt; lst = {1, 2, 3};</code></td>
</tr>
</tbody>
</table>
<h4 id="api-区别总览重点">API 区别总览（重点）</h4>
<table>
<thead>
<tr>
<th>功能类别</th>
<th><code>std::deque</code></th>
<th><code>std::list</code></th>
<th>区别说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>随机访问</strong></td>
<td>✅ 支持 <code>operator[]</code>, <code>at()</code></td>
<td>❌ 不支持</td>
<td>list 无法直接访问第 i 个元素</td>
</tr>
<tr>
<td><strong>访问接口</strong></td>
<td><code>.at(i)</code>, <code>[i]</code>, <code>.front()</code>, <code>.back()</code></td>
<td><code>.front()</code>, <code>.back()</code></td>
<td>list 没有下标访问</td>
</tr>
<tr>
<td><strong>迭代器</strong></td>
<td>双向迭代器</td>
<td>双向迭代器</td>
<td>都是 bidirectional（list 不能做随机跳跃）</td>
</tr>
<tr>
<td><strong>插入位置</strong></td>
<td><code>.insert(pos, val)</code></td>
<td>✅ 同上</td>
<td>接口类似，list 插入效率更高</td>
</tr>
<tr>
<td><strong>删除元素</strong></td>
<td><code>.erase(pos)</code></td>
<td><code>.erase(pos)</code>, <code>.remove(val)</code></td>
<td>list 多了 <code>remove()</code> 和 <code>unique()</code> 等</td>
</tr>
<tr>
<td><strong>移动元素</strong></td>
<td>❌ 不支持</td>
<td>✅ <code>splice()</code></td>
<td>list 可直接移动其他 list 的节点（不拷贝）</td>
</tr>
<tr>
<td><strong>排序</strong></td>
<td>❌ 需 <code>std::sort</code>（必须 random access）</td>
<td>✅ 内建 <code>.sort()</code></td>
<td>list 内建排序，不用 <code>std::sort</code></td>
</tr>
<tr>
<td><strong>内存结构</strong></td>
<td>分段数组</td>
<td>双向链表</td>
<td>list 节点分散，不连续</td>
</tr>
<tr>
<td><strong>内存局部性</strong></td>
<td>好</td>
<td>差</td>
<td>deque 在性能上通常比 list 更好</td>
</tr>
</tbody>
</table>
<h4 id="list-独有-api"><code>list</code> 独有 API</h4>
<pre><code class="language-cpp">std::list&lt;int&gt; lst = {1, 2, 2, 3, 3, 4};

lst.remove(2);      // 删除所有值为2的元素
lst.unique();       // 去重：相邻重复元素只保留一个
lst.sort();         // 内建排序（非随机访问）
</code></pre>
<h2 id="4-forward_listtc11">4. <code>forward_list&lt;T&gt;</code>（C++11）</h2>
<blockquote>
<p><code>std::forward_list</code> 是<strong>单向链表</strong>，轻量、高效但功能少；<br>
<code>std::list</code> 是<strong>双向链表</strong>，功能强大但相对更重。</p>
</blockquote>
<hr>
<h4 id="forward_list-vs-list-api-对比总览"><code>forward_list</code> vs <code>list</code> API 对比总览</h4>
<table>
<thead>
<tr>
<th>功能类别</th>
<th><code>std::forward_list</code></th>
<th><code>std::list</code></th>
<th>区别说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>链表类型</strong></td>
<td>单向链表</td>
<td>双向链表</td>
<td>方向不同，结构完全不同</td>
</tr>
<tr>
<td><strong>迭代器类型</strong></td>
<td>单向（<code>forward_iterator</code>）</td>
<td>双向（<code>bidirectional_iterator</code>）</td>
<td><code>forward_list</code> 只能从前往后走</td>
</tr>
<tr>
<td><strong>遍历方向</strong></td>
<td>只能正向遍历</td>
<td>支持正向和反向遍历</td>
<td><code>list</code> 支持 <code>reverse_iterator</code></td>
</tr>
<tr>
<td><strong>头部插入</strong></td>
<td><code>.push_front()</code> / <code>.emplace_front()</code></td>
<td>✅ 支持</td>
<td></td>
</tr>
<tr>
<td><strong>尾部插入</strong></td>
<td>❌ 无 <code>.push_back()</code></td>
<td>✅ <code>.push_back()</code> / <code>.emplace_back()</code></td>
<td></td>
</tr>
<tr>
<td><strong>中间插入</strong></td>
<td><code>.insert_after(pos, val)</code></td>
<td><code>.insert(pos, val)</code></td>
<td>插入方式不同</td>
</tr>
<tr>
<td><strong>中间删除</strong></td>
<td><code>.erase_after(pos)</code></td>
<td><code>.erase(pos)</code></td>
<td>删除方式也不同</td>
</tr>
<tr>
<td><strong>删除所有指定值</strong></td>
<td><code>.remove(val)</code></td>
<td><code>.remove(val)</code></td>
<td>✅ 两者都支持</td>
</tr>
<tr>
<td><strong>排序</strong></td>
<td><code>.sort()</code></td>
<td><code>.sort()</code></td>
<td>✅ 都内建排序（非 <code>std::sort</code>）</td>
</tr>
<tr>
<td><strong>合并</strong></td>
<td><code>.merge()</code></td>
<td><code>.merge()</code></td>
<td>✅ 都支持（要求排序）</td>
</tr>
<tr>
<td><strong>去重</strong></td>
<td><code>.unique()</code></td>
<td><code>.unique()</code></td>
<td>✅ 都支持</td>
</tr>
<tr>
<td><strong>大小查询</strong></td>
<td>❌ 无 <code>.size()</code></td>
<td>✅ <code>.size()</code></td>
<td><code>forward_list</code> 需手动统计</td>
</tr>
<tr>
<td><strong>反转</strong></td>
<td><code>.reverse()</code></td>
<td><code>.reverse()</code></td>
<td>✅ 都支持</td>
</tr>
<tr>
<td><strong>splice（转移节点）</strong></td>
<td><code>.splice_after()</code></td>
<td><code>.splice()</code></td>
<td>名字和语义不同</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="示例对比">示例对比</h4>
<pre><code class="language-cpp">std::list&lt;int&gt; lst = {1, 2, 3, 4};
auto it = lst.begin();
++it;
lst.insert(it, 99);  // 在第二个位置插入
lst.erase(it);       // 删除第二个元素

std::forward_list&lt;int&gt; fl = {1, 2, 3, 4};
auto it = fl.before_begin();  // 注意：必须使用 before_begin()
fl.insert_after(it, 99);      // 在开头插入
fl.erase_after(it);           // 删除开头后一个元素
</code></pre>
<hr>
<h4 id="本质结构差异图示">本质结构差异图示：</h4>
<pre><code>std::forward_list （单向）：
[1] → [2] → [3] → nullptr

std::list （双向）：
nullptr ← [1] ⇄ [2] ⇄ [3] → nullptr
</code></pre>
<hr>
<h4 id="为什么没有push_back-api">为什么没有push_back api</h4>
<p><strong>性能问题</strong>：<code>push_back</code> 操作意味着在链表的末尾添加一个新元素。然而，在 <code>std::forward_list</code> 中，要找到链表的末尾需要从头开始遍历整个链表，因为每个节点只知道它的下一个节点是谁，而不知道它在整个链表中的位置或者如何快速访问最后一个节点。这意味着 <code>push_back</code> 的时间复杂度是 O(n)，其中 n 是链表的长度。对于一个以高效插入和删除为卖点的数据结构来说，这不是理想的设计选择。</p>
<h4 id="总结重点区别表">总结重点区别表</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>forward_list</code></th>
<th><code>list</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>链表方向</td>
<td>单向</td>
<td>双向</td>
</tr>
<tr>
<td>迭代器</td>
<td>单向迭代器</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>尾部插入</td>
<td>❌ 无</td>
<td>✅ 有</td>
</tr>
<tr>
<td>中间插入</td>
<td><code>.insert_after()</code></td>
<td><code>.insert()</code></td>
</tr>
<tr>
<td>删除方式</td>
<td><code>.erase_after()</code></td>
<td><code>.erase()</code></td>
</tr>
<tr>
<td>是否支持 <code>.size()</code></td>
<td>❌ 无</td>
<td>✅ 有</td>
</tr>
<tr>
<td>是否轻量</td>
<td>✅</td>
<td>❌ 略重</td>
</tr>
</tbody>
</table>
<h2 id="5-arrayt-nc11">5. <code>array&lt;T, N&gt;</code>（C++11）</h2>
<p><code>std::array</code> 是 C++11 引入的 <strong>定长数组容器</strong>，在头文件 <code>&lt;array&gt;</code> 中定义，提供了类似 STL 容器的接口但底层是<strong>栈上固定大小数组</strong>。</p>
<blockquote>
<p><code>std::array&lt;T, N&gt;</code> 是 C++ 中封装了原生数组的 STL 容器，大小固定、性能接近 C 数组，但支持标准容器接口。</p>
</blockquote>
<hr>
<h4 id="构造函数-2">构造函数</h4>
<table>
<thead>
<tr>
<th>构造/初始化形式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>默认构造</strong></td>
<td>元素未初始化（内置类型无默认值，需注意）</td>
<td><code>std::array&lt;int, 3&gt; a;</code></td>
</tr>
<tr>
<td><strong>列表初始化（推荐）</strong></td>
<td>直接初始化所有元素，大小固定必须匹配</td>
<td><code>std::array&lt;int, 3&gt; a = {1,2,3};</code></td>
</tr>
<tr>
<td><strong>拷贝构造/赋值</strong></td>
<td>支持，拷贝元素</td>
<td><code>std::array&lt;int, 3&gt; b(a);</code></td>
</tr>
</tbody>
</table>
<h4 id="常用-api-总览">常用 API 总览</h4>
<table>
<thead>
<tr>
<th>类别</th>
<th>成员函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素访问</td>
<td><code>at(i)</code></td>
<td>安全访问（越界抛异常）</td>
</tr>
<tr>
<td></td>
<td><code>operator[i]</code></td>
<td>非安全访问（无越界检查）</td>
</tr>
<tr>
<td></td>
<td><code>front()</code></td>
<td>返回首元素</td>
</tr>
<tr>
<td></td>
<td><code>back()</code></td>
<td>返回尾元素</td>
</tr>
<tr>
<td></td>
<td><code>data()</code></td>
<td>返回底层原始数组指针（T*）</td>
</tr>
<tr>
<td>容量</td>
<td><code>size()</code></td>
<td>返回元素数量（固定）</td>
</tr>
<tr>
<td></td>
<td><code>empty()</code></td>
<td>是否为空（即 <code>size == 0</code>）</td>
</tr>
<tr>
<td>迭代器</td>
<td><code>begin(), end()</code></td>
<td>正向迭代器</td>
</tr>
<tr>
<td></td>
<td><code>rbegin(), rend()</code></td>
<td>反向迭代器</td>
</tr>
<tr>
<td></td>
<td><code>cbegin(), cend()</code></td>
<td>const 版本</td>
</tr>
<tr>
<td>修改操作</td>
<td><code>fill(val)</code></td>
<td>全部元素填充为指定值</td>
</tr>
<tr>
<td></td>
<td><code>swap(other)</code></td>
<td>与另一个 <code>std::array</code> 交换内容</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="示例代码快速上手">示例代码：快速上手</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;array&gt;

int main() {
    std::array&lt;int, 5&gt; arr = {1, 2, 3, 4, 5};

    // 元素访问
    std::cout &lt;&lt; arr[0] &lt;&lt; "\n";        // 1
    std::cout &lt;&lt; arr.at(1) &lt;&lt; "\n";     // 2（越界抛异常）
    std::cout &lt;&lt; arr.front() &lt;&lt; "\n";   // 1
    std::cout &lt;&lt; arr.back() &lt;&lt; "\n";    // 5

    // 容量
    std::cout &lt;&lt; "size: " &lt;&lt; arr.size() &lt;&lt; "\n";    // 5
    std::cout &lt;&lt; "empty: " &lt;&lt; arr.empty() &lt;&lt; "\n";  // false

    // 迭代器
    for (int x : arr) {
        std::cout &lt;&lt; x &lt;&lt; " ";   // 1 2 3 4 5
    }
    std::cout &lt;&lt; "\n";

    // 修改操作
    arr.fill(9);
    for (int x : arr) std::cout &lt;&lt; x &lt;&lt; " ";  // 9 9 9 9 9
}
</code></pre>
<h4 id="stdarray-vs-stdvector"><code>std::array</code> vs <code>std::vector</code></h4>
<table>
<thead>
<tr>
<th>类别</th>
<th><code>std::vector</code></th>
<th><code>std::array</code></th>
<th>差异说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>大小可变性</td>
<td>✅ 动态变化</td>
<td>❌ 固定大小</td>
<td><code>vector</code> 支持增删元素，<code>array</code> 不支持</td>
</tr>
<tr>
<td>元素访问</td>
<td><code>operator[]</code>, <code>at()</code>, <code>front()</code>, <code>back()</code></td>
<td>同上</td>
<td>元素访问接口一致</td>
</tr>
<tr>
<td>获取裸指针</td>
<td><code>.data()</code></td>
<td><code>.data()</code></td>
<td>相同</td>
</tr>
<tr>
<td>容量相关</td>
<td><code>.size()</code>, <code>.capacity()</code>, <code>.empty()</code>, <code>.resize()</code>, <code>.reserve()</code></td>
<td><code>.size()</code>, <code>.empty()</code></td>
<td><code>array</code> 无 <code>.capacity()</code> 和 <code>.resize()</code></td>
</tr>
<tr>
<td>修改操作</td>
<td><code>.push_back()</code>, <code>.pop_back()</code>, <code>.insert()</code>, <code>.erase()</code></td>
<td>❌ 无这些操作</td>
<td><code>array</code> 不支持动态修改</td>
</tr>
<tr>
<td>元素填充</td>
<td>❌ 无 <code>.fill()</code></td>
<td>✅ <code>.fill(val)</code></td>
<td><code>array</code> 独有</td>
</tr>
<tr>
<td>交换内容</td>
<td><code>.swap()</code></td>
<td><code>.swap()</code></td>
<td>相同</td>
</tr>
<tr>
<td>迭代器</td>
<td><code>.begin()</code>, <code>.end()</code>, <code>rbegin()</code>, <code>rend()</code> 等</td>
<td>同上</td>
<td>支持一致的 STL 迭代器接口</td>
</tr>
<tr>
<td>内存位置</td>
<td>堆上分配（new）</td>
<td>栈上分配</td>
<td><code>array</code> 更轻量，<code>vector</code> 更灵活</td>
</tr>
</tbody>
</table>
<h1 id="关联式容器自动排序基于红黑树">关联式容器（自动排序，基于红黑树）</h1>
<table>
<thead>
<tr>
<th>容器名</th>
<th>特点</th>
<th>键是否唯一</th>
<th>复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>set</code></td>
<td>自动排序的集合</td>
<td>✅ 是</td>
<td>O(log n)</td>
</tr>
<tr>
<td><code>multiset</code></td>
<td>可重复元素集合</td>
<td>❌ 否</td>
<td>O(log n)</td>
</tr>
<tr>
<td><code>map</code></td>
<td>键值对（key-value）</td>
<td>✅ 是</td>
<td>O(log n)</td>
</tr>
<tr>
<td><code>multimap</code></td>
<td>可重复键的 map</td>
<td>❌ 否</td>
<td>O(log n)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>功能 / 容器</th>
<th>std::map</th>
<th>std::multimap</th>
<th>std::set</th>
<th>std::multiset</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>键唯一性</strong></td>
<td>是</td>
<td>否，允许重复键</td>
<td>是</td>
<td>否，允许重复元素</td>
</tr>
<tr>
<td><strong>元素类型</strong></td>
<td><code>pair&lt;const Key, Value&gt;</code></td>
<td><code>pair&lt;const Key, Value&gt;</code></td>
<td><code>Key</code></td>
<td><code>Key</code></td>
</tr>
<tr>
<td><strong>插入方式</strong></td>
<td><code>insert</code>, <code>emplace</code>, <code>operator[]</code></td>
<td><code>insert</code>, <code>emplace</code></td>
<td><code>insert</code>, <code>emplace</code></td>
<td><code>insert</code>, <code>emplace</code></td>
</tr>
<tr>
<td><strong>访问元素</strong></td>
<td>支持 <code>operator[]</code>, <code>at()</code></td>
<td>不支持</td>
<td>只支持查找</td>
<td>只支持查找</td>
</tr>
<tr>
<td><strong>查找元素</strong></td>
<td><code>find(key)</code>, <code>count(key) (0/1)</code></td>
<td><code>find(key)</code>, <code>count(key) (≥0)</code></td>
<td><code>find(val)</code>, <code>count(val) (0/1)</code></td>
<td><code>find(val)</code>, <code>count(val) (≥0)</code></td>
</tr>
<tr>
<td><strong>范围查询</strong></td>
<td><code>lower_bound</code>, <code>upper_bound</code>, <code>equal_range</code></td>
<td>同 <code>map</code></td>
<td>同 <code>map</code></td>
<td>同 <code>map</code></td>
</tr>
<tr>
<td><strong>删除元素</strong></td>
<td><code>erase(key)</code>, <code>erase(iterator)</code></td>
<td><code>erase(key)</code> 删除所有匹配元素</td>
<td><code>erase(value)</code>, <code>erase(iterator)</code></td>
<td><code>erase(value)</code>, <code>erase(iterator)</code></td>
</tr>
<tr>
<td><strong>元素排序</strong></td>
<td>默认按键升序</td>
<td>默认按键升序</td>
<td>默认按元素升序</td>
<td>默认按元素升序</td>
</tr>
<tr>
<td><strong>是否允许重复</strong></td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td><strong>是否支持下标</strong></td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td><strong>默认底层容器</strong></td>
<td>红黑树</td>
<td>红黑树</td>
<td>红黑树</td>
<td>红黑树</td>
</tr>
<tr>
<td><strong>典型用途</strong></td>
<td>唯一键值映射</td>
<td>一键多值映射</td>
<td>唯一有序集合</td>
<td>允许重复元素的有序集合</td>
</tr>
</tbody>
</table>
<h2 id="stdpair"><code>std::pair</code></h2>
<p><code>std::pair</code> 是 C++ 标准库中一个非常基础的模板类，定义在 <code>&lt;utility&gt;</code> 头文件里。它的作用是 <strong>将两个类型可以不同的值“成对”存储起来</strong>，是构建简单复合数据结构的便捷工具。</p>
<hr>
<h3 id="主要作用">主要作用</h3>
<ul>
<li><strong>成对存储两个数据</strong>，可以是不同类型，比如 <code>int</code> 和 <code>std::string</code>。</li>
<li>常用来表示键值对（比如 <code>std::map</code> 的元素类型就是 <code>std::pair&lt;const Key, Value&gt;</code>）。</li>
<li>用于函数返回多个值。</li>
<li>用作容器元素，方便存储关联的两个数据。</li>
</ul>
<hr>
<h3 id="定义示例">定义示例</h3>
<pre><code class="language-cpp">template &lt;class T1, class T2&gt;
struct pair {
    T1 first;
    T2 second;
};
</code></pre>
<hr>
<h3 id="典型用法示例">典型用法示例</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;utility&gt;  // std::pair
#include &lt;string&gt;

int main() {
    std::pair&lt;int, std::string&gt; p(1, "apple");

    std::cout &lt;&lt; "first: " &lt;&lt; p.first &lt;&lt; "\n";   // 输出 1
    std::cout &lt;&lt; "second: " &lt;&lt; p.second &lt;&lt; "\n"; // 输出 apple

    // 使用 std::make_pair 自动推导类型
    auto p2 = std::make_pair(2, 3.14);
    std::cout &lt;&lt; p2.first &lt;&lt; ", " &lt;&lt; p2.second &lt;&lt; "\n"; // 2, 3.14

    return 0;
}
</code></pre>
<hr>
<h3 id="常见操作">常见操作</h3>
<ul>
<li><code>p.first</code>：访问第一个元素</li>
<li><code>p.second</code>：访问第二个元素</li>
<li>比较运算符（==, &lt; 等）基于成员逐个比较</li>
</ul>
<hr>
<h3 id="在-stl-中的应用">在 STL 中的应用</h3>
<ul>
<li>
<p><code>std::map</code> 和 <code>std::multimap</code> 存储元素的类型是 <code>std::pair&lt;const Key, Value&gt;</code></p>
</li>
<li>
<p><code>std::unordered_map</code> 也是以 <code>std::pair</code> 表示元素</p>
</li>
<li>
<p>迭代器解包常用结构绑定：</p>
<pre><code class="language-cpp">for (const auto&amp; [key, val] : myMap) {
    // 直接访问 key 和 val
}
</code></pre>
</li>
</ul>
<h2 id="map"><code>map</code></h2>
<h3 id="关联容器-api-对比map-vs-multimap-vs-unordered_map">关联容器 API 对比：<code>map</code> vs <code>multimap</code> vs <code>unordered_map</code></h3>
<table>
<thead>
<tr>
<th>特性/容器</th>
<th><code>std::map</code></th>
<th><code>std::multimap</code></th>
<th><code>std::unordered_map</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>是否允许重复 key</strong></td>
<td>❌ 否</td>
<td>✅ 是</td>
<td>❌ 否</td>
</tr>
<tr>
<td><strong>key 排序方式</strong></td>
<td>✅ 按 key 升序（默认用 <code>&lt;</code>）</td>
<td>✅ 按 key 升序</td>
<td>❌ 无序（基于哈希）</td>
</tr>
<tr>
<td><strong>底层结构</strong></td>
<td>平衡二叉搜索树（通常是红黑树）</td>
<td>平衡二叉搜索树</td>
<td>哈希表</td>
</tr>
<tr>
<td><strong>平均时间复杂度</strong></td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(1)（最坏 O(n)）</td>
</tr>
<tr>
<td><strong>元素类型</strong></td>
<td><code>pair&lt;const Key, T&gt;</code></td>
<td><code>pair&lt;const Key, T&gt;</code></td>
<td><code>pair&lt;const Key, T&gt;</code></td>
</tr>
<tr>
<td><strong>访问元素方式</strong></td>
<td><code>operator[]</code>, <code>at()</code></td>
<td>❌ 不支持 <code>[]</code>，只能用 <code>insert</code>/<code>find</code></td>
<td><code>operator[]</code>, <code>at()</code></td>
</tr>
<tr>
<td><strong>插入方式</strong></td>
<td><code>insert</code>, <code>emplace</code>, <code>[]</code></td>
<td><code>insert</code>, <code>emplace</code></td>
<td><code>insert</code>, <code>emplace</code>, <code>[]</code></td>
</tr>
<tr>
<td><strong>删除方式</strong></td>
<td><code>erase(key)</code> / <code>erase(iterator)</code></td>
<td>同上</td>
<td>同上</td>
</tr>
<tr>
<td><strong>遍历顺序是否稳定/有序</strong></td>
<td>✅ 有序</td>
<td>✅ 有序</td>
<td>❌ 无序</td>
</tr>
<tr>
<td><strong>边界操作支持</strong></td>
<td>✅ <code>lower_bound</code>, <code>upper_bound</code></td>
<td>✅ <code>equal_range</code>, <code>lower_bound</code>, 等</td>
<td>❌ 不支持边界操作</td>
</tr>
<tr>
<td><strong>遍历所有重复 key 的值</strong></td>
<td>不适用（key 唯一）</td>
<td>✅ <code>equal_range(key)</code></td>
<td>不适用（key 唯一）</td>
</tr>
<tr>
<td><strong>典型使用场景</strong></td>
<td>一一映射、排序要求的数据结构</td>
<td>一对多映射（如成绩→学生）</td>
<td>快速哈希查找映射</td>
</tr>
</tbody>
</table>
<h3 id="示例代码对比">示例代码对比</h3>
<h4 id="stdmap-和stdunordered_map"><code>std::map</code> 和<code>std::unordered_map</code></h4>
<p><code>std::map</code> 和 <code>std::multimap</code>和<code>std::unordered_map</code>插入遍历是一致的，不同的是 <code>std::multimap</code>有时候可能遍历某个键的所有元素，使用 equal_range。</p>
<p>equal_range也可以用在 <code>std::map</code>和<code>std::unordered_map</code>，但是因为键是唯一的，没有必要。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;

int main() {
    std::map&lt;std::string, int&gt; mp;

    mp["apple"] = 3;
    mp["banana"] = 5;

    mp.insert({"orange", 7});    // 插入
    mp.emplace("pear", 2);       // 原地构造

    std::cout &lt;&lt; mp["apple"] &lt;&lt; "\n";     // 3

    if (mp.find("banana") != mp.end())
        std::cout &lt;&lt; "found\n";

    mp.erase("orange");          // 删除元素
    std::cout &lt;&lt; "C++17 及以上遍历：" &lt;&lt; "\n";     
    
    //遍历元素 范围基 for（结构化绑定，C++17 及以上）
    for (const auto&amp; [key, value] : mp) {
        std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\n";
    }
    std::cout &lt;&lt; "传统迭代器遍历：" &lt;&lt; "\n";     
    
    // 传统迭代器遍历写法
    for (auto it = mp.begin(); it != mp.end(); ++it) {
        std::cout &lt;&lt; it-&gt;first &lt;&lt; ": " &lt;&lt; it-&gt;second &lt;&lt; "\n";
    }

    return 0;
}
</code></pre>
<hr>
<h4 id="stdmultimap"><code>std::multimap</code></h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;

int main() {
    std::multimap&lt;std::string, int&gt; mmap;

    mmap.insert({"apple", 3});
    mmap.insert({"apple", 4});  // 允许重复 key

    std::cout &lt;&lt; "C++17 及以上遍历：" &lt;&lt; "\n";
    // 遍历所有元素（包含重复键）
    for (const auto&amp; [key, value] : mmap) {
        std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\n";
    }
    
    std::cout &lt;&lt; "遍历某个键的所有元素：" &lt;&lt; "\n";
    // 如果想遍历某个键的所有元素，使用 equal_range
    auto range = mmap.equal_range("apple");
    std::cout &lt;&lt; "All values for key 'apple': ";
    for (auto it = range.first; it != range.second; ++it) {
        std::cout &lt;&lt; it-&gt;second &lt;&lt; " ";
    }
    std::cout &lt;&lt; "\n";
}
</code></pre>
<hr>
<h2 id="set"><code>set</code></h2>
<h3 id="三种set对比">三种set对比</h3>
<table>
<thead>
<tr>
<th>特性/容器</th>
<th><code>std::set</code></th>
<th><code>std::multiset</code></th>
<th><code>std::unordered_set</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>元素是否唯一</td>
<td>✅ 是（自动去重）</td>
<td>❌ 否（允许重复）</td>
<td>✅ 是（自动去重）</td>
</tr>
<tr>
<td>元素是否有序</td>
<td>✅ 是（默认升序）</td>
<td>✅ 是（默认升序）</td>
<td>❌ 否（无序）</td>
</tr>
<tr>
<td>底层结构</td>
<td>红黑树</td>
<td>红黑树</td>
<td>哈希表</td>
</tr>
<tr>
<td>时间复杂度（插/删/查）</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>平均 O(1)，最坏 O(n)</td>
</tr>
<tr>
<td>插入方式</td>
<td><code>insert</code>, <code>emplace</code></td>
<td>同左</td>
<td>同左</td>
</tr>
<tr>
<td>删除方式</td>
<td><code>erase(val)</code>, <code>erase(it)</code></td>
<td>同左</td>
<td>同左</td>
</tr>
<tr>
<td>查找方式</td>
<td><code>find(val)</code>, <code>count(val)</code></td>
<td><code>find(val)</code>, <code>count(val)</code></td>
<td><code>find(val)</code>, <code>count(val)</code></td>
</tr>
<tr>
<td>范围操作（<code>lower_bound</code> 等）</td>
<td>✅ 支持</td>
<td>✅ 支持</td>
<td>❌ 不支持（哈希无顺序）</td>
</tr>
<tr>
<td>遍历顺序是否固定</td>
<td>✅ 升序</td>
<td>✅ 升序</td>
<td>❌ 无序</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="示例代码">示例代码</h3>
<h4 id="1-stdset-示例唯一且自动升序">1. <code>std::set</code> 示例：唯一且自动升序</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;set&gt;

int main() {
    std::set&lt;int&gt; s;

    s.insert(3);
    s.insert(1);
    s.insert(2);
    s.insert(2); // 重复元素不会插入

    for (int val : s) {
        std::cout &lt;&lt; val &lt;&lt; " ";  // 输出：1 2 3
    }

    if (s.count(2)) std::cout &lt;&lt; "\nFound 2\n";

    s.erase(2); // 删除元素
}
</code></pre>
<hr>
<h4 id="2-stdmultiset-示例允许重复元素">2. <code>std::multiset</code> 示例：允许重复元素</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;set&gt;

int main() {
    std::multiset&lt;int&gt; ms;

    ms.insert(2);
    ms.insert(1);
    ms.insert(2); // 允许插入重复元素

    for (int val : ms) {
        std::cout &lt;&lt; val &lt;&lt; " ";  // 输出：1 2 2
    }

    std::cout &lt;&lt; "\nCount of 2: " &lt;&lt; ms.count(2) &lt;&lt; "\n"; // 输出 2

    ms.erase(ms.find(2)); // 只删一个 2
}
</code></pre>
<hr>
<h4 id="3-stdunordered_set-示例唯一但无序">3. <code>std::unordered_set</code> 示例：唯一但无序</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

int main() {
    std::unordered_set&lt;int&gt; us;

    us.insert(2);
    us.insert(3);
    us.insert(1);
    us.insert(2); // 重复插入无效

    for (int val : us) {
        std::cout &lt;&lt; val &lt;&lt; " ";  // 输出顺序不确定
    }

    if (us.count(3)) std::cout &lt;&lt; "\nFound 3\n";

    us.erase(1); // 删除元素
}
</code></pre>
<h1 id="容器适配器不是独立容器是封装器">容器适配器（不是独立容器，是“封装器”）</h1>
<table>
<thead>
<tr>
<th>容器名</th>
<th>底层实现</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stack</code></td>
<td>默认用 <code>deque</code></td>
<td>后进先出（LIFO）</td>
</tr>
<tr>
<td><code>queue</code></td>
<td>默认用 <code>deque</code></td>
<td>先进先出（FIFO）</td>
</tr>
<tr>
<td><code>priority_queue</code></td>
<td>默认用 <code>vector</code> + <code>make_heap</code></td>
<td>优先队列（最大堆/最小堆）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="三种容器适配器对比">三种容器适配器对比</h2>
<table>
<thead>
<tr>
<th>适配器</th>
<th>行为模型</th>
<th>默认底层容器</th>
<th>支持的接口</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stack</code></td>
<td>后进先出（LIFO）</td>
<td><code>deque</code></td>
<td><code>push()</code>, <code>pop()</code>, <code>top()</code></td>
</tr>
<tr>
<td><code>queue</code></td>
<td>先进先出（FIFO）</td>
<td><code>deque</code></td>
<td><code>push()</code>, <code>pop()</code>, <code>front()</code>, <code>back()</code></td>
</tr>
<tr>
<td><code>priority_queue</code></td>
<td>最大堆（默认）</td>
<td><code>vector</code></td>
<td><code>push()</code>, <code>pop()</code>, <code>top()</code>，可自定义比较器</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="stdstack"><code>std::stack</code></h2>
<h3 id="stack常用-api-一览表">stack常用 API 一览表</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push(const T&amp; val)</code></td>
<td>将元素压入栈顶</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>移除栈顶元素（不返回）</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>top()</code></td>
<td>返回栈顶元素（不移除）</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>判断栈是否为空</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回元素数量</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>emplace(args...)</code></td>
<td>原地构造元素（C++11）</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>swap(other)</code></td>
<td>与另一个 <code>stack</code> 交换</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="示例代码-1">示例代码</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stack&gt;

int main() {
    std::stack&lt;int&gt; st;

    st.push(10);
    st.push(20);
    st.push(30);

    std::cout &lt;&lt; "Top: " &lt;&lt; st.top() &lt;&lt; "\n";  // 30

    st.pop();
    std::cout &lt;&lt; "Top after pop: " &lt;&lt; st.top() &lt;&lt; "\n";  // 20

    std::cout &lt;&lt; "Size: " &lt;&lt; st.size() &lt;&lt; "\n";  // 2
    std::cout &lt;&lt; "Is empty? " &lt;&lt; std::boolalpha &lt;&lt; st.empty() &lt;&lt; "\n";  // false

    // 原地构造（适合自定义类型）
    std::stack&lt;std::pair&lt;int, std::string&gt;&gt; pst;
    pst.emplace(1, "Hello");
    std::cout &lt;&lt; pst.top().second &lt;&lt; "\n";  // Hello
}
</code></pre>
<hr>
<h3 id="注意事项">注意事项</h3>
<ol>
<li>
<p><code>pop()</code> <strong>不会返回值</strong>，只能先用 <code>top()</code> 查看再 <code>pop()</code>。</p>
<pre><code class="language-cpp">int x = st.pop();  // ❌ 编译错误
</code></pre>
</li>
<li>
<p>默认底层容器是 <code>std::deque</code>，也可以使用 <code>std::vector</code>、<code>std::list</code>（但不推荐 <code>list</code>）。</p>
<pre><code class="language-cpp">std::stack&lt;int, std::vector&lt;int&gt;&gt; vstack;
</code></pre>
</li>
</ol>
<h2 id="stdqueue"><code>std::queue</code></h2>
<p><code>std::queue</code> 是 C++ STL 中的<strong>容器适配器</strong>，实现的是<strong>先进先出（FIFO）</strong>的队列行为。</p>
<ul>
<li>默认基于 <code>std::deque</code> 实现。</li>
<li>只能从<strong>队尾添加元素</strong>，从<strong>队头移除元素</strong>。</li>
<li>不支持迭代器、下标访问等功能。</li>
</ul>
<hr>
<h3 id="常用-api-总览-1">常用 API 总览</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push(const T&amp; val)</code></td>
<td>将元素加入队尾</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>emplace(args...)</code></td>
<td>在队尾原地构造元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>移除队头元素（不返回）</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>front()</code></td>
<td>返回队头元素（不移除）</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>back()</code></td>
<td>返回队尾元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>判断是否为空</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回元素个数</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>swap(other)</code></td>
<td>与另一个 queue 交换内容</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="示例代码-2">示例代码</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;

int main() {
    std::queue&lt;int&gt; q;

    q.push(10);
    q.push(20);
    q.push(30);

    std::cout &lt;&lt; "Front: " &lt;&lt; q.front() &lt;&lt; "\n";  // 10
    std::cout &lt;&lt; "Back: " &lt;&lt; q.back() &lt;&lt; "\n";    // 30

    q.pop();  // 移除10
    std::cout &lt;&lt; "New Front: " &lt;&lt; q.front() &lt;&lt; "\n";  // 20

    std::cout &lt;&lt; "Size: " &lt;&lt; q.size() &lt;&lt; "\n";    // 2
    std::cout &lt;&lt; "Empty? " &lt;&lt; std::boolalpha &lt;&lt; q.empty() &lt;&lt; "\n";  // false
}
</code></pre>
<hr>
<h3 id="注意事项-1">注意事项</h3>
<ol>
<li>
<p><code>pop()</code> 不返回值：</p>
<pre><code class="language-cpp">int x = q.pop(); // ❌ 编译错误！
</code></pre>
<p>需要先 <code>front()</code> 再 <code>pop()</code>：</p>
<pre><code class="language-cpp">int x = q.front();
q.pop();
</code></pre>
</li>
<li>
<p>不能访问中间元素或用下标：</p>
<pre><code class="language-cpp">q[0];     // ❌ 错误
for (auto it = q.begin(); ...)  // ❌ 错误
</code></pre>
</li>
<li>
<p>可以使用其他底层容器（如 <code>list</code>），但<strong>必须支持 <code>front()</code> / <code>back()</code> / <code>push_back()</code> / <code>pop_front()</code></strong>：</p>
<pre><code class="language-cpp">std::queue&lt;int, std::list&lt;int&gt;&gt; q2;
</code></pre>
</li>
</ol>
<h2 id="stdpriority_queue"><code>std::priority_queue</code></h2>
<p><code>std::priority_queue</code> 是 C++ STL 中的<strong>容器适配器</strong>，实现的是一个<strong>堆（heap）结构的优先队列</strong>。</p>
<ul>
<li><strong>默认行为</strong>：大顶堆（最大元素优先出队）</li>
<li><strong>底层容器</strong>：默认使用 <code>std::vector</code></li>
<li><strong>排序工具</strong>：基于 <code>std::make_heap</code> / <code>push_heap</code> / <code>pop_heap</code> 实现</li>
</ul>
<hr>
<h3 id="常用-api-总览-2">常用 API 总览</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push(const T&amp; val)</code></td>
<td>插入元素</td>
<td>O(log n)</td>
</tr>
<tr>
<td><code>emplace(args...)</code></td>
<td>原地构造元素（C++11）</td>
<td>O(log n)</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>移除优先级最高的元素</td>
<td>O(log n)</td>
</tr>
<tr>
<td><code>top()</code></td>
<td>查看优先级最高的元素</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>判断是否为空</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回元素数量</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>swap(other)</code></td>
<td>与另一个 <code>priority_queue</code> 交换内容</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="示例代码默认大顶堆">示例代码（默认大顶堆）</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;

int main() {
    std::priority_queue&lt;int&gt; pq;

    pq.push(10);
    pq.push(30);
    pq.push(20);

    std::cout &lt;&lt; pq.top() &lt;&lt; "\n"; // 30
    pq.pop();                      // 删除 30

    std::cout &lt;&lt; pq.top() &lt;&lt; "\n"; // 20
}
</code></pre>
<hr>
<h3 id="小顶堆写法自定义比较器">小顶堆写法（自定义比较器）</h3>
<pre><code class="language-cpp">#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;

std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;&gt;&gt; minHeap;

minHeap.push(5);
minHeap.push(2);
minHeap.push(8);

// 最小值优先
std::cout &lt;&lt; minHeap.top() &lt;&lt; "\n";  // 2
</code></pre>
<hr>
<h3 id="存储结构说明">存储结构说明</h3>
<pre><code class="language-cpp">template&lt;
    class T,
    class Container = std::vector&lt;T&gt;,
    class Compare = std::less&lt;typename Container::value_type&gt;
&gt; class priority_queue;
</code></pre>
<ul>
<li><code>T</code>: 元素类型</li>
<li><code>Container</code>: 底层容器（默认 <code>std::vector</code>）</li>
<li><code>Compare</code>: 比较器（默认 <code>std::less&lt;T&gt;</code>，即大顶堆）</li>
</ul>
<hr>
<h3 id="自定义类型示例">自定义类型示例</h3>
<pre><code class="language-cpp">struct Task {
    int priority;
    std::string name;
    bool operator&lt;(const Task&amp; other) const {
        return priority &lt; other.priority;  // 大顶堆：priority 高的优先
    }
};

std::priority_queue&lt;Task&gt; taskQ;
taskQ.push({5, "compile"});
taskQ.push({10, "build"});
std::cout &lt;&lt; taskQ.top().name;  // build
</code></pre>
<hr>
<h3 id="不支持的操作适配器特性">不支持的操作（适配器特性）</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>是否支持</th>
<th>原因说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>下标访问</td>
<td>❌</td>
<td>仅支持访问 <code>top()</code></td>
</tr>
<tr>
<td>迭代器遍历</td>
<td>❌</td>
<td>不支持遍历</td>
</tr>
<tr>
<td>排序顺序访问</td>
<td>❌</td>
<td>每次只能访问“堆顶最大”元素</td>
</tr>
</tbody>
</table>
<h2 id="总结对比表">总结对比表</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>行为模型</th>
<th>默认底层容器</th>
<th>主要接口</th>
<th>是否可自定义比较器</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stack</code></td>
<td>LIFO</td>
<td><code>deque</code></td>
<td><code>push</code>, <code>pop</code>, <code>top</code></td>
<td>❌</td>
</tr>
<tr>
<td><code>queue</code></td>
<td>FIFO</td>
<td><code>deque</code></td>
<td><code>push</code>, <code>pop</code>, <code>front</code>, <code>back</code></td>
<td>❌</td>
</tr>
<tr>
<td><code>priority_queue</code></td>
<td>堆</td>
<td><code>vector</code></td>
<td><code>push</code>, <code>pop</code>, <code>top</code></td>
<td>✅ 支持</td>
</tr>
</tbody>
</table>

</div>
<div id="MySignature" role="contentinfo">
    <p>未经作者同意请勿转载</p>
<p>本文来自博客园作者：<a href="https://www.cnblogs.com/aslanvon/" target="_blank">aixueforever</a>，原文链接：<a href="https://www.cnblogs.com/aslanvon/p/18946910" target="_blank">https://www.cnblogs.com/aslanvon/p/18946910</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-24 21:57">2025-06-24 21:56</span>&nbsp;
<a href="https://www.cnblogs.com/aslanvon">aixueforever</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18946910);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18946910', targetLink: 'https://www.cnblogs.com/aslanvon/p/18946910', title: 'STL 容器' })">举报</a>
</div>
        