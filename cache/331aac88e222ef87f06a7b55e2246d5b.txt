
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/itzgr/p/18763914" title="发布于 2025-03-10 22:49">
    <span role="heading" aria-level="2">附035.Kubernetes_v1.25.3高可用部署架构二</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#部署组件" rel="noopener nofollow">部署组件</a><ul><li><a href="#kubeadm介绍" rel="noopener nofollow">kubeadm介绍</a></li><li><a href="#kubelet介绍" rel="noopener nofollow">kubelet介绍</a></li><li><a href="#kubectl介绍" rel="noopener nofollow">kubectl介绍</a></li></ul></li><li><a href="#方案概述" rel="noopener nofollow">方案概述</a><ul><li><a href="#方案介绍" rel="noopener nofollow">方案介绍</a></li><li><a href="#部署规划" rel="noopener nofollow">部署规划</a><ul><li><a href="#节点规划" rel="noopener nofollow">节点规划</a></li></ul></li><li><a href="#主机名配置" rel="noopener nofollow">主机名配置</a></li><li><a href="#变量准备" rel="noopener nofollow">变量准备</a></li><li><a href="#互信配置" rel="noopener nofollow">互信配置</a></li><li><a href="#环境初始化" rel="noopener nofollow">环境初始化</a></li></ul></li><li><a href="#部署高可用组件" rel="noopener nofollow">部署高可用组件</a><ul><li><a href="#haproxy安装" rel="noopener nofollow">HAProxy安装</a></li><li><a href="#keepalived安装" rel="noopener nofollow">KeepAlived安装</a></li><li><a href="#创建配置文件" rel="noopener nofollow">创建配置文件</a></li><li><a href="#启动服务" rel="noopener nofollow">启动服务</a></li></ul></li><li><a href="#集群部署" rel="noopener nofollow">集群部署</a><ul><li><a href="#相关组件包" rel="noopener nofollow">相关组件包</a></li><li><a href="#正式安装" rel="noopener nofollow">正式安装</a></li></ul></li><li><a href="#集群初始化" rel="noopener nofollow">集群初始化</a><ul><li><a href="#拉取镜像" rel="noopener nofollow">拉取镜像</a></li><li><a href="#master01上初始化" rel="noopener nofollow">Master01上初始化</a></li><li><a href="#添加master节点" rel="noopener nofollow">添加Master节点</a></li></ul></li><li><a href="#安装nic插件" rel="noopener nofollow">安装NIC插件</a><ul><li><a href="#nic插件介绍" rel="noopener nofollow">NIC插件介绍</a></li><li><a href="#部署calico" rel="noopener nofollow">部署calico</a></li><li><a href="#修改node端口范围" rel="noopener nofollow">修改node端口范围</a></li></ul></li><li><a href="#添加worker节点" rel="noopener nofollow">添加Worker节点</a><ul><li><a href="#添加worker节点-1" rel="noopener nofollow">添加Worker节点</a></li><li><a href="#确认验证" rel="noopener nofollow">确认验证</a></li></ul></li><li><a href="#metrics部署" rel="noopener nofollow">Metrics部署</a><ul><li><a href="#metrics介绍" rel="noopener nofollow">Metrics介绍</a></li><li><a href="#metrics特点" rel="noopener nofollow">Metrics特点</a></li><li><a href="#metrics需求" rel="noopener nofollow">Metrics需求</a></li><li><a href="#开启聚合层" rel="noopener nofollow">开启聚合层</a></li><li><a href="#获取部署文件" rel="noopener nofollow">获取部署文件</a></li><li><a href="#正式部署" rel="noopener nofollow">正式部署</a></li><li><a href="#查看资源监控" rel="noopener nofollow">查看资源监控</a></li></ul></li><li><a href="#nginx-ingress部署" rel="noopener nofollow">Nginx ingress部署</a><ul><li><a href="#设置标签" rel="noopener nofollow">设置标签</a></li><li><a href="#获取资源" rel="noopener nofollow">获取资源</a></li><li><a href="#修改配置" rel="noopener nofollow">修改配置</a></li><li><a href="#确认验证-1" rel="noopener nofollow">确认验证</a></li></ul></li><li><a href="#dashboard部署" rel="noopener nofollow">Dashboard部署</a><ul><li><a href="#设置标签-1" rel="noopener nofollow">设置标签</a></li><li><a href="#创建证书" rel="noopener nofollow">创建证书</a></li><li><a href="#手动创建secret" rel="noopener nofollow">手动创建secret</a></li><li><a href="#下载yaml" rel="noopener nofollow">下载yaml</a></li><li><a href="#修改yaml" rel="noopener nofollow">修改yaml</a></li><li><a href="#正式部署-1" rel="noopener nofollow">正式部署</a></li><li><a href="#创建管理员账户" rel="noopener nofollow">创建管理员账户</a></li><li><a href="#创建kubeconfig文件" rel="noopener nofollow">创建kubeconfig文件</a></li><li><a href="#导入证书" rel="noopener nofollow">导入证书</a></li></ul></li><li><a href="#ingress暴露dashboard" rel="noopener nofollow">ingress暴露dashboard</a><ul><li><a href="#创建ingress-tls" rel="noopener nofollow">创建ingress tls</a></li><li><a href="#创建ingress策略" rel="noopener nofollow">创建ingress策略</a></li><li><a href="#测试访问dashboard" rel="noopener nofollow">测试访问dashboard</a></li></ul></li><li><a href="#longhorn存储部署" rel="noopener nofollow">Longhorn存储部署</a><ul><li><a href="#longhorn概述" rel="noopener nofollow">Longhorn概述</a></li><li><a href="#基础软件安装" rel="noopener nofollow">基础软件安装</a></li><li><a href="#设置标签-2" rel="noopener nofollow">设置标签</a></li><li><a href="#准备磁盘" rel="noopener nofollow">准备磁盘</a></li><li><a href="#配置longhorn" rel="noopener nofollow">配置Longhorn</a></li><li><a href="#正式部署-2" rel="noopener nofollow">正式部署</a></li><li><a href="#动态sc创建" rel="noopener nofollow">动态sc创建</a></li><li><a href="#测试pv及pvc" rel="noopener nofollow">测试PV及PVC</a></li><li><a href="#ingress暴露longhorn" rel="noopener nofollow">Ingress暴露Longhorn</a></li><li><a href="#确认验证-2" rel="noopener nofollow">确认验证</a></li></ul></li><li><a href="#helm部署" rel="noopener nofollow">Helm部署</a><ul><li><a href="#helm介绍" rel="noopener nofollow">helm介绍</a></li><li><a href="#helm优势" rel="noopener nofollow">Helm优势</a></li><li><a href="#前置准备" rel="noopener nofollow">前置准备</a></li><li><a href="#二进制安装helm" rel="noopener nofollow">二进制安装Helm</a></li><li><a href="#helm操作" rel="noopener nofollow">Helm操作</a></li><li><a href="#查找chart" rel="noopener nofollow">查找chart</a></li><li><a href="#添加repo" rel="noopener nofollow">添加repo</a></li></ul></li><li><a href="#扩展集群扩容及缩容" rel="noopener nofollow">扩展：集群扩容及缩容</a><ul><li><a href="#集群扩容" rel="noopener nofollow">集群扩容</a></li><li><a href="#集群缩容" rel="noopener nofollow">集群缩容</a></li></ul></li></ul></div><p></p>
<h2 id="部署组件">部署组件</h2>
<p>该 Kubernetes 部署过程中，对于部署环节，涉及多个组件，主要有 kubeadm 、kubelet 、kubectl。</p>
<h3 id="kubeadm介绍">kubeadm介绍</h3>
<p>Kubeadm 为构建 Kubernetes 提供了便捷、高效的“最佳实践” ，该工具提供了初始化完整 Kubernetes 过程所需的组件，其主要命令及功能有：</p>
<ul>
<li>kubeadm init：用于搭建 Kubernetes 控制平面节点；</li>
<li>kubeadm join：用于搭建 Kubernetes 工作节点并将其加入到集群中；</li>
<li>kubeadm upgrade：用于升级 Kubernetes 集群到新版本；</li>
<li>kubeadm token：用于管理 kubeadm join 使用的 token；</li>
<li>kubeadm reset：用于恢复（重置）通过 kubeadm init 或者 kubeadm join 命令对节点进行的任何变更；</li>
<li>kubeadm certs：用于管理 Kubernetes 证书；</li>
<li>kubeadm kubeconfig：用于管理 kubeconfig 文件；</li>
<li>kubeadm version：用于显示（查询）kubeadm 的版本信息；</li>
<li>kubeadm alpha：用于预览当前从社区收集到的反馈中的 kubeadm 特性。</li>
</ul>
<h3 id="kubelet介绍">kubelet介绍</h3>
<p>kubelet 是 Kubernetes 集群中用于操作 Docker 、containerd 等容器运行时的核心组件，需要在每个节点运行。通常该操作是基于 CRI 实现，kubelet 和 CRI 交互，以便于实现对 Kubernetes 的管控。</p>
<p>kubelet 主要用于配置容器网络、管理容器数据卷等容器全生命周期，对于 kubelet 而言，其主要的功能核心有：</p>
<ul>
<li>Pod 更新事件；</li>
<li>Pod 生命周期管理；</li>
<li>上报 Node 节点信息。</li>
</ul>
<h3 id="kubectl介绍">kubectl介绍</h3>
<p>kubectl 控制 Kubernetes 集群管理器，是作为 Kubernetes 的命令行工具，用于与 apiserver 进行通信，使用 kubectl 工具在 Kubernetes 上部署和管理应用程序。<br>
使用 kubectl，可以检查群集资源的创建、删除和更新组件。<br>
同时集成了大量子命令，可更便捷的管理 Kubernetes 集群，主要命令如下：</p>
<ul>
<li>Kubetcl -h：显示子命令；</li>
<li>kubectl option：查看全局选项；</li>
<li>kubectl &lt;command&gt; --help：查看子命令帮助信息；</li>
<li>kubelet [command] [PARAMS] -o=&lt;format&gt;：设置输出格式，如json、yaml等；</li>
<li>Kubetcl explain [RESOURCE]：查看资源的定义。</li>
</ul>
<h2 id="方案概述">方案概述</h2>
<h3 id="方案介绍">方案介绍</h3>
<p>本方案基于 kubeadm 部署工具实现完整生产环境可用的 Kubernetes 高可用集群，同时提供相关 Kubernetes 周边组件。<br>
其主要信息如下：</p>
<ul>
<li>本方案采用 kubeadm 部署 Kubernetes 1.25.3 版本；</li>
<li>基于国产化需求出发，底层操作系统为 Anolis 8.3 64；</li>
<li>etcd采用融合方式；</li>
<li>KeepAlived：用于实现 apiserver 的高可用；</li>
<li>HAProxy：以系统 systemd 服务形式运行，提供反向代理至3个 master 6443 端口；</li>
<li>其他主要部署组件包括：
<ul>
<li>Metrics：度量组件，用于提供相关监控指标；</li>
<li>Dashboard：Kubernetes 集群的前端图形界面；</li>
<li>Helm：Kubernetes Helm 包管理器工具，用于后续使用 helm 整合包快速部署应用；</li>
<li>Ingress：Kubernetes 服务暴露应用，用于提供7层的负载均衡，类似 Nginx，可建立外部和内部的多个映射规则；</li>
<li>containerd：Kubernetes底层容器时；</li>
<li>Longhorn：Kubernetes 动态存储组件，用于提供 Kubernetes 的持久存储。</li>
</ul>
</li>
</ul>
<p><font color="red">提示：本方案部署所使用脚本均由本人提供，可能不定期更新。 </font></p>
<h3 id="部署规划">部署规划</h3>
<h4 id="节点规划">节点规划</h4>
<table>
<thead>
<tr>
<th style="text-align: center">节点主机名</th>
<th style="text-align: center">IP</th>
<th style="text-align: center">类型</th>
<th style="text-align: center">运行服务</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">master01</td>
<td style="text-align: center">172.24.8.151</td>
<td style="text-align: center">Kubernetes master节点</td>
<td style="text-align: center">kubeadm、kubelet、kubectl、KeepAlived、HAProxy、containerd、etcd、kube-apiserver、kube-scheduler、kube-controller-manager、calico、WebUI、metrics、ingress、Longhorn存储节点</td>
</tr>
<tr>
<td style="text-align: center">master02</td>
<td style="text-align: center">172.24.8.152</td>
<td style="text-align: center">Kubernetes master节点</td>
<td style="text-align: center">kubeadm、kubelet、kubectl、KeepAlived、HAProxy、containerd、etcd、kube-apiserver、kube-scheduler、kube-controller-manager、calico、WebUI、metrics、ingress、Longhorn存储节点</td>
</tr>
<tr>
<td style="text-align: center">master03</td>
<td style="text-align: center">172.24.8.153</td>
<td style="text-align: center">Kubernetes master节点</td>
<td style="text-align: center">kubeadm、kubelet、kubectl、KeepAlived、HAProxy、containerd、etcd、kube-apiserver、kube-scheduler、kube-controller-manager、calico、WebUI、metrics、ingress、Longhorn存储节点</td>
</tr>
<tr>
<td style="text-align: center">worker01</td>
<td style="text-align: center">172.24.8.154</td>
<td style="text-align: center">Kubernetes worker节点</td>
<td style="text-align: center">kubelet、containerd、calico、Longhorn存储节点</td>
</tr>
<tr>
<td style="text-align: center">worker02</td>
<td style="text-align: center">172.24.8.155</td>
<td style="text-align: center">Kubernetes worker节点</td>
<td style="text-align: center">kubelet、containerd、calico、Longhorn存储节点</td>
</tr>
<tr>
<td style="text-align: center">worker03</td>
<td style="text-align: center">172.24.8.156</td>
<td style="text-align: center">Kubernetes worker节点</td>
<td style="text-align: center">kubelet、containerd、calico、Longhorn存储节点</td>
</tr>
<tr>
<td style="text-align: center">worker04</td>
<td style="text-align: center">172.24.8.157</td>
<td style="text-align: center">Kubernetes worker节点</td>
<td style="text-align: center">kubelet、containerd、calico、Longhorn存储节点</td>
</tr>
</tbody>
</table>
<p>Kubernetes集群高可用主要指的是控制平面的高可用，多个Master节点组件（通常为奇数）和Etcd组件的高可用，worker节点通过前端负载均衡VIP连接到Master。</p>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f022/001.png" alt="架构图" loading="lazy"></p>
<p>Kubernetes高可用架构中etcd与Master节点组件混合部署方式特点：</p>
<ul>
<li>所需服务器节点资源少，具备超融合架构特点</li>
<li>部署简单，利于管理</li>
<li>容易进行横向扩展</li>
<li>etcd复用Kubernetes的高可用</li>
<li>存在一定风险，如一台master主机挂了，master和etcd都少了一个节点，集群冗余度受到一定影响</li>
</ul>
<p><font color="red">提示：本实验使用Keepalived+HAProxy架构实现Kubernetes的高可用。 </font></p>
<h3 id="主机名配置">主机名配置</h3>
<p>需要对所有节点主机名进行相应配置。</p>
<pre><code>[root@localhost ~]# hostnamectl set-hostname master01	    #其他节点依次修改
</code></pre>
<p>生产环境通常建议在内网部署dns服务器，使用dns服务器进行解析，本指南采用本地hosts文件名进行解析。<br>
如下hosts文件修改仅需在master01执行，后续使用批量分发至其他所有节点。</p>
<pre><code>[root@master01 ~]# cat &gt;&gt; /etc/hosts &lt;&lt; EOF
172.24.8.151 master01
172.24.8.152 master02
172.24.8.153 master03
172.24.8.154 worker01
172.24.8.155 worker02
172.24.8.156 worker03
EOF
</code></pre>
<h3 id="变量准备">变量准备</h3>
<p>为实现自动化部署，自动化分发相关文件，提前定义相关主机名、IP组、变量等。</p>
<pre><code>[root@master01 ~]# vi environment.sh            #确认相关主机名和IP
#!/bin/sh
#****************************************************************#
# ScriptName: environment.sh
# Author: xhy
# Create Date: 2022-10-11 17:10
# Modify Author: xhy
# Modify Date: 2022-11-12 22:22
# Version: v1
#***************************************************************#

# 集群 MASTER 机器 IP 数组
export MASTER_IPS=(172.24.8.151 172.24.8.152 172.24.8.153)

# 集群 MASTER IP 对应的主机名数组
export MASTER_NAMES=(master01 master02 master03)

# 集群 NODE 机器 IP 数组
export NODE_IPS=(172.24.8.154 172.24.8.155 172.24.8.156)

# 集群 NODE IP 对应的主机名数组
export NODE_NAMES=(worker01 worker02 worker03)

# 集群所有机器 IP 数组
export ALL_IPS=(172.24.8.151 172.24.8.152 172.24.8.153 172.24.8.154 172.24.8.155 172.24.8.156)

# 集群所有IP 对应的主机名数组
export ALL_NAMES=(master01 master02 master03 worker01 worker02 worker03)
</code></pre>
<h3 id="互信配置">互信配置</h3>
<p>为了方便远程分发文件和执行命令，本方案配置master01节点到其它节点的 ssh信任关系，即免秘钥管理所有其他节点。</p>
<pre><code>[root@master01 ~]# source environment.sh                                #载入变量
    
[root@master01 ~]# ssh-keygen -f ~/.ssh/id_rsa -N ''
[root@master01 ~]# for all_ip in ${ALL_IPS[@]}
  do
    echo "&gt;&gt;&gt; ${all_ip}"
    ssh-copy-id -i ~/.ssh/id_rsa.pub root@${all_ip}
  done
</code></pre>
<p><font color="red">提示：此操作仅需要在master01节点操作。 </font></p>
<h3 id="环境初始化">环境初始化</h3>
<p>kubeadm本身仅用于部署Kubernetes集群，在正式使用kubeadm部署Kubernetes集群之前需要对操作系统环境进行准备，即环境初始化准备。<br>
环境的初始化准备本方案使用脚本自动完成。<br>
使用如下脚本对基础环境进行初始化，主要功能包括：</p>
<ul>
<li>安装containerd，Kubernetes平台底层的容器组件</li>
<li>关闭SELinux及防火墙</li>
<li>优化相关内核参数，针对生产环境Kubernetes集群的基础系统调优配置</li>
<li>关闭swap</li>
<li>设置相关模块，主要为转发模块</li>
<li>配置相关基础软件，部署Kubernetes集群所需要的基础依赖包</li>
</ul>
<pre><code>[root@master01 ~]# vim k8sconinit.sh
#!/bin/sh
#****************************************************************#
# ScriptName: k8sconinit.sh
# Author: xhy
# Create Date: 2020-05-30 16:30
# Modify Author: xhy
# Modify Date: 2022-11-12 21:30
# Version: v1
#***************************************************************#
# Initialize the machine. This needs to be executed on every machine.
rm -f /var/lib/rpm/__db.00*
rpm -vv --rebuilddb
#yum clean all 
#yum makecache
sleep 3s
# Install containerd
CONVERSION=1.4.9
yum -y install yum-utils device-mapper-persistent-data lvm2
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
sudo sed -i 's+download.docker.com+mirrors.aliyun.com/docker-ce+' /etc/yum.repos.d/docker-ce.repo
sleep 3s
yum -y install containerd.io-${CONVERSION}
mkdir /etc/containerd

cat &gt; /etc/containerd/config.toml &lt;&lt;EOF
disabled_plugins = ["restart"]

[plugins.linux]
shim_debug = true

[plugins.cri.registry.mirrors."docker.io"]
endpoint = ["https://dbzucv6w.mirror.aliyuncs.com"]

[plugins.cri]
sandbox_image = "registry.k8s.io/pause:3.8"
EOF

cat &gt; /etc/crictl.yaml &lt;&lt;EOF
runtime-endpoint: unix:///run/containerd/containerd.sock
image-endpoint: unix:///run/containerd/containerd.sock
timeout: 10
debug: false
EOF

systemctl restart containerd
systemctl enable containerd --now
systemctl status containerd

# Disable the SELinux.
sed -i 's/^SELINUX=.*/SELINUX=disabled/' /etc/selinux/config

# Turn off and disable the firewalld.
systemctl stop firewalld
systemctl disable firewalld

# Modify related kernel parameters &amp; Disable the swap.
cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF
net.ipv4.ip_forward = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.tcp_tw_recycle = 0
vm.swappiness = 0
vm.overcommit_memory = 1
vm.panic_on_oom = 0
net.ipv6.conf.all.disable_ipv6 = 1
EOF
sysctl -p /etc/sysctl.d/k8s.conf &gt;&amp;/dev/null
swapoff -a
sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
modprobe br_netfilter
modprobe overlay

# Add ipvs modules
cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF
#!/bin/bash
modprobe -- ip_vs
modprobe -- ip_vs_rr
modprobe -- ip_vs_wrr
modprobe -- ip_vs_sh
modprobe -- nf_conntrack_ipv4
modprobe -- nf_conntrack
modprobe -- br_netfilter
modprobe -- overlay
EOF

chmod 755 /etc/sysconfig/modules/ipvs.modules
bash /etc/sysconfig/modules/ipvs.modules

# Install rpm
yum install -y conntrack ipvsadm ipset jq iptables curl sysstat libseccomp wget iproute-tc

# Update kernel
# rpm --import http://down.linuxsb.com/RPM-GPG-KEY-elrepo.org
# rpm -Uvh http://down.linuxsb.com/elrepo-release-7.el7.elrepo.noarch.rpm
# mv -b /etc/yum.repos.d/elrepo.repo /etc/yum.repos.d/backup
# wget -c http://down.linuxsb.com/myoptions/elrepo7.repo -O /etc/yum.repos.d/elrepo.repo 
# yum --disablerepo="*" --enablerepo="elrepo-kernel" install -y kernel-ml
# sed -i 's/^GRUB_DEFAULT=.*/GRUB_DEFAULT=0/' /etc/default/grub
# grub2-mkconfig -o /boot/grub2/grub.cfg
# yum -y --exclude=docker* update

# Reboot the machine.
# reboot
</code></pre>
<p><font color="red">提示：此操作仅需要在master01节点操作。</font></p><font color="red">
</font><ul><font color="red">
<li>对于某些特性，可能需要升级内核，内核升级操作见<a href="https://www.cnblogs.com/itzgr/p/14668991.html" target="_blank">018.Linux升级内核</a>。</li>
<li>4.19版及以上内核nf_conntrack_ipv4已经改为nf_conntrack。</li>
</font><li><font color="red">Kubernetes 1.24.0后可兼容的containerd版本最新为1.4.9。 </font></li>
</ul>
<pre><code>[root@master01 ~]# source environment.sh
[root@master01 ~]# chmod +x *.sh
[root@master01 ~]# for all_ip in ${ALL_IPS[@]}
  do
    echo "&gt;&gt;&gt; ${all_ip}"
    scp -rp /etc/hosts root@${all_ip}:/etc/hosts
    scp -rp k8sconinit.sh root@${all_ip}:/root/
    ssh root@${all_ip} "bash /root/k8sconinit.sh"
  done
</code></pre>
<h2 id="部署高可用组件">部署高可用组件</h2>
<p><a></a></p>
<h3 id="haproxy安装">HAProxy安装</h3>
<p>HAProxy是可提供高可用性、负载均衡以及基于TCP(从而可以反向代理kubeapiserver等应用)和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种高可用解决方案。</p>
<pre><code class="language-shell">[root@master01 ~]# wget http://down.linuxsb.com/software/haproxy-2.6.6.tar.gz
[root@master01 ~]# for master_ip in ${MASTER_IPS[@]}
  do
    echo "&gt;&gt;&gt; ${master_ip}"
    ssh root@${master_ip} "yum -y install gcc gcc-c++ make libnl3 libnl3-devel libnfnetlink openssl-devel wget openssh-clients systemd-devel zlib-devel pcre-devel"
    scp -rp haproxy-2.6.6.tar.gz root@${master_ip}:/root/
    ssh root@${master_ip} "tar -zxvf haproxy-2.6.6.tar.gz"
    ssh root@${master_ip} "cd haproxy-2.6.6/ &amp;&amp; make ARCH=x86_64 TARGET=linux-glibc USE_PCRE=1 USE_ZLIB=1 USE_SYSTEMD=1 PREFIX=/usr/local/haprpxy &amp;&amp; make install PREFIX=/usr/local/haproxy"
    ssh root@${master_ip} "cp /usr/local/haproxy/sbin/haproxy /usr/sbin/"
    ssh root@${master_ip} "useradd -r haproxy &amp;&amp; usermod -G haproxy haproxy"
    ssh root@${master_ip} "mkdir -p /etc/haproxy &amp;&amp; cp -r /root/haproxy-2.6.6/examples/errorfiles/ /usr/local/haproxy/"
  done
</code></pre>
<p><a></a></p>
<h3 id="keepalived安装">KeepAlived安装</h3>
<p>KeepAlived 是一个基于VRRP协议来实现的LVS服务高可用方案，可以解决静态路由出现的单点故障问题。<br>
本方案3台master节点均部署并运行Keepalived，一台为主服务器（MASTER），另外两台为备份服务器（BACKUP）。<br>
Master集群外表现为一个VIP，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候，备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性。</p>
<pre><code class="language-shell">[root@master01 ~]# wget https://www.keepalived.org/software/keepalived-2.2.7.tar.gz
[root@master01 ~]# for master_ip in ${MASTER_IPS[@]}
  do
    echo "&gt;&gt;&gt; ${master_ip}"
    ssh root@${master_ip} "yum -y install curl gcc gcc-c++ make libnl3 libnl3-devel libnfnetlink openssl-devel"
    scp -rp keepalived-2.2.7.tar.gz root@${master_ip}:/root/
    ssh root@${master_ip} "tar -zxvf keepalived-2.2.7.tar.gz"
    ssh root@${master_ip} "cd keepalived-2.2.7/ &amp;&amp; LDFLAGS=\"$LDFAGS -L /usr/local/openssl/lib/\" ./configure --sysconf=/etc --prefix=/usr/local/keepalived &amp;&amp; make &amp;&amp; make install"
    ssh root@${master_ip} "systemctl enable keepalived &amp;&amp; systemctl restart keepalived"
  done
</code></pre>
<p><font color="red">提示：如上仅需Master01节点操作，从而实现所有节点自动化安装。若出现如下报错：undefined reference to `OPENSSL_init_ssl’，可带上openssl lib路径： </font></p>
<p><font color="red"><code>LDFLAGS="$LDFAGS -L /usr/local/openssl/lib/" ./configure --sysconf=/etc --prefix=/usr/local/keepalived</code> </font></p>
<h3 id="创建配置文件">创建配置文件</h3>
<p>创建集群部署所需的相关组件配置，采用脚本自动化创建相关配置文件。</p>
<pre><code class="language-shell">[root@master01 ~]# wget http://down.linuxsb.com/mydeploy/k8s/v1.25.3/k8sconfig.sh				#拉取自动部署脚本

[root@master01 ~]# vim k8sconfig.sh
#!/bin/sh
#****************************************************************#
# ScriptName: k8sconfig
# Author: xhy
# Create Date: 2022-06-08 20:00
# Modify Author: xhy
# Modify Date: 2022-11-12 22:21
# Version: v3
#***************************************************************#

#######################################
# set variables below to create the config files, all files will create at ./kubeadm directory
#######################################

# master keepalived virtual ip address
export K8SHA_VIP=172.24.8.100

# master01 ip address
export K8SHA_IP1=172.24.8.151

# master02 ip address
export K8SHA_IP2=172.24.8.152

# master03 ip address
export K8SHA_IP3=172.24.8.153

# master01 hostname
export K8SHA_HOST1=master01

# master02 hostname
export K8SHA_HOST2=master02

# master03 hostname
export K8SHA_HOST3=master03

# master01 network interface name
export K8SHA_NETINF1=eth0

# master02 network interface name
export K8SHA_NETINF2=eth0

# master03 network interface name
export K8SHA_NETINF3=eth0

# keepalived auth_pass config
export K8SHA_KEEPALIVED_AUTH=412f7dc3bfed32194d1600c483e10ad1d

# kubernetes CIDR pod subnet
export K8SHA_PODCIDR=10.10.0.0

# kubernetes CIDR svc subnet
export K8SHA_SVCCIDR=10.20.0.0

##############################
# please do not modify anything below
##############################

mkdir -p kubeadm/$K8SHA_HOST1/{keepalived,haproxy}
mkdir -p kubeadm/$K8SHA_HOST2/{keepalived,haproxy}
mkdir -p kubeadm/$K8SHA_HOST3/{keepalived,haproxy}
mkdir -p kubeadm/keepalived
mkdir -p kubeadm/haproxy

# wget all files
wget -c -P kubeadm/keepalived/ http://down.linuxsb.com/mydeploy/k8s/common/k8s-keepalived.conf.tpl
wget -c -P kubeadm/keepalived/ http://down.linuxsb.com/mydeploy/k8s/common/check_apiserver.sh
wget -c -P kubeadm/haproxy/ http://down.linuxsb.com/mydeploy/k8s/common/k8s-haproxy.cfg.tpl
wget -c -P kubeadm/haproxy/ http://down.linuxsb.com/mydeploy/k8s/common/k8s-haproxy.service
wget -c -P kubeadm/ http://down.linuxsb.com/mydeploy/k8s/v1.25.3/kubeadm-config.yaml.tpl
wget -c -P kubeadm/calico/ http://down.linuxsb.com/mydeploy/k8s/calico/v3.24.5/calico.yaml.tpl
wget -c -P kubeadm/ http://down.linuxsb.com/mydeploy/k8s/v1.25.3/conloadimage.sh

# create all kubeadm-config.yaml files
sed \
-e "s/K8SHA_HOST1/${K8SHA_HOST1}/g" \
-e "s/K8SHA_HOST2/${K8SHA_HOST2}/g" \
-e "s/K8SHA_HOST3/${K8SHA_HOST3}/g" \
-e "s/K8SHA_IP1/${K8SHA_IP1}/g" \
-e "s/K8SHA_IP2/${K8SHA_IP2}/g" \
-e "s/K8SHA_IP3/${K8SHA_IP3}/g" \
-e "s/K8SHA_VIP/${K8SHA_VIP}/g" \
-e "s/K8SHA_PODCIDR/${K8SHA_PODCIDR}/g" \
-e "s/K8SHA_SVCCIDR/${K8SHA_SVCCIDR}/g" \
kubeadm/kubeadm-config.yaml.tpl &gt; kubeadm/kubeadm-config.yaml

echo "create kubeadm-config.yaml files success. kubeadm-config.yaml"

# create all keepalived files
chmod u+x kubeadm/keepalived/check_apiserver.sh
cp kubeadm/keepalived/check_apiserver.sh kubeadm/$K8SHA_HOST1/keepalived
cp kubeadm/keepalived/check_apiserver.sh kubeadm/$K8SHA_HOST2/keepalived
cp kubeadm/keepalived/check_apiserver.sh kubeadm/$K8SHA_HOST3/keepalived

sed \
-e "s/K8SHA_KA_STATE/BACKUP/g" \
-e "s/K8SHA_KA_INTF/${K8SHA_NETINF1}/g" \
-e "s/K8SHA_IPLOCAL/${K8SHA_IP1}/g" \
-e "s/K8SHA_KA_PRIO/102/g" \
-e "s/K8SHA_VIP/${K8SHA_VIP}/g" \
-e "s/K8SHA_KA_AUTH/${K8SHA_KEEPALIVED_AUTH}/g" \
kubeadm/keepalived/k8s-keepalived.conf.tpl &gt; kubeadm/$K8SHA_HOST1/keepalived/keepalived.conf

sed \
-e "s/K8SHA_KA_STATE/BACKUP/g" \
-e "s/K8SHA_KA_INTF/${K8SHA_NETINF2}/g" \
-e "s/K8SHA_IPLOCAL/${K8SHA_IP2}/g" \
-e "s/K8SHA_KA_PRIO/101/g" \
-e "s/K8SHA_VIP/${K8SHA_VIP}/g" \
-e "s/K8SHA_KA_AUTH/${K8SHA_KEEPALIVED_AUTH}/g" \
kubeadm/keepalived/k8s-keepalived.conf.tpl &gt; kubeadm/$K8SHA_HOST2/keepalived/keepalived.conf

sed \
-e "s/K8SHA_KA_STATE/BACKUP/g" \
-e "s/K8SHA_KA_INTF/${K8SHA_NETINF3}/g" \
-e "s/K8SHA_IPLOCAL/${K8SHA_IP3}/g" \
-e "s/K8SHA_KA_PRIO/100/g" \
-e "s/K8SHA_VIP/${K8SHA_VIP}/g" \
-e "s/K8SHA_KA_AUTH/${K8SHA_KEEPALIVED_AUTH}/g" \
kubeadm/keepalived/k8s-keepalived.conf.tpl &gt; kubeadm/$K8SHA_HOST3/keepalived/keepalived.conf

echo "create keepalived files success. kubeadm/$K8SHA_HOST1/keepalived/"
echo "create keepalived files success. kubeadm/$K8SHA_HOST2/keepalived/"
echo "create keepalived files success. kubeadm/$K8SHA_HOST3/keepalived/"

# create all haproxy files
sed \
-e "s/K8SHA_IP1/$K8SHA_IP1/g" \
-e "s/K8SHA_IP2/$K8SHA_IP2/g" \
-e "s/K8SHA_IP3/$K8SHA_IP3/g" \
-e "s/K8SHA_HOST1/$K8SHA_HOST1/g" \
-e "s/K8SHA_HOST2/$K8SHA_HOST2/g" \
-e "s/K8SHA_HOST3/$K8SHA_HOST3/g" \
kubeadm/haproxy/k8s-haproxy.cfg.tpl &gt; kubeadm/haproxy/haproxy.conf

echo "create haproxy files success. kubeadm/$K8SHA_HOST1/haproxy/"
echo "create haproxy files success. kubeadm/$K8SHA_HOST2/haproxy/"
echo "create haproxy files success. kubeadm/$K8SHA_HOST3/haproxy/"

# create calico yaml file
sed \
-e "s/K8SHA_PODCIDR/${K8SHA_PODCIDR}/g" \
kubeadm/calico/calico.yaml.tpl &gt; kubeadm/calico/calico.yaml

# scp all file
scp -rp kubeadm/haproxy/haproxy.conf root@$K8SHA_HOST1:/etc/haproxy/haproxy.cfg
scp -rp kubeadm/haproxy/haproxy.conf root@$K8SHA_HOST2:/etc/haproxy/haproxy.cfg
scp -rp kubeadm/haproxy/haproxy.conf root@$K8SHA_HOST3:/etc/haproxy/haproxy.cfg
scp -rp kubeadm/haproxy/k8s-haproxy.service root@$K8SHA_HOST1:/usr/lib/systemd/system/haproxy.service
scp -rp kubeadm/haproxy/k8s-haproxy.service root@$K8SHA_HOST2:/usr/lib/systemd/system/haproxy.service
scp -rp kubeadm/haproxy/k8s-haproxy.service root@$K8SHA_HOST3:/usr/lib/systemd/system/haproxy.service

scp -rp kubeadm/$K8SHA_HOST1/keepalived/* root@$K8SHA_HOST1:/etc/keepalived/
scp -rp kubeadm/$K8SHA_HOST2/keepalived/* root@$K8SHA_HOST2:/etc/keepalived/
scp -rp kubeadm/$K8SHA_HOST3/keepalived/* root@$K8SHA_HOST3:/etc/keepalived/

# chmod *.sh
chmod u+x kubeadm/*.sh
</code></pre>
<p><code>[root@master01 ~]# bash k8sconfig.sh</code></p>
<p><font color="red">解释：如上仅需Master01节点操作。执行k8sconfig.sh脚本后会生产如下配置文件清单：</font></p><font color="red">
</font><ul><font color="red">
<li>kubeadm-config.yaml：kubeadm初始化配置文件，位于kubeadm/目录，可参考 <a href="https://kubernetes.io/zh-cn/docs/reference/config-api/kubeadm-config.v1beta3/" target="_blank" rel="noopener nofollow">kubeadm 配置 </a></li>
<li>keepalived：keepalived配置文件，位于各个master节点的/etc/keepalived目录</li>
<li>haproxy：haproxy的配置文件，位于各个master节点的/etc/haproxy/目录</li>
</font><li><font color="red">calico.yaml：calico网络组件部署文件，位于kubeadm/calico/目录 </font></li>
</ul>
<pre><code>[root@master01 ~]# vim kubeadm/kubeadm-config.yaml	#检查集群初始化配置
---
apiVersion: kubeadm.k8s.io/v1beta3
kind: ClusterConfiguration
networking:
  serviceSubnet: "10.20.0.0/16"			     	    #设置svc网段
  podSubnet: "10.10.0.0/16"                         #设置Pod网段
  dnsDomain: "cluster.local"
kubernetesVersion: "v1.25.3"			    	    #设置安装版本
controlPlaneEndpoint: "172.24.8.100:16443"		    #设置相关API VIP地址
apiServer:
  certSANs:
  - master01
  - master02
  - master03
  - 127.0.0.1
  - 172.24.8.151
  - 172.24.8.152
  - 172.24.8.153
  - 172.24.8.100
  timeoutForControlPlane: 4m0s
certificatesDir: "/etc/kubernetes/pki"
imageRepository: "registry.k8s.io"
#clusterName: "example-cluster"

---
apiVersion: kubeproxy.config.k8s.io/v1alpha1
kind: KubeProxyConfiguration
mode: ipvs
</code></pre>
<p><font color="red">提示：如上仅需Master01节点操作，更多config文件参考：<a href="https://kubernetes.io/zh-cn/docs/reference/config-api/kubeadm-config.v1beta3/" target="_blank" rel="noopener nofollow">kubeadm 配置 (v1beta3)</a><br>
默认kubeadm配置可使用kubeadm config print init-defaults &gt; config.yaml生成。 </font></p>
<h3 id="启动服务">启动服务</h3>
<p>启动keepalive和HAProxy服务，从而构建master节点的高可用。</p>
<ul>
<li>检查服务配置</li>
</ul>
<pre><code>[root@master01 ~]# cat /etc/keepalived/keepalived.conf              #所有节点确认相关keepalive配置文件
! Configuration File for keepalived
global_defs {
    router_id LVS_DEVEL
    script_user root
    enable_script_security
}
vrrp_script check_apiserver {
    script "/etc/keepalived/check_apiserver.sh"
    interval 5
    weight -60
    fall 2
    rise 2
}
vrrp_instance VI_1 {
    state BACKUP
    interface eth0
    mcast_src_ip 172.24.8.151
    virtual_router_id 51
    priority 102
    advert_int 5
    authentication {
        auth_type PASS
        auth_pass 412f7dc3bfed32194d1600c483e10ad1d
    }
    virtual_ipaddress {
        172.24.8.100
    }
    track_script {
       check_apiserver
    }
}

[root@master01 ~]# cat /etc/keepalived/check_apiserver.sh              #所有节点确认相关keepalive监测脚本文件
#!/bin/bash

# if check error then repeat check for 12 times, else exit
err=0
for k in $(seq 1 12)
do
    check_code=$(curl -k https://localhost:6443)
    if [[ $check_code == "" ]]; then
        err=$(expr $err + 1)
        sleep 5
        continue
    else
        err=0
        break
    fi
done

if [[ $err != "0" ]]; then
    # if apiserver is down send SIG=1
    echo 'apiserver error!'
    exit 1
else
    # if apiserver is up send SIG=0
    echo 'apiserver normal!'
    exit 0
fi
</code></pre>
<ul>
<li>启动高可用服务</li>
</ul>
<pre><code>[root@master01 ~]# for master_ip in ${MASTER_IPS[@]}
do
    echo "&gt;&gt;&gt; ${master_ip}"
    ssh root@${master_ip} "systemctl enable haproxy.service --now &amp;&amp; systemctl restart haproxy.service"
    ssh root@${master_ip} "systemctl enable keepalived.service --now &amp;&amp; systemctl restart keepalived.service"
    ssh root@${master_ip} "systemctl status keepalived.service | grep Active"
    ssh root@${master_ip} "systemctl status haproxy.service | grep Active"
done

[root@master01 ~]# for all_ip in ${ALL_IPS[@]}
do
    echo "&gt;&gt;&gt; ${all_ip}"
    ssh root@${all_ip} "ping -c1 172.24.8.100"
done								                #等待10s执行检查

</code></pre>
<p><font color="red">提示：如上仅需Master01节点操作，从而实现所有节点自动启动服务。 </font></p>
<h2 id="集群部署">集群部署</h2>
<h3 id="相关组件包">相关组件包</h3>
<p>需要在每台机器上都安装以下的软件包：</p>
<ul>
<li>kubeadm: 用来初始化集群的指令；</li>
<li>kubelet: 在集群中的每个节点上用来启动 pod 和 container 等；</li>
<li>kubectl: 用来与集群通信的命令行工具。</li>
</ul>
<p>kubeadm不能安装或管理 kubelet 或 kubectl ，因此在初始化集群之前必须完成kubelet和kubectl的安装，且能保证他们满足通过 kubeadm 安装的 Kubernetes控制层对版本的要求。<br>
如果版本没有满足匹配要求，可能导致一些意外错误或问题。<br>
具体相关组件安装见；<a href="https://www.cnblogs.com/itzgr/p/10258937.html" target="_blank">附001.kubectl介绍及使用书</a> </p>
<p><font color="red">提示：Kubernetes 1.25.3版本所有兼容相应组件的版本参考：<a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.25.md" target="_blank" rel="noopener nofollow">https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.25.md</a> 。</font></p>
<h3 id="正式安装">正式安装</h3>
<p>快速安装所有节点的kubeadm、kubelet、kubectl组件。</p>
<pre><code>[root@master01 ~]# for all_ip in ${ALL_IPS[@]}
  do
    echo "&gt;&gt;&gt; ${all_ip}"
    ssh root@${all_ip} "cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF"
    ssh root@${all_ip} "yum install -y kubeadm-1.25.3-0.x86_64 kubelet-1.25.3-0.x86_64 kubectl-1.25.3-0.x86_64 --disableexcludes=kubernetes"
    ssh root@${all_ip} "systemctl enable kubelet"
done

[root@master01 ~]# yum search -y kubelet --showduplicates             #查看相应版本 
</code></pre>
<p><font color="red">提示：如上仅需Master01节点操作，从而实现所有节点自动化安装，同时此时不需要启动kubelet，初始化的过程中会自动启动的，如果此时启动了会出现报错，忽略即可。 </font></p>
<p><font color="red">说明：同时安装了cri-tools, kubernetes-cni, socat三个依赖：<br>
socat：kubelet的依赖；<br>
cri-tools：即CRI(Container Runtime Interface)容器运行时接口的命令行工具。 </font></p>
<h2 id="集群初始化">集群初始化</h2>
<h3 id="拉取镜像">拉取镜像</h3>
<p>初始化过程中会pull大量镜像，并且镜像位于国外，可能出现无法pull的情况导致Kubernetes初始化失败。建议提前准备镜像，保证后续初始化。</p>
<pre><code>[root@master01 ~]# kubeadm --kubernetes-version=v1.25.3 config images list     	#列出所需镜像

[root@master01 ~]# vim kubeadm/k8simage.sh
#!/bin/sh
#****************************************************************#
# ScriptName: conloadimage.sh
# Author: xhy
# Create Date: 2021-04-15 14:03
# Modify Author: xhy
# Modify Date: 2022-11-20 00:01
# Version: 
#***************************************************************#

KUBE_VERSION=v1.25.3
KUBE_PAUSE_VERSION=3.8
ETCD_VERSION=3.5.4-0
CORE_DNS_VERSION=v1.9.3
K8S_URL=registry.k8s.io
GCR_URL=k8s.gcr.io
UCLOUD_URL=uhub.service.ucloud.cn/imxhy
LONGHORN_URL=longhornio
CALICO_URL='docker.io/calico'
CALICO_VERSION=v3.24.5
METRICS_SERVER_VERSION=v0.6.1
INGRESS_VERSION=v1.5.1
INGRESS_WEBHOOK_VERSION=v20220916-gd32f8c343
LONGHORN1_VERSION=master-head
LONGHORN2_VERSION=v3_20221117
LONGHORN3_VERSION=v3_20220808
LONGHORN4_VERSION=v1_20220914
#CSI_PROVISIONER_VERSION=v1.6.0-lh1
#CSI_NODE_DRIVER_VERSION=v1.2.0-lh1
#CSI_ATTACHER_VERSION=v2.2.1-lh1
#CSI_RESIZER_VERSION=v0.5.1-lh1
#DEFAULTBACKENDVERSION=1.5
#ALIYUN_URL=registry.cn-hangzhou.aliyuncs.com/google_containers

mkdir -p k8simages/

# config node hostname
export ALL_NAMES=(master02 master03 worker01 worker02 worker03)

kubeimages=(kube-proxy:${KUBE_VERSION}
kube-scheduler:${KUBE_VERSION}
kube-controller-manager:${KUBE_VERSION}
kube-apiserver:${KUBE_VERSION}
pause:${KUBE_PAUSE_VERSION}
etcd:${ETCD_VERSION}
)

for kubeimageName in ${kubeimages[@]} ; do
echo ${kubeimageName}
ctr -n k8s.io images pull ${UCLOUD_URL}/${kubeimageName}
ctr -n k8s.io images tag ${UCLOUD_URL}/${kubeimageName} ${K8S_URL}/${kubeimageName}
ctr -n k8s.io images rm ${UCLOUD_URL}/${kubeimageName}
ctr -n k8s.io images export k8simages/${kubeimageName}\.tar ${K8S_URL}/${kubeimageName}
done

corednsimages=(coredns:${CORE_DNS_VERSION}
)

for corednsimageName in ${corednsimages[@]} ; do
echo ${corednsimageName}
ctr -n k8s.io images pull ${UCLOUD_URL}/${corednsimageName}
ctr -n k8s.io images tag ${UCLOUD_URL}/${corednsimageName} ${K8S_URL}/coredns/${corednsimageName}
ctr -n k8s.io images rm ${UCLOUD_URL}/${corednsimageName}
ctr -n k8s.io images export k8simages/${corednsimageName}\.tar ${K8S_URL}/coredns/${corednsimageName}
done

metricsimages=(metrics-server:${METRICS_SERVER_VERSION})

for metricsimageName in ${metricsimages[@]} ; do
echo ${metricsimageName}
ctr -n k8s.io images pull ${UCLOUD_URL}/${metricsimageName}
ctr -n k8s.io images tag ${UCLOUD_URL}/${metricsimageName} ${GCR_URL}/metrics-server/${metricsimageName}
ctr -n k8s.io images rm ${UCLOUD_URL}/${metricsimageName}
ctr -n k8s.io images export k8simages/${metricsimageName}\.tar ${GCR_URL}/metrics-server/${metricsimageName}
done

calimages=(cni:${CALICO_VERSION}
node:${CALICO_VERSION}
kube-controllers:${CALICO_VERSION})

for calimageName in ${calimages[@]} ; do
echo ${calimageName}
ctr -n k8s.io images pull ${UCLOUD_URL}/${calimageName}
ctr -n k8s.io images tag ${UCLOUD_URL}/${calimageName} ${CALICO_URL}/${calimageName}
ctr -n k8s.io images rm ${UCLOUD_URL}/${calimageName}
ctr -n k8s.io images export k8simages/${calimageName}\.tar ${CALICO_URL}/${calimageName}
done

ingressimages=(controller:${INGRESS_VERSION}
kube-webhook-certgen:${INGRESS_WEBHOOK_VERSION}
)

for ingressimageName in ${ingressimages[@]} ; do
echo ${ingressimageName}
ctr -n k8s.io images pull ${UCLOUD_URL}/${ingressimageName}
ctr -n k8s.io images tag ${UCLOUD_URL}/${ingressimageName} ${K8S_URL}/ingress-nginx/${ingressimageName}
ctr -n k8s.io images rm ${UCLOUD_URL}/${ingressimageName}
ctr -n k8s.io images export k8simages/${ingressimageName}\.tar ${K8S_URL}/ingress-nginx/${ingressimageName}
done

longhornimages01=(longhorn-manager:${LONGHORN1_VERSION}
longhorn-ui:${LONGHORN1_VERSION}
longhorn-engine:${LONGHORN1_VERSION}
)

for longhornimageNameA in ${longhornimages01[@]} ; do
echo ${longhornimageNameA}
ctr -n k8s.io images pull ${UCLOUD_URL}/${longhornimageNameA}
ctr -n k8s.io images tag ${UCLOUD_URL}/${longhornimageNameA} ${LONGHORN_URL}/${longhornimageNameA}
ctr -n k8s.io images rm ${UCLOUD_URL}/${longhornimageNameA}
ctr -n k8s.io images export k8simages/${longhornimageNameA}\.tar ${LONGHORN_URL}/${longhornimageNameA}
done

longhornimages02=(longhorn-instance-manager:${LONGHORN2_VERSION}
)

for longhornimageNameB in ${longhornimages02[@]} ; do
echo ${longhornimageNameB}
ctr -n k8s.io images pull ${UCLOUD_URL}/${longhornimageNameB}
ctr -n k8s.io images tag ${UCLOUD_URL}/${longhornimageNameB} ${LONGHORN_URL}/${longhornimageNameB}
ctr -n k8s.io images rm ${UCLOUD_URL}/${longhornimageNameB}
ctr -n k8s.io images export k8simages/${longhornimageNameB}\.tar ${LONGHORN_URL}/${longhornimageNameB}
done

longhornimages03=(backing-image-manager:${LONGHORN3_VERSION})

for longhornimageNameC in ${longhornimages03[@]} ; do
echo ${longhornimageNameC}
ctr -n k8s.io images pull ${UCLOUD_URL}/${longhornimageNameC}
ctr -n k8s.io images tag ${UCLOUD_URL}/${longhornimageNameC} ${LONGHORN_URL}/${longhornimageNameC}
ctr -n k8s.io images rm ${UCLOUD_URL}/${longhornimageNameC}
ctr -n k8s.io images export k8simages/${longhornimageNameC}\.tar ${LONGHORN_URL}/${longhornimageNameC}
done

longhornimages04=(longhorn-share-manager:${LONGHORN4_VERSION})

for longhornimageNameD in ${longhornimages04[@]} ; do
echo ${longhornimageNameD}
ctr -n k8s.io images pull ${UCLOUD_URL}/${longhornimageNameD}
ctr -n k8s.io images tag ${UCLOUD_URL}/${longhornimageNameD} ${LONGHORN_URL}/${longhornimageNameD}
ctr -n k8s.io images rm ${UCLOUD_URL}/${longhornimageNameD}
ctr -n k8s.io images export k8simages/${longhornimageNameD}\.tar ${LONGHORN_URL}/${longhornimageNameD}
done

#csiimages=(csi-provisioner:${CSI_PROVISIONER_VERSION}
#csi-node-driver-registrar:${CSI_NODE_DRIVER_VERSION}
#csi-attacher:${CSI_ATTACHER_VERSION}
#csi-resizer:${CSI_RESIZER_VERSION}
#)

#for csiimageName in ${csiimages[@]} ; do
#echo ${csiimageName}
#ctr -n k8s.io images pull ${UCLOUD_URL}/${csiimageName}
#ctr -n k8s.io images tag ${UCLOUD_URL}/${csiimageName} longhornio/${csiimageName}
#ctr -n k8s.io images rm ${UCLOUD_URL}/${csiimageName}
#ctr -n k8s.io images export k8simages/${csiimageName}\.tar longhornio/${csiimageName}
#done
#
#otherimages=(defaultbackend-amd64:${DEFAULTBACKENDVERSION})

#for otherimagesName in ${otherimages[@]} ; do
#echo ${otherimagesName}
#ctr -n k8s.io images pull ${UCLOUD_URL}/${otherimagesName}
#ctr -n k8s.io images tag ${UCLOUD_URL}/${otherimagesName} ${K8S_URL}/${otherimagesName}
#ctr -n k8s.io images rm ${UCLOUD_URL}/${otherimagesName}
#ctr -n k8s.io images export k8simages/${otherimagesName}\.tar ${K8S_URL}/${otherimagesName}
#done
#
allimages=(kube-proxy:${KUBE_VERSION}
kube-scheduler:${KUBE_VERSION}
kube-controller-manager:${KUBE_VERSION}
kube-apiserver:${KUBE_VERSION}
pause:${KUBE_PAUSE_VERSION}
etcd:${ETCD_VERSION}
coredns:${CORE_DNS_VERSION}
metrics-server:${METRICS_SERVER_VERSION}
cni:${CALICO_VERSION}
node:${CALICO_VERSION}
kube-controllers:${CALICO_VERSION}
controller:${INGRESS_VERSION}
kube-webhook-certgen:${INGRESS_WEBHOOK_VERSION}
longhorn-manager:${LONGHORN1_VERSION}
longhorn-ui:${LONGHORN1_VERSION}
longhorn-engine:${LONGHORN1_VERSION}
longhorn-instance-manager:${LONGHORN2_VERSION}
backing-image-manager:${LONGHORN3_VERSION}
longhorn-share-manager:${LONGHORN4_VERSION}
#csi-provisioner:${CSI_PROVISIONER_VERSION}
#csi-node-driver-registrar:${CSI_NODE_DRIVER_VERSION}
#csi-attacher:${CSI_ATTACHER_VERSION}
#csi-resizer:${CSI_RESIZER_VERSION}
#defaultbackend-amd64:${DEFAULTBACKENDVERSION}
)

for all_name in ${ALL_NAMES[@]}
  do  
    echo "&gt;&gt;&gt; ${all_name}"
    ssh root@${all_name} "mkdir /root/k8simages"
    scp -rp k8simages/* root@${all_name}:/root/k8simages/
  done

for allimageName in ${allimages[@]}
  do
  for all_name in ${ALL_NAMES[@]}
    do
    echo "${allimageName} copy to ${all_name}"
    ssh root@${all_name} "ctr -n k8s.io images import k8simages/${allimageName}\.tar"
    done
  done

[root@master01 ~]# bash kubeadm/k8simage.sh                     #确认版本，提前下载镜像
</code></pre>
<p><font color="red">提示：如上仅需Master01节点操作，从而实现所有节点镜像的分发。<br>
注意相关版本，如上脚本为v1.21.0 Kubernetes版本所需镜像。 </font></p>
<pre><code>[root@master01 ~]# ctr -n k8s.io images ls        	#确认验证
[root@master01 ~]# crictl images ls
</code></pre>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/001.png" alt="001" loading="lazy"></p>
<h3 id="master01上初始化">Master01上初始化</h3>
<p>Master-1节点上执行初始化，即完成单节点的Kubernetes，其他节点采用添加的方式部署。</p>
<pre><code>[root@master01 ~]# kubeadm init --config=kubeadm/kubeadm-config.yaml --upload-certs                 #保留如下命令用于后续节点添加：
……
Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

Alternatively, if you are the root user, you can run:

  export KUBECONFIG=/etc/kubernetes/admin.conf

You should now deploy a pod network to the cluster.
Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

You can now join any number of the control-plane node running the following command on each as root:

  kubeadm join 172.24.8.100:16443 --token qkaf0s.ar48yhg1q4ii5mhf \
        --discovery-token-ca-cert-hash sha256:1238bf64661112257ed266fc054e65ec53f7ed64c0c17f39d681f92754860b54 \
        --control-plane --certificate-key 1f5de4e4aa380d6dd074f38a260332f95d36945fead04520072766391b9f6423

Please note that the certificate-key gives access to cluster sensitive data, keep it secret!
As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use
"kubeadm init phase upload-certs --upload-certs" to reload certs afterward.

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 172.24.8.100:16443 --token qkaf0s.ar48yhg1q4ii5mhf \
        --discovery-token-ca-cert-hash sha256:1238bf64661112257ed266fc054e65ec53f7ed64c0c17f39d681f92754860b54
</code></pre>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/003.png" alt="003" loading="lazy"></p>
<p><font color="red">注意：如上token具有默认24小时的有效期，token和hash值可通过如下方式获取：<br>
kubeadm token list<br>
如果 Token 过期以后，可以输入以下命令，生成新的 Token: </font></p>
<pre><code>kubeadm token create
openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'
</code></pre>
<p>创建相关Kubernetes集群配置文件保存目录。</p>
<pre><code>[root@master01 ~]# mkdir -p $HOME/.kube
[root@master01 ~]# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
[root@master01 ~]# sudo chown $(id -u):$(id -g) $HOME/.kube/config

[root@master01 ~]# cat &lt;&lt; EOF &gt;&gt; ~/.bashrc
export KUBECONFIG=$HOME/.kube/config
EOF							#设置KUBECONFIG环境变量

[root@master01 ~]# echo "source &lt;(kubectl completion bash)" &gt;&gt; ~/.bashrc
[root@master01 ~]# source ~/.bashrc
</code></pre>
<p>附加：初始化过程大致步骤如下：</p>
<ul>
<li>[certs]：生成相关的各种证书</li>
<li>[control-plane]：创建Kubernetes控制节点的静态Pod</li>
<li>[etcd]：创建ETCD的静态Pod</li>
<li>[kubelet-start]：生成kubelet的配置文件”/var/lib/kubelet/config.yaml”</li>
<li>[kubeconfig]：生成相关的kubeconfig文件</li>
<li>[bootstraptoken]：生成token记录下来，后续使用kubeadm join往集群中添加节点时会用到</li>
<li>[addons]：附带的相关插件</li>
</ul>
<p><font color="red">提示：初始化仅需要在master01上执行，若初始化异常可通过<code>kubeadm reset -f kubeadm/kubeadm-config.yaml &amp;&amp; rm -rf $HOME/.kube /etc/cni/ /etc/kubernetes/</code>重置。 </font></p>
<h3 id="添加master节点">添加Master节点</h3>
<p>采用 kubeadm join 将其他Master节点添加至集群。</p>
<pre><code>[root@master02 ~]# kubeadm join 172.24.8.100:16443 --token qkaf0s.ar48yhg1q4ii5mhf \
 --discovery-token-ca-cert-hash sha256:1238bf64661112257ed266fc054e65ec53f7ed64c0c17f39d681f92754860b54 \
 --control-plane --certificate-key 1f5de4e4aa380d6dd074f38a260332f95d36945fead04520072766391b9f6423

[root@master02 ~]# mkdir -p $HOME/.kube
[root@master02 ~]# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
[root@master02 ~]# sudo chown $(id -u):$(id -g) $HOME/.kube/config
[root@master02 ~]# cat &lt;&lt; EOF &gt;&gt; ~/.bashrc
export KUBECONFIG=$HOME/.kube/config
EOF						               	            #设置KUBECONFIG环境变量
[root@master02 ~]# echo "source &lt;(kubectl completion bash)" &gt;&gt; ~/.bashrc
[root@master02 ~]# source ~/.bashrc
</code></pre>
<p><font color="red">提示：master03也如上操作，添加至当前集群的controlplane。<br>
若添加异常可通过<code>kubeadm reset -f kubeadm/kubeadm-config.yaml &amp;&amp; rm -rf $HOME/.kube /etc/cni/ /etc/kubernetes/</code>重置。 </font></p>
<h2 id="安装nic插件">安装NIC插件</h2>
<h3 id="nic插件介绍">NIC插件介绍</h3>
<ul>
<li>Calico 是一个安全的 L3 网络和网络策略提供者。</li>
<li>Canal 结合 Flannel 和 Calico， 提供网络和网络策略。</li>
<li>Cilium 是一个 L3 网络和网络策略插件， 能够透明的实施 HTTP/API/L7 策略。 同时支持路由（routing）和叠加/封装（ overlay/encapsulation）模式。</li>
<li>Contiv 为多种用例提供可配置网络（使用 BGP 的原生 L3，使用 vxlan 的 overlay，经典 L2 和 Cisco-SDN/ACI）和丰富的策略框架。Contiv 项目完全开源。安装工具同时提供基于和不基于 kubeadm 的安装选项。</li>
<li>Flannel 是一个可以用于 Kubernetes 的 overlay 网络提供者。<br>
+Romana 是一个 pod 网络的层 3 解决方案，并且支持 NetworkPolicy API。Kubeadm add-on 安装细节可以在这里找到。</li>
<li>Weave Net 提供了在网络分组两端参与工作的网络和网络策略，并且不需要额外的数据库。</li>
<li>CNI-Genie 使 Kubernetes 无缝连接到一种 CNI 插件，例如：Flannel、Calico、Canal、Romana 或者 Weave。</li>
</ul>
<p><font color="red">提示：本方案使用Calico插件。 </font></p>
<h3 id="部署calico">部署calico</h3>
<p>确认相关配置，如MTU，网卡接口，Pod的IP地址段。<br>
calico原文件可参考官方：<code>https://docs.projectcalico.org/manifests/calico.yaml</code></p>
<pre><code>
[root@master01 ~]# vim kubeadm/calico/calico.yaml	    #检查配置
……
data:
……
  veth_mtu: "1400"
……
            - name: CALICO_IPV4POOL_CIDR
              value: "10.10.0.0/16"			            #配置Pod网段
……
            - name: IP_AUTODETECTION_METHOD
              value: "interface=eth.*"			        #检查节点之间的网卡
# Auto-detect the BGP IP address.
            - name: IP
              value: "autodetect"
……

[root@master01 ~]# kubectl apply -f kubeadm/calico/calico.yaml
[root@master01 ~]# kubectl get pods --all-namespaces -o wide		#查看部署
[root@master01 ~]# kubectl get nodes
</code></pre>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/004.png" alt="004" loading="lazy"> <font color="red">提示：官方calico参考：<a href="https://docs.projectcalico.org/manifests/calico.yaml%E3%80%82" target="_blank" rel="noopener nofollow">https://docs.projectcalico.org/manifests/calico.yaml。</a> </font></p>
<h3 id="修改node端口范围">修改node端口范围</h3>
<p>Kubernetes默认的端口范围为30000-32767，为便于后期大量的应用，如ingress的80、443端口，可开放全端口。<br>
同时开放全端口范围后，需要注意避开公共端口，如8080。</p>
<pre><code>[root@master01 ~]# vi /etc/kubernetes/manifests/kube-apiserver.yaml                     #追加端口开放配置
……
    - --service-node-port-range=1-65535
……
</code></pre>
<p><font color="red">提示：如上需要在所有Master节点操作。 </font></p>
<h2 id="添加worker节点">添加Worker节点</h2>
<h3 id="添加worker节点-1">添加Worker节点</h3>
<pre><code>[root@master01 ~]# source environment.sh

[root@master01 ~]# for node_ip in ${NODE_IPS[@]}
  do
    echo "&gt;&gt;&gt; ${node_ip}"
    ssh root@${node_ip} "kubeadm join 172.24.8.100:16443 --token qkaf0s.ar48yhg1q4ii5mhf \
      --discovery-token-ca-cert-hash sha256:1238bf64661112257ed266fc054e65ec53f7ed64c0c17f39d681f92754860b54"
    ssh root@${node_ip} "systemctl enable kubelet.service"
  done
</code></pre>
<p><font color="red">提示：如上仅需Master01节点操作，从而实现所有Worker节点添加至集群，若添加异常可通过如下方式重置： </font></p>
<pre><code>[root@worker01 ~]# kubeadm reset
[root@worker01 ~]# ifconfig cni0 down
[root@worker01 ~]# ip link delete cni0
[root@worker01 ~]# ifconfig flannel.1 down
[root@worker01 ~]# ip link delete flannel.1
[root@worker01 ~]# rm -rf /var/lib/cni/
</code></pre>
<h3 id="确认验证">确认验证</h3>
<pre><code>[root@master01 ~]# kubectl get nodes			         	#节点状态
[root@master01 ~]# kubectl get cs			             	#组件状态
[root@master01 ~]# kubectl get serviceaccount		     	#服务账户
[root@master01 ~]# kubectl cluster-info			         	#集群信息
[root@master01 ~]# kubectl get pod -n kube-system -o wide	#所有服务状态
</code></pre>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/005.png" alt="005" loading="lazy"></p>
<p><font color="red">提示：更多Kubetcl使用参考：<a href="https://kubernetes.io/docs/reference/kubectl/kubectl/" target="_blank" rel="noopener nofollow">https://kubernetes.io/docs/reference/kubectl/kubectl/</a><br>
<a href="https://kubernetes.io/docs/reference/kubectl/overview/" target="_blank" rel="noopener nofollow">https://kubernetes.io/docs/reference/kubectl/overview/</a><br>
更多kubeadm使用参考：<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" target="_blank" rel="noopener nofollow">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</a> </font></p>
<h2 id="metrics部署">Metrics部署</h2>
<h3 id="metrics介绍">Metrics介绍</h3>
<p>Kubernetes的早期版本依靠Heapster来实现完整的性能数据采集和监控功能，Kubernetes从1.8版本开始，性能数据开始以Metrics API的方式提供标准化接口，并且从1.10版本开始将Heapster替换为Metrics Server。在Kubernetes新的监控体系中，Metrics Server用于提供核心指标（Core Metrics），包括Node、Pod的CPU和内存使用指标。</p>
<p>Metrics Server从Kubelets收集资源指标，并通过Metrics API将其暴露在Kubernetes apiserver中，以供Horizontal Pod Autoscaler和Vertical Pod Autoscaler使用。还可以通过kubectl top方式访问Metrics API。</p>
<p>对其他自定义指标（Custom Metrics）的监控则由Prometheus等组件来完成。</p>
<h3 id="metrics特点">Metrics特点</h3>
<p>Metrics Server主要特点:</p>
<ul>
<li>在大多数集群上可以以单Pod工作；</li>
<li>快速自动伸缩，且每15秒收集一次指标；</li>
<li>资源消耗极低，在集群中每个节点上仅需1分片CPU和2 MB内存；</li>
<li>可扩展支持最多5000个节点集群。</li>
</ul>
<h3 id="metrics需求">Metrics需求</h3>
<p>Metrics Server对集群和网络配置有特定的需求依赖，这些需求依赖并不是所有集群默认开启的。<br>
在使用Metrics Server之前，需要确保集群支持这些需求：</p>
<ul>
<li>kube-apiserver必须启用聚合层（aggregation layer）；</li>
<li>节点必须启用Webhook身份验证和授权；</li>
<li>Kubelet证书需要由集群证书颁发机构签名(或者通过向Metrics Server传递--kubelet-insecure-tls禁用证书验证)；</li>
<li>容器运行时必须实现容器度量rpc(或有cAdvisor支持)；</li>
<li>网络应支持以下通信:
<ul>
<li>控制平面到Metrics Server通信要求：控制平面节点需要到达Metrics Server的pod IP和端口10250(如果hostNetwork开启，则可以是自定义的node IP和对应的自定义端口，保持通信即可）；</li>
<li>Metrics Server到所有节点的Kubelete通信要求：Metrics Server需要到达node节点地址和Kubelet端口。地址和端口在Kubelet中配置，并作为Node对象的一部分发布。.status.address和.status.daemonEndpoints.kubeletEndpoint.port定义地址和端口（默认10250）。Metrics Server将根据kubelet-preferred-address-types命令行标志提供的列表选择第一个节点地址（默认InternalIP，ExternalIP，Hostname）。</li>
</ul>
</li>
</ul>
<h3 id="开启聚合层">开启聚合层</h3>
<p>有关聚合层知识参考：<a href="https://blog.csdn.net/liukuan73/article/details/81352637" target="_blank" rel="noopener nofollow">https://blog.csdn.net/liukuan73/article/details/81352637</a><br>
kubeadm方式部署默认已开启。</p>
<h3 id="获取部署文件">获取部署文件</h3>
<p>根据实际生产环境，对Metrics Server的部署进行个性化修改，其他保持默认即可。<br>
主要涉及：部署副本数为3，追加--kubelet-insecure-tls配置。</p>
<pre><code>[root@master01 ~]# mkdir metrics
[root@master01 ~]# cd metrics/
[root@master01 metrics]# wget https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml



[root@master01 metrics]# vi components.yaml
……
apiVersion: apps/v1
kind: Deployment
……
spec:
  replicas: 3						                                                                    	#根据集群规模调整副本数
    ……
    spec:
      hostNetwork: true
      containers:
      - args:
        - --cert-dir=/tmp
        - --secure-port=4443
        - --kubelet-insecure-tls				                                                            #追加此args
        - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname,InternalDNS,ExternalDNS          #追加此args
        - --kubelet-use-node-status-port
        - --metric-resolution=15s
        image: k8s.gcr.io/metrics-server/metrics-server:v0.6.1
        imagePullPolicy: IfNotPresent
    ……
</code></pre>
<h3 id="正式部署">正式部署</h3>
<pre><code>[root@master01 metrics]# kubectl apply -f components.yaml
[root@master01 metrics]# kubectl -n kube-system get pods -l k8s-app=metrics-server -o wide
NAME                             READY   STATUS    RESTARTS   AGE   IP             NODE       NOMINATED NODE   READINESS GATES
metrics-server-dfd7fbbfb-gh4bg   1/1     Running   0          29s   172.24.8.156   worker03   &lt;none&gt;           &lt;none&gt;
metrics-server-dfd7fbbfb-trz7w   1/1     Running   0          29s   172.24.8.155   worker02   &lt;none&gt;           &lt;none&gt;
metrics-server-dfd7fbbfb-xm5mm   1/1     Running   0          29s   172.24.8.154   worker01   &lt;none&gt;           &lt;none&gt;
</code></pre>
<h3 id="查看资源监控">查看资源监控</h3>
<p>可使用kubectl top查看相关监控项。</p>
<pre><code>[root@master01 ~]# kubectl top nodes
[root@master01 ~]# kubectl top pods --all-namespaces
</code></pre>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/006.png" alt="006" loading="lazy"></p>
<p><font color="red">提示：Metrics Server提供的数据也可以供HPA控制器使用，以实现基于CPU使用率或内存使用值的Pod自动扩缩容功能。<br>
部署参考：<a href="https://linux48.com/container/2019-11-13-metrics-server.html" target="_blank" rel="noopener nofollow">https://linux48.com/container/2019-11-13-metrics-server.html</a><br>
有关metrics更多部署参考：<br>
<a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-metrics-pipeline/" target="_blank" rel="noopener nofollow">https://kubernetes.io/docs/tasks/debug-application-cluster/resource-metrics-pipeline/</a><br>
开启开启API Aggregation参考：<br>
<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/" target="_blank" rel="noopener nofollow">https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/</a><br>
API Aggregation介绍参考：<br>
<a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/configure-aggregation-layer/" target="_blank" rel="noopener nofollow">https://kubernetes.io/docs/tasks/access-kubernetes-api/configure-aggregation-layer/</a> </font></p>
<h2 id="nginx-ingress部署">Nginx ingress部署</h2>
<p>Kubernetes中的应用通常以Service对外暴露，而Service的表现形式为IP:Port，即工作在TCP/IP层。<br>
对于基于HTTP的服务来说，不同的URL地址经常对应到不同的后端服务（RS）或者虚拟服务器（Virtual Host），这些应用层的转发机制仅通过Kubernetes的Service机制是无法实现的。</p>
<p>从Kubernetes 1.1版本开始新增Ingress资源对象，用于将不同URL的访问请求转发到后端不同的Service，以实现HTTP层的业务路由机制。<br>
Kubernetes使用了一个Ingress策略规则和一个具体的Ingress Controller，两者结合实现了一个完整的Ingress负载均衡器。<br>
使用Ingress进行负载分发时，Ingress Controller基于Ingress策略规则将客户端请求直接转发到Service对应的后端Endpoint（Pod）上，从而跳过kube-proxy的转发功能，kube-proxy不再起作用。</p>
<p>简单的理解就是：ingress使用DaemonSet或Deployment在相应Node上监听80或443，然后配合相应规则，因为Nginx外面绑定了宿主机80端口（就像 NodePort），本身又在集群内，那么向后直接转发到相应ServiceIP即可实现相应需求。<br>
ingress controller + ingress 策略规则 ----&gt; services。</p>
<p>同时当Ingress Controller提供的是对外服务，则实际上实现的是边缘路由器的功能。</p>
<p>典型的HTTP层路由的架构：</p>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f034/017.png" alt="017" loading="lazy"></p>
<h3 id="设置标签">设置标签</h3>
<p>建议对于非业务相关的应用，构建集群所需的应用（如Ingress），部署在master节点，从而复用master节点的高可用。<br>
采用标签，结合部署的yaml中的tolerations，实现ingress部署在master节点的配置。</p>
<pre><code>[root@master01 ~]# kubectl label nodes master0{1,2,3} ingress=enable
</code></pre>
<h3 id="获取资源">获取资源</h3>
<p>获取部署所需的yaml资源。</p>
<pre><code>[root@master01 ~]# mkdir ingress
[root@master01 ~]# cd ingress/
[root@master01 ingress]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.5.1/deploy/static/provider/baremetal/deploy.yaml
</code></pre>
<p><font color="red">提示：ingress官方参考：<a href="https://github.com/kubernetes/ingress-nginx" target="_blank" rel="noopener nofollow">https://github.com/kubernetes/ingress-nginx</a><br>
<a href="https://kubernetes.github.io/ingress-nginx/deploy/" target="_blank" rel="noopener nofollow">https://kubernetes.github.io/ingress-nginx/deploy/</a> </font></p>
<h3 id="修改配置">修改配置</h3>
<p>为方便后续管理和排障，对相关Nginx ingress挂载时区，以便使Pod时间正确，从而相关记录日志能具有时效性。<br>
同时对ingress做了简单配置，如日志格式等。</p>
<pre><code>[root@master01 ingress]# vi deploy.yaml
……
---
apiVersion: v1
data:
  allow-snippet-annotations: "true"
  # 客户端请求头的缓冲区大小                                                    #配置如下日志格式
  client-header-buffer-size: "512k"
  # 设置用于读取大型客户端请求标头的最大值number和size缓冲区
  large-client-header-buffers: "4 512k"
  # 读取客户端请求body的缓冲区大小
  client-body-buffer-size: "128k"
  # 代理缓冲区大小
  proxy-buffer-size: "256k"
  # 代理body大小
  proxy-body-size: "50m"
  # 服务器名称哈希大小
  server-name-hash-bucket-size: "128"
  # map哈希大小
  map-hash-bucket-size: "128"
  # SSL加密套件
  ssl-ciphers: "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-R
SA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA
:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA"
  # ssl 协议
  ssl-protocols: "TLSv1 TLSv1.1 TLSv1.2"
  # 日志格式
  log-format-upstream: '{"time": "$time_iso8601", "remote_addr": "$proxy_protocol_addr", "x-forward-for": "$proxy_add_x_forwarded_for", "request_id": "$req_id","remote_user": "$remote_user", "bytes_sent": $bytes_sent, "request_time": $request_time, "sta
tus":$status, "vhost": "$host", "request_proto": "$server_protocol", "path": "$uri", "request_query": "$args", "request_length": $request_length, "duration": $request_time,"method": "$request_method", "http_referrer": "$http_referer", "http_user_agent":
 "$http_user_agent" }'
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.5.1
  name: ingress-nginx-controller
  namespace: ingress-nginx
……
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.5.1
  name: ingress-nginx-controller
  namespace: ingress-nginx
spec:
  ipFamilies:
  - IPv4
  ipFamilyPolicy: SingleStack
  ports:
  - appProtocol: http
    name: http
    port: 80
    protocol: TCP 
    targetPort: http
    nodePort: 80                                                    #追加此行
  - appProtocol: https
    name: https
    port: 443
    protocol: TCP 
    targetPort: https
    nodePort: 443                                                   #追加此行
  selector:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
  type: NodePort
  externalTrafficPolicy: Local                                      #追加此行
……
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.5.1
  name: ingress-nginx-controller
  namespace: ingress-nginx
spec:
  replicas: 3                                                       #配置副本数
……
    spec:
      containers:
      - args:
        - /nginx-ingress-controller
……
        image: registry.k8s.io/ingress-nginx/controller:v1.5.1      #修改image镜像
……
        volumeMounts:
……
        - mountPath: /etc/localtime                                 #挂载localtime
          name: timeconfig
          readOnly: true
      dnsPolicy: ClusterFirst
      nodeSelector:
        kubernetes.io/os: linux
        ingress: enable
      tolerations:
        - key: node-role.kubernetes.io/control-plane
          effect: NoSchedule
……
      volumes:
      - name: webhook-cert
        secret:
          secretName: ingress-nginx-admission
      - name: timeconfig                                            #将hostpath配置为挂载卷
        hostPath:
          path: /etc/localtime
……
        image: registry.k8s.io/ingress-nginx/kube-webhook-certgen:v20220916-gd32f8c343      #修改image镜像
……
        image: registry.k8s.io/ingress-nginx/kube-webhook-certgen:v20220916-gd32f8c343      #修改image镜像
……

[root@master01 ingress]# kubectl apply -f deploy.yaml
</code></pre>
<p><font color="red">提示：添加默认backend需要等待default-backend创建完成controllers才能成功部署，新版本ingress不再推荐添加default backend。 </font></p>
<h3 id="确认验证-1">确认验证</h3>
<p>查看Pod部署进度，是否成功完成。</p>
<pre><code>[root@master01 ingress]# kubectl get pods -n ingress-nginx -o wide
[root@master01 ingress]# kubectl get svc -n ingress-nginx -o wide
</code></pre>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/007.png" alt="007" loading="lazy"></p>
<p><font color="red">提示：参考文档：<a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md%E3%80%82" target="_blank" rel="noopener nofollow">https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md。</a> </font></p>
<h2 id="dashboard部署">Dashboard部署</h2>
<p>dashboard是基于Web的Kubernetes用户界面，即WebUI。<br>
可以使用dashboard将容器化应用程序部署到Kubernetes集群，对容器化应用程序进行故障排除，以及管理集群资源。<br>
可以使用dashboard来查看群集上运行的应用程序，以及创建或修改单个Kubernetes资源（例如部署、任务、守护进程等）。<br>
可以使用部署向导扩展部署，启动滚动更新，重新启动Pod或部署新应用程序。<br>
dashboard还提供有关群集中Kubernetes资源状态以及可能发生的任何错误的信息。<br>
通常生产环境中建议部署dashboard，以便于图形化来完成基础运维。</p>
<h3 id="设置标签-1">设置标签</h3>
<p>基于最佳实践，非业务应用，或集群自身的应用都部署在Master节点。</p>
<pre><code>[root@master01 ~]# kubectl label nodes master0{1,2,3} dashboard=enable
</code></pre>
<p><font color="red">提示：建议对于Kubernetes自身相关的应用（如dashboard），此类非业务应用部署在master节点。 </font></p>
<h3 id="创建证书">创建证书</h3>
<p>默认dashboard会自动创建证书，同时使用对应证书创建secret。生产环境可以启用相应的域名进行部署dashboard，因此需要将对于的域名制作为TLS证书。<br>
本实验已获取免费一年的证书，免费证书获取可参考：<a href="https://freessl.cn." target="_blank" rel="noopener nofollow">https://freessl.cn.</a><br>
将已获取的证书上传至对应目录。</p>
<pre><code>[root@master01 ~]# mkdir -p /root/dashboard/certs
[root@master01 ~]# cd /root/dashboard/certs
[root@master01 certs]# mv webui.linuxsb.com.crt tls.crt
[root@master01 certs]# mv webui.linuxsb.com.key tls.key

[root@master01 certs]# ll
total 12K
-rw-r--r-- 1 root root 4.1K Nov 14 23:49 tls.crt
-rw-r--r-- 1 root root 1.7K Nov 14 23:49 tls.key
</code></pre>
<p><font color="red">提示：也可手动如下操作创建自签证书： </font></p>
<p><code> [root@master01 ~]# openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/C=CN/ST=ZheJiang/L=HangZhou/O=Xianghy/OU=Xianghy/CN=webui.linuxsb.com"</code></p>
<h3 id="手动创建secret">手动创建secret</h3>
<p>自定义证书的场景，建议提前使用对应的证书创建secret。</p>
<pre><code>[root@master01 ~]# kubectl create ns kubernetes-dashboard	                                        #v2版本dashboard独立ns
[root@master01 ~]# kubectl create secret generic kubernetes-dashboard-certs --from-file=/root/dashboard/certs/ -n kubernetes-dashboard
[root@master01 ~]# kubectl get secret kubernetes-dashboard-certs -n kubernetes-dashboard -o yaml	#查看新证书
</code></pre>
<h3 id="下载yaml">下载yaml</h3>
<p>从官方下载最新的dashboard部署所需yaml。</p>
<pre><code>[root@master01 ~]# cd /root/dashboard
[root@master01 dashboard]# wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml
</code></pre>
<p><font color="red">提示：官方参考：&lt;<a href="https://github.com/kubernetes/dashboard" target="_blank" rel="noopener nofollow">https://github.com/kubernetes/dashboard</a> 。&gt; </font></p>
<h3 id="修改yaml">修改yaml</h3>
<p>根据实际生产环境修改yaml，以便于使用已创建的证书TLS secret。</p>
<pre><code>[root@master01 dashboard]# vi recommended.yaml
……
kind: Service
apiVersion: v1
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: kubernetes-dashboard
  namespace: kubernetes-dashboard
spec:
  type: NodePort			                	            #新增
  ports:
    - port: 443
      targetPort: 8443
      nodePort: 30001			            	            #新增
  selector:
    k8s-app: kubernetes-dashboard
……
#apiVersion: v1		                                        #如下全部注释
#kind: Secret
#metadata:
#  labels:
#    k8s-app: kubernetes-dashboard
#  name: kubernetes-dashboard-certs
#  namespace: kubernetes-dashboard
#type: Opaque
……
kind: Deployment
apiVersion: apps/v1
metadata:
  labels:
    k8s-app: kubernetes-dashboard
  name: kubernetes-dashboard
  namespace: kubernetes-dashboard
spec:
  replicas: 3					                            #根据实际环境调整为3副本
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      k8s-app: kubernetes-dashboard
  template:
    metadata:
      labels:
        k8s-app: kubernetes-dashboard
    spec:
      securityContext:
        seccompProfile:
          type: RuntimeDefault
      containers:
        - name: kubernetes-dashboard
          image: kubernetesui/dashboard:v2.7.0
          imagePullPolicy: IfNotPresent                     #修改镜像下载策略
          ports:
            - containerPort: 8443
              protocol: TCP
          args:
            - --auto-generate-certificates
            - --namespace=kubernetes-dashboard	       	    #追加如下args参数以便使用已有证书
            - --tls-key-file=tls.key
            - --tls-cert-file=tls.crt
            - --token-ttl=3600
……
      nodeSelector:
#        "kubernetes.io/os": linux
        "dashboard": enable	        		                #部署在带有dashboard tag的节点，即master节点
……
kind: Service
apiVersion: v1
metadata:
  labels:
    k8s-app: dashboard-metrics-scraper
  name: dashboard-metrics-scraper
  namespace: kubernetes-dashboard
spec:
  type: NodePort	             			                #新增
  ports:
    - port: 8000
      targetPort: 8000
      nodePort: 30000		         		                #新增
  selector:
    k8s-app: dashboard-metrics-scraper

---

kind: Deployment
apiVersion: apps/v1
metadata:
  labels:
    k8s-app: dashboard-metrics-scraper
  name: dashboard-metrics-scraper
  namespace: kubernetes-dashboard
spec:
  replicas: 3                                               #根据实际环境调整为3副本
……
      nodeSelector:
#        "kubernetes.io/os": linux
        "dashboard": enable	        		                #部署在带有dashboard tag的节点，即master节点
……
</code></pre>
<h3 id="正式部署-1">正式部署</h3>
<p>根据生产环境最佳实践进行调优，调优完成后开始部署。</p>
<pre><code>[root@master01 dashboard]# kubectl apply -f recommended.yaml
[root@master01 dashboard]# kubectl get deployment kubernetes-dashboard -n kubernetes-dashboard
[root@master01 dashboard]# kubectl get services -n kubernetes-dashboard
[root@master01 dashboard]# kubectl get pods -o wide -n kubernetes-dashboard
</code></pre>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/008.png" alt="008" loading="lazy"></p>
<p><font color="red">提示：master NodePort 30001/TCP映射到 dashboard pod 443 端口。 </font></p>
<h3 id="创建管理员账户">创建管理员账户</h3>
<p>建议创建管理员账户，dashboard v2版本默认没有创建具有管理员权限的账户，同时登录可以选择kubeconfig以及token，通常使用kubeconfig比较方便。<br>
在创建管理员用户后，将用户相关信息配置成kubeconfig文件，即可实现快速登录dashboard。</p>
<pre><code>[root@master01 dashboard]# cat &lt;&lt;EOF &gt; dashboard-admin.yaml
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin
  namespace: kubernetes-dashboard

---
apiVersion: v1
kind: Secret
type: kubernetes.io/service-account-token
metadata:
  name: admin
  namespace: kubernetes-dashboard
  annotations:
    kubernetes.io/service-account.name: "admin"

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin
  namespace: kubernetes-dashboard
EOF

[root@master01 dashboard]# kubectl apply -f dashboard-admin.yaml
</code></pre>
<h3 id="创建kubeconfig文件">创建kubeconfig文件</h3>
<p>使用token相对复杂，可将token添加至kubeconfig文件中，使用KubeConfig文件访问dashboard。</p>
<pre><code>[root@master01 dashboard]# ADMIN_SECRET=$(kubectl -n kubernetes-dashboard get secret | grep admin | awk '{print $1}') 
[root@master01 dashboard]# DASHBOARD_LOGIN_TOKEN=$(kubectl describe secret -n kubernetes-dashboard ${ADMIN_SECRET} | grep -E '^token' | awk '{print $2}') 
[root@master01 dashboard]# kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/pki/ca.crt \
  --embed-certs=true \
  --server=172.24.8.100:16443 \
  --kubeconfig=local-ngkeconk8s-1-25-admin.kubeconfig		# 设置集群参数
 [root@master01 dashboard]# kubectl config set-credentials dashboard_user \
  --token=${DASHBOARD_LOGIN_TOKEN} \
  --kubeconfig=local-ngkeconk8s-1-25-admin.kubeconfig       # 设置客户端认证参数，使用上面创建的 Token
[root@master01 dashboard]# kubectl config set-context default \
  --cluster=kubernetes \
  --user=dashboard_user \
  --kubeconfig=local-ngkeconk8s-1-25-admin.kubeconfig	    # 设置上下文参数
[root@master01 dashboard]# kubectl config use-context default --kubeconfig=local-ngkeconk8s-1-25-admin.kubeconfig         # 设置默认上下文
</code></pre>
<p>将webui.linuxsb.com.crt证书文件导入，以便于浏览器使用该文件登录。</p>
<h3 id="导入证书">导入证书</h3>
<p>将webui.linuxsb.com.crt证书导入浏览器，并设置为信任，可规避证书不受信任的弹出。</p>
<h2 id="ingress暴露dashboard">ingress暴露dashboard</h2>
<h3 id="创建ingress-tls">创建ingress tls</h3>
<p>使用ingress创建dashboard服务，可实现通过URL域名访问dashboard的七层服务方式。</p>
<pre><code>[root@master01 dashboard]# kubectl -n kubernetes-dashboard create secret tls kubernetes-dashboard-tls --cert=/root/dashboard/certs/tls.crt --key=/root/dashboard/certs/tls.key
[root@master01 dashboard]# kubectl -n kubernetes-dashboard describe secrets kubernetes-dashboard-tls
</code></pre>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/009.png" alt="009" loading="lazy"></p>
<h3 id="创建ingress策略">创建ingress策略</h3>
<p>创建ingress策略，实现前端URL，后端SVC的方式对外提供访问服务。</p>
<pre><code>[root@master01 dashboard]# cat &lt;&lt;EOF &gt; dashboard-ingress.yaml
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: kubernetes-dashboard-ingress
  namespace: kubernetes-dashboard
  annotations:
    kubernetes.io/ingress.class: "nginx"
    nginx.ingress.kubernetes.io/use-regex: "true"
    nginx.ingress.kubernetes.io/ssl-passthrough: "true"
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    #nginx.ingress.kubernetes.io/secure-backends: "true"
    nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "600"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
    nginx.ingress.kubernetes.io/configuration-snippet: |
      proxy_ssl_session_reuse off;
spec:
  rules:
  - host: webui.linuxsb.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: kubernetes-dashboard
            port:
              number: 443
  tls:
  - hosts:
    - webui.linuxsb.com
    secretName: kubernetes-dashboard-tls
EOF

[root@master01 dashboard]# kubectl apply -f dashboard-ingress.yaml
[root@master01 dashboard]# kubectl -n kubernetes-dashboard get ingress
</code></pre>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/010.png" alt="010" loading="lazy"></p>
<h3 id="测试访问dashboard">测试访问dashboard</h3>
<p>本实验采用ingress所暴露的域名：<a href="https://webui.linuxsb.com" target="_blank" rel="noopener nofollow">https://webui.linuxsb.com</a><br>
方式一：token访问<br>
可使用<code>kubectl describe secret -n kubernetes-dashboard ${ADMIN_SECRET} | grep -E '^token' | awk '{print $2}'</code>所获取的token访问。</p>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/011.png" alt="011" loading="lazy"></p>
<p>方式二：kubeconfig访问<br>
local-ngkeconk8s-1-25-admin.kubeconfig文件访问。</p>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/012.png" alt="012" loading="lazy"></p>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/013.png" alt="013" loading="lazy"></p>
<p><font color="red">提示：更多dashboard访问方式及认证可参考<a href="https://www.cnblogs.com/itzgr/p/11082342.html" target="_blank">附004.Kubernetes Dashboard简介及使用</a>。<br>
dashboard登录整个流程可参考：<a href="https://www.cnadn.net/post/2613.html" target="_blank" rel="noopener nofollow">https://www.cnadn.net/post/2613.html</a> </font></p>
<h2 id="longhorn存储部署">Longhorn存储部署</h2>
<h3 id="longhorn概述">Longhorn概述</h3>
<p>Longhorn是用于Kubernetes的开源分布式块存储系统。<br>
当前Kubernetes 1.25版本建议使用Longhorn 1.4.0 。</p>
<p><font color="red">提示：更多介绍参考：<a href="https://github.com/longhorn/longhorn" target="_blank" rel="noopener nofollow">https://github.com/longhorn/longhorn</a> 。</font></p>
<h3 id="基础软件安装">基础软件安装</h3>
<p>后续业务应用可能运行在任意节点位置，挂载操作需要在任何节点可正常执行。<br>
所有节点均需要安装基础以来软件。</p>
<pre><code>[root@master01 ~]# source environment.sh
[root@master01 ~]# for all_ip in ${ALL_IPS[@]}
  do
    echo "&gt;&gt;&gt; ${all_ip}"
    ssh root@${all_ip} "yum -y install iscsi-initiator-utils &amp;"
  done
</code></pre>
<p><font color="red">提示：所有节点都需要安装。 </font></p>
<h3 id="设置标签-2">设置标签</h3>
<p>在Master节点上部署存储组件的图形界面。</p>
<pre><code>[root@master01 ~]# kubectl label nodes master0{1,2,3} longhorn-ui=enabled
</code></pre>
<p><font color="red">提示：ui图形界面可复用master高可用，因此部署在master节点。 </font></p>
<h3 id="准备磁盘">准备磁盘</h3>
<p>Longhorn的分布式存储，建议独立磁盘设备专门作为存储卷，可提前挂载。<br>
longhorn默认使用/var/lib/longhorn/作为设备路径，可提前挂载sdb设备。</p>
<pre><code>[root@master01 ~]# source environment.sh
[root@master01 ~]# for all_ip in ${ALL_IPS[@]}
  do
    echo "&gt;&gt;&gt; ${all_ip}"
    ssh root@${all_ip} "mkfs.xfs -f /dev/sdb &amp;&amp; mkdir -p /var/lib/longhorn/ &amp;&amp; echo '/dev/sdb        /var/lib/longhorn        xfs        defaults        0 0' &gt;&gt; /etc/fstab &amp;&amp; mount -a"
  done
</code></pre>
<h3 id="配置longhorn">配置Longhorn</h3>
<p>根据实际生产环境，对Longhorn进行优化配置。</p>
<pre><code>[root@master01 ~]# mkdir longhorn
[root@master01 ~]# cd longhorn/
[root@master01 longhorn]# wget https://raw.githubusercontent.com/longhorn/longhorn/master/deploy/longhorn.yaml

[root@master01 longhorn]# vi longhorn.yaml
……
---
# Source: longhorn/templates/deployment-ui.yaml
kind: Service
apiVersion: v1
metadata:
  labels:
    app.kubernetes.io/name: longhorn
    app.kubernetes.io/instance: longhorn
    app.kubernetes.io/version: v1.3.2
    app: longhorn-ui
  name: longhorn-frontend
  namespace: longhorn-system
spec:
  type: NodePort			                                #修改为nodeport
  selector:
    app: longhorn-ui
  ports:
  - name: http
    port: 80
    targetPort: http
    nodePort: 30002                                         #配置未使用的端口
……
---
# Source: longhorn/templates/deployment-ui.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/name: longhorn
    app.kubernetes.io/instance: longhorn
    app.kubernetes.io/version: v1.3.2
    app: longhorn-ui
  name: longhorn-ui
  namespace: longhorn-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: longhorn-ui
  template:
    metadata:
      labels:
        app.kubernetes.io/name: longhorn
        app.kubernetes.io/instance: longhorn
        app.kubernetes.io/version: v1.3.2
        app: longhorn-ui
    spec:
      containers:
      - name: longhorn-ui
        image: longhornio/longhorn-ui:v1.3.2
……
      nodeSelector:
        longhorn-ui: enabled                                #追加标签选择
      tolerations:
        - key: node-role.kubernetes.io/control-plane        #添加容忍
          effect: NoSchedule
……
</code></pre>
<h3 id="正式部署-2">正式部署</h3>
<p>基于优化的yaml进行部署。</p>
<pre><code>[root@master01 ~]# cd  longhorn/
[root@master01 longhorn]# kubectl apply -f longhorn.yaml
[root@master01 longhorn]# kubectl -n longhorn-system get pods -o wide
</code></pre>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/014.png" alt="014" loading="lazy"></p>
<p><font color="red">提示：若部署异常可删除重建，若出现无法删除namespace，可通过如下操作进行删除： </font></p>
<pre><code>wget https://github.com/longhorn/longhorn/blob/master/uninstall/uninstall.yaml
rm -rf /var/lib/longhorn/
kubectl apple -f uninstall.yaml
kubectl delete -f uninstall.yaml
</code></pre>
<h3 id="动态sc创建">动态sc创建</h3>
<p>部署Longhorn后，默认已创建一个名为longhorn的sc。</p>
<pre><code>[root@master01 longhorn]# kubectl get sc
NAME                 PROVISIONER          RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
longhorn (default)   driver.longhorn.io   Delete          Immediate           true                   8h
</code></pre>
<p><font color="red">提示：默认longhorn部署完成已创建一个sc，也可通过如下手动编写yaml创建。 </font></p>
<pre><code>[root@master01 longhorn]# cat &lt;&lt;EOF &gt; longhornsc.yaml
kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: longhornsc
provisioner: rancher.io/longhorn
parameters:
  numberOfReplicas: "3"
  staleReplicaTimeout: "30"
  fromBackup: "" 
EOF

[root@master01 longhorn]# kubectl apply -f longhornsc.yaml
</code></pre>
<h3 id="测试pv及pvc">测试PV及PVC</h3>
<p>使用常见的Nginx Pod进行测试，模拟生产环境常见的Web类应用的持久性存储卷。</p>
<pre><code>[root@master01 longhorn]# cat &lt;&lt;EOF &gt; longhornpod.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: longhorn-pvc
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: longhorn
  resources:
    requests:
      storage: 500Mi

---
apiVersion: v1
kind: Pod
metadata:
  name: longhorn-pod
  namespace: default
spec:
  containers:
  - name: volume-test
    image: nginx:stable-alpine
    imagePullPolicy: IfNotPresent
    volumeMounts:
    - name: volv
      mountPath: /data
    ports:
    - containerPort: 80
  volumes:
  - name: volv
    persistentVolumeClaim:
      claimName: longhorn-pvc
EOF

[root@master01 longhorn]# kubectl apply -f longhornpod.yaml
[root@master01 longhorn]# kubectl get pods
[root@master01 longhorn]# kubectl get pvc
[root@master01 longhorn]# kubectl get pv
</code></pre>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/015.png" alt="015" loading="lazy"></p>
<h3 id="ingress暴露longhorn">Ingress暴露Longhorn</h3>
<p>使用已部署完成的ingress将Longhorn UI暴露，以便于使用URL形式访问Longhorn图形界面进行Longhorn的基础管理。</p>
<pre><code>[root@master01 longhorn]# yum -y install httpd-tools
[root@master01 longhorn]# htpasswd -c auth xhy			#创建用户名和密码
    New password: [输入密码]
    Re-type new password:  [输入密码]
</code></pre>
<p><font color="red">提示：也可通过如下命令创建： </font><br>
<code>USER=xhy; PASSWORD=x120952576; echo "${USER}:$(openssl passwd -stdin -apr1 &lt;&lt;&lt; ${PASSWORD})" &gt;&gt; auth</code></p>
<pre><code>[root@master01 longhorn]# kubectl -n longhorn-system create secret generic longhorn-basic-auth --from-file=auth

[root@master01 longhorn]# cat &lt;&lt;EOF &gt; longhorn-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: longhorn-ingress
  namespace: longhorn-system
  annotations:
    kubernetes.io/ingress.class: "nginx"
    nginx.ingress.kubernetes.io/auth-type: basic
    nginx.ingress.kubernetes.io/auth-secret: longhorn-basic-auth
    nginx.ingress.kubernetes.io/auth-realm: 'Authentication Required '
spec:
  rules:
  - host: longhorn.linuxsb.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: longhorn-frontend
            port: 
              number: 80
EOF

[root@master01 longhorn]# kubectl apply -f longhorn-ingress.yaml

[root@master01 longhorn]# kubectl -n longhorn-system get pods longhorn-ui-7b68b96686-pfg8v 
[root@master01 longhorn]# kubectl -n longhorn-system get svc longhorn-frontend 
[root@master01 longhorn]# kubectl -n longhorn-system get ingress longhorn-ingress 

[root@master01 longhorn]# kubectl -n longhorn-system describe svc longhorn-frontend       
[root@master01 longhorn]# kubectl -n longhorn-system describe ingress longhorn-ingress
</code></pre>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/016.png" alt="016" loading="lazy"><br>
<img src="http://tp.linuxsb.com/study/kubernetes/f035/017.png" alt="017" loading="lazy"></p>
<h3 id="确认验证-2">确认验证</h3>
<p>浏览器访问：longhorn.linuxsb.com ，并输入设置的账号和密码。</p>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/018.png" alt="018" loading="lazy"></p>
<p>使用xhy/[密码]登录查看。</p>
<p><img src="http://tp.linuxsb.com/study/kubernetes/f035/019.png" alt="019" loading="lazy"></p>
<h2 id="helm部署">Helm部署</h2>
<h3 id="helm介绍">helm介绍</h3>
<p>Helm 是 Kubernetes 的软件包管理工具。包管理器类似 Ubuntu 中使用的apt、Centos中使用的yum 或者Python中的 pip 一样，能快速查找、下载和安装软件包。通常每个包称为一个Chart，一个Chart是一个目录（一般情况下会将目录进行打包压缩，形成name-version.tgz格式的单一文件，方便传输和存储）。<br>
Helm 由客户端组件 helm 和服务端组件 Tiller 组成, 能够将一组K8S资源打包统一管理, 是查找、共享和使用为Kubernetes构建的软件的最佳方式。</p>
<h3 id="helm优势">Helm优势</h3>
<p>在 Kubernetes中部署一个可以使用的应用，需要涉及到很多的 Kubernetes 资源的共同协作。<br>
如安装一个 WordPress 博客，用到了一些 Kubernetes 的一些资源对象。包括 Deployment 用于部署应用、Service 提供服务发现、Secret 配置 WordPress 的用户名和密码，可能还需要 pv 和 pvc 来提供持久化服务。并且 WordPress 数据是存储在mariadb里面的，所以需要 mariadb 启动就绪后才能启动 WordPress。这些 k8s 资源过于分散，不方便进行管理。</p>
<p>基于如上场景，在 k8s 中部署一个应用，通常面临以下几个问题：<br>
如何统一管理、配置和更新这些分散的 k8s 的应用资源文件；<br>
如何分发和复用一套应用模板；<br>
如何将应用的一系列资源当做一个软件包管理。</p>
<p>对于应用发布者而言，可以通过 Helm 打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。<br>
对于使用者而言，使用 Helm 后不用需要编写复杂的应用部署文件，可以以简单的方式在 Kubernetes 上查找、安装、升级、回滚、卸载应用程序。</p>
<h3 id="前置准备">前置准备</h3>
<p>Helm 将使用 kubectl 在已配置的集群上部署 Kubernetes 资源，因此需要如下前置准备：</p>
<ul>
<li>正在运行的 Kubernetes 集群；</li>
<li>预配置的 kubectl 客户端和 Kubernetes 集群正确交互。</li>
</ul>
<h3 id="二进制安装helm">二进制安装Helm</h3>
<p>建议采用二进制安装helm。</p>
<pre><code>[root@master01 ~]# mkdir helm
[root@master01 ~]# cd helm/
[root@master01 helm]# wget https://get.helm.sh/helm-v3.10.2-linux-amd64.tar.gz
[root@master01 helm]# tar -zxvf helm-v3.10.2-linux-amd64.tar.gz
[root@master01 helm]# cp linux-amd64/helm /usr/local/bin/

[root@master01 helm]# helm version		#查看安装版本
[root@master01 helm]# echo 'source &lt;(helm completion bash)' &gt;&gt; $HOME/.bashrc	#helm自动补全
</code></pre>
<p><font color="red">提示：更多安装方式参考官方手册：<a href="https://helm.sh/docs/intro/install/" target="_blank" rel="noopener nofollow">https://helm.sh/docs/intro/install/</a> 。</font></p>
<h3 id="helm操作">Helm操作</h3>
<h3 id="查找chart">查找chart</h3>
<p>helm search：可以用于搜索两种不同类型的源。<br>
helm search hub：搜索 Helm Hub，该源包含来自许多不同仓库的Helm chart。<br>
helm search repo：搜索已添加到本地头helm客户端（带有helm repo add）的仓库，该搜索是通过本地数据完成的，不需要连接公网。</p>
<pre><code>[root@master01 ~]# helm search hub			                    #可搜索全部可用chart
[root@master01 ~]# helm search hub wordpress
</code></pre>
<h3 id="添加repo">添加repo</h3>
<p>类似CentOS添加yum源，可以给helm仓库添加相关源。</p>
<pre><code>[root@master01 ~]# helm repo list			                    #查看repo
[root@master01 ~]# helm repo add brigade https://brigadecore.github.io/charts
[root@master01 ~]# helm repo add bitnami https://charts.bitnami.com/bitnami

[root@master01 ~]# helm search repo brigade
[root@master01 ~]# helm search repo bitnami		                #搜索repo中的chart
[root@master01 ~]# helm repo update			                    #更新repo的chart
</code></pre>
<h2 id="扩展集群扩容及缩容">扩展：集群扩容及缩容</h2>
<h3 id="集群扩容">集群扩容</h3>
<ul>
<li>master节点扩容<br>
参考：添加Master节点 步骤</li>
<li>worker节点扩容<br>
参考：添加Worker节点 步骤</li>
</ul>
<h3 id="集群缩容">集群缩容</h3>
<ul>
<li>master节点缩容<br>
Master节点缩容的时候会自动将Pod迁移至其他节点。</li>
</ul>
<pre><code>[root@master01 ~]# kubectl drain master03 --delete-emptydir-data --force --ignore-daemonsets
[root@master01 ~]# kubectl delete node master03

[root@master03 ~]# kubeadm reset -f &amp;&amp; rm -rf $HOME/.kube
</code></pre>
<ul>
<li>worker节点缩容<br>
Worker节点缩容的时候会自动将Pod迁移至其他节点。</li>
</ul>
<pre><code>[root@master01 ~]# kubectl drain worker04 --delete-emptydir-data --force --ignore-daemonsets
[root@master01 ~]# kubectl delete node worker04

[root@worker04 ~]# kubeadm reset -f
[root@worker04 ~]# rm -rf /etc/kubernetes/admin.conf /etc/kubernetes/kubelet.conf /etc/kubernetes/bootstrap-kubelet.conf /etc/kubernetes/controller-manager.conf /etc/kubernetes/scheduler.conf
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <div style="background: #f7acbc; color: #0; font-size: small">
<p>
作者：<a href="http://www.linuxsb.com/">木二</a>
</p>
<p>
出处：<a href="http://www.cnblogs.com/itzgr/">http://www.cnblogs.com/itzgr/</a>
</p>
<p>
关于作者：云计算、虚拟化，Linux，多多交流！
</p>
<p>
本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出<a href="#" style="background: #b6ff00; color: #0; font-size: medium">原文链接</a>!如有其他问题，可邮件（xhy@itzgr.com）咨询。
</p>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5628357013784723" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-10 22:49">2025-03-10 22:49</span>&nbsp;
<a href="https://www.cnblogs.com/itzgr">木二</a>&nbsp;
阅读(<span id="post_view_count">68</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18763914" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18763914);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18763914', targetLink: 'https://www.cnblogs.com/itzgr/p/18763914', title: '附035.Kubernetes_v1.25.3高可用部署架构二' })">举报</a>
</div>
        