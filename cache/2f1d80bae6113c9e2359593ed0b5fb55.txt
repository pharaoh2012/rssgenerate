
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/johnnyzen/p/18704323" title="发布于 2025-02-08 15:28">
    <span role="heading" aria-level="2">[车联网/计算机网络] Autosar 的 `ARXML` 配置数据库文件协议</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="序-缘起-arxml">序: 缘起 ARXML</h1>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208152946398-1326591891.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208153007559-1754431758.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208153147511-619672214.png" alt="" loading="lazy"></p>
<pre><code class="language-xml">//ARXML_AP_V2.9.arxml
&lt;AUTOSAR xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://autosar.org/schema/r4.0" xsi:schemaLocation="http://autosar.org/schema/r4.0 AUTOSAR_00048.xsd"&gt;

//ARXML_CP_V2.9.arxml
&lt;AUTOSAR xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://autosar.org/schema/r4.0" xsi:schemaLocation="http://autosar.org/schema/r4.0 AUTOSAR_4-3-0.xsd"&gt;
</code></pre>
<h1 id="概述--autosar-的-arxml-配置数据库文件协议">概述 ： Autosar 的 <code>ARXML</code> 配置数据库文件协议</h1>
<h2 id="arxml-文件">ARXML 文件</h2>
<ul>
<li><code>ARXML</code>文件： AUTOSAR<strong>系统描述文件</strong>，后缀<code>*.arxml</code></li>
</ul>
<blockquote>
<ul>
<li>实质是一个<code>XML</code>文件，一般通过<code>Autosar</code>标准的<code>XSD</code>进行约束</li>
<li>可用专用工具<code>Artop</code>，Systemdesk，Matlab，DaVinci developer，Autosar Explorer…生成。</li>
<li>和<code>XML</code>、<code>DBC</code>文件一样，<code>ARXML</code>是一个<strong>通用的配置/数据库文件</strong>。</li>
</ul>
<blockquote>
<p>所以，这里只需了解<code>ARXML</code>文件的结构（方便在将<code>ARXML</code>导入工具前，能够检查一些基本的错误），无需想着用过多的时间手动生成它(生成的工作，专业工具已经帮你做解决了)。</p>
</blockquote>
</blockquote>
<h2 id="xml">XML</h2>
<h2 id="xml简介">XML简介</h2>
<ul>
<li><code>XML</code> ： 可扩展标记语言（<code>eXtensible Markup Language</code>），是是一种非常灵活的标记语言，没有固定的标签，所有的标签，在符合XML命名规则的基础上，都可以自定义，但是在写标签名的时候一定要有含义。</li>
</ul>
<blockquote>
<p>通常，<code>XML</code>被用于信息的记录和传递。因此，<code>XML</code>经常被用来充当“配置文件”和“数据库”。</p>
</blockquote>
<ul>
<li>一般可通过“<strong>Eclipse</strong>”和“<strong>网页浏览器</strong>”等软件工具打开<code>XML</code>文件。</li>
</ul>
<blockquote>
<p>将<code>ARXML</code>文件的后缀名修改为<code>XML</code>，可以通过这些工具打开。</p>
</blockquote>
<h2 id="xml-文件数据结构">XML 文件数据结构</h2>
<blockquote>
<p>以下是一个简单Demo</p>
</blockquote>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;books&gt;
&lt;!-- 图书信息 --&gt;
    &lt;book id="book_1"&gt;
        &lt;author&gt;张三&lt;/author&gt;
        &lt;title&gt;XML高级教程&lt;/title&gt;
        &lt;description&gt;介绍XML和XML实战&lt;/description&gt;
    &lt;/book&gt;
&lt;/books&gt;
</code></pre>
<ul>
<li>XML文档是树状结构；</li>
</ul>
<blockquote>
<ul>
<li>第1行：<strong>XML声明</strong>。 必须放在第一行，第一列，声明语句之前，不能有任何的空格和注释。定义了XML版本和编码信息。其中，版本永远都是1.0；编码方式一般都使用UTF-8（该编码支持中文标签），编码信息不区分大小写。</li>
<li>第2行：<strong>根元素</strong> : <code>&lt;books&gt;</code>。XML有且仅有一个根元素。元素由开始标签、元素内容、结束标签组成，没有被其它元素包围的元素称为根元素；</li>
<li>第3行：<strong>注释的写法</strong> ： <code>&lt;!-- 注释内容 --&gt;</code>，但不能嵌套使用。</li>
<li>第4行：<strong>属性</strong> : <code>id="book_1"</code>。属性必有值，值必须使用引号（单引号，双引号）。属性其实是描述标签一些额外的信息，一个标签可以有多个属性。可以将属性看为元素的另一种写法。</li>
<li>第5~7行：表示<strong>元素</strong>。</li>
</ul>
</blockquote>
<ul>
<li>XML中的标签区分大小写，对应的开始标签和结束标签必须大小写一致。</li>
<li>标签命名：普通字符有：字母，数字，-中横线，_下划线，.点号，数字不能作为首字母出现等。大段内容有许多特殊符号内容，使用转义，如下的例子：了看可是lj<sdlkjs>lkdjlsjd ls<jdl>ksj lsjdlks d]]&gt;</jdl></sdlkjs></li>
<li>XML中的标签是成对的，而且要正确嵌套：标签可以嵌套，但不可以交叉嵌套。</li>
<li>实际的项目当中，第4~8行这部分经常是重复的。</li>
<li>特殊符号使用符号实体：</li>
</ul>
<blockquote>
<ul>
<li>单引号：用<code>&amp;apos</code>表示</li>
<li>双引号：用<code>&amp;quot</code>表示</li>
<li>空格：用<code>&amp;nbsp</code>表示</li>
<li><code>&amp;</code>符号：用<code>&amp;amp</code>表示</li>
<li><code>&gt;</code>符号：用<code>&amp;gt</code>表示</li>
<li><code>&lt;</code>符号：用<code>&amp;lt</code>表示</li>
</ul>
</blockquote>
<ul>
<li>如下根元素下，可以存在多个并列的元素：</li>
</ul>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;books&gt;
&lt;!-- 图书信息 --&gt;
    &lt;book id="book_1"&gt;
        &lt;author&gt;张三&lt;/author&gt;
        &lt;title&gt;XML高级教程&lt;/title&gt;
        &lt;description&gt;介绍XML和XML实战&lt;/description&gt;
    &lt;/book&gt;
    &lt;book id="book_2"&gt;
        &lt;author&gt;李四&lt;/author&gt;
        &lt;title&gt;XML中级教程&lt;/title&gt;
        &lt;description&gt;介绍XML和XML实战&lt;/description&gt;
    &lt;/book&gt;
&lt;/books&gt;
</code></pre>
<h2 id="有效的xml">有效的XML</h2>
<ul>
<li><code>XML</code>首先必须是<strong>格式良好</strong>的，一般使用<code>DTD</code>和<code>XSD</code>（<code>XML Schema</code>）定义语义约束。<code>ARXML</code>文件使用<code>XSD</code>进行约束。</li>
</ul>
<h2 id="认识dtd">认识DTD</h2>
<h3 id="dtd简介">DTD简介</h3>
<ul>
<li><code>DTD</code>全称: <code>Document Type Definition</code></li>
</ul>
<blockquote>
<p>用于约束XML的文档格式，保证XML是一个有效的XML。定义好接口和格式，方便多个人同时开发。</p>
</blockquote>
<ul>
<li>
<p><code>DTD</code>可以分为两种：内部<code>DTD</code>；外部<code>DTD</code></p>
</li>
<li>
<p><code>DTD</code>和<code>XML</code>之间的关系：</p>
</li>
</ul>
<blockquote>
<ul>
<li>类（人类）和对象（我）</li>
<li>数据库（表）和行（一条记录）</li>
</ul>
</blockquote>
<ul>
<li><code>DTD</code>的缺点：</li>
</ul>
<blockquote>
<ul>
<li><code>DTD</code>约束<code>XML</code>的时候，不能对<code>XML</code>中数据类型做详细的限定。</li>
<li><code>DTD</code>约束有自己的语法，书写时必须遵守<code>DTD</code>的语法；</li>
<li>一个<code>XML</code>文件中只能引入一个<code>DTD</code>约束，而无法通过多个<code>DTD</code>文件来约束同一个<code>XML</code>文件。</li>
</ul>
</blockquote>
<h3 id="内部的-doctype-声明">内部的 DOCTYPE 声明</h3>
<ul>
<li>内部DTD的定义，语法如下：<br>
a) <br>
b) 元素声明语法：</li>
</ul>
<pre><code class="language-shell">&lt;!ELEMENT 元素名 (子元素[,子元素...])&gt;
</code></pre>
<p>c) 数量词：</p>
<pre><code class="language-txt">+：表示元素出现至少出现一次

？：表示元素出现0次或1次

*：表示元素出现任意次。举例&lt;!ELEMENT books (book*)&gt;
</code></pre>
<p>d) 属性声明语法：</p>
<blockquote>
<ul>
<li>属性类型：CDATA，表示字符数据（character data）</li>
<li>默认值：</li>
</ul>
</blockquote>
<pre><code class="language-txt">#REQUIRED，表示必须出现

#IMPLIED，表示不是必须出现
</code></pre>
<ul>
<li><strong>带内部DTD的完整XML</strong>：</li>
</ul>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!-- 声明内部DTD --&gt;
&lt;!DOCTYPE books [
  &lt;!ELEMENT books (book+)&gt;
  &lt;!ELEMENT book  (author, title, description)&gt;
  &lt;!ATTLIST book id CDATA #REQUIRED &gt;
  &lt;!ELEMENT author (#PCDATA)&gt;
  &lt;!ELEMENT title (#PCDATA)&gt;
  &lt;!ELEMENT description (#PCDATA)&gt;
]&gt;

&lt;books&gt;
&lt;!-- 图书信息 --&gt;
    &lt;book id="book_1"&gt;
        &lt;author&gt;张三&lt;/author&gt;
        &lt;title&gt;XML高级教程&lt;/title&gt;
        &lt;description&gt;介绍XML和XML实战&lt;/description&gt;
    &lt;/book&gt;
    &lt;book id="book_2"&gt;
        &lt;author&gt;李四&lt;/author&gt;
        &lt;title&gt;XML中级教程&lt;/title&gt;
        &lt;description&gt;介绍XML和XML实战&lt;/description&gt;
    &lt;/book&gt;
&lt;/books&gt;
</code></pre>
<h3 id="外部的-doctype-声明">外部的 DOCTYPE 声明</h3>
<ul>
<li>创建一各独立的外部<code>DTD</code>文件，内容如下：</li>
</ul>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!—声明内部DTD--&gt;
  &lt;!ELEMENT books (book+)&gt;
  &lt;!ELEMENT book (author, title, description)&gt;
  &lt;!ATTLIST book id CDATA #REQUIRED &gt;
  &lt;!ELEMENT author (#PCDATA)&gt;
  &lt;!ELEMENT title (#PCDATA)&gt;
  &lt;!ELEMENT description (#PCDATA)&gt;
</code></pre>
<ul>
<li>在XML中引入外部DTD文件，完整的语法如下：</li>
</ul>
<pre><code class="language-xml">&lt;!DOCTYPE 根元素 SYSTEM "文件名"&gt;
</code></pre>
<ul>
<li><strong>带外部DTD的完整XML</strong>：</li>
</ul>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!-- 声明外部DTD --&gt;
&lt;!DOCTYPE books SYSTEM "books.dtd"&gt;
&lt;books&gt;
&lt;!-- 图书信息 --&gt;
    &lt;book id="book_1"&gt;
        &lt;author&gt;张三&lt;/author&gt;
        &lt;title&gt;XML高级教程&lt;/title&gt;
        &lt;description&gt;介绍XML和XML实战&lt;/description&gt;
    &lt;/book&gt;
    &lt;book id="book_2"&gt;
        &lt;author&gt;李四&lt;/author&gt;
        &lt;title&gt;XML中级教程&lt;/title&gt;
        &lt;description&gt;介绍XML和XML实战&lt;/description&gt;
    &lt;/book&gt;
&lt;/books&gt;
</code></pre>
<h2 id="认识xsd">认识XSD</h2>
<h3 id="xsd简介">XSD简介</h3>
<ul>
<li>
<p><code>XSD</code>全称：XML结构定义（<code>XML Schema Definition</code>），是<code>DTD</code>的替代者。</p>
</li>
<li>
<p>不仅可以定义<code>XML</code>文档的结构，还可以规范<code>XML</code>文档的内容。<code>XSD</code>本身也是<code>XML</code>文档。</p>
</li>
<li>
<p><code>XSD</code>采用<code>XML</code>文档来定义语义约束，比<code>DTD</code>要复杂一些，但是功能强大的多：</p>
</li>
</ul>
<blockquote>
<ul>
<li>定义可出现在文档中的元素；</li>
<li>定义可出现在文档中的属性；</li>
<li>定义哪个元素是子元素；</li>
<li>定义子元素的次序；</li>
<li>定义子元素的数目；</li>
<li>定义元素是否为空，或者是否可包含文本；</li>
<li>定义元素的数据类型；</li>
<li>定义元素和属性的默认值以及固定值。</li>
<li>允许开发这自定义数据类型</li>
<li>可读性强</li>
<li>可针对未来需求进行扩展</li>
<li>一个XML中可以引入N个Schema进行约束。</li>
<li>书写的时候，它遵守XML的语法规则，它的文件扩展名<code>XSD</code>。</li>
</ul>
</blockquote>
<h3 id="xsd举例">XSD举例</h3>
<ul>
<li>
<p>这一章节仅做了解，无需过多深入。知道XML和XSD的之间的关系就行。</p>
</li>
<li>
<p><code>book.xsd</code>文件</p>
</li>
</ul>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"&gt;
&lt;!--
	Schema文件中使用W3C对Schema文件的约束信息

	不管是XML还是XSD文件，都需要被约束
	在根标签上使用xmls属性(xmlns="http://www.w3.org/2001/XMLSchema")引用W3C的约束

	在schema中使用
	targetNamespace定义当前schema被xml引用是的名称（名称空间）;
	targetNamespace="http://www.example.org/book"定义当前的schema的名称为：http://www.example.org/book值，这个值可以随便写,用来标识约束文件
--&gt;
&lt;schema xmlns="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.example.org/book"
        xmlns:tns="http://www.example.org/book"
        elementFormDefault="qualified"&gt;
	&lt;!--
	在Schema文件中使用element标签来定义xml中可以书写的标签名	
	--&gt;
    &lt;element name="books"&gt;
		&lt;!--
		在books中的子标签，需要在Schema中定义的books的标签内部嵌入element来定义。
		简单标签：如果一个标签没有子标签，也没有属性，这个标签是一个简单标签。
		复杂标签：如果标签拥有属性或者拥有子标签，那么这个标签就是一个复杂标签。
		
		在element标签中
		complexType来声明当前element定义的那个标签是一个复杂标签
		simpleType来声明当前element定义的那个标签是一个简单标签		
		--&gt;
		&lt;complexType&gt;
		    &lt;!--在complexType使用sequence定义子标签之间的顺序--&gt;
			&lt;sequence&gt;
			    &lt;element name="book"&gt;
				    &lt;complexType&gt;
					    &lt;sequence&gt;
						     &lt;element name="name" type="string"&gt;&lt;/element&gt;
						     &lt;element name="price" type="double"&gt;&lt;/element&gt;
						     &lt;element name="author" type="string"&gt;&lt;/element&gt;							 
						&lt;/sequence&gt;					
					&lt;/complexType&gt;
				&lt;/element&gt;			
			&lt;/sequence&gt;
		&lt;/complexType&gt;		
    &lt;/element&gt;
&lt;/schema&gt;
</code></pre>
<ul>
<li><code>book.xml</code>文件</li>
</ul>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"&gt;
&lt;!--
	在根标签上使用xmls属性(xmlns="http://www.example.org/book")引用Schema的约束
	当引用多个约束时，需要在xmlns后追加
	xmlns:context="***"
	xmlns:p="***"

	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	声明当前的XML文件是schema一个实例（当前这是一个自定义的xml文件，是被某个schema文件约束）

	xsi:schemaLocation="http://www.example.org/book book.xsd"引用schema的位置，其中的“http://www.example.org/book”要与XSD中的targetNamespace里的字符串保持一致
--&gt;
&lt;books
	xmlns="http://www.example.org/book"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.example.org/book book.xsd"
&gt;
    &lt;book&gt;
	    &lt;name&gt;XML高级教程&lt;/name&gt;
	    &lt;price&gt;59&lt;/price&gt;
	    &lt;author&gt;张三&lt;/author&gt;		
	&lt;/book&gt;
&lt;/books&gt;
</code></pre>
<h1 id="应用场景">应用场景</h1>
<h2 id="case-创建一个classic-can经典can20的系统描述arxml文件">CASE: 创建一个Classic CAN（经典CAN2.0）的系统描述ARXML文件</h2>
<h3 id="参考文献">参考文献</h3>
<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/340479146" target="_blank" rel="noopener nofollow">创建一个Classic CAN（经典CAN2.0）的系统描述ARXML文件 - Zhihu</a> 【推荐】</li>
</ul>
</blockquote>
<h3 id="0-序言">0 序言</h3>
<ul>
<li><code>AUTOSAR System Description Network Explorer</code>是一个<strong>文件编辑器</strong>，支持可视化和编辑系统描述的<code>AUTOSAR</code><strong>系统描述文件(<code>.arxml</code>)</strong>和<code>ECU</code><strong>摘录的通信内容</strong></li>
</ul>
<blockquote>
<ul>
<li>它支持架构版本4.0.3、4.1.2、4.2.1、4.2.2和4.3.0。</li>
<li><strong>AUTOSAR系统描述</strong>（<code>ARXML</code>）文件是基于XML的文件格式，描述网络通信的元素基于AUTOSAR系统模板。</li>
<li>其界面如下：</li>
</ul>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208150745963-638890676.png" alt="" loading="lazy"></p>
<h3 id="1-创建一个autosar系统描述">1 创建一个AUTOSAR系统描述</h3>
<ul>
<li>双击“AUTOSAR Explorer 2.0”快捷方式（见图1-1），打开“AUTOSAR System Description Network Explorer”（见图1-2）。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208150845714-778756527.png" alt="" loading="lazy"></p>
<blockquote>
<p>图1-1</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208150856970-2073860507.png" alt="" loading="lazy"></p>
<blockquote>
<p>图1-2</p>
</blockquote>
<ul>
<li>在菜单栏中，依次选择 <code>File</code> --&gt; <code>New File …</code>(见图1-3)，弹出“Create New File”对话框。接着在该对话框中选择项目需要的“Autosar格式版本”和“物理层的通信方式”，单击“OK” (见图1-4)。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208150943862-236132018.png" alt="" loading="lazy"></p>
<blockquote>
<p>图1-3</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208150957075-1510748272.png" alt="" loading="lazy"></p>
<blockquote>
<p>图1-4</p>
</blockquote>
<blockquote>
<p>注意：</p>
<ul>
<li>创建完成后，就无法再修改“Autosar格式版本”。</li>
<li>根据所选类型创建一个具有通信Cluster和物理通道的AUTOSAR系统描述文件（见图1-5）。单击“保存”按钮，选择合适的路径，并命名这个描述文件（见图1-6）。</li>
</ul>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151042769-413318722.png" alt="" loading="lazy"></p>
<blockquote>
<p>图1-5</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151104874-996318870.png" alt="" loading="lazy"></p>
<blockquote>
<p>图1-6</p>
</blockquote>
<h3 id="2-物理层命名以及创建ecu">2 物理层命名以及创建ECU</h3>
<ul>
<li>完成第1章后，重新打开<code>Test_CAN.arxml</code>（见图2-1），选中通信Cluster，在其右侧的属性视图中，重命名这个Cluster，并设置这个CAN通信的波特率（见图2-2）。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151136011-1581045826.png" alt="" loading="lazy"></p>
<blockquote>
<p>图2-1</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151155543-528864547.png" alt="" loading="lazy"></p>
<blockquote>
<p>图2-2</p>
</blockquote>
<ul>
<li>创建ECU方法，有两种：</li>
</ul>
<blockquote>
<ul>
<li>菜单栏中，依次选择“Edit”à“Create Ecu…”(见图2-3)；</li>
<li>工具栏中，单击“Create ECU”(见图2-4)。</li>
</ul>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151224229-346100975.png" alt="" loading="lazy"></p>
<blockquote>
<p>图2-3</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151240255-598324265.png" alt="" loading="lazy"></p>
<blockquote>
<p>图2-4</p>
</blockquote>
<ul>
<li>弹出“New ECU”对话框(见图2-5)。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151305579-68072483.png" alt="" loading="lazy"></p>
<blockquote>
<p>图2-5</p>
</blockquote>
<ul>
<li>重命名ECU，单击“OK”(见图2-6)。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151319098-463233655.png" alt="" loading="lazy"></p>
<blockquote>
<p>图2-6</p>
</blockquote>
<ul>
<li>完成后的效果如下(见图2-7)：</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151342230-1061805372.png" alt="" loading="lazy"></p>
<blockquote>
<p>图2-7</p>
</blockquote>
<h3 id="3-新建一个frame">3 新建一个Frame</h3>
<ul>
<li>创建Frame方法，有三种：</li>
</ul>
<blockquote>
<ul>
<li>
<blockquote>
<p>+先在“导航栏”中选择“Frames”,然后在主视图中鼠标右键，在上下文中选择“Create Frame…”(见图3-1)；</p>
</blockquote>
</li>
</ul>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151413506-134762103.png" alt="" loading="lazy"></p>
<blockquote>
<p>图3-1</p>
</blockquote>
<ul>
<li>依次在菜单栏中选择“Edit--&gt;“Create Frame…”(见图3-2)；</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151436341-2021728738.png" alt="" loading="lazy"></p>
<blockquote>
<p>图3-2</p>
</blockquote>
<ul>
<li>工具栏中，单击“Create Frame”(见图3-3)。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151502652-1845570908.png" alt="" loading="lazy"></p>
<blockquote>
<p>图3-3</p>
</blockquote>
<ul>
<li>弹出“Edit Frame”对话框（见图3-4）。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151526337-363795531.png" alt="" loading="lazy"></p>
<ul>
<li>“Edit Frame”对话框修改如下（见图3-5）。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151547165-1464729403.png" alt="" loading="lazy"></p>
<blockquote>
<p>图3-5</p>
</blockquote>
<ul>
<li>注意：</li>
</ul>
<blockquote>
<ul>
<li>1、“Edit Frame”对话框中的“Name”，可以理解为“DBC中Message名称”；</li>
<li>2、“Edit Frame”对话框中的“Length”表示帧的数据域长度，单位Byte；</li>
<li>3、“Edit Frame”对话框中的“ID”表示CAN_ID，十六进制表示；</li>
<li>4、“Edit Frame”对话框中的“Addressing Mode”有：Standard(标准帧)和Extended(扩展帧)两个选项，表示“帧类型”，可以理解为“DBC中Message里的Type”；</li>
<li>5、“Edit Frame”对话框中的“CAN FD Supported”选项：不勾选，表示是经典CAN2.0帧；勾选，表示是CAN FD帧；</li>
<li>6、“Edit Frame”对话框中的“Sender/Receiver Relations”用来定义该Frame帧的发送和接收ECU。图3-6表示该Frame帧的发送节点是OBC；图3-7表示该Frame帧的接收节点是OBC。</li>
</ul>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151655588-1583229395.png" alt="" loading="lazy"></p>
<blockquote>
<p>图3-6</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151708773-1610569916.png" alt="" loading="lazy"></p>
<blockquote>
<p>图3-7</p>
</blockquote>
<ul>
<li>完成后的效果如下(见图3-8) ，按照此方法可以添加其它的Frame帧：</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151901460-1630300876.png" alt="" loading="lazy"></p>
<blockquote>
<p>图3-8</p>
</blockquote>
<h3 id="4-新建一个pdu协议数据单元">4 新建一个PDU（协议数据单元）</h3>
<ul>
<li>PDU的概念在DBC中是没有的。</li>
<li>PDU（Protoco&gt; +Data Unit：协议数据单元）代表<strong>在帧上传输的数据单元</strong>。</li>
</ul>
<blockquote>
<ul>
<li>它包含在协议栈中交换的有效负载和控制信息。</li>
<li>根据PDU的应用和AUTOSAR格式版本，AUTOSAR模型可以区分不同类型的PDU。</li>
<li>实际的使用：将Signal信号映射的PDU当中。</li>
</ul>
</blockquote>
<ul>
<li>接着图3-5，在PDU-Frame-Mapping中，选择“Signal-I-PDU” (见图4-1)，弹出“Edit Signal-I-PDU”对话框，根据需要编辑相关的信息(见图4-2)。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208151949633-1384736400.png" alt="" loading="lazy"></p>
<blockquote>
<p>图4-1</p>
</blockquote>
<ul>
<li>注意：常用的有以下PDU。</li>
</ul>
<blockquote>
<ul>
<li>Signal-I-PDU:</li>
<li>N-PDU: 网络层PDU。由传输协议模块用于分段I-PDU;</li>
<li>NM-PDU:</li>
<li>XCP-PDU:</li>
<li>General-Purpose-I-PDU(XCP):</li>
<li>multiplexed I-PDU: I-PDU在两个COM I-PDU中组装在IpduM模块中, 将Signal-I-PDU映射到静态和动态段。</li>
</ul>
</blockquote>
<ul>
<li>DCM-I-PDU:</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208152059675-52431606.png" alt="" loading="lazy"></p>
<blockquote>
<p>图4-2</p>
</blockquote>
<ul>
<li>注意：</li>
</ul>
<blockquote>
<ul>
<li>“Edit Signal-I-PDU”中的信息一般默认不修改。</li>
</ul>
</blockquote>
<h3 id="5-新建一个signal">5 新建一个signal</h3>
<ul>
<li>接着图3-5，在Mapped Signals中，选择“Signal” (见图5-1)，弹出“Edit Signal”对话框(见图5-2)。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208152200287-1121082889.png" alt="" loading="lazy"></p>
<blockquote>
<p>图5-1</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208152225376-411012846.png" alt="" loading="lazy"></p>
<blockquote>
<p>图5-2</p>
</blockquote>
<ul>
<li>根据需要编辑相关的信息(见图5-3，图5-4，图5-5，图5-6)。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208152241803-1005180037.png" alt="" loading="lazy"></p>
<blockquote>
<p>图5-3</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208152311643-1595645582.png" alt="" loading="lazy"></p>
<blockquote>
<p>图5-4</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208152315799-2052184295.png" alt="" loading="lazy"></p>
<blockquote>
<p>图5-5</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208152328531-1592959808.png" alt="" loading="lazy"></p>
<blockquote>
<p>图5-6</p>
</blockquote>
<ul>
<li>注意：</li>
</ul>
<blockquote>
<ul>
<li>“Edit Signal”对话框中的“Name”，可以理解为“DBC中Signal名称”；</li>
<li>“Edit Signal”对话框中的“Length”，表示信号的长度，单位Bit；<br>
+“Edit Signal”对话框中的“Data Type Policy”，对于每个ISignal，都有一个DataTypePolicy定义，在大多数情况下将确定信息源。<br>
+“Edit Signal”对话框中的“Position[Bit]”，表示信号的起始位；<br>
+“Edit Signal”对话框中的“Update Bit”，表示信号的更新位；<br>
+“Edit Signal”对话框中的“Byte Order”，表示信号的字节顺序：Intel，Motorola，Opaque；<br>
+“Edit Signal”对话框中的“Transfer Property”，表示信号的触发方式：Pending，Triggered，TriggeredOnChange，TriggeredWithoutRepetition，TriggeredOnChangeWithoutRepetition。相关的解释参加AUTOSAR COM标准；<br>
+“Edit Signal”对话框中的“Sender/Receiver Relations”，表示该信号是接收信号，还是发送信号，或者及不接收也发不发送；<br>
+“Edit Signal”对话框中的“Base Type”，定义了信号的一种编码：数据类型名称，符号类型（是否有符号），长度。当多个信号表示的物理含义相同，且信号长度相同时，可以在下拉框中选择相同的Base Type；<br>
+“Edit Signal”对话框中的“Computation Method”，描述了将信号传输的原始值转换为物理值的转换规则，信号的范围，信号的单位，无效信号的定义</li>
</ul>
</blockquote>
<ul>
<li>完成后的效果如下(见图5-7)，按照此方法可以添加其它的Signal信号：</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1173617/202502/1173617-20250208152639415-588356363.png" alt="" loading="lazy"></p>
<blockquote>
<p>图5-7</p>
</blockquote>
<blockquote>
<p>自此一个AUTOSAR的系统描述ARXML文件就生成好了。</p>
</blockquote>
<h2 id="case-在can-fd20的arxml文件实现multiplexor多路复用信号">CASE: 在CAN FD/2.0的ARXML文件实现Multiplexor多路复用信号</h2>
<ul>
<li>推荐文献</li>
</ul>
<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/340757969" target="_blank" rel="noopener nofollow">【ARXML专题】-3-在CAN FD/2.0的ARXML文件实现Multiplexor多路复用信号 - Zhihu/汽车电子Autosar</a></li>
</ul>
</blockquote>
<h1 id="arxml-软件工具支持--有哪些开源项目支持解析-arxml-文件">ARXML 软件工具支持 : 有哪些开源项目支持解析 .ARXML 文件？</h1>
<ul>
<li>解析 <code>ARXML</code>（<code>AUTOSAR XML</code>）文件的<strong>开源工具</strong>相对较少，因为 <code>AUTOSAR</code> <strong>标准</strong>在<strong>汽车电子领域</strong>较为复杂且通常依赖<strong>商业工具链</strong>（如 Vector CANoe）。</li>
</ul>
<blockquote>
<p>不过，以下开源项目和工具可以支持 ARXML 文件的解析或部分处理：(CANoe除外)</p>
</blockquote>
<h2 id="vector-canoe-商业闭源付费">Vector CANoe (商业/闭源/付费)</h2>
<ul>
<li><code>CANoe</code>是Vector公司的商业工具，常用于汽车网络分析和仿真</li>
</ul>
<h2 id="pyautosar">pyAUTOSAR</h2>
<ul>
<li>
<p>简介：一个 Python 库，专注于读写 AUTOSAR 4.x 标准的 ARXML 文件，支持解析和生成 ARXML 文件中的 ECU 配置、通信矩阵、软件组件等。</p>
</li>
<li>
<p>功能：</p>
</li>
</ul>
<blockquote>
<ul>
<li>解析 ARXML 文件并提取通信矩阵（Signals、PDUs、ECU 配置等）。</li>
<li>支持 AUTOSAR 4.x 的核心模型。</li>
<li>提供简单的 API 用于生成或修改 ARXML 内容。</li>
</ul>
</blockquote>
<ul>
<li>URL</li>
</ul>
<blockquote>
<ul>
<li>GitHub： <a href="https://github.com/ceremcem/pyautosar" target="_blank" rel="noopener nofollow">https://github.com/ceremcem/pyautosar</a></li>
</ul>
</blockquote>
<ul>
<li>适用场景：适合需要自动化处理 ARXML 文件的开发者，例如生成代码或配置 SOME/IP 服务。</li>
</ul>
<h2 id="autosar-xml-parser-autosar-schema-tools"><strong>Autosar XML Parser (AUTOSAR Schema Tools)</strong></h2>
<ul>
<li>
<p><strong>简介</strong>：部分开源项目基于 AUTOSAR 的 XML Schema（XSD）提供基础解析功能，例如使用通用 XML 解析库（如 <code>lxml</code> 或 <code>xml.etree</code>）结合 AUTOSAR Schema 解析 ARXML。</p>
</li>
<li>
<p><strong>实现方式</strong>：</p>
</li>
</ul>
<blockquote>
<ul>
<li>使用 Python 的 <code>lxml</code> 或 <code>xml.etree.ElementTree</code> 解析 XML。</li>
<li>通过 XPath 或手动遍历节点提取数据。</li>
</ul>
</blockquote>
<ul>
<li><strong>示例代码</strong>：</li>
</ul>
<pre><code class="language-python">import xml.etree.ElementTree as ET

tree = ET.parse("example.arxml")
root = tree.getroot()
# 提取信号定义（示例）
for signal in root.findall(".//{http://autosar.org/schema/r4.0}SYSTEM-SIGNAL"):
    name = signal.find("{http://autosar.org/schema/r4.0}SHORT-NAME").text
    length = signal.find("{http://autosar.org/schema/r4.0}LENGTH").text
    print(f"Signal: {name}, Length: {length}")
</code></pre>
<ul>
<li><strong>限制</strong>：需要开发者熟悉 AUTOSAR 的 XML 结构和命名空间，适合简单需求。</li>
</ul>
<h2 id="arxml-converter-开源工具链"><strong>ARXML Converter (开源工具链)</strong></h2>
<ul>
<li><strong>简介</strong>：某些开源工具链（如 <strong>COVESA Vehicle Signal Specification</strong> 相关工具）支持将 ARXML 转换为其他格式（如 JSON、YAML 或 FIBEX），便于后续处理。</li>
<li><strong>工具示例</strong>：
<ul>
<li><strong>vsomeip</strong> 的代码生成工具：通过 ARXML 提取 SOME/IP 服务定义（需自行实现解析逻辑）。</li>
<li><strong>Franca IDL</strong> 转换工具：将 ARXML 转换为 Franca 接口定义文件（需定制脚本）。</li>
</ul>
</li>
</ul>
<h2 id="eclipse-插件部分开源"><strong>Eclipse 插件（部分开源）</strong></h2>
<ul>
<li><strong>简介</strong>：Eclipse 生态中有一些支持 AUTOSAR 开发的插件（如 <strong>ARTop</strong>），但通常需要结合商业工具链使用，开源功能有限。</li>
</ul>
<hr>
<h2 id="通用-xml-工具"><strong>通用 XML 工具</strong></h2>
<p>如果仅需简单解析，可以使用通用 XML 工具（如 <code>xmllint</code> 或 Python 的 <code>xmltodict</code>）结合 AUTOSAR Schema 进行验证和数据提取：</p>
<ul>
<li><strong>xmllint</strong>：验证 ARXML 是否符合 AUTOSAR XSD。</li>
</ul>
<pre><code class="language-bash">xmllint --schema AUTOSAR_4.3.0.xsd example.arxml --noout
</code></pre>
<ul>
<li><strong>xmltodict</strong>（Python 库）：将 ARXML 转换为 Python 字典，方便处理。</li>
</ul>
<pre><code class="language-python">import xmltodict
with open("example.arxml") as f:
  arxml_dict = xmltodict.parse(f.read())
</code></pre>
<h2 id="注意事项">注意事项</h2>
<ol>
<li><strong>AUTOSAR 版本兼容性</strong>：不同版本的 AUTOSAR（如 3.x 和 4.x）的 ARXML 结构差异较大，需确认工具支持的版本。</li>
<li><strong>复杂度</strong>：ARXML 文件通常包含数千行 XML 代码，手动解析耗时且易出错，建议优先使用 <code>pyAUTOSAR</code>。</li>
<li><strong>自定义需求</strong>：如果开源工具无法满足需求，可能需要基于 XML 解析库自行开发解析逻辑。</li>
</ol>
<hr>
<h2 id="推荐方案">推荐方案</h2>
<ul>
<li><strong>快速解析</strong>：使用 <strong>pyAUTOSAR</strong>（支持 AUTOSAR 4.x）。</li>
<li><strong>简单提取</strong>：用 Python 的 <code>lxml</code> 或 <code>xmltodict</code> 结合 XPath 查询。</li>
<li><strong>格式转换</strong>：开发自定义脚本将 ARXML 转换为 JSON/YAML，再结合其他工具链处理。</li>
</ul>
<h1 id="y-推荐文献">Y 推荐文献</h1>
<ul>
<li>Github 相关项目</li>
</ul>
<blockquote>
<ul>
<li><a href="https://github.com/ebroecker/canmatrix" target="_blank" rel="noopener nofollow">https://github.com/ebroecker/canmatrix</a></li>
</ul>
<blockquote>
<p><a href="https://canmatrix.readthedocs.io/en/latest/installation.html" target="_blank" rel="noopener nofollow">https://canmatrix.readthedocs.io/en/latest/installation.html</a><br>
Converting Can (Controller Area Network) Database Formats .arxml .dbc .dbf .kcd ...</p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li><a href="https://github.com/cogu/autosar" target="_blank" rel="noopener nofollow">https://github.com/cogu/autosar</a></li>
</ul>
<blockquote>
<p>A set of python modules for working with AUTOSAR XML files<br>
主要用例是使Python能够生成ARXML文件，以便在其他（商业）AUTOSAR工具链中导入。它还对解析AUTOSAR XML文件提供了一些支持。</p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li><a href="https://github.com/mahmut-aksakalli/arxml-viewer" target="_blank" rel="noopener nofollow">https://github.com/mahmut-aksakalli/arxml-viewer</a></li>
</ul>
<blockquote>
<p>基于Vue+Node JS的纯前端/ARXML可视化项目<br>
This tool aims to visualize ARXML files in human readable form with easy search operations.</p>
</blockquote>
</blockquote>
<h1 id="x-参考文献">X 参考文献</h1>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/340347631" target="_blank" rel="noopener nofollow">【ARXML专题】-1-什么是ARXML - Zhihu</a></li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <div class="essaySuffix-box">
    <div class="essaySuffix-box-left" style=" margin: 6px auto; ">
        <img src="https://blog-static.cnblogs.com/files/johnnyzen/cnblogs-qq-group-qrcode.gif?t=1679679148" alt="QQ沟通交流群" onload="changeImg(this,200,100)">
    </div>
<div class="essaySuffix-box-right">
    <span class="essaySuffix-right-title">本文作者</span>：
        <strong><span><a href="https://github.com/Johnny-ZTSD" target="_blank">千千寰宇</a></span></strong>
    <br>
    <span style="font-weight: bold; white-space:nowrap;">本文链接</span>：
        <a href="https://www.cnblogs.com/johnnyzen" target="_blank" id="articleLinkElement"> https://www.cnblogs.com/johnnyzen</a>
    <br>
    <span class="essaySuffix-right-title">关于博文</span>：评论和私信会在第一时间回复，或<a href="https://msg.cnblogs.com/msg/send/johnnyzen" target="_blank">直接私信</a>我。
    <br>
    <span class="essaySuffix-right-title">版权声明</span>：本博客所有文章除特别声明外，均采用 <a title="https://creativecommons.org/licenses/by-nc-nd/4.0/" href="http://blog.sina.com.cn/s/blog_896327b90102y6c6.html" alt="BY-NC-SA" target="_blank">BY-NC-SA</a> 
    许可协议。转载请注明出处！<br>
    <span class="essaySuffix-right-title">日常交流</span>：大数据与软件开发-QQ交流群: 774386015<strong>
        <span style="color: #ff0000; font-size: 12pt;">【<a id="post-up" onclick="votePost(getArticleNumber(),'Digg')" href="javascript:void(0);">入群二维码</a>】</span></strong>参见左下角。您的支持、鼓励<span style="color: #ff0000; font-size: 12pt;"></span>是博主技术写作的重要动力！
    <br>
</div>
<div style="clear: both;">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.020591281806712963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-08 15:47">2025-02-08 15:28</span>&nbsp;
<a href="https://www.cnblogs.com/johnnyzen">千千寰宇</a>&nbsp;
阅读(<span id="post_view_count">18</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18704323" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18704323);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18704323', targetLink: 'https://www.cnblogs.com/johnnyzen/p/18704323', title: '[车联网/计算机网络] Autosar 的 `ARXML` 配置数据库文件协议' })">举报</a>
</div>
        