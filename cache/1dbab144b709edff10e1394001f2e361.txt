<!----> <meta itemprop="headline" content="制作数字农场可视化大屏"> <meta itemprop="keywords" content="前端"> <meta itemprop="datePublished" content="2024-11-01T08:41:57.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Gyrate"> <meta itemprop="url" content="https://juejin.cn/user/1591748568294120"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7cdd11fb="">
            制作数字农场可视化大屏
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7cdd11fb=""><div class="author-info-box" data-v-7cdd11fb=""><div class="author-name" data-v-7cdd11fb=""><a href="/user/1591748568294120/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-7cdd11fb=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    Gyrate
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-7cdd11fb=""><time datetime="2024-11-01T08:41:57.000Z" title="Fri Nov 01 2024 08:41:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7cdd11fb="">
                    2024-11-01
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7cdd11fb=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7cdd11fb=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7cdd11fb=""></circle></svg> <span class="views-count" data-v-7cdd11fb="">
                    21,477
                  </span> <span class="read-time" data-v-7cdd11fb=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7cdd11fb=""><rect width="16" height="16" fill="none" data-v-7cdd11fb=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7cdd11fb=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7cdd11fb=""></path></svg>
                    阅读25分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7cdd11fb=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7cdd11fb=""><div class="article-viewer markdown-body result"><h2 data-id="heading-0">1.介绍</h2>
<p>数字农业可视化是一种将农业生产过程中的各类数据，通过先进的信息技术手段进行采集、整合、分析，并以直观的可视化形式呈现出来的技术应用模式。它利用大数据、物联网、人工智能、GIS等技术，为农业生产经营管理提供了全新的、高效的决策支持工具，使农业从业者能够更加清晰、准确地了解农业生产的各个环节，从而实现精准决策、精细管理和高效运营。</p>
<p>最近对数字农业有点感兴趣，于是就有了接下来的探索和尝试，本文的内容比较有综合性，基本上用到了之前在技术社区分享的大部分经验，不仅包括高德开发平台的技术，也集成了具体业务分析、GIS数据生成、3D模型制作等内容。附<a href="https://link.juejin.cn?target=https%3A%2F%2Fgyrate.github.io%2FdigitalFarm%2Fdist%2Findex.html%23%2Findex" target="_blank" title="https://gyrate.github.io/digitalFarm/dist/index.html#/index" ref="nofollow noopener noreferrer">演示页面地址</a>，源代码地址见文末。</p>
<p><span href="https://www.ixigua.com/7430734464654770700" target="_blank" class="jj-video-container" style="box-sizing:border-box;display:block;position:relative;z-index:1;"><iframe class="jj-video-frame" style="position:absolute;visibility:hidden;z-index:1;width:100%;aspect-ratio: 16/9;border-radius:8px;border:0.5px solid rgba(128,128,128,0.4);" src="https://www.ixigua.com/iframe/7430734464654770700?autoplay=0" loading="lazy" allowfullscreen="" frameborder="0" referrerpolicy="unsafe-url"></iframe><span class="jj-video-placeholder"><img class="jj-video-placeholder-img" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8e14f9701a846b389ec138eb2b6349a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1008&amp;h=483&amp;s=7674&amp;e=png&amp;b=000000" style="width:100%;aspect-ratio: 16/9;border-radius:8px;border:0.5px solid rgba(128,128,128,0.4);" loading="lazy"></span></span></p>
<h2 data-id="heading-1">2. 需求分析</h2>
<p>本次做可视化大屏的开发，我希望最终的开发成果是可以在后续的产品或者项目中复用、至少能发挥一定的参考价值，因此需要做一些业务需求分析。由于我在这方面的业务涉猎比较浅显，于是先看了几个智慧农业解决方案方便的PPT，然后询问AI助手，整理为下面几个专题的内容：</p>
<h3 data-id="heading-2">2.1 基础配套</h3>
<ol>
<li>
<p>地形：以三维地形图的形式呈现，通过不同颜色和高度标识展示区域内的山地、沼泽、平原等地形分布。可以使用等高线、阴影等效果增强立体感，让用户直观了解地形的起伏。由于增加地形起伏会直接增加其他贴合地形图层的实现复杂度，为降低阅读难度本次示例选了块地形相对平整的冲击平原，因此规避地形问题。</p>
</li>
<li>
<p>影像：展示高分辨率的卫星影像图，全面覆盖智慧农业所涉及的区域范围，让用户能够以宏观视角清晰了解整个区域的全貌，包括地形、河流、村居、植被等基础配套元素的分布及相互关系。</p>
</li>
<li>
<p>水域：在地图上清晰标注河流的走向、河道宽度以及与其他水体的连接关系</p>
</li>
<li>
<p>水质：如酸碱度、溶解氧、污染物含量等指标，并以不同颜色或图表形式在大屏上直观展示，以保障农业用水安全。</p>
</li>
<li>
<p>村居建筑：展示村庄的分布位置和范围，以建筑模型或图标形式呈现村居的布局。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/613c13e31ab446d3bf7778f5d44fea90~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=Yt1IuHGcKmaMx5kPM6wG%2BIKsmwo%3D" alt="Honeycam_2024-10-28_09-30-42.gif" loading="lazy"></p>
</li>
</ol>
<h3 data-id="heading-3">2.2 农业生产</h3>
<ol>
<li>
<p>农田：以高精度地图展示农田地块的边界和面积，对不同的农田进行编号和分类管理，例如按照种植作物类型、当前使用状态等进行划分</p>
</li>
<li>
<p>鱼塘：标注鱼塘的位置和范围，显示鱼塘的面积和水深等基本信息。展示鱼塘的养殖情况，包括养殖的鱼类品种、生长阶段、投喂记录等，方便养殖户进行科学管理和养殖计划制定。</p>
</li>
<li>
<p>作物识别：利用图像识别技术，通过摄像头或卫星影像对农田中的作物进行实时识别和分类。在大屏上以不同颜色或图标标注出不同作物的种植区域，方便用户快速了解农田的作物布局</p>
</li>
<li>
<p>灾害预测：通过监测田间的病虫害发生情况、气象条件、作物生长状况等因素，运用病虫害预测模型，预测病虫害的发生趋势和流行范围。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/99c746c33544450abedcb4a910757147~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=suK5L7XZSt29pILt7mejXFnmipo%3D" alt="Honeycam_2024-10-28_10-04-29.gif" loading="lazy"></p>
</li>
</ol>
<h3 data-id="heading-4">2.3 安全监管</h3>
<ol>
<li>
<p>无人机巡查：在地图上展示无人机的巡查路线和实时位置，用户可以直观地看到无人机的飞行轨迹。</p>
</li>
<li>
<p>入侵告警：在地图上划定重点安全区域，如农田保护区、鱼塘养殖区、仓库等，当有人员或车辆未经授权进入这些区域时，系统自动触发入侵告警。</p>
</li>
<li>
<p>重点位置POI：在地图上标注所有摄像头的位置，形成 POI（Point of Interest）图层。用户可以点击每个摄像头图标，查看该摄像头的实时监控画面和相关信息，如摄像头编号、安装位置、监控范围等。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c4f88fce7e784e1db282be79cad471f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=4U902iTh2NlF2MxUEWQj7FVMhoM%3D" alt="Honeycam_2024-10-23_15-34-14.gif" loading="lazy"></p>
</li>
</ol>
<h3 data-id="heading-5">2.4 经济效益</h3>
<ol>
<li>
<p>区块产量预测：对比不同年份或不同种植季节的产量预测数据，分析产量变化趋势和影响因素，为农业生产规划和资源配置提供决策依据</p>
</li>
<li>
<p>投入产出比分析：详细展示农业生产过程中的各项投入成本，包括土地租赁费用、农资采购成本、人工成本、水电费、运输费用等，并以图表形式呈现各项成本在总成本中的占比情况，帮助用户清晰了解成本结构。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0883e00aba8245aaa0cb8a4e9a6172cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=Xx1NWa4BurON2ifIhQgtwEfC5aQ%3D" alt="Honeycam_2024-10-28_09-36-31.gif" loading="lazy"></p>
</li>
</ol>
<h2 data-id="heading-6">3. 技术分析</h2>
<p>经过上面的业务需求分析，我们就可以开始将它们转为技术上的需求模块进行逐个实现，其中部分图层可视化效果，使用高德平台提供的可视化类Loca可以满足了，其他部分图层则需要自行开发，这里我将自己平时积累的可视化图层整理为的gl-layers图层库，核心代码是基于three JS和高德自定义图层类CustomLayer、GLCustomLayer进行开发。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d42439d747174febace3cb8c139b5600~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=rhWV3NH4ownLxWPZUkohVMeobcE%3D" alt="image.png" loading="lazy"></p>
<h3 data-id="heading-7">3.1 技术栈说明</h3>























































<table><thead><tr><th>工具名称</th><th>版本</th><th>用途</th></tr></thead><tbody><tr><td>高德地图 JSAPI</td><td>2.0</td><td>为GIS平台提供基础底图和服务</td></tr><tr><td>three.js</td><td>0.157</td><td>主流webGL引擎之一，负责实现展示层面的功能</td></tr><tr><td>QGIS</td><td>3.32.3</td><td>GIS数据处理工具，用于处理本文的矢量化数据</td></tr><tr><td>cesiumlab</td><td>3.1.11</td><td>三维数据处理工具集，用于将模型转换为互联网可用的3DTiles</td></tr><tr><td>blender</td><td>3.6</td><td>模型处理工具，用于对BIM模型进行最简单的预处理</td></tr><tr><td>CityEngine</td><td>2023.0</td><td>arcGIS团队开发的程序化 3D 城市生成器 ，支持通过脚本将GIS转换为3D模型</td></tr><tr><td>vue</td><td>3.2.25</td><td>实现可视化大屏UI的语言框架，特点是数据双向绑定</td></tr><tr><td>vite</td><td>2.9.15</td><td>便捷的前端工程构建工具</td></tr><tr><td>AI Earth</td><td></td><td>达摩学院提供的AIE-SEM影像识别、分割、提取服务，可以帮忙我们从遥感影像图片中提取GIS数据</td></tr></tbody></table>
<h3 data-id="heading-8">3.2 图层说明</h3>







































































































<table><thead><tr><th>专题</th><th>内容</th><th>GIS数据类型</th><th>表现形式</th><th>代码层</th></tr></thead><tbody><tr><td>基础配套</td><td>卫星影像底图</td><td>图片</td><td>瓦片地图</td><td>AMap.TileLayer</td></tr><tr><td>基础配套</td><td>村居建筑</td><td>polygon</td><td>三维建筑模型</td><td>GlLayer.TilesLayer</td></tr><tr><td>基础配套</td><td>绿化区域</td><td>point</td><td>实例模型</td><td>GlLayer.TilesLayer</td></tr><tr><td>基础配套</td><td>水域</td><td>polygon</td><td>水面多边形</td><td>GlLayer.WaterLayer</td></tr><tr><td>农业生产</td><td>农田地块</td><td>polygon</td><td>带纹理多边形，可区分当前使用状态</td><td>GlLayer.PolygonLayer</td></tr><tr><td>农业生产</td><td>鱼塘地块</td><td>polygon</td><td>带纹理多边形，可区分当前水体状态</td><td>GlLayer.PolygonLayer</td></tr><tr><td>农业生产</td><td>农作物识别结果</td><td>point</td><td>作物类型点图标</td><td>AMap.MassMarker</td></tr><tr><td>农业生产</td><td>农田灾害风险AI预测图</td><td>point</td><td>热力图</td><td>Loca.HeatMapLayer</td></tr><tr><td>安全监管</td><td>区域边界</td><td>polyline</td><td>三维发光墙面体，如果有监控目标进入区域内则会出现告警</td><td>GlLayer.BorderLayer</td></tr><tr><td>安全监管</td><td>无人机导航</td><td>polyline</td><td>无人机模型在空中飞行移动</td><td>GlLayer.DrivingLayer</td></tr><tr><td>安全监管</td><td>巡查路线</td><td>polyline</td><td>无人机移动轨迹</td><td>GlLayer.FlowlineLayer</td></tr><tr><td>安全监管</td><td>示范区服务点</td><td>point</td><td>带名称点标记，点击可切换到专属视角</td><td>Loca.LabelsLayer</td></tr><tr><td>经济效益</td><td>产量AI预测图层</td><td>point</td><td>网格蜂窝柱状图，产量越大柱状越红且越高</td><td>Loca.HexagonLayer</td></tr></tbody></table>
<h2 data-id="heading-9">4. 实现步骤</h2>
<h3 data-id="heading-10">4.1 主体框架开发</h3>
<ol>
<li>
<p>使用vite创建工程，安装前文技术栈提及的各种依赖包</p>
</li>
<li>
<p>在入口模块编写主体逻辑，引入主要模块、声明变量</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { getMap, initMap } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/mainMap2.js'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">GLlayer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'#/gl-layers/src/index'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'three'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> dat <span class="hljs-keyword">from</span> <span class="hljs-string">'dat.gui'</span>
<span class="hljs-comment">//...</span>

<span class="hljs-comment">// 高德可视化类</span>
<span class="hljs-keyword">let</span> loca
<span class="hljs-comment">// 容器</span>
<span class="hljs-keyword">const</span> container = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)
<span class="hljs-comment">// 图层管理</span>
<span class="hljs-keyword">const</span> layerManger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LayerManager</span>()
<span class="hljs-comment">// 信息提示浮层</span>
<span class="hljs-keyword">let</span> normalMarker
<span class="hljs-comment">//...</span>

<span class="hljs-title function_">onMounted</span>(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">// 初始化地图</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">init</span>()
  <span class="hljs-comment">// 初始化各种图层</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">initLayers</span>()
  <span class="hljs-comment">// 逐帧函数，用于更新模型动画等内容</span>
  <span class="hljs-title function_">animateFn</span>()
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"container"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tool"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"gotoCenter()"</span>&gt;</span>回到中心<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"toggleCross()"</span>&gt;</span>越界告警<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"toggleDronView()"</span>&gt;</span>无人机巡航<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
</li>
<li>
<p>初始化基础地图，并添加卫星影像图</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
	<span class="hljs-comment">// 将高德地图Map实例化做了一次封装</span>
  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">await</span> <span class="hljs-title function_">initMap</span>({
    <span class="hljs-attr">viewMode</span>: <span class="hljs-string">'3D'</span>,
    <span class="hljs-attr">dom</span>: container.<span class="hljs-property">value</span>,
    <span class="hljs-attr">showBuildingBlock</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">center</span>: <span class="hljs-variable constant_">SETTING</span>.<span class="hljs-property">center</span>,
    <span class="hljs-attr">zoom</span>: <span class="hljs-number">15.5</span>,
    <span class="hljs-attr">pitch</span>: <span class="hljs-number">42.0</span>,
    <span class="hljs-attr">rotation</span>: <span class="hljs-number">4.9</span>,
    <span class="hljs-attr">mapStyle</span>: <span class="hljs-string">'amap://styles/light'</span>,
    <span class="hljs-attr">skyColor</span>: <span class="hljs-string">'#c8edff'</span>
  })

  <span class="hljs-comment">// 添加卫星地图</span>
  <span class="hljs-keyword">const</span> satelliteLayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMap</span>.<span class="hljs-property">TileLayer</span>.<span class="hljs-title class_">Satellite</span>();
  map.<span class="hljs-title function_">add</span>([satelliteLayer]);
  
  <span class="hljs-comment">// 监听地图缩放和点击，用于开发调试</span>
  map.<span class="hljs-title function_">on</span>(<span class="hljs-string">'zoomend'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">getZoom</span>())
  })
  map.<span class="hljs-title function_">on</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { lng, lat } = e.<span class="hljs-property">lnglat</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([lng, lat])
  })
  <span class="hljs-comment">// 高德可视化类</span>
  loca = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Loca</span>.<span class="hljs-title class_">Container</span>({
    map,
  });
  <span class="hljs-comment">// 鼠标悬浮于图层元素上时，出现信息浮层</span>
  normalMarker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMap</span>.<span class="hljs-title class_">Marker</span>({
    <span class="hljs-attr">offset</span>: [<span class="hljs-number">70</span>, -<span class="hljs-number">15</span>],
    <span class="hljs-attr">zooms</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">22</span>]
  });

}
</code></pre>
</li>
</ol>
<h3 data-id="heading-11">4.2 村居/绿化图层</h3>
<p>村居是指农业示范区内的建筑面生成模型，绿化图层则是绿树等植物的覆盖区域，原本应该是两个图层，因为在本场景中仅仅作为地图三维底座，均无交互性，我就直接把它们合并为一个3Dtiles以提升性能了。</p>
<h4 data-id="heading-12">4.2.1 制作村居数据</h4>
<ol>
<li>
<p>村居数据的建筑面获取方法有两种，我们可以通过一些GIS数据工具下载指定区域内建筑面数据，也可以通过AI Earth进行卫星影像图建筑物提取，最终生成geoJSON文件，导入QGIS进行数据清洗和加工。</p>
</li>
<li>
<p>如果建筑面没有高度数据，我们根据目标场景的实际情况，可以在QGIS中生成一定范围内的随机值</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d1f20e466a62467fbc4e9e0370fd1621~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=cBqZu28aWcsYvLgCatsNLGZQaRs%3D" alt="Honeycam_2024-10-28_09-45-21.gif" loading="lazy"></p>
</li>
</ol>
<h4 data-id="heading-13">4.2.2 制作绿化区域数据</h4>
<ol>
<li>使用QGIS新建多边形面图层，在目标场景区域内将绿化区域圈选出来。在过程中可能会涉及到带孔多边形的制作，我们可以利用矢量多边形的布尔运算获得。</li>
<li>在QGIS工具箱找到“矢量创建-多边形内部的随机点”即可生成随机点功能，即可在绿化区域生成均匀分布的随机点，后续每个点我们都可以种上一棵树。</li>
</ol>
<h4 data-id="heading-14">4.2.3 转换为3D瓦片</h4>
<ol>
<li>
<p>新建cityEngine工程，并将制作好的村居和绿化数据另存为SHP格式，置入到工程中</p>
</li>
<li>
<p>将目标场景的矩形范围也导出一张TIF格式的图片，置入到工程中，作为本工程场景的底图</p>
</li>
<li>
<p>将村居数据Polygons拖入场景编辑面板中，选中元素对象并配置规则文件，我们就可以快速生成建筑模型，并通过配置将建筑高度与建筑面高度数据关联上，选择合适的房屋造型和风格。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3f9bc62b0e247828f810eeb76494e09~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=TszlVigsZtnt8nBQ0y4%2B1gDxZwY%3D" alt="Honeycam_2024-10-28_09-53-08.gif" loading="lazy"></p>
</li>
<li>
<p>同理将绿化区域数据Points拖拽入场景编辑面板，并配置植物生成规则文件，我们就可以快速得到效果非常不错的植物绿化区域</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a8fd5b0c49d3487ab97991dd4eb971c7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=c2uijGtYez9HZRCM%2B1EegD4SWGM%3D" alt="Honeycam_2024-10-28_09-54-49.gif" loading="lazy"></p>
</li>
<li>
<p>选中两个图层的模型并导出为FBX，注意配置面板中的设置，中心一项关系到所有模型在地图上的位置是否正确，需要格外关注</p>
</li>
<li>
<p>开启cesiumlab，进入通用模型切片，直接转换为3Dtiles，可以在ceisumlab的预览页面中看到建筑和植物都落在地球的地面上，可能原点的地理位置是错误的。这个不用担心，我们在将其接入高德地图时做再做调整。更细节的步骤可以看我之前写的<a href="https://juejin.cn/post/7329322608212885555" target="_blank" title="https://juejin.cn/post/7329322608212885555">低成本创建数字孪生场景</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f7e36aba7f644264baf130880b455785~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=btRirerE7Zd%2FNlrPXQfVOieIhuE%3D" alt="image 1.png" loading="lazy"></p>
</li>
</ol>
<h4 data-id="heading-15">4.2.4 在高德地图呈现</h4>
<ol>
<li>
<p>部署3dtiles静态服务，在高德地图中需要重新定义3dtiles的原点坐标，因此需要创建一个tileset.json入口文件副本，并将其初始转置矩阵归零</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc105880dcfb4b74a20be0b1d93d21a7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=I3NdaLwIJ1qsmkWcRJeq75Xco3c%3D" alt="image 2.png" loading="lazy"></p>
</li>
<li>
<p>编写代码，这里使用之前开发的TilesLayer图层做加载，关于如何在高德地图中实现3dtiles，想了解具体实现可以<a href="https://juejin.cn/post/7143445626658193439" target="_blank" title="https://juejin.cn/post/7143445626658193439">看看这里</a> 。</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">async</span> function <span class="hljs-title">initBuildingLayer</span>()</span> {
  <span class="hljs-keyword">const</span> map = getMap()

  <span class="hljs-keyword">const</span> layer = <span class="hljs-keyword">new</span> TilesLayer({
    id: <span class="hljs-string">'buildingLayer'</span>,
    title: <span class="hljs-string">'村居建筑图层'</span>,
    alone: SETTING.alone,
    map,
    center: [<span class="hljs-number">113.531905</span>, <span class="hljs-number">22.737473</span>], <span class="hljs-comment">// 图层中心点</span>
    zooms: [<span class="hljs-number">4</span>, <span class="hljs-number">30</span>],
    interact: <span class="hljs-literal">false</span>,
    tilesURL: <span class="hljs-string">'http://localhost:9003/model/twQ1mVSwQ/tileset.0.json'</span>, <span class="hljs-comment">// 村居模型 </span>
    needShadow: <span class="hljs-literal">true</span>
  })
  layerManger.<span class="hljs-keyword">add</span>(layer)
}
</code></pre>
</li>
<li>
<p>为保证视觉效果，加载完成后还对模型打光调亮、添加阴影，关于如何在地图的平面上添加阴影，需要开个单独的小节在后文详叙。</p>
<pre><code class="hljs language-jsx" lang="jsx">layer.<span class="hljs-title function_">on</span>(<span class="hljs-string">'complete'</span>, <span class="hljs-function">(<span class="hljs-params">{ scene, renderer }</span>) =&gt;</span> {
    <span class="hljs-comment">// 调整模型的亮度</span>
    <span class="hljs-keyword">const</span> aLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AmbientLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">0.5</span>)
    scene.<span class="hljs-title function_">add</span>(aLight)
    <span class="hljs-comment">//...</span>

    <span class="hljs-comment">// 平行光,增加投影</span>
    <span class="hljs-keyword">var</span> dLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">DirectionalLight</span>(<span class="hljs-number">0xffffff</span>, intetity);
    dLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(lightPositionX, lightPositionY, lightPositionZ);
    dLight.<span class="hljs-property">castShadow</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 开启阴影投射</span>
    dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">mapSize</span>.<span class="hljs-property">width</span> = mapSize; <span class="hljs-comment">// 增加阴影分辨率</span>
    dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">mapSize</span>.<span class="hljs-property">height</span> = mapSize;
    dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">near</span> = cameraNear;
    dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">far</span> = caremaFar;
    dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">left</span> = cameraLeft;
    dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">right</span> = cameraRight;
    dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">top</span> = cameraTop;
    dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">bottom</span> = cameraBottom;
    dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">bias</span> = -<span class="hljs-number">0.0001</span>; <span class="hljs-comment">// 负值将阴影稍微向外偏移</span>
    scene.<span class="hljs-title function_">add</span>(dLight);
    directionalLight = dLight

    <span class="hljs-comment">// 平面阴影</span>
    <span class="hljs-keyword">const</span> geometry1 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneGeometry</span>(<span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>);
    <span class="hljs-keyword">const</span> material1 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">ShadowMaterial</span>({ <span class="hljs-attr">opacity</span>: <span class="hljs-number">1.0</span> })
    <span class="hljs-keyword">const</span> plane = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry1, material1);
    plane.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = <span class="hljs-number">0</span>;
    plane.<span class="hljs-property">receiveShadow</span> = <span class="hljs-literal">true</span>;
    scene.<span class="hljs-title function_">add</span>(plane);

  })
</code></pre>
</li>
<li>
<p>最终的效果如下</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/597bebb233a24eb0aa4a0257c1df3d49~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=rZ8ozg5s%2B1J4stwIxEbVifYCR1k%3D" alt="image 3.png" loading="lazy"></p>
</li>
</ol>
<h3 data-id="heading-16">4.3 水域图层</h3>
<ol>
<li>
<p>我们同样可以使用QGIS自行绘制、或者使用GIS工具获取水域范围数据</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/594884d0e88b432c8248b343e6cfa975~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=OjqWKgLLJSFmwNZGPi0V64wlRug%3D" alt="image 4.png" loading="lazy"></p>
</li>
<li>
<p>水面的实现方式是在指定的多边形平面上添加水纹材质，这里使用到了ShaderMaterial编写自定义着色器材质，我们封装为WaterLayer图层，详细步骤可以<a href="https://juejin.cn/post/7173172422445629448" target="_blank" title="https://juejin.cn/post/7173172422445629448">看这里</a></p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initWaterLayer</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> map = <span class="hljs-title function_">getMap</span>()
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchMockData</span>(<span class="hljs-string">'water.geojson'</span>)
  <span class="hljs-keyword">const</span> layer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GLlayers</span>.<span class="hljs-title class_">WaterLayer</span>({
    <span class="hljs-attr">id</span>: <span class="hljs-string">'waterLayer'</span>,
    map,
    data, <span class="hljs-comment">// 水域GIS数据</span>
    <span class="hljs-attr">alone</span>: <span class="hljs-variable constant_">SETTING</span>.<span class="hljs-property">alone</span>,
    <span class="hljs-attr">zooms</span>: [<span class="hljs-number">16</span>, <span class="hljs-number">22</span>],
    <span class="hljs-attr">animate</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">waterColor</span>: <span class="hljs-string">'#CFEACD'</span>, <span class="hljs-comment">// 水体颜色</span>
    <span class="hljs-attr">altitude</span>: -<span class="hljs-number">5</span> <span class="hljs-comment">// 水面Mesh高度</span>
  })
  layerManger.<span class="hljs-title function_">add</span>(layer)
}
</code></pre>
</li>
<li>
<p>最终效果如下，动静结合这样一来村居看起来更灵动了</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c5aeca4d378a48f7ae512f8004da68b6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=7ETpQmvz1LL3GlBuQPe5us%2F9wB0%3D" alt="Honeycam_2024-10-27_10-58-23.gif" loading="lazy"></p>
</li>
</ol>
<h3 data-id="heading-17">4.4 农田地块</h3>
<ol>
<li>
<p>农田和鱼塘地块具有共同的特性，实现方法类似可以合起来讲，在QGIS上我们就可以通过属性表对polygone按属性做分类</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6e967c3074ff40699f92dd780f5ba9aa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=FcD0ElJ4qD%2Fsk5Heifxjl%2BLI31k%3D" alt="image 5.png" loading="lazy"></p>
</li>
<li>
<p>获取数据，实例化Polylone，其实这种常规的Polygon，高德地图Loca也有提供，之所以用自己开发的polygon是想给Polygon添加图片纹理，比如正在使用的地块使用水稻田纹理 ，而养护中的地块则使用土地纹理，简单一点就是用颜色做区分。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initFarmLayer</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> map = <span class="hljs-title function_">getMap</span>()
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchMockData</span>(<span class="hljs-string">'farm.geojson'</span>)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)

  data.<span class="hljs-property">features</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> { used } = item.<span class="hljs-property">properties</span>
    <span class="hljs-comment">// 根据地块不同的使用状态，赋予不同的颜色</span>
    item.<span class="hljs-property">properties</span>.<span class="hljs-property">color</span> = used == <span class="hljs-number">1</span> ? <span class="hljs-string">"#33a02c"</span> : (used == <span class="hljs-number">0</span> ? <span class="hljs-string">"#b2df8a"</span> : <span class="hljs-string">"#ceb89e"</span>)
  })
	
  <span class="hljs-keyword">const</span> layer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlLayer</span>.<span class="hljs-title class_">PolygonLayer</span>({
    <span class="hljs-attr">id</span>: <span class="hljs-string">'farmLayer'</span>,
    <span class="hljs-attr">alone</span>: <span class="hljs-variable constant_">SETTING</span>.<span class="hljs-property">alone</span>,
    map,
    data,
    <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.4</span>,
    <span class="hljs-attr">interact</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//可鼠标互动</span>
    <span class="hljs-attr">zIndex</span>: <span class="hljs-number">100</span>,
    <span class="hljs-attr">altitude</span>: <span class="hljs-number">2</span>
  })
  <span class="hljs-comment">// 放入图层管理器</span>
  layerManger.<span class="hljs-title function_">add</span>(layer)

}
</code></pre>
</li>
<li>
<p>单个PolygonLayer生成Mesh的核心代码如下，将空间坐标数组转为Mesh的顶点三角面，并赋予材质，更详细的的实现步骤可以看看之前分享的<a href="https://juejin.cn/post/7343915907940024347" target="_blank" title="https://juejin.cn/post/7343915907940024347">在高德地图上实现Polylone图层</a>。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">/**
 * 绘制多边形
 * <span class="hljs-doctag">@private</span>
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Array</span>} path 路径
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} properties 属性
 */</span>
drawPolygon ({ path, properties }) {
  <span class="hljs-keyword">const</span> { altitude, opacity } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_conf</span>

  <span class="hljs-comment">// 将路径数据扁平化</span>
  <span class="hljs-keyword">const</span> flatArr = path.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> [v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>], altitude]
  }).<span class="hljs-title function_">flat</span>()

  <span class="hljs-comment">// 三角剖分</span>
  <span class="hljs-keyword">const</span> triangles = <span class="hljs-title class_">Earcut</span>.<span class="hljs-title function_">triangulate</span>(flatArr, <span class="hljs-literal">null</span>, <span class="hljs-number">3</span>)
  <span class="hljs-comment">// 创建一个THREE.Geometry对象</span>
  <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferGeometry</span>()
  <span class="hljs-comment">// 将三角形的顶点添加到geometry对象</span>
  <span class="hljs-keyword">let</span> faceList = []

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; triangles.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> [x, y, z] = path[triangles[i]]
    faceList = [...faceList, x, y, altitude]
  }

  <span class="hljs-comment">// 顶点三角面</span>
  geometry.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'position'</span>, <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(faceList), <span class="hljs-number">3</span>))
  <span class="hljs-comment">// 计算法线和顶点的面连接关系</span>
  geometry.<span class="hljs-title function_">computeVertexNormals</span>()

  <span class="hljs-comment">// 创建材质</span>
  <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>({
    <span class="hljs-attr">color</span>: properties.<span class="hljs-property">color</span> || <span class="hljs-string">'#0674F1'</span>,
    <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">opacity</span>: properties.<span class="hljs-property">opacity</span> || opacity
  })

  <span class="hljs-comment">// 创建多边形的网格对象</span>
  <span class="hljs-keyword">const</span> polygon = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material)
  <span class="hljs-comment">// 将多边形网格对象添加到场景中</span>
  <span class="hljs-keyword">const</span> _scene = <span class="hljs-variable language_">this</span>.<span class="hljs-property">group</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">scene</span>
  _scene.<span class="hljs-title function_">add</span>(polygon)
}
</code></pre>
</li>
<li>
<p>最终效果如下</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/143db79cf18443809aeb542b2b883f33~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=RvAdtvyo1UxSpl00UU%2Bfa9w0Fzc%3D" alt="Honeycam_2024-10-27_11-19-52.gif" loading="lazy"></p>
</li>
</ol>
<h3 data-id="heading-18">4.5 作物识别图层</h3>
<ol>
<li>
<p>作物识别图层的作用是展示AI遥感识别技术对农田作物的识别结果，以及展示AI技术对鱼塘产量做出的预测数据，用AMap.MassMarker就可以满足了</p>
</li>
<li>
<p>需要注意的是点标记的坐标位置是如何生成的，总不可能手动创建效率太低了，我们可以使用QGIS自带的矢量数据处理功能自动创建质心，直接为每个polygon生成中心坐标点。右键图层打开属性表添加识别结果，导出geojson格式备用。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4256beead93446958b9c4b1f096acece~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=djbb9uV68Cl3I7X9PMXFwW49gJI%3D" alt="image 6.png" loading="lazy"></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ad461ef836249e39dcb9793d0d267d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=G35Lg2UO4SkawSKabtpR1kFB8nA%3D" alt="image 7.png" loading="lazy"></p>
</li>
<li>
<p>在高德地图中添加图层实现，为保证与其他图层的接口统一，我对MassMark和MassMakers进行了封装，统一基础属性、初始化配置参数和显示隐藏方法。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">BaseUtils</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./BaseUtils'</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CropLayer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">BaseUtils</span> {
    data = [];
    markers = [];
    id = <span class="hljs-literal">null</span>
    layer = <span class="hljs-literal">null</span>

    iconMap = {
        <span class="hljs-string">'香蕉'</span>: { <span class="hljs-attr">icon</span>: <span class="hljs-string">'xiangjiao.png'</span>, <span class="hljs-attr">style</span>: <span class="hljs-number">0</span>},
        <span class="hljs-string">'火龙果'</span>: { <span class="hljs-attr">icon</span>: <span class="hljs-string">'huolongguo.png'</span>, <span class="hljs-attr">style</span>: <span class="hljs-number">1</span>},
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">config</span>) {
        <span class="hljs-variable language_">super</span>(config);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getData</span>(config.<span class="hljs-property">data</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span> = config.<span class="hljs-property">map</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">zooms</span> = config.<span class="hljs-property">zooms</span> ?? [<span class="hljs-number">10</span>, <span class="hljs-number">22</span>];
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_zIndex</span> = config.<span class="hljs-property">zIndex</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = config.<span class="hljs-property">id</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">init</span>();
    }

    <span class="hljs-comment">/**
     * 处理具体的图层显示逻辑
     * <span class="hljs-doctag">@param</span> <span class="hljs-variable">val</span>
     */</span>
    <span class="hljs-title function_">_handleVisible</span>(<span class="hljs-params">val</span>) {
        <span class="hljs-keyword">const</span> {layer} = <span class="hljs-variable language_">this</span>;
        <span class="hljs-keyword">const</span> fn = val ? <span class="hljs-string">'show'</span> : <span class="hljs-string">'hide'</span>;
        <span class="hljs-keyword">if</span>(layer){        
            layer[fn]()
        }
    }

    <span class="hljs-comment">// 整理数据</span>
    <span class="hljs-title function_">getData</span>(<span class="hljs-params">geoJSON</span>) {
        <span class="hljs-keyword">const</span> arr  = []
        <span class="hljs-keyword">const</span> {iconMap} = <span class="hljs-variable language_">this</span>

        geoJSON.<span class="hljs-property">features</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>{
            <span class="hljs-keyword">const</span> {geometry, properties} = item
            <span class="hljs-keyword">const</span> {crop} = properties
            <span class="hljs-keyword">const</span> match = iconMap[crop]
            <span class="hljs-keyword">const</span> [lng, lat] =  geometry.<span class="hljs-property">coordinates</span>

            <span class="hljs-keyword">if</span>(match){            
                arr.<span class="hljs-title function_">push</span>({
                    <span class="hljs-attr">lnglat</span>:  [lng, lat, <span class="hljs-number">50</span>],
                    crop,
                    <span class="hljs-attr">style</span>: match.<span class="hljs-property">style</span>
                })
            }
        })
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = arr
    }

    <span class="hljs-keyword">async</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> {data, map, iconMap, zooms, _zIndex} = <span class="hljs-variable language_">this</span>;
        <span class="hljs-keyword">const</span> style = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">iconMap</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">key</span>=&gt;</span>{
            <span class="hljs-keyword">const</span> {icon, style} = iconMap[key]
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">url</span>: <span class="hljs-string">`./static/icons/<span class="hljs-subst">${icon}</span>`</span>,
                <span class="hljs-attr">size</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMap</span>.<span class="hljs-title class_">Size</span>(<span class="hljs-number">30</span>,<span class="hljs-number">30</span>),
                <span class="hljs-attr">name</span>: key
            }
        })
        <span class="hljs-keyword">const</span> layer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMap</span>.<span class="hljs-title class_">MassMarks</span>(data, {
            <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">zIndex</span>: _zIndex,
            <span class="hljs-attr">cursor</span>: <span class="hljs-string">'pointer'</span>,
            style,
            zooms
        });
        layer.<span class="hljs-title function_">setMap</span>(map)
        layer.<span class="hljs-title function_">on</span>(<span class="hljs-string">'mouseover'</span>,  <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-string">'mouseover'</span>, e)
        });

        <span class="hljs-variable language_">this</span>.<span class="hljs-property">layer</span> = layer
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">visible</span> = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">//...</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CropLayer</span>;
</code></pre>
</li>
<li>
<p>这样一来就可以轻松调用了，直接将农田和鱼塘数据合并使用一个图层展示</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initCropLayer</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> map = <span class="hljs-title function_">getMap</span>()
  <span class="hljs-keyword">const</span> data1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchMockData</span>(<span class="hljs-string">'crop.geojson'</span>)
  <span class="hljs-keyword">const</span> data2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchMockData</span>(<span class="hljs-string">'poolCenter.geojson'</span>)
  data1.<span class="hljs-property">features</span> = data1.<span class="hljs-property">features</span>.<span class="hljs-title function_">concat</span>(data2.<span class="hljs-property">features</span>)

  <span class="hljs-keyword">const</span> layer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CropLayer</span>({
    <span class="hljs-attr">id</span>: <span class="hljs-string">'cropLayer'</span>,
    <span class="hljs-attr">data</span>: data1,
    <span class="hljs-attr">zooms</span>: [<span class="hljs-number">16</span>, <span class="hljs-number">22</span>],
    <span class="hljs-attr">zIndex</span>: <span class="hljs-number">200</span>,
    map
  })

  <span class="hljs-comment">// 鼠标悬浮时弹出信息浮层</span>
  layer.<span class="hljs-title function_">on</span>(<span class="hljs-string">'mouseover'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { crop, style } = e.<span class="hljs-property">data</span>
    normalMarker.<span class="hljs-title function_">setPosition</span>(e.<span class="hljs-property">data</span>.<span class="hljs-property">lnglat</span>);
    normalMarker.<span class="hljs-title function_">setOffset</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AMap</span>.<span class="hljs-title class_">Pixel</span>(<span class="hljs-number">90</span>, -<span class="hljs-number">10</span>))

    <span class="hljs-keyword">let</span> content = <span class="hljs-string">''</span>
    <span class="hljs-keyword">if</span> (style &lt;= <span class="hljs-number">4</span>) {
      <span class="hljs-comment">//农作物</span>
      content = <span class="hljs-string">`&lt;div class="amap-info-window"&gt;
        &lt;p&gt;作物: <span class="hljs-subst">${crop}</span>&lt;/p&gt;
        &lt;p&gt;识别匹配度: <span class="hljs-subst">${<span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">20</span>) + <span class="hljs-number">80</span>}</span>%&lt;/p&gt;
        &lt;p&gt;产量预计: <span class="hljs-subst">${<span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">30</span>) + <span class="hljs-number">20</span>}</span>吨&lt;/p&gt;
      &lt;/div&gt;`</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">//水产品</span>
      content = <span class="hljs-string">`&lt;div class="amap-info-window"&gt;
        &lt;p&gt;作物: <span class="hljs-subst">${crop}</span>&lt;/p&gt;
        &lt;p&gt;产量预计: <span class="hljs-subst">${<span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">20</span>) + <span class="hljs-number">10</span>}</span>吨&lt;/p&gt;
      &lt;/div&gt;`</span>
    }

    normalMarker.<span class="hljs-title function_">setContent</span>(content)
    normalMarker.<span class="hljs-title function_">setMap</span>(map)
  })
  layer.<span class="hljs-title function_">on</span>(<span class="hljs-string">'mouseout'</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    map.<span class="hljs-title function_">remove</span>(normalMarker);
  })
  <span class="hljs-comment">// 放入图层管理器</span>
  layerManger.<span class="hljs-title function_">add</span>(layer)
}
</code></pre>
</li>
<li>
<p>最终效果如下</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/38fe37f68c324ab39d5a282ac49b22c1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=XhRBY9%2BSyVR3mioHi3jVcSIcVu8%3D" alt="Honeycam_2024-10-27_11-31-59.gif" loading="lazy"></p>
</li>
</ol>
<h3 data-id="heading-19">4.6 区域边界</h3>
<ol>
<li>
<p>区域边界的数据绘制很简单，就是一个常规的封闭线图形polyline。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ff750c5442984f45b2caa135b81dc0de~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=QCCBqDnFiFnAdShk1TltCJKrFZU%3D" alt="image 8.png" loading="lazy"></p>
</li>
<li>
<p>我使用之前开发的<a href="http://juejin.cn/post/7119765471083266056" target="_blank" title="http://juejin.cn/post/7119765471083266056">GlLayer.BorderLayer</a>进行实例化渲染，方便定制各种动画。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initBorderLayer</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> map = <span class="hljs-title function_">getMap</span>()
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchMockData</span>(<span class="hljs-string">'border.geojson'</span>)

  <span class="hljs-keyword">const</span> layer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlLayer</span>.<span class="hljs-title class_">BorderLayer</span>({
    <span class="hljs-attr">id</span>: <span class="hljs-string">'borderLayer'</span>,
    <span class="hljs-attr">alone</span>: <span class="hljs-variable constant_">SETTING</span>.<span class="hljs-property">alone</span>,
    map,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'#3dfcfc'</span>, <span class="hljs-comment">// 墙体颜色</span>
    <span class="hljs-attr">wallHeight</span>: <span class="hljs-number">100</span>, <span class="hljs-comment">// 墙体高度</span>
    data,
    <span class="hljs-attr">speed</span>: <span class="hljs-number">0.3</span>,
    <span class="hljs-attr">animate</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">zooms</span>: [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>],
    <span class="hljs-attr">altitude</span>: <span class="hljs-number">0</span>
  })

  layerManger.<span class="hljs-title function_">add</span>(layer)
}
</code></pre>
</li>
<li>
<p>区域入侵监控这部分操作正常来说是由物联网设备检测到，推送消息给服务端，再由服务端推送给前端一条消息。为方便演示我直接在前端模拟了，定时检测指定目标位置，如果在polygon内部，则区域边界图层出现告警状态，整体变为红色；目标离开，则解除告警状态。为此新增了setColor方法用于切换颜色状态。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">/**
 * 设置区域边界颜色
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} newColor 颜色值，比如'#ffffff'
 */</span>
<span class="hljs-title function_">setColor</span>(<span class="hljs-params">newColor</span>){
  <span class="hljs-comment">// 创建新纹理</span>
  <span class="hljs-keyword">const</span> newTexture = <span class="hljs-variable language_">this</span>.<span class="hljs-property">generateTexture</span> (<span class="hljs-number">128</span>, newColor) 
  newTexture.<span class="hljs-property">wrapS</span> = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">RepeatWrapping</span> <span class="hljs-comment">// 水平重复平铺</span>
  newTexture.<span class="hljs-property">wrapT</span> = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">RepeatWrapping</span> <span class="hljs-comment">// 垂直重复平铺</span>

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_color</span> = newColor
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_texture_offset</span> = <span class="hljs-number">0</span>

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">mainMesh</span>.<span class="hljs-property">material</span>.<span class="hljs-property">color</span> = newColor

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">animateMesh</span>.<span class="hljs-property">material</span>.<span class="hljs-property">map</span> = newTexture
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_texture</span> = newTexture
}
<span class="hljs-comment">// 创建材质</span>
generateTexture (size = <span class="hljs-number">64</span>, color = <span class="hljs-string">'#ff0000'</span>) {
  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'canvas'</span>)
  canvas.<span class="hljs-property">width</span> = size
  canvas.<span class="hljs-property">height</span> = size
  <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">'2d'</span>)
  <span class="hljs-keyword">const</span> linearGradient = ctx.<span class="hljs-title function_">createLinearGradient</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, size)
  linearGradient.<span class="hljs-title function_">addColorStop</span>(<span class="hljs-number">0.2</span>, <span class="hljs-title function_">hexToRgba</span>(color, <span class="hljs-number">0.0</span>))
  linearGradient.<span class="hljs-title function_">addColorStop</span>(<span class="hljs-number">0.8</span>, <span class="hljs-title function_">hexToRgba</span>(color, <span class="hljs-number">0.5</span>))
  linearGradient.<span class="hljs-title function_">addColorStop</span>(<span class="hljs-number">1.0</span>, <span class="hljs-title function_">hexToRgba</span>(color, <span class="hljs-number">1.0</span>))
  ctx.<span class="hljs-property">fillStyle</span> = linearGradient
  ctx.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, size, size)

  <span class="hljs-keyword">const</span> texture = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Texture</span>(canvas)
  texture.<span class="hljs-property">needsUpdate</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">// 必须</span>
  <span class="hljs-keyword">return</span> texture
}

</code></pre>
</li>
<li>
<p>模拟边界入侵检测，我们可以使用<a href="https://link.juejin.cn?target=https%3A%2F%2Flbs.amap.com%2Fapi%2Fjavascript-api-v2%2Fdocumentation%23geometryutil" target="_blank" title="https://lbs.amap.com/api/javascript-api-v2/documentation#geometryutil" ref="nofollow noopener noreferrer">AMap.GeometryUtils</a>提供的几何计算方法，判断点是否在多边形内，是的话则改变边界状态为告警，否则移除告警。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 是否进入入侵检测模式</span>
<span class="hljs-keyword">let</span> isInvadeMode = <span class="hljs-literal">false</span>
<span class="hljs-comment">// 定时器</span>
<span class="hljs-keyword">let</span> invadeClock = <span class="hljs-literal">null</span>
<span class="hljs-comment">// 入侵者标记</span>
<span class="hljs-keyword">let</span> invadeMarker

<span class="hljs-comment">/**
 * 切换入侵检测模式
 */</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">toggleInvade</span>(<span class="hljs-params"></span>) {

  <span class="hljs-keyword">const</span> map = <span class="hljs-title function_">getMap</span>()
  <span class="hljs-keyword">const</span> borderLayer = layerManger.<span class="hljs-title function_">findLayerById</span>(<span class="hljs-string">'borderLayer'</span>)  

  isInvadeMode = !isInvadeMode

  <span class="hljs-comment">// 入侵检测范围</span>
  <span class="hljs-keyword">let</span> ring = []
  <span class="hljs-comment">// 入侵者路径</span>
  <span class="hljs-keyword">let</span> invadePath

  <span class="hljs-comment">// 当前步数</span>
  <span class="hljs-keyword">let</span> invadeStep = <span class="hljs-number">0</span>
  
  <span class="hljs-keyword">if</span> (isInvadeMode) { 
    <span class="hljs-keyword">const</span> borderPath =  <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchMockData</span>(<span class="hljs-string">'border.geojson'</span>)
    ring = borderPath.<span class="hljs-property">features</span>[<span class="hljs-number">0</span>].<span class="hljs-property">geometry</span>.<span class="hljs-property">coordinates</span>[<span class="hljs-number">0</span>]
    <span class="hljs-title function_">initInvade</span>()

    invadeClock = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 更新目标位置</span>
      <span class="hljs-keyword">const</span> pos = invadePath[invadeStep]
      invadeStep = (invadeStep + <span class="hljs-number">1</span>) % invadePath.<span class="hljs-property">length</span>
      invadeMarker.<span class="hljs-title function_">setPosition</span>(pos)
      
      <span class="hljs-comment">// 判断为入侵，边界墙修改颜色</span>
      <span class="hljs-keyword">const</span> color = <span class="hljs-title function_">isInRing</span>(pos, ring) ? <span class="hljs-string">'#ff0000'</span> : <span class="hljs-string">'#3dfcfc'</span>
      <span class="hljs-keyword">if</span>(borderLayer.<span class="hljs-property">_color</span> !== color){
        borderLayer.<span class="hljs-title function_">setColor</span>(color)
      }
    }, <span class="hljs-number">1000</span>)

  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">clearInvade</span>()
    borderLayer.<span class="hljs-title function_">setColor</span>(<span class="hljs-string">'#3dfcfc'</span>)
  }

  <span class="hljs-comment">// 创建</span>
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initInvade</span>(<span class="hljs-params"></span>){
    <span class="hljs-comment">// 路径</span>
    <span class="hljs-keyword">const</span> {features} = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchMockData</span>(<span class="hljs-string">'invade-path.geojson'</span>)
    invadePath = features[<span class="hljs-number">0</span>].<span class="hljs-property">geometry</span>.<span class="hljs-property">coordinates</span>[<span class="hljs-number">0</span>]
    <span class="hljs-comment">// 目标</span>
    invadeMarker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMap</span>.<span class="hljs-title class_">Marker</span>({
      <span class="hljs-attr">content</span>: <span class="hljs-string">`&lt;img style="width:30px;" src="./static/icons/ico-invade.png"&gt;`</span>,
      <span class="hljs-attr">anchor</span>: <span class="hljs-string">'bottom-center'</span>,
      <span class="hljs-attr">offset</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMap</span>.<span class="hljs-title class_">Pixel</span>(-<span class="hljs-number">15</span>, -<span class="hljs-number">20</span>)
    })
    map.<span class="hljs-title function_">add</span>(invadeMarker)   
  }

  <span class="hljs-comment">// 销毁</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">clearInvade</span>(<span class="hljs-params"></span>){
    <span class="hljs-built_in">clearInterval</span>(invadeClock)
    invadeClock = <span class="hljs-literal">null</span>
    
    map.<span class="hljs-title function_">remove</span>(invadeMarker)
    invadeMarker = <span class="hljs-literal">null</span>  
  }

  <span class="hljs-comment">// 检测是否在范围内</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isInRing</span> (pos, ring){
    <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">AMap</span>.<span class="hljs-property">GeometryUtil</span>.<span class="hljs-title function_">isPointInRing</span>(pos, ring)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'is in ring '</span>, res)
    <span class="hljs-keyword">return</span> res
  }
}
</code></pre>
</li>
<li>
<p>最终效果如下</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d772adc6245a42d5ae286e7f70a05f1c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=7Q9Ylh%2BycJaOuD9Omw1JXivEjw0%3D" alt="Honeycam_2024-10-28_14-59-17.gif" loading="lazy"></p>
</li>
</ol>
<h3 data-id="heading-20">4.7 无人机巡查功能</h3>
<p>最近“低空经济”这个概念很火，说的是是以各种有人驾驶和无人驾驶航空器的各类低空飞行活动为牵引，辐射带动相关领域融合发展的综合性经济形态，既然如此怎么能少得了无人机的出场。在本文中我们实现的是单架无人机模型沿着指定的闭合轨迹飞行移动，并且可以用无人机的第三人称视角俯瞰地图。</p>
<ol>
<li>
<p>关于自动巡航的功能在之前做无人车巡航的时候已经实现过了，这里再讲解一下核心代码，其实就是在Tween更新函数中，按照既定的路径轨迹不断调整NPC的位置和朝向，如果需要第三人称视角，则同步更新相机的朝向即可，更详细的步骤可以看<a href="https://juejin.cn/post/7238439667137593403" target="_blank" title="https://juejin.cn/post/7238439667137593403">在高德地图实现自动巡航</a></p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 创建移动目标NPC 和 移动控制器</span>
<span class="hljs-comment">// NPC 是外部加载的gltf模型</span>
onReady () {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_conf</span>.<span class="hljs-property">NPC</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initNPC</span>()
  }
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initController</span>()
}

<span class="hljs-comment">/**
 * 初始化主体NPC的状态
 * <span class="hljs-doctag">@private</span>
 */</span>
initNPC () {
  <span class="hljs-keyword">const</span> { _PATH_COORDS, scene } = <span class="hljs-variable language_">this</span>
  <span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">NPC</span> } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_conf</span>

  <span class="hljs-comment">// z轴朝上</span>
  <span class="hljs-variable constant_">NPC</span>.<span class="hljs-property">up</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)

  <span class="hljs-comment">// 初始位置和朝向</span>
  <span class="hljs-keyword">if</span> (_PATH_COORDS.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) {
    <span class="hljs-variable constant_">NPC</span>.<span class="hljs-property">position</span>.<span class="hljs-title function_">copy</span>(_PATH_COORDS[<span class="hljs-number">0</span>])
    <span class="hljs-variable constant_">NPC</span>.<span class="hljs-title function_">lookAt</span>(_PATH_COORDS[<span class="hljs-number">1</span>])
  }

  <span class="hljs-comment">// 添加到场景中</span>
  scene.<span class="hljs-title function_">add</span>(<span class="hljs-variable constant_">NPC</span>)
}

<span class="hljs-comment">/**
 * 创建移动控制器
 * <span class="hljs-doctag">@private</span>
 */</span>
initController () {
  <span class="hljs-comment">// 状态记录器</span>
  <span class="hljs-keyword">const</span> target = { <span class="hljs-attr">t</span>: <span class="hljs-number">0</span> }
  <span class="hljs-comment">// 获取第一段线段的移动时长</span>
  <span class="hljs-keyword">const</span> duration = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getMoveDuration</span>()
  <span class="hljs-comment">// 路线数据</span>
  <span class="hljs-keyword">const</span> { _PATH_COORDS, _PATH_LNG_LAT, map } = <span class="hljs-variable language_">this</span>

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_rayController</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">TWEEN</span>.<span class="hljs-title class_">Tween</span>(target)
    .<span class="hljs-title function_">to</span>({ <span class="hljs-attr">t</span>: <span class="hljs-number">1</span> }, duration)
    .<span class="hljs-title function_">easing</span>(<span class="hljs-variable constant_">TWEEN</span>.<span class="hljs-property">Easing</span>.<span class="hljs-property">Linear</span>.<span class="hljs-property">None</span>)
    .<span class="hljs-title function_">onUpdate</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">NPC</span>, cameraFollow } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_conf</span>
      <span class="hljs-comment">// 终点坐标索引</span>
      <span class="hljs-keyword">const</span> nextIndex = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getNextStepIndex</span>()
      <span class="hljs-comment">// 获取当前位置在路径上的位置</span>
      <span class="hljs-keyword">const</span> point = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">copy</span>(_PATH_COORDS[<span class="hljs-variable language_">this</span>.<span class="hljs-property">npc_step</span>])
      <span class="hljs-comment">// 计算下一个路径点的位置</span>
      <span class="hljs-keyword">const</span> nextPoint = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">copy</span>(_PATH_COORDS[nextIndex])
      <span class="hljs-comment">// 计算物体应该移动到的位置，并移动物体</span>
      <span class="hljs-keyword">const</span> position = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">copy</span>(point).<span class="hljs-title function_">lerp</span>(nextPoint, target.<span class="hljs-property">t</span>)
      <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">NPC</span>) {
        <span class="hljs-comment">// 更新NPC的位置</span>
        <span class="hljs-variable constant_">NPC</span>.<span class="hljs-property">position</span>.<span class="hljs-title function_">copy</span>(position)
      }

      <span class="hljs-comment">// 需要镜头跟随</span>
      <span class="hljs-keyword">if</span> (cameraFollow) {
        <span class="hljs-comment">// 计算两个lngLat端点的中间值</span>
        <span class="hljs-keyword">const</span> pointLngLat = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">copy</span>(_PATH_LNG_LAT[<span class="hljs-variable language_">this</span>.<span class="hljs-property">npc_step</span>])
        <span class="hljs-keyword">const</span> nextPointLngLat = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">copy</span>(_PATH_LNG_LAT[nextIndex])
        <span class="hljs-keyword">const</span> positionLngLat = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>().<span class="hljs-title function_">copy</span>(pointLngLat).<span class="hljs-title function_">lerp</span>(nextPointLngLat, target.<span class="hljs-property">t</span>)
        <span class="hljs-comment">// 更新地图镜头位置</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateMapCenter</span>(positionLngLat)
      }

      <span class="hljs-comment">// 更新地图朝向</span>
      <span class="hljs-keyword">if</span> (cameraFollow) {
        <span class="hljs-keyword">const</span> angle = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAngle</span>(position, _PATH_COORDS[(<span class="hljs-variable language_">this</span>.<span class="hljs-property">npc_step</span> + <span class="hljs-number">3</span>) % _PATH_COORDS.<span class="hljs-property">length</span>])
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateMapRotation</span>(angle)
      }
    })
    .<span class="hljs-title function_">onStart</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">NPC</span> } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_conf</span>

      <span class="hljs-comment">// 计算线段重点的位置和角度</span>
      <span class="hljs-keyword">const</span> nextPoint = _PATH_COORDS[(<span class="hljs-variable language_">this</span>.<span class="hljs-property">npc_step</span> + <span class="hljs-number">3</span>) % _PATH_COORDS.<span class="hljs-property">length</span>]

      <span class="hljs-comment">// 更新主体的正面朝向</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">NPC</span>) {
        <span class="hljs-variable constant_">NPC</span>.<span class="hljs-title function_">lookAt</span>(nextPoint)
        <span class="hljs-variable constant_">NPC</span>.<span class="hljs-property">up</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)
      }
    })
    .<span class="hljs-title function_">onComplete</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 更新到下一段路线</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">npc_step</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getNextStepIndex</span>()
      <span class="hljs-comment">// 调整时长</span>
      <span class="hljs-keyword">const</span> duration = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getMoveDuration</span>()
      <span class="hljs-comment">// 重新出发</span>
      target.<span class="hljs-property">t</span> = <span class="hljs-number">0</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_rayController</span>
        .<span class="hljs-title function_">stop</span>()
        .<span class="hljs-title function_">to</span>({ <span class="hljs-attr">t</span>: <span class="hljs-number">1</span> }, duration)
        .<span class="hljs-title function_">start</span>()
    })
    .<span class="hljs-title function_">start</span>()
}

</code></pre>
</li>
<li>
<p>实例化GlLayer.DrivinLayer图层，我们将无人机巡航和飞行轨迹拆分为两个图层实现</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initDroneLayer</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> map = <span class="hljs-title function_">getMap</span>()
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchMockData</span>(<span class="hljs-string">'dronWander2.geojson'</span>)
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NPC</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getDroneModel</span>()

  <span class="hljs-comment">// 巡航图层</span>
  <span class="hljs-keyword">const</span> layer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DrivingLayer</span>({
    <span class="hljs-attr">id</span>: <span class="hljs-string">'dronLayer'</span>,
    map,
    <span class="hljs-attr">zooms</span>: [<span class="hljs-number">4</span>, <span class="hljs-number">30</span>],
    <span class="hljs-attr">path</span>: data,
    <span class="hljs-attr">altitude</span>: <span class="hljs-number">50</span>,
    <span class="hljs-attr">speed</span>: <span class="hljs-number">50.0</span>,
    <span class="hljs-variable constant_">NPC</span>,
    <span class="hljs-attr">interact</span>: <span class="hljs-literal">true</span>
  })
  layer.<span class="hljs-title function_">on</span>(<span class="hljs-string">'complete'</span>, <span class="hljs-function">(<span class="hljs-params">{ scene }</span>) =&gt;</span> {
    <span class="hljs-comment">// 调整模型的亮度</span>
    <span class="hljs-keyword">const</span> aLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AmbientLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">3.5</span>)
    scene.<span class="hljs-title function_">add</span>(aLight)

    layer.<span class="hljs-title function_">resume</span>()
  })
  layerManger.<span class="hljs-title function_">add</span>(layer)

  <span class="hljs-comment">// 路径轨迹动画图层</span>
  <span class="hljs-keyword">const</span> dronPathLayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowlineLayer</span>({
    <span class="hljs-attr">id</span>: <span class="hljs-string">'dronPathLayer'</span>,
    map,
    <span class="hljs-attr">zooms</span>: [<span class="hljs-number">16</span>, <span class="hljs-number">22</span>],
    data,
    <span class="hljs-attr">speed</span>: <span class="hljs-number">0.5</span>,
    <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">10</span>,
    <span class="hljs-attr">altitude</span>: <span class="hljs-number">50</span>
  })
  layerManger.<span class="hljs-title function_">add</span>(dronPathLayer)
}
</code></pre>
</li>
<li>
<p>本实例最大的难度在于如何让无人机在飞行的时候4个螺旋桨旋转摆动，这里最后选择了在逐帧函数更新gltf自带动画的方法；关于gltf动画如何制作，在后面有单独章节。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 加载无人机</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getDroneModel</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {

    <span class="hljs-keyword">const</span> loader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GLTFLoader</span>()
    loader.<span class="hljs-title function_">load</span>(<span class="hljs-string">'./static/model/drone/drone1.glb'</span>, <span class="hljs-function">(<span class="hljs-params">gltf</span>) =&gt;</span> {
      <span class="hljs-comment">// 调整模型尺寸</span>
      <span class="hljs-keyword">const</span> model = gltf.<span class="hljs-property">scene</span>.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>]
      <span class="hljs-keyword">const</span> size = <span class="hljs-number">10.0</span>
      model.<span class="hljs-property">scale</span>.<span class="hljs-title function_">set</span>(size, size, size)

      <span class="hljs-comment">// 播放动画</span>
      mixer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AnimationMixer</span>(gltf.<span class="hljs-property">scene</span>);
      <span class="hljs-keyword">const</span> action = mixer.<span class="hljs-title function_">clipAction</span>(gltf.<span class="hljs-property">animations</span>[<span class="hljs-number">0</span>])
      <span class="hljs-comment">// 动画播放速度</span>
      action.<span class="hljs-title function_">setEffectiveTimeScale</span>(guiCtrl.<span class="hljs-property">mixerPlaySpeed</span>);
      action.<span class="hljs-title function_">play</span>();

      <span class="hljs-title function_">resolve</span>(model)
    })

  })
}

<span class="hljs-comment">// 播放无人机动画</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">animateFn</span>(<span class="hljs-params"></span>) {
	<span class="hljs-title function_">requestAnimationFrame</span>(animateFn);
	<span class="hljs-keyword">if</span> (mixer) {
	  <span class="hljs-comment">// 更新无人机旋转动画</span>
	  mixer.<span class="hljs-title function_">update</span>(<span class="hljs-number">0.01</span>); <span class="hljs-comment">//必须加上参数才有动画    </span>
	}
}
</code></pre>
</li>
<li>
<p>最终实现效果如下，第三人称游戏的代入感出来了有没有。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/35598d5591a14fb190ae832aafce0c39~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=zCf4lYORY0t8%2BkzubFTysmzures%3D" alt="Honeycam_2024-10-23_16-03-10.gif" loading="lazy"></p>
</li>
</ol>
<h3 data-id="heading-21">4.8 灾害预测图层</h3>
<ol>
<li>
<p>该图层本质上是个3D热力图，源数据是带有权重属性的坐标点集合，我们可以在QGIS上编辑它们甚至可以查看二维效果</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f3f2f18eb38140f0a9522580c66209f6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=XdFPEdHlUJwWKJTqnRRBxJuGBxw%3D" alt="image 9.png" loading="lazy"></p>
</li>
<li>
<p>导出数据，使用高德自带的可视化图层Loca.Heatmap实现</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">/**
 * 灾害风险检测图层
 */</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initRiskLayer</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> map = <span class="hljs-title function_">getMap</span>()
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchMockData</span>(<span class="hljs-string">'fertility.geojson'</span>)
  <span class="hljs-keyword">const</span> geo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Loca</span>.<span class="hljs-title class_">GeoJSONSource</span>({ data })

  <span class="hljs-keyword">const</span> heatmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Loca</span>.<span class="hljs-title class_">HeatMapLayer</span>({
    <span class="hljs-attr">zIndex</span>: <span class="hljs-number">10</span>,
    <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">visible</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">zooms</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">22</span>],
  });

  heatmap.<span class="hljs-title function_">setSource</span>(geo, {
    <span class="hljs-attr">id</span>: <span class="hljs-string">'riskLayer'</span>,
    <span class="hljs-attr">radius</span>: <span class="hljs-number">150</span>,
    <span class="hljs-attr">unit</span>: <span class="hljs-string">'meter'</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-number">300</span>,
    <span class="hljs-attr">gradient</span>: {
      <span class="hljs-number">1</span>: <span class="hljs-string">'#FF4C2F'</span>,
      <span class="hljs-number">0.8</span>: <span class="hljs-string">'#FAA53F'</span>,
      <span class="hljs-number">0.6</span>: <span class="hljs-string">'#FFF100'</span>,
      <span class="hljs-number">0.5</span>: <span class="hljs-string">'#7DF675'</span>,
      <span class="hljs-number">0.4</span>: <span class="hljs-string">'#5CE182'</span>,
      <span class="hljs-number">0.2</span>: <span class="hljs-string">'#29CF6F'</span>,
    },
    <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">index, feature</span>) {
      <span class="hljs-keyword">return</span> feature.<span class="hljs-property">properties</span>.<span class="hljs-property">weight</span> ?? <span class="hljs-number">0</span>;
    },
    <span class="hljs-attr">min</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">max</span>: <span class="hljs-number">100</span>,
    <span class="hljs-attr">visible</span>: <span class="hljs-literal">true</span>
  });
  loca.<span class="hljs-title function_">add</span>(heatmap);

  map.<span class="hljs-title function_">on</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) {
    <span class="hljs-keyword">const</span> feat = heatmap.<span class="hljs-title function_">queryFeature</span>(e.<span class="hljs-property">pixel</span>.<span class="hljs-title function_">toArray</span>());
    <span class="hljs-comment">// 展示更多信息...</span>
  });

  heatmap.<span class="hljs-property">id</span> = <span class="hljs-string">'riskLayer'</span>
  layerManger.<span class="hljs-title function_">add</span>(heatmap)
}

</code></pre>
</li>
<li>
<p>在切换图层为显示状态时，可以加上动画以达到更好的视觉效果</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 给图层的显示增加动画效果</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">animateLayer</span>(<span class="hljs-params">layer</span>){
  <span class="hljs-keyword">switch</span>(layer.<span class="hljs-property">id</span>){
    <span class="hljs-keyword">case</span> <span class="hljs-string">'riskLayer'</span>: 
      layer.<span class="hljs-title function_">addAnimate</span>({
        <span class="hljs-attr">key</span>: <span class="hljs-string">'height'</span>,
        <span class="hljs-attr">value</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
        <span class="hljs-attr">duration</span>: <span class="hljs-number">2000</span>,
        <span class="hljs-attr">easing</span>: <span class="hljs-string">'BackOut'</span>,
      });
      layer.<span class="hljs-title function_">addAnimate</span>({
        <span class="hljs-attr">key</span>: <span class="hljs-string">'radius'</span>,
        <span class="hljs-attr">value</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
        <span class="hljs-attr">duration</span>: <span class="hljs-number">2000</span>,
        <span class="hljs-attr">easing</span>: <span class="hljs-string">'BackOut'</span>,
        <span class="hljs-attr">transform</span>: <span class="hljs-number">1000</span>,
        <span class="hljs-attr">random</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">delay</span>: <span class="hljs-number">5000</span>,
      });    
    <span class="hljs-keyword">break</span>;      
    <span class="hljs-comment">//...</span>
}
</code></pre>
</li>
<li>
<p>最终效果如下，产量AI预测图层的实现方法类似就不赘述</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3b6d5cb64cf84b0ba9b6df2e6cc51e94~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=5Wbyb92dGIyCR6q0o3BFU0aHZNo%3D" alt="Honeycam_2024-10-28_09-35-25.gif" loading="lazy"></p>
</li>
</ol>
<h3 data-id="heading-22">4.9 使用图层管理器操作图层</h3>
<p>本示例涉及到图层数量已经有十几个，为方便进行图层的统一操作（比如在专题A哪些图层需要显示，其他图层隐藏；或者调用图层的某个功能），我们需要图层管理器layerManager，且给图层赋予唯一的id值便于在管理器中获取。</p>
<p>如下面代码所示，提供最基础的添加、查找、清除功能</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">/**
 * 图层管理器
 * <span class="hljs-doctag">@extends</span> <span class="hljs-variable">null</span>
 * <span class="hljs-doctag">@author</span> Zhanglinhai &lt;gyrate.sky<span class="hljs-doctag">@qq</span>.com&gt;
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> {
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@description</span> 创建一个实例
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">conf</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Array</span>} conf.data 图层数组 [layer,...] 默认为[]
   */</span>
  <span class="hljs-title function_">constructor</span> (config = {}) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_list</span> = config.<span class="hljs-property">data</span> || []
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@description</span> 添加1个图层到管理器
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} id 图层id
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} title 图层名称
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">*</span>} layer 图层实例
   */</span>
  add (layer) {
    <span class="hljs-keyword">if</span> (layer === <span class="hljs-literal">undefined</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'缺少图层实例'</span>)
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">if</span> (layer.<span class="hljs-property">id</span> === <span class="hljs-literal">undefined</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'缺少图层id'</span>)
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">const</span> { id } = layer
    <span class="hljs-keyword">const</span> match = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">findLayerById</span>(id)

    <span class="hljs-keyword">if</span> (match) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`图层的id <span class="hljs-subst">${id}</span> 不是唯一标识，请更换`</span>)
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_list</span>.<span class="hljs-title function_">push</span>(layer)
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@description</span> 通过id查找图层信息
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} id 图层id
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">*</span>} 返回匹配的第一个图层
   */</span>
  findLayerById (id) {
    <span class="hljs-keyword">const</span> match = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_list</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === id)
    <span class="hljs-keyword">return</span> match
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@description</span> 清空当前的图层管理器
   */</span>
  clear () {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_list</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">layer</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (layer.<span class="hljs-property">destroy</span>) {
        layer.<span class="hljs-title function_">destroy</span>()
      }
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`销毁layer <span class="hljs-subst">${layer.id}</span>`</span>)
    })
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_list</span> = []
  }
}

</code></pre>
<p>这样一来就方便我们快捷操作图层，将整个地图作为可视化大屏的主体，放置到带有导航和图表的低代码大屏框架中，就完成了初步的搭建工作。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/96b5485f99774a4d815ac43a09954ffe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=8QuQTM0MRJ3CUJNrQTfSq%2BaQGSk%3D" alt="Honeycam_2024-10-25_11-57-58.gif" loading="lazy"></p>
<h2 data-id="heading-23">5. 其他问题解决方案</h2>
<h3 data-id="heading-24">5.1 如何在场景中产生投影</h3>
<p>如何在高德地图的底图上添加模型的投影，我被困扰了一段时间，后来请教了高德的技术大佬WT才得到启发解开了这个问题，感谢wt大佬的支持。three.js提供了一种阴影材(ShadowMaterial)此材质可以接收阴影，但在其他方面完全透明。</p>
<p>要想在场景中获得投影，需要下面几个步骤都齐全</p>
<ol>
<li>
<p>渲染器打开投影</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 禁用自动清理，以保持地图底图可见</span>
renderer.<span class="hljs-property">autoClear</span> = <span class="hljs-literal">false</span>;
renderer.<span class="hljs-property">shadowMap</span>.<span class="hljs-property">enabled</span> = <span class="hljs-literal">true</span>;
renderer.<span class="hljs-property">shadowMap</span>.<span class="hljs-property">type</span> = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">PCFSoftShadowMap</span>;
<span class="hljs-comment">// 重要：会影响到画布尺寸</span>
renderer.<span class="hljs-title function_">setSize</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>);
</code></pre>
</li>
<li>
<p>创建合适的平行光源，有各种参数需要设置</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 创建平行光</span>
<span class="hljs-keyword">var</span> dLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">DirectionalLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">3</span>);
dLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(lightPositionX, lightPositionY, lightPositionZ);
dLight.<span class="hljs-property">castShadow</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 开启阴影投射</span>
dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">mapSize</span>.<span class="hljs-property">width</span> = mapSize; <span class="hljs-comment">// 增加阴影分辨率</span>
dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">mapSize</span>.<span class="hljs-property">height</span> = mapSize;
dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">near</span> = cameraNear;
dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">far</span> = caremaFar;
dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">left</span> = cameraLeft;
dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">right</span> = cameraRight;
dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">top</span> = cameraTop;
dLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">bottom</span> = cameraBottom;
scene.<span class="hljs-title function_">add</span>(dLight);
</code></pre>
</li>
<li>
<p>各种关联物体也必须将属性castShadow 、receiveShadow设置为true</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 创建几何体</span>
<span class="hljs-keyword">var</span> geo = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-property">length</span>; i++) {
  <span class="hljs-keyword">const</span> d = data[i];
  <span class="hljs-keyword">var</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geo, mat);
  mesh.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(d[<span class="hljs-number">0</span>], d[<span class="hljs-number">1</span>], <span class="hljs-number">500</span>);
  mesh.<span class="hljs-property">castShadow</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 启用阴影投射!</span>
  mesh.<span class="hljs-property">receiveShadow</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 接收阴影!</span>
  <span class="hljs-comment">//...</span>
}
</code></pre>
</li>
<li>
<p>给底部平面赋予shadowMaterial材质</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 创建接收阴影的平面</span>
<span class="hljs-keyword">var</span> planeGeo = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneGeometry</span>(<span class="hljs-number">50000</span>, <span class="hljs-number">50000</span>);
<span class="hljs-keyword">var</span> shadowMat = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">ShadowMaterial</span>({
  <span class="hljs-attr">opacity</span>: planeMaterialOpacity,
});

plane = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(planeGeo, shadowMat);
plane.<span class="hljs-property">receiveShadow</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 接收阴影!</span>
scene.<span class="hljs-title function_">add</span>(plane);
</code></pre>
</li>
<li>
<p>最终效果如下，演示代码链接<a href="https://link.juejin.cn?target=https%3A%2F%2Fjsfiddle.net%2Fgyratesky%2F7mezq06g%2F13%2F" target="_blank" title="https://jsfiddle.net/gyratesky/7mezq06g/13/" ref="nofollow noopener noreferrer">放到这里了</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ae884e531014051884652fedb75fded~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=%2FhrSIgp9T6S554mOnymfSeduHNk%3D" alt="Honeycam_2024-10-27_22-08-11.gif" loading="lazy"></p>
</li>
</ol>
<h3 data-id="heading-25">5.2 给模型制作常规动画</h3>
<ol>
<li>
<p>下载一个无人机模型FBX格式，推荐在sketchfab上找，素材齐全。打开blender，导入FBX模型，把所有部件归属到一个根节点，后续控制根节点其他部件也跟着移动</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d5c98d7e96314c14996c0d6a4d478dfe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=Uox%2FN7htMCaeIDjP0IQRwbfb7Ns%3D" alt="image 10.png" loading="lazy"></p>
</li>
<li>
<p>在动画时间轴给每个部件加上动画关键帧，调试好动画</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c13b1a2a338e461e82325a9ffdd52a93~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=14APqbBSHyu05Bi9JttXbtzt%2BYo%3D" alt="image 11.png" loading="lazy"></p>
</li>
<li>
<p>补间动画默认是缓入缓出的，可以同个左上角切换面板到曲线编辑器修改补间动画线</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b3b32ec2b4b041b2a94dc092c215e64c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=6CdywgUFxZ92p8u1HQU1Vi8vXPI%3D" alt="image 12.png" loading="lazy"></p>
</li>
<li>
<p>最关键的一步。导出gltf时动画一项必须勾选，且动画模式设置为“合并的活动动作”，这样的话，导出的gltf就能把所有部件动作合并为一个动作了。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/09c34271f1d547308044310c9a6cd20d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=9PVbVD4mrDCDI48w9GUqpSJS%2BFo%3D" alt="image 13.png" loading="lazy"></p>
</li>
<li>
<p>最终预览效果，螺旋桨的旋转动画不需要做太快，因为在web端实际播放时，速度倍率是可以通过action.setEffectiveTimeScal()调节的，要多快有多块。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/85c6af51105240cc8a446537cc03f2e9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=qvmbu%2BTkBS7iUTC0%2Bjb5IGBUGmI%3D" alt="Honeycam_2024-10-22_15-56-10.gif" loading="lazy"></p>
</li>
</ol>
<h3 data-id="heading-26">5.3  图层的深度关系</h3>
<p>如何处理高德自有图层和自定义图层的深度关系，这里必须了解高德提供的CustomLayer和GLCustomLayer的区别。</p>
<p>前者是在地图实例画布Canvas1之外另外覆盖了一个Canvas标签，因此所有内容都会置于Canvas1内容之上，无论空间上是否合理；而后者则是与地图实例共享画布的，在GLCustomLayer上创建的内容能够与地图上的元素、高德可视化类创建的元素共享深度关系，因此使用GLCustomLayer会让多图层的场景视觉上更加和谐，但代价就是Map需要逐帧重绘，性能损耗更高。所以如何取舍还是要看具体的业务场景进行选择。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c12afb4e5057470db12b7f77aa667dc8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgR3lyYXRl:q75.awebp?rk3s=f64ab15b&amp;x-expires=1737677390&amp;x-signature=JzdSRwL1PnLYYwqtJvcRVRnLK1s%3D" alt="image 14.png" loading="lazy"></p>
<h2 data-id="heading-27">总结</h2>
<p>至此，使用高德地图制作数字农业可视化大屏的分享就告一段落了。事实上这并不是一个最终成本，因为我还有很多想法没有落实， 比如精细化农业大棚的搭建，无人机实时视频投影、火灾预测等等功能展示；还有一些技术问题没有解决，比如cesiumlab使用FBX生成的3dtiles没有支持LOD，即不同地图缩放层级下的精细度，这在性能和视觉效果上肯定是存在优化空间的，据我所见在cityEngine阶段LOD信息还是存在的，至于具体在哪个过程中丢失了，还需要排查一下。</p>
<p>但战线拉太长的话项目可能就会永远没有阶段成果，时间关系就先发布这么多了了。说不定分享出来之后，可以起到抛砖引玉的作用，最好能捞到更多志同道合的伙伴来一起共建虚拟农场元宇宙。</p>
<h2 data-id="heading-28"><strong>本示例使用到的高德JSAPI</strong></h2>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Flbs.amap.com%2Fapi%2Fjavascript-api-v2%2Fdocumentation%23glcustomlayer" target="_blank" title="https://link.juejin.cn/?target=https%3A%2F%2Flbs.amap.com%2Fapi%2Fjavascript-api-v2%2Fdocumentation%23glcustomlayer">3D自定义图层AMap.GLCustomLayer</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Flbs.amap.com%2Fapi%2Fjavascript-api-v2%2Fdocumentation%23customlayer" target="_blank" title="https://lbs.amap.com/api/javascript-api-v2/documentation#customlayer" ref="nofollow noopener noreferrer">自定义图层AMap.CustomLayer</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Flbs.amap.com%2Fapi%2Fjavascript-api-v2%2Fdocumentation%23map" target="_blank" title="https://link.juejin.cn/?target=https%3A%2F%2Flbs.amap.com%2Fapi%2Fjavascript-api-v2%2Fdocumentation%23map">AMap.Map地图对象类</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Flbs.amap.com%2Fapi%2Fjavascript-api-v2%2Fdocumentation%23massmarks" target="_blank" title="https://lbs.amap.com/api/javascript-api-v2/documentation#massmarks" ref="nofollow noopener noreferrer">海量点类AMap.MassMarkers</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Flbs.amap.com%2Fapi%2Floca-v2%2Fapi" target="_blank" title="https://lbs.amap.com/api/loca-v2/api" ref="nofollow noopener noreferrer">LOCA 数据可视化 API 2.0</a></p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Flbs.amap.com%2Fapi%2Fjavascript-api-v2%2Fdocumentation%23geometryutil" target="_blank" title="https://link.juejin.cn/?target=https%3A%2F%2Flbs.amap.com%2Fapi%2Fjavascript-api-v2%2Fdocumentation%23geometryutil">空间数据计算的函数库 GeometryUtil</a></p>
<h2 data-id="heading-29">相关链接</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FV34_p9DRNm9TFgMDVXP-hQ" target="_blank" title="https://mp.weixin.qq.com/s/V34_p9DRNm9TFgMDVXP-hQ" ref="nofollow noopener noreferrer">数字孪生×低空经济 | 天空地一体化 城市数字孪生电子沙盘指挥系统</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Falun550%2Farticle%2Fdetails%2F107531395" target="_blank" title="https://blog.csdn.net/alun550/article/details/107531395" ref="nofollow noopener noreferrer">在cityEngine编写模型生成规则</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fthreejs.org%2Fdocs%2F%23api%2Fzh%2Fmaterials%2FShadowMaterial" target="_blank" title="https://threejs.org/docs/#api/zh/materials/ShadowMaterial" ref="nofollow noopener noreferrer">THREEJS 阴影材质的使用文档</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgyrate%2FdigitalFarm" target="_blank" title="https://github.com/gyrate/digitalFarm" ref="nofollow noopener noreferrer">源代码Github地址</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgyrate.github.io%2FdigitalFarm%2Fdist%2Findex.html%23%2Findex" target="_blank" title="https://gyrate.github.io/digitalFarm/dist/index.html#/index" ref="nofollow noopener noreferrer">演示页面地址</a></p></div></div>