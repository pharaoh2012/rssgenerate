
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ThinkerQAQ/p/18949737" title="发布于 2025-06-26 12:32">
    <span role="heading" aria-level="2">Java源码分析系列笔记-12.BlockingQueue</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-是什么" rel="noopener nofollow">1. 是什么</a></li><li><a href="#2-使用场景" rel="noopener nofollow">2. 使用场景</a></li><li><a href="#3-如何使用" rel="noopener nofollow">3. 如何使用</a></li><li><a href="#4-各种blockingqueue详解以及对比" rel="noopener nofollow">4. 各种BlockingQueue详解以及对比</a></li><li><a href="#5-arrayblockingqueue" rel="noopener nofollow">5. ArrayBlockingQueue</a><ul><li><a href="#51-是什么" rel="noopener nofollow">5.1. 是什么</a></li><li><a href="#52-如何使用" rel="noopener nofollow">5.2. 如何使用</a><ul><li><a href="#521-方法选择" rel="noopener nofollow">5.2.1. 方法选择</a></li></ul></li><li><a href="#53-原理分析" rel="noopener nofollow">5.3. 原理分析</a><ul><li><a href="#531-uml" rel="noopener nofollow">5.3.1. uml</a></li><li><a href="#532-构造方法" rel="noopener nofollow">5.3.2. 构造方法</a><ul><li><a href="#5321-底层使用数组lockcondtion实现" rel="noopener nofollow">5.3.2.1. 底层使用数组+Lock+Condtion实现</a></li></ul></li><li><a href="#533-put阻塞" rel="noopener nofollow">5.3.3. put【阻塞】</a><ul><li><a href="#5331-加锁" rel="noopener nofollow">5.3.3.1. 加锁</a></li><li><a href="#5332-如果数组已经满了那么等待" rel="noopener nofollow">5.3.3.2. 如果数组已经满了，那么等待</a></li><li><a href="#5333-没满则入队并唤醒读者" rel="noopener nofollow">5.3.3.3. 没满则入队并唤醒读者</a></li></ul></li><li><a href="#534-take阻塞" rel="noopener nofollow">5.3.4. take【阻塞】</a><ul><li><a href="#5341-加锁" rel="noopener nofollow">5.3.4.1. 加锁</a></li><li><a href="#5342-如果数组为空那么等待" rel="noopener nofollow">5.3.4.2. 如果数组为空，那么等待</a></li><li><a href="#5343-不为空则出队并唤醒写者" rel="noopener nofollow">5.3.4.3. 不为空则出队并唤醒写者</a></li></ul></li><li><a href="#535-offer返回特殊值" rel="noopener nofollow">5.3.5. offer【返回特殊值】</a></li><li><a href="#536-poll返回特殊值" rel="noopener nofollow">5.3.6. poll【返回特殊值】</a></li><li><a href="#537-add抛出异常" rel="noopener nofollow">5.3.7. add【抛出异常】</a></li><li><a href="#538-remove抛出异常" rel="noopener nofollow">5.3.8. remove【抛出异常】</a></li><li><a href="#539-element抛出异常" rel="noopener nofollow">5.3.9. element【抛出异常】</a></li><li><a href="#5310-peek返回特殊值" rel="noopener nofollow">5.3.10. peek【返回特殊值】</a></li></ul></li><li><a href="#54-总结" rel="noopener nofollow">5.4. 总结</a></li></ul></li><li><a href="#6-linkedblockingqueue" rel="noopener nofollow">6. LinkedBlockingQueue</a><ul><li><a href="#61-是什么" rel="noopener nofollow">6.1. 是什么</a></li><li><a href="#62-如何使用" rel="noopener nofollow">6.2. 如何使用</a></li><li><a href="#63-源码分析" rel="noopener nofollow">6.3. 源码分析</a><ul><li><a href="#631-构造方法" rel="noopener nofollow">6.3.1. 构造方法</a><ul><li><a href="#6311-底层使用单向链表lockcondition实现" rel="noopener nofollow">6.3.1.1. 底层使用单向链表+Lock+Condition实现</a></li><li><a href="#6312-node" rel="noopener nofollow">6.3.1.2. Node</a></li></ul></li><li><a href="#632-put阻塞" rel="noopener nofollow">6.3.2. put【阻塞】</a><ul><li><a href="#6321-加写锁" rel="noopener nofollow">6.3.2.1. 加写锁</a></li><li><a href="#6322-如果队列已满那么等待" rel="noopener nofollow">6.3.2.2. 如果队列已满那么等待</a></li><li><a href="#6323-未满则入队" rel="noopener nofollow">6.3.2.3. 未满则入队</a></li><li><a href="#6324-入队完发现队列没满那么继续唤醒写者入队" rel="noopener nofollow">6.3.2.4. 入队完发现队列没满，那么继续唤醒写者入队</a></li><li><a href="#6325-入队完解锁后发现之前队列是空的那么唤醒读者" rel="noopener nofollow">6.3.2.5. 入队完解锁后发现之前队列是空的，那么唤醒读者</a></li></ul></li><li><a href="#633-take阻塞" rel="noopener nofollow">6.3.3. take【阻塞】</a><ul><li><a href="#6331-加读锁" rel="noopener nofollow">6.3.3.1. 加读锁</a></li><li><a href="#6332-队列为空那么等待" rel="noopener nofollow">6.3.3.2. 队列为空那么等待</a></li><li><a href="#6333-未空则出队" rel="noopener nofollow">6.3.3.3. 未空则出队</a></li><li><a href="#6334-出了队发现队列没空那么继续唤醒读者" rel="noopener nofollow">6.3.3.4. 出了队发现队列没空，那么继续唤醒读者</a></li><li><a href="#6335-出了队解了锁发现之前队列是满的那么唤醒写者" rel="noopener nofollow">6.3.3.5. 出了队解了锁发现之前队列是满的，那么唤醒写者</a></li></ul></li><li><a href="#634-offer-返回特殊值" rel="noopener nofollow">6.3.4. offer 返回特殊值</a></li><li><a href="#635-poll-返回特殊值" rel="noopener nofollow">6.3.5. poll 返回特殊值</a></li><li><a href="#636-peek-返回特殊值" rel="noopener nofollow">6.3.6. peek 返回特殊值</a></li></ul></li><li><a href="#64-总结" rel="noopener nofollow">6.4. 总结</a></li></ul></li><li><a href="#7-priorityblockingqueue" rel="noopener nofollow">7. PriorityBlockingQueue</a><ul><li><a href="#71-是什么" rel="noopener nofollow">7.1. 是什么</a><ul><li><a href="#711-二叉堆" rel="noopener nofollow">7.1.1. 二叉堆</a></li></ul></li><li><a href="#72-如何使用" rel="noopener nofollow">7.2. 如何使用</a></li><li><a href="#73-原理分析" rel="noopener nofollow">7.3. 原理分析</a><ul><li><a href="#731-构造方法" rel="noopener nofollow">7.3.1. 构造方法</a><ul><li><a href="#7311-底层使用数组lockcondition实现" rel="noopener nofollow">7.3.1.1. 底层使用数组+Lock+Condition实现</a></li></ul></li><li><a href="#732-put" rel="noopener nofollow">7.3.2. put</a><ul><li><a href="#7321-转调offer不需要阻塞" rel="noopener nofollow">7.3.2.1. 转调offer，不需要阻塞</a><ul><li><a href="#73211-加锁" rel="noopener nofollow">7.3.2.1.1. 加锁</a></li><li><a href="#73212-判断是否需要扩容" rel="noopener nofollow">7.3.2.1.2. 判断是否需要扩容</a><ul><li><a href="#732121-需要的话进行扩容" rel="noopener nofollow">7.3.2.1.2.1. 需要的话进行扩容</a></li></ul></li><li><a href="#73213-把元素加入堆的末尾" rel="noopener nofollow">7.3.2.1.3. 把元素加入堆的末尾</a><ul><li><a href="#732131-上浮操作调整堆" rel="noopener nofollow">7.3.2.1.3.1. 上浮操作调整堆</a></li><li><a href="#732132-调整的过程图" rel="noopener nofollow">7.3.2.1.3.2. 调整的过程图</a></li></ul></li></ul></li></ul></li><li><a href="#733-take" rel="noopener nofollow">7.3.3. take</a><ul><li><a href="#7331-加锁" rel="noopener nofollow">7.3.3.1. 加锁</a></li><li><a href="#7332-一直阻塞等待直到出队成功" rel="noopener nofollow">7.3.3.2. 一直阻塞等待，直到出队成功</a><ul><li><a href="#73321-出队具体操作" rel="noopener nofollow">7.3.3.2.1. 出队具体操作</a><ul><li><a href="#733211-移除堆顶末尾元素放到堆顶" rel="noopener nofollow">7.3.3.2.1.1. 移除堆顶，末尾元素放到堆顶</a></li><li><a href="#733212-下沉操作调整堆" rel="noopener nofollow">7.3.3.2.1.2. 下沉操作调整堆</a></li><li><a href="#733213-调整的过程图" rel="noopener nofollow">7.3.3.2.1.3. 调整的过程图</a></li></ul></li></ul></li></ul></li></ul></li><li><a href="#74-总结" rel="noopener nofollow">7.4. 总结</a></li></ul></li><li><a href="#8-synchronousqueue" rel="noopener nofollow">8. SynchronousQueue</a><ul><li><a href="#81-是什么" rel="noopener nofollow">8.1. 是什么</a></li><li><a href="#82-使用" rel="noopener nofollow">8.2. 使用</a></li><li><a href="#83-原理" rel="noopener nofollow">8.3. 原理</a><ul><li><a href="#831-构造方法" rel="noopener nofollow">8.3.1. 构造方法</a><ul><li><a href="#8311-transfer" rel="noopener nofollow">8.3.1.1. Transfer</a></li><li><a href="#8312-qnode" rel="noopener nofollow">8.3.1.2. QNode</a></li></ul></li><li><a href="#832-put-阻塞" rel="noopener nofollow">8.3.2. put 阻塞</a><ul><li><a href="#8321-调用transferqueue" rel="noopener nofollow">8.3.2.1. 调用TransferQueue</a></li></ul></li><li><a href="#833-take-阻塞" rel="noopener nofollow">8.3.3. take 阻塞</a></li></ul></li><li><a href="#84-总结" rel="noopener nofollow">8.4. 总结</a></li></ul></li><li><a href="#9-参考" rel="noopener nofollow">9. 参考</a></li></ul></div><p></p>
<h1 id="1-是什么">1. 是什么</h1>
<p>线程安全的阻塞队列。<br>
特点：</p>
<ul>
<li>先进先出：<br>
既然是队列那肯定是先进先出</li>
<li>阻塞<br>
支持在插入元素时，如果队列已满，那么阻塞，等待队列非满<br>
也支持在删除元素时，如果队列为空，那么阻塞，等待队列非空</li>
<li>无界有界<br>
数组容量的大小。无界其实是Integer.MAX_VALUE</li>
<li>线程安全</li>
</ul>
<h1 id="2-使用场景">2. 使用场景</h1>
<p>生产者、消费者</p>
<h1 id="3-如何使用">3. 如何使用</h1>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td><strong>put(e)</strong></td>
<td><strong>offer(e,time,unit)</strong></td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td><strong>take()</strong></td>
<td><strong>poll(time,unit)</strong></td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<h1 id="4-各种blockingqueue详解以及对比">4. 各种BlockingQueue详解以及对比</h1>
<table>
<thead>
<tr>
<th></th>
<th>ArrayBlockingQueue</th>
<th>LinkedBlockingQueue</th>
<th>PriorityBlockingQueue</th>
<th>SynchronousQueue</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据结构</td>
<td>数组</td>
<td>单向链表</td>
<td>数组（二叉堆）</td>
<td>单向链表</td>
</tr>
<tr>
<td>怎么实现阻塞</td>
<td>Lock+Condition</td>
<td>Lock+Condition</td>
<td>Lock+Condition</td>
<td>CAS+LockSupport</td>
</tr>
<tr>
<td>有界/无界</td>
<td>有界</td>
<td>有界</td>
<td>无界</td>
<td>无界（不存储元素）</td>
</tr>
<tr>
<td>吞吐量（以LinkedBlockingQueue为基准）</td>
<td>比LinkedBlockingQueue低（读读、读写、写写相互阻塞）</td>
<td>/ （读读、写写相互阻塞，读写不相互阻塞）</td>
<td>无界（读读、读写、写写相互阻塞）</td>
<td>比LinkedBlockingQueue高（读写匹配才能进行下去）</td>
</tr>
</tbody>
</table>
<ul>
<li><a href="ArrayBlockingQueue.md" target="_blank" rel="noopener nofollow">ArrayBlockingQueue.md</a></li>
<li><a href="LinkedBlockingQueue.md" target="_blank" rel="noopener nofollow">LinkedBlockingQueue.md</a></li>
<li><a href="PriorityBlockingQueue.md" target="_blank" rel="noopener nofollow">PriorityBlockingQueue.md</a></li>
<li><a href="SynchronousQueue.md" target="_blank" rel="noopener nofollow">SynchronousQueue.md</a></li>
</ul>
<h1 id="5-arrayblockingqueue">5. ArrayBlockingQueue</h1>
<h2 id="51-是什么">5.1. 是什么</h2>
<p>使用Object数组实现的有界的阻塞队列<br>
读读、读写、写写相互阻塞</p>
<h2 id="52-如何使用">5.2. 如何使用</h2>
<pre><code class="language-java">public class ArrayBlockingQueueTest
{
    public static void main(String[] args) throws InterruptedException
    {
        ArrayBlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(1);
        CountDownLatch latch = new CountDownLatch(2);

        new Thread(()-&gt;{
            for (int i = 0;;i++)
            {
                try
                {
                 	String data = "data" + i;
                    queue.put(data);
                    System.out.println("Producer放入消息：" + data);
                    TimeUnit.SECONDS.sleep(1);
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
                finally
                {
                    latch.countDown();
                }
            }
        }).start();

        new Thread(()-&gt;{
            for (;;)
            {
                try
                {
                    System.out.println("Consumer获取消息：" + queue.take());
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
                finally
                {
                    latch.countDown();
                }
            }
        }).start();

        latch.await();

    }
}
</code></pre>
<h3 id="521-方法选择">5.2.1. 方法选择</h3>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<h2 id="53-原理分析">5.3. 原理分析</h2>
<h3 id="531-uml">5.3.1. uml</h3>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20191229225548.png" class="lazyload"></p>
<h3 id="532-构造方法">5.3.2. 构造方法</h3>
<h4 id="5321-底层使用数组lockcondtion实现">5.3.2.1. 底层使用数组+Lock+Condtion实现</h4>
<pre><code class="language-java">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {
	//底层是数组实现的
	final Object[] items;

	//take, poll, peek or remove等读方法，读取下一个元素的位置
	int takeIndex;
	//put, offer, or add等方法，写入下一个元素的位置
	int putIndex;

	//数组中实际元素的数量
	//当count==item.length()的时候说明数组已满
	int count;

	//一个锁说明读写互斥
	final ReentrantLock lock;
    //两个条件量
    private final Condition notEmpty;//用来唤醒读线程
	private final Condition notFull;//用来唤醒写线程

	public ArrayBlockingQueue(int capacity, boolean fair) {
		if (capacity &lt;= 0)
			throw new IllegalArgumentException();
	
		this.items = new Object[capacity];
		lock = new ReentrantLock(fair);
		notEmpty = lock.newCondition();
		notFull =  lock.newCondition();
	}
}

</code></pre>
<h3 id="533-put阻塞">5.3.3. put【阻塞】</h3>
<pre><code class="language-java">public void put(E e) throws InterruptedException {
    checkNotNull(e);
    //加锁
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
    	//如果数组已经满了，那么等待。读者取出元素后唤醒
        while (count == items.length)
            notFull.await();
        //没满，加入数组
        enqueue(e);
    } finally {
        lock.unlock();
    }
}
</code></pre>
<ul>
<li>4行：加锁。一旦该写线程加锁其他读写线程都不能同时进来</li>
<li>8-9行：如果数组已经满了，那么阻塞等待</li>
<li>11行：没满则入队并唤醒读者</li>
</ul>
<p>下面具体分析：</p>
<h4 id="5331-加锁">5.3.3.1. 加锁</h4>
<pre><code class="language-java">//加锁
final ReentrantLock lock = this.lock;
lock.lockInterruptibly();
try {
    //...
} finally {
    lock.unlock();
}
</code></pre>
<h4 id="5332-如果数组已经满了那么等待">5.3.3.2. 如果数组已经满了，那么等待</h4>
<pre><code class="language-java">//如果数组已经满了，那么等待。直到读者取出元素后唤醒
while (count == items.length)
    notFull.await();
</code></pre>
<h4 id="5333-没满则入队并唤醒读者">5.3.3.3. 没满则入队并唤醒读者</h4>
<pre><code class="language-java">enqueue(e);
</code></pre>
<ul>
<li>enqueue</li>
</ul>
<pre><code class="language-java">private void enqueue(E x) {
    //把元素加入到队尾
    final Object[] items = this.items;
    items[putIndex] = x;
    //已插入到末尾，重置插入索引为0
    //这个数组是可以循环使用的，不需要扩容。
    if (++putIndex == items.length)
        putIndex = 0;
    count++;
    //插入后唤醒读者
    notEmpty.signal();
}
</code></pre>
<h3 id="534-take阻塞">5.3.4. take【阻塞】</h3>
<pre><code class="language-java">public E take() throws InterruptedException {
	//加锁
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
    	//如果数组为空，那么等待。写者加入元素后唤醒
        while (count == 0)
            notEmpty.await();
    	//出队
        return dequeue();
    } finally {
    	//释放锁
        lock.unlock();
    }
}
</code></pre>
<ul>
<li>3行：加锁。一旦该读线程加锁其他读写线程都不能同时进来</li>
<li>6-8行：如果数组为空，那么等待</li>
<li>10行：不为空则出队并唤醒写者</li>
</ul>
<p>下面具体分析：</p>
<h4 id="5341-加锁">5.3.4.1. 加锁</h4>
<pre><code class="language-java">//加锁
final ReentrantLock lock = this.lock;
lock.lockInterruptibly();
 try {
	//...
} finally {
	//释放锁
    lock.unlock();
}

</code></pre>
<h4 id="5342-如果数组为空那么等待">5.3.4.2. 如果数组为空，那么等待</h4>
<pre><code class="language-java">//如果数组为空，那么等待。写者加入元素后唤醒
while (count == 0)
    notEmpty.await();
</code></pre>
<h4 id="5343-不为空则出队并唤醒写者">5.3.4.3. 不为空则出队并唤醒写者</h4>
<ul>
<li>dequeue</li>
</ul>
<pre><code class="language-java">private E dequeue() {
    final Object[] items = this.items;
    @SuppressWarnings("unchecked")
    //获取最后一个元素并置为null
    E x = (E) items[takeIndex];
    items[takeIndex] = null;
    //已取到末尾，重置取值索引为0
     //这个数组是可以循环使用的，不需要扩容。
    if (++takeIndex == items.length)
        takeIndex = 0;
    count--;
    if (itrs != null)
        itrs.elementDequeued();
    //出队后唤醒写者
    notFull.signal();
    return x;
}
</code></pre>
<h3 id="535-offer返回特殊值">5.3.5. offer【返回特殊值】</h3>
<pre><code class="language-java">public boolean offer(E e) {
    checkNotNull(e);
    //加锁
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
    	//已满，直接返回false
        if (count == items.length)
            return false;
        else {
        	//未满，加入队列同时唤醒读者
            enqueue(e);
            return true;
        }
    } finally {
    	//解锁
        lock.unlock();
    }
}

</code></pre>
<h3 id="536-poll返回特殊值">5.3.6. poll【返回特殊值】</h3>
<pre><code class="language-java">public E poll() {
    final ReentrantLock lock = this.lock;
	//加锁
    lock.lock();
    try {
    	//长度为0直接返回null，否则出队并唤醒写者
        return (count == 0) ? null : dequeue();
    } finally {
        lock.unlock();
    }
}

</code></pre>
<h3 id="537-add抛出异常">5.3.7. add【抛出异常】</h3>
<pre><code class="language-java">public boolean add(E e) {
	//简单调用AbstractQueue的add方法
    return super.add(e);
}

//AbstractQueue的add方法
public boolean add(E e) {
	//调用ArrayBlockingQueue的方offer法
    if (offer(e))
        return true;
    else
        throw new IllegalStateException("Queue full");
}


</code></pre>
<h3 id="538-remove抛出异常">5.3.8. remove【抛出异常】</h3>
<pre><code class="language-java">public E remove() {
	//简单调用poll方法
    E x = poll();
    if (x != null)
        return x;
    else
    	//没有元素，抛出异常
        throw new NoSuchElementException();
}
</code></pre>
<h3 id="539-element抛出异常">5.3.9. element【抛出异常】</h3>
<pre><code class="language-java">public E element() {
	//调用peek方法
    E x = peek();
    if (x != null)
        return x;
    else
    	//为空直接抛出异常
        throw new NoSuchElementException();
}
</code></pre>
<h3 id="5310-peek返回特殊值">5.3.10. peek【返回特殊值】</h3>
<pre><code class="language-java">public E peek() {
	//加锁
	final ReentrantLock lock = this.lock;
	lock.lock();
	try {
		return itemAt(takeIndex); // null when queue is empty
	} finally {
		//解锁
		lock.unlock();
	}
}
	
	
@SuppressWarnings("unchecked")
final E itemAt(int i) {
	//直接返回数组中的第i个元素
    return (E) items[i];
}

</code></pre>
<h2 id="54-总结">5.4. 总结</h2>
<p>底层使用数组实现，是个有界队列。<br>
并且用了一个锁和两个condition。一个锁说明读写互斥，两个conditon说明读写相互唤醒</p>
<h1 id="6-linkedblockingqueue">6. LinkedBlockingQueue</h1>
<h2 id="61-是什么">6.1. 是什么</h2>
<p>使用单向链表实现的有界的阻塞队列<br>
读读、写写相互阻塞，读写不相互阻塞<br>
吞吐量比ArrayBlockingQueue高</p>
<h2 id="62-如何使用">6.2. 如何使用</h2>
<pre><code class="language-java">public class LinkedBlockingQueueTest
{
    public static void main(String[] args) throws InterruptedException
    {
        LinkedBlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;(1);
        CountDownLatch latch = new CountDownLatch(2);

        new Thread(()-&gt;{
            for (int i = 0;;i++)
            {
                try
                {
                 	String data = "data" + i;
                    queue.put(data);
                    System.out.println("Producer放入消息：" + data);
                    TimeUnit.SECONDS.sleep(1);
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
                finally
                {
                    latch.countDown();
                }
            }
        }).start();

        new Thread(()-&gt;{
            for (;;)
            {
                try
                {
                    System.out.println("Consumer获取消息：" + queue.take());
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
                finally
                {
                    latch.countDown();
                }
            }
        }).start();

        latch.await();

    }
}

</code></pre>
<h2 id="63-源码分析">6.3. 源码分析</h2>
<h3 id="631-构造方法">6.3.1. 构造方法</h3>
<h4 id="6311-底层使用单向链表lockcondition实现">6.3.1.1. 底层使用单向链表+Lock+Condition实现</h4>
<pre><code class="language-java">public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
        implements BlockingQueue&lt;E&gt;, java.io.Serializable {

  	//最大长度
    private final int capacity;

    //实际长度
    private final AtomicInteger count = new AtomicInteger();

    //头节点
    transient Node&lt;E&gt; head;

    //尾节点
    private transient Node&lt;E&gt; last;

    //出队时用的锁。锁住队头
    private final ReentrantLock takeLock = new ReentrantLock();

    //如果读操作的时候队列是空的，那么等待 notEmpty 条件
    private final Condition notEmpty = takeLock.newCondition();

    //入队时用的锁。锁住队尾
    private final ReentrantLock putLock = new ReentrantLock();

    // 如果写操作的时候队列是满的，那么等待 notFull 条件
    private final Condition notFull = putLock.newCondition();

	public LinkedBlockingQueue() {
		//相当于无界队列
		this(Integer.MAX_VALUE);
	}

	public LinkedBlockingQueue(int capacity) {
		if (capacity &lt;= 0) throw new IllegalArgumentException();
		this.capacity = capacity;//有界队列
		last = head = new Node&lt;E&gt;(null);//头节点是个占位符
	}
}
</code></pre>
<h4 id="6312-node">6.3.1.2. Node</h4>
<pre><code class="language-java">static class Node&lt;E&gt; {
    E item;

    //单向队列
    Node&lt;E&gt; next;

    Node(E x) { item = x; }
}
</code></pre>
<p>结构如下图：<br>
<img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200116110328.png" class="lazyload"></p>
<h3 id="632-put阻塞">6.3.2. put【阻塞】</h3>
<pre><code class="language-java">public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
    int c = -1;
    Node&lt;E&gt; node = new Node&lt;E&gt;(e);
    final ReentrantLock putLock = this.putLock;
    final AtomicInteger count = this.count;
    //加写锁
    putLock.lockInterruptibly();
    try {
        //链表实际容量到达链表最大容量，阻塞等待读者取出
        while (count.get() == capacity) {
            notFull.await();
        }
    	//加入尾部
        enqueue(node);
        c = count.getAndIncrement();//+1，不过返回的是c的原值
        if (c + 1 &lt; capacity)
            notFull.signal();//唤醒其他写者？
    } finally {
        putLock.unlock();
    }
    //c == 0 说明原来queue是空的, 那么可能有其他读线程阻塞住了。
    if (c == 0)
    	//所以这里 唤醒正在 poll/take 等待中的线程
        signalNotEmpty();
}
</code></pre>
<ul>
<li>8行：加写锁。一旦加了写锁其他写者无法同时进来写入数据，但是读者可以同时进来读</li>
<li>11-13行：链表实际容量到达链表最大容量，那么写者阻塞等待读者取出</li>
<li>15行：链表没有满的话，那么把该元素添加至尾部</li>
<li>16行：更新队列中元素的数量，+1，返回原值</li>
<li>17-18行：添加了元素后发现队列还是没有满，那么唤醒其他写者继续添加</li>
<li>23-25行：由这句<code>c = count.getAndIncrement();</code>可看出+1后返回的是c的原值，如果为0说明之前队列可能为空，那么加读锁、唤醒读者读取元素、解读锁</li>
</ul>
<p>下面具体分析：</p>
<h4 id="6321-加写锁">6.3.2.1. 加写锁</h4>
<pre><code class="language-java">//加写锁
putLock.lockInterruptibly();
try {
//...
} finally {
    putLock.unlock();
}
</code></pre>
<h4 id="6322-如果队列已满那么等待">6.3.2.2. 如果队列已满那么等待</h4>
<pre><code class="language-java">//链表实际容量到达链表最大容量，阻塞等待读者取出
while (count.get() == capacity) {
    notFull.await();
}
</code></pre>
<h4 id="6323-未满则入队">6.3.2.3. 未满则入队</h4>
<ul>
<li>enqueue</li>
</ul>
<pre><code class="language-java">private void enqueue(Node&lt;E&gt; node) {
    //把节点加入到链表尾部，并且更新last指针
    last = last.next = node;
}
</code></pre>
<h4 id="6324-入队完发现队列没满那么继续唤醒写者入队">6.3.2.4. 入队完发现队列没满，那么继续唤醒写者入队</h4>
<pre><code class="language-java">if (c + 1 &lt; capacity)
    notFull.signal();//唤醒其他写者
</code></pre>
<h4 id="6325-入队完解锁后发现之前队列是空的那么唤醒读者">6.3.2.5. 入队完解锁后发现之前队列是空的，那么唤醒读者</h4>
<pre><code class="language-java">//c == 0 说明原来queue是空的, 那么可能有其他读线程阻塞住了。
if (c == 0)
	//所以这里 唤醒正在 poll/take 等待中的线程
    signalNotEmpty();
</code></pre>
<ul>
<li>signalNotEmpty</li>
</ul>
<pre><code class="language-java"> private void signalNotEmpty() {
 	//加读锁
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lock();
    try {
    	//唤醒读者
        notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
}
</code></pre>
<h3 id="633-take阻塞">6.3.3. take【阻塞】</h3>
<pre><code class="language-java">public E take() throws InterruptedException {
    E x;
    int c = -1;
    final AtomicInteger count = this.count;
    final ReentrantLock takeLock = this.takeLock;
	//加了读锁
    takeLock.lockInterruptibly();
    try {
    	//长度为0，阻塞等待写着加入
        while (count.get() == 0) {
            notEmpty.await();
        }
    	//删除第一个节点
        x = dequeue();
        c = count.getAndDecrement();
        if (c &gt; 1)
            notEmpty.signal();//唤醒其他读者？
    } finally {
        takeLock.unlock();
    }
    //c == capacity 说明原来queue是满的, 那么可能有其他写线程阻塞住了。
    if (c == capacity)
    	//所以这里 唤醒正在 put 等待中的线程
        signalNotFull();
    return x;
}
</code></pre>
<ul>
<li>7行：加读锁。一旦加了读锁其他读者无法同时进来读取数据，但是写者可以同时进来写数据</li>
<li>10-12行：链表实际容量为0，那么读者阻塞等待写者写入</li>
<li>14行：链表不为空的话，那么删除链表头部的元素</li>
<li>15行：更新队列中元素的数量，-1，返回原值</li>
<li>16-17行：取出了元素后发现队列还是不为空，那么唤醒其他读者继续读取</li>
<li>22-24行：由这句<code>c = count.getAndDecrement();</code>可看出-1后返回的是c的原值，当他为capacity的时候说明之前队列可能是满的，那么加写锁、唤醒写者写入元素、解写锁</li>
</ul>
<p>下面具体分析：</p>
<h4 id="6331-加读锁">6.3.3.1. 加读锁</h4>
<pre><code class="language-java">//加了读锁
takeLock.lockInterruptibly();
try {
    //....
} finally {
    takeLock.unlock();
}
</code></pre>
<h4 id="6332-队列为空那么等待">6.3.3.2. 队列为空那么等待</h4>
<pre><code class="language-java">//长度为0，阻塞等待写着加入
while (count.get() == 0) {
    notEmpty.await();
}
</code></pre>
<h4 id="6333-未空则出队">6.3.3.3. 未空则出队</h4>
<ul>
<li>dequeue</li>
</ul>
<pre><code class="language-java">private E dequeue() {
    Node&lt;E&gt; h = head;//头节点是个占位符
    Node&lt;E&gt; first = h.next;//真正的第一个节点
    h.next = h; // help GC 头节点next指向头节点自己？
    head = first;//更新头节点指向第一个节点（即从队头出队）
    E x = first.item;
    first.item = null;
    return x;
}
</code></pre>
<h4 id="6334-出了队发现队列没空那么继续唤醒读者">6.3.3.4. 出了队发现队列没空，那么继续唤醒读者</h4>
<pre><code class="language-java">if (c &gt; 1)
    notEmpty.signal();//唤醒其他读者？
</code></pre>
<h4 id="6335-出了队解了锁发现之前队列是满的那么唤醒写者">6.3.3.5. 出了队解了锁发现之前队列是满的，那么唤醒写者</h4>
<pre><code class="language-java">if (c == capacity)
	//加写锁，唤醒写者
    signalNotFull();
</code></pre>
<ul>
<li>signalNotFull</li>
</ul>
<pre><code class="language-java">private void signalNotFull() {
	final ReentrantLock putLock = this.putLock;
	//加写锁
	putLock.lock();
	try {
		//通知写者没满，可以写了
		notFull.signal();
	} finally {
		putLock.unlock();
	}
}
</code></pre>
<h3 id="634-offer-返回特殊值">6.3.4. offer 返回特殊值</h3>
<pre><code class="language-java">public boolean offer(E e) {
    if (e == null) throw new NullPointerException();
    final AtomicInteger count = this.count;
	if (count.get() == capacity)
		return false;
	int c = -1;
	Node&lt;E&gt; node = new Node&lt;E&gt;(e);
	final ReentrantLock putLock = this.putLock;
	putLock.lock();
	try {
		if (count.get() &lt; capacity) {
			enqueue(node);
			c = count.getAndIncrement();
			if (c + 1 &lt; capacity)
				notFull.signal();
		}
	} finally {
		putLock.unlock();
	}
	if (c == 0)
		signalNotEmpty();
	return c &gt;= 0;//跟put不同的地方在这里，返回而不阻塞
}
</code></pre>
<h3 id="635-poll-返回特殊值">6.3.5. poll 返回特殊值</h3>
<pre><code class="language-java">public E poll() {
    final AtomicInteger count = this.count;
    if (count.get() == 0)//跟take不同的地方在这里，返回null
        return null;
    E x = null;
    int c = -1;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lock();
    try {
        if (count.get() &gt; 0) {
            x = dequeue();
            c = count.getAndDecrement();
            if (c &gt; 1)
                notEmpty.signal();
        }
    } finally {
        takeLock.unlock();
    }
    if (c == capacity)
        signalNotFull();
    return x;
}
</code></pre>
<h3 id="636-peek-返回特殊值">6.3.6. peek 返回特殊值</h3>
<pre><code class="language-java">public E peek() {
    if (count.get() == 0)//为空返回null
        return null;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lock();
    try {
        Node&lt;E&gt; first = head.next;
        if (first == null)
            return null;
        else
            return first.item;
    } finally {
        takeLock.unlock();
    }
    //不需要唤醒写着，因为没有出队
}
</code></pre>
<h2 id="64-总结">6.4. 总结</h2>
<p>底层使用单向数组实现，可以有界也可以无界队列。<br>
并且用了两个锁和两个condition。两个个锁说明读写可以同时进行，两个conditon说明读写相互唤醒</p>
<h1 id="7-priorityblockingqueue">7. PriorityBlockingQueue</h1>
<h2 id="71-是什么">7.1. 是什么</h2>
<p>底层使用数组（二叉堆）实现的无界的阻塞队列<br>
读读、读写、写写相互阻塞<br>
可以排序<br>
由于无界，所以put操作不会阻塞，但是take操作会阻塞（队列为空的时候）</p>
<h3 id="711-二叉堆">7.1.1. 二叉堆</h3>
<p>一颗完全二叉树，堆序性质为，每个节点的值都小于其左右子节点的值，二叉堆中最小的值就是根节点。<br>
底层用数组进行存储。对于数组中的元素 a[i]，其左子节点为 a[2<em>i+1]，其右子节点为 a[2</em>i + 2]，其父节点为 a[(i-1)/2]。<br>
结构如下图：<br>
<img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200116145205.png" class="lazyload"></p>
<h2 id="72-如何使用">7.2. 如何使用</h2>
<pre><code class="language-java">public class PriorityBlockingQueueTest
{
    public static void main(String[] args) throws InterruptedException
    {
        PriorityBlockingQueue&lt;String&gt; queue = new PriorityBlockingQueue&lt;&gt;(1);
        CountDownLatch latch = new CountDownLatch(2);

        new Thread(()-&gt;{
            for (int i = 0;;i++)
            {
                try
                {
                    String data = "data" + i;
                    queue.put(data);
                    System.out.println("Producer放入消息：" + data);
                    TimeUnit.SECONDS.sleep(1);
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
                finally
                {
                    latch.countDown();
                }
            }
        }).start();

        new Thread(()-&gt;{
            for (;;)
            {
                try
                {
                    System.out.println("Consumer获取消息：" + queue.take());
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
                finally
                {
                    latch.countDown();
                }
            }
        }).start();

        latch.await();

    }
}
</code></pre>
<h2 id="73-原理分析">7.3. 原理分析</h2>
<h3 id="731-构造方法">7.3.1. 构造方法</h3>
<h4 id="7311-底层使用数组lockcondition实现">7.3.1.1. 底层使用数组+Lock+Condition实现</h4>
<pre><code class="language-java">public class PriorityBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {


	//底层使用数组实现（堆）
	private transient Object[] queue;
	//实际使用的长度
    private transient int size;

    //comparator确定元素的顺序，如果是null那么是自然序
    private transient Comparator&lt;? super E&gt; comparator;

    //只有一把锁说明读写互斥
    private final ReentrantLock lock;

	//只有一个condition说明只有读或者写的操作是阻塞的
    //当队列不为空的时候唤醒读操作
    private final Condition notEmpty;

	// 这个也是用于锁，用于数组扩容的时候，需要先获取到这个锁，才能进行扩容操作
	// 其使用 CAS 操作
	private transient volatile int allocationSpinLock;

	public PriorityBlockingQueue() {
		//默认11个，自然序
        this(DEFAULT_INITIAL_CAPACITY, null);
    }

	public PriorityBlockingQueue(int initialCapacity) {
		this(initialCapacity, null);
	}

	public PriorityBlockingQueue(int initialCapacity,
		                         Comparator&lt;? super E&gt; comparator) {
		if (initialCapacity &lt; 1)
		    throw new IllegalArgumentException();
		this.lock = new ReentrantLock();
		this.notEmpty = lock.newCondition();
		this.comparator = comparator;
		this.queue = new Object[initialCapacity];
	}
}
</code></pre>
<h3 id="732-put">7.3.2. put</h3>
<pre><code class="language-java">public void put(E e) {
    //转调offer
    offer(e); // never need to block
}
</code></pre>
<h4 id="7321-转调offer不需要阻塞">7.3.2.1. 转调offer，不需要阻塞</h4>
<ul>
<li>offer</li>
</ul>
<pre><code class="language-java">public boolean offer(E e) {
    if (e == null)
        throw new NullPointerException();
    final ReentrantLock lock = this.lock;
    //加锁
    lock.lock();
    int n, cap;
    Object[] array;
    //如果当前队列中的元素个数 &gt;= 数组的大小，那么需要扩容了
    while ((n = size) &gt;= (cap = (array = queue).length))
        tryGrow(array, cap);
    try {
        Comparator&lt;? super E&gt; cmp = comparator;
		//自然序。把e加入到数组array末尾的位置n，然后与父亲比较，若是比父亲小则交换位置
        if (cmp == null)
            siftUpComparable(n, e, array);
        else
            siftUpUsingComparator(n, e, array, cmp);
        size = n + 1;
        //唤醒读者
        notEmpty.signal();
    } finally {
        lock.unlock();
    }
    return true;
}
</code></pre>
<ul>
<li>6行：加锁。一旦该写者加了锁，那么其他读写线程不能进来操作</li>
<li>10-11行：根据需要进行扩容</li>
<li>13-18行：插入数组末尾，并且通过上浮操作保持堆的性质</li>
<li>19行：队列中元素的实际数量+1</li>
<li>21行：其他读者可能在队列为空的时候阻塞，这里需要唤醒<br>
由上面的代码可以看出写的时候是不需要阻塞的，因为这个队列是无界的</li>
</ul>
<h5 id="73211-加锁">7.3.2.1.1. 加锁</h5>
<pre><code class="language-java">final ReentrantLock lock = this.lock;
    //加锁
    lock.lock();
} finally {
    lock.unlock();
}
</code></pre>
<h5 id="73212-判断是否需要扩容">7.3.2.1.2. 判断是否需要扩容</h5>
<pre><code class="language-java">//如果当前队列中的元素个数 &gt;= 数组的大小，那么需要扩容了
    while ((n = size) &gt;= (cap = (array = queue).length))
        tryGrow(array, cap);
</code></pre>
<h6 id="732121-需要的话进行扩容">7.3.2.1.2.1. 需要的话进行扩容</h6>
<ul>
<li>tryGrow</li>
</ul>
<pre><code class="language-java">private void tryGrow(Object[] array, int oldCap) {
	//为什么这里释放锁？让读的线程可以读而不至于再扩容的时候阻塞
    lock.unlock(); // must release and then re-acquire main lock
    Object[] newArray = null;
    //allocationSpinLock为0表示没有其他进行扩容，1表示有
    //当没有其他线程扩容 且 当前线程CAS加锁成功才进行扩容
    if (allocationSpinLock == 0 &amp;&amp;
        UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,
                                 0, 1)) {
        try {
        	//如果旧容量&lt;64，那么新容量=2*旧容量+2
        	//否则为1.5*旧容量
            int newCap = oldCap + ((oldCap &lt; 64) ?
                                   (oldCap + 2) : // grow faster if small
                                   (oldCap &gt;&gt; 1));
           //溢出判断
            if (newCap - MAX_ARRAY_SIZE &gt; 0) {    // possible overflow
                int minCap = oldCap + 1;
                if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE)
                    throw new OutOfMemoryError();
                newCap = MAX_ARRAY_SIZE;
            }
        	//确实有扩容 且 array没有变动--说明没有其他线程在扩容？
            if (newCap &gt; oldCap &amp;&amp; queue == array)
                newArray = new Object[newCap];
        } finally {
        	//释放锁
            allocationSpinLock = 0;
        }
    }
    //其他线程在扩容，让出CPU
    if (newArray == null) // back off if another thread is allocating
        Thread.yield();
    //这里有重新加锁了？扩容完毕，需要真正的修改数组了，这里需要阻塞读
    lock.lock();
    //转移旧数组到新数组
    if (newArray != null &amp;&amp; queue == array) {
        queue = newArray;
        System.arraycopy(array, 0, newArray, 0, oldCap);
    }
}
</code></pre>
<h5 id="73213-把元素加入堆的末尾">7.3.2.1.3. 把元素加入堆的末尾</h5>
<pre><code class="language-java">//自然序。把e加入到数组array末尾的位置n，然后与父亲比较，若是比父亲小则交换位置
if (cmp == null)
    siftUpComparable(n, e, array);
</code></pre>
<h6 id="732131-上浮操作调整堆">7.3.2.1.3.1. 上浮操作调整堆</h6>
<ul>
<li>siftUpComparable</li>
</ul>
<pre><code class="language-java">//把x，插入到堆数组array，的k位置
private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] array) {
    Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x;
	//最多调整到root即0
    while (k &gt; 0) {
    	//父节点的位置 (k-1)/2
        int parent = (k - 1) &gt;&gt;&gt; 1;
        Object e = array[parent];
        
        //如果x比父节点大，那么退出
        if (key.compareTo((T) e) &gt;= 0)
            break;

        //否则与父节点交换位置
        array[k] = e;
        //从父节点继续往上
        k = parent;
    }
    //走到这里说明k位置存放x满足二叉堆的性质：比父节点大，比左右孩子小
    array[k] = key;
}
</code></pre>
<h6 id="732132-调整的过程图">7.3.2.1.3.2. 调整的过程图</h6>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200116150518.png" class="lazyload"></p>
<h3 id="733-take">7.3.3. take</h3>
<pre><code class="language-java"> public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    //加锁
    lock.lockInterruptibly();
    E result;
    try {
    	//出队元素为空那么阻塞等待唤醒
        while ( (result = dequeue()) == null)
            notEmpty.await();
    } finally {
    	//解锁
        lock.unlock();
    }
    return result;
}
</code></pre>
<ul>
<li>4行：加锁。一旦该读者加了锁，那么其他读写线程不能进来操作</li>
<li>8-9行：出队，如果队列为空那么进行阻塞，等待队列不为空的时候由写者唤醒</li>
</ul>
<h4 id="7331-加锁">7.3.3.1. 加锁</h4>
<pre><code class="language-java"> final ReentrantLock lock = this.lock;
    //加锁
    lock.lockInterruptibly();
    try {
    	//...
    } finally {
    	//解锁
        lock.unlock();
    }
</code></pre>
<h4 id="7332-一直阻塞等待直到出队成功">7.3.3.2. 一直阻塞等待，直到出队成功</h4>
<pre><code class="language-java">//出队元素为空那么阻塞等待唤醒
while ( (result = dequeue()) == null)
    notEmpty.await();
</code></pre>
<h5 id="73321-出队具体操作">7.3.3.2.1. 出队具体操作</h5>
<ul>
<li>dequeue</li>
</ul>
<pre><code class="language-java">private E dequeue() {
	//队列为空返回null
    int n = size - 1;
    if (n &lt; 0)
        return null;
    else {
        Object[] array = queue;
        //root节点，即0号位置就是出队的元素
        E result = (E) array[0];
       
        E x = (E) array[n];//数组末尾的元素x
        array[n] = null;
        Comparator&lt;? super E&gt; cmp = comparator;
        if (cmp == null)
         	//把数组末尾的元素x放到0号位置，调整堆
            siftDownComparable(0, x, array, n);
        else
            siftDownUsingComparator(0, x, array, n, cmp);
        size = n;
        return result;
    }
}

</code></pre>
<ul>
<li>7-12行：移除堆顶，末尾元素放到堆顶</li>
<li>14-18行：下沉操作调整堆</li>
</ul>
<h6 id="733211-移除堆顶末尾元素放到堆顶">7.3.3.2.1.1. 移除堆顶，末尾元素放到堆顶</h6>
<pre><code class="language-java">Object[] array = queue;
//root节点，即0号位置就是出队的元素
E result = (E) array[0];

E x = (E) array[n];//数组末尾的元素x
array[n] = null;
</code></pre>
<h6 id="733212-下沉操作调整堆">7.3.3.2.1.2. 下沉操作调整堆</h6>
<ul>
<li>siftDownComparable</li>
</ul>
<pre><code class="language-java">//把元素x，插入到长度为n，的堆数组array的，k位置
private static &lt;T&gt; void siftDownComparable(int k, T x, Object[] array,
                                           int n) {
    if (n &gt; 0) {
        Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x;
        //只能在 非叶子节点（有孩子的节点）调整
        int half = n &gt;&gt;&gt; 1;           
        while (k &lt; half) {
        	//左孩子
            int child = (k &lt;&lt; 1) + 1; // assume left child is least
            Object c = array[child];
			//右孩子
            int right = child + 1;
            if (right &lt; n &amp;&amp;
                ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0)
                c = array[child = right];
            //c是左右孩子中较小的那个
            //如果要插入的元素比左右孩子都小，那么二叉堆性质以满足，无需调整
            if (key.compareTo((T) c) &lt;= 0)
                break;
            //否则将较小的孩子上移
            array[k] = c;
            //继续往下调整
            k = child;
        }
        //走到这里说明k位置存放x满足二叉堆的性质：比父节点大，比左右孩子小
        array[k] = key;
    }
}
</code></pre>
<h6 id="733213-调整的过程图">7.3.3.2.1.3. 调整的过程图</h6>
<p><img alt="" loading="lazy" data-src="https://raw.githubusercontent.com/TDoct/images/master/img/20200116151142.png" class="lazyload"></p>
<h2 id="74-总结">7.4. 总结</h2>
<p>无界队列，底层使用二叉堆实现，有序。<br>
写不阻塞，读阻塞</p>
<h1 id="8-synchronousqueue">8. SynchronousQueue</h1>
<h2 id="81-是什么">8.1. 是什么</h2>
<p>底层使用单向实现的阻塞队列，不存储元素<br>
一个写者必须同时有一个读者才能进行下去，反之亦然。<br>
否则写者将会一直阻塞或者读者将会一直阻塞</p>
<h2 id="82-使用">8.2. 使用</h2>
<pre><code class="language-java">public class SynchronousQueueTest
{
    public static void main(String[] args) throws InterruptedException
    {
        SynchronousQueue &lt;String&gt; queue = new SynchronousQueue&lt;&gt;();
        CountDownLatch latch = new CountDownLatch(2);

        new Thread(()-&gt;{
            for (int i = 0;;i++)
            {
                try
                {
                 	String data = "data" + i;
                    queue.put(data);
                    System.out.println("Producer放入消息：" + data);//不支持peek操作
                    TimeUnit.SECONDS.sleep(1);
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
                finally
                {
                    latch.countDown();
                }
            }
        }).start();

        new Thread(()-&gt;{
            for (;;)
            {
                try
                {
                    System.out.println("Consumer获取消息：" + queue.take());
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
                finally
                {
                    latch.countDown();
                }
            }
        }).start();

        latch.await();

    }
}
</code></pre>
<h2 id="83-原理">8.3. 原理</h2>
<h3 id="831-构造方法">8.3.1. 构造方法</h3>
<pre><code class="language-java">public class SynchronousQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {

	private transient volatile Transferer&lt;E&gt; transferer;
    
	public SynchronousQueue() {
		this(false);//默认不公平，即用stack
	}

	public SynchronousQueue(boolean fair) {
		transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();
	}

	//单向链表头、尾
    transient volatile QNode head;
    transient volatile QNode tail;
}
</code></pre>
<h4 id="8311-transfer">8.3.1.1. Transfer</h4>
<pre><code class="language-java">abstract static class Transferer&lt;E&gt; {
     //put和take操作都会调用这个
     //如果e为空，那么代表读者的take操作
     //如果e不为空，那么代表写着的put操作
     // 第二个参数代表是否设置超时，如果设置超时，超时时间是第三个参数的值
    // 返回值如果是 null，代表超时，或者中断。具体是哪个，可以通过检测中断状态得到。
    abstract E transfer(E e, boolean timed, long nanos);
}
</code></pre>
<h4 id="8312-qnode">8.3.1.2. QNode</h4>
<pre><code class="language-java"> static final class QNode {
    volatile QNode next;          // 单向链表
    volatile Object item;         // CAS'ed to or from null
    volatile Thread waiter;       // to control park/unpark
    final boolean isData;//true表示写，false表示读
}
</code></pre>
<h3 id="832-put-阻塞">8.3.2. put 阻塞</h3>
<pre><code class="language-java">public void put(E e) throws InterruptedException {
	//写着e保证不为空
    if (e == null) throw new NullPointerException();
	//调用Transfer的transfer方法传递元素给读者
    if (transferer.transfer(e, false, 0) == null) {
        Thread.interrupted();
        throw new InterruptedException();
    }
}
</code></pre>
<h4 id="8321-调用transferqueue">8.3.2.1. 调用TransferQueue</h4>
<ul>
<li>TransferQueue transfer</li>
</ul>
<pre><code class="language-java">E transfer(E e, boolean timed, long nanos) {
    QNode s = null;
    boolean isData = (e != null);//e不为空表示写（true），为空表示读（false）

    for (;;) {
        QNode t = tail;
        QNode h = head;
        if (t == null || h == null)         // saw uninitialized value
            continue;                       // spin

		//队列为空或者队列中尾节点的模式与当前节点一样（即都是写或者都是读的情况）
		//那么直接将当前节点入队
        if (h == t || t.isData == isData) {
            QNode tn = t.next;
            //之前的tail跟当前tail不同，说明已经有节点入队了，重新来一次
            if (t != tail)                 
                continue;
            //走到这里说明tail没有改变，可以tail.next居然不为空，说明有节点入队，但是还没有修改tail
            //那么把tail指向tail.next即可
            if (tn != null) {            
                advanceTail(t, tn);//tail==t的话，把tail指向tn
                continue;
            }
            //设置了超时但是时间不对
            if (timed &amp;&amp; nanos &lt;= 0)
                return null;
            //构造当前节点
            if (s == null)
                s = new QNode(e, isData);
            //插入到链表尾部
            if (!t.casNext(null, s))
                continue;

			//tail==t的话，把tail指向s
            advanceTail(t, s);              
            //自旋或者阻塞等待另一个模式的线程过来唤醒
            //写线程拿到的是null，读线程拿到的是写线程的值
            Object x = awaitFulfill(s, e, timed, nanos);

            //走到这里说明已经唤醒了，继续往下执行
            if (x == s) {                   // wait was cancelled
                clean(t, s);
                return null;
            }

			//当前节点的next不是当前节点
			//那么当头节点==尾节点的时候，CAS设置头为当前节点
            if (!s.isOffList()) {           // not already unlinked
                advanceHead(t, s);          // unlink if head
                if (x != null)              // and forget fields
                    s.item = s;
                s.waiter = null;
            }
            return (x != null) ? (E)x : e;

        } 
		//一读一写刚好匹配的情况
        else {                           
        	//头节点的next是当前节点
            QNode m = h.next;   
            //头节点或者尾节点或者头节点的next为空了，即链表改变了，重新开始            
            if (t != tail || m == null || h != head)
                continue;                   

            //失败重试的情况
            Object x = m.item;
            if (isData == (x != null) ||    // m already fulfilled
                x == m ||                   // m cancelled
                !m.casItem(x, e)) {         // lost CAS
                advanceHead(h, m);          // dequeue and retry
                continue;
            }

			//CAS需改头节点。如果h==head，那么修改头节点为当前节点
            advanceHead(h, m);              // successfully fulfilled
            //唤醒当前节点的线程。对应awaitFulfill
            LockSupport.unpark(m.waiter);
		
            return (x != null) ? (E)x : e;
        }
    }
}
</code></pre>
<ul>
<li>advanceTail</li>
</ul>
<pre><code>void advanceTail(QNode t, QNode nt) {
	//如果当前尾节点==传过来的尾节点的话
    if (tail == t)
    	//CAS操作修改尾节点指针指向nt
        UNSAFE.compareAndSwapObject(this, tailOffset, t, nt);
}
</code></pre>
<ul>
<li>awaitFulfill</li>
</ul>
<pre><code class="language-java">//要么自旋、要么阻塞
Object awaitFulfill(QNode s, E e, boolean timed, long nanos) {
    //设置了超时，那么计算超时到期的时间
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    Thread w = Thread.currentThread();
    //头节点的下一个节点就是我自己了，那么我不入队，而是自旋等待
    int spins = ((head.next == s) ?
                 (timed ? maxTimedSpins : maxUntimedSpins) : 0);
    for (;;) {
		//当前线程被中断了，那么将当前节点的item属性CAS设置为e
        if (w.isInterrupted())
            s.tryCancel(e);
        //这里是这个方法的唯一的出口
        //当前节点的item属性跟e不同的时候
        Object x = s.item;
        if (x != e)
            return x;
        //超时了，那么将当前节点的item属性CAS设置为e
        if (timed) {
            nanos = deadline - System.nanoTime();
            if (nanos &lt;= 0L) {
                s.tryCancel(e);
                continue;
            }
        }
    	//每次循环自旋-1
        if (spins &gt; 0)
            --spins;
        //走到这里说明自旋到了最大次数或者没有设置自旋

        //当前节点还没关联线程，那么关联
        else if (s.waiter == null)
            s.waiter = w;
        //没有设置超时，那么阻塞
        else if (!timed)
            LockSupport.park(this);
        else if (nanos &gt; spinForTimeoutThreshold)
            LockSupport.parkNanos(this, nanos);
    }
}

</code></pre>
<ul>
<li>tryCancel</li>
</ul>
<pre><code class="language-java">void tryCancel(Object cmp) {
    UNSAFE.compareAndSwapObject(this, itemOffset, cmp, this);
}
</code></pre>
<ul>
<li>advanceHead</li>
</ul>
<pre><code class="language-java">void advanceHead(QNode h, QNode nh) {
    if (h == head &amp;&amp;
        UNSAFE.compareAndSwapObject(this, headOffset, h, nh))
        h.next = h; // forget old next
}
</code></pre>
<h3 id="833-take-阻塞">8.3.3. take 阻塞</h3>
<pre><code class="language-java">public E take() throws InterruptedException {
	//调用Transfer的transfer方法从写者获取元素
    E e = transferer.transfer(null, false, 0);
    if (e != null)
        return e;
    Thread.interrupted();
    throw new InterruptedException();
}
</code></pre>
<h2 id="84-总结">8.4. 总结</h2>
<p>不存储元素，吞吐量比LinkedBlockingQueue高<br>
读、写必须匹配才能进行下去，否则会加入队列阻塞等待，直到另一个模式的线程到来唤醒</p>
<h1 id="9-参考">9. 参考</h1>
<ul>
<li><a href="https://juejin.im/post/5bcece9be51d457a765bce28" target="_blank" rel="noopener nofollow">解读 Java 并发队列 BlockingQueue - 掘金</a></li>
<li><a href="https://www.cs.rochester.edu/research/synchronization/pseudocode/queues.html" target="_blank" rel="noopener nofollow">Fast Concurrent Queue Algorithms</a></li>
<li><a href="https://www.jianshu.com/p/28c9d9e34b29" target="_blank" rel="noopener nofollow">LinkedBlockingQueue 源码分析 (基于Java 8) - 简书</a></li>
<li><a href="https://juejin.im/post/5ae754c7f265da0ba76f8534" target="_blank" rel="noopener nofollow">并发编程之 SynchronousQueue 核心源码分析 - 掘金</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.12361111111111112" data-date-updated="2025-06-26 15:30">2025-06-26 12:32</span>&nbsp;
<a href="https://www.cnblogs.com/ThinkerQAQ">ThinkerQAQ</a>&nbsp;
阅读(<span id="post_view_count">79</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18949737);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18949737', targetLink: 'https://www.cnblogs.com/ThinkerQAQ/p/18949737', title: 'Java源码分析系列笔记-12.BlockingQueue' })">举报</a>
</div>
        