
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/seven97-top/p/18928700" title="发布于 2025-06-16 09:00">
    <span role="heading" aria-level="2">你了解CAS吗？有什么问题吗？如何解决？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="什么是cas">什么是CAS？</h2>
<p>CAS全称<code>Compare And Swap</code>，比较与交换，是乐观锁的主要实现方式。CAS在不使用锁的情况下实现多线程之间的变量同步。<code>ReentrantLock</code>内部的AQS和原子类内部都使用了CAS。</p>
<p>CAS算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存值V。</li>
<li>进行比较的值A。</li>
<li>要写入的新值B。</li>
</ul>
<p>只有当V的值等于A时，才会使用原子方式用新值B来更新V的值，否则会继续重试直到成功更新值。</p>
<p>在Java中，CAS操作主要通过java.util.concurrent.atomic包中的类来实现。例如，AtomicInteger、AtomicBoolean、AtomicReference等。通过这些类的操作，Java应用可以在多线程环境下安全地对基本数据类型进行操作，而无需显式锁定。</p>
<p>以<code>AtomicInteger</code>为例，<code>AtomicInteger</code>的<code>getAndIncrement()</code>方法底层就是CAS实现，关键代码是 <code>compareAndSwapInt(obj, offset, expect, update)</code>，其含义就是，如果<code>obj</code>内的<code>value</code>和<code>expect</code>相等，就证明没有其他线程改变过这个变量，那么就更新它为<code>update</code>，如果不相等，那就会继续重试直到成功更新值。</p>
<h2 id="cas的优点存在的问题解决方案是什么">CAS的优点？存在的问题？解决方案是什么？</h2>
<p>优点：</p>
<ul>
<li>无锁机制：CAS允许许多线程尝试更新同一个变量，而无需锁定，大大减小了锁竞争。</li>
<li>性能提升：在无锁的情况下，通常会有更好的性能表现，适合高并发场景。</li>
</ul>
<p>存在的问题：</p>
<ol>
<li>
<p><strong>ABA问题</strong>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从<code>A－B－A</code>变成了<code>1A－2B－3A</code>。</p>
<p>解决方案：JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，原子更新带有版本号的引用类型。</p>
</li>
<li>
<p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。<br>
解决方案：可以使用java8中的LongAdder，分段CAS和自动分段迁移。</p>
</li>
<li>
<p><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p>
<p>解决方案：可以用AtomicReference，这个是封装自定义对象的，多个变量可以放一个自定义对象里，然后他会检查这个对象的引用是不是同一个。如果多个线程同时对一个对象变量的引用进行赋值，用AtomicReference的CAS操作可以解决并发冲突问题。</p>
</li>
</ol>
<h2 id="如何实现无锁并发">如何实现无锁并发？</h2>
<p>CAS 可以保证对共享变量操作的原子性，而volatile可以实现可见性和有序性，结合CAS和volatile可以实现无锁并发，适用于竞争不激烈，多核CPU的场景下。</p>
<p>CAS之所以效率高是因为在其内部没有使用synchronized关键字，CAS不会让线程进入阻塞状态，那么也就避免了synchronized当中用户态和内核态的切换所带来的的性能消耗问题，也避免了线程挂起等问题。如果竞争非常激烈，那么CAS就会出现线程大量重试，因为多线程来进行竞争，那么也就导致有可能很多的线程设置取值失败，那么又要进行while循环重试，即大量的线程进行重试操作，成功存的线程反而不多，那么这样的话反而会使性能大大降低。所以如果竞争太激烈还使用的是CAS机制，会导致其性能比synchronized还要低。</p>
<h2 id="扩展知识">扩展知识</h2>
<h3 id="atomicinteger">AtomicInteger</h3>
<h4 id="问题">问题</h4>
<pre><code class="language-java">public class Demo01 {
    // 定义一个共享变量 num
    private static int num = 0;

    public static void main(String[] args) throws InterruptedException {
        // 任务：对 num 进行10000次加操作
        Runnable mr = () -&gt; {
            for (int i = 0; i &lt; 10000; i++) {
                num++;    // num++并不是原子操作，就会导致原子性问题的产生
            }
        };

        ArrayList&lt;Thread&gt; ts = new ArrayList&lt;&gt;();
        // 同时开辟5个线程执行任务
        for (int i = 0; i &lt; 5; i++) {
            Thread t = new Thread(mr);
            t.start();
            ts.add(t);
        }

        for (Thread t : ts) {
            t.join();
        }
        //因此最终会输出的num &lt; 50000
        System.out.println("num = " + num);
    }
}
</code></pre>
<p>改为原子类</p>
<pre><code class="language-java">public class Demo01 {

    public static void main(String[] args) throws InterruptedException {
        // 
        AtomicInteger atomicInteger = new AtomicInteger();
        // 任务：自增 10000 次
        Runnable mr = () -&gt; {
            for (int i = 0; i &lt; 10000; i++) {
                atomicInteger.incrementAndGet();    //该自增操作是一个原子性的操作
            }
        };

        ArrayList&lt;Thread&gt; ts = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            Thread t = new Thread(mr);
            t.start();
            ts.add(t);
        }

        for (Thread t : ts) {
            t.join();
        }
        //由于是原子操作，值将一直会是50000
        System.out.println("number = " + atomicInteger.get());
    }
}
</code></pre>
<h4 id="底层源码">底层源码</h4>
<p>AtomicInteger类当中其内部会包含一个叫做UnSafe的类，该类可以保证变量在赋值时的原子操作；</p>
<pre><code class="language-java">/* AtomicInteger.java */
private volatile int value;    // value初始取值为0

public final int incrementAndGet() {
    // this：自己 new 好的 atomicInteger对象
    // valueOffset：内存偏移量
    // 1 ：这个方法时自增操作，因此是1
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
</code></pre>
<ul>
<li>
<p>变量valueOffset：表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的</p>
</li>
<li>
<p>变量value用volatile修饰：保证了多线程之间的内存可见性</p>
</li>
</ul>
<pre><code class="language-java">/* Unsafe.class */

// var1：上面的this，即atomicInteger对象；  var2：valueOffset ； var4：要添加的值
public final int getAndAddInt(Object var1, long var2, int var4) {
    // var5 旧的预估值
    int var5;
    do {
        // this 和 内存 valueOffset，目的是找出这个 value的当前最新值（旧的预估值）
        var5 = this.getIntVolatile(var1, var2);
    } while (!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
</code></pre>
<p>变量解释：</p>
<ul>
<li>
<p>var5：就是从主内存中拷贝到工作内存中的值</p>
</li>
<li>
<p>val1：AtomicInteger对象本身</p>
</li>
<li>
<p>var2：该对象值的valueOffset</p>
</li>
<li>
<p>var4：需要变动的数量</p>
</li>
<li>
<p>var5：用var1和var2找到的内存中的真实值</p>
</li>
</ul>
<p>compareAndSwapInt(var1, var2, var5, var5 + var4) 表示用该对象当前的值与var5比较</p>
<ul>
<li>
<p>如果相同，更新成var5 + var4 并返回true</p>
</li>
<li>
<p>如果不同，继续取值然后再比较，直到更新完成</p>
</li>
</ul>
<p>需要比较工作内存中的值，和主内存中的值进行比较</p>
<p>假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样</p>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404251040434.gif" alt="" loading="lazy"></p>
<p>假设线程A和线程B同时执行getAndInt操作（分别跑在不同的CPU上）</p>
<ol>
<li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存</li>
<li>线程A通过getIntVolatile(var1 , var2) 拿到value值3，这时线程A被挂起（该线程失去CPU执行权）</li>
<li>线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B没有被挂起，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK</li>
<li>这时线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4不一致，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够重新读取后在来一遍了，也就是继续执行do while</li>
<li>线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</li>
</ol>
<p>但是AtomicInteger会存在CAS循环开销大的问题，因此JDK8引入LongAdder来解决这个问题</p>
<h3 id="longadder">LongAdder</h3>
<p>LongAdder主要使用分段CAS以及自动分段迁移的方式来大幅度提升多线程高并发执行CAS操作的性能</p>
<p><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404251040438.gif" alt="" loading="lazy"></p>
<p>实现过程：</p>
<ol>
<li>在LongAdder的底层实现中，首先有一个base值，刚开始多线程来不停的累加数值，都是对base进行累加的，比如刚开始累加成了base = 5。</li>
<li>接着如果发现并发更新的线程数量过多，就会开始施行分段CAS的机制，也就是内部会搞一个Cell数组，每个数组是一个数值分段。</li>
<li>这时，让大量的线程分别去对不同Cell内部的value值进行CAS累加操作，这样就把CAS计算压力分散到了不同的Cell分段数值中了！</li>
<li>这样就可以大幅度的降低多线程并发更新同一个数值时出现的无限循环的问题，大幅度提升了多线程并发更新数值的性能和效率！</li>
<li>内部实现了自动分段迁移的机制，也就是如果某个Cell的value执行CAS失败了，那么就会自动去找另外一个Cell分段内的value值进行CAS操作。这样也解决了线程空旋转、自旋不停等待执行CAS操作的问题，让一个线程过来执行CAS时可以尽快的完成这个操作。</li>
</ol>
<p>最后，如果要从LongAdder中获取当前累加的总值，就会把base值和所有Cell分段数值加起来返回。</p>
<p>总的来说LongAdder减少了乐观锁的重试次数</p>
<h4 id="add源码">add源码</h4>
<pre><code class="language-java">public void add(long x) {
        //as 表示cells引用
        //b 表示获取的base值
        // v 表示期望值
        // m表示cells的数组长度 - 1 （cells长度一定是2的幂）
        // a表示当前现成命中的cell单元格
        Cell[] as; long b, v; int m; Cell a;
        
        //条件一： true-&gt;表示cells已经初始化过了，当前线程应该将数据写入到对应的cell中
        //            false-&gt;表示cells未初始化，当前所有线程应该将数据写入到base中
        //条件二： 要执行到条件二，说明条件一是false
        //        true-&gt; 表示发生竞争了，可能需要重试或者扩容
        //        false-&gt; 表示当前现成CAS替换数据成功，
        if ((as = cells) != null || !casBase(b = base, b + x)) {
            //什么时候进入？
            //1.条件一 true-&gt;表示cells已经初始化过了，当前线程应该将数据写入到对应的cell中
            //2.条件二 true-&gt; 表示发生竞争了，可能需要重试或者扩容
            
            // true 表示未发生竞争，false 发生竞争
            boolean uncontended = true;
            
            //条件一： true -&gt; cells未初始化，说明此时是通过 2，多线程写base发生竞争进来的
            //          false -&gt; cells初始化了，说明是 那么当前线程应该找自己的cell写值
            if (as == null || (m = as.length - 1) &lt; 0 ||
            //条件一为false，就走条件二
            //条件二：getProbe()：获取当前线程的hash值  getProbe()&amp;m 会 &lt;= m 。因此as[getProbe() &amp; m])就表示当前线程想把数据扔进去的单元格
            //        true-&gt;说明当前线程对应下标的cell为空，需要longAccumulate 创建
            //        false-&gt;说明当前线程对应下标的cell不为空，下一步想要将x值添加到cell中
                (a = as[getProbe() &amp; m]) == null ||
                
                //如果条件二位false，就走条件三
                //条件三：将x值添加到cell的过程
                //         true-&gt;表示cas添加失败，意味着当前线程对应的cell有竞争
                //        false-&gt;表示cas成功，
                !(uncontended = a.cas(v = a.value, v + x)))
                
                //什么时候会调用这个方法？
                //1. 条件一： true -&gt; cells未初始化，说明此时是通过 2，多线程写base发生竞争进来的。说明后续需要  重试 或者 初始化cells
                //2. 条件二：true-&gt;说明当前线程对应下标的cell为空，需要longAccumulate 创建
                //3. 条件三：true-&gt;表示cas添加失败，意味着当前线程对应的cell有竞争。后续需要  重试 或者 扩容
                longAccumulate(x, null, uncontended);
        }
    }
</code></pre>
<p>longAccumulate方法</p>
<pre><code class="language-java">//什么时候会调用这个方法？
//1. 条件一： true -&gt; cells未初始化，说明此时是通过 2，多线程写base发生竞争进来的。说明后续需要  重试 或者 初始化cells
//2. 条件二：true-&gt;说明当前线程对应下标的cell为空，需要longAccumulate 创建
//3. 条件三：true-&gt;表示cas添加失败，意味着当前线程对应的cell有竞争。后续需要  重试 或者 扩容

//wasUncontended：只有cells初始化之后，并且当前线程竞争修改失败，才会是false 
final void longAccumulate(long x, LongBinaryOperator fn,
                              boolean wasUncontended) {
        //当前线程的hash值
        int h;
        //条件 true-&gt;表示当前线程还未分配hash值
        if ((h = getProbe()) == 0) {
            //因此，执行分配hash值的逻辑
            ThreadLocalRandom.current(); // force initialization
            h = getProbe();
            //为什么？因为在这之前当前线程没有hash值，也就是0，那么当前线程肯定是写入到cells[0]的位置
            //如果没有分配hash值的都写到cells[0]，那就出现了cells[0]的竞争。那么就不应该把这次竞争当成真正的竞争，因此修改为true
            wasUncontended = true;
        }
        //表示 扩容意向，false：一定不会扩容；true：可能会扩容
        boolean collide = false;                // True if last slot nonempty
        
        //自旋
        for (;;) {
            // as 表示cells引用
            // a 表示当前线程命中的cell
            // n 表示cells数组长度
            // v 表示期望值
            Cell[] as; Cell a; int n; long v;
            
            //case1：条件1：true -&gt; cells已经初始化，当前线程应该写入数据到对应cell中
            //       条件2：true -&gt; 数组长度大于0，与上面一样
            if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) {
                //什么时候来到case1 
                //2. 条件二：true-&gt;说明当前线程对应下标的cell为空，需要longAccumulate 创建
                //3. 条件三：true-&gt;表示cas添加失败，意味着当前线程对应的cell有竞争。后续需要  重试 或者 扩容
                //case 1.1：true -&gt; 当前线程对应下标的cell为空，需要创建cell
                if ((a = as[(n - 1) &amp; h]) == null) {
                    //true-&gt;当前是无锁未被占用，false-&gt;锁被占用
                    if (cellsBusy == 0) {       // Try to attach new Cell
                        //创建cell
                        Cell r = new Cell(x);   // Optimistically create
                        //条件一：cellsBusy == 0
                        //            true-&gt;当前无锁，当前线程可以竞争这把锁
                        //条件二：casCellsBusy()，竞争锁
                        //            true-&gt;当前线程获取锁
                        if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {
                            //定义是否创建成功的标记
                            boolean created = false;
                            try {               // Recheck under lock
                                //rs表示当前cells引用
                                //m cells长度
                                //j 当前线程命中下标
                                Cell[] rs; int m, j;
                                
                                //条件一条件二恒成立
                                //条件三：rs[j = (m - 1) &amp; h] == null？ 在case1.1时已经判断过这个位置了，为什么这里还要判断？
                                //原因是多线程并发情况下，有线程可能已经在执行下述流程，此时在case1.1判断为null，但到这里已经有线程执行过了，因此需要重新判断
                                if ((rs = cells) != null &amp;&amp;
                                    (m = rs.length) &gt; 0 &amp;&amp;
                                    rs[j = (m - 1) &amp; h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                //释放锁
                                cellsBusy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                    }
                    //扩容意向改为false
                    collide = false;
                }
                //case 1.2: wasUncontended：只有cells初始化之后，并且当前线程竞争修改失败，才会是false 
                else if (!wasUncontended)       // CAS already known to fail
                    wasUncontended = true;      // Continue after rehash
                //case1.3：什么时候到这，当前线程重置过hash值。新命中的cell不为空
                //        true-&gt;将数据写入cell成功，那就可以退出了
                //        false-&gt;表示重置hash后命中的新的cell也有竞争，重试1次，会执行case1.4
                else if (a.cas(v = a.value, ((fn == null) ? v + x :
                                             fn.applyAsLong(v, x))))
                    break;
                //case1.4：n&gt;=NCPU
                //            true-&gt;数组长度大于等于CPU数量
                //            false-&gt;数组长度还可以扩容
                //        cells != as？
                //            true-&gt;其它线程已经扩容过了，当前线程就应该重置hash重试
                else if (n &gt;= NCPU || cells != as)
                    //扩容意向改为false
                    collide = false;            // At max size or stale
                //case1.5：!collide
                //         true-&gt;表示设置扩容意向为true，但不一定扩容，因为需要自旋重新尝试
                else if (!collide)
                    collide = true;
                //case 1.6：真正扩容的逻辑
                //    条件一：cellsBusy == 0
                //            true-&gt;当前无锁，当前线程可以竞争这把锁
                //条件二：casCellsBusy()，竞争锁
                //            true-&gt;当前线程获取锁，当前线程执行可以扩容逻辑
                //false就说明有其他线程在执行扩容
                else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {
                    try {
                        //这里与之前的逻辑一致，需要再次判断
                        if (cells == as) {      // Expand table unless stale
                            Cell[] rs = new Cell[n &lt;&lt; 1];//扩容长度翻倍，长度是2的幂
                            for (int i = 0; i &lt; n; ++i)
                                rs[i] = as[i];
                            cells = rs;
                        }
                    } finally {
                        cellsBusy = 0;
                    }
                    collide = false;
                    continue;                   // Retry with expanded table
                }
                
                //重置当前线程hash值
                h = advanceProbe(h);
            }
            
            //case2: 显然要到case2，case1就为false,也就是cells还未初始化，as为null
            //         条件一：true -&gt; 当前未加锁
            //        条件二：cells == as？ 原因在多线程并发情况下，有线程可能已经在执行下述流程，此时在case1判断为null，但到case2可能已经扩容完成了，cells可能就不为null了
            //        条件三：true -&gt; 表示获取锁成功，casCellsBusy() = 1。
            //                false -&gt; 表示其它线程正在持有锁
            else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy() = 1。
            ) {
                boolean init = false;
                try {                           // Initialize table
                    //为了防止其它线程已经初始化了，当前线程再次初始化，丢失数据
                    if (cells == as) {
                        Cell[] rs = new Cell[2];
                        rs[h &amp; 1] = new Cell(x);
                        cells = rs;
                        init = true;
                    }
                } finally {
                    //释放锁
                    cellsBusy = 0;
                }
                if (init)
                    break;
            }
            //case3：什么时候会到这个条件。
            //1. 当前casCellsBusy()锁已经被持有，说明其他线程正在初始化cells
            //2. cells被其他线程初始化了
            //那么此时就应该去累加数据了
            else if (casBase(v = base, ((fn == null) ? v + x :
                                        fn.applyAsLong(v, x))))
                break;                          // Fall back on using base
        }
    }
</code></pre>
<h3 id="atomicstampedreference">AtomicStampedReference</h3>
<p>AtomicStampedReference主要维护包含一个对象引用以及一个可以自动更新的整数"stamp"的pair对象来解决ABA问题。</p>
<pre><code class="language-java">public class AtomicStampedReference&lt;V&gt; {
    private static class Pair&lt;T&gt; {
        final T reference;  //维护对象引用
        final int stamp;  //用于标志版本
        private Pair(T reference, int stamp) {
            this.reference = reference;
            this.stamp = stamp;
        }
        static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) {
            return new Pair&lt;T&gt;(reference, stamp);
        }
    }
    private volatile Pair&lt;V&gt; pair;
    ....
    
    /**
      * expectedReference ：更新之前的原始值
      * newReference : 将要更新的新值
      * expectedStamp : 期待更新的标志版本
      * newStamp : 将要更新的标志版本
      */
    public boolean compareAndSet(V   expectedReference,
                             V   newReference,
                             int expectedStamp,
                             int newStamp) {
        // 获取当前的(元素值，版本号)对
        Pair&lt;V&gt; current = pair;
        return
            // 引用没变
            expectedReference == current.reference &amp;&amp;
            // 版本号没变
            expectedStamp == current.stamp &amp;&amp;
            // 新引用等于旧引用
            ((newReference == current.reference &amp;&amp;
            // 新版本号等于旧版本号
            newStamp == current.stamp) ||
            // 构造新的Pair对象并CAS更新
            casPair(current, Pair.of(newReference, newStamp)));
    }

    private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) {
        // 调用Unsafe的compareAndSwapObject()方法CAS更新pair的引用为新引用
        return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);
    }
</code></pre>
<ul>
<li>
<p>如果元素值和版本号都没有变化，并且和新的也相同，返回true；</p>
</li>
<li>
<p>如果元素值和版本号都没有变化，并且和新的不完全相同，就构造一个新的Pair对象并执行CAS更新pair。</p>
</li>
</ul>
<p>可以看到，java中的实现跟我们上面讲的ABA的解决方法是一致的。</p>
<ul>
<li>首先，使用版本号控制；</li>
<li>其次，不重复使用节点(Pair)的引用，每次都新建一个新的Pair来作为CAS比较的对象，而不是复用旧的；</li>
<li>最后，外部传入元素值及版本号，而不是节点(Pair)的引用。</li>
</ul>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自在线网站：seven的菜鸟成长之路，作者：seven，转载请注明原文链接：www.seven97.top</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-16 09:00">2025-06-16 09:00</span>&nbsp;
<a href="https://www.cnblogs.com/seven97-top">SevenCoder</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18928700);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18928700', targetLink: 'https://www.cnblogs.com/seven97-top/p/18928700', title: '你了解CAS吗？有什么问题吗？如何解决？' })">举报</a>
</div>
        