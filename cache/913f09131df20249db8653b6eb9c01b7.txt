
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chenshibao/p/18635870" title="发布于 2024-12-27 15:19">
    <span role="heading" aria-level="2">redis缓存穿透和 缓存雪崩</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在使用Redis作为缓存系统时，缓存穿透（Cache Penetration） 和 缓存雪崩（Cache Avalanche） 是两种常见的问题。它们会影响缓存系统的性能和稳定性。以下是这两种问题的详细解释及其解决方法。</p>
<h3 id="缓存穿透cache-penetration">缓存穿透（Cache Penetration）</h3>
<p>缓存穿透是指查询一个在缓存和数据库中都不存在的数据，导致请求直接穿透到数据库，增加了数据库的负载。</p>
<h4 id="成因">成因</h4>
<ol>
<li>恶意查询：
<ul>
<li>攻击者故意查询一些在缓存和数据库中都不存在的数据。</li>
</ul>
</li>
<li>误操作：
<ul>
<li>
<p>用户或系统误操作查询了不存在的数据。<br>
示例<br>
假设有一个用户查询接口，用户ID 123456 不存在于缓存和数据库中。</p>
<pre><code>  public async Task&lt;User&gt; GetUserAsync(int userId)
  {
  	// 尝试从缓存中获取用户
  	string userJson = await _redisCache.GetStringAsync($"user:{userId}");
  	if (userJson != null)
  	{
  		return JsonSerializer.Deserialize&lt;User&gt;(userJson);
  	}

  	// 从数据库中获取用户
  	User user = await _userRepository.GetByIdAsync(userId);
  	if (user != null)
  	{
  		// 将用户存入缓存
  		await _redisCache.SetStringAsync($"user:{userId}", JsonSerializer.Serialize(user));
  	}

  	return user;
  }
</code></pre>
</li>
</ul>
</li>
</ol>
<p>如果查询的用户ID 123456 不存在，每次查询都会直接穿透到数据库，增加数据库负载。</p>
<h3 id="解决缓存穿透的方法">解决缓存穿透的方法</h3>
<ol>
<li>缓存空值：
<ul>
<li>将查询结果为空的数据也缓存起来，设置一个较短的过期时间。</li>
</ul>
</li>
<li>布隆过滤器（Bloom Filter）：
<ul>
<li>使用布隆过滤器来预先判断一个请求是否可能命中缓存，减少对数据库的无效查询。</li>
</ul>
</li>
<li>参数校验：
<ul>
<li>在查询缓存之前，对查询参数进行校验，确保参数的有效性。</li>
</ul>
</li>
<li>限流和熔断：
<ul>
<li>使用限流（Rate Limiting）和熔断（Circuit Breaking）机制来控制对数据库的请求。</li>
</ul>
</li>
</ol>
<p>示例：缓存空值</p>
<pre><code>		public async Task&lt;User&gt; GetUserAsync(int userId)
		{
			// 尝试从缓存中获取用户
			string userJson = await _redisCache.GetStringAsync($"user:{userId}");
			if (userJson != null)
			{
				if (userJson == "null")
				{
					return null;
				}
				return JsonSerializer.Deserialize&lt;User&gt;(userJson);
			}

			// 从数据库中获取用户
			User user = await _userRepository.GetByIdAsync(userId);
			if (user != null)
			{
				// 将用户存入缓存
				await _redisCache.SetStringAsync($"user:{userId}", JsonSerializer.Serialize(user), TimeSpan.FromMinutes(10));
			}
			else
			{
				// 缓存空值
				await _redisCache.SetStringAsync($"user:{userId}", "null", TimeSpan.FromMinutes(1));
			}

			return user;
		}
</code></pre>
<p>示例：布隆过滤器</p>
<pre><code>		public class BloomFilterExample
		{
			private readonly BloomFilter _bloomFilter;
			private readonly IRedisCache _redisCache;
			private readonly IUserRepository _userRepository;

			public BloomFilterExample(BloomFilter bloomFilter, IRedisCache redisCache, IUserRepository userRepository)
			{
				_bloomFilter = bloomFilter;
				_redisCache = redisCache;
				_userRepository = userRepository;
			}

			public async Task&lt;User&gt; GetUserAsync(int userId)
			{
				// 使用布隆过滤器预先判断用户ID是否存在
				if (!_bloomFilter.Contains(userId))
				{
					return null;
				}

				// 尝试从缓存中获取用户
				string userJson = await _redisCache.GetStringAsync($"user:{userId}");
				if (userJson != null)
				{
					return JsonSerializer.Deserialize&lt;User&gt;(userJson);
				}

				// 从数据库中获取用户
				User user = await _userRepository.GetByIdAsync(userId);
				if (user != null)
				{
					// 将用户存入缓存
					await _redisCache.SetStringAsync($"user:{userId}", JsonSerializer.Serialize(user), TimeSpan.FromMinutes(10));
				}
				else
				{
					// 缓存空值
					await _redisCache.SetStringAsync($"user:{userId}", "null", TimeSpan.FromMinutes(1));
				}

				return user;
			}
		}
</code></pre>
<h3 id="缓存雪崩cache-avalanche">缓存雪崩（Cache Avalanche）</h3>
<p>缓存雪崩是指在某个时间点，大量的缓存数据同时过期，导致大量请求直接穿透到数据库，增加数据库负载，甚至可能导致数据库崩溃。</p>
<h4 id="成因-1">成因</h4>
<ol>
<li>缓存过期时间一致：
<ul>
<li>大量缓存数据设置相同的过期时间，导致同时过期。</li>
</ul>
</li>
<li>缓存预热失败：
<ul>
<li>缓存预热（Cache Warm-up）机制失败，导致缓存数据在短时间内大量过期。</li>
</ul>
</li>
<li>系统重启或故障：
<ul>
<li>系统重启或故障导致缓存数据被清除，大量请求直接穿透到数据库。</li>
</ul>
</li>
</ol>
<h4 id="解决缓存雪崩的方法">解决缓存雪崩的方法</h4>
<ol>
<li>设置不同的过期时间：
<ul>
<li>将缓存数据的过期时间设置为不同的随机值，避免同时过期。</li>
</ul>
</li>
<li>分批过期：
<ul>
<li>将缓存数据分批设置不同的过期时间，减少短时间内大量数据过期的情况。</li>
</ul>
</li>
<li>缓存预热：
<ul>
<li>系统启动时或定期预热缓存，确保缓存中有足够的数据，减少缓存数据被清除后的压力。</li>
</ul>
</li>
<li>限流和熔断：
<ul>
<li>使用限流和熔断机制来控制对数据库的请求，防止数据库过载。</li>
</ul>
</li>
<li>本地缓存：
<ul>
<li>使用本地缓存（如内存缓存）来临时存储数据，减少对数据库的直接访问。</li>
</ul>
</li>
<li>双缓存：
<ul>
<li>使用两级缓存，如Redis和本地缓存，提高缓存的稳定性和可靠性。</li>
</ul>
</li>
</ol>
<p>示例：设置不同的过期时间</p>
<pre><code>		public async Task&lt;User&gt; GetUserAsync(int userId)
		{
			// 尝试从缓存中获取用户
			string userJson = await _redisCache.GetStringAsync($"user:{userId}");
			if (userJson != null)
			{
				return JsonSerializer.Deserialize&lt;User&gt;(userJson);
			}

			// 从数据库中获取用户
			User user = await _userRepository.GetByIdAsync(userId);
			if (user != null)
			{
				// 设置随机的过期时间
				Random random = new Random();
				int randomMinutes = random.Next(5, 15); // 随机过期时间在5到15分钟之间
				await _redisCache.SetStringAsync($"user:{userId}", JsonSerializer.Serialize(user), TimeSpan.FromMinutes(randomMinutes));
			}
			else
			{
				// 缓存空值
				await _redisCache.SetStringAsync($"user:{userId}", "null", TimeSpan.FromMinutes(1));
			}

			return user;
		}
</code></pre>
<p>示例：缓存预热</p>
<pre><code>		public class CacheWarmupExample
		{
			private readonly IRedisCache _redisCache;
			private readonly IUserRepository _userRepository;

			public CacheWarmupExample(IRedisCache redisCache, IUserRepository userRepository)
			{
				_redisCache = redisCache;
				_userRepository = userRepository;
			}

			public async Task WarmupCacheAsync()
			{
				// 获取所有用户ID
				List&lt;int&gt; userIds = await _userRepository.GetAllUserIdsAsync();

				foreach (int userId in userIds)
				{
					User user = await _userRepository.GetByIdAsync(userId);
					if (user != null)
					{
						// 设置随机的过期时间
						Random random = new Random();
						int randomMinutes = random.Next(5, 15); // 随机过期时间在5到15分钟之间
						await _redisCache.SetStringAsync($"user:{userId}", JsonSerializer.Serialize(user), TimeSpan.FromMinutes(randomMinutes));
					}
					else
					{
						// 缓存空值
						await _redisCache.SetStringAsync($"user:{userId}", "null", TimeSpan.FromMinutes(1));
					}
				}
			}

			public async Task&lt;User&gt; GetUserAsync(int userId)
			{
				// 尝试从缓存中获取用户
				string userJson = await _redisCache.GetStringAsync($"user:{userId}");
				if (userJson != null)
				{
					if (userJson == "null")
					{
						return null;
					}
					return JsonSerializer.Deserialize&lt;User&gt;(userJson);
				}

				// 从数据库中获取用户
				User user = await _userRepository.GetByIdAsync(userId);
				if (user != null)
				{
					// 设置随机的过期时间
					Random random = new Random();
					int randomMinutes = random.Next(5, 15); // 随机过期时间在5到15分钟之间
					await _redisCache.SetStringAsync($"user:{userId}", JsonSerializer.Serialize(user), TimeSpan.FromMinutes(randomMinutes));
				}
				else
				{
					// 缓存空值
					await _redisCache.SetStringAsync($"user:{userId}", "null", TimeSpan.FromMinutes(1));
				}

				return user;
			}
		}
</code></pre>
<h4 id="总结">总结</h4>
<ol>
<li>缓存穿透（Cache Penetration）：<br>
成因：查询在缓存和数据库中都不存在的数据。<br>
解决方法：
<ul>
<li>缓存空值</li>
<li>布隆过滤器</li>
<li>参数校验</li>
<li>限流和熔断</li>
</ul>
</li>
<li>缓存雪崩（Cache Avalanche）：<br>
成因：大量缓存数据同时过期，导致大量请求直接穿透到数据库。<br>
解决方法：
<ul>
<li>设置不同的过期时间</li>
<li>分批过期</li>
<li>缓存预热</li>
<li>限流和熔断</li>
<li>本地缓存</li>
<li>双缓存</li>
</ul>
</li>
</ol>
<p>参考资源</p>
<ul>
<li>Redis 官方文档：<br>
<a href="https://redis.io/docs/latest/" title="Redis 官方文档" target="_blank" rel="noopener nofollow">Redis 官方文档</a></li>
<li>布隆过滤器：<br>
<a href="https://en.wikipedia.org/wiki/Bloom_filter" title="布隆过滤器介绍" target="_blank" rel="noopener nofollow">布隆过滤器介绍</a></li>
<li>限流和熔断：<br>
<a href="https://en.wikipedia.org/wiki/Rate_limiting" title="限流" target="_blank" rel="noopener nofollow">限流</a><br>
<a href="https://martinfowler.com/bliki/CircuitBreaker.html" title="熔断" target="_blank" rel="noopener nofollow">熔断</a></li>
<li>缓存预热：<br>
<a href="https://en.wikipedia.org/wiki/Warming_up" title="缓存预热" target="_blank" rel="noopener nofollow">缓存预热</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3739894659375" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-27 15:20">2024-12-27 15:19</span>&nbsp;
<a href="https://www.cnblogs.com/chenshibao">似梦亦非梦</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18635870" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18635870);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18635870', targetLink: 'https://www.cnblogs.com/chenshibao/p/18635870', title: 'redis缓存穿透和 缓存雪崩' })">举报</a>
</div>
        