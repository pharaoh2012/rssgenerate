
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhennann/p/19028145" title="发布于 2025-08-08 11:39">
    <span role="heading" aria-level="2">如何基于动态关系进行ORM关联查询，并动态推断DTO？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1462384/202508/1462384-20250808113818385-895686454.png" alt="如何基于动态关系进行ORM关联查询，并动态推断DTO？" class="desc_img">
        如果事先没有定义静态关系，在实际代码中，我们就需要提供一种使用动态关系的机制，让我们的查询、类型推断、DTO推断等能力得以正常使用。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在上一篇文章（<a href="https://juejin.cn/post/7534568184419893275" target="_blank" rel="noopener nofollow">Prisma不能优雅的支持DTO，试试Vona ORM吧</a>）中，我们基于静态关系实现了<code>目录树</code>的关联查询，并且动态推断生成了DTO（用于Swagger元数据）。在这篇文章我们探讨<code>动态关系</code>的用法。</p>
<h2 id="什么是动态关系">什么是动态关系</h2>
<p>那么，什么是动态关系呢？在大型业务系统中，我们会创建大量数据模型，这些数据模型之间的关联众多，我们不可能将所有关联通过<code>静态关系</code>的机制事先声明出来。特别是当存在大量业务模块，这些数据模型散落在不同的业务模块中，那么通过<code>静态关系</code>事先声明所有的关联关系也变得不太现实。比如，Prisma就只支持<code>静态关系</code>。如果事先没有定义<code>静态关系</code>，在实际代码中，我们就需要提供一种使用<code>动态关系</code>的机制，让我们的查询、类型推断、DTO推断等能力得以正常使用。</p>
<h2 id="准备数据模型">准备数据模型</h2>
<p>在上一篇文章中，我们已经介绍了如何创建Entity和Model，这里不再赘述。而是直接把Order和Customer的Entity和Model罗列出来，然后演示<code>动态关系</code>的用法</p>
<h3 id="entity">Entity</h3>
<h4 id="1-order">1. Order</h4>
<pre><code class="language-typescript">@Entity()
export class EntityOrder extends EntityBase {
  @Api.field(v.openapi({ title: $locale('OrderNo') }), v.default(''), v.min(3))
  orderNo: string;

  @Api.field(v.title($locale('Remark')), v.optional())
  remark?: string;

  @Api.field(v.tableIdentity())
  customerId: TableIdentity;
}
</code></pre>
<ul>
<li>v.openapi：声明字段的元数据，用于Swagger
<ul>
<li>title：采用$locale定义，从而让Swagger元数据支持多语言能力</li>
</ul>
</li>
<li>v.title：等价于v.openapi({ title: ... })</li>
<li>TableIdentity：string | number</li>
</ul>
<h4 id="2-customer">2. Customer</h4>
<pre><code class="language-typescript">@Entity()
export class EntityCustomer extends EntityBase {
  @Api.field(v.min(3))
  name: string;
}
</code></pre>
<h3 id="model">Model</h3>
<h4 id="1-order-1">1. Order</h4>
<pre><code class="language-typescript">@Model({ entity: EntityOrder })
export class ModelOrder extends BeanModelBase {}
</code></pre>
<h4 id="2-customer-1">2. Customer</h4>
<pre><code class="language-typescript">@Model({ entity: EntityCustomer })
export class ModelCustomer extends BeanModelBase {}
</code></pre>
<h2 id="基于动态关系的查询">基于<code>动态关系</code>的查询</h2>
<p>现在我们查询订单列表，包含归属的顾客信息：</p>
<pre><code class="language-typescript">const orders = await this.scope.model.order.select({
  with: {
    customer: $relationDynamic.belongsTo(
      () =&gt; ModelOrder,
      () =&gt; ModelCustomer,
      'customerId',
    ),
  },
});
</code></pre>
<ul>
<li>$relationDynamic:提供一组工具，用于定义动态关系</li>
<li>belongsTo：定义<code>多对一</code>的关系
<ul>
<li>参数1：Order模型</li>
<li>参数2：Customer模型</li>
<li>参数3：设置关联外键customerId</li>
</ul>
</li>
</ul>
<p>下面我们看一下<code>orders</code>的类型推断效果：</p>
<p><img alt="6" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1462384/202508/1462384-20250808113703464-315060510.png" class="lazyload"></p>
<p><img alt="7" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1462384/202508/1462384-20250808113709389-1988259359.png" class="lazyload"></p>
<h2 id="自动推断dto">自动推断DTO</h2>
<p>现在我们自动推断DTO，并且设为API的返回数据的类型：</p>
<pre><code class="language-typescript">const DtoOrderResult = $Dto.get(
  () =&gt; ModelOrder,
  {
    with: {
      customer: $relationDynamic.belongsTo(
        () =&gt; ModelOrder,
        () =&gt; ModelCustomer,
        'customerId',
      ),
    },
  },
);

@Controller('order')
export class ControllerOrder extends BeanBase {
  @Web.get()
  @Api.body(v.array(v.object(DtoOrderResult)))
  async findAll() {
    return await this.scope.service.order.findAll();
  }
}  
</code></pre>
<ul>
<li>行1：动态创建<code>DtoOrderResult</code></li>
<li>行17：将<code>DtoOrderResult</code>用于Swagger/Openapi的元数据</li>
</ul>
<p>下面我们看一下API的Swagger效果：</p>
<p><img alt="8" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1462384/202508/1462384-20250808113638509-1695597752.png" class="lazyload"></p>
<h2 id="封装dto">封装DTO</h2>
<p>我们还可以创建一个新的DTO，将前面动态创建的<code>DtoOrderResult</code>封装起来，从而用于其他地方：</p>
<p>在VSCode中，可以通过右键菜单<code>Vona Create/Dto</code>创建DTO的代码骨架：</p>
<pre><code class="language-typescript">@Dto()
export class DtoOrderResult {}
</code></pre>
<p>然后我们通过继承机制来封装DTO：</p>
<pre><code class="language-typescript">const DtoOrderResultDynamic = $Dto.get(
  () =&gt; ModelOrder,
  {
    with: {
      customer: $relationDynamic.belongsTo(
        () =&gt; ModelOrder,
        () =&gt; ModelCustomer,
        'customerId',
      ),
    },
  },
);

@Dto()
export class DtoOrderResult extends DtoOrderResultDynamic {}
</code></pre>
<p>现在，我们再使用新创建的DTO来改造前面的API代码：</p>
<pre><code class="language-diff">+ import { DtoOrderResult } from '../dto/orderResult.ts';

@Controller('order')
export class ControllerOrder extends BeanBase {
  @Web.get()
+ @Api.body(v.array(v.object(DtoOrderResult)))
+ async findAll(): Promise&lt;DtoOrderResult[]&gt; {
    return await this.scope.service.order.findAll();
  }
}
</code></pre>
<ul>
<li>行6: 直接传入<code>DtoOrderResult</code></li>
<li>行7: 返回类型为<code>Promise&lt;DtoOrderResult[]&gt;</code></li>
</ul>
<h2 id="结语">结语</h2>
<p>Vonajs已开源：<a href="https://github.com/vonajs/vona" target="_blank" rel="noopener nofollow">https://github.com/vonajs/vona</a>。</p>
<p>Vonajs作者正在B站直播撰写技术文档，工作日每晚8:30，欢迎围观：<a href="https://space.bilibili.com/454737998" target="_blank" rel="noopener nofollow">濮水代码直播间</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-08 11:39">2025-08-08 11:39</span>&nbsp;
<a href="https://www.cnblogs.com/zhennann">濮水大叔</a>&nbsp;
阅读(<span id="post_view_count">155</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19028145);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19028145', targetLink: 'https://www.cnblogs.com/zhennann/p/19028145', title: '如何基于动态关系进行ORM关联查询，并动态推断DTO？' })">举报</a>
</div>
        