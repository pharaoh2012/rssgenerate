
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TheMagicalRainbowSea/p/18698571" title="发布于 2025-02-04 22:34">
    <span role="heading" aria-level="2">九. Redis 持久化-RDB(详细讲解说明，一个配置一个说明分析，步步讲解到位)</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="九-redis-持久化-rdb详细讲解说明一个配置一个说明分析步步讲解到位">九. Redis 持久化-RDB(详细讲解说明，一个配置一个说明分析，步步讲解到位)</h1>
<p>@</p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#九-redis-持久化-rdb详细讲解说明一个配置一个说明分析步步讲解到位" rel="noopener nofollow">九. Redis 持久化-RDB(详细讲解说明，一个配置一个说明分析，步步讲解到位)</a></li><li><a href="#1-rdb-概述" rel="noopener nofollow">1. RDB 概述</a></li><li><a href="#2-rdb-持久化执行流程" rel="noopener nofollow">2. RDB 持久化执行流程</a></li><li><a href="#3-rdb-的详细配置" rel="noopener nofollow">3. RDB 的详细配置</a></li><li><a href="#4-rdb-备份恢复" rel="noopener nofollow">4. RDB 备份&amp;恢复</a></li><li><a href="#5-rdb-持久化小结优势-和-劣势" rel="noopener nofollow">5. RDB 持久化小结(优势 和 劣势)</a></li><li><a href="#6-最后" rel="noopener nofollow">6. 最后：</a></li></ul></div><p></p>
<hr>
<p><strong>Redis 持久化-RDB：官网文档地址：</strong> <a href="https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/" target="_blank" rel="noopener nofollow">https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/</a></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728247-1555900805.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>Redis 关于持久化方案：有两种：</strong></p>
<ol>
<li>RDB(Redis DataBase)</li>
<li>AOF(Append Of File)</li>
</ol>
<blockquote>
<p>这里我们主要介绍  RDB 持久化方案，AOF 持久化方案，在下一篇文章当中。</p>
</blockquote>
<h1 id="1-rdb-概述">1. RDB 概述</h1>
<p><strong>RDB 是什么 ?：</strong></p>
<p>在指定的时间间隔内将内存当中的数据集快照写入到磁盘当中，也就是 <code>Snapshot</code> 快照，恢复时将快照文件当中的内容读取到<strong>内存</strong> 当中。</p>
<h1 id="2-rdb-持久化执行流程">2. RDB 持久化执行流程</h1>
<p><strong>RDB 及其执行流程：</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728068-1097413961.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>对上图的解读：</strong></p>
<p><strong>具体流程如下：</strong></p>
<blockquote>
<ol>
<li>Redis 客户端执行 bgsave 命令或者自动触发 bgsave 命令。</li>
<li>主进程判断当前是否已经存在<strong>正在执行的子进程</strong> ，如果存在，那么主进程直接返回。</li>
<li>如果不存在，<strong>正在执行的子进程</strong> ，那么就 fork 一个新的子进程进行持久化数据，fork 过程是阻塞的，fork 操作完成后主进程即可执行其它操作。</li>
<li>子进程先将数据写入到 <strong>临时的 <code>rdb</code> 文件中</strong> ，待快照数据写入完成后，再原子替换旧的 <code>rdb</code> 文件。</li>
<li>同时发送信号给主进程，通知主进程 <code>rdb</code> 持久化完成，主进程更新相关的统计信息。</li>
</ol>
</blockquote>
<p><strong>小结：</strong></p>
<blockquote>
<ol>
<li>整个过程中，主进程是不进行任何 <strong>IO</strong> 操作的，这就确保了极高的性能。</li>
<li>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。</li>
<li>RDB的缺点是最后一次持久化的数据可能丢失。</li>
</ol>
<p>如果你是正常关闭 Redis ，仍然会进行持久化，不会造成数据丢失。</p>
<p>如果是 Redis <strong>异常终止/宕机</strong> ，就可能造成数据丢失。</p>
<p>后面在讲解快照配置的时候，进行说明。</p>
</blockquote>
<p><strong>Fork&amp;Copy-On-Write：</strong></p>
<ol>
<li>
<p>Fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据(变量，环境变量，程序计数器等)数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p>
</li>
<li>
<p>在 Linux 程序中，fork() 会产生一个和父进程完全相同的子进程，但子进程在此后都会 exec 系统调用，出于效率考虑，Linux 中引入了 <strong>“写时复制技术 即：copy-on-write”</strong> ，有兴趣的可以移步至🌟🌟🌟 <a href="https://blog.csdn.net/Code_beeps/article/details/92838520" target="_blank" rel="noopener nofollow">https://blog.csdn.net/Code_beeps/article/details/92838520</a> 一位网友的解读。</p>
</li>
<li>
<p>一般情况父进程和子进程会共用一段物理内存，只有进程空间的各段的内容要发送变化时，才会将父进程的内容复制一份给子进程。</p>
</li>
</ol>
<h1 id="3-rdb-的详细配置">3. RDB 的详细配置</h1>
<ol>
<li><strong>默认快照配置：</strong></li>
</ol>
<p>Redis 当中的快照的文件是名为 <code>dump.rdb</code> 文件，这是默认的。</p>
<p>在 /etc/redis.conf 中配置文件名称当中，存在这个 <code>dump.rdb</code> 的配置。<br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727912-1435307234.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>如何配置</p>
<p>默认为 Redis 启动时命令行所在的目录下：</p>
<blockquote>
<p>意思就是：默认会将 “dump.rdb” 快照文件存储到 Redis 启动时命令行所在的目录下<br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728239-1787421806.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<p><strong>重点：</strong> 进入到<code>/usr/local/bin</code>  目录下,  启动 Redis,    这个那么这里的  <code>./ </code> 所指的路径就是 <code> /usr/local/bin</code> ,  如果你在 <code>/root/ </code>目录下启动  Redis ,  那么这里<code> ./</code> 所指的就是  <code>/root</code>/  下了路径  ,  这点请大家注意。</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728080-1560196738.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p><strong>那么这样的默认配置就存在一个问题，那就是，如果我们每次去到不同的目录下启动 redis 的化，那么这个<code>dump.rdb</code>（快照存储我们信息/数据的文件） 就会存储到不同的目录下，这样就导致了，如果该目录下没有我们之前执行存储的数据的 <code>dump.rdb</code> 文件的话，我们Redis 就无法读取到该存有我们之前<code>dump.rdb</code> 数据的文件，也就无法恢复我们之前存储操作的数据了。</strong></p>
<p><strong>演示：</strong></p>
<pre><code class="language-tex">我们创建两个目录：分别是: test01，和 test02
在 test01 目录下执行 set k1 "test01"  同时查看该目录下是否生成 dump.rdb(快照文件)
在 test02 目录下执行 set k2 "test02" 同时查看该目录下是否生成 dump.rdb(快照文件)
</code></pre>
<pre><code class="language-sh">[root@localhost home]# mkdir test01 # 创建目录
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728248-1860237829.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<blockquote>
<pre><code class="language-sh">[root@localhost test01]# redis-cli
127.0.0.1:6379&gt; keys *
(error) NOAUTH Authentication required.
127.0.0.1:6379&gt; auth rainbowsea
OK
127.0.0.1:6379&gt; keys *
(empty array)
127.0.0.1:6379&gt; set k1 "test01"
OK
127.0.0.1:6379&gt; keys *
1) "k1"

</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728066-2072051585.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727977-919356141.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<blockquote>
<p>同理执行：test02</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727944-934298843.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727855-1338571510.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<p><strong>怎么解决这个，Redis 在不同的目录下，导致数据存储快照不同，数据没有跟上？</strong></p>
<p>我们可以自定义配置好这个 dump.rdb 文件的存放路径，不是默认的<code>dir./</code>(根据启动Redis目录不同而变化) ，而是一直配置在一个固定的路径下。就可以解决这个问题了。</p>
<p><strong>这里我们将其配置到 <code>/root/ </code>目录下，这样我们每次生成的 dump.rdb 文件就一直是在同一个路径的目录下了</strong></p>
<pre><code class="language-properties">dir /root/
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727949-1097836725.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p><strong>注意：需要关闭 Redis 服务，重新启动 Redis 服务，配置才会生效</strong> 。</p>
<pre><code class="language-sh">[root@localhost test02]# redis-server /etc/redis.conf
[root@localhost test02]# redis-cli
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727915-1746463485.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727922-1214854932.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<ol start="2">
<li><strong>save 和 bgsave</strong></li>
</ol>
<pre><code class="language-sh">127.0.0.1:6379&gt; save
</code></pre>
<pre><code class="language-sh">127.0.0.1:6379&gt; bgsave
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727797-898923423.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>默认的快照配置：</strong> 如图：同样是在 `/etc/redis.conf文件当中配置的。<br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727947-1902263498.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728216-2087698895.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>注意理解这个时间段的概念.：</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727891-843131704.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>如果我们没有开启 save 的注释 那么在退出,Redis 时   也会进行备份   更新 dump.rdb 文件的。</p>
<ul>
<li><strong>save ：</strong> save 时只管保存，其它不管，全部阻塞。手动保存，不建议。</li>
<li><strong>bgsave：</strong>  Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。</li>
<li>可以通过 <strong>lastave</strong>  命令获取最后一次成功执行快照的时间(unix 时间戳)，可以使用工具转换。<a href="https://tool.lu/timestamp/" target="_blank" rel="noopener nofollow">https://tool.lu/timestamp/</a></li>
</ul>
<ol start="3">
<li><strong>flushall</strong></li>
</ol>
<ul>
<li>执行 flushall 命令，也会产生 dump.rdb 文件，数据为空。</li>
<li><code>Redis Flushall</code> 命令用于清空整个 Redis 服务器的数据(删除所有数据库的所有 key )<br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728064-801347360.png" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728075-1403666438.png" alt="在这里插入图片描述" loading="lazy"></p>
<ol start="4">
<li><strong>Save</strong></li>
</ol>
<p>格式：save 秒钟  写操作次数,  如图</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728083-2059240994.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728167-346056623.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>RDB 是整个内存的压缩过的 Snapshot，RDB 的数据结构，可以配置复合的快照触发条件</strong> 。</p>
<p><strong>禁用：给 save 传空字符串，可以看文档：</strong></p>
<ol start="5">
<li><strong>stop-writes-on-bgsave-error</strong><br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728071-1163521156.png" alt="在这里插入图片描述" loading="lazy"></li>
</ol>
<blockquote>
<p>意思是：<strong>当 Redis 无法写入磁盘的话(比如磁盘满了),  直接关掉 Redis 的写操作。推荐 yes</strong></p>
</blockquote>
<ol start="6">
<li><strong>rdbcompression</strong></li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728118-1057793637.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>该配置的意思是：</strong></p>
<blockquote>
<ol>
<li>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis 会采用 <strong>LZF</strong> 算法进行压缩。</li>
<li>如果你不想消耗 CPU 来进行压缩的话，可以设置为关闭此功能，默认 yes。</li>
</ol>
</blockquote>
<ol start="7">
<li><strong>rdbchecksum</strong></li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727985-1994836542.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><strong>该配置的意思是：</strong></p>
<blockquote>
<ol>
<li>在存储快照后，还可以让 redis 使用 CRC64算法来进行数据校验，保证文件是完整的。</li>
<li>但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能，推荐 yes 打开。</li>
</ol>
</blockquote>
<ol start="8">
<li>
<p><strong>动态停止 RDB：</strong></p>
</li>
<li>
<p>动态停止RDB： <code>redis-cli config set save ""</code> ，就是给 save 属性赋值为 <code>""</code>空字符串，表示禁用保护策略。这里使用命令是让 客户端在此刻，启动的客户端停止 RDB，一旦退出了该客户端就，该配置就失效了。RDB 持久化策略又启动了。</p>
</li>
</ol>
<hr>
<p><strong>示例演示：</strong></p>
<p>需求: 如果 Redis 的 key 在 30 秒内,  有 5 个 key 变化, 就自动进行 RDB 备份.<br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727895-1061223627.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-properties">save 30 5
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727721-1793891322.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728060-1093204588.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728057-848551200.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728088-370827509.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728290-1573912056.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="4-rdb-备份恢复">4. RDB 备份&amp;恢复</h1>
<p>Redis 可以充当缓存，对项目进行优化，因此重要/敏感的数据建议在 MySQL要保存一份。</p>
<p>从设计层面来说，Redis 的内存数据，都是可以重新获取的(可能来自程序，也可能来自MySQL)</p>
<p>因此我们这里说的<strong>备份&amp;恢复</strong> ：<strong>主要是给大家说明一下 Redis 启动时，初始化数据是从 <code>dump.rdb</code> 来的</strong> 整个机制。</p>
<p><strong>演示：</strong></p>
<p>这里我们演示的是：</p>
<blockquote>
<p>将我们已经的 <code>dump.rdb</code> 备份文件复制拷贝(备份)一份，复制后之后，再将原来的<code>dump.rdb</code> 文件删除了(模拟文件损坏了，或者是执行 flushall 删除库)。再将我们拷贝备份的 dum.rdb 文件，复制过去，然后重启 redis 读取 dump.rdb 备份文件当中的数据，进行一个数据上的恢复。</p>
</blockquote>
<p><code>config get dir </code>   查询 rdb 文件的目录</p>
<pre><code class="language-sh">127.0.0.1:6379&gt; config get dir
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727893-2102326791.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>将 dump.rdb  进行备份   如果有必要可以写 shell 脚本来定时备份  [参考韩顺平老师 Linux 课程定时<br>
,备份 Mysql 数据库视频地址  <a href="https://www.bilibili.com/video/BV1Sv411r7vd?p=105" target="_blank" rel="noopener nofollow">https://www.bilibili.com/video/BV1Sv411r7vd?p=105</a> ] 。</p>
<pre><code class="language-sh">[root@localhost ~]# cp /root/dump.rdb /root/dump.rdb.bak
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728235-1066469836.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727919-1651991348.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728221-1396697556.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-sh">127.0.0.1:6379&gt; flushall
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728227-126968919.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728224-764722636.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>注意：这里得关闭一下服务器</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728061-1739221397.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<pre><code class="language-sh">[root@localhost ~]# rm /root/dump.rdb # 删除文件夹
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728230-1443492600.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728231-198659821.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728081-1120978350.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728072-1989254182.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728070-1479736544.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>关闭 Redis 服务器，重新启动 Redis 服务器，让它读取到我们配置的<code>dump.rdb</code> 备份文件，恢复我们的数据信息。</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727767-425519328.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="5-rdb-持久化小结优势-和-劣势">5. RDB 持久化小结(优势 和 劣势)</h1>
<p><strong>优势：</strong></p>
<ol>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高更适合使用</li>
<li>节省磁盘空间</li>
<li>恢复速度快<br>
<img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222727758-865338926.png" alt="在这里插入图片描述" loading="lazy"></li>
</ol>
<p><strong>劣势：</strong></p>
<ol>
<li>虽然 Redis 在 fork 时使用了写时拷贝技术(Cop-On-Write) ，但是如果数据庞大时还是比较消耗性能。</li>
<li>在备份周期在一定间隔时间做一次备份，所以如果 <strong>Redis 意外 down 掉</strong>  的话(如果正常关闭 Redis仍然会进行 RDB 备份，不会丢失数据)，就会丢失最后一次快照后的所有修改。</li>
</ol>
<h1 id="6-最后">6. 最后：</h1>
<blockquote>
<p>“在这个最后的篇章中，我要表达我对每一位读者的感激之情。你们的关注和回复是我创作的动力源泉，我从你们身上吸取了无尽的灵感与勇气。我会将你们的鼓励留在心底，继续在其他的领域奋斗。感谢你们，我们总会在某个时刻再次相遇。”</p>
<p><img src="https://img2024.cnblogs.com/blog/3084824/202502/3084824-20250204222728069-1975895416.gif" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7415376654502315" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-04 22:34">2025-02-04 22:34</span>&nbsp;
<a href="https://www.cnblogs.com/TheMagicalRainbowSea">Rainbow-Sea</a>&nbsp;
阅读(<span id="post_view_count">239</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18698571" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18698571);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18698571', targetLink: 'https://www.cnblogs.com/TheMagicalRainbowSea/p/18698571', title: '九. Redis 持久化-RDB(详细讲解说明，一个配置一个说明分析，步步讲解到位)' })">举报</a>
</div>
	