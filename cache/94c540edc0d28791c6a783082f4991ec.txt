
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zphh/p/18553906" title="发布于 2025-01-18 14:27">
    <span role="heading" aria-level="2">分块莫队学习笔记</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>优雅的暴力。</p>
</blockquote>
<h2 id="引入">引入</h2>
<p><a href="https://www.luogu.com.cn/problem/P3372" target="_blank" rel="noopener nofollow">link</a>。</p>
<p>这道题显然可以用线段树、树状数组做，但如果我偏不用这些数据结构呢？</p>
<p>我们知道，暴力修改和查询最坏是 <span class="math inline">\(\mathcal{O}(n)\)</span> 的，这样肯定会挂掉。</p>
<p>那该怎么办呢？</p>
<h2 id="正题">正题</h2>
<h3 id="分块">分块</h3>
<p>考虑将序列分成若干块，我们设每块长为 <span class="math inline">\(B\)</span>。</p>
<p>对于每次查询 <span class="math inline">\(\left [ l, r \right ]\)</span>，我们涉及到修改的块是 <span class="math inline">\(\left [ b_l, b_r \right ]\)</span>（<span class="math inline">\(b_i\)</span> 代表 <span class="math inline">\(i\)</span> 属于哪个块）。</p>
<p>其中 <span class="math inline">\(\left [ b_l + 1, b_r - 1 \right ]\)</span> 是整块都被修改了。</p>
<p>不妨设置一个懒标记，把每块的整块操作都加到这里面。</p>
<p>这样修改的复杂度是 <span class="math inline">\(\mathcal{O}(\frac{n}{B})\)</span> 的。</p>
<p>那剩下的我们就可以暴力操作，复杂度是 <span class="math inline">\(\mathcal{O}(B)\)</span> 的。</p>
<p>查询同理。</p>
<p>此时修改查询的复杂度就变成了 <span class="math inline">\(\mathcal{O}(B + \frac{n}{B})\)</span> 了。</p>
<p>使得该数最小的显然是 <span class="math inline">\(B = \sqrt{n}\)</span>，所以该算法的时间复杂度是 <span class="math inline">\(\mathcal{O}(m\sqrt{n})\)</span>。</p>
<p>分块主要解决区修区查类问题，只要满足以下条件即可：</p>
<ul>
<li>可以打懒标记（结合律）。</li>
<li>时间复杂度允许。</li>
</ul>
<p><strong>优势</strong>：可解决问题范围广。</p>
<p><strong>劣势</strong>：时间复杂度高。</p>
<p>时间复杂度：<span class="math inline">\(\mathcal{O}(m\sqrt{n})\)</span>。</p>
<p>空间复杂度：<span class="math inline">\(\mathcal{O}(n)\)</span>。</p>
<h3 id="莫队">莫队</h3>
<h4 id="普通莫队">普通莫队</h4>
<p>莫队是一种离线算法，需要满足以下条件：</p>
<ul>
<li>在知道 <span class="math inline">\(\left [ l, r \right ]\)</span> 的答案的情况下，可以 <span class="math inline">\(\mathcal{O}(1)\)</span> 求出  <span class="math inline">\(\left [ l, r + 1 \right ]\)</span>、 <span class="math inline">\(\left [ l, r - 1 \right ]\)</span>、 <span class="math inline">\(\left [ l + 1, r \right ]\)</span>、 <span class="math inline">\(\left [ l - 1, r \right ]\)</span> 的答案。</li>
<li>允许离线。</li>
<li>只有询问没有修改。</li>
</ul>
<p>首先将所有的询问离线下来，记为  <span class="math inline">\(\left [ ql_1, qr_1 \right ],\left [ ql_2, qr_2 \right ],\dots,\left [ ql_m, qr_m \right ]\)</span>。</p>
<p>将询问排序（这正是莫队算法的精髓），从上一个询问的答案一个个改到当前询问，得到答案。</p>
<p>实现：</p>
<pre><code class="language-cpp">for (int i = 1; i &lt;= m; i++) {
	while (l &lt; q[i].l) del(l++);
	while (r &gt; q[i].r) del(r--);
	while (l &gt; q[i].l) add(--l);
	while (r &lt; q[i].r) add(++r);
	ans[q[i].id] = res;
}
</code></pre>
<p>但是仔细分析发现时间复杂度仍然可以被卡成 <span class="math inline">\(nm\)</span>，一点都不优秀，甚至会更慢。</p>
<p><strong>考虑优化</strong>。</p>
<p>我们想要优化复杂度的根本是让 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(r\)</span> 指针移动的距离尽量少。</p>
<p>对询问范围进行分块，块长为 <span class="math inline">\(B\)</span>。</p>
<p>以询问左端点的块编号为第一关键字，右端点为第二关键字排序。</p>
<ul>
<li>如果当前询问与上一次处于同一块，则 <span class="math inline">\(l\)</span> 最多移动 <span class="math inline">\(B\)</span>。</li>
<li>不同块的询问，<span class="math inline">\(l\)</span> 最多移动 <span class="math inline">\(2B\)</span>。</li>
</ul>
<p>则：</p>
<ul>
<li><span class="math inline">\(l\)</span> 移动的复杂度是 <span class="math inline">\(m\times B = mB\)</span>；</li>
<li><span class="math inline">\(r\)</span> 的复杂度是 <span class="math inline">\(\frac{n}{B} \times n = \frac{n^2}{B}\)</span>。</li>
</ul>
<p>则复杂度是 <span class="math inline">\(\mathcal{O}(mB + \frac{n^2}{B})\)</span>。</p>
<p>使得该式最小的 <span class="math inline">\(B\)</span> 的值是 <span class="math inline">\(\frac{n}{\sqrt m}\)</span>，则此时的时间复杂度就是 <span class="math inline">\(\mathcal{O}(n\sqrt{m} + m\log m)\)</span>。</p>
<p><span class="math inline">\(m \log m\)</span> 是排序的复杂度。</p>
<p>总结一下。</p>
<p>普通莫队解决的问题满足以下条件：</p>
<ul>
<li>在知道 <span class="math inline">\(\left [ l, r \right ]\)</span> 的答案的情况下，可以 <span class="math inline">\(\mathcal{O}(1)\)</span> 求出  <span class="math inline">\(\left [ l, r + 1 \right ]\)</span>、 <span class="math inline">\(\left [ l, r - 1 \right ]\)</span>、 <span class="math inline">\(\left [ l + 1, r \right ]\)</span>、 <span class="math inline">\(\left [ l - 1, r \right ]\)</span> 的答案。</li>
<li>允许离线。</li>
<li>只有询问没有修改。</li>
</ul>
<p><strong>优势</strong>：再没有更快的思维做法之前，她几乎是跑得最快并且思维含量最低的。</p>
<p><strong>劣势</strong>：只支持离线。</p>
<p>时间复杂度： <span class="math inline">\(\mathcal{O}(n\sqrt{m} + m\log m)\)</span>。</p>
<p>空间复杂度： <span class="math inline">\(\mathcal{O}(n)\)</span>。</p>
<h5 id="例题-1小-b-的询问">例题 1：<a href="https://www.luogu.com.cn/problem/P2709" target="_blank" rel="noopener nofollow">小 B 的询问</a></h5>
<p>非常板子的一道，维护一下 <span class="math inline">\(c\)</span> 数组即可。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
// #define int long long
#define pii pair&lt;int, int&gt;
#define FRE(x) freopen(x ".in", "r", stdin), freopen(x ".out", "w", stdout)
#define ALL(x) x.begin(), x.end()
using namespace std;

int _test_ = 1;

const int N = 50008;

int n, m, k, block_size, res, cnt[N], a[N], ans[N];
struct node {
	int l, r, id;
} q[N];

bool operator&lt;(node x, node y) {
	int xl = (x.l - 1) / block_size + 1, xr = (x.r - 1) / block_size + 1;
	int yl = (y.l - 1) / block_size + 1, yr = (y.r - 1) / block_size + 1;
	return (xl != yl) ? (xl &lt; yl) : (x.r &lt; y.r);
}

void add(int x) {
	res += cnt[a[x]] * 2 + 1;
	cnt[a[x]]++;
}

void del(int x) {
	res -= cnt[a[x]] * 2 - 1;
	cnt[a[x]]--;
}

void init() {}

void clear() {}

void solve() {
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	for (int i = 1; i &lt;= n; i++) {
		cin &gt;&gt; a[i];
	}
	block_size = n / sqrt(m); // 块长
	for (int i = 1; i &lt;= m; i++) {
		cin &gt;&gt; q[i].l &gt;&gt; q[i].r;
		q[i].id = i;
	}
	sort(q + 1, q + m + 1);
	int l = 1, r = 0;
	for (int i = 1; i &lt;= m; i++) {
		while (l &lt; q[i].l) del(l++);
		while (r &gt; q[i].r) del(r--);
		while (l &gt; q[i].l) add(--l);
		while (r &lt; q[i].r) add(++r);
		ans[q[i].id] = res;
	}
	for (int i = 1; i &lt;= m; i++) {
		cout &lt;&lt; ans[i] &lt;&lt; "\n";
	}
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
//	cin &gt;&gt; _test_;
	init();
	while (_test_--) {
		clear();
		solve();
	}
	return 0;
}
</code></pre>
<p>不过此题块长就是 <span class="math inline">\(1\)</span> 都能在 <span class="math inline">\(700\)</span> 毫秒以内过，数据太水。</p>
<h5 id="例题-2小-z-的袜子">例题 2：<a href="https://www.luogu.com.cn/problem/P1494" target="_blank" rel="noopener nofollow">小 Z 的袜子</a></h5>
<p>也是非常板子的一道，维护一下 <span class="math inline">\(c\)</span> 数组，并将上一题中的答案分别记分子分母即可。</p>
<p>请注意分子为 <span class="math inline">\(0\)</span> 的情况。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
// #define int long long
#define pii pair&lt;int, int&gt;
#define FRE(x) freopen(x ".in", "r", stdin), freopen(x ".out", "w", stdout)
#define ALL(x) x.begin(), x.end()
using namespace std;

int _test_ = 1;

const int N = 500008;

int n, m, k, block_size, len;
pii res;
int cnt[N], a[N];
pii ans[N];
struct node {
	int l, r, id;
} q[N];

bool operator&lt;(node x, node y) {
	int xl = (x.l - 1) / block_size + 1, xr = (x.r - 1) / block_size + 1;
	int yl = (y.l - 1) / block_size + 1, yr = (y.r - 1) / block_size + 1;
	return (xl != yl) ? (xl &lt; yl) : (x.r &lt; y.r);
}

void add(int x) {
	res.first += cnt[a[x]];
	res.second += len;
	len++;
	cnt[a[x]]++;
}

void del(int x) {
	len--;
	cnt[a[x]]--;
	res.first -= cnt[a[x]];
	res.second -= len;
}

void init() {}

void clear() {}

void solve() {
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1; i &lt;= n; i++) {
		cin &gt;&gt; a[i];
	}
	block_size = n / sqrt(m);
	for (int i = 1; i &lt;= m; i++) {
		cin &gt;&gt; q[i].l &gt;&gt; q[i].r;
		q[i].id = i;
	}
	sort(q + 1, q + m + 1);
	int l = 1, r = 0;
	for (int i = 1; i &lt;= m; i++) {
		if (q[i].l == q[i].r) ans[q[i].id] = {0, 1};
		while (l &lt; q[i].l) del(l++);
		while (r &gt; q[i].r) del(r--);
		while (l &gt; q[i].l) add(--l);
		while (r &lt; q[i].r) add(++r);
		if (res.first == 0) {
			ans[q[i].id] = {0, 1};
			continue;
		}
		int g = __gcd(res.first, res.second);
		ans[q[i].id] = {res.first / g, res.second / g};
	}
	for (int i = 1; i &lt;= m; i++) {
		cout &lt;&lt; ans[i].first &lt;&lt; "/" &lt;&lt; ans[i].second &lt;&lt; "\n";
	}
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
//	cin &gt;&gt; _test_;
	init();
	while (_test_--) {
		clear();
		solve();
	}
	return 0;
}
</code></pre>
<p>事实证明，还是 <span class="math inline">\(B = \frac{n}{\sqrt{m}}\)</span> 跑得最快。</p>
<h4 id="带修莫队">带修莫队</h4>
<blockquote>
<p>由于不能带修改实在是太别扭了，所以出现了带修莫队</p>
</blockquote>
<p>带修莫队的思想跟所有可持久化数据结构是差不多的。</p>
<p><a href="https://www.luogu.com.cn/problem/P1903" target="_blank" rel="noopener nofollow">link</a>.</p>
<p>由于加进了修改，我们无法再像正常莫队一样转移了。</p>
<p>可以考虑在迭代时增加一维时间戳。</p>
<p>每次就按顺序一个一个增加或减少修改即可。</p>
<p>同时就要以右端点所在块编号为第二关键字、时间为第三关键字排序。</p>
<h5 id="时间复杂度与最优块长">时间复杂度与最优块长</h5>
<p>设块长为 <span class="math inline">\(B\)</span>、序列长度为 <span class="math inline">\(n\)</span>、询问次数为 <span class="math inline">\(q\)</span>、修改次数为 <span class="math inline">\(c\)</span>。</p>
<ul>
<li>左右端点移动上文分析过，是 <span class="math inline">\(qB + \frac{n^2}{B}\)</span> 的。</li>
<li>时间指针，对于每一个块，我们至多移动 <span class="math inline">\(c\)</span> 次，即 <span class="math inline">\(\frac{n}{B} \times \frac{n}{B} \times c = \frac{cn^2}{B^2}\)</span>。</li>
</ul>
<p>总时间复杂度为 <span class="math inline">\(\mathcal{O}(qB + \frac{n^2}{B} + \frac{cn^2}{B^2})\)</span>。</p>
<p>最优块长大概是……</p>
<p></p><div class="math display">\[\frac{n^2}{3^{1/3}(9m^3n^2+\sqrt{3}\sqrt{27m^6n^4-m^3n^6})^{1/3}}+\frac{(9m^3n^2+\sqrt{3}\sqrt{27m^6n^4-m^3n^6})^{1/3}}{3^{2/3}m}
\]</div><p></p><p>所以还是取一个更好看一点的。</p>
<p>譬如 <span class="math inline">\(B = \sqrt[3]{n^2}\)</span>。</p>
<p>所以此时时间复杂度是约 <span class="math inline">\(\mathcal{O}(\sqrt[3]{n^5})\)</span>。</p>
<hr>
<p>总结一下，带修莫队需要满足以下条件：</p>
<ul>
<li>在知道 <span class="math inline">\(\left [ l, r \right ]\)</span> 的答案的情况下，可以 <span class="math inline">\(\mathcal{O}(1)\)</span> 求出  <span class="math inline">\(\left [ l, r + 1 \right ]\)</span>、 <span class="math inline">\(\left [ l, r - 1 \right ]\)</span>、 <span class="math inline">\(\left [ l + 1, r \right ]\)</span>、 <span class="math inline">\(\left [ l - 1, r \right ]\)</span> 的答案。</li>
<li>允许离线。</li>
</ul>
<p><strong>优势</strong>：可以允许修改。</p>
<p><strong>劣势</strong>：比思维方法慢且只能离线。、</p>
<p>时间复杂度：<span class="math inline">\(\mathcal{O}(n\log n + \sqrt[3]{n^5})\)</span>​。</p>
<p>空间复杂度： <span class="math inline">\(\mathcal{O}(n)\)</span>。</p>
<h5 id="例题1数颜色--维护队列">例题1：<a href="https://www.luogu.com.cn/problem/P1903" target="_blank" rel="noopener nofollow">数颜色 / 维护队列</a></h5>
<p>按上文中写的模拟即可。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define int long long
#define pii pair&lt;int, int&gt;
#define FRE(x) freopen(x ".in", "r", stdin), freopen(x ".out", "w", stdout)
#define ALL(x) x.begin(), x.end()
using namespace std;

int _test_ = 1;

const int N = 2e6 + 5; 

int n, m, block_size, cnt_c, cnt_q, a[N], bel[N], cnt[N], ans[N], res;
struct query {
	int l, r, t, id;
} c[N], q[N];
bool operator&lt;(query x, query y) {
	return (bel[x.l] != bel[y.l]) ? (x.l &lt; y.l) : ((bel[x.r] != bel[y.r]) ? (x.r &lt; y.r) : (x.t &lt; y.t));
}
void build() {
	block_size = pow(n, 0.666);
	for (int i = 1; i &lt;= n; i++) {
		bel[i] = (i - 1) / block_size + 1;
	}
}
void add(int x) {
	res += (cnt[x] == 0);
	cnt[x]++;
}
void del(int x) {
	cnt[x]--;
	res -= (cnt[x] == 0);
}
void upt(int x, int y) {
	if (q[y].l &lt;= c[x].l &amp;&amp; c[x].l &lt;= q[y].r) {
		del(a[c[x].l]);
		add(c[x].r);
	}
	swap(a[c[x].l], c[x].r);
}

void init() {}

void clear() {}

void solve() {
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1; i &lt;= n; i++) {
		cin &gt;&gt; a[i];
	}
	build();
	for (int i = 1; i &lt;= m; i++) {
		char op;
		int l, r;
		cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;
		if (op == 'Q') q[++cnt_q] = {l, r, cnt_c, cnt_q};
		else c[++cnt_c] = {l, r, 0, 0};
	}
	sort(q + 1, q + cnt_q + 1);
	int l = 1, r = 0, t = 0;
	for (int i = 1; i &lt;= cnt_q; i++) {
		while (l &gt; q[i].l) add(a[--l]);
		while (r &lt; q[i].r) add(a[++r]);
		while (l &lt; q[i].l) del(a[l++]);
		while (r &gt; q[i].r) del(a[r--]);
		while (t &lt; q[i].t) upt(++t, i);
		while (t &gt; q[i].t) upt(t--, i); 
		ans[q[i].id] = res;
	}
	for (int i = 1; i &lt;= cnt_q; i++) cout &lt;&lt; ans[i] &lt;&lt; "\n";
}

signed main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  // cin &gt;&gt; _test_;
  init();
  while (_test_--) {
    clear();
    solve();
	}
  return 0;
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1.406365400019676" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-18 14:31">2025-01-18 14:27</span>&nbsp;
<a href="https://www.cnblogs.com/zphh">Archippus</a>&nbsp;
阅读(<span id="post_view_count">90</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18553906" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18553906);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18553906', targetLink: 'https://www.cnblogs.com/zphh/p/18553906', title: '分块莫队学习笔记' })">举报</a>
</div>
        