
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Qzzz/p/18651848" title="发布于 2025-01-04 14:00">
    <span role="heading" aria-level="2">Verilog5_有限状态机</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104135930213-2041282161.png" alt="Verilog5_有限状态机" class="desc_img">
        Verilog内容总结5_有限状态机
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="一有限状态机finite-state-machine-fsm基本概念">一、有限状态机（Finite State Machine, FSM）基本概念</h3>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有限状态机是由<strong>寄存器组</strong>和<strong>组合逻辑</strong>构成的硬件时序电路；<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其状态只能在同一时钟跳变沿从一个状态转向另一个状态；状态的选择不仅取决于各个输入值，还取决于当前状态，可用于产生在时钟跳变沿时刻开关的复杂的控制逻辑，是数字逻辑的控制核心</p>
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104100421397-1636039851.png" height="250"></center>
</blockquote>
<h4 id="1有限状态机的优势">1.有限状态机的优势</h4>
<ul>
<li><strong>高效的顺序控制逻辑</strong><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;克服了纯硬件数字系统顺序方式控制不灵活的缺点，在其运行方式上类似于控制灵活和方便的CPU，是高速高效控制的首选</li>
<li><strong>容易利用现成的EDA工具进行优化设计</strong><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态机构建简单，设计方案相对固定，使用HDL综合其可以发挥其强大的优化功能；<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;性能良好的综合器都具有许多可控或自动优化状态机的功能</li>
<li><strong>稳定性能</strong><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态机容易构成良好的同步时序逻辑模块，可用于解决大规模逻辑电路设计中的竞争和冒险现象</li>
<li><strong>高速性能</strong><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在高速通信和高速控制方面，状态机更有其巨大的优势，一个状态机的功能类似于CPU的功能</li>
<li><strong>高可靠性能</strong><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态机是由纯硬件电路构成，不存在CPU运行软件过程中许多固有的缺陷；<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态机的设计中能够使用各种容错技术；<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当状态机进入非法状态并从中跳出进入正常状态的时间短暂，对系统的危害不大。</li>
</ul>
<h4 id="2有限状态机的分类">2.有限状态机的分类</h4>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，状态机的基本操作主要有：<strong>状态机的内部状态转换</strong>和<strong>产生输出信号序列</strong><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据电路的输出信号是否与电路的输入有关，可以将状态机划分为：<strong>Moore型状态机</strong>（输出只与当前电路状态有关，保持输出的稳定性和可预测性）；<strong>Mealy型状态机</strong>（输出与当前电路状态和当前电路输入有关，来快速响应输入变化）</p>
<h4 id="3有限状态机的描述方法">3.有限状态机的描述方法</h4>
<ul>
<li><strong>状态转移图</strong>：紧凑，适合描述较为简单的系统</li>
</ul>
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104101230840-1713675593.png" height="250"></center>
<ul>
<li><strong>算法状态机（ASM）图</strong><br>
算法状态机图更像是流程图，能较好地描述复杂系统中状态的转换和动作</li>
</ul>
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104101521134-1131536411.png" height="300"></center>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两种表示方法包含了相同的信息，都包含了状态机的输入、输出、状态和转换。
<h3 id="二有限状态机的设计">二、有限状态机的设计</h3>
<h4 id="1状态机的设计步骤">1.状态机的设计步骤</h4>
<ul>
<li>依据具体的设计原则，确定采用Moore型状态机还是Mealy型状态机</li>
<li>分析设计要求，列出状态机的所有状态，并对每一个状态进行状态编码</li>
<li>依据状态转移关系和输出函数，画出状态图</li>
<li>依据所画的状态图，采用硬件描述语言对状态机进行描述</li>
</ul>
<h4 id="2状态图的完备性和互斥性检查">2.状态图的完备性和互斥性检查</h4>
<ul>
<li><strong>完备性：</strong> 对于每一个状态，将所有脱离这一状态的条件表达式进行<strong>逻辑或运算</strong>，如果结果为<strong>1</strong>就是完备的，否则不完备，也就是说状态图进入某状态后，却不能跳出该状态；</li>
<li><strong>互斥性：</strong> 对于每一个状态，将所有脱离这一状态的条件表达式找出，然后任意两个表达式进行<strong>逻辑与</strong>运算，如果结果为<strong>0</strong>就是互斥的。也就是要保证在任何时候不会激活两个脱离状态的转换，即从一个状态跳到两个状态</li>
</ul>
<h4 id="3安全状态机设计">3.安全状态机设计</h4>
<ul>
<li><strong>状态引导法</strong>：对于未使用的状态，也给予次态赋值，避免状态机处于未知状态；</li>
<li><strong>状态编码检测法</strong>：判断被触发的触发器的个数，当数量大于1时，说明出现问题；</li>
<li>借助<strong>EDA工具</strong>自动生成安全状态机</li>
</ul>
<h3 id="三有限状态机的verilog-hdl描述">三、有限状态机的Verilog HDL描述</h3>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑如下图所示的状态转移图</p>
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104110720851-588007969.png" height="250"></center>
<h4 id="1描述状态机中各个状态的名称并指定状态编码">1.描述状态机中各个状态的名称，并指定状态编码</h4>
<ul>
<li><strong>状态定义/声明与编码</strong>
<ul>
<li>状态必须是常量<strong>parameter</strong>或者 <strong>`define</strong></li>
</ul>
</li>
</ul>
<pre><code class="language-verilog">    IDLE=2'b00;
    START=2'b01;
    STOP=2'b10;
    CLEAR=2'B11;
</code></pre>
<ul>
<li>
<p><strong>状态寄存器</strong>（位宽必须与parameter变量一致）</p>
<ul>
<li>cur_state:存储现态</li>
<li>next_state:存储次态</li>
<li>reg [1:0] state:定义状态寄存器</li>
</ul>
</li>
<li>
<p><strong>状态编码</strong></p>
  <center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104111334005-576452967.png" height="200"></center>
</li>
</ul>
<pre><code class="language-verilog">module fsm
	#(parameter IDLE=2'b00,
	  parameter START=2'b01,
	  parameter STOP=2'b10,
	  parameter CLEAR=2'b11)
	( input clk, rstn, a,
	  output reg k1, k2);

	reg [1:0] cur_state, next_state;//定义状态寄存器
</code></pre>
<h4 id="2状态机设计">2.状态机设计</h4>
<h5 id="21-设计步骤">2.1 设计步骤</h5>
<ul>
<li>用时序的<strong>always块</strong>描述状态触发器实现的状态存储；</li>
<li>使用敏感表和case语句（或if-else等价语句）描述的状态转换逻辑</li>
<li>描述状态机的输出逻辑</li>
</ul>
<h5 id="22-状态机的三种rtl描述方法">2.2 状态机的三种RTL描述方法</h5>
<ul>
<li><strong>一段式</strong>：现态、次态与输出逻辑在同一个always块中</li>
<li><strong>两段式</strong>：现态在一个always块中，次态与输出逻辑在一个always块中</li>
<li><strong>三段式</strong>：现态、次态与输出逻辑分别在一个always块中</li>
</ul>
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104111904158-1135765620.png"></center>
<pre><code class="language-verilog">//一段式
always @(posedge clk)	begin
	if(!rstn)	begin
		cur_state&lt;=IDLE;
		k2&lt;=1'b0;
		k1&lt;=1'b0;
	end
	else	
		case(cur_state)
			IDLE:
				if(a) begin
					cur_state&lt;=START;
					k1&lt;=1'b0;
				end
				else
					cur_state&lt;=IDLE;
			START: 
				if(!a)
					cur_state &lt;= STOP;
				else
					cur_state &lt;=START;
			STOP:
				if(a)	begin
					cur_state &lt;= CLEAR;
					k2&lt;=1'b1;
				end
				else 
					cur_state &lt;= STOP;
			CLEAR:
				if(!a)	begin
					cur_state &lt;= IDLE;
					k2&lt;=1'b0; 
					k1&lt;=1'b1;
				end
				else	
					cur_state &lt;= CLEAR;
		endcase
	end
</code></pre>
<pre><code class="language-verilog">//两段式
always @(posedge clk)	begin
	if(!rstn)
		cur_state &lt;= IDLE;
	else 
		cur_state &lt;= next_state;
end

always @(cur_state, a)	begin
	case(cur_state)	
		IDLE:
			if(a) begin
				next_state=START;
				k1=1'b0;
			end
			else
				next_state=IDLE;
		START: 
			if(!a)
				next_state = STOP;
			else
				next_state =START;
		STOP:
			if(a)	begin
				next_state = CLEAR;
				k2=1'b1;
			end
			else 
				next_state = STOP;
		CLEAR:
			if(!a)	begin
				next_state = IDLE;
				k2=1'b0; 
				k1=1'b1;
			end
			else	
				next_state = CLEAR;
	endcase
end
</code></pre>
<pre><code class="language-verilog">//三段式
always@(posedge clk)	begin
	if(!rstn)	
		cur_state &lt;= IDLE;
	else
		cur_state &lt;= next_state;
end

always@(cur_state, a)	begin
	case(cur_state)
		IDLE:
			if(a)	next_state = START;
			else	next_state = IDLE;
		START:
			if(!a)	next_state = STOP;
			else	next_state = START;
		STOP:
			if(a)	next_state = CLEAR;
			else	next_state = STOP;
		CLEAR:
			if(!a)	next_state = IDLE;
			else	next_state = CLEAR;
	endcase
end

always@(cur_state, a)	begin
	k2=1'b0;
	k1=1'b0;
	if(!rstn)	begin
		k2=1'b0;
		k1=1'b0;
	end
	else	begin
		if(cur_state == CLEAR &amp;&amp; !a)
			k1=1'b1;
		else
			k1=1'b0;
		if(cur_state == STOP &amp;&amp; a)
			k2=1'b1;
		else
			k2=1'b0;
	end
end
</code></pre>
<h3 id="四有限状态机设计实例">四、有限状态机设计实例</h3>
<h4 id="实例1moore型序列检测器">实例1：Moore型序列检测器：</h4>
<blockquote>
<p><strong>要求描述：</strong><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;序列检测器可用于检测一组或多组由二进制码组成的脉冲序列信号，当序列检测器连续收到一组串行二进制码后，如果这组码与检测器中预先设置的码相同，则输出1，否则输出0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计一个“1101”的序列检测器，设din为数字码流输入，sout为检出标记输出，高电平表示发现指定序列，低电平表示没有发现指令序列。</p>
</blockquote>
<h5 id="step1状态定义">Step1.状态定义</h5>
<ul>
<li><strong>s0</strong>:未检测到“1”</li>
<li><strong>s1</strong>:检测到输入序列“1”</li>
<li><strong>s2</strong>:检测到输入序列“11”</li>
<li><strong>s3</strong>:检测到输入序列“110”</li>
<li><strong>s4</strong>:检测到输入序列“1101”<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共五个状态，需要声明位宽为3的状态寄存器<strong>reg [2:0] cur_state, next_state;</strong></li>
</ul>
<h5 id="step2状态转移表和状态转移图">Step2.状态转移表和状态转移图</h5>
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104121330936-321372687.png" height="250"></center>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无可简化状态,对应的Moore型状态转移图如下：
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104121707379-1247602223.png" height="150"></center>
<h5 id="step3hdl语言描述状态转换">Step3.HDL语言描述状态转换</h5>
<pre><code class="language-verilog">//实现代码
module seqdet#(
	parameter s0=3'b000,
	parameter s1=3'b001,
	parameter s2=3'b010,
	parameter s3=3'b011,
	parameter s4=3'b100)(
	input clk, rstn, din,
	output reg sout);

	reg [2:0] cur_state, next_state;

	always @(posedge clk)	begin
		if(!rstn)	cur_state &lt;= s0;
		else		cur_state &lt;= next_state;
	end

	always @(cur_state, din)	begin
		sout=0;
		case(cur_state)
			s0:	begin
				if(din == 1)	next_state=s1;
				else		next_state=s0;
			end
			s1:	begin
				if(din == 1)	next_state=s2;
				else		next_state=s0;
			end
			s2:	begin
				if(din == 0)	next_state=s3;
				else		next_state=s2;
			end
			s3:	begin
				if(din == 1)	next_state=s4;
				else		next_state=s0;
			end
			s4:	begin
				if(din == 0)	begin	next_state=s0; sout=1;	end
				else		begin	next_state=s1; sout=1;	end
			end
			default	next_state=s0;
		endcase
	end
endmodule

//仿真代码
module seqdet_tb();
	reg clk, rstn, din;
	wire sout;

	seqdet U1(clk, rstn, din, sout);
	always #1 clk=~clk;

	initial begin
		clk=0; rstn=0; din=0;
		#5 rstn=1;
		#2 din=1;
		#2 din=1;
		#2 din=0;
		#2 din=1;
		#2 din=1;
		#2 din=0;
		#2 din=0;
		#3 rstn=0;
		#5 $finish;
	end
endmodule
</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仿真得到的波形图如下：</p>
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104123351305-455916721.png" height="100"></center>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综合出的电路结构图如下：
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104123943423-228379037.png" height="200"></center>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;电路状态转移图如下：
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104123744387-1418058736.png" height="500"></center>
<h4 id="实例2mealy型序列检测器">实例2：Mealy型序列检测器：</h4>
<h5 id="step2状态转移表和状态转换图">Step2.状态转移表和状态转换图</h5>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态定义与实例1相同，可以得到状态转移表如下：</p>
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104124626601-249716915.png" height="250"></center>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对应的Mealy型状态转换图如下：
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104124745258-1253154137.png" height="150"></center>
<pre><code class="language-verilog">//实现代码
module seqdet_mealy#(
	parameter s0=3'b000,
	parameter s1=3'b001,
	parameter s2=3'b010,
	parameter s3=3'b011,
	parameter s4=3'b100)(
	input clk, rstn, din,
	output reg sout);

	reg [2:0] cur_state, next_state;
	
	always @(posedge clk)	begin
		if(!rstn)	cur_state &lt;= s0;
		else		cur_state &lt;= next_state;
	end

	always @(cur_state, din)	begin
		sout = 1'b0;
		case(cur_state)
			s0:	if(din==1)	next_state=s1;
				else		next_state=s0;
			s1:	if(din==1)	next_state=s2;
				else		next_state=s0;
			s2:	if(din==0)	next_state=s3;
				else		next_state=s2;
			s3:	if(din==1)	begin	next_state=s4; sout=1;	end
				else		next_state=s0;
			s4:	if(din==1)	next_state=s2;
				else		next_state=s0;
			default:		next_state=s0;
		endcase
	end
endmodule

//仿真代码
module seqdet_mealy_tb();
	reg clk, rstn, din;
	wire sout;

	seqdet_mealy U1(clk, rstn, din, sout);
	always #1 clk=~clk;

	initial begin
		clk=0; rstn=0; din=0;
		#5 rstn=1;
		#2 din=1;
		#2 din=1;
		#2 din=0;
		#2 din=1;
		#2 din=1;
		#2 din=0;
		#2 din=0;
		#3 rstn=0;
		#5 $finish;
	end
endmodule
</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仿真得到的波形图如下：</p>
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104130829224-411522592.png" height="100"></center>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综合出的电路结构图如下：
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104130849406-1800496588.png" height="150"></center>
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104130919113-1872878700.png" height="200"></center>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;电路状态转移图如下：
<center><img src="https://img2024.cnblogs.com/blog/2326690/202501/2326690-20250104130907153-1750364679.png" height="500"></center>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.09527662210069444" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-04 14:00">2025-01-04 14:00</span>&nbsp;
<a href="https://www.cnblogs.com/Qzzz">Mundane-_-</a>&nbsp;
阅读(<span id="post_view_count">14</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18651848" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18651848);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18651848', targetLink: 'https://www.cnblogs.com/Qzzz/p/18651848', title: 'Verilog5_有限状态机' })">举报</a>
</div>
        