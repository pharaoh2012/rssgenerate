<!----> <meta itemprop="headline" content="2025前端面试题-React基础篇"> <meta itemprop="keywords" content="前端,面试"> <meta itemprop="datePublished" content="2025-05-14T02:28:52.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="EB_Coder"> <meta itemprop="url" content="https://juejin.cn/user/3228641967213214"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            2025前端面试题-React基础篇
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3228641967213214/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    EB_Coder
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-05-14T02:28:52.000Z" title="Wed May 14 2025 02:28:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-05-14
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    5,367
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><blockquote>
<p>以下为React面试基础考察点总结，具体知识点不会太详细，主要梳理面试核心考察点，为面试做准备。</p>
</blockquote>
<ul>
<li><a href="https://juejin.cn/post/7504545616841965583" target="_blank" title="https://juejin.cn/post/7504545616841965583">2025前端面试题-React进阶篇</a></li>
<li><a href="https://juejin.cn/post/7504926961627054099" target="_blank" title="https://juejin.cn/post/7504926961627054099">2025前端面试题-React高阶篇</a></li>
<li><a href="https://juejin.cn/post/7503111373468893193" target="_blank" title="https://juejin.cn/post/7503111373468893193">2025前端面试题-Vue3基础篇</a></li>
<li><a href="https://juejin.cn/post/7511568225987051555" target="_blank" title="https://juejin.cn/post/7511568225987051555">2025前端面试题-Vue3进阶篇</a></li>
</ul>
<h2 data-id="heading-0">一、基础概念</h2>
<h3 data-id="heading-1">1.React核心设计思想</h3>
<h4 data-id="heading-2">组件化设计</h4>
<ul>
<li><strong>原子化构建</strong>：<code>UI</code>分解为独立的功能单元（如函数式组件/类组件）</li>
<li><strong>组合模式</strong>：通过<code>props</code>嵌套实现组件树结构</li>
<li><strong>隔离型</strong>：每个组件维护自身状态和样式（<code>CSS-in-JS</code>生态支持）</li>
<li><strong>复用机制</strong>：高阶组件（<code>HOC</code>）与自定义<code>Hooks</code>实现逻辑复用</li>
</ul>
<h4 data-id="heading-3">声明式编程范式</h4>
<ul>
<li><strong>状态驱动</strong>：<code>UI=f(state)</code>的数学表达式（无需手动操作DOM）</li>
<li><strong>抽象渲染</strong>：开发者专注描述目标状态，框架处理渲染细节</li>
<li><strong>幂等性保证</strong>：相同<code>state</code>必定输出相同视图（确定性原则）</li>
</ul>
<h4 data-id="heading-4">高效更新引擎</h4>
<ul>
<li><strong>虚拟DOM层</strong>：内存中轻量级<code>DOM</code>表示（对象树结构）</li>
<li><strong>Diff算法优化</strong>：启发式<code>O(n)</code>复杂度比较策略（基于树遍历策略）</li>
<li><strong>批量更新策略</strong>：自动合并<code>setState</code>操作（异步更新策略）</li>
<li><strong>渲染流水线</strong>：<code>Fiber</code>架构实现可中断渲染（并发模式）</li>
</ul>
<h4 data-id="heading-5">单向数据控制</h4>
<ul>
<li><strong>严格数据通道</strong>：<code>props</code>自上而下传递（严禁子级逆向修改）</li>
<li><strong>状态托管</strong>：通过<code>Context/Redux</code>实现跨层级通信</li>
<li><strong>副作用隔离</strong>：<code>Hooks</code>机制约束副作用边界（<code>useEffect</code>依赖链）</li>
</ul>
<p>这些原则使React具备：<strong>高维护性</strong>（组件解耦）、<strong>高性能</strong>（智能更新）、<strong>可预测性</strong>（数据流透明）。</p>
<h3 data-id="heading-6">2.JSX</h3>
<h4 data-id="heading-7">1.JSX的本质</h4>
<ul>
<li><strong>定义</strong>：<code>JSX(JavaScript XML)</code>是React提供的语法扩展，允许在JavaScript中编写类似HTML的结构</li>
<li><strong>核心作用</strong>：提升代码可读性，直观描述UI的层次结构，同时保留JavaScript的全部编程能力</li>
<li><strong>底层实现</strong>：JSX会被Babel或TypeScript编译器转换为<code>React.createElement()</code>调用，生成React元素（即虚拟DOM对象）</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// JSX代码</span>
<span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"title"</span>&gt;</span>Hello React<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
<span class="hljs-comment">// 编译后的JavaScript</span>
<span class="hljs-keyword">const</span> element = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(
    <span class="hljs-string">'div'</span>,
    { <span class="hljs-attr">className</span>:<span class="hljs-string">'title'</span> },
    <span class="hljs-string">'Hello React'</span>
)
</code></pre>
<h4 data-id="heading-8">2.JSX编译过程</h4>
<ul>
<li><strong>编译阶段</strong>：Babel的<code>@babel/plugin-transform-react-jsx</code>插件负责转换</li>
<li><strong>新转换模式</strong>（React17+）：通过<code>jsx-runtime</code>自动引入<code>_jsx</code>函数，无需手动引入React</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// React 17+ 编译后</span>
<span class="hljs-keyword">import</span> { jsx <span class="hljs-keyword">as</span> _jsx } <span class="hljs-keyword">from</span> <span class="hljs-string">'react/jsx-runtime'</span>;
<span class="hljs-keyword">const</span> element = <span class="hljs-title function_">_jsx</span>(<span class="hljs-string">'div'</span>, { <span class="hljs-attr">className</span>: <span class="hljs-string">'title'</span>, <span class="hljs-attr">children</span>: <span class="hljs-string">'Hello React'</span> });
</code></pre>
<h4 data-id="heading-9">3.JSX与HTML的关键区别</h4>
<ul>
<li><strong>属性命名</strong>：使用小驼峰命名（如<code>className,htmlFor,onClick</code>）</li>
<li><strong>样式对象</strong>：CSS属性转为小驼峰，值为字符串或数值</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;div style={{ <span class="hljs-attr">fontSize</span>: <span class="hljs-number">14</span>, <span class="hljs-attr">padding</span>: <span class="hljs-string">'10px'</span> }} &gt;&lt;/div&gt;
</code></pre>
<ul>
<li><strong>布尔值属性</strong>：属性省略值时默认为<code>true</code>（如<code>&lt;input disabled /&gt;</code>）</li>
<li><strong>子元素类型</strong>：支持字符串、JSX元素、数组，<code>false/null/undefined</code>不渲染</li>
</ul>
<h4 data-id="heading-10">4.JSX中的表达式嵌入</h4>
<ul>
<li><strong>动态内容</strong>：使用{}嵌入任意JavaScript表达式</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;h1&gt;当前时间：{<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleTimeString</span>()}&lt;/h1&gt;
</code></pre>
<ul>
<li><strong>条件渲染</strong>：</li>
</ul>
<pre><code class="hljs language-js" lang="js">{isLoggedIn ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserPanel</span> /&gt;</span></span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginButton</span> /&gt;</span></span>}
</code></pre>
<ul>
<li><strong>列表渲染</strong>：</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;ul&gt;
  {items.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>&gt;</span>{item.name}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
  ))}
&lt;/ul&gt;
</code></pre>
<h4 data-id="heading-11">5.JSX安全特性</h4>
<ul>
<li><strong>自动转义</strong>：嵌入内容（如用户输入）会被转义为字符串，防止XSS攻击</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> userInput = <span class="hljs-string">'&lt;script&gt;恶意代码&lt;/script&gt;'</span>;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{userInput}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <span class="hljs-comment">// 输出为文本，而非执行脚本</span>
</code></pre>
<ul>
<li><strong>dangerouslySetInnerHTML</strong>：显式插入原始HTML（需手动防范风险）</li>
</ul>
<pre><code class="hljs language-jsx" lang="jsx">&lt;div dangerouslySetInnerHTML={{ <span class="hljs-attr">__html</span>: sanitizedHTML }} /&gt;
</code></pre>
<h4 data-id="heading-12">6.JSX高级用法</h4>
<ul>
<li><strong>片段</strong>（Fragment）：包裹多个元素避免额外的DOM节点</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;<span class="hljs-title class_">React</span>.<span class="hljs-property">Fragment</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Column 1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Column 2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span>
&lt;/<span class="hljs-title class_">React</span>.<span class="hljs-property">Fragment</span>&gt;
<span class="hljs-comment">// 或简写为 &lt;&gt;&lt;/&gt;</span>
</code></pre>
<ul>
<li><strong>组件嵌套</strong>：自定义组件必须以大写字母开头，小写标签视为原生标签</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;<span class="hljs-title class_">MyComponent</span> prop1=<span class="hljs-string">"value"</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">MyComponent</span>&gt;
</code></pre>
<h4 data-id="heading-13">7.JSX与模版引擎对比</h4>

























<table><thead><tr><th><strong>特性</strong>​</th><th>​<strong>JSX</strong>​</th><th>​<strong>传统模板引擎（如 Vue）​</strong>​</th></tr></thead><tbody><tr><td>语法灵活性</td><td>原生 JavaScript 能力，无 DSL 限制</td><td>受限于模板语法（指令、过滤器等）</td></tr><tr><td>组件逻辑</td><td>逻辑与 UI 紧密耦合</td><td>分离的模板与脚本块</td></tr><tr><td>类型安全</td><td>完美支持 TypeScript 类型检查</td><td>需要额外工具支持</td></tr></tbody></table>
<h4 data-id="heading-14">8.实战技巧</h4>
<ul>
<li><strong>条件渲染优化</strong>：使用短路运算简化简单条件</li>
</ul>
<pre><code class="hljs language-js" lang="js">{isLoading &amp;&amp; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span></span>}
</code></pre>
<ul>
<li><strong>动态组件</strong>：通过变量名渲染不同组件</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> components = { <span class="hljs-attr">photo</span>: <span class="hljs-title class_">PhotoComponent</span>, <span class="hljs-attr">video</span>: <span class="hljs-title class_">VideoComponent</span> };
<span class="hljs-keyword">const</span> <span class="hljs-title class_">DynamicComponent</span> = components[type];
<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DynamicComponent</span> /&gt;</span></span>;
</code></pre>
<h4 data-id="heading-15">高频面试题</h4>
<h5 data-id="heading-16">1.为什么JSX中组件首字母必须大写？</h5>
<ul>
<li>React通过首字母大小写区分原生DOM标签（如<code>&lt;div&gt;</code>）和自定义组件（如<code>&lt;MyComponent&gt;</code>）</li>
</ul>
<h5 data-id="heading-17">2.如何避免JSX回调中的闭包陷阱？</h5>
<ul>
<li>使用<code>useCallback</code>缓存函数，或通过函数参数传递最新值</li>
</ul>
<h3 data-id="heading-18">3.生命周期方法演进</h3>
<h4 data-id="heading-19">1.类组件生命周期演进</h4>
<h5 data-id="heading-20">1.传统生命周期（React 16.3前）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-comment">// 初始化阶段</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) { 
    <span class="hljs-variable language_">super</span>(props);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-comment">/*...*/</span> };
  }

  <span class="hljs-comment">// 挂载阶段</span>
  <span class="hljs-title function_">componentWillMount</span>(<span class="hljs-params"></span>) { }      <span class="hljs-comment">// ⚠️已废弃</span>
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> }
  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) { }      <span class="hljs-comment">// 主要副作用执行位置</span>

  <span class="hljs-comment">// 更新阶段（props/state变化）</span>
  <span class="hljs-title function_">componentWillReceiveProps</span>(<span class="hljs-params">nextProps</span>) { }  <span class="hljs-comment">// ⚠️已废弃</span>
  <span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextProps, nextState</span>) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> } <span class="hljs-comment">// 性能优化关键</span>
  <span class="hljs-title function_">componentWillUpdate</span>(<span class="hljs-params"></span>) { }    <span class="hljs-comment">// ⚠️已废弃</span>
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">/*...*/</span> }
  <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState</span>) { }

  <span class="hljs-comment">// 卸载阶段</span>
  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) { }   <span class="hljs-comment">// 资源清理</span>
}
</code></pre>
<h5 data-id="heading-21">4.新版本生命周期（React 16.3+）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-comment">// 新增静态方法替代 componentWillReceiveProps</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>) { 
    <span class="hljs-comment">// 必须返回新的state或null</span>
  }

  <span class="hljs-comment">// 新增错误边界处理</span>
  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, info</span>) { }

  <span class="hljs-comment">// 替代 componentWillUpdate</span>
  <span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params">prevProps, prevState</span>) {
    <span class="hljs-comment">// 返回快照值给 componentDidUpdate</span>
  }
}
</code></pre>
<h4 data-id="heading-22">2.生命周期阶段</h4>
<h5 data-id="heading-23">1.Mounting阶段</h5>
<ul>
<li><strong>constructor</strong>：初始化state、绑定方法</li>
<li><strong>getDerivedStateFromProps</strong>：props初始化时同步到state</li>
<li><strong>render</strong>：生成虚拟DOM</li>
<li><strong>componentDidMount</strong>：网络请求、DOM操作、订阅事件</li>
</ul>
<h5 data-id="heading-24">2.Updating阶段</h5>
<ul>
<li><strong>getDerviedStateFromProps</strong>：props变化时更新state</li>
<li><strong>shouldComponentUpdate</strong>：返回false可阻止渲染（性能优化核心）</li>
<li><strong>render</strong>：生成新虚拟DOM</li>
<li><strong>getSnapshotBeforeUpdate</strong>：获取DOM更新前的状态（如滚动位置）</li>
<li><strong>componentDidUpdate</strong>：DOM更新后操作、网络请求</li>
</ul>
<h5 data-id="heading-25">3.Unmounting阶段</h5>
<ul>
<li><strong>componentWillUnmount</strong>：清除定时器、取消订阅、释放资源等</li>
</ul>
<h4 data-id="heading-26">3.函数组件生命周期模拟</h4>
<p>通过useEffect Hook实现生命周期控制：</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Mounting</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// componentDidMount</span>
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(...);
    
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">// componentWillUnmount</span>
      <span class="hljs-built_in">clearInterval</span>(timer);
    }
  }, []);

  <span class="hljs-comment">// Updating</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// componentDidUpdate（任意状态变化时）</span>
  });

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 特定状态变化时执行（替代 componentDidUpdate）</span>
  }, [count]); 

  <span class="hljs-comment">// getDerivedStateFromProps 模拟</span>
  <span class="hljs-keyword">const</span> [derivedState, setDerivedState] = <span class="hljs-title function_">useState</span>();
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setDerivedState</span>(props.<span class="hljs-property">input</span>);
  }, [props.<span class="hljs-property">input</span>]);
}
</code></pre>
<h4 data-id="heading-27">4.生命周期废弃原因与最佳实践</h4>

























<table><thead><tr><th><strong>废弃方法</strong>​</th><th>​<strong>替代方案</strong>​</th><th>​<strong>废弃原因</strong>​</th></tr></thead><tbody><tr><td>componentWillMount</td><td>constructor 或 useEffect</td><td>异步渲染导致可能多次执行</td></tr><tr><td>componentWillReceiveProps</td><td>getDerivedStateFromProps + useEffect</td><td>容易产生副作用和竞态条件</td></tr><tr><td>componentWillUpdate</td><td>getSnapshotBeforeUpdate</td><td>不安全副作用操作风险</td></tr></tbody></table>
<h4 data-id="heading-28">5.性能优化</h4>
<ul>
<li><strong>shouldComponentUpdate优化</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextProps, nextState</span>) {
  <span class="hljs-comment">// 浅比较 props 和 state 变化</span>
  <span class="hljs-keyword">return</span> !<span class="hljs-title function_">shallowEqual</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>, nextProps) 
      || !<span class="hljs-title function_">shallowEqual</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>, nextState);
}
</code></pre>
<ul>
<li><strong>PureComponent自动浅比较</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.PureComponent</span> { ... }
</code></pre>
<ul>
<li><strong>React.memo函数组件优化</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">MyComponent</span>, areEqual);
</code></pre>
<h4 data-id="heading-29">6.错误边界处理</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  state = { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> };
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params">error</span>) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> };
  }

  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, info</span>) {
    <span class="hljs-title function_">logErrorToService</span>(error, info);
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span> 
      ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FallbackUI</span> /&gt;</span></span> 
      : <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;
  }
}
</code></pre>
<h4 data-id="heading-30">7.高频面试题</h4>
<h5 data-id="heading-31">1.为什么componentWillXXX系列方法被标记为UNSAFE</h5>
<ul>
<li>异步渲染模式（Concurrent Mode）下可能被多次调用</li>
<li>副作用操作可能会导致渲染不一致</li>
</ul>
<h5 data-id="heading-32">2.useEffect与生命周期方法的对应关系</h5>
<ul>
<li><code>useEffect(fn, []) -&gt; componentDidMount + componentWillUnmount</code></li>
<li><code>useEffect(fn) -&gt; componentDidUpdate</code></li>
<li><code>useEffect(fn, [dep]) -&gt; 特定依赖更新时的副作用</code></li>
</ul>
<h5 data-id="heading-33">3.getDerivedStateFromProps的正确使用场景</h5>
<ul>
<li>仅当需要根据props变化被动更新state时使用</li>
<li>避免在此方法中触发副作用</li>
</ul>
<h3 data-id="heading-34">4.受控组件与非受控组件</h3>
<h4 data-id="heading-35">1.核心定义</h4>




















<table><thead><tr><th><strong>组件类型</strong>​</th><th>​<strong>数据管理方式</strong>​</th><th>​<strong>控制权</strong>​</th></tr></thead><tbody><tr><td>受控组件 (Controlled)</td><td>表单数据由 React 组件状态（state）驱动</td><td>React 完全控制</td></tr><tr><td>非受控组件 (Uncontrolled)</td><td>表单数据由 DOM 节点自身维护</td><td>DOM 原生控制</td></tr></tbody></table>
<h4 data-id="heading-36">2.实现原理对比</h4>
<h5 data-id="heading-37">1.受控组件实现</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ControlledForm</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params">e</span>) =&gt; {
    e.<span class="hljs-title function_">preventDefault</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'提交值:'</span>, value);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{handleSubmit}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
        <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> 
        <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span> 
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setValue(e.target.value)}
      /&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>
  );
}
</code></pre>
<p><strong>核心特点</strong></p>
<ul>
<li>value绑定到React state</li>
<li>onChange同步更新state</li>
<li>数据流：<code>React state -&gt; DOM</code>显示</li>
</ul>
<h5 data-id="heading-38">2.非受控组件实现</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UncontrolledForm</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params">e</span>) =&gt; {
    e.<span class="hljs-title function_">preventDefault</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'提交值:'</span>, inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span>);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{handleSubmit}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
        <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> 
        <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">"初始值"</span> 
        <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputRef}</span> 
      /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>
  );
}
</code></pre>
<p><strong>核心特点</strong></p>
<ul>
<li>使用ref访问DOM节点值</li>
<li>defaultValue设置初始值（非动态更新）</li>
<li>数据流：DOM节点 -&gt; 手动获取值</li>
</ul>
<h4 data-id="heading-39">3.核心差异分析</h4>








































<table><thead><tr><th><strong>维度</strong>​</th><th>​<strong>受控组件</strong>​</th><th>​<strong>非受控组件</strong>​</th></tr></thead><tbody><tr><td>数据存储位置</td><td>React 组件状态</td><td>DOM 节点</td></tr><tr><td>值更新机制</td><td>通过&nbsp;<code>onChange</code>&nbsp;事件同步更新 state</td><td>用户输入直接修改 DOM，需手动获取</td></tr><tr><td>表单验证时机</td><td>实时验证（每次输入触发）</td><td>提交时验证</td></tr><tr><td>动态表单控制</td><td>支持动态禁用/启用字段</td><td>需要手动操作 DOM</td></tr><tr><td>性能影响</td><td>高频输入场景可能引发多次渲染</td><td>无额外渲染开销</td></tr><tr><td>文件上传支持</td><td>不支持（文件输入天生不可控）</td><td>必须使用</td></tr></tbody></table>
<h4 data-id="heading-40">4.最佳实践场景</h4>
<h5 data-id="heading-41">受控组件适用场景</h5>
<ol>
<li>实时表单验证（如密码强度提示）</li>
<li>条件禁用提交按钮</li>
<li>动态表单字段（根据输入增减表单项）</li>
<li>复杂表单联动（多个输入相互依赖）</li>
</ol>
<h5 data-id="heading-42">非受控组件适用场景</h5>
<ol>
<li>一次性表单提交（只需要最终值）</li>
<li>文件上传<code>&lt;input type="file"&gt;</code></li>
<li>第三方库集成（需要直接操作DOM）</li>
</ol>
<h4 data-id="heading-43">5.进阶</h4>
<h5 data-id="heading-44">1.为什么文件输入必须用非受控组件?</h5>
<pre><code class="hljs language-js" lang="js">&lt;input type=<span class="hljs-string">"file"</span> onChange={handleFile} /&gt;
</code></pre>
<ul>
<li><strong>浏览安全限制</strong>：JavaScript无法以编程方式设置文件输入的值</li>
<li><strong>只读属性</strong>：文件路径由用户选择，无法通过React state控制</li>
</ul>
<h5 data-id="heading-45">2.如何给非受控组件设置初始值？</h5>
<ul>
<li>使用<code>defaultValue/defaultChecked</code>属性（类似原生HTML）</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;input type=<span class="hljs-string">"text"</span> defaultValue=<span class="hljs-string">"初始值"</span> ref={inputRef} /&gt;
</code></pre>
<h5 data-id="heading-46">3.受控组件性能优化策略</h5>
<ul>
<li><strong>防抖处理</strong>（避免高频触发渲染）</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> debouncedSetValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> 
  _.<span class="hljs-title function_">debounce</span>(setValue, <span class="hljs-number">300</span>), []
);
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> debouncedSetValue(e.target.value)} /&gt;</span>
</code></pre>
<ul>
<li><strong>精细化渲染控制</strong>：使用React.memo隔离表单组件</li>
</ul>
<h4 data-id="heading-47">6.混用模式</h4>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">HybridInput</span>(<span class="hljs-params">{ value: propValue, onChange }</span>) {
  <span class="hljs-keyword">const</span> [internalValue, setInternalValue] = <span class="hljs-title function_">useState</span>(propValue);
  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>();

  <span class="hljs-comment">// 同步外部传入的值</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (ref.<span class="hljs-property">current</span>.<span class="hljs-property">value</span> !== propValue) {
      ref.<span class="hljs-property">current</span>.<span class="hljs-property">value</span> = propValue;
      <span class="hljs-title function_">setInternalValue</span>(propValue);
    }
  }, [propValue]);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e</span>) =&gt; {
    <span class="hljs-title function_">setInternalValue</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);
    onChange?.(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);
  };

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{internalValue}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleChange}</span> /&gt;</span></span>;
}
</code></pre>
<h4 data-id="heading-48">7.高频面试题</h4>
<h5 data-id="heading-49">1.如何避免受控组件的value变成undefined？</h5>
<ul>
<li>确保value的值始终为受控值（字符串/数字），避免null或undefined</li>
</ul>
<h5 data-id="heading-50">2.受控组件中如何实现文本域（textarea）的换行符保留</h5>
<ul>
<li>使用<code>value={ text.replace(/\n/g, '\\n') }</code>处理，展示时转换回<code>\n</code></li>
</ul>
<h5 data-id="heading-51">3.为什么非受控组件不需要onChange处理?</h5>
<ul>
<li>非受控组件的数据流是单向的（DOM -&gt; React），仅在需要时通过ref获取值</li>
</ul>
<h4 data-id="heading-52">8.决策流程图</h4>
<pre><code class="hljs language-md" lang="md">是否需要实时验证/控制？ → 是 → 使用受控组件
<span class="hljs-code">           ↓
          否
           ↓
是否涉及文件上传？ → 是 → 使用非受控组件
           ↓
          否
           ↓
是否性能要求极高？ → 是 → 使用非受控组件
           ↓
          否
           ↓
默认推荐 → 受控组件
</span></code></pre>
<h3 data-id="heading-53">5.类组件和函数式组件</h3>
<h4 data-id="heading-54">1.核心定义与语法对比</h4>



































<table><thead><tr><th><strong>维度</strong>​</th><th>​<strong>类组件</strong>​</th><th>​<strong>函数式组件</strong>​</th></tr></thead><tbody><tr><td>​<strong>定义方式</strong>​</td><td>ES6 类继承&nbsp;<code>React.Component</code></td><td>JavaScript 函数</td></tr><tr><td>​<strong>状态管理</strong>​</td><td><code>this.state</code>&nbsp;+&nbsp;<code>this.setState()</code></td><td><code>useState</code>/<code>useReducer</code>&nbsp;Hooks</td></tr><tr><td>​<strong>生命周期</strong>​</td><td>完整生命周期方法（如&nbsp;<code>componentDidMount</code>）</td><td><code>useEffect</code>&nbsp;模拟生命周期</td></tr><tr><td>​<strong>副作用处理</strong>​</td><td>生命周期方法（如&nbsp;<code>componentDidUpdate</code>）</td><td><code>useEffect</code>&nbsp;+ 依赖数组</td></tr><tr><td>​<strong>代码量</strong>​</td><td>较冗长（需处理&nbsp;<code>this</code>&nbsp;绑定）</td><td>更简洁</td></tr></tbody></table>
<h4 data-id="heading-55">2.生命周期与Hooks映射关系</h4>
<h5 data-id="heading-56">类组件生命周期方法</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">/* 挂载完成 */</span> }
  <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">/* 更新完成 */</span> }
  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">/* 卸载前 */</span> }
  <span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">/* 决定是否渲染 */</span> }
}
</code></pre>
<h5 data-id="heading-57">函数式组件等效实现</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 模拟 componentDidMount + componentWillUnmount</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 挂载逻辑</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">/* 卸载逻辑 */</span> };
  }, []);

  <span class="hljs-comment">// 模拟 componentDidUpdate</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">/* 更新逻辑 */</span> });

  <span class="hljs-comment">// 模拟 shouldComponentUpdate</span>
  <span class="hljs-keyword">const</span> memoizedComponent = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> (<span class="hljs-comment">/* 组件 */</span>), <span class="hljs-function">(<span class="hljs-params">prevProps, nextProps</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">shallowEqual</span>(prevProps, nextProps);
  });
}
</code></pre>
<h4 data-id="heading-58">3.状态管理对比</h4>
<h5 data-id="heading-59">类组件状态管理</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };
  }

  increment = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> ({ <span class="hljs-attr">count</span>: prev.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> }));
  };
}
</code></pre>
<h5 data-id="heading-60">函数式组件状态管理</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);
  }, []);
}
</code></pre>
<h4 data-id="heading-61">4.性能优化策略</h4>






























<table><thead><tr><th><strong>优化手段</strong>​</th><th>​<strong>类组件</strong>​</th><th>​<strong>函数式组件</strong>​</th></tr></thead><tbody><tr><td>浅比较控制渲染</td><td><code>PureComponent</code>&nbsp;或&nbsp;<code>shouldComponentUpdate</code></td><td><code>React.memo</code>&nbsp;+ 自定义比较函数</td></tr><tr><td>计算缓存</td><td>手动缓存计算结果</td><td><code>useMemo</code></td></tr><tr><td>函数引用稳定性</td><td>箭头函数或&nbsp;<code>bind</code></td><td><code>useCallback</code></td></tr><tr><td>渲染节流</td><td>手动实现防抖/节流</td><td><code>useDebounce</code>&nbsp;自定义 Hook</td></tr></tbody></table>
<h4 data-id="heading-62">5.代码组织与逻辑复用</h4>
<h5 data-id="heading-63">类组件复用</h5>
<ul>
<li><strong>高阶组件（HOC）</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">withLogger</span> = <span class="hljs-title class_">WrappedComponent</span> =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extend</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> {
        <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>){
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'component mounted'</span>);
        }
        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
            <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...this.props</span>} /&gt;</span></span>
        }
    }
}
</code></pre>
<h5 data-id="heading-64">函数式组件复用方式</h5>
<ul>
<li><strong>自定义Hooks</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">useLogger</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Component mounted'</span>);
  }, []);
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">useLogger</span>();
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<h4 data-id="heading-65">6.关键差异深度解析</h4>
<h5 data-id="heading-66">1.this绑定问题（类组件）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) { 
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 未绑定时为 undefined</span>
  }

  <span class="hljs-comment">// 解决方案：</span>
  <span class="hljs-comment">// 1. 构造函数中绑定: this.handleClick = this.handleClick.bind(this);</span>
  <span class="hljs-comment">// 2. 箭头函数: handleClick = () =&gt; {...}</span>
}
</code></pre>
<h5 data-id="heading-67">2.闭包陷阱（函数式组件）</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Timer</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 始终捕获初始值 count=0</span>
      <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>); 
    }, <span class="hljs-number">1000</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);
  }, []); <span class="hljs-comment">// ❌ 错误：缺少依赖项</span>

  <span class="hljs-comment">// 修复方案：</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>); <span class="hljs-comment">// ✅ 使用函数式更新</span>
    }, <span class="hljs-number">1000</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);
  }, []);
}
</code></pre>
<h4 data-id="heading-68">7.现代React开发趋势</h4>
<h5 data-id="heading-69">1.Hooks的统治地位</h5>
<ul>
<li>官方推荐<strong>函数式组件+Hooks</strong>作为主要开发模式</li>
<li>React18新特性（如并发模式）优先支持Hooks</li>
</ul>
<h5 data-id="heading-70">2.类组件使用场景</h5>
<ul>
<li>旧项目维护</li>
<li>需要<code>Error Boundaries</code>（函数式组件暂不支持）</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  state = { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> };
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params">error</span>) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> };
  }
  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, info</span>) { <span class="hljs-comment">/* 记录错误 */</span> }
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">/* ... */</span> }
}
</code></pre>
<h4 data-id="heading-71">8.高频面试题</h4>
<h5 data-id="heading-72">1.为什么推荐使用函数式组件？</h5>
<ul>
<li><strong>代码简洁</strong>：避免this绑定和类语法冗余</li>
<li><strong>逻辑复用</strong>：自定义Hooks比HOC更灵活</li>
<li><strong>性能优化</strong>：Hooks提供更细颗粒度的控制（如useMemo）</li>
<li><strong>未来兼容</strong>：新特性（如并发模式）优先支持Hooks</li>
</ul>
<h5 data-id="heading-73">2.如何选择组件类型？</h5>
<ul>
<li>新项目：100%函数式组件+Hooks</li>
<li>旧项目：逐步迁移至函数式组件</li>
<li>特殊需求：需要getSnapshotBeforeUpdate或componentDidCatch时使用类组件</li>
</ul>
<h5 data-id="heading-74">3.Hooks的限制和突破</h5>
<ul>
<li>规则：只能在函数顶层调用Hooks</li>
<li>原理：依赖调用顺序的链表结构记录状态</li>
<li>解决方案：使用eslint-plugin-react-hooks强制规范</li>
</ul>
<h4 data-id="heading-75">9.核心对比表</h4>



































<table><thead><tr><th>​<strong>​维度​</strong>​</th><th>​<strong>​类组件优势​</strong>​</th><th>​<strong>​函数式组件优势​</strong>​</th></tr></thead><tbody><tr><td>代码可读性</td><td>生命周期逻辑集中</td><td>逻辑按功能聚合（Hooks 分组）</td></tr><tr><td>学习曲线</td><td>需掌握 OOP 概念</td><td>纯函数思维更符合 JavaScript 习惯</td></tr><tr><td>TypeScript 支持</td><td>类型推断较复杂</td><td>类型推导更直观</td></tr><tr><td>测试友好度</td><td>需处理实例方法</td><td>纯函数更易单元测试</td></tr><tr><td>未来维护性</td><td>官方逐步弱化支持</td><td>新特性优先适配</td></tr></tbody></table>
<h3 data-id="heading-76">6.props和state</h3>
<h4 data-id="heading-77">1.核心定义对比</h4>






























<table><thead><tr><th>​<strong>维度</strong>​</th><th>​<strong>props</strong>​</th><th>​<strong>state</strong>​</th></tr></thead><tbody><tr><td>​<strong>数据来源</strong>​</td><td>外部传入（父组件 → 子组件）</td><td>组件内部维护</td></tr><tr><td>​<strong>可变性</strong>​</td><td>只读（Immutable）</td><td>可修改（通过&nbsp;<code>setState</code>&nbsp;或&nbsp;<code>useState</code>）</td></tr><tr><td>​<strong>作用范围</strong>​</td><td>跨组件层级传递</td><td>组件私有，外部不可访问</td></tr><tr><td>​<strong>更新触发</strong>​</td><td>父组件重新渲染时传递新 props</td><td>调用状态更新方法触发重新渲染</td></tr></tbody></table>
<h4 data-id="heading-78">2.使用场景</h4>
<h5 data-id="heading-79">1.何时用props？</h5>
<ul>
<li><strong>组件通信</strong>：父组件向子组件传递数据或回调函数</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 父组件</span>
&lt;<span class="hljs-title class_">UserProfile</span> name=<span class="hljs-string">"Alice"</span> age={<span class="hljs-number">25</span>} onUpdate={handleUpdate} /&gt;

<span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">{ name, age, onUpdate }</span>) { ... }
</code></pre>
<ul>
<li><strong>配置参数</strong>：定义数组的默认行为或样式</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;<span class="hljs-title class_">Button</span> type=<span class="hljs-string">"primary"</span> size=<span class="hljs-string">"large"</span> /&gt;
</code></pre>
<ul>
<li><strong>渲染控制</strong>：通过props条件性渲染子组件</li>
</ul>
<pre><code class="hljs language-js" lang="js">&lt;<span class="hljs-title class_">Modal</span> visible={showModal} /&gt;
</code></pre>
<h5 data-id="heading-80">2.何时用state</h5>
<ul>
<li><strong>用户交互时</strong>：表单输入、按钮点击等</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> [inputValue, setInputValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);
</code></pre>
<ul>
<li><strong>组件私有数据</strong>：计时器ID、动画状态等</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> [timeId, setTimeId] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
</code></pre>
<ul>
<li><strong>动态UI状态</strong>：下拉菜单展开/收起、加载状态</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> [isOpen, setIsOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
</code></pre>
<h4 data-id="heading-81">3.深度对比与交互</h4>
<h5 data-id="heading-82">1.数据流方向</h5>
<ul>
<li><strong>单项数据流</strong>：props只能自上而下传递，state仅在组件内部流动</li>
</ul>
<pre><code class="hljs language-text" lang="text">父组件 → props → 子组件  
子组件 → 回调函数 → 父组件更新 state → 传递新 props
</code></pre>
<h5 data-id="heading-83">2.更新机制对比</h5>

























<table><thead><tr><th><strong>更新方式</strong>​</th><th>​<strong>props</strong>​</th><th>​<strong>state</strong>​</th></tr></thead><tbody><tr><td>​<strong>类组件</strong>​</td><td>父组件重新渲染时自动更新</td><td><code>this.setState()</code>&nbsp;触发异步更新</td></tr><tr><td>​<strong>函数组件</strong>​</td><td>父组件重新渲染时自动更新</td><td><code>useState</code>&nbsp;的 setter 函数触发更新</td></tr><tr><td>​<strong>更新影响</strong>​</td><td>子组件接收新 props 后重新渲染</td><td>当前组件及其子组件重新渲染</td></tr></tbody></table>
<h5 data-id="heading-84">3.数据交互示例</h5>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 父组件管理状态</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">count</span>=<span class="hljs-string">{count}</span> <span class="hljs-attr">onIncrement</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(c =&gt; c + 1)} /&gt;</span>;
}

<span class="hljs-comment">// 子组件通过 props 接收状态和回调</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">{ count, onIncrement }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onIncrement}</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<h4 data-id="heading-85">4.高级使用模式</h4>
<h5 data-id="heading-86">1.状态提升</h5>
<p>当多个组件需要共享状态的时候，将state提升到最近的共同祖先</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">'light'</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">{theme}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">{theme}</span> <span class="hljs-attr">onToggle</span>=<span class="hljs-string">{()</span> =&gt;</span> setTheme(t =&gt; t === 'light' ? 'dark' : 'light')} /&gt;
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
}
</code></pre>
<h5 data-id="heading-87">2.受控组件</h5>
<p>表单的值由props或state控制</p>
<pre><code class="hljs language-js" lang="js">&lt;input 
  value={inputValue} 
  onChange={<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-title function_">setInputValue</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)}
/&gt;
</code></pre>
<h5 data-id="heading-88">3.非受控组件</h5>
<p>使用ref直接访问DOM节点值（避免与state发生冲突）</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();
<span class="hljs-comment">// 提交时获取值</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span>);
<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputRef}</span> <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">""</span> /&gt;</span></span>;
</code></pre>
<h4 data-id="heading-89">5.开发注意事项</h4>
<h5 data-id="heading-90">1.props不可变性原则</h5>
<ul>
<li><strong>禁止修改props</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// ❌ 错误做法</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">{ user }</span>) {
  user.<span class="hljs-property">name</span> = <span class="hljs-string">'Bob'</span>; <span class="hljs-comment">// 直接修改 props 对象</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<h5 data-id="heading-91">2.state更新陷阱</h5>
<ul>
<li><strong>异步更新问题</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// ❌ 错误：连续调用不会合并更新</span>
<span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);
<span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);

<span class="hljs-comment">// ✅ 正确：使用函数式更新</span>
<span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);
<span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);
</code></pre>
<h5 data-id="heading-92">3.性能优化</h5>
<ul>
<li><strong>避免不必要的渲染</strong></li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 使用 React.memo 浅比较 props</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">MyComponent</span>);

<span class="hljs-comment">// 类组件中使用 shouldComponentUpdate</span>
<span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextProps, nextState</span>) {
  <span class="hljs-keyword">return</span> !<span class="hljs-title function_">shallowEqual</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>, nextProps);
}
</code></pre>
<h4 data-id="heading-93">六、高频面试题</h4>
<h5 data-id="heading-94">1.能否在子组件修改props？</h5>
<ul>
<li><strong>不能</strong>。props是只读的，修改会导致React抛出警告。若需要修改数据，应通过父组件传递回调函数更新父级state</li>
</ul>
<h5 data-id="heading-95">2.props和state可以相互转换吗？</h5>
<ul>
<li><strong>可以</strong>，例如父组件的state作为props传递给子组件，或子组件通过回调函数触发父组件更新</li>
</ul>
<h5 data-id="heading-96">3.如何实现跨多层组件传递props</h5>
<ul>
<li>使用<code>Context API</code>或状态管理库（如<code>Redux、Mobx</code>）避免props逐层传递</li>
</ul>
<blockquote>
<p>以上是React面试题的基础篇内容，如有错误欢迎评论区指正，后续还会更新React进阶篇。</p>
</blockquote>
<ul>
<li><a href="https://juejin.cn/post/7504545616841965583" target="_blank" title="https://juejin.cn/post/7504545616841965583">2025前端面试题-React进阶篇</a></li>
<li><a href="https://juejin.cn/post/7504926961627054099" target="_blank" title="https://juejin.cn/post/7504926961627054099">2025前端面试题-React高阶篇</a></li>
<li><a href="https://juejin.cn/post/7503111373468893193" target="_blank" title="https://juejin.cn/post/7503111373468893193">2025前端面试题-Vue3基础篇</a></li>
<li><a href="https://juejin.cn/post/7511568225987051555" target="_blank" title="https://juejin.cn/post/7511568225987051555">2025前端面试题-Vue3进阶篇</a></li>
</ul></div></div>