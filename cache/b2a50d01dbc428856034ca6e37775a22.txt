
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18650441" title="发布于 2025-01-03 16:39">
    <span role="heading" aria-level="2">掌握设计模式--组合模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="组合模式composite-pattern">组合模式（Composite Pattern）</h2>
<p>组合模式（Composite Pattern）是一种结构型设计模式，它用于将对象组织成<code>树形结构</code>，以表示<code>部分-整体</code>的层次结构。通过组合模式，客户端可以统一对待单个对象和组合对象，从而简化了客户端代码的复杂性。</p>
<h3 id="组合模式的核心思想">组合模式的核心思想</h3>
<ol>
<li><strong>统一的接口</strong>：通过抽象类或接口将<code>单个对象</code>和<code>组合对象</code>统一起来；</li>
<li><strong>递归组合</strong>：<code>组合对象</code>中可以包含单个对象或其他组合对象；</li>
<li><strong>透明性</strong>：客户端可以<code>一致地调用</code>单个对象和组合对象的方法，而无需区分两者的差异。</li>
</ol>
<h3 id="组合模式的角色">组合模式的角色</h3>
<ol>
<li>
<p><strong>组件（Component）</strong><br>
定义单个对象和组合对象的公共接口，例如通用操作（<code>add</code>、<code>remove</code>、<code>getChild</code>等）。</p>
</li>
<li>
<p><strong>叶子节点（Leaf）</strong><br>
表示树形结构中的基本单元，不能再包含其他对象。它实现了组件接口，但不支持添加或移除操作。</p>
</li>
<li>
<p><strong>组合对象（Composite）</strong><br>
表示树形结构中的复杂单元，可以包含叶子节点或其他组合对象。它实现组件接口，并负责管理其子对象的操作。</p>
</li>
</ol>
<h2 id="示例代码">示例代码</h2>
<p>组合模式解析XML或 HTML 元素结构的代码示例。我们将 XML/HTML 元素看作“部分-整体”结构，其中：</p>
<ul>
<li><strong>叶子节点(leaf)</strong>：表示没有子节点的元素（如 <code>&lt;img&gt;</code> 或 <code>&lt;input&gt;</code>）。</li>
<li><strong>组合节点(Composite)</strong>：表示可以包含其他子元素的元素（如 <code>&lt;div&gt;</code> 或 <code>&lt;body&gt;</code>）。</li>
</ul>
<p>两种节点使用同一种的顶层抽象，属于同一类对象，统称为元素（节点）。</p>
<h3 id="类图">类图</h3>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250103163725610-1429970605.png" alt="image" loading="lazy"></p>
<h3 id="1-抽象组件">1. 抽象组件</h3>
<p>HTML顶层元素抽象类。你也可以定义一个顶层接口，然后在抽象类中实现基础功能。</p>
<pre><code class="language-java">public abstract class HTMLElement {
    protected String name;

    public HTMLElement(String name) {
        this.name = name;
    }

    public abstract void render(int level);

    public HTMLElement getChild(int index) {
        throw new UnsupportedOperationException();
    }

    // 默认行为：叶子结点禁止新增元素
    public void addChild(HTMLElement element) {
        throw new UnsupportedOperationException();
    }
    // 默认行为：叶子结点禁止移除子元素
    public void removeChild(HTMLElement element) {
        throw new UnsupportedOperationException();
    }

    // 辅助方法：生成缩进
    protected String generateIndent(int level) {
        StringBuilder indent = new StringBuilder();
        for (int i = 0; i &lt; level * 2; i++) {
            indent.append(" "); // 每层缩进2个空格
        }
        return indent.toString();
    }
}
</code></pre>
<h3 id="2-组合结点">2. 组合结点</h3>
<p>表示可以包含子元素的HTML标签</p>
<pre><code class="language-java">public class HTMLComposite extends HTMLElement {
    private List&lt;HTMLElement&gt; children = new LinkedList&lt;&gt;();

    public HTMLComposite(String name) {
        super(name);
    }

    @Override
    public void addChild(HTMLElement element) {
        children.add(element);
    }

    @Override
    public void removeChild(HTMLElement element) {
        children.remove(element);
    }

    @Override
    public HTMLElement getChild(int index) {
        return children.get(index);
    }

    @Override
    public void render(int level) {
        System.out.println(generateIndent(level) + "&lt;" + name + "&gt;");
        for (HTMLElement child : children) {
            child.render(level + 1); // 子节点递归调用
        }
        System.out.println(generateIndent(level) + "&lt;/" + name + "&gt;");
    }
}
</code></pre>
<h3 id="3叶子节点">3.叶子节点</h3>
<p>表示没有子元素的HTML标签</p>
<pre><code class="language-java">public class HTMLLeaf extends HTMLElement {
    public HTMLLeaf(String name) {
        super(name);
    }

    @Override
    public void render(int level) {
        System.out.println(generateIndent(level) + "&lt;" + name + " /&gt;");
    }
}
</code></pre>
<h3 id="测试">测试</h3>
<pre><code class="language-java">public class CompositePatternHTMLDemo {
    public static void main(String[] args) {
        // 创建HTML结构
        HTMLElement html = new HTMLComposite("html");
        HTMLElement body = new HTMLComposite("body");
        HTMLElement div = new HTMLComposite("div");
        HTMLElement img = new HTMLLeaf("img");
        HTMLElement input = new HTMLLeaf("input");
        HTMLElement p = new HTMLLeaf("p");


        // 组合结构
        html.addChild(body);
        body.addChild(div);
        body.addChild(input);
        div.addChild(img);
        div.addChild(p);

        // 渲染HTML结构
        html.render(0);

        // 去除某个节点
        div.removeChild(p);
        html.render(0);
    }
}
</code></pre>
<p>测试结果：</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;body&gt;
    &lt;div&gt;
      &lt;img /&gt;
      &lt;p /&gt;
    &lt;/div&gt;
    &lt;input /&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;div&gt;
      &lt;img /&gt;
    &lt;/div&gt;
    &lt;input /&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>从类图或测试类（使用者）中可以看出，使用者直接依赖于具体的类，属于高耦合的一种编程方式。</p>
<h3 id="简单优化结合其它设计模式">简单优化（结合其它设计模式）</h3>
<p>加入一个工厂类来创建组合节点和叶子结点</p>
<p><strong>类图结构</strong>变为</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250103163742394-1654785100.png" alt="image" loading="lazy"></p>
<p><strong>工厂类代码</strong></p>
<pre><code class="language-java">public class HTMLElementFactory {
    private static Map&lt;String, Class&lt;? extends HTMLElement&gt;&gt; elementRegistry = new HashMap&lt;&gt;();

    static {
        // 注册类
        try {
            HTMLElementFactory.registerElement("composite", (Class&lt;? extends HTMLElement&gt;) Class.forName("org.example.composite.htmldemo.HTMLComposite"));
            HTMLElementFactory.registerElement("leaf", (Class&lt;? extends HTMLElement&gt;) Class.forName("org.example.composite.htmldemo.HTMLLeaf"));
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }

    // 注册类
    public static void registerElement(String type, Class&lt;? extends HTMLElement&gt; clazz) {
        elementRegistry.put(type, clazz);
    }

    // 创建实例
    public HTMLElement createElement(String type, String name) {
        Class&lt;? extends HTMLElement&gt; clazz = elementRegistry.get(type);
        if (clazz == null) {
            throw new IllegalArgumentException("未知元素类型: " + type);
        }
        try {
            return clazz.getDeclaredConstructor(String.class).newInstance(name);
        } catch (Exception e) {
            throw new RuntimeException("错误创建元素对象: " + e.getMessage(), e);
        }
    }
}
</code></pre>
<p>测试代码</p>
<pre><code class="language-java">public class CompositePatternHTMLDemo {
    public static void main(String[] args) {
        // 创建HTML结构
//        HTMLElement html = new HTMLComposite("html");
//        HTMLElement body = new HTMLComposite("body");
//        HTMLElement div = new HTMLComposite("div");
//        HTMLElement img = new HTMLLeaf("img");
//        HTMLElement input = new HTMLLeaf("input");
//        HTMLElement p = new HTMLLeaf("p");

        HTMLElementFactory htmlElementFactory = new HTMLElementFactory();
        // 创建对象
        HTMLElement html = htmlElementFactory.createElement("composite", "html");
        HTMLElement body = htmlElementFactory.createElement("composite", "body");
        HTMLElement div = htmlElementFactory.createElement("composite", "div");
        HTMLElement input = htmlElementFactory.createElement("leaf", "input");
        HTMLElement img = htmlElementFactory.createElement("leaf", "img");
        HTMLElement p = htmlElementFactory.createElement("leaf", "p");

        // 组合结构
        html.addChild(body);
        body.addChild(div);
        body.addChild(input);
        div.addChild(img);
        div.addChild(p);

        // 渲染HTML结构
        html.render(0);

        // 去除某个节点
        div.removeChild(p);
        html.render(0);
    }
}
</code></pre>
<p>测试结果和前面的一样。</p>
<p>除了结合工厂模式外，还可以结合其它设计模式。比如，结合迭代器模式来递归遍历组合树。</p>
<h2 id="总结">总结</h2>
<p>组合模式（Composite Pattern）是一种结构型设计模式，它用于将对象组织成<code>树形结构</code>，以表示<code>部分-整体</code>的层次结构。同时可以结合其它设计模式，使组合模式变得更加灵活和高效。</p>
<h3 id="优点">优点</h3>
<ol>
<li><strong>透明性</strong>：客户端无需区分单个对象和组合对象。</li>
<li><strong>灵活性</strong>：可以方便地动态组合对象，拓展系统。</li>
<li><strong>符合开闭原则</strong>：添加新的组件类无需修改现有代码。</li>
</ol>
<p><strong>开闭原则</strong>的核心是：</p>
<ul>
<li><strong>对扩展开放</strong>：可以通过扩展系统的功能，而不是修改已有的代码来实现新需求。</li>
<li><strong>对修改关闭</strong>：已有的代码逻辑不需要因需求变化而被改动。</li>
</ul>
<p>关于<strong>开闭原则的“修改关闭”主要是指不修改核心业务逻辑</strong>。对于工厂类这样的“管理型”代码，适当的修改是可以接受的，因为它并不属于核心业务逻辑。</p>
<h3 id="缺点">缺点</h3>
<ol>
<li><strong>复杂性增加</strong>：系统中的类和对象数量可能会增多。</li>
<li><strong>单一职责原则的可能破坏</strong>：组合对象需要管理其子对象，可能职责过多。</li>
</ol>
<h3 id="使用场景">使用场景</h3>
<ol>
<li>文件系统（文件和文件夹）；</li>
<li>GUI（窗口、按钮、文本框等控件）；</li>
<li>公司组织架构（员工与部门）；</li>
<li>XML或HTML的元素结构。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250103163759563-1937468555.gif" alt="image" loading="lazy"></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485977&amp;idx=1&amp;sn=1fcbbbe778bc863c176ba1ed3088f43f&amp;chksm=ec62ca84db154392e0f7ea45ce4f332653578bb3b59dcff9bbc35a5cfba07fbbc009be57651d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">什么是设计模式？</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486033&amp;idx=1&amp;sn=9c2d6e06e9146e19fa6c8f2d20aaf40a&amp;chksm=ec62caccdb1543da80271cd2e558127d9880d1f5b8d5ba9d8af29c67f42e8fa9d11524212b2e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">单例模式及其思想</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486104&amp;idx=1&amp;sn=9bc3a4f1046186e36fd8c9cdfae41e1e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">设计模式--原型模式及其编程思想</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486123&amp;idx=1&amp;sn=c67702624f1a2c981cee5982de78fbf9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">掌握设计模式之生成器模式</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486132&amp;idx=1&amp;sn=4dde3fe1150bb631ef4f192aef92c8e1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">掌握设计模式之简单工厂模式</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486141&amp;idx=1&amp;sn=2b7b397561dcdd10e10bee654ce893a3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">掌握设计模式之工厂方法模式</a></p>
<p><a href="https://mp.weixin.qq.com/s/Rw4iTuor_3wi9AVUp7aUTA" target="_blank" rel="noopener nofollow">掌握设计模式--装饰模式</a></p>
<hr>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0672791049224537" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-03 16:39">2025-01-03 16:39</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">18</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18650441" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18650441);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18650441', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18650441', title: '掌握设计模式--组合模式' })">举报</a>
</div>
        