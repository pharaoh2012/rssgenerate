
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18873817" title="发布于 2025-05-13 10:14">
    <span role="heading" aria-level="2">集成学习常用组合策略：让多个模型“合作”得更好</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><strong>集成学习</strong>通过组合多个学习器的预测结果，达到超越单个学习器的效果。</p>
<p>就像医生会诊时综合多位专家的意见，集成学习的关键在于如何有效整合不同学习器的判断。</p>
<p>这些学习器可以是不同类型的模型，比如决策树、支持向量机、神经网络等。通过合理地组合这些学习器，我们可以获得比单一模型更好的预测效果。</p>
<p>今天，重点介绍<strong>4种</strong>常见的<strong>集成学习</strong>组合策略：<strong>平均法</strong>、<strong>加权平均法</strong>、<strong>投票法</strong>和<strong>加权投票法</strong>。</p>
<h1 id="1-回归任务组合策略">1. 回归任务组合策略</h1>
<h2 id="11-平均法">1.1. 平均法</h2>
<p><strong>平均法</strong>是一种非常简单直观的组合策略。</p>
<p>假设我们有多个学习器，每个学习器都会对同一个问题给出一个预测值。</p>
<p>平均法就是将这些预测值简单地取平均，作为最终的预测结果。</p>
<p>它的原理如果用数学公式来表示的话，</p>
<p>假设有$ n <span class="math inline">\(个学习器，每个学习器对某个样本的预测值分别为\)</span> y_1,y_2,\dots,y_n $，</p>
<p>那么<strong>平均法</strong>的预测结果$ y_{avg} <span class="math inline">\(就是：\)</span> y_{avg}=\frac{y_1+y_2+\dots+y_n}{n} $</p>
<p><strong>平均法</strong>的优点在于：</p>
<ul>
<li>实现简单，计算效率高。</li>
<li>对所有学习器一视同仁，不偏袒任何一个。</li>
</ul>
<p>不过，如果某些学习器的性能明显优于其他学习器，平均法可能会降低整体性能。</p>
<h2 id="12-加权平均法">1.2. 加权平均法</h2>
<p><strong>加权平均法</strong>是对<strong>平均法</strong>的一种改进。</p>
<p>它认为不同的学习器可能有不同的重要性，因此给每个学习器分配一个权重，然后根据权重计算加权平均值。</p>
<p>它的原理是：</p>
<p>假设每个学习器的权重分别为$ w_1,w_2,\dots,w_n <span class="math inline">\(，且满足\)</span> w_1+w_2+\dots+w_n=1 $，</p>
<p>那么加权平均法的预测结果$ y_{weighted} <span class="math inline">\(就是：\)</span> y_{weighted}=w_1 y_1+w_2 y_2+\dots+w_n y_n $</p>
<p>加权平均法的优点在于：</p>
<ul>
<li>可以根据学习器的性能或其他标准分配权重，更灵活。</li>
<li>如果权重分配合理，可以提高整体性能。</li>
</ul>
<p>不过，权重的选择需要一定的经验和技巧，否则可能会适得其反。</p>
<h2 id="13-代码示例">1.3. 代码示例</h2>
<p>下面，我们使用<code>scikit-learn</code>来实现平均法和加权平均法。</p>
<p>示例中，我们构造了三个不同的回归模型：线性回归、决策树回归和随机森林回归。</p>
<p>然后分别用<strong>平均法</strong>和<strong>加权平均法</strong>来实现三个模型的集成学习，看看两种方法的<code>MSE</code>（<strong>均方误差</strong>）。</p>
<pre><code class="language-python">import numpy as np
from sklearn.datasets import make_regression
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error

# 创建数据集
X, y = make_regression(n_samples=1000, n_features=10, noise=0.1, random_state=42)
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# 创建不同的回归模型
models = {
    "线性回归": LinearRegression(),
    "决策树": DecisionTreeRegressor(random_state=42),
    "随机森林": RandomForestRegressor(random_state=42),
}

# 训练模型
for name, model in models.items():
    model.fit(X_train, y_train)
    print(f"{name} trained.")

# 平均法
predictions = []
for model in models.values():
    pred = model.predict(X_test)
    predictions.append(pred)

average_prediction = np.mean(predictions, axis=0)
print("平均法 MSE:", mean_squared_error(y_test, average_prediction))

# 加权平均法
weights = [0.7, 0.2, 0.1]  # 假设我们给每个模型分配不同的权重
weighted_prediction = np.average(predictions, axis=0, weights=weights)
print("加权平均法 MSE:", mean_squared_error(y_test, weighted_prediction))

## 输出结果：
'''
线性回归 trained.
决策树 trained.
随机森林 trained.
平均法 MSE: 1564.00882692281
加权平均法 MSE: 382.4462907617945
'''
</code></pre>
<p>从结果来看，通过调整三种模型的权重（<code>weights = [0.7, 0.2, 0.1]</code>），<strong>加权平均法</strong>的<code>MSE</code>要小很多。</p>
<p>当然，如果权重设置的不合理，<strong>加权平均法</strong>的<code>MSE</code>也可能比<strong>平均法</strong>大很多。</p>
<h1 id="2-分类任务组合策略">2. 分类任务组合策略</h1>
<h2 id="21-投票法">2.1. 投票法</h2>
<p><strong>投票法</strong>主要用于<strong>分类问题</strong>。</p>
<p>假设我们有多个分类器，每个分类器都会对同一个样本进行分类预测。</p>
<p><strong>投票法</strong>就是让这些分类器“投票”，然后根据多数票来确定最终的分类结果。</p>
<p>如果用<strong>简单投票法</strong>，那么，每个分类器的预测结果都是一票，最终选择得票最多的类别作为预测结果。</p>
<p><strong>投票法</strong>的优点在于：</p>
<ul>
<li>实现简单，容易理解。</li>
<li>对所有分类器一视同仁，不偏袒任何一个。</li>
</ul>
<p>不过，如果某些分类器的性能明显优于其他分类器，投票法也可能会降低整体性能。</p>
<h2 id="22-加权投票法">2.2. 加权投票法</h2>
<p><strong>加权投票法</strong>是对投票法的一种改进。</p>
<p>它认为不同的分类器可能有不同的重要性，因此给每个分类器分配一个权重，然后根据权重计算加权投票结果。</p>
<p>假设每个分类器的权重分别为$ w_1,w_2,\dots,w_n <span class="math inline">\(，且满足\)</span> w_1+w_2+\dots+w_n=1 $，那么每个类别的加权票数就是该类别在所有分类器中的预测概率乘以对应的权重之和。</p>
<p>最终选择<strong>加权票数最多</strong>的类别作为预测结果。</p>
<p><strong>加权投票法</strong>的优点是：</p>
<ul>
<li>可以根据分类器的性能或其他标准分配权重，更灵活。</li>
<li>如果权重分配合理，可以提高整体性能。</li>
</ul>
<p>不过，权重的选择需要一定的经验和技巧，否则可能会适得其反。</p>
<h2 id="23-代码示例">2.3. 代码示例</h2>
<p>下面，使用<code>scikit-learn</code>来实现投票法和加权投票法。</p>
<p>假设我们有三个不同的分类模型：逻辑回归、决策树分类器和支持向量机分类器。</p>
<pre><code class="language-python">from sklearn.datasets import make_classification
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.ensemble import VotingClassifier
from sklearn.metrics import accuracy_score

# 创建数据集
X, y = make_classification(
    n_samples=1000, n_features=10, n_informative=5, n_redundant=3, random_state=42
)
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# 创建不同的分类模型
models = {
    "逻辑回归": LogisticRegression(random_state=42),
    "决策树": DecisionTreeClassifier(random_state=42),
    "SVC": SVC(probability=True, random_state=42),
}

# 训练模型
for name, model in models.items():
    model.fit(X_train, y_train)
    print(f"{name} trained.")

# 简单投票法
voting_clf = VotingClassifier(
    estimators=[(name, model) for name, model in models.items()], voting="hard"
)
voting_clf.fit(X_train, y_train)
y_pred = voting_clf.predict(X_test)
print("简单投票法 准确率:", accuracy_score(y_test, y_pred))

# 加权投票法
weights = [0.2, 0.3, 0.5]  # 假设我们给每个模型分配不同的权重
weighted_voting_clf = VotingClassifier(
    estimators=[(name, model) for name, model in models.items()],
    voting="soft",
    weights=weights,
)
weighted_voting_clf.fit(X_train, y_train)
y_pred = weighted_voting_clf.predict(X_test)
print("加权投票法 准确率:", accuracy_score(y_test, y_pred))

## 输出结果：
'''
逻辑回归 trained.
决策树 trained.
SVC trained.
简单投票法 准确率: 0.96
加权投票法 准确率: 0.965
'''
</code></pre>
<p>通过调节三种模型的权重，<strong>加权投票法</strong>的准确率略高，有兴趣的朋友可以试试其他的权重分配方式。</p>
<h1 id="3-组合策略对比">3. 组合策略对比</h1>
<p>我们在选择组合策略时，不一定加权的就一定比不加权的好，需要根据具体的场景和数据来决定选择哪种组合策略。</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>适用场景</th>
<th>计算复杂度</th>
<th>抗噪能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单平均</td>
<td>模型性能相近</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>加权平均</td>
<td>模型差异明显</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>多数投票</td>
<td>分类任务简单</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>加权投票</td>
<td>分类器可信度不同</td>
<td>中</td>
<td>中</td>
</tr>
</tbody>
</table>
<p>选择组合策略时，建议：</p>
<ol>
<li>当模型性能差异较大时优先选择加权方法</li>
<li>数据噪声较多时使用平均法或简单投票、</li>
<li>分类任务中推荐优先尝试软投票策略</li>
</ol>
<h1 id="4-总结">4. 总结</h1>
<p>集成学习中的组合策略有很多种，今天我们介绍了平均法、加权平均法、投票法和加权投票法。</p>
<p>这些策略各有优缺点，选择哪种策略取决于具体的问题和模型的性能。</p>
<p>在实际应用中，我们可以通过实验来选择最适合的组合策略，从而提高模型的整体性能。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.039307938" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-13 10:15">2025-05-13 10:14</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18873817);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18873817', targetLink: 'https://www.cnblogs.com/wang_yb/p/18873817', title: '集成学习常用组合策略：让多个模型“合作”得更好' })">举报</a>
</div>
        