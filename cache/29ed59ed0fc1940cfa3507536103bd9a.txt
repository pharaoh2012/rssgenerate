
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/xwz1024/p/19025414" title="发布于 2025-08-06 16:54">
    <span role="heading" aria-level="2">DRF视图详解：从基础视图到通用视图实践指南</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/1565852/202508/1565852-20250806165344424-2060911225.png" alt="DRF视图详解：从基础视图到通用视图实践指南" class="desc_img">
        在 Django REST Framework (DRF) 开发中，视图是处理 HTTP 请求并返回响应的核心组件。DRF 提供了多种视图类型，从基础的 APIView 到功能丰富的通用视图。本文将详细介绍视图的演进过程，帮助理解不同视图的设计思想和使用方法。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一基础视图-apiview">一、基础视图 (APIView)</h2>
<p><code>APIView</code> 是 DRF 中所有视图的基类，继承自 Django 的 <code>View</code>，并添加了 DRF 特有的功能（如认证、权限、限流等）。</p>
<p>示例：使用APIView实现“增删改查查”</p>
<pre><code class="language-python">from rest_framework.views import APIView
from rest_framework import serializers
from rest_framework.response import Response
from rest_framework import generics

class ShopSerializer(serializers.ModelSerializer):
    class Meta:
        model = ShopModel
        fields = ["id", "username", "title", "description"]

class ShopView(APIView):
    # 查列表
    def get(self, request):
        shops = ShopModel.objects.all()
        serializer = ShopSerializer(instance=shops, many=True)
        return Response(serializer.data)

    # 增
    def post(self, request):
        serializer = ShopSerializer(data=request.data)
        if serializer.is_valid():  
            serializer.save()
            return Response(serializer.data)
        else:
            return Response(serializer.errors)


class ShopDetailView(APIView):
    # 查单个
    def get(self, request, pk):
        shop = ShopModel.objects.get(pk=pk)
        serializer = ShopSerializer(instance=shop)
        return Response(serializer.data)

    # 删
    def delete(self, request, pk):
        ShopModel.objects.get(pk=pk).delete()
        return Response()  

    # 改
    def put(self, request, pk):
        shop = ShopModel.objects.get(pk=pk)
        serializer = ShopSerializer(instance=shop, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        else:
            return Response(serializer.errors)
</code></pre>
<p>配置路由：<code>urls.py</code></p>
<pre><code class="language-python">from django.urls import path
from .views import ShopView, ShopDetailView

urlpatterns = [
    path("shops/", ShopView.as_view()),
    path("shops/&lt;int:pk&gt;/", ShopDetailView.as_view()),
]
</code></pre>
<p>这种方式虽然直观，但存在大量重复代码（如查询集获取、序列化器实例化等）。为了解决这个问题，DRF 提供了通用视图。</p>
<h2 id="二通用视图-generic-views">二、通用视图 (Generic Views)</h2>
<p>DRF 的通用视图基于 "Mixin 组合" 思想，将常用功能封装成可复用的组件，通过继承组合实现复杂功能。通用视图的核心是 <code>GenericAPIView</code>，它提供了基础的查询集和序列化器管理功能。</p>
<h3 id="常用通用视图">常用通用视图</h3>
<ul>
<li><code>ListAPIView</code>：获取列表数据（GET）</li>
<li><code>CreateAPIView</code>：创建数据（POST）</li>
<li><code>RetrieveAPIView</code>：获取单个数据（GET）</li>
<li><code>UpdateAPIView</code>：更新数据（PUT/PATCH）</li>
<li><code>DestroyAPIView</code>：删除数据（DELETE）</li>
<li>组合视图：<code>ListCreateAPIView</code>、<code>RetrieveUpdateAPIView</code> 等</li>
</ul>
<h3 id="通用视图示例学生信息管理">通用视图示例：学生信息管理</h3>
<p>步骤 1：定义模型</p>
<pre><code class="language-python"># models.py
from django.db import models

class Student(models.Model):
    name = models.CharField(max_length=255, verbose_name="姓名")
    age = models.IntegerField(verbose_name="年龄")
    gender = models.CharField(max_length=255, verbose_name="性别")
    
    class Meta:
        db_table = "student"
        verbose_name = "学生表"
</code></pre>
<p>步骤 2：创建序列化器</p>
<pre><code class="language-python"># serializers.py
from rest_framework import serializers
from .models import Student

class StudentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Student
        fields = "__all__"
</code></pre>
<p>步骤 3：实现通用视图</p>
<pre><code class="language-python"># views.py
from rest_framework.generics import ListCreateAPIView, RetrieveUpdateDestroyAPIView
from .models import Student
from .serializers import StudentSerializer

# 查列表、增 视图
class StudentListCreate(ListCreateAPIView):
    queryset = Student.objects.all()
    serializer_class = StudentSerializer

# 查单个、删、改 视图
class StudentRetrieveUpdateDestroy(RetrieveUpdateDestroyAPIView):
    queryset = Student.objects.all()
    serializer_class = StudentSerializer
</code></pre>
<p>步骤 4：配置 URL</p>
<pre><code class="language-python"># urls.py
from django.urls import path
from .views import StudentListCreate, StudentRetrieveUpdateDestroy

urlpatterns = [
    path("api/students/", StudentListCreate.as_view()),
    path("api/students/&lt;int:pk&gt;/", StudentRetrieveUpdateDestroy.as_view()),
]
</code></pre>
<p>使用通用视图，实现完整的 CRUD 功能，大大减少了重复代码。</p>
<h3 id="测试通用视图">测试通用视图</h3>
<p>运行Django项目</p>
<pre><code class="language-sh"># 创建管理员账号
python manage.py createsuperuser --username admin --email admin@example.com
# 运行Django项目
python manage.py runserver 0.0.0.0:8000
</code></pre>
<p>打开浏览器登录访问：<code>http://127.0.0.1:8000/api/books/</code></p>
<ul>
<li>get：查询列表</li>
<li>post：新增</li>
</ul>
<p><img alt="image-20240927081239620" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1565852/202508/1565852-20250806165300171-1565529712.png" class="lazyload"></p>
<p>打开浏览器登录访问：<code>http://127.0.0.1:8000/api/books/1</code></p>
<ul>
<li>get：查询单个对象</li>
<li>put：修改</li>
<li>delete：删除</li>
</ul>
<p><img alt="image-20240927081608988" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1565852/202508/1565852-20250806165308364-256570130.png" class="lazyload"></p>
<h2 id="三通用视图的高级用法">三、通用视图的高级用法</h2>
<h3 id="动态查询集">动态查询集</h3>
<p>通过重写 <code>get_queryset()</code> 方法，可以实现动态过滤查询集，例如只返回当前登录用户的数据：</p>
<pre><code class="language-python">def get_queryset(self):
    # 只返回当前用户创建的数据
    return Student.objects.filter(created_by=self.request.user)
</code></pre>
<h3 id="多字段查询">多字段查询</h3>
<p>默认情况下，通用视图通过 <code>pk</code> 字段查询单个对象。如果需要支持多字段查询，可以自定义 Mixin 类：</p>
<pre><code class="language-python">from django.shortcuts import get_object_or_404

class MultipleFieldLookupMixin:
    """支持多字段查询的 Mixin"""
    def get_object(self):
        queryset = self.get_queryset()
        queryset = self.filter_queryset(queryset)
        filter_conditions = {}
        # 遍历 lookup_fields 构建查询条件
        for field in self.lookup_fields:
            if self.kwargs.get(field):
                filter_conditions[field] = self.kwargs[field]
        return get_object_or_404(queryset, **filter_conditions)
</code></pre>
<p>使用示例：</p>
<pre><code class="language-python">class RetrieveUserView(MultipleFieldLookupMixin, generics.RetrieveAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    lookup_fields = ['account', 'username']  # 支持通过 account 或 username 查询
</code></pre>
<h3 id="自定义权限和认证">自定义权限和认证</h3>
<p>通过设置 <code>permission_classes</code> 和 <code>authentication_classes</code> 属性，可以为视图添加权限和认证控制：</p>
<pre><code class="language-python">from rest_framework.permissions import IsAuthenticated
from rest_framework.authentication import TokenAuthentication

class UserProfileView(RetrieveAPIView):
    serializer_class = UserSerializer
    # 只允许已认证用户访问
    permission_classes = [IsAuthenticated]
    # 使用 Token 认证
    authentication_classes = [TokenAuthentication]

    def get_object(self):
        # 返回当前登录用户信息
        return self.request.user
</code></pre>
<h2 id="四genericapiview类深度解析">四、GenericAPIView类深度解析</h2>
<p><code>GenericAPIView</code> 是 DRF 视图系统的核心抽象，它通过标准化的属性和方法，简化了数据查询、序列化和过滤等常见操作。通过与 Mixin 类结合，<code>GenericAPIView</code> 能够快速实现 CRUD 功能，同时保留了足够的灵活性，允许开发者通过重写方法定制业务逻辑。</p>
<h3 id="类继承关系">类继承关系</h3>
<p><code>GenericAPIView</code> 是 DRF 通用视图体系的基石，其继承关系如下</p>
<ul>
<li>作为 <code>APIView</code> 的子类，<code>GenericAPIView</code> 保留了请求处理、认证、权限、限流等基础功能</li>
<li><code>GenericAPIView</code> 新增了对查询集（QuerySet）和序列化器（Serializer）的标准化管理，为数据操作提供了统一接口</li>
</ul>
<p><img alt="image-20250806160540977" loading="lazy" data-src="https://img2024.cnblogs.com/blog/1565852/202508/1565852-20250806165239363-902938911.png" class="lazyload"></p>
<h3 id="核心类属性">核心类属性</h3>
<p><code>GenericAPIView</code> 通过类属性定义了视图的核心配置，这些属性决定了视图如何获取数据、如何序列化数据以及如何处理查询参数。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>queryset</code></td>
<td>视图使用的基础查询集，用于获取模型实例。通常需要设置此属性或重写 <code>get_queryset()</code> 方法。注意直接访问 <code>self.queryset</code> 会导致结果缓存，应优先使用 <code>get_queryset()</code> 方法。</td>
</tr>
<tr>
<td><code>serializer_class</code></td>
<td>用于数据验证、序列化和反序列化的序列化器类。需设置此属性或重写 <code>get_serializer_class()</code> 方法。</td>
</tr>
<tr>
<td><code>lookup_field</code></td>
<td>用于查询单个对象的模型字段，默认值为 <code>'pk'</code>（主键）。若使用自定义字段，需确保视图和序列化器同步设置。</td>
</tr>
<tr>
<td><code>lookup_url_kwarg</code></td>
<td>URL 中用于对象查找的关键字参数，默认与 <code>lookup_field</code> 相同。需与 URL 配置中的参数名保持一致。</td>
</tr>
<tr>
<td><code>pagination_class</code></td>
<td>列表数据的分页类，默认使用全局配置 <code>DEFAULT_PAGINATION_CLASS</code>。设置为 <code>None</code> 可禁用分页。</td>
</tr>
<tr>
<td><code>filter_backends</code></td>
<td>用于过滤查询集的后端类列表，默认使用全局配置 <code>DEFAULT_FILTER_BACKENDS</code>。</td>
</tr>
</tbody>
</table>
<h3 id="常用类方法">常用类方法</h3>
<p><code>GenericAPIView</code> 提供了一系列方法用于处理查询集、对象实例和序列化器，这些方法是构建数据交互逻辑的核心。</p>
<p>数据查询相关方法</p>
<ul>
<li>get_queryset(self)：返回视图使用的查询集，是获取数据的主要入口。默认返回 queryset 属性定义的查询集，可重写以实现动态过滤（如返回当前用户的数据）</li>
</ul>
<pre><code class="language-python">def get_queryset(self):
    return self.request.user.articles.all()  # 仅返回当前用户发布的文章
</code></pre>
<ul>
<li>get_object(self)：返回详细视图所需的单个对象实例。默认通过 lookup_field 从查询集中过滤对象，可重写以实现复杂查询逻辑（如多字段联合查询）。</li>
<li>filter_queryset(self, queryset)：应用过滤后端对查询集进行过滤，返回处理后的查询集。可通过重写自定义过滤逻辑</li>
</ul>
<pre><code class="language-python">def filter_queryset(self, queryset):
    # 根据请求参数动态选择过滤后端
    if 'category' in self.request.query_params:
        queryset = queryset.filter(category=self.request.query_params['category'])
    return queryset
</code></pre>
<p>序列化器相关方法</p>
<ul>
<li>get_serializer_class(self)：返回当前视图使用的序列化器类，默认返回 serializer_class 属性。可重写以根据条件返回不同的序列化器</li>
</ul>
<pre><code class="language-python">def get_serializer_class(self):
    if self.request.method == 'GET':
        return ReadOnlyArticleSerializer  # 只读场景使用简化序列化器
    return ArticleSerializer  # 写操作使用完整序列化器
</code></pre>
<ul>
<li>get_serializer(self, instance=None, data=None, many=False, partial=False)：返回序列化器实例，自动注入请求上下文（如 request、view）。通常无需重写，直接调用即可</li>
</ul>
<pre><code class="language-python">serializer = self.get_serializer(instance=article, data=request.data)
</code></pre>
<h3 id="钩子方法与-mixin-配合">钩子方法（与 Mixin 配合）</h3>
<p><code>GenericAPIView</code> 本身不直接实现 CRUD 操作，而是通过与 Mixin 类（如 <code>CreateModelMixin</code>、<code>UpdateModelMixin</code>）结合实现完整功能。这些 Mixin 提供了以下钩子方法，用于定制对象的保存和删除行为</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>所属 Mixin</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>perform_create(self, serializer)</code></td>
<td><code>CreateModelMixin</code></td>
<td>创建对象时调用，可用于添加额外字段（如设置创建者）： <code>def perform_create(self, serializer):</code>  <code>serializer.save(author=self.request.user)</code></td>
</tr>
<tr>
<td><code>perform_update(self, serializer)</code></td>
<td><code>UpdateModelMixin</code></td>
<td>更新对象时调用，可用于记录更新时间等： <code>def perform_update(self, serializer):</code>  <code>serializer.save(updated_at=timezone.now())</code></td>
</tr>
<tr>
<td><code>perform_destroy(self, instance)</code></td>
<td><code>DestroyModelMixin</code></td>
<td>删除对象时调用，可用于执行额外清理操作： <code>def perform_destroy(self, instance):</code>  <code>instance.comments.all().delete()</code>  <code>instance.delete()</code></td>
</tr>
</tbody>
</table>
<h3 id="其他实用方法">其他实用方法</h3>
<p>以下方法通常无需重写</p>
<ul>
<li><strong><code>get_serializer_context(self)</code></strong>：返回序列化器的上下文字典，默认包含 <code>request</code>、<code>view</code>、<code>format</code> 信息，可用于在序列化器中访问请求数据。</li>
<li><strong><code>paginate_queryset(self, queryset)</code></strong>：对查询集进行分页处理，返回页面对象或 <code>None</code>（若未配置分页）。</li>
<li><strong><code>get_paginated_response(self, data)</code></strong>：返回分页格式的响应对象，配合分页功能使用。</li>
</ul>
<hr>
<p>您正在阅读的是《<strong>Django从入门到实战</strong>》专栏！关注不迷路~</p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-06 16:54">2025-08-06 16:54</span>&nbsp;
<a href="https://www.cnblogs.com/xwz1024">小王子1024</a>&nbsp;
阅读(<span id="post_view_count">43</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19025414);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19025414', targetLink: 'https://www.cnblogs.com/xwz1024/p/19025414', title: 'DRF视图详解：从基础视图到通用视图实践指南' })">举报</a>
</div>
	