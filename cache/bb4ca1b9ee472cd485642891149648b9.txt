
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/CodeBlogMan/p/18300877" title="发布于 2025-03-11 09:08">
    <span role="heading" aria-level="2">【主流技术】Spring Boot Starter 的应用场景与自动配置</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/2458865/202411/2458865-20241103164113470-1673779062.png" alt="【主流技术】Spring Boot Starter 的应用场景与自动配置" class="desc_img">
        一般在企业开发中，会有专门的 git 仓库（组）来统一放置各个系统对应的 Starter 项目，其中会包括一个空的框架，拉取下来后我们就可以自己开发了。
在开发之前，我们需要知道常见的使用场景有哪些：
1、API 调用：将某系统的部分功能经过封装后通过 API 暴露出去，方便内部/外部系统调用；
2、基础组件：比如全局统一的 Http 组件、缓存组件和一些通用工具包等；
3、底层框架：主要是公司自研的系统框架。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#前言" rel="noopener nofollow">前言</a></li><li><a href="#一spring-boo-starter-简介" rel="noopener nofollow">一、Spring Boo Starter 简介</a></li><li><a href="#二如何自定义-starter" rel="noopener nofollow">二、如何自定义 Starter</a><ul><li><a href="#21命名规范" rel="noopener nofollow">2.1命名规范</a></li><li><a href="#22整体结构" rel="noopener nofollow">2.2整体结构</a></li><li><a href="#23模块开发" rel="noopener nofollow">2.3模块开发</a><ul><li><a href="#231依赖引入" rel="noopener nofollow">2.3.1依赖引入</a></li><li><a href="#232xxxautoconfiguration的实现" rel="noopener nofollow">2.3.2xxxAutoConfiguration的实现</a></li><li><a href="#233-xxxproperties的实现" rel="noopener nofollow">2.3.3 xxxProperties的实现</a></li><li><a href="#234配置springfactories文件" rel="noopener nofollow">2.3.4配置spring.factories文件</a></li></ul></li></ul></li><li><a href="#三浅析-spring-boot-自动配置原理" rel="noopener nofollow">三、浅析 Spring Boot 自动配置原理</a><ul><li><a href="#31自动配置原理" rel="noopener nofollow">3.1自动配置原理</a></li><li><a href="#32自动配置的过程" rel="noopener nofollow">3.2自动配置的过程</a></li></ul></li><li><a href="#四文章小结" rel="noopener nofollow">四、文章小结</a></li></ul></div><p></p>
<h3 id="前言">前言</h3>
<h3 id="一spring-boo-starter-简介">一、Spring Boo Starter 简介</h3>
<p>在 SpringBoot 出现之前，如果我们想使用 SpringMVC 来构建我们的 web 项目，必须要做的几件事情如下：</p>
<ul>
<li>首先项目中需要引入 SpringMVC 的依赖</li>
<li>在 web.xml 中注册 SpringMVC 的<code>DispatcherServlet</code>，并配置url映射</li>
<li>编写<code>springmcv-servlet.xml</code>，在其中配置几个重要的组件，处理映射器（HandlerMapping）、处理适配器（HandlerAdapter）、视图解析器（ViewResolver）</li>
<li>在<code>applicationcontext.xml</code>文件中引入<code>springmvc-servlet.xml</code>文件</li>
</ul>
<p>以上这几步只是配置好了 SpringMVC，如果我们还需要与数据库进行交互，就要在 application.xml 中配置数据库连接池 DataSource，如果需要数据库事务，还需要配置 TransactionManager… 等等。</p>
<p>以上会带来两个明显的问题：</p>
<ul>
<li><strong>依赖导入问题：</strong> 每个项目都需要来单独维护自己所依赖的 jar 包，手动导入依赖容易出错，且无法统一集中管理。</li>
<li><strong>配置繁琐：</strong> 在引入依赖之后需要做繁琐的配置，并且这些配置是每个项目来说都是必要的，例如 web.xml 配置（Listener 配置、Filter 配置、Servlet 配置）、log4j 配置、数据库连接池配置等。</li>
</ul>
<p>而使用 Spring Boot 的 starters（场景启动器）解决上述的两个痛点，Spring Boot 通过将我们常用的功能场景抽取出来，做成的一系列场景启动器。</p>
<p>我们只需要在项目中引入这些 starters，相关场景的所有依赖就会全部被导入进来，并且我们仅需要通过配置文件来进行少量的配置就可以使用相应的功能。</p>
<hr>
<h3 id="二如何自定义-starter">二、如何自定义 Starter</h3>
<p>一般在企业开发中，会有专门的 git 仓库（组）来统一放置各个系统对应的 Starter 项目，其中会包括一个空的框架，拉取下来后我们就可以自己开发了。</p>
<p>在开发之前，我们需要知道常见的使用场景有哪些：</p>
<ul>
<li><strong>API 调用：</strong> 将某系统的部分功能经过封装后通过 API 暴露出去，方便内部/外部系统调用，调用时需要经过认证；</li>
<li><strong>基础组件：</strong> 比如全局统一的 Http 组件、缓存组件和一些通用工具包等，目的是提升团队开发效率和形成开发规范；</li>
<li><strong>底层框架：</strong> 主要是公司自研的系统框架，如 Netty 通信、Maven 插件、ORM 框架等等，用于项目开发的基础支持。</li>
</ul>
<h4 id="21命名规范">2.1命名规范</h4>
<p>Spring Boot 官方推荐的命名规范如下：</p>
<ul>
<li>前缀：spring-boot-starter-</li>
<li>模式：spring-boot-starter-模块名</li>
<li>举例：spring-boot-starter-web、spring-boot-starter-jdbc 等</li>
</ul>
<p>我们自定义开发推荐的命名：</p>
<ul>
<li>前缀：xx-spring-boot-starter</li>
<li>模式：xx模块-spring-boot-starter</li>
<li>举例：业务线-系统名-spring-boot-starter、saas-user-spring-boot-starter等</li>
</ul>
<h4 id="22整体结构">2.2整体结构</h4>
<p>一个 starter 的整体实现逻辑主要由两个基本部分组成：</p>
<ol>
<li><code>xxxAutoConfiguration</code>：自动配置类，对某个场景下需要使用到的一些组件进行自动注入，并利用xxxProperties类来进行组件相关配置。</li>
<li><code>xxxProperties</code>：某个场景下所有可配置属性的集成，在配置文件中配置可以进行属性值的覆盖。</li>
</ol>
<p>按照 SpringBoot 官方的定义，starer 的作用就是依赖聚合，因此直接在 starter 内部去进行代码实现是不符合规定的，starter 应该只起到依赖导入的作用，而具体的代码实现应该去交给其它服务/模块来实现。</p>
<h4 id="23模块开发">2.3模块开发</h4>
<h5 id="231依赖引入">2.3.1依赖引入</h5>
<p>首先所有的自动配置模块都要引入两个 jar 包依赖：</p>
<pre><code class="language-xml">&lt;dependencies&gt;
     &lt;dependency&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
         &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; 
        &lt;!-- 包含很多与自动配置相关的注解的定义，必须要引入 --&gt;
     &lt;/dependency&gt;
     &lt;dependency&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
         &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; 
       &lt;!-- 可以通过其它 .properties 文件为相关类进行属性映射，SpringBoot 默认使用 application.yml--&gt;
         &lt;optional&gt;true&lt;/optional&gt;
     &lt;/dependency&gt;
 &lt;dependencies&gt;
</code></pre>
<h5 id="232xxxautoconfiguration的实现">2.3.2xxxAutoConfiguration的实现</h5>
<p>xxxAutoconfigure 模块中最重要的就是自动配置类的编写，它为我们实现组件的自动配置与自动注入。在编写自动配置类的时候，我们应该要考虑向容器中注入什么组件，如何去配置它。</p>
<pre><code class="language-java">@Configuration 
@EnableConfigurationProperties(xxxProperties.class)
public class xxxAutoConfiguration {
    
 @Resource
 private xxxProperties properties;
    
    @Bean
    public static BeanYouNeed beanYouNeed() {
     BeanYouNeed bean = new BeanYouNeed()
     bean.setField(properties.get(field));
     bean.setField(properties.get(field));
    }
}
</code></pre>
<h5 id="233-xxxproperties的实现">2.3.3 xxxProperties的实现</h5>
<p>这是跟配置文件相绑定的类，里边的属性就是我们可以在配置文件中配置的内容，然后通过<code>@ConfigurationProperties</code>将其与配置文件绑定：</p>
<pre><code class="language-java">//使用 @ConfigurationProperties 注解绑定配置文件
@ConfigurationProperties(prefix = "your properties") 
public class xxxProperties {
    private String url;
    private String key;
    private String secret;
}
</code></pre>
<h5 id="234配置springfactories文件">2.3.4配置spring.factories文件</h5>
<p>在 resource 目录下新建META-INF文件夹，在文件夹下新建<code>spring.factories</code>文件，并添加写好的<code>xxxAutoConfiguration</code>类：</p>
<pre><code class="language-txt">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.xx.xx.xx.autoconfigure.xxxAutoConfiguration
</code></pre>
<hr>
<h3 id="三浅析-spring-boot-自动配置原理">三、浅析 Spring Boot 自动配置原理</h3>
<p>在这一小节我将分析 Spring Boot 在创建 Stater 时主要帮我们完成的<strong>两件最关键的事情：</strong></p>
<ul>
<li>相关组件的自动导入</li>
<li>相关组件的自动配置</li>
</ul>
<p><strong>这两件事情统一称为 SpringBoot 的自动配置。</strong></p>
<h4 id="31自动配置原理">3.1自动配置原理</h4>
<p>我们从主程序入口来探索一下整个过程的原理：</p>
<pre><code class="language-java">@SpringBootApplication //标注这个类是一个 springboot 的应用
public class MyApplication {
    public static void main(String[] args) {
        //将 springboot 应用启动
        SpringApplication.run(MyApplication.class, args);
    }
}
</code></pre>
<p><code>@SpringBootApplication</code>注解内部结构如下图3-1所示：</p>
<div align="center">
<img src="https://img2024.cnblogs.com/blog/2458865/202411/2458865-20241103163454731-489801771.png" width="88%">
</div>
<center>图3-1</center>
<p>我们可以去到上边提到的<code>spring.factories</code>文件中去看一下，找到 spring 官方提供的<code>spring-boot-autoconfigure</code>包，再去找一下该文件，如图3-2所示：</p>
<div align="center">
<img src="https://img2024.cnblogs.com/blog/2458865/202411/2458865-20241103163653275-2003799325.png" width="88%">
</div>
<center>图3-2</center>
<p>可以看到这个就是SpringBoot官方为我们提供的所有自动配置类的候选列表。<br>
我们可以在其中找到一个我们比较熟悉的自动配置类去看一下它内部的实现，可以看到这些一个个的都是JavaConfig配置类，而且都通过<code>@Bean</code>注解向容器中注入了一些 Bean，如图3-3所示：</p>
<div align="center">
<img src="https://img2024.cnblogs.com/blog/2458865/202411/2458865-20241103163746679-2115800728.png" width="88%">
</div>
<center>图3-3</center>
小结：
<ul>
<li>SpringBoot 在启动的时候从类路径下的<code>META-INF/spring.factories</code>中获取 EnableAutoConfiguration 指定的所有自动配置类的全限定类名；</li>
<li>整个 J2EE 的全部解决方案和自动配置都在<code>spring-boot-autoconfigure</code>的 jar 包中，将这些自动配置类导入容器，自动配置类就生效；</li>
<li>上面2点会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件，并配置好这些组件 。</li>
</ul>
<h4 id="32自动配置的过程">3.2自动配置的过程</h4>
<p>SpringBoot 中所有可配置项都集中在一个文件中（application.yml），这个文件中的配置通过<code>@ConfigurationProperties</code>注解来与我们程序内部定义的 POJO</p>
<p>类来产生关联，这些 POJO 类统一命名为<code>xxxProperties</code>，并且这些<code>xxxProperties</code>类中各个属性字段都有自己的默认值。</p>
<p>这也是 SpringBoot 约定大于配置理念的体现，尽可能减少开发人员做选择的次数，但同时又不失灵活性。只要我们想，配置文件中的配置随时可以覆盖默认值，如图3-4所示：</p>
<div align="center">
<img src="https://img2024.cnblogs.com/blog/2458865/202411/2458865-20241103163842655-342408926.png" width="88%">
</div>
<center>图3-4</center>
<p>小结：</p>
<ul>
<li>首先容器会根据当前不同的条件判断，决定这个配置类是否生效；</li>
<li>一但这个配置类生效，这个配置类就会给容器中添加相应组件；</li>
<li>这些组件的属性是从对应的 properties 类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</li>
<li>所有在配置文件中的属性都是在 xxxxProperties 类中封装着，配置文件可以配置什么内容，可以参照该前缀对应的属性类中的属性字段。</li>
</ul>
<h3 id="四文章小结">四、文章小结</h3>
<p>到这里关于Spring Boot Starter 的应用场景与自动配置就分享完了，stater 的开发和使用并不难，最重要的掌握使用场景和自动配置，这样无论是什么类型的 stater 都可以快速掌握运用在项目里。</p>
<p>最后，如果文章有不足和错误，还请大家指正。或者你有其它想说的，也欢迎大家在评论区交流！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.30008230189930557" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-11 09:09">2025-03-11 09:08</span>&nbsp;
<a href="https://www.cnblogs.com/CodeBlogMan">CodeBlogMan</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18300877" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18300877);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18300877', targetLink: 'https://www.cnblogs.com/CodeBlogMan/p/18300877', title: '【主流技术】Spring Boot Starter 的应用场景与自动配置' })">举报</a>
</div>
        