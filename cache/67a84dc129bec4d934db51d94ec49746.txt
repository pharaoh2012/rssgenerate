
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/MelonTe/p/18734755" title="发布于 2025-02-24 20:07">
    <span role="heading" aria-level="2">使用Go复刻skiplist核心功能</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="0引言">0、引言</h1>
<p>正好做LC每日一题要求实现一个跳表，于是学习了redis的扩展<code>skiplist</code>，并使用Go进行复刻学习。学习参考了文章：<a href="http://zhangtielei.com/posts/blog-redis-skiplist.html" target="_blank" rel="noopener nofollow">Redis内部数据结构详解(6)——skiplist - 铁蕾的个人博客</a></p>
<p>因为作者能力有限，本文只是对跳表的核心功能：创建节点与跳表、插入节点、删除节点、获取节点rank、根据rank获取节点、获取分数区间的ele集合进行复刻，其余的需要自己去实现。</p>
<h1 id="1跳表核心结构">1、跳表核心结构</h1>
<p>源码的数据结构定义如下：</p>
<pre><code class="language-c">#define ZSKIPLIST_MAXLEVEL 32
#define ZSKIPLIST_P 0.25

/* ZSETs use a specialized version of Skiplists */
typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;

typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
</code></pre>
<ul>
<li>定义了两个常量，一个是跳表的最大层数<code>ZSKIPLIST_MAXLEVEL</code>，一个是当前节点含有<code>i+1</code>层的概率<code>ZSKIPLIST_P</code></li>
<li>跳表节点<code>zskiplistNode</code>：
<ul>
<li><code>ele</code>，为string类型，存放的是节点的数据</li>
<li><code>score</code>，存放数据对应的值</li>
<li><code>backward</code>指向前一个跳表节点，只存在第一层链接中</li>
<li><code>level</code>存放多层指向下一个节点的指针<code>forawrd</code>，同时含有一个<code>span</code>用于表示当前指针跨越了多少个节点，用于实现通过排名查询。注意，span是表示当前层，从header到当前节点跨过的指针数，它不包括指针的起始节点，但是包括终点节点。</li>
</ul>
</li>
<li>跳表本身<code>zskiplist</code>：
<ul>
<li><code>header</code>和<code>tail</code>，指向跳表首尾的指针</li>
<li><code>length</code>跳表总节点数</li>
<li><code>level</code>跳表当前的层数</li>
</ul>
</li>
</ul>
<p>复刻：</p>
<pre><code class="language-go">package goskiplist

const (
	SKIPLIST_MAXLEVEL = 32
	SKIPLIST_P        = 0.25
)

type GskiplistLevel struct {
	forward *GskiplistNode
	span    uint64
}
type GskiplistNode struct {
	ele      string
	score    float64
	backward *GskiplistNode
	level    []GskiplistLevel
}
type Gskiplist struct {
	header *GskiplistNode
	tail   *GskiplistNode
	length uint64
	level int
}
</code></pre>
<h1 id="2创建跳表节点与跳表">2、创建跳表节点与跳表</h1>
<p>创建跳表节点源码：</p>
<pre><code class="language-c">zskiplistNode *zslCreateNode(int level, double score, sds ele) {
    zskiplistNode *zn =
        zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));
    zn-&gt;score = score;
    zn-&gt;ele = ele;
    return zn;
}
</code></pre>
<p>复刻：</p>
<pre><code class="language-go">func createNode(level int, score float64, ele string) *GskiplistNode{
	node := &amp;GskiplistNode{
		ele:      ele,
		score:    score,
		level:    make([]GskiplistLevel, level),
		backward: nil,
	}
	return node
}

</code></pre>
<hr>
<p>创建跳表源码：</p>
<pre><code class="language-c">/* Create a new skiplist. */
zskiplist *zslCreate(void) {
    int j;
    zskiplist *zsl;

    zsl = zmalloc(sizeof(*zsl));
    zsl-&gt;level = 1;
    zsl-&gt;length = 0;
    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);
    for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) {
        zsl-&gt;header-&gt;level[j].forward = NULL;
        zsl-&gt;header-&gt;level[j].span = 0;
    }
    zsl-&gt;header-&gt;backward = NULL;
    zsl-&gt;tail = NULL;
    return zsl;
}
</code></pre>
<p>初始化设置了跳表的层数为1、节点数为0、初始化头节点指针，分配内存。注意，头节点并不计算在length中。</p>
<p>经过初始化，创建的跳表如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/3542244/202502/3542244-20250224200558177-240089610.png" alt="" loading="lazy"></p>
<h1 id="3向跳表插入节点">3、向跳表插入节点</h1>
<p>源码：</p>
<pre><code class="language-c">zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long rank[ZSKIPLIST_MAXLEVEL];
    int i, level;

    serverAssert(!isnan(score));
    x = zsl-&gt;header;
    for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
        /* store rank that is crossed to reach the insert position */
        rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];
        while (x-&gt;level[i].forward &amp;&amp;
                (x-&gt;level[i].forward-&gt;score &lt; score ||
                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))
        {
            rank[i] += x-&gt;level[i].span;
            x = x-&gt;level[i].forward;
        }
        update[i] = x;
    }
    /* we assume the element is not already inside, since we allow duplicated
     * scores, reinserting the same element should never happen since the
     * caller of zslInsert() should test in the hash table if the element is
     * already inside or not. */
    level = zslRandomLevel();
    if (level &gt; zsl-&gt;level) {
        for (i = zsl-&gt;level; i &lt; level; i++) {
            rank[i] = 0;
            update[i] = zsl-&gt;header;
            update[i]-&gt;level[i].span = zsl-&gt;length;
        }
        zsl-&gt;level = level;
    }
    x = zslCreateNode(level,score,ele);
    for (i = 0; i &lt; level; i++) {
        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;
        update[i]-&gt;level[i].forward = x;

        /* update span covered by update[i] as x is inserted here */
        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);
        update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;
    }

    /* increment span for untouched levels */
    for (i = level; i &lt; zsl-&gt;level; i++) {
        update[i]-&gt;level[i].span++;
    }

    x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];
    if (x-&gt;level[0].forward)
        x-&gt;level[0].forward-&gt;backward = x;
    else
        zsl-&gt;tail = x;
    zsl-&gt;length++;
    return x;
}
</code></pre>
<p><code>zslInsert</code>主要实现了向跳表中插入一个节点，节点的值为<code>ele</code>，分数为<code>score</code>。</p>
<p>解析：</p>
<h3 id="1创建数组与断言检查">（1）创建数组与断言检查</h3>
<pre><code class="language-c">zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
unsigned long rank[ZSKIPLIST_MAXLEVEL];
int i, level;
serverAssert(!isnan(score));
x = zsl-&gt;header;
</code></pre>
<ul>
<li><code>*update[]</code>用于记录每一层插入的位置，<code>update[i]</code>表示节点在第i层，应该插入在<code>update[i]</code>节点之后。</li>
<li><code>rank[]</code>用于记录每一层的跨度，<code>rank[i]</code>表示从第i层，跳到update[i]节点的跨度。使用了前缀和的思想。</li>
<li><code>*x</code>用于节点的遍历</li>
<li><code>serverAssert</code>用于判断数值是否异常</li>
</ul>
<h3 id="2查找插入位置">（2）查找插入位置</h3>
<pre><code class="language-c">for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
        /* store rank that is crossed to reach the insert position */
        rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];
        while (x-&gt;level[i].forward &amp;&amp;
                (x-&gt;level[i].forward-&gt;score &lt; score ||
                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))
        {
            rank[i] += x-&gt;level[i].span;
            x = x-&gt;level[i].forward;
        }
        update[i] = x;
    }
</code></pre>
<p>i从当前跳表的最高层向下遍历。在每一次遍历中：</p>
<ul>
<li>rank[i]初始赋值上一层的结果，若为最高层则赋值0</li>
<li>若当<strong>前层的当前节点存在下一节点，并且分数&lt;新节点分数（从小到大排序）或者分数相同但字典序要小</strong>，则累加下一步的跨度，并且移动结点至下一结点。</li>
<li>找到当前层应该插入的位置后，记录这个结点。</li>
</ul>
<p>加入目前跳表结构如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/3542244/202502/3542244-20250224200613254-1631379899.png" alt="" loading="lazy"></p>
<p>我们想要插入的新节点ele为“e”，score为“75”。那么经过更新后：</p>
<ul>
<li>rank[1] = 3，update[1] = c</li>
<li>rank[0] = 3，update[0] = c</li>
</ul>
<h3 id="3设定新节点最大层数">（3）设定新节点最大层数</h3>
<pre><code class="language-c">level = zslRandomLevel();
    if (level &gt; zsl-&gt;level) {
        for (i = zsl-&gt;level; i &lt; level; i++) {
            rank[i] = 0;
            update[i] = zsl-&gt;header;
            update[i]-&gt;level[i].span = zsl-&gt;length;
        }
        zsl-&gt;level = level;
    }
</code></pre>
<p>使用<code>zslRandomLevel</code>函数设定新节点的最高层数。如果这个最高层数大于目前跳表的层数，那么就需要设定新高层的rank和update。</p>
<p><code>zslRandomLevel</code>的实现如下：</p>
<pre><code class="language-c">int zslRandomLevel(void) {
    static const int threshold = ZSKIPLIST_P*RAND_MAX;
    int level = 1;
    while (random() &lt; threshold)
        level += 1;
    return (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}
</code></pre>
<p>通过将浮点数映射至整数，可以加快运算效率。</p>
<p>假设我们要插入的（“e”，75）节点生成的层数为3，经历上述操作后，跳表结构如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/3542244/202502/3542244-20250224200627372-1423872978.png" alt="" loading="lazy"></p>
<h3 id="4插入新节点和更新跨度">（4）插入新节点和更新跨度</h3>
<pre><code class="language-c">x = zslCreateNode(level,score,ele);
    for (i = 0; i &lt; level; i++) {
        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;
        update[i]-&gt;level[i].forward = x;

        /* update span covered by update[i] as x is inserted here */
        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);
        update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;
    }
/* increment span for untouched levels */
    for (i = level; i &lt; zsl-&gt;level; i++) {
        update[i]-&gt;level[i].span++;
    }
</code></pre>
<p>调整每一层的要插入的位置的前一个节点的指针指向，并且更新span。</p>
<p>假设在第i层，我们称<code>update[i]</code>为<code>pre</code>，未更新前pre的下一个节点未<code>next</code>，那么因为要在pre和next之间插入新的节点，更新pre的span为<strong>pre到next的距离-cur到next的距离</strong>。更新cur的span为cur到next的距离。</p>
<p>第二个循环是为了更新当前节点的更高层未更新节点的span值。</p>
<p>经过这一次调整，如图：</p>
<p><img src="https://img2024.cnblogs.com/blog/3542244/202502/3542244-20250224200640367-890541105.png" alt="" loading="lazy"></p>
<p>这里我画图用于形象的表示span的计算过程，它采用了前缀和的方式：<br>
<img src="https://img2024.cnblogs.com/blog/3542244/202502/3542244-20250224200648727-1948773627.png" alt="" loading="lazy"></p>
<h3 id="5更新新节点的前指针">（5）更新新节点的前指针</h3>
<pre><code class="language-c">x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];
    if (x-&gt;level[0].forward)
        x-&gt;level[0].forward-&gt;backward = x;
    else
        zsl-&gt;tail = x;
    zsl-&gt;length++;
    return x;
</code></pre>
<p>如果update[0]不是头节点，那么它就是x的前一个节点。如果x的后节点存在，则更新x的后节点的前指针指向x，否则x是末尾节点，让tail指向它。</p>
<p>复刻Go源码：</p>
<pre><code class="language-go">// 向跳表插入一个节点，同时返回插入好的节点。
// ele不能为空串，否则返回nil。
func (this *Gskiplist) Insert(score float64, ele string) *GskiplistNode {
	if ele == "" {
		return nil
	}
	update := make([]*GskiplistNode, SKIPLIST_MAXLEVEL)
	rank := make([]uint64, SKIPLIST_MAXLEVEL)
	var x *GskiplistNode

	x = this.header
	//更新update以及rank
	for i := this.level - 1; i &gt;= 0; i-- {
		rank[i] = 0
		if i != this.level-1 {
			rank[i] = rank[i+1]
		}
		for x.level[i].forward != nil &amp;&amp;
			(x.level[i].forward.score &lt; score ||
				(x.level[i].forward.score == score &amp;&amp; x.level[i].forward.ele &lt; ele)) {
			rank[i] += x.level[i].span
			x = x.level[i].forward
		}
		update[i] = x
	}
	level := this.randomLevel()
	//更新最大层数
	if level &gt; this.level {
		for i := this.level; i &lt; level; i++ {
			rank[i] = 0
			update[i] = this.header
			update[i].level[i].span = this.length
		}
		this.level = level
	}
	x = createNode(level, score, ele)

	//插入操作
	for i := 0; i &lt; level; i++ {
		x.level[i].forward = update[i].level[i].forward
		update[i].level[i].forward = x
		//更新x和前一个节点的span
		x.level[i].span = update[i].level[i].span - (rank[0] - rank[i])
		update[i].level[i].span = (rank[0] - rank[i]) + 1
	}

	//更新更高层
	for i := level; i &lt; this.level; i++ {
		update[i].level[i].span++
	}

	//更新前节点指针指向
	x.backward = nil
	if update[0] != this.header {
		x.backward = update[0]
	}
	if x.level[0].forward != nil {
		x.level[0].forward.backward = x
	} else {
		this.tail = x
	}
	this.length++
	return x
}
</code></pre>
<h1 id="4删除跳表节点">4、删除跳表节点</h1>
<pre><code class="language-c">void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
    int i;
    for (i = 0; i &lt; zsl-&gt;level; i++) {
        if (update[i]-&gt;level[i].forward == x) {
            update[i]-&gt;level[i].span += x-&gt;level[i].span - 1;
            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;
        } else {
            update[i]-&gt;level[i].span -= 1;
        }
    }
    if (x-&gt;level[0].forward) {
        x-&gt;level[0].forward-&gt;backward = x-&gt;backward;
    } else {
        zsl-&gt;tail = x-&gt;backward;
    }
    while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward == NULL)
        zsl-&gt;level--;
    zsl-&gt;length--;
}

int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;

    x = zsl-&gt;header;
    for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
        while (x-&gt;level[i].forward &amp;&amp;
                (x-&gt;level[i].forward-&gt;score &lt; score ||
                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))
        {
            x = x-&gt;level[i].forward;
        }
        update[i] = x;
    }
    /* We may have multiple elements with the same score, what we need
     * is to find the element with both the right score and object. */
    x = x-&gt;level[0].forward;
    if (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == 0) {
        zslDeleteNode(zsl, x, update);
        if (!node)
            zslFreeNode(x);
        else
            *node = x;
        return 1;
    }
    return 0; /* not found */
}
</code></pre>
<p>先来看<code>zslDelete</code>：它是删除节点的最上层，update的更新方法与插入一致。接着就是删除score和ele相同的节点，其中node参数用于提供保存删除节点的作用。在Go语言的复刻中，我们可以直接返回node和是否删除成功。</p>
<p>再看<code>zslDeleteNode</code>，它是删除节点的下游具体实现，具体细节如下：</p>
<ul>
<li>逐层删除x，如果当前层有x，则需要将前一个节点的后指针指向x的后指针，然后更新前一个节点的span；否则只用更新span</li>
<li>如果x的后节点存在，则更新后节点的backward指针，否则修改跳表的tail。</li>
<li>如果存在高层，在删除x后为空层，要修改跳表的层数。</li>
<li>减去一个length</li>
</ul>
<p>Go复刻如下：</p>
<pre><code class="language-go">//删除节点，返回这个节点以及是否成功
func (this *Gskiplist) Delete(score float64, ele string) (*GskiplistNode, bool) {
	update := make([]*GskiplistNode, SKIPLIST_MAXLEVEL)
	var x *GskiplistNode

	x = this.header
	for i := this.level - 1; i &gt;= 0; i-- {
		for x.level[i].forward != nil &amp;&amp;
			(x.level[i].forward.score &lt; score ||
				(x.level[i].forward.score == score &amp;&amp; x.level[i].forward.ele &lt; ele)) {
			x = x.level[i].forward
		}
		update[i] = x
	}

	x = x.level[0].forward
	//从底层删除
	if x != nil &amp;&amp; x.score == score &amp;&amp; x.ele == ele {
		this.deleteNode(x, update)
		return x, true
	}
	//未找到对应节点
	return nil, false
}

func (this *Gskiplist) deleteNode(x *GskiplistNode, update []*GskiplistNode) {
	for i := 0; i &lt; this.level; i++ {
		if update[i].level[i].forward == x {
			//在这一层，存在x
			update[i].level[i].span += x.level[i].span - 1
			update[i].level[i].forward = x.level[i].forward
		} else {
			//不存在则只更新span
			update[i].level[i].span--
		}
	}
	if x.level[0].forward != nil {
		x.level[0].forward.backward = x.backward
	} else {
		this.tail = x.backward
	}

	//若x独占高层，需要逐个清除
	for this.level &gt; 1 &amp;&amp; this.header.level[this.level-1].forward == nil {
		this.level--
	}
	this.length--
}
</code></pre>
<h1 id="5获取节点的rank">5、获取节点的rank</h1>
<pre><code class="language-c">unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *x;
    unsigned long rank = 0;
    int i;

    x = zsl-&gt;header;
    for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
        while (x-&gt;level[i].forward &amp;&amp;
            (x-&gt;level[i].forward-&gt;score &lt; score ||
                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
                sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt;= 0))) {
            rank += x-&gt;level[i].span;
            x = x-&gt;level[i].forward;
        }

        /* x might be equal to zsl-&gt;header, so test if obj is non-NULL */
        if (x-&gt;ele &amp;&amp; x-&gt;score == score &amp;&amp; sdscmp(x-&gt;ele,ele) == 0) {
            return rank;
        }
    }
    return 0;
}
</code></pre>
<p>从高层逐个寻找，找到即返回。</p>
<h1 id="6根据排名获取节点">6、根据排名获取节点</h1>
<pre><code class="language-c">/* Finds an element by its rank from start node. The rank argument needs to be 1-based. */
zskiplistNode *zslGetElementByRankFromNode(zskiplistNode *start_node, int start_level, unsigned long rank) {
    zskiplistNode *x;
    unsigned long traversed = 0;
    int i;

    x = start_node;
    for (i = start_level; i &gt;= 0; i--) {
        while (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)
        {
            traversed += x-&gt;level[i].span;
            x = x-&gt;level[i].forward;
        }
        if (traversed == rank) {
            return x;
        }
    }
    return NULL;
}

/* Finds an element by its rank. The rank argument needs to be 1-based. */
zskiplistNode *zslGetElementByRank(zskiplist *zsl, unsigned long rank) {
    return zslGetElementByRankFromNode(zsl-&gt;header, zsl-&gt;level - 1, rank);
}
</code></pre>
<p>Go复刻：</p>
<pre><code class="language-go">// 根据排名获取节点
func (this *Gskiplist) GetElementByRank(rank uint64) *GskiplistNode {
	return this.getElementByRankFromNode(this.header, this.level-1, rank)
}
func (this *Gskiplist) getElementByRankFromNode(startNode *GskiplistNode, startLevel int, rank uint64) *GskiplistNode {
	x := startNode
	var traversed uint64
	for i := startLevel; i &gt;= 0; i-- {
		for x.level[i].forward != nil &amp;&amp; traversed+x.level[i].span &lt;= rank {
			traversed += x.level[i].span
			x = x.level[i].forward
		}
		//遍历完一层，查看是否到达
		if traversed == rank {
			return x
		}
	}
	return nil
}
</code></pre>
<h1 id="7根据分数区间获取数据集合">7、根据分数区间获取数据集合</h1>
<p>现在，我们能很轻易的实现根据分数区间获取数据集合的功能。</p>
<pre><code class="language-go">// 根据分数区间获取数据集合，返回数据的ele集合
func (this *Gskiplist) GetElementsRangeByScore(low float64, high float64) (ans []string) {
	x := this.header
	var i int
	for i = this.level - 1; i &gt;= 0; i-- {
		for x.level[i].forward != nil &amp;&amp; x.level[i].forward.score &lt; low {
			x = x.level[i].forward
		}
	}
	x = x.level[0].forward
	for x != nil &amp;&amp; x.score &lt;= high {
		ans = append(ans, x.ele)
		x = x.level[0].forward
	}
	return ans
}
</code></pre>
<p>到这里为止，对skiplist的核心功能就复刻完成了，剩余的根据需要可以自己探索。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.17513635243171297" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-24 20:08">2025-02-24 20:07</span>&nbsp;
<a href="https://www.cnblogs.com/MelonTe">MelonTe</a>&nbsp;
阅读(<span id="post_view_count">11</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18734755" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18734755);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18734755', targetLink: 'https://www.cnblogs.com/MelonTe/p/18734755', title: '使用Go复刻skiplist核心功能' })">举报</a>
</div>
        