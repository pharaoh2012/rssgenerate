
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/InCerry/p/-/introduce-cs-pattern-match" title="发布于 2025-06-07 12:17">
    <span role="heading" aria-level="2">C# 模式匹配全解：原理、用法与易错点</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="引言">引言</h2>
<p>随着<code>C#</code>不断发展，"模式匹配"（Pattern Matching）已经成为让代码更加友好、可读和强大的核心特性。从 <code>C#</code> 7.0 初次引入，到 <code>C#</code> 11的能力扩展，模式匹配为处理类型判断、属性解构、集合匹配等提供了简洁、高效且类型安全的表达方式。它不仅能让 if/switch 等控制结构变得“声明式”，还能带来性能提升。在这篇文章里，我们将深入剖析 C 的所有模式匹配语法和用法，追踪其演变，讲清一些容易混淆和误用的地方，让大家能了解模式匹配本质。</p>
<hr>
<h2 id="1-什么是模式匹配">1. 什么是模式匹配</h2>
<p><strong>模式匹配本质上是一种表达式判定工具</strong>：用以检查一个对象是否与某种“模式”相吻合，如果吻合，还允许对其分解、绑定成员变量。这可以是类型检查、常量判断、属性结构匹配等。</p>
<p>传统C#写法：</p>
<pre><code class="language-cs">if (person != null &amp;&amp; person.Age &gt;= 18 &amp;&amp; person is Employee
    &amp;&amp; ((Employee)person).YearsAtCompany &gt; 5) {
    // 处理逻辑
}
</code></pre>
<p>模式匹配写法：</p>
<pre><code class="language-csharp">if (person is Employee { Age: &gt;= 18, YearsAtCompany: &gt; 5 }) {
    // 处理逻辑
}
</code></pre>
<p>更简洁、可读、类型安全，不需要重复显式强制转型。</p>
<hr>
<h2 id="2-c70-初代模式匹配特性">2. C#7.0 初代模式匹配特性</h2>
<h3 id="21-null-模式与常量模式">2.1 Null 模式与常量模式</h3>
<p>C#7.0 首先支持了用<code>is</code>直接与null以及常量对比：</p>
<pre><code class="language-csharp">if (obj is null) Console.WriteLine("对象为null");
if (d is Math.PI) Console.WriteLine("d 是圆周率");
if (str is "test") Console.WriteLine("str内容等于test");
</code></pre>
<p><strong>注意</strong>：常量匹配仅支持编译期常量，比如数字、字符串、bool、enum、const字段和null。不能直接用非const变量或表达式。</p>
<h4 id="这个限制为何存在">这个限制为何存在？</h4>
<ul>
<li>编译器要保证 switch 和 if 全覆盖检查，如果允许变量参与，则难推导 exhaustiveness（全覆盖）。</li>
<li>也可避免不可预期的副作用与逻辑混乱（比如变量运行期改变等）。</li>
</ul>
<h3 id="22-类型模式与变量捕获">2.2 类型模式与变量捕获</h3>
<p>类型模式允许 you not only 判断类型，还能直接捕获变量：</p>
<pre><code class="language-csharp">if (shape is Circle circle1) 
    Console.WriteLine($"圆的半径为 {circle1.Radius}");
</code></pre>
<p>甚至可以链式判断：</p>
<pre><code class="language-csharp">if (shape is Rectangle r &amp;&amp; r.Width == r.Height)
    Console.WriteLine("正方形");
</code></pre>
<p>非常适用于临时变量创建、减少强制类型转换(显式as/cast)代码杂音。</p>
<h4 id="is-vs-as"><code>is</code> vs <code>as</code>？</h4>
<ul>
<li><code>is</code> 结合新模式后可以直接<strong>安全声明变量</strong>，无需后续 null 检查。</li>
<li><code>as</code> 后还得写 <code>if (x != null)</code>。</li>
</ul>
<h3 id="23-discard-与-var-模式">2.3 Discard 与 var 模式</h3>
<ul>
<li>Discard（<code>_</code>）：匹配但忽略，用于 switch 的 default 分支或类型“只是判断，不关心值”。</li>
<li>var：总是匹配成功，并引出变量。通常用于解构场景，比如 switch/case 匹配对象成员。</li>
</ul>
<pre><code class="language-csharp">if (obj is var o)
   Console.WriteLine(o); // 不管 obj 是否为null，o 指向原始值（即使null）
</code></pre>
<h4 id="️-这里容易误用">⚠️ 这里容易误用！</h4>
<p><strong>不要用 var 跳过 null 检查</strong>。因为这样会把 null 值“吞掉”，造成 NullReferenceError 隐患。</p>
<pre><code class="language-cs">if (p is var _)  
{             // 这里仍可能是 null  
    Console.WriteLine(p.Length); // NullReferenceException  
}  
</code></pre>
<h3 id="24-switch-语句的模式匹配">2.4 switch 语句的模式匹配</h3>
<p>传统 switch 只能匹配简单的枚举或数字等，C#7.0 后支持以下写法：</p>
<pre><code class="language-csharp">switch (seq) {
    case Array a: return a.Length;
    case ICollection&lt;T&gt; c: return c.Count;
    case IEnumerable&lt;T&gt; _: return seq.Count();
    default: return 0;
}
</code></pre>
<ul>
<li>某类型满足条件即分支命中</li>
<li>Discard <code>case IEnumerable&lt;T&gt; _:</code></li>
<li>default处理剩余情况</li>
</ul>
<h4 id="switch-的-when-子句">switch 的 when 子句</h4>
<p><code>when</code> 只能用于 switch：</p>
<pre><code class="language-csharp">case Array a when a.Length &lt; 10: return a.Length;
</code></pre>
<p><strong>无法用于 if</strong>！</p>
<hr>
<h2 id="3-c80-switch表达式属性位置元组模式">3. C#8.0: Switch表达式、属性、位置、元组模式</h2>
<h3 id="31-表达式-switch">3.1 表达式 Switch</h3>
<p>C#8 引入 switch-表达式，极大提升 switch 可读性和函数式编程体验：</p>
<pre><code class="language-csharp">string whatShape = shape switch {
    Circle c     =&gt; $"circle radius: {c.Radius}",
    Rectangle _  =&gt; "rectangle",
    _            =&gt; "null or unknown"
};
</code></pre>
<ul>
<li>匹配分支是表达式，不能有多条语句</li>
</ul>
<p><code>=&gt;</code>右边直接返回值，非常适合表达式体成员：</p>
<pre><code class="language-csharp">public static string Describe(this Shape s) =&gt; s switch { ... };
</code></pre>
<h3 id="32-属性模式-property-patterns">3.2 属性模式 (Property Patterns)</h3>
<p>可直接针对属性表达式判定</p>
<pre><code class="language-csharp">if (shape is Circle { Radius: 1.0 })
    Console.WriteLine("单位圆");

whatShape = shape switch {
    Rectangle { Width: 10, Height: 5 } =&gt; "10x5 矩形",
    Rectangle { Width: var x, Height: var y } =&gt; $"rect: {x}x{y}",
    { } =&gt; "非null",
    _ =&gt; "null"
};
</code></pre>
<h4 id="重点说明">重点说明：</h4>
<ul>
<li><code>{ }</code> 代表对象非null。</li>
<li><code>{ Width: 10, Height: 5 }</code> 同时要求2个属性等于指定值。</li>
<li><code>{ Width: var x, Height: &gt;5 }</code> 可以对属性用关系操作和抽取变量。</li>
<li>若对象有<code>Deconstruct</code>方法，可用位置/元组模式更优雅。</li>
</ul>
<h3 id="33-位置模式positional-patterns">3.3 位置模式（Positional Patterns）</h3>
<p>利用 Deconstruct 抽取变量：</p>
<pre><code class="language-csharp">public void Deconstruct(out double w, out double h) =&gt; (w, h) = (Width, Height);

shape switch {
    Rectangle(var x, var y) =&gt; $"矩形尺寸:{x}x{y}",
    ...
}
</code></pre>
<ul>
<li>用于解构类对象（类似元组）</li>
<li>写法类似解构元组</li>
</ul>
<h3 id="34-元组模式">3.4 元组模式</h3>
<p>处理多个参数的模式组合：</p>
<pre><code class="language-csharp">(c1, c2, c3) switch {
    (Color.Blue, Color.White, Color.Red) =&gt; "France",
    (Color.Green, Color.White, Color.Red) =&gt; "Italy",
    _ =&gt; "Unknown"
};
</code></pre>
<ul>
<li>有效解决“复杂组合条件冗长”的老大难。</li>
<li>更直观表达多变量匹配，不需层层嵌套。</li>
</ul>
<hr>
<h2 id="4-c90-组合括号及关系模式">4. C#9.0: 组合、括号及关系模式</h2>
<h3 id="41-组合模式andornot">4.1 组合模式（and/or/not）</h3>
<p>组合条件极其强大：</p>
<pre><code class="language-csharp">c is (&gt;= 'a' and &lt;= 'z') or (&gt;= 'A' and &lt;= 'Z') or '.' or ','
</code></pre>
<p>等价于：</p>
<pre><code class="language-csharp">(c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || c == '.' || c == ','
</code></pre>
<h4 id="not-语法"><em>not</em> 语法</h4>
<pre><code class="language-csharp">if (obj is not null) { ... }
</code></pre>
<p>比传统 <code>!(obj is null)</code> 更直观。</p>
<h3 id="42-关系模式relational-patterns">4.2 关系模式（Relational Patterns）</h3>
<p>直接用 &gt;, &lt;, &gt;=, &lt;= 表达区间</p>
<pre><code class="language-csharp">rate = monthlyIncome switch {
    &gt;=0 and &lt;1000 =&gt; 0,
    &lt;5000 =&gt; 10,
    _ =&gt; 20
};
</code></pre>
<p>结合属性/类型模式：</p>
<pre><code class="language-csharp">shape switch {
    Circle { Radius: &gt;1 and &lt;=10 } =&gt; "较合理圆",
    Circle { Radius: &gt;10 } =&gt; "过大圆",
    Rectangle =&gt; "矩形",
    _ =&gt; "不匹配"
};
</code></pre>
<h3 id="43-类型模式精简">4.3 类型模式精简</h3>
<p>C#9 类型模式无需 underscore，eg：<code>Rectangle</code> 直接写。</p>
<hr>
<h2 id="5-c100-扩展属性模式">5. C#10.0: 扩展属性模式</h2>
<p>支持嵌套点表达式：</p>
<p>之前版本：</p>
<pre><code class="language-csharp">x is Person { FirstName: { Length: &lt;=5 } }
</code></pre>
<p>C#10：</p>
<pre><code class="language-csharp">x is Person { FirstName.Length: &lt;=5 }
</code></pre>
<p>让属性链判定更加直观简洁。</p>
<hr>
<h2 id="6-c110-列表与切片模式">6. C#11.0: 列表与切片模式</h2>
<h3 id="61-列表模式">6.1 列表模式</h3>
<p>让数组/集合结构模式判定成为可能：</p>
<pre><code class="language-csharp">if (arr is [1, 2, 3])
// 匹配长度为3，内容依次为1,2,3
</code></pre>
<ul>
<li><code>[..]</code>: 切片模式，等价于“0个或多个元素”</li>
<li><code>_</code>: 忽略一个元素（discard）</li>
</ul>
<pre><code class="language-csharp">[_, &gt;0, ..]      // 至少2个元素，第二个&gt;0
[.., &lt;=0, _]     // 至少2个元素，倒数第二个&lt;=0且不关心最后一个
</code></pre>
<p>注意：切片只能出现一次。</p>
<h3 id="62-列表递归">6.2 列表递归</h3>
<p>可以做嵌套匹配：</p>
<pre><code class="language-csharp">bool EndsWithSingleIntList(List&lt;List&lt;int&gt;&gt; lists) =&gt; lists is [.., [_]];
// 至少一个元素，且最后一个是单元素list
</code></pre>
<h3 id="63-支持的结构">6.3 支持的结构</h3>
<p>只要类型有 <code>Length</code>/<code>Count</code> 属性和支持 <code>[index]</code> 则可用列表模式，如 string、数组、自定义集合（只需这两个成员）。</p>
<p>例如处理国别码：</p>
<pre><code class="language-csharp">switch (s) {
    case [char c0, char c1]: // 即 s.Length==2
        ...
}
</code></pre>
<hr>
<h2 id="7-模式匹配背后的实现与性能分析">7. 模式匹配背后的实现与性能分析</h2>
<h3 id="71-不是魔法而是il优化">7.1 不是“魔法”，而是IL优化</h3>
<p>许多人以为 pattern matching 是一种基于反射或者表达式树的黑魔法。实际上，编译器常常能把很多 pattern 匹配转为高效的“顺序判断”或“跳表”等机器码。</p>
<p>例如：</p>
<pre><code class="language-csharp">c is (&gt;= 'a' and &lt;= 'z') or (&gt;= 'A' and &lt;= 'Z') or '.' or ','
</code></pre>
<p>编译后 Equals:</p>
<pre><code class="language-csharp">(c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || c == '.' || c == ','
</code></pre>
<p>对于一组常量匹配：</p>
<pre><code class="language-csharp">statusCode is 0x1000 or 0x1001 or 0x1002 or 0x2000 or 0x2001 or 0x3000
</code></pre>
<p>编译器会变换成：</p>
<pre><code class="language-csharp">return ((uint)(statusCode - 4096) &lt;= 2u || (uint)(statusCode - 8192) &lt;= 1u || statusCode == 12288);
</code></pre>
<p>即用范围短路、减少 equals 判断次数。</p>
<h4 id="️-建议">⚠️ 建议：</h4>
<p>对于性能敏感代码，请<strong>结合 Benchmark.NET 做实测对比</strong>。有时手写的判定和 pattern matching 效果类似，甚至后者更优。</p>
<hr>
<h2 id="8-常见误区与最佳实践">8. 常见误区与最佳实践</h2>
<h3 id="81-不要用-pattern-替代多态">8.1 不要用 pattern 替代多态</h3>
<p>最容易见的误用是用模式匹配处理继承结构的多态行为：</p>
<pre><code class="language-csharp">// xxx
public static double Area(this Shape shape) =&gt; shape switch {
    Circle c    =&gt; c.Radius * c.Radius * Math.PI,
    Rectangle r =&gt; r.Width * r.Height
};
</code></pre>
<p><strong>事实上，应该优先用抽象基类/接口的虚方法或属性</strong>：</p>
<pre><code class="language-csharp">abstract class Shape { public abstract double Area {get;} }

class Circle : Shape {
    public double Radius { get; set; }
    public override double Area =&gt; Radius * Radius * Math.PI;
}
</code></pre>
<p><strong>为什么？</strong></p>
<ul>
<li>可扩展性强（新子类无需修改 Area 逻辑，符合开闭原则）。</li>
<li>虚调用比类型判定快。</li>
<li>更少维护负担。</li>
</ul>
<h3 id="82-constant-only-限制">8.2 Constant-Only 限制</h3>
<p>只有<strong>编译期常量</strong>才能用于模式匹配，如果需要支持运行时变量，需采用传统判定。</p>
<h3 id="83-避免滥用-vardiscard">8.3 避免滥用 var/discard</h3>
<ul>
<li>不要用 <code>is var x</code> 跳过 null 检查。</li>
<li>discard <code>_</code> 只适合确实不关心值的场景，用后不要尝试访问。</li>
</ul>
<h3 id="84-listslice-模式性能">8.4 List/Slice 模式性能</h3>
<p>使用 <code>[..var arr, x]</code> 这种 slice+变量捕获，编译器可能分配新数组，造成性能下降。大数据集合应谨慎。</p>
<hr>
<h2 id="9-小结与展望">9. 小结与展望</h2>
<p>Pattern Matching 是现代 C# 代码的“瑞士军刀”，能极大提升 if/else、switch/case 类代码的简洁性、表达力和类型安全性，在 switch 表达式等场景下优势更加明显。它不仅代码层面更美观，也能为某些条件分支提供更优指令级性能。然而，模式匹配<strong>并非多态(polymorphism)、虚方法的替代品</strong>！业务逻辑与类型分发仍建议用面向对象原则解决。</p>
<blockquote>
<p>当前最大限制为：<strong>只能用常量做模式判定</strong>，变量（非编译期const）不支持，理由有 exhaustiveness 推导、避免副作用等。后续版本是否会提升，还需 C# 团队权衡设计复杂性。</p>
</blockquote>
<p>未来，随着 C# 特性继续演进（如 pattern 泛型化、任意表达式匹配），我们有理由期待模式匹配变得更加强大和灵活。如果你还没用过模式匹配，是时候投入生产实践试试啦！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.08606594225925926" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-07 12:17">2025-06-07 12:17</span>&nbsp;
<a href="https://www.cnblogs.com/InCerry">InCerry</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18916568);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18916568', targetLink: 'https://www.cnblogs.com/InCerry/p/-/introduce-cs-pattern-match', title: 'C# 模式匹配全解：原理、用法与易错点' })">举报</a>
</div>
        