
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18754476" title="发布于 2025-03-06 10:35">
    <span role="heading" aria-level="2">瞧瞧别人家的判空，那叫一个优雅！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一传统判空的血泪史">一、传统判空的血泪史</h2>
<p>某互联网金融平台因费用计算层级的空指针异常，导致凌晨产生9800笔错误交易。</p>
<p>DEBUG日志显示问题出现在如下代码段：</p>
<pre><code class="language-java">// 错误示例
BigDecimal amount = user.getWallet().getBalance().add(new BigDecimal("100"));
</code></pre>
<p>此类链式调用若中间环节出现null值，必定导致NPE。</p>
<p>初级阶段开发者通常写出多层嵌套式判断：</p>
<pre><code class="language-java">if(user != null){
    Wallet wallet = user.getWallet();
    if(wallet != null){
        BigDecimal balance = wallet.getBalance();
        if(balance != null){
            // 实际业务逻辑
        }
    }
}
</code></pre>
<p>这种写法既不优雅又影响代码可读性。</p>
<p>那么，我们该如何优化呢？</p>
<p><a href="http://www.susan.net.cn" target="_blank" rel="noopener nofollow">最近准备面试的小伙伴，可以看一下这个宝藏网站：www.susan.net.cn，里面：面试八股文、面试真题、工作内推什么都有</a>。</p>
<h2 id="二java-8时代的判空革命">二、Java 8+时代的判空革命</h2>
<p>Java8之后，新增了Optional类，它是用来专门判空的。</p>
<p>能够帮你写出更加优雅的代码。</p>
<h3 id="1-optional黄金三板斧">1. Optional黄金三板斧</h3>
<pre><code class="language-java">// 重构后的链式调用
BigDecimal result = Optional.ofNullable(user)
    .map(User::getWallet)
    .map(Wallet::getBalance)
    .map(balance -&gt; balance.add(new BigDecimal("100")))
    .orElse(BigDecimal.ZERO);
</code></pre>
<p><strong>高级用法：条件过滤</strong></p>
<pre><code class="language-java">Optional.ofNullable(user)
    .filter(u -&gt; u.getVipLevel() &gt; 3)
    .ifPresent(u -&gt; sendCoupon(u)); // VIP用户发券
</code></pre>
<h3 id="2-optional抛出业务异常">2. Optional抛出业务异常</h3>
<pre><code class="language-java">BigDecimal balance = Optional.ofNullable(user)
    .map(User::getWallet)
    .map(Wallet::getBalance)
    .orElseThrow(() -&gt; new BusinessException("用户钱包数据异常"));
</code></pre>
<h3 id="3-封装通用工具类">3. 封装通用工具类</h3>
<pre><code class="language-java">public class NullSafe {
    
    // 安全获取对象属性
    public static &lt;T, R&gt; R get(T target, Function&lt;T, R&gt; mapper, R defaultValue) {
        return target != null ? mapper.apply(target) : defaultValue;
    }
    
    // 链式安全操作
    public static &lt;T&gt; T execute(T root, Consumer&lt;T&gt; consumer) {
        if (root != null) {
            consumer.accept(root);
        }
        return root;
    }
}

// 使用示例
NullSafe.execute(user, u -&gt; {
    u.getWallet().charge(new BigDecimal("50"));
    logger.info("用户{}已充值", u.getId());
});
</code></pre>
<h2 id="三现代化框架的判空银弹">三、现代化框架的判空银弹</h2>
<h3 id="4-spring实战技巧">4. Spring实战技巧</h3>
<p>Spring中自带了一些好用的工具类，比如：CollectionUtils、StringUtils等，可以非常有效的进行判空。</p>
<p>具体代码如下：</p>
<pre><code class="language-java">// 集合判空工具
List&lt;Order&gt; orders = getPendingOrders();
if (CollectionUtils.isEmpty(orders)) {
    return Result.error("无待处理订单");
}

// 字符串检查
String input = request.getParam("token");
if (StringUtils.hasText(input)) {
    validateToken(input); 
}
</code></pre>
<h3 id="5-lombok保驾护航">5. Lombok保驾护航</h3>
<p>我们在日常开发中的entity对象，一般会使用Lombok框架中的注解，来实现getter/setter方法。</p>
<p>其实，这个框架中也提供了@NonNull等判空的注解。</p>
<p>比如：</p>
<pre><code class="language-java">@Getter
@Setter
public class User {
    @NonNull // 编译时生成null检查代码
    private String name;
    
    private Wallet wallet;
}

// 使用构造时自动判空
User user = new User(@NonNull "张三", wallet);
</code></pre>
<h2 id="四工程级解决方案">四、工程级解决方案</h2>
<h3 id="6-空对象模式">6. 空对象模式</h3>
<pre><code class="language-java">public interface Notification {
    void send(String message);
}

// 真实实现
public class EmailNotification implements Notification {
    @Override
    public void send(String message) {
        // 发送邮件逻辑
    }
}

// 空对象实现
public class NullNotification implements Notification {
    @Override
    public void send(String message) {
        // 默认处理
    }
}

// 使用示例
Notification notifier = getNotifier();
notifier.send("系统提醒"); // 无需判空
</code></pre>
<h3 id="7-guava的optional增强">7. Guava的Optional增强</h3>
<p>其实Guava工具包中，给我们提供了Optional增强的功能。</p>
<p>比如：</p>
<pre><code class="language-java">import com.google.common.base.Optional;

// 创建携带缺省值的Optional
Optional&lt;User&gt; userOpt = Optional.fromNullable(user).or(defaultUser);

// 链式操作配合Function
Optional&lt;BigDecimal&gt; amount = userOpt.transform(u -&gt; u.getWallet())
                                    .transform(w -&gt; w.getBalance());
</code></pre>
<p>Guava工具包中的Optional类已经封装好了，我们可以直接使用。</p>
<h2 id="五防御式编程进阶">五、防御式编程进阶</h2>
<h3 id="8-assert断言式拦截">8. Assert断言式拦截</h3>
<p>其实有些Assert断言类中，已经做好了判空的工作，参数为空则会抛出异常。</p>
<p>这样我们就可以直接调用这个断言类。</p>
<p>例如下面的ValidateUtils类中的requireNonNull方法，由于它内容已经判空了，因此，在其他地方调用requireNonNull方法时，如果为空，则会直接抛异常。</p>
<p>我们在业务代码中，直接调用requireNonNull即可，不用写额外的判空逻辑。</p>
<p>例如：</p>
<pre><code class="language-java">public class ValidateUtils {
    public static &lt;T&gt; T requireNonNull(T obj, String message) {
        if (obj == null) {
            throw new ServiceException(message);
        }
        return obj;
    }
}

// 使用姿势
User currentUser = ValidateUtils.requireNonNull(
    userDao.findById(userId), 
    "用户不存在-ID:" + userId
);
</code></pre>
<h3 id="9-全局aop拦截">9. 全局AOP拦截</h3>
<p>我们在一些特殊的业务场景种，可以通过自定义注解 + 全局AOP拦截器的方式，来实现实体或者字段的判空。</p>
<p>例如：</p>
<pre><code class="language-java">@Aspect
@Component
public class NullCheckAspect {
    
    @Around("@annotation(com.xxx.NullCheck)")
    public Object checkNull(ProceedingJoinPoint joinPoint) throws Throwable {
        Object[] args = joinPoint.getArgs();
        for (Object arg : args) {
            if (arg == null) {
                throw new IllegalArgumentException("参数不可为空");
            }
        }
        return joinPoint.proceed();
    }
}

// 注解使用
public void updateUser(@NullCheck User user) {
    // 方法实现
}
</code></pre>
<h2 id="六实战场景对比分析">六、实战场景对比分析</h2>
<h3 id="场景1深层次对象取值">场景1：深层次对象取值</h3>
<pre><code class="language-java">// 旧代码（4层嵌套判断）
if (order != null) {
    User user = order.getUser();
    if (user != null) {
        Address address = user.getAddress();
        if (address != null) {
            String city = address.getCity();
            // 使用city
        }
    }
}

// 重构后（流畅链式）
String city = Optional.ofNullable(order)
    .map(Order::getUser)
    .map(User::getAddress)
    .map(Address::getCity)
    .orElse("未知城市");
</code></pre>
<h3 id="场景2批量数据处理">场景2：批量数据处理</h3>
<pre><code class="language-java">List&lt;User&gt; users = userService.listUsers();

// 传统写法（显式迭代判断）
List&lt;String&gt; names = new ArrayList&lt;&gt;();
for (User user : users) {
    if (user != null &amp;&amp; user.getName() != null) {
        names.add(user.getName());
    }
}

// Stream优化版
List&lt;String&gt; nameList = users.stream()
    .filter(Objects::nonNull)
    .map(User::getName)
    .filter(Objects::nonNull)
    .collect(Collectors.toList());
</code></pre>
<h2 id="七性能与安全的平衡艺术">七、性能与安全的平衡艺术</h2>
<p>上面介绍的这些方案都可以使用，但除了代码的可读性之外，我们还需要考虑一下性能因素。</p>
<p>下面列出了上面的几种在CPU消耗、内存只用和代码可读性的对比：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>CPU消耗</th>
<th>内存占用</th>
<th>代码可读性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>多层if嵌套</td>
<td>低</td>
<td>低</td>
<td>★☆☆☆☆</td>
<td>简单层级调用</td>
</tr>
<tr>
<td>Java Optional</td>
<td>中</td>
<td>中</td>
<td>★★★★☆</td>
<td>中等复杂度业务流</td>
</tr>
<tr>
<td>空对象模式</td>
<td>高</td>
<td>高</td>
<td>★★★★★</td>
<td>高频调用的基础服务</td>
</tr>
<tr>
<td>AOP全局拦截</td>
<td>中</td>
<td>低</td>
<td>★★★☆☆</td>
<td>接口参数非空验证</td>
</tr>
</tbody>
</table>
<p><strong>黄金法则</strong></p>
<ul>
<li>Web层入口强制参数校验</li>
<li>Service层使用Optional链式处理</li>
<li>核心领域模型采用空对象模式</li>
</ul>
<h2 id="八扩展技术">八、扩展技术</h2>
<p>除了，上面介绍的常规判空之外，下面再给大家介绍两种扩展的技术。</p>
<h3 id="kotlin的空安全设计">Kotlin的空安全设计</h3>
<p>虽然Java开发者无法直接使用，但可借鉴其设计哲学：</p>
<pre><code class="language-plain">val city = order?.user?.address?.city ?: "default"
</code></pre>
<h3 id="jdk-14新特性预览">JDK 14新特性预览</h3>
<pre><code class="language-java">// 模式匹配语法尝鲜
if (user instanceof User u &amp;&amp; u.getName() != null) {
    System.out.println(u.getName().toUpperCase());
}
</code></pre>
<p>总之，优雅判空不仅是代码之美，更是生产安全底线。</p>
<p>本文分享了代码判空的10种方案，希望能够帮助你编写出既优雅又健壮的Java代码。</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.013496898545138889" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-06 10:35">2025-03-06 10:35</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18754476" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18754476);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18754476', targetLink: 'https://www.cnblogs.com/12lisu/p/18754476', title: '瞧瞧别人家的判空，那叫一个优雅！' })">举报</a>
</div>
        