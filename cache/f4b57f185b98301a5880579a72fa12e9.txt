
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/madtom/p/19060806" title="å‘å¸ƒäº 2025-08-27 12:41">
    <span role="heading" aria-level="2">ElasticSearchæ˜¯ä»€ä¹ˆï¼Ÿ</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="elasticsearchæ˜¯ä»€ä¹ˆ">ElasticSearchæ˜¯ä»€ä¹ˆ</h1>
<h2 id="-æ¦‚è¿°">ğŸ“– æ¦‚è¿°</h2>
<p>ElasticSearch (ES) æ˜¯ä¸€ä¸ªåŸºäºApache Luceneæ„å»ºçš„åˆ†å¸ƒå¼ã€å®æ—¶æœç´¢å’Œåˆ†æå¼•æ“ã€‚å®ƒå°†å•æœºçš„Luceneæœç´¢åº“æ‰©å±•ä¸ºåˆ†å¸ƒå¼æ¶æ„ï¼Œæä¾›äº†å¼ºå¤§çš„å…¨æ–‡æœç´¢ã€ç»“æ„åŒ–æœç´¢å’Œåˆ†æèƒ½åŠ›ã€‚ESåœ¨æ—¥å¿—åˆ†æã€åº”ç”¨æœç´¢ã€å•†å“æ¨èç­‰åœºæ™¯ä¸­è¢«å¹¿æ³›åº”ç”¨ã€‚</p>
<h2 id="-æ ¸å¿ƒå­˜å‚¨ç»“æ„è¯¦è§£">ğŸ” æ ¸å¿ƒå­˜å‚¨ç»“æ„è¯¦è§£</h2>
<h3 id="1-å€’æ’ç´¢å¼•-inverted-index">1. å€’æ’ç´¢å¼• (Inverted Index)</h3>
<p>å€’æ’ç´¢å¼•æ˜¯ElasticSearchå®ç°é«˜æ•ˆå…³é”®è¯æœç´¢çš„æ ¸å¿ƒæ•°æ®ç»“æ„ã€‚</p>
<h4 id="å·¥ä½œåŸç†">å·¥ä½œåŸç†</h4>
<div class="mermaid">graph LR
    A[åŸå§‹æ–‡æ¡£] --&gt; B[åˆ†è¯å™¨]
    B --&gt; C[è¯é¡¹Term]
    C --&gt; D[å€’æ’ç´¢å¼•]
    D --&gt; E[æ–‡æ¡£IDåˆ—è¡¨]
    
    subgraph "å€’æ’ç´¢å¼•ç»“æ„"
        F[Term Dictionary] --&gt; G[Posting List]
        G --&gt; H[Doc ID + ä½ç½®ä¿¡æ¯]
    end
</div><h4 id="æ•°æ®ç»“æ„ç¤ºä¾‹">æ•°æ®ç»“æ„ç¤ºä¾‹</h4>
<pre><code class="language-json">// åŸå§‹æ–‡æ¡£
{
  "doc1": "Elasticsearch is a search engine",
  "doc2": "Lucene is the core of Elasticsearch", 
  "doc3": "Search engines use inverted index"
}

// åˆ†è¯åçš„å€’æ’ç´¢å¼•
{
  "elasticsearch": [1, 2],      // å‡ºç°åœ¨æ–‡æ¡£1å’Œ2ä¸­
  "search": [1, 3],             // å‡ºç°åœ¨æ–‡æ¡£1å’Œ3ä¸­
  "engine": [1, 3],             // å‡ºç°åœ¨æ–‡æ¡£1å’Œ3ä¸­
  "lucene": [2],                // åªå‡ºç°åœ¨æ–‡æ¡£2ä¸­
  "core": [2],                  // åªå‡ºç°åœ¨æ–‡æ¡£2ä¸­
  "inverted": [3],              // åªå‡ºç°åœ¨æ–‡æ¡£3ä¸­
  "index": [3]                  // åªå‡ºç°åœ¨æ–‡æ¡£3ä¸­
}
</code></pre>
<h4 id="æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–">æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–</h4>
<p>é€šè¿‡å€’æ’ç´¢å¼•ï¼Œæœç´¢æ—¶é—´å¤æ‚åº¦ä»æš´åŠ›æœç´¢çš„O(N*M)ä¼˜åŒ–ä¸ºO(logN)ï¼š</p>
<pre><code class="language-java">// ä¼ ç»Ÿå…¨æ–‡æœç´¢ - O(N*M)
public List&lt;Document&gt; bruteForceSearch(String keyword, List&lt;Document&gt; docs) {
    List&lt;Document&gt; results = new ArrayList&lt;&gt;();
    for (Document doc : docs) {  // O(N)
        if (doc.content.contains(keyword)) {  // O(M)
            results.add(doc);
        }
    }
    return results;
}

// å€’æ’ç´¢å¼•æœç´¢ - O(logN)
public List&lt;Document&gt; invertedIndexSearch(String keyword, InvertedIndex index) {
    // é€šè¿‡è·³è¡¨æˆ–B+æ ‘å¿«é€Ÿå®šä½Term - O(logN)
    PostingList postingList = index.getPostingList(keyword);
    return postingList.getDocuments();
}
</code></pre>
<h4 id="è¯¦ç»†å­˜å‚¨ç»“æ„">è¯¦ç»†å­˜å‚¨ç»“æ„</h4>
<pre><code class="language-text">å€’æ’ç´¢å¼•çš„ç‰©ç†å­˜å‚¨ç»“æ„ï¼š

Term Dictionary (è¯å…¸):
â”œâ”€â”€ Term: "elasticsearch" â†’ Pointer to Posting List
â”œâ”€â”€ Term: "lucene" â†’ Pointer to Posting List  
â””â”€â”€ Term: "search" â†’ Pointer to Posting List

Posting List (å€’æ’é“¾è¡¨):
elasticsearch â†’ [DocID:1, Freq:1, Positions:[0]] â†’ [DocID:2, Freq:1, Positions:[5]]
lucene â†’ [DocID:2, Freq:1, Positions:[0]]
search â†’ [DocID:1, Freq:1, Positions:[3]] â†’ [DocID:3, Freq:1, Positions:[0]]
</code></pre>
<h3 id="2-term-index---å†…å­˜ç›®å½•æ ‘">2. Term Index - å†…å­˜ç›®å½•æ ‘</h3>
<p>Term Indexæ˜¯åŸºäºå‰ç¼€å¤ç”¨æ„å»ºçš„å†…å­˜æ•°æ®ç»“æ„ï¼Œç”¨äºåŠ é€ŸTerm Dictionaryçš„ç£ç›˜æ£€ç´¢ã€‚</p>
<h4 id="fst-finite-state-transducer-ç»“æ„">FST (Finite State Transducer) ç»“æ„</h4>
<div class="mermaid">graph TB
    Root --&gt; |e| Node1
    Node1 --&gt; |l| Node2
    Node2 --&gt; |a| Node3
    Node3 --&gt; |s| Node4
    Node4 --&gt; |t| Node5
    Node5 --&gt; |i| Node6
    Node6 --&gt; |c| Node7
    Node7 --&gt; |s| Node8[Final: elasticsearch]
    
    Node2 --&gt; |u| Node9
    Node9 --&gt; |c| Node10
    Node10 --&gt; |e| Node11
    Node11 --&gt; |n| Node12
    Node12 --&gt; |e| Node13[Final: lucene]
</div><h4 id="å‰ç¼€å¤ç”¨ä¼˜åŠ¿">å‰ç¼€å¤ç”¨ä¼˜åŠ¿</h4>
<pre><code class="language-java">// ä¼ ç»ŸTrieæ ‘ - æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨å®Œæ•´å­—ç¬¦
class TrieNode {
    char character;
    Map&lt;Character, TrieNode&gt; children;
    boolean isEndOfWord;
    // å†…å­˜ä½¿ç”¨ï¼šæ¯ä¸ªå­—ç¬¦ä¸€ä¸ªèŠ‚ç‚¹
}

// FST - å‰ç¼€å¤ç”¨ï¼Œå‹ç¼©å­˜å‚¨
class FSTNode {
    String sharedPrefix;  // å…±äº«å‰ç¼€
    Map&lt;String, FSTNode&gt; transitions;
    Object output;  // æŒ‡å‘Term Dictionaryçš„åç§»é‡
    // å†…å­˜ä½¿ç”¨ï¼šå¤§å¹…å‡å°‘ï¼Œç‰¹åˆ«æ˜¯æœ‰å…¬å…±å‰ç¼€çš„æƒ…å†µ
}
</code></pre>
<h4 id="æ£€ç´¢æµç¨‹">æ£€ç´¢æµç¨‹</h4>
<pre><code class="language-text">æŸ¥æ‰¾Term "elasticsearch"çš„æµç¨‹ï¼š

1. å†…å­˜ä¸­çš„Term Index (FST)ï¼š
   Root â†’ e â†’ el â†’ ela â†’ elas â†’ elast â†’ elasti â†’ elastic â†’ elastics â†’ elasticsearch
   æ‰¾åˆ°å¯¹åº”çš„ç£ç›˜åç§»é‡ï¼šoffset_123

2. æ ¹æ®åç§»é‡è®¿é—®ç£ç›˜ä¸Šçš„Term Dictionaryï¼š
   seek(offset_123) â†’ è¯»å–"elasticsearch"çš„Posting ListæŒ‡é’ˆ

3. åŠ è½½Posting Listï¼š
   è·å–åŒ…å«"elasticsearch"çš„æ‰€æœ‰æ–‡æ¡£IDå’Œä½ç½®ä¿¡æ¯
</code></pre>
<h3 id="3-stored-fields---è¡Œå¼å­˜å‚¨">3. Stored Fields - è¡Œå¼å­˜å‚¨</h3>
<p>Stored Fieldsä»¥è¡Œå¼ç»“æ„å­˜å‚¨å®Œæ•´çš„æ–‡æ¡£å†…å®¹ï¼Œç”¨äºè¿”å›æœç´¢ç»“æœä¸­çš„åŸå§‹æ•°æ®ã€‚</p>
<h4 id="å­˜å‚¨ç»“æ„">å­˜å‚¨ç»“æ„</h4>
<pre><code class="language-text">Document Storage Layout (è¡Œå¼å­˜å‚¨):

Doc 1: [field1: "value1", field2: "value2", field3: "value3"]
Doc 2: [field1: "value4", field2: "value5", field3: "value6"]  
Doc 3: [field1: "value7", field2: "value8", field3: "value9"]

æ¯è¡Œè¿ç»­å­˜å‚¨ï¼Œä¾¿äºæ ¹æ®DocIDå¿«é€Ÿè·å–å®Œæ•´æ–‡æ¡£
</code></pre>
<h4 id="è®¿é—®æ¨¡å¼">è®¿é—®æ¨¡å¼</h4>
<pre><code class="language-java">// æ ¹æ®DocIDè·å–å®Œæ•´æ–‡æ¡£
public Document getStoredDocument(int docId) {
    // 1. æ ¹æ®docIdè®¡ç®—åœ¨æ–‡ä»¶ä¸­çš„åç§»é‡
    long offset = docId * averageDocSize + indexOffset;
    
    // 2. ä»ç£ç›˜è¯»å–å®Œæ•´æ–‡æ¡£æ•°æ®
    byte[] docData = readFromFile(offset, docLength);
    
    // 3. ååºåˆ—åŒ–ä¸ºDocumentå¯¹è±¡
    return deserialize(docData);
}
</code></pre>
<h4 id="å‹ç¼©ä¼˜åŒ–">å‹ç¼©ä¼˜åŒ–</h4>
<pre><code class="language-text">Stored Fieldsçš„å‹ç¼©ç­–ç•¥ï¼š

1. æ–‡æ¡£çº§å‹ç¼©ï¼š
   - ä½¿ç”¨LZ4/DEFLATEå‹ç¼©ç®—æ³•
   - æ‰¹é‡å‹ç¼©16KBå—ï¼Œå¹³è¡¡å‹ç¼©æ¯”å’Œè§£å‹é€Ÿåº¦

2. å­—æ®µçº§ä¼˜åŒ–ï¼š
   - æ•°å€¼å­—æ®µä½¿ç”¨å˜é•¿ç¼–ç 
   - å­—ç¬¦ä¸²å­—æ®µä½¿ç”¨å­—å…¸å‹ç¼©
   - æ—¥æœŸå­—æ®µä½¿ç”¨å·®å€¼ç¼–ç 
</code></pre>
<h3 id="4-doc-values---åˆ—å¼å­˜å‚¨">4. Doc Values - åˆ—å¼å­˜å‚¨</h3>
<p>Doc Valuesé‡‡ç”¨åˆ—å¼å­˜å‚¨ç»“æ„ï¼Œé›†ä¸­å­˜æ”¾å­—æ®µå€¼ï¼Œä¸“é—¨ä¼˜åŒ–æ’åºå’Œèšåˆæ“ä½œçš„æ€§èƒ½ã€‚</p>
<h4 id="å­˜å‚¨å¯¹æ¯”">å­˜å‚¨å¯¹æ¯”</h4>
<pre><code class="language-text">è¡Œå¼å­˜å‚¨ (Stored Fields):
Doc1: [name:"Alice", age:25, city:"NYC"]
Doc2: [name:"Bob", age:30, city:"LA"] 
Doc3: [name:"Carol", age:28, city:"NYC"]

åˆ—å¼å­˜å‚¨ (Doc Values):
nameåˆ—: ["Alice", "Bob", "Carol"]
ageåˆ—:  [25, 30, 28]
cityåˆ—: ["NYC", "LA", "NYC"]
</code></pre>
<h4 id="æ•°æ®ç±»å‹ä¼˜åŒ–">æ•°æ®ç±»å‹ä¼˜åŒ–</h4>
<pre><code class="language-java">// æ•°å€¼ç±»å‹çš„Doc Valuesä¼˜åŒ–
class NumericDocValues {
    // ä½¿ç”¨ä½æ‰“åŒ…æŠ€æœ¯ï¼Œæ ¹æ®æ•°å€¼èŒƒå›´é€‰æ‹©æœ€å°å­˜å‚¨ä½æ•°
    private PackedInts.Reader values;
    
    public long get(int docId) {
        return values.get(docId);  // O(1)è®¿é—®
    }
}

// å­—ç¬¦ä¸²ç±»å‹çš„Doc Valuesä¼˜åŒ–  
class SortedDocValues {
    private PackedInts.Reader ordinals;  // æ–‡æ¡£åˆ°åºå·çš„æ˜ å°„
    private BytesRef[] terms;            // å»é‡åçš„å­—ç¬¦ä¸²æ•°ç»„
    
    public BytesRef get(int docId) {
        int ord = (int) ordinals.get(docId);
        return terms[ord];
    }
}
</code></pre>
<h4 id="èšåˆæ€§èƒ½ä¼˜åŒ–">èšåˆæ€§èƒ½ä¼˜åŒ–</h4>
<pre><code class="language-java">// åŸºäºDoc Valuesçš„é«˜æ•ˆèšåˆ
public class AggregationOptimization {
    
    // æ•°å€¼èšåˆ - åˆ©ç”¨åˆ—å¼å­˜å‚¨çš„é¡ºåºè®¿é—®ä¼˜åŠ¿
    public double calculateAverage(NumericDocValues ageValues, int[] docIds) {
        long sum = 0;
        for (int docId : docIds) {
            sum += ageValues.get(docId);  // é¡ºåºè®¿é—®ï¼Œç¼“å­˜å‹å¥½
        }
        return (double) sum / docIds.length;
    }
    
    // åˆ†ç»„èšåˆ - åˆ©ç”¨æ’åºçš„Doc Values
    public Map&lt;String, List&lt;Integer&gt;&gt; groupByCity(SortedDocValues cityValues, 
                                                   int[] docIds) {
        Map&lt;String, List&lt;Integer&gt;&gt; groups = new HashMap&lt;&gt;();
        for (int docId : docIds) {
            String city = cityValues.get(docId).utf8ToString();
            groups.computeIfAbsent(city, k -&gt; new ArrayList&lt;&gt;()).add(docId);
        }
        return groups;
    }
}
</code></pre>
<h2 id="ï¸-luceneæ ¸å¿ƒæ¦‚å¿µ">ğŸ—‚ï¸ Luceneæ ¸å¿ƒæ¦‚å¿µ</h2>
<h3 id="1-segment---æœ€å°æœç´¢å•å…ƒ">1. Segment - æœ€å°æœç´¢å•å…ƒ</h3>
<p>Segmentæ˜¯Luceneçš„æœ€å°æœç´¢å•å…ƒï¼ŒåŒ…å«å®Œæ•´çš„æœç´¢æ•°æ®ç»“æ„ã€‚</p>
<h4 id="segmentç»“æ„">Segmentç»“æ„</h4>
<pre><code class="language-text">Segmentæ–‡ä»¶ç»„æˆï¼š
â”œâ”€â”€ .tim (Term Index)           - å†…å­˜ä¸­çš„FSTç´¢å¼•
â”œâ”€â”€ .tip (Term Dictionary)      - ç£ç›˜ä¸Šçš„è¯å…¸
â”œâ”€â”€ .doc (Frequency)            - è¯é¢‘ä¿¡æ¯
â”œâ”€â”€ .pos (Positions)            - è¯ä½ç½®ä¿¡æ¯
â”œâ”€â”€ .pay (Payloads)            - è‡ªå®šä¹‰è½½è·æ•°æ®
â”œâ”€â”€ .fdt (Stored Fields Data)   - å­˜å‚¨å­—æ®µæ•°æ®
â”œâ”€â”€ .fdx (Stored Fields Index)  - å­˜å‚¨å­—æ®µç´¢å¼•
â”œâ”€â”€ .dvd (Doc Values Data)      - åˆ—å¼æ•°æ®
â”œâ”€â”€ .dvm (Doc Values Metadata)  - åˆ—å¼å…ƒæ•°æ®
â””â”€â”€ .si  (Segment Info)         - æ®µä¿¡æ¯
</code></pre>
<h4 id="ä¸å¯å˜æ€§ç‰¹å¾">ä¸å¯å˜æ€§ç‰¹å¾</h4>
<pre><code class="language-java">public class ImmutableSegment {
    private final String segmentName;
    private final int maxDoc;
    private final Map&lt;String, InvertedIndex&gt; fieldIndexes;
    
    // Segmentä¸€æ—¦ç”Ÿæˆå°±ä¸å¯ä¿®æ”¹
    public ImmutableSegment(String name, Document[] docs) {
        this.segmentName = name;
        this.maxDoc = docs.length;
        this.fieldIndexes = buildIndexes(docs);  // æ„å»ºæ—¶ç¡®å®šï¼Œä¹‹ååªè¯»
    }
    
    // æ›´æ–°æ“ä½œéœ€è¦åˆ›å»ºæ–°çš„Segment
    public ImmutableSegment addDocuments(Document[] newDocs) {
        Document[] allDocs = ArrayUtils.addAll(this.getDocs(), newDocs);
        return new ImmutableSegment(generateNewName(), allDocs);
    }
}
</code></pre>
<h4 id="æœç´¢è¿‡ç¨‹">æœç´¢è¿‡ç¨‹</h4>
<pre><code class="language-java">public class SegmentSearcher {
    
    public SearchResult search(Query query, Segment segment) {
        // 1. æŸ¥è¯¢Term Indexï¼Œå®šä½Term Dictionaryåç§»
        List&lt;String&gt; terms = query.extractTerms();
        Map&lt;String, PostingList&gt; termPostings = new HashMap&lt;&gt;();
        
        for (String term : terms) {
            // å¿«é€Ÿå®šä½ - O(logN)
            long offset = segment.getTermIndex().getOffset(term);
            PostingList posting = segment.getTermDict().getPosting(offset);
            termPostings.put(term, posting);
        }
        
        // 2. åˆå¹¶Posting Listsï¼Œè®¡ç®—ç›¸å…³æ€§
        Set&lt;Integer&gt; candidateDocs = intersectPostings(termPostings);
        
        // 3. ä»Stored Fieldsè·å–æ–‡æ¡£å†…å®¹
        List&lt;Document&gt; results = new ArrayList&lt;&gt;();
        for (Integer docId : candidateDocs) {
            Document doc = segment.getStoredFields().getDocument(docId);
            results.add(doc);
        }
        
        return new SearchResult(results);
    }
}
</code></pre>
<h3 id="2-æ®µåˆå¹¶-segment-merging">2. æ®µåˆå¹¶ (Segment Merging)</h3>
<p>æ®µåˆå¹¶æ˜¯Luceneä¼˜åŒ–æ€§èƒ½çš„é‡è¦æœºåˆ¶ï¼Œå®šæœŸåˆå¹¶å°Segmentä¸ºå¤§Segmentã€‚</p>
<h4 id="åˆå¹¶ç­–ç•¥">åˆå¹¶ç­–ç•¥</h4>
<pre><code class="language-java">public class TieredMergePolicy {
    private static final double DEFAULT_SEGS_PER_TIER = 10.0;
    private static final int DEFAULT_MAX_MERGE_AT_ONCE = 10;
    
    public MergeSpecification findMerges(List&lt;SegmentInfo&gt; segments) {
        // 1. æŒ‰Segmentå¤§å°åˆ†ç»„
        List&lt;List&lt;SegmentInfo&gt;&gt; tiers = groupBySize(segments);
        
        // 2. è¯†åˆ«éœ€è¦åˆå¹¶çš„å±‚çº§
        MergeSpecification mergeSpec = new MergeSpecification();
        for (List&lt;SegmentInfo&gt; tier : tiers) {
            if (tier.size() &gt; DEFAULT_SEGS_PER_TIER) {
                // é€‰æ‹©æœ€å°çš„Nä¸ªSegmentè¿›è¡Œåˆå¹¶
                List&lt;SegmentInfo&gt; toMerge = selectSmallestSegments(tier, 
                    DEFAULT_MAX_MERGE_AT_ONCE);
                mergeSpec.add(new OneMerge(toMerge));
            }
        }
        
        return mergeSpec;
    }
    
    // åˆå¹¶æ‰§è¡Œ
    public SegmentInfo executeMerge(List&lt;SegmentInfo&gt; segments) {
        SegmentWriter writer = new SegmentWriter();
        
        // é€ä¸ªå¤„ç†æ¯ä¸ªå­—æ®µçš„æ•°æ®
        for (String fieldName : getAllFields(segments)) {
            // åˆå¹¶å€’æ’ç´¢å¼•
            mergeInvertedIndex(writer, segments, fieldName);
            // åˆå¹¶Stored Fields
            mergeStoredFields(writer, segments, fieldName);
            // åˆå¹¶Doc Values
            mergeDocValues(writer, segments, fieldName);
        }
        
        return writer.commit();
    }
}
</code></pre>
<h4 id="åˆå¹¶æ”¶ç›Š">åˆå¹¶æ”¶ç›Š</h4>
<pre><code class="language-text">åˆå¹¶å‰ï¼š
Segment1 (1000 docs, 10MB)
Segment2 (1200 docs, 12MB)  
Segment3 (800 docs, 8MB)
Segment4 (1500 docs, 15MB)
æ€»è®¡: 4ä¸ªæ–‡ä»¶ï¼Œ45MBï¼Œ4æ¬¡ç£ç›˜seek

åˆå¹¶åï¼š
Segment_merged (4500 docs, 42MB)  // å‹ç¼©åç•¥å°
æ€»è®¡: 1ä¸ªæ–‡ä»¶ï¼Œ42MBï¼Œ1æ¬¡ç£ç›˜seek

æŸ¥è¯¢æ€§èƒ½æå‡ï¼š
- å‡å°‘æ–‡ä»¶æ‰“å¼€æ•°é‡ï¼š4 â†’ 1
- å‡å°‘ç£ç›˜seekæ¬¡æ•°ï¼š4 â†’ 1  
- æé«˜ç¼“å­˜å‘½ä¸­ç‡ï¼šè¿ç»­å­˜å‚¨
- å‡å°‘å†…å­˜å¼€é”€ï¼šåˆå¹¶ç´¢å¼•ç»“æ„
</code></pre>
<h2 id="-ä»luceneåˆ°elasticsearchçš„æ¼”è¿›">ğŸŒ ä»Luceneåˆ°ElasticSearchçš„æ¼”è¿›</h2>
<h3 id="1-åˆ†å¸ƒå¼æ¶æ„è®¾è®¡">1. åˆ†å¸ƒå¼æ¶æ„è®¾è®¡</h3>
<p>ElasticSearchå°†å•æœºçš„Luceneæ‰©å±•ä¸ºåˆ†å¸ƒå¼æœç´¢å¼•æ“ã€‚</p>
<h4 id="æ¶æ„å¯¹æ¯”">æ¶æ„å¯¹æ¯”</h4>
<div class="mermaid">graph TB
    subgraph "å•æœºLucene"
        A[Application] --&gt; B[Lucene Library]
        B --&gt; C[Local Index Files]
    end
    
    subgraph "åˆ†å¸ƒå¼ElasticSearch"
        D[Client] --&gt; E[Coordinate Node]
        E --&gt; F[Data Node 1]
        E --&gt; G[Data Node 2]
        E --&gt; H[Data Node 3]
        
        F --&gt; I[Shard 1]
        F --&gt; J[Shard 2]
        G --&gt; K[Shard 3] 
        G --&gt; L[Replica 1]
        H --&gt; M[Replica 2]
        H --&gt; N[Replica 3]
    end
</div><h4 id="æ ¸å¿ƒæ”¹è¿›">æ ¸å¿ƒæ”¹è¿›</h4>
<pre><code class="language-java">// Luceneå•æœºæœç´¢
public class LuceneSearcher {
    private IndexSearcher searcher;
    
    public TopDocs search(Query query, int numHits) {
        return searcher.search(query, numHits);  // å•æœºå¤„ç†
    }
}

// ElasticSearchåˆ†å¸ƒå¼æœç´¢
public class DistributedSearcher {
    private List&lt;ShardSearcher&gt; shards;
    
    public SearchResponse search(SearchRequest request) {
        // 1. åˆ†å‘æŸ¥è¯¢åˆ°æ‰€æœ‰åˆ†ç‰‡
        List&lt;Future&lt;ShardSearchResult&gt;&gt; futures = new ArrayList&lt;&gt;();
        for (ShardSearcher shard : shards) {
            Future&lt;ShardSearchResult&gt; future = executor.submit(() -&gt; 
                shard.search(request));
            futures.add(future);
        }
        
        // 2. æ”¶é›†å„åˆ†ç‰‡ç»“æœ
        List&lt;ShardSearchResult&gt; shardResults = new ArrayList&lt;&gt;();
        for (Future&lt;ShardSearchResult&gt; future : futures) {
            shardResults.add(future.get());
        }
        
        // 3. åˆå¹¶æ’åºï¼Œè¿”å›Top-Kç»“æœ
        return mergeAndSort(shardResults, request.getSize());
    }
}
</code></pre>
<h3 id="2-åˆ†ç‰‡ä¸å‰¯æœ¬æœºåˆ¶">2. åˆ†ç‰‡ä¸å‰¯æœ¬æœºåˆ¶</h3>
<h4 id="primary-shard-vs-replica-shard">Primary Shard vs Replica Shard</h4>
<pre><code class="language-text">åˆ†ç‰‡ç­–ç•¥ï¼š

Primary Shard (ä¸»åˆ†ç‰‡)ï¼š
- è´Ÿè´£å†™æ“ä½œçš„å¤„ç†
- æ•°æ®çš„æƒå¨æ¥æº
- åˆ›å»ºç´¢å¼•æ—¶ç¡®å®šæ•°é‡ï¼Œåç»­ä¸å¯æ›´æ”¹

Replica Shard (å‰¯æœ¬åˆ†ç‰‡)ï¼š
- Primary Shardçš„å®Œæ•´å‰¯æœ¬
- è´Ÿè´£è¯»æ“ä½œçš„è´Ÿè½½å‡è¡¡
- æä¾›é«˜å¯ç”¨ä¿éšœ
- æ•°é‡å¯ä»¥åŠ¨æ€è°ƒæ•´
</code></pre>
<h4 id="æ•°æ®åˆ†å¸ƒç¤ºä¾‹">æ•°æ®åˆ†å¸ƒç¤ºä¾‹</h4>
<pre><code class="language-java">public class ShardAllocation {
    
    // æ–‡æ¡£è·¯ç”±ç®—æ³•
    public int getShardId(String documentId, int numberOfShards) {
        // ä½¿ç”¨æ–‡æ¡£IDçš„å“ˆå¸Œå€¼ç¡®å®šåˆ†ç‰‡
        return Math.abs(documentId.hashCode()) % numberOfShards;
    }
    
    // åˆ†ç‰‡åˆ†å¸ƒç­–ç•¥
    public void allocateShards(Index index, List&lt;Node&gt; nodes) {
        int primaryShards = index.getNumberOfShards();
        int replicaCount = index.getNumberOfReplicas();
        
        // åˆ†é…Primary Shards
        for (int shardId = 0; shardId &lt; primaryShards; shardId++) {
            Node primaryNode = selectNodeForPrimary(nodes, shardId);
            primaryNode.allocatePrimaryShard(index, shardId);
            
            // åˆ†é…Replica Shards
            for (int replica = 0; replica &lt; replicaCount; replica++) {
                Node replicaNode = selectNodeForReplica(nodes, primaryNode, shardId);
                replicaNode.allocateReplicaShard(index, shardId, replica);
            }
        }
    }
}
</code></pre>
<h4 id="è¯»å†™è´Ÿè½½å‡è¡¡">è¯»å†™è´Ÿè½½å‡è¡¡</h4>
<pre><code class="language-java">public class LoadBalancedOperations {
    
    // å†™æ“ä½œï¼šå¿…é¡»è·¯ç”±åˆ°Primary Shard
    public IndexResponse index(IndexRequest request) {
        String docId = request.getId();
        int shardId = getShardId(docId, numberOfShards);
        
        // æ‰¾åˆ°Primary Shard
        Shard primaryShard = findPrimaryShard(shardId);
        
        // åœ¨Primaryä¸Šæ‰§è¡Œå†™æ“ä½œ
        IndexResponse response = primaryShard.index(request);
        
        // åŒæ­¥åˆ°æ‰€æœ‰Replica Shards
        List&lt;Shard&gt; replicas = findReplicaShards(shardId);
        for (Shard replica : replicas) {
            replica.index(request);  // å¼‚æ­¥å¤åˆ¶
        }
        
        return response;
    }
    
    // è¯»æ“ä½œï¼šå¯ä»¥è·¯ç”±åˆ°Primaryæˆ–Replica
    public GetResponse get(GetRequest request) {
        String docId = request.getId();
        int shardId = getShardId(docId, numberOfShards);
        
        // è´Ÿè½½å‡è¡¡é€‰æ‹©åˆ†ç‰‡ï¼ˆPrimary + Replicasï¼‰
        List&lt;Shard&gt; availableShards = findAvailableShards(shardId);
        Shard selectedShard = selectShardForRead(availableShards);
        
        return selectedShard.get(request);
    }
}
</code></pre>
<h3 id="3-èŠ‚ç‚¹è§’è‰²åˆ†å·¥">3. èŠ‚ç‚¹è§’è‰²åˆ†å·¥</h3>
<p>ElasticSearché€šè¿‡èŠ‚ç‚¹è§’è‰²åˆ†åŒ–å®ç°åŠŸèƒ½è§£è€¦å’Œæ€§èƒ½ä¼˜åŒ–ã€‚</p>
<h4 id="èŠ‚ç‚¹ç±»å‹è¯¦è§£">èŠ‚ç‚¹ç±»å‹è¯¦è§£</h4>
<pre><code class="language-java">// Master Node - é›†ç¾¤ç®¡ç†
public class MasterNode extends Node {
    private ClusterState clusterState;
    private AllocationService allocationService;
    
    public void handleClusterStateChange() {
        // 1. å¤„ç†ç´¢å¼•åˆ›å»º/åˆ é™¤
        processIndexOperations();
        
        // 2. ç®¡ç†åˆ†ç‰‡åˆ†é…
        rebalanceShards();
        
        // 3. å¤„ç†èŠ‚ç‚¹åŠ å…¥/ç¦»å¼€
        updateNodeMembership();
        
        // 4. å¹¿æ’­é›†ç¾¤çŠ¶æ€åˆ°æ‰€æœ‰èŠ‚ç‚¹
        broadcastClusterState();
    }
    
    @Override
    public boolean canHandleSearchRequests() {
        return false;  // ä¸“æ³¨äºé›†ç¾¤ç®¡ç†ï¼Œä¸å¤„ç†æœç´¢è¯·æ±‚
    }
}

// Data Node - æ•°æ®å­˜å‚¨
public class DataNode extends Node {
    private Map&lt;ShardId, Shard&gt; localShards;
    private LuceneService luceneService;
    
    public SearchResponse executeSearch(SearchRequest request) {
        List&lt;ShardSearchResult&gt; results = new ArrayList&lt;&gt;();
        
        for (ShardId shardId : request.getShardIds()) {
            if (localShards.containsKey(shardId)) {
                Shard shard = localShards.get(shardId);
                ShardSearchResult result = shard.search(request);
                results.add(result);
            }
        }
        
        return aggregateResults(results);
    }
    
    @Override
    public boolean canStorePrimaryShards() {
        return true;  // å¯ä»¥å­˜å‚¨ä¸»åˆ†ç‰‡
    }
}

// Coordinate Node - è¯·æ±‚åè°ƒ
public class CoordinateNode extends Node {
    private LoadBalancer loadBalancer;
    private ResultAggregator aggregator;
    
    public SearchResponse coordinateSearch(SearchRequest request) {
        // 1. æŸ¥è¯¢è·¯ç”±è§„åˆ’
        Map&lt;Node, List&lt;ShardId&gt;&gt; shardRouting = planShardRouting(request);
        
        // 2. å¹¶å‘å‘é€åˆ°å„ä¸ªData Node
        Map&lt;Node, Future&lt;SearchResponse&gt;&gt; futures = new HashMap&lt;&gt;();
        for (Map.Entry&lt;Node, List&lt;ShardId&gt;&gt; entry : shardRouting.entrySet()) {
            Node dataNode = entry.getKey();
            SearchRequest shardRequest = buildShardRequest(request, entry.getValue());
            Future&lt;SearchResponse&gt; future = sendSearchRequest(dataNode, shardRequest);
            futures.put(dataNode, future);
        }
        
        // 3. æ”¶é›†å¹¶èšåˆç»“æœ
        List&lt;SearchResponse&gt; responses = collectResponses(futures);
        return aggregator.aggregate(responses, request);
    }
    
    @Override
    public boolean canStoreData() {
        return false;  // ä¸å­˜å‚¨æ•°æ®ï¼Œä¸“æ³¨äºåè°ƒ
    }
}
</code></pre>
<h4 id="è§’è‰²ç»„åˆé…ç½®">è§’è‰²ç»„åˆé…ç½®</h4>
<pre><code class="language-yaml"># elasticsearch.yml é…ç½®ç¤ºä¾‹

# ä¸“ç”¨MasterèŠ‚ç‚¹
node.master: true
node.data: false
node.ingest: false
node.ml: false

# ä¸“ç”¨DataèŠ‚ç‚¹  
node.master: false
node.data: true
node.ingest: false
node.ml: false

# ä¸“ç”¨CoordinateèŠ‚ç‚¹
node.master: false
node.data: false
node.ingest: true
node.ml: false

# æ··åˆèŠ‚ç‚¹ï¼ˆå°é›†ç¾¤ï¼‰
node.master: true
node.data: true
node.ingest: true
node.ml: false
</code></pre>
<h3 id="4-å»ä¸­å¿ƒåŒ–è®¾è®¡">4. å»ä¸­å¿ƒåŒ–è®¾è®¡</h3>
<p>ElasticSearché‡‡ç”¨å»ä¸­å¿ƒåŒ–æ¶æ„ï¼Œé¿å…ä¾èµ–å¤–éƒ¨ç»„ä»¶ã€‚</p>
<h4 id="raftåè®®å®ç°">Raftåè®®å®ç°</h4>
<pre><code class="language-java">public class RaftConsensus {
    private NodeRole currentRole = NodeRole.FOLLOWER;
    private int currentTerm = 0;
    private String votedFor = null;
    private List&lt;LogEntry&gt; log = new ArrayList&lt;&gt;();
    
    // Leaderé€‰ä¸¾
    public void startElection() {
        currentTerm++;
        currentRole = NodeRole.CANDIDATE;
        votedFor = this.nodeId;
        
        // å‘æ‰€æœ‰èŠ‚ç‚¹è¯·æ±‚æŠ•ç¥¨
        int votes = 1;  // è‡ªå·±çš„ç¥¨
        for (Node node : clusterNodes) {
            VoteRequest request = new VoteRequest(currentTerm, nodeId, 
                getLastLogIndex(), getLastLogTerm());
            VoteResponse response = node.requestVote(request);
            
            if (response.isVoteGranted()) {
                votes++;
            }
        }
        
        // è·å¾—å¤šæ•°ç¥¨ï¼Œæˆä¸ºLeader
        if (votes &gt; clusterNodes.size() / 2) {
            becomeLeader();
        } else {
            becomeFollower();
        }
    }
    
    // æ—¥å¿—å¤åˆ¶
    public void replicateEntry(ClusterStateUpdate update) {
        if (currentRole != NodeRole.LEADER) {
            throw new IllegalStateException("Only leader can replicate entries");
        }
        
        LogEntry entry = new LogEntry(currentTerm, update);
        log.add(entry);
        
        // å¹¶è¡Œå¤åˆ¶åˆ°æ‰€æœ‰Follower
        int replicationCount = 1;  // Leaderæœ¬èº«
        for (Node follower : followers) {
            AppendEntriesRequest request = new AppendEntriesRequest(
                currentTerm, nodeId, getLastLogIndex() - 1, 
                getLastLogTerm(), Arrays.asList(entry), commitIndex);
                
            AppendEntriesResponse response = follower.appendEntries(request);
            if (response.isSuccess()) {
                replicationCount++;
            }
        }
        
        // å¤šæ•°èŠ‚ç‚¹ç¡®è®¤åæäº¤
        if (replicationCount &gt; clusterNodes.size() / 2) {
            commitIndex = log.size() - 1;
            applyToStateMachine(update);
        }
    }
}
</code></pre>
<h4 id="é›†ç¾¤å‘ç°æœºåˆ¶">é›†ç¾¤å‘ç°æœºåˆ¶</h4>
<pre><code class="language-java">public class ClusterDiscovery {
    private List&lt;String&gt; seedNodes;
    private Map&lt;String, NodeInfo&gt; discoveredNodes;
    
    // èŠ‚ç‚¹å‘ç°
    public void discoverNodes() {
        Set&lt;String&gt; allNodes = new HashSet&lt;&gt;(seedNodes);
        
        // é€’å½’å‘ç°ï¼šä»ç§å­èŠ‚ç‚¹å¼€å§‹ï¼Œè·å–å®ƒä»¬çŸ¥é“çš„å…¶ä»–èŠ‚ç‚¹
        Queue&lt;String&gt; toDiscover = new LinkedList&lt;&gt;(seedNodes);
        Set&lt;String&gt; discovered = new HashSet&lt;&gt;();
        
        while (!toDiscover.isEmpty()) {
            String nodeAddress = toDiscover.poll();
            if (discovered.contains(nodeAddress)) {
                continue;
            }
            
            try {
                // è¿æ¥èŠ‚ç‚¹ï¼Œè·å–å…¶å·²çŸ¥çš„é›†ç¾¤æˆå‘˜
                NodeInfo nodeInfo = connectAndGetInfo(nodeAddress);
                discoveredNodes.put(nodeAddress, nodeInfo);
                discovered.add(nodeAddress);
                
                // å°†æ–°å‘ç°çš„èŠ‚ç‚¹åŠ å…¥å¾…æ¢ç´¢é˜Ÿåˆ—
                for (String knownNode : nodeInfo.getKnownNodes()) {
                    if (!discovered.contains(knownNode)) {
                        toDiscover.offer(knownNode);
                    }
                }
            } catch (Exception e) {
                log.warn("Failed to discover node: " + nodeAddress, e);
            }
        }
        
        // æ›´æ–°é›†ç¾¤æˆå‘˜è§†å›¾
        updateClusterMembership(discoveredNodes.values());
    }
    
    // æ•…éšœæ£€æµ‹
    @Scheduled(fixedDelay = 1000)
    public void detectFailures() {
        for (Map.Entry&lt;String, NodeInfo&gt; entry : discoveredNodes.entrySet()) {
            String nodeAddress = entry.getKey();
            NodeInfo nodeInfo = entry.getValue();
            
            try {
                // å‘é€å¿ƒè·³æ£€æµ‹
                boolean isAlive = sendHeartbeat(nodeAddress);
                if (!isAlive) {
                    handleNodeFailure(nodeAddress, nodeInfo);
                }
            } catch (Exception e) {
                handleNodeFailure(nodeAddress, nodeInfo);
            }
        }
    }
}
</code></pre>
<h2 id="-æ ¸å¿ƒå·¥ä½œæµç¨‹">ğŸ”„ æ ¸å¿ƒå·¥ä½œæµç¨‹</h2>
<h3 id="1-ç´¢å¼•æµç¨‹">1. ç´¢å¼•æµç¨‹</h3>
<pre><code class="language-java">public class IndexingWorkflow {
    
    public IndexResponse index(IndexRequest request) {
        // 1. è·¯ç”±åˆ°æ­£ç¡®çš„åˆ†ç‰‡
        int shardId = calculateShardId(request.getId());
        Shard primaryShard = getPrimaryShard(shardId);
        
        // 2. åœ¨Primary Shardä¸Šæ‰§è¡Œç´¢å¼•
        Document doc = parseDocument(request.getSource());
        
        // 2.1 åˆ†è¯å¤„ç†
        Map&lt;String, List&lt;String&gt;&gt; analyzedFields = analyzeDocument(doc);
        
        // 2.2 æ„å»ºå€’æ’ç´¢å¼•
        updateInvertedIndex(analyzedFields, doc.getId());
        
        // 2.3 å­˜å‚¨åŸå§‹æ–‡æ¡£
        storeDocument(doc);
        
        // 2.4 æ›´æ–°Doc Values
        updateDocValues(doc);
        
        // 3. å¤åˆ¶åˆ°Replica Shards
        List&lt;Shard&gt; replicas = getReplicaShards(shardId);
        replicateToReplicas(replicas, request);
        
        // 4. è¿”å›å“åº”
        return new IndexResponse(request.getId(), shardId, "created");
    }
}
</code></pre>
<h3 id="2-æœç´¢æµç¨‹">2. æœç´¢æµç¨‹</h3>
<pre><code class="language-java">public class SearchWorkflow {
    
    public SearchResponse search(SearchRequest request) {
        // Phase 1: Query Phase (æŸ¥è¯¢é˜¶æ®µ)
        Map&lt;ShardId, ShardSearchResult&gt; queryResults = queryPhase(request);
        
        // Phase 2: Fetch Phase (è·å–é˜¶æ®µ)  
        List&lt;Document&gt; documents = fetchPhase(queryResults, request);
        
        return buildSearchResponse(documents, queryResults);
    }
    
    private Map&lt;ShardId, ShardSearchResult&gt; queryPhase(SearchRequest request) {
        Map&lt;ShardId, ShardSearchResult&gt; results = new HashMap&lt;&gt;();
        
        // å¹¶è¡ŒæŸ¥è¯¢æ‰€æœ‰ç›¸å…³åˆ†ç‰‡
        List&lt;Future&lt;ShardSearchResult&gt;&gt; futures = new ArrayList&lt;&gt;();
        for (ShardId shardId : getTargetShards(request)) {
            Future&lt;ShardSearchResult&gt; future = executor.submit(() -&gt; {
                Shard shard = getShard(shardId);
                
                // 1. è§£ææŸ¥è¯¢
                Query luceneQuery = parseQuery(request.getQuery());
                
                // 2. æ‰§è¡Œæœç´¢ï¼Œåªè¿”å›DocIDå’ŒScore
                TopDocs topDocs = shard.search(luceneQuery, request.getSize());
                
                // 3. åŒ…è£…ç»“æœ
                return new ShardSearchResult(shardId, topDocs);
            });
            futures.add(future);
        }
        
        // æ”¶é›†æŸ¥è¯¢ç»“æœ
        for (Future&lt;ShardSearchResult&gt; future : futures) {
            ShardSearchResult result = future.get();
            results.put(result.getShardId(), result);
        }
        
        return results;
    }
    
    private List&lt;Document&gt; fetchPhase(Map&lt;ShardId, ShardSearchResult&gt; queryResults,
                                     SearchRequest request) {
        // 1. å…¨å±€æ’åºï¼Œé€‰å‡ºTop-K
        List&lt;ScoreDoc&gt; globalTopDocs = mergeAndSort(queryResults.values(), 
            request.getSize());
        
        // 2. æ ¹æ®DocIDè·å–å®Œæ•´æ–‡æ¡£å†…å®¹
        List&lt;Document&gt; documents = new ArrayList&lt;&gt;();
        for (ScoreDoc scoreDoc : globalTopDocs) {
            ShardId shardId = getShardId(scoreDoc);
            Shard shard = getShard(shardId);
            
            // ä»Stored Fieldsè·å–å®Œæ•´æ–‡æ¡£
            Document doc = shard.getStoredDocument(scoreDoc.doc);
            documents.add(doc);
        }
        
        return documents;
    }
}
</code></pre>
<h2 id="-æ€§èƒ½ç‰¹å¾åˆ†æ">ğŸ“Š æ€§èƒ½ç‰¹å¾åˆ†æ</h2>
<h3 id="1-æŸ¥è¯¢æ€§èƒ½">1. æŸ¥è¯¢æ€§èƒ½</h3>
<pre><code class="language-text">æ—¶é—´å¤æ‚åº¦åˆ†æï¼š

1. TermæŸ¥æ‰¾ï¼šO(logN)
   - Term Index (FST): O(logT), Tä¸ºä¸é‡å¤Termæ•°é‡
   - Term Dictionary: O(1), ç›´æ¥åç§»è®¿é—®
   
2. Posting Listéå†ï¼šO(K)
   - Kä¸ºåŒ…å«Termçš„æ–‡æ¡£æ•°é‡
   - ä½¿ç”¨è·³è¡¨ä¼˜åŒ–ï¼Œå¯ä»¥è·³è¿‡æ— å…³æ–‡æ¡£
   
3. å¤šTermæŸ¥è¯¢åˆå¹¶ï¼šO(K1 + K2 + ... + Kn)
   - ä½¿ç”¨åŒæŒ‡é’ˆæ³•åˆå¹¶æœ‰åºåˆ—è¡¨
   - å¸ƒå°”æŸ¥è¯¢çš„AND/OR/NOTæ“ä½œ
   
4. ç»“æœæ’åºï¼šO(R*logR)
   - Rä¸ºæœ€ç»ˆè¿”å›çš„ç»“æœæ•°é‡
   - é€šå¸¸R &lt;&lt; æ€»æ–‡æ¡£æ•°ï¼Œæ€§èƒ½å¯æ§

æ€»ä½“æŸ¥è¯¢å¤æ‚åº¦ï¼šO(logN + K + R*logR)
</code></pre>
<h3 id="2-å­˜å‚¨æ•ˆç‡">2. å­˜å‚¨æ•ˆç‡</h3>
<pre><code class="language-text">å­˜å‚¨ç©ºé—´åˆ†æï¼š

1. å€’æ’ç´¢å¼•ï¼š
   - Term Dictionary: çº¦ä¸ºåŸæ–‡æœ¬çš„10-30%
   - Posting Lists: çº¦ä¸ºåŸæ–‡æœ¬çš„20-50%
   - Term Index (å†…å­˜): çº¦ä¸ºTerm Dictionaryçš„1-5%

2. Stored Fieldsï¼š
   - å‹ç¼©æ¯”: 50-80% (å–å†³äºæ•°æ®ç±»å‹å’Œå‹ç¼©ç®—æ³•)
   - éšæœºè®¿é—®: éœ€è¦è§£å‹ç¼©å¼€é”€

3. Doc Valuesï¼š
   - æ•°å€¼ç±»å‹: åŸå§‹æ•°æ®çš„70-90% (ä½æ‰“åŒ…ä¼˜åŒ–)
   - å­—ç¬¦ä¸²ç±»å‹: åŸå§‹æ•°æ®çš„60-85% (åºå·åŒ–+å­—å…¸)

4. æ€»ä½“å­˜å‚¨å¼€é”€ï¼š
   - åŸå§‹æ•°æ®: 100%
   - ç´¢å¼•å¼€é”€: 50-100%
   - æ€»å­˜å‚¨: 150-200% of åŸå§‹æ•°æ®
</code></pre>
<h3 id="3-å†…å­˜ä½¿ç”¨">3. å†…å­˜ä½¿ç”¨</h3>
<pre><code class="language-java">public class MemoryUsageAnalysis {
    
    // å„ç»„ä»¶å†…å­˜ä½¿ç”¨ä¼°ç®—
    public MemoryUsage calculateMemoryUsage(IndexStats stats) {
        long termIndexMemory = estimateTermIndexMemory(stats);
        long filterCacheMemory = estimateFilterCacheMemory(stats);
        long fieldDataMemory = estimateFieldDataMemory(stats);
        long segmentMemory = estimateSegmentMemory(stats);
        
        return new MemoryUsage(termIndexMemory, filterCacheMemory, 
            fieldDataMemory, segmentMemory);
    }
    
    private long estimateTermIndexMemory(IndexStats stats) {
        // Term Index (FST) å¤§çº¦å ç”¨ï¼š
        // æ¯ä¸ªå”¯ä¸€Term 8-32å­—èŠ‚ (å–å†³äºå‰ç¼€å‹ç¼©æ•ˆæœ)
        return stats.getUniqueTermCount() * 20; // å¹³å‡20å­—èŠ‚/Term
    }
    
    private long estimateFilterCacheMemory(IndexStats stats) {
        // è¿‡æ»¤å™¨ç¼“å­˜ï¼šç¼“å­˜å¸¸ç”¨çš„è¿‡æ»¤å™¨BitSet
        // æ¯ä¸ªæ–‡æ¡£1bitï¼ŒæŒ‰å­—èŠ‚å¯¹é½
        return stats.getDocumentCount() / 8 * stats.getCachedFilterCount();
    }
    
    private long estimateFieldDataMemory(IndexStats stats) {
        // Doc ValuesåŠ è½½åˆ°å†…å­˜çš„éƒ¨åˆ†
        // æ•°å€¼å­—æ®µï¼š8å­—èŠ‚/æ–‡æ¡£ï¼Œå­—ç¬¦ä¸²å­—æ®µï¼šå˜é•¿
        long numericMemory = stats.getNumericFieldCount() * stats.getDocumentCount() * 8;
        long stringMemory = stats.getStringFieldSize(); // å®é™…å­—ç¬¦ä¸²é•¿åº¦
        return numericMemory + stringMemory;
    }
}
</code></pre>
<h2 id="-æ€»ç»“">ğŸ¯ æ€»ç»“</h2>
<p>ElasticSearché€šè¿‡ç²¾å·§çš„æ•°æ®ç»“æ„è®¾è®¡å’Œåˆ†å¸ƒå¼æ¶æ„ï¼Œå°†Luceneä»å•æœºæœç´¢åº“æ¼”è¿›ä¸ºåˆ†å¸ƒå¼æœç´¢å¼•æ“ï¼š</p>
<h3 id="æ ¸å¿ƒæ•°æ®ç»“æ„ä¼˜åŠ¿">æ ¸å¿ƒæ•°æ®ç»“æ„ä¼˜åŠ¿ï¼š</h3>
<ul>
<li><strong>å€’æ’ç´¢å¼•</strong>ï¼šO(logN)æŸ¥è¯¢å¤æ‚åº¦ï¼Œé«˜æ•ˆå…³é”®è¯æœç´¢</li>
<li><strong>Term Index</strong>ï¼šFSTå‰ç¼€å¤ç”¨ï¼Œå‡å°‘å†…å­˜å¼€é”€å’Œç£ç›˜IO</li>
<li><strong>Stored Fields</strong>ï¼šè¡Œå¼å­˜å‚¨ï¼Œå¿«é€Ÿæ–‡æ¡£æ£€ç´¢</li>
<li><strong>Doc Values</strong>ï¼šåˆ—å¼å­˜å‚¨ï¼Œä¼˜åŒ–èšåˆå’Œæ’åºæ€§èƒ½</li>
</ul>
<h3 id="åˆ†å¸ƒå¼æ¶æ„ç‰¹è‰²">åˆ†å¸ƒå¼æ¶æ„ç‰¹è‰²ï¼š</h3>
<ul>
<li><strong>åˆ†ç‰‡æœºåˆ¶</strong>ï¼šæ°´å¹³æ‰©å±•ï¼Œè´Ÿè½½å‡è¡¡</li>
<li><strong>å‰¯æœ¬ä¿éšœ</strong>ï¼šé«˜å¯ç”¨ï¼Œè¯»å†™åˆ†ç¦»</li>
<li><strong>èŠ‚ç‚¹åˆ†å·¥</strong>ï¼šMasterã€Dataã€Coordinateè§’è‰²è§£è€¦</li>
<li><strong>å»ä¸­å¿ƒåŒ–</strong>ï¼šRaftåè®®ï¼Œæ— å¤–éƒ¨ä¾èµ–</li>
</ul>
<h3 id="æ€§èƒ½ç‰¹å¾">æ€§èƒ½ç‰¹å¾ï¼š</h3>
<ul>
<li><strong>æŸ¥è¯¢æ€§èƒ½</strong>ï¼šäºšç§’çº§å…¨æ–‡æœç´¢å“åº”</li>
<li><strong>å­˜å‚¨æ•ˆç‡</strong>ï¼š50-100%ç´¢å¼•å¼€é”€ï¼Œå¯æ¥å—çš„ç©ºé—´æˆæœ¬</li>
<li><strong>æ‰©å±•èƒ½åŠ›</strong>ï¼šçº¿æ€§æ‰©å±•ï¼Œæ”¯æŒPBçº§æ•°æ®</li>
</ul>
<p>ElasticSearchæˆåŠŸåœ°å°†å¤æ‚çš„ä¿¡æ¯æ£€ç´¢ç†è®ºè½¬åŒ–ä¸ºå®ç”¨çš„åˆ†å¸ƒå¼æœç´¢å¹³å°ï¼Œåœ¨ç°ä»£å¤§æ•°æ®ç”Ÿæ€ä¸­å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚å…¶è®¾è®¡ç†å¿µå’ŒæŠ€æœ¯å®ç°ä¸ºåˆ†å¸ƒå¼ç³»ç»Ÿæ¶æ„æä¾›äº†å®è´µçš„å‚è€ƒä»·å€¼ã€‚</p>

</div>
<div id="MySignature" role="contentinfo">
    <p>æœ¬æ–‡æ¥è‡ªåšå®¢å›­ï¼Œä½œè€…ï¼š<a href="https://www.cnblogs.com/madtom/" target="_blank">MadLongTom</a>ï¼Œè½¬è½½è¯·æ³¨æ˜åŸæ–‡é“¾æ¥ï¼š<a href="https://www.cnblogs.com/madtom/p/19060806" target="_blank">https://www.cnblogs.com/madtom/p/19060806</a></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-27 12:41">2025-08-27 12:41</span>&nbsp;
<a href="https://www.cnblogs.com/madtom">MadLongTom</a>&nbsp;
é˜…è¯»(<span id="post_view_count">34</span>)&nbsp;
è¯„è®º(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19060806);return false;">æ”¶è—</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19060806', targetLink: 'https://www.cnblogs.com/madtom/p/19060806', title: 'ElasticSearchæ˜¯ä»€ä¹ˆï¼Ÿ' })">ä¸¾æŠ¥</a>
</div>
        