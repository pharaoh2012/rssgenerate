
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipstone/p/18712440" title="发布于 2025-02-13 08:53">
    <span role="heading" aria-level="2">干货：DeepSeek+SpringAI实现流式对话！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>前面一篇文章我们实现了《炸裂：SpringAI内置DeepSeek啦！》，但是大模型的响应速度通常是很慢的，为了避免用户用户能够耐心等待输出的结果，我们通常会使用流式输出一点点将结果输出给用户。</p>
<p>那么问题来了，想要实现流式结果输出，后端和前端要如何配合？后端要使用什么技术实现流式输出呢？接下来本文给出具体的实现代码，先看最终实现效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/gif/92791/1739354599624-b05812e0-fa87-4567-9a70-0000d2a38b67.gif" alt="" loading="lazy"></p>
<h2 id="解决方案">解决方案</h2>
<p>在 Spring Boot 中实现流式输出可以使用 Sse（Server-Sent Events，服务器发送事件）技术来实现，它是一种服务器推送技术，适合单向实时数据流，我们<strong>使用 <strong><strong>Spring MVC</strong></strong>（基于 <strong><strong>Servlet</strong></strong>）中的 SseEmitter 对象来实现流式输出</strong>。</p>
<p>具体实现如下。</p>
<h2 id="1后端代码">1.后端代码</h2>
<p>Spring Boot 程序使用 SseEmitter 对象提供的 send 方法发送数据，具体实现代码如下：</p>
<pre><code class="language-java">import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

@RestController
public class StreamController {

    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter streamData() {
        // 创建 SSE 发射器，设置超时时间（例如 1 分钟）
        SseEmitter emitter = new SseEmitter(60_000L);
        // 创建新线程，防止主程序阻塞
        new Thread(() -&gt; {
            try {
                for (int i = 1; i &lt;= 5; i++) {
                    Thread.sleep(1000); // 模拟延迟
                    // 发送数据
                    emitter.send("time=" + System.currentTimeMillis());
                }
                // 发送完毕
                emitter.complete();
            } catch (Exception e) {
                emitter.completeWithError(e);
            }
        }).start();
        return emitter;
    }
}
</code></pre>
<h2 id="2前端代码">2.前端代码</h2>
<p>前端接受数据流也比较简单，不需要在使用传统 Ajax 技术了，只需要创建一个 EventSource 对象，监听后端 SSE 接口，然后将接收到的数据流展示出来即可，如下代码所示：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;流式输出示例&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt;流式数据接收演示&lt;/h2&gt;
    &lt;button onclick="startStream()"&gt;开始接收数据&lt;/button&gt;
    &lt;div id="output" style="margin-top: 20px; border: 1px solid #ccc; padding: 10px;"&gt;&lt;/div&gt;

    &lt;script&gt;
      function startStream() {
        const output = document.getElementById('output');
        output.innerHTML = ''; // 清空之前的内容

        const eventSource = new EventSource('/stream');

        eventSource.onmessage = function(e) {
          const newElement = document.createElement('div');
          newElement.textContent = "print -&gt; " + e.data;
          output.appendChild(newElement);
        };

        eventSource.onerror = function(e) {
          console.error('EventSource 错误:', e);
          eventSource.close();
          const newElement = document.createElement('div');
          newElement.textContent = "连接关闭";
          output.appendChild(newElement);
        };
      }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="3运行项目">3.运行项目</h2>
<p>运行项目测试结果：</p>
<ul>
<li>启动 Spring Boot 项目。</li>
<li>在浏览器中访问地址 <a href="http://localhost:8080/index.html%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA%E7%9A%84%E5%86%85%E5%AE%B9%E9%80%90%E6%B8%90%E6%98%BE%E7%A4%BA%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E3%80%82" target="_blank" rel="noopener nofollow">http://localhost:8080/index.html，即可看到流式输出的内容逐渐显示在页面上。</a></li>
</ul>
<h2 id="4最终版流式输出">4.最终版：流式输出</h2>
<p>后端代码如下：</p>
<pre><code class="language-java">import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.openai.OpenAiChatModel;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.util.Map;

@RestController
public class ChatController {
    private final OpenAiChatModel chatModel;

    @Autowired
    public ChatController(OpenAiChatModel chatModel) {
        this.chatModel = chatModel;
    }

    @GetMapping("/ai/generate")
    public Map generate(@RequestParam(value = "message", defaultValue = "你是谁？") String message) {
        return Map.of("generation", this.chatModel.call(message));
    }

    @GetMapping("/ai/generateStream")
    public SseEmitter streamChat(@RequestParam String message) {
        // 创建 SSE 发射器，设置超时时间（例如 1 分钟）
        SseEmitter emitter = new SseEmitter(60_000L);
        // 创建 Prompt 对象
        Prompt prompt = new Prompt(new UserMessage(message));
        // 订阅流式响应
        chatModel.stream(prompt).subscribe(response -&gt; {
            try {
                String content = response.getResult().getOutput().getContent();
                System.out.print(content);
                // 发送 SSE 事件
                emitter.send(SseEmitter.event()
                             .data(content)
                             .id(String.valueOf(System.currentTimeMillis()))
                             .build());
            } catch (Exception e) {
                emitter.completeWithError(e);
            }
        },
                                           error -&gt; { // 异常处理
                                               emitter.completeWithError(error);
                                           },
                                           () -&gt; { // 完成处理
                                               emitter.complete();
                                           }
                                          );
        // 处理客户端断开连接
        emitter.onCompletion(() -&gt; {
            // 可在此处释放资源
            System.out.println("SSE connection completed");
        });
        emitter.onTimeout(() -&gt; {
            emitter.complete();
            System.out.println("SSE connection timed out");
        });
        return emitter;
    }
}
</code></pre>
<p>前端核心 JS 代码如下：</p>
<pre><code class="language-javascript">$('#send-button').click(function () {
  const message = $('#chat-input').val();
  const eventSource = new EventSource(`/ai/generateStream?message=` + message);
  // 构建动态结果
  var chatMessages = $('#chat-messages');
  var newMessage = $('&lt;div class="message user"&gt;&lt;/div&gt;');
  newMessage.append('&lt;img class="avatar" src="/imgs/user.png" alt="用户头像"&gt;');
  newMessage.append(`&lt;span class="nickname"&gt;${message}&lt;/span&gt;`);
  chatMessages.prepend(newMessage);
  var botMessage = $('&lt;div class="message bot"&gt;&lt;/div&gt;');
  botMessage.append('&lt;img class="avatar" src="/imgs/robot.png" alt="助手头像"&gt;');
  // 流式输出
  eventSource.onmessage = function (event) {
    botMessage.append(`${event.data}`);
  };
  chatMessages.prepend(botMessage);
  $('#chat-input').val('');
  eventSource.onerror = function (err) {
    console.error("EventSource failed:", err);
    eventSource.close();
  };
});
</code></pre>
<p>以上代码中的“$”代表的是 jQuery。</p>
<blockquote>
<p>本文已收录到我的面试小站 <a href="https://www.javacn.site" target="_blank" rel="noopener nofollow">www.javacn.site</a>，其中包含的内容有：DeepSeek、场景题、并发编程、MySQL、Redis、Spring、Spring MVC、Spring Boot、Spring Cloud、MyBatis、JVM、设计模式、消息队列等模块。</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <div style="text-align: center; color: red">
关注下面二维码，订阅更多精彩内容。
<br>
<img style="margin-left: 0px" src="https://images.cnblogs.com/cnblogs_com/vipstone/848916/o_211225130402_gognzhonghao.jpg">
</div>

<div style="display: none">
    <img src="http://icdn.apigo.cn/gitchat/rabbitmq.png?imageView2/0/w/500/h/400">
</div>
<div style="margin-bottom: 50px; display: none">

<img title="微信打赏" src="http://icdn.apigo.cn/myinfo/wchat-pay.png" alt="微信打赏">
<br>

<div style="display: none">
<span style="display: block; position: absolute; height: 40px; top: 50%; margin-top: -20px">关注公众号（加好友）：</span>

<img style="margin-left: 144px" src="http://icdn.apigo.cn/gongzhonghao2.png?imageView2/0/w/120/h/120">
</div>
<p></p>

<div id="AllanboltSignature">
    <p style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 60px; background: url(&quot;https://images.cnblogs.com/cnblogs_com/lloydsheng/239039/o_copyright.gif&quot;) #e5f1f4 no-repeat 1% 50%; font-family: 微软雅黑; font-size: 11px" id="PSignature">
        <br> 作者：
        <a href="http://vipstone.cnblogs.com/" target="_blank">王磊的博客</a>
        <br> 出处：
        <a href="http://vipstone.cnblogs.com/" target="_blank">http://vipstone.cnblogs.com/</a>
        <br>
    </p>
</div></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.005886258189814815" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-13 08:53">2025-02-13 08:53</span>&nbsp;
<a href="https://www.cnblogs.com/vipstone">磊哥|www.javacn.site</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18712440" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18712440);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18712440', targetLink: 'https://www.cnblogs.com/vipstone/p/18712440', title: '干货：DeepSeek+SpringAI实现流式对话！' })">举报</a>
</div>
        