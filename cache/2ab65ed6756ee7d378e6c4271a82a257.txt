
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/handsomer/p/19035095" title="发布于 2025-08-13 09:26">
    <span role="heading" aria-level="2">Docker Swarm Keepalived Operator：高可用集群虚拟 IP 管理方案</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在生产环境中，服务的高可用性往往是一个必要但复杂的需求。传统的容器化高可用部署面临着不少挑战，今天来介绍一个针对 Docker Swarm 设计的 Keepalived Operator，看看它如何简化虚拟 IP 的管理工作。</p>
<h2 id="传统部署方式的挑战">传统部署方式的挑战</h2>
<p>在 Docker 和 Docker Swarm 环境下，实现高可用通常会遇到以下问题：</p>
<h3 id="原生-docker-部署的不足">原生 Docker 部署的不足</h3>
<ul>
<li><strong>手动配置复杂</strong>：需要在每个节点单独配置 Keepalived</li>
<li><strong>配置文件管理困难</strong>：多节点间配置同步容易出错</li>
<li><strong>缺乏动态感知</strong>：节点变化时需要手动修改所有相关配置</li>
<li><strong>监控分散</strong>：各节点日志和状态检查需要逐一处理</li>
</ul>
<h3 id="docker-swarm-原生限制">Docker Swarm 原生限制</h3>
<ul>
<li><strong>服务发现局限</strong>：Swarm 内建的负载均衡无法提供固定的外部 IP</li>
<li><strong>故障切换不透明</strong>：依赖外部负载均衡器，增加架构复杂度</li>
<li><strong>跨主机网络复杂</strong>：需要额外配置 overlay 网络和路由规则</li>
</ul>
<h2 id="operator-方案的改进">Operator 方案的改进</h2>
<p>Docker Swarm Keepalived Operator 采用了 Operator 模式来解决这些问题：</p>
<ul>
<li><strong>自动节点发现</strong>：通过 Docker 标签识别目标节点</li>
<li><strong>配置自动生成</strong>：根据集群状态自动生成 Keepalived 配置</li>
<li><strong>动态服务管理</strong>：节点变化时自动创建或删除服务</li>
<li><strong>集中化监控</strong>：统一的日志和状态管理</li>
</ul>
<h2 id="架构设计">架构设计</h2>
<p>整个系统采用控制器模式，分为两个主要组件：</p>
<h3 id="控制层operator">控制层（Operator）</h3>
<p>运行在 Swarm Manager 节点，负责：</p>
<ul>
<li><strong>节点监控</strong>：持续监控节点标签和状态变化</li>
<li><strong>服务管理</strong>：根据标签变化创建、更新或删除 Keepalived 服务</li>
<li><strong>配置生成</strong>：自动生成集群拓扑对应的 Keepalived 配置</li>
<li><strong>异常处理</strong>：检测到服务异常时进行恢复</li>
</ul>
<h3 id="执行层keepalived-实例">执行层（Keepalived 实例）</h3>
<p>分布在标记的工作节点上：</p>
<ul>
<li><strong>VRRP 协议</strong>：处理虚拟 IP 的选举和切换</li>
<li><strong>健康检查</strong>：监控本地服务状态</li>
<li><strong>故障转移</strong>：在检测到故障时快速切换</li>
</ul>
<p>这种分层设计的优势是职责分离，便于维护和扩展。</p>
<h2 id="三步完成部署">三步完成部署</h2>
<h3 id="步骤一系统环境检查">步骤一：系统环境检查</h3>
<p>部署前先确认系统环境，主要是检查内核模块支持：</p>
<pre><code class="language-bash"># 检查是否已加载 ip_vs 模块
lsmod | grep -P '^ip_vs\s'

# 如果没有输出，需要手动加载
echo "modprobe ip_vs" &gt;&gt; /etc/modules
modprobe ip_vs

# 验证加载成功
lsmod | grep ip_vs
</code></pre>
<p><strong>注意</strong>：<code>ip_vs</code> 模块是 Linux 虚拟服务器的核心模块，Keepalived 需要它来实现负载均衡功能。</p>
<h3 id="步骤二给节点贴标签">步骤二：给节点"贴标签"</h3>
<p>这一步是整个方案的核心 —— 通过 Docker 节点标签来告诉 Operator 哪些节点需要参与高可用：</p>
<pre><code class="language-bash"># 基础标签配置：标记参与高可用的节点
docker node update web-01 --label-add keepalived_group=production
docker node update web-02 --label-add keepalived_group=production
docker node update web-03 --label-add keepalived_group=production
</code></pre>
<p><strong>进阶配置</strong>：如果要精确控制 VRRP 优先级（推荐）：</p>
<pre><code class="language-bash"># 数值越高，成为 Master 的概率越大
docker node update web-01 --label-add KEEPALIVED_PRIORITY=102  # 首选主节点
docker node update web-02 --label-add KEEPALIVED_PRIORITY=101  # 备选主节点
docker node update web-03 --label-add KEEPALIVED_PRIORITY=100  # 普通备节点
</code></pre>
<p><strong>标签说明</strong>：</p>
<ul>
<li><code>keepalived_group=production</code>：指定节点所属的高可用组</li>
<li><code>KEEPALIVED_PRIORITY=102</code>：设置 VRRP 优先级，数值越大优先级越高</li>
</ul>
<h3 id="步骤三编写部署配置">步骤三：编写部署配置</h3>
<p>创建 <code>keepalived-stack.yaml</code> 配置文件，这是整个部署的"蓝图"：</p>
<pre><code class="language-yaml">version: '3.8'

services:
  keepalived_operator:
    image: pubimgs/keepalived-swarm-operator:latest
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      - host
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints: [node.role == manager]
    environment:
      # 必需配置
      KEEPALIVED_GROUP: "production"
      KEEPALIVED_VIRTUAL_IPS: "192.168.1.100,192.168.1.101"

      # 可选配置
      KEEPALIVED_INTERFACE: "eth0"
      KEEPALIVED_PASSWORD: "MySecurePassword123"
      KEEPALIVED_ROUTER_ID: "51"

networks:
  host:
    external: true
    name: host
</code></pre>
<h3 id="一键部署启动">一键部署启动</h3>
<pre><code class="language-bash"># 部署 Keepalived Operator
docker stack deploy -c keepalived-stack.yaml keepalived

# 查看部署状态
docker service ls --filter name=keepalived

# 查看 Operator 工作日志
docker service logs -f keepalived_keepalived_operator
</code></pre>
<p><strong>部署完成后</strong>，Operator 会自动执行以下操作：</p>
<ol>
<li>发现所有带 <code>keepalived_group=production</code> 标签的节点</li>
<li>为每个节点创建对应的 Keepalived 服务</li>
<li>生成集群配置和节点通信列表</li>
<li>开始持续监控服务状态</li>
</ol>
<h2 id="进阶使用技巧">进阶使用技巧</h2>
<h3 id="多环境部署">多环境部署</h3>
<p>在同一个集群中可以通过不同的组标签实现环境隔离：</p>
<pre><code class="language-bash"># 生产环境集群
docker node update prod-01 --label-add keepalived_group=production
docker node update prod-02 --label-add keepalived_group=production

# 测试环境集群
docker node update test-01 --label-add keepalived_group=staging
docker node update test-02 --label-add keepalived_group=staging

# 开发环境集群
docker node update dev-01 --label-add keepalived_group=development
docker node update dev-02 --label-add keepalived_group=development
</code></pre>
<p>然后部署不同的 Operator 实例，每个管理对应的环境，使用独立的虚拟 IP 段实现隔离。</p>
<h3 id="动态扩缩容">动态扩缩容</h3>
<p>Operator 的一个重要特性是支持动态扩缩容，集群节点变化时无需手动干预：</p>
<pre><code class="language-bash"># 集群扩容：新节点加入高可用组
docker node update new-web-04 --label-add keepalived_group=production
# Operator 会发现新节点，自动创建 Keepalived 服务

# 集群缩容：节点退出高可用组
docker node update old-web-01 --label-rm keepalived_group
# Operator 会自动清理对应的 Keepalived 服务

# 临时维护：暂时移除节点
docker node update web-02 --label-rm keepalived_group
# 维护完成后重新加入
docker node update web-02 --label-add keepalived_group=production
</code></pre>
<p>整个过程中，其他节点的服务不受影响，虚拟 IP 会自动重新选举。</p>
<h3 id="优先级策略最佳实践">优先级策略最佳实践</h3>
<p>合理的优先级设计能让故障切换更加符合业务预期：</p>
<p>** 按数据中心分层**：</p>
<ul>
<li><strong>主数据中心</strong>：优先级 110-120（优先承载流量）</li>
<li><strong>同城灾备</strong>：优先级 100-110（次优选择）</li>
<li><strong>异地灾备</strong>：优先级 90-100（最后选择）</li>
</ul>
<p>** 按性能分层**：</p>
<ul>
<li><strong>高性能节点</strong>：优先级 110-120</li>
<li><strong>标准节点</strong>：优先级 100-110</li>
<li><strong>低配节点</strong>：优先级 90-100</li>
</ul>
<pre><code class="language-bash"># 实例：三地三中心部署
docker node update beijing-web-01 --label-add KEEPALIVED_PRIORITY=115   # 主中心
docker node update shanghai-web-01 --label-add KEEPALIVED_PRIORITY=105  # 同城备份
docker node update guangzhou-web-01 --label-add KEEPALIVED_PRIORITY=95  # 异地备份
</code></pre>
<p><strong>建议</strong>：优先级差距保持 5-10 比较合理，既能体现优先顺序，又避免过度集中。</p>
<h2 id="监控运维">监控运维</h2>
<h3 id="日常状态检查">日常状态检查</h3>
<p>建立日常巡检习惯，及时发现问题：</p>
<pre><code class="language-bash"># 1. 检查 Operator 运行状态和日志
docker service logs -f keepalived_keepalived_operator

# 2. 查看集群中所有 Keepalived 服务
docker service ls --filter name=keepalived-node

# 3. 检查具体节点服务详情
docker service logs keepalived-node-web-01-1 --tail 50

# 4. 查看服务分布情况
docker service ps $(docker service ls --filter name=keepalived-node -q)
</code></pre>
<h3 id="虚拟-ip-健康验证">虚拟 IP 健康验证</h3>
<p>确保虚拟 IP 正常工作的检查清单：</p>
<pre><code class="language-bash"># 基础连通性测试
ping -c 3 192.168.1.100

# 查看虚拟 IP 当前绑定在哪个节点
ip addr show | grep "192.168.1.100"

# 从集群外部测试虚拟 IP 服务
curl -I http://192.168.1.100

# 检查 VRRP 协议状态
docker exec $(docker ps -q -f name=keepalived-node | head -1) ip addr show
</code></pre>
<h2 id="典型应用场景">典型应用场景</h2>
<h3 id="场景一电商网站前端高可用">场景一：电商网站前端高可用</h3>
<p>某电商公司有 3 台 Web 服务器，需要对外提供统一访问入口：</p>
<pre><code class="language-bash"># 步骤 1：节点标签配置
docker node update web-server-01 --label-add keepalived_group=frontend
docker node update web-server-02 --label-add keepalived_group=frontend
docker node update web-server-03 --label-add keepalived_group=frontend

# 步骤 2：优先级设置（主机房优先）
docker node update web-server-01 --label-add KEEPALIVED_PRIORITY=110  # 主机房
docker node update web-server-02 --label-add KEEPALIVED_PRIORITY=105  # 主机房
docker node update web-server-03 --label-add KEEPALIVED_PRIORITY=100  # 备机房

# 步骤 3：部署配置
KEEPALIVED_GROUP: "frontend"
KEEPALIVED_VIRTUAL_IPS: "192.168.1.200"  # 用户访问的统一入口
</code></pre>
<p><strong>效果</strong>：用户始终通过 <code>192.168.1.200</code> 访问服务，任意一台服务器故障都不影响用户访问。</p>
<h3 id="场景二数据库集群高可用">场景二：数据库集群高可用</h3>
<p>MySQL 主从集群需要提供统一的写入入口：</p>
<pre><code class="language-bash"># 配置数据库集群节点
docker node update mysql-master --label-add keepalived_group=database
docker node update mysql-master --label-add KEEPALIVED_PRIORITY=120    # 主库最高优先级

docker node update mysql-slave-01 --label-add keepalived_group=database
docker node update mysql-slave-01 --label-add KEEPALIVED_PRIORITY=110  # 首选备库

docker node update mysql-slave-02 --label-add keepalived_group=database
docker node update mysql-slave-02 --label-add KEEPALIVED_PRIORITY=100  # 备选备库

# 部署配置
KEEPALIVED_GROUP: "database"
KEEPALIVED_VIRTUAL_IPS: "192.168.1.210"  # 数据库统一写入入口
</code></pre>
<p><strong>效果</strong>：应用程序连接 <code>192.168.1.210</code> 进行数据库操作，主库故障时自动切换到备库。</p>
<h3 id="场景三api-网关集群">场景三：API 网关集群</h3>
<p>微服务架构下的 API 网关高可用部署：</p>
<pre><code class="language-bash"># 多地域 API 网关部署
docker node update gateway-beijing-01 --label-add keepalived_group=api-gateway
docker node update gateway-beijing-01 --label-add KEEPALIVED_PRIORITY=115

docker node update gateway-shanghai-01 --label-add keepalived_group=api-gateway
docker node update gateway-shanghai-01 --label-add KEEPALIVED_PRIORITY=105

# 部署配置支持多个虚拟 IP
KEEPALIVED_GROUP: "api-gateway"
KEEPALIVED_VIRTUAL_IPS: "192.168.1.220,192.168.1.221"  # 内外网双入口
</code></pre>
<h2 id="总结">总结</h2>
<p>Docker Swarm Keepalived Operator 提供了一种相对简化的高可用部署方案，通过 Operator 模式自动化了传统 Keepalived 的配置和管理工作。</p>
<h3 id="主要优势">主要优势</h3>
<p>与传统部署方式相比：</p>
<ul>
<li>减少了手动配置工作量</li>
<li>支持集群动态变化</li>
<li>提供统一的管理界面</li>
<li>降低了配置出错的可能性</li>
</ul>
<h3 id="适用场景">适用场景</h3>
<p>这个方案比较适合：</p>
<ul>
<li>需要快速部署高可用服务的团队</li>
<li>希望简化 Keepalived 运维工作的场景</li>
<li>Docker Swarm 环境下的虚拟 IP 管理需求</li>
</ul>
<h3 id="使用建议">使用建议</h3>
<ol>
<li>在测试环境先熟悉操作流程</li>
<li>了解 VRRP 协议和 Keepalived 的工作原理</li>
<li>根据实际网络环境调整配置参数</li>
<li>建立相应的监控和告警机制</li>
</ol>
<p>总体来说，这是一个实用的工具，可以在一定程度上简化 Docker Swarm 环境下的高可用部署工作。</p>
<h2 id="相关资源">相关资源</h2>
<ul>
<li><strong>项目地址</strong>：<a href="https://github.com/isqiao/keepalived-docker-swarm-operator" target="_blank" rel="noopener nofollow">https://github.com/isqiao/keepalived-docker-swarm-operator</a></li>
<li><strong>Docker 镜像</strong>：<code>pubimgs/keepalived-swarm-operator:latest</code></li>
<li><strong>问题反馈</strong>：<a href="https://github.com/isqiao/keepalived-docker-swarm-operator/issues" target="_blank" rel="noopener nofollow">https://github.com/isqiao/keepalived-docker-swarm-operator/issues</a></li>
</ul>
<hr>
<p><em>如果这篇文章对你有帮助，别忘了给项目点个 ⭐ Star！</em></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-13 09:26">2025-08-13 09:26</span>&nbsp;
<a href="https://www.cnblogs.com/handsomer">乔闻</a>&nbsp;
阅读(<span id="post_view_count">111</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19035095);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19035095', targetLink: 'https://www.cnblogs.com/handsomer/p/19035095', title: 'Docker Swarm Keepalived Operator：高可用集群虚拟 IP 管理方案' })">举报</a>
</div>
        