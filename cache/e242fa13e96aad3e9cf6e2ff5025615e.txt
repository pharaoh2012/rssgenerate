
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mjunz/p/18740060" title="发布于 2025-02-26 23:43">
    <span role="heading" aria-level="2">JUC并发—14.Future模式和异步编程分析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="1" data-pm-slice="0 0 []"><strong>大纲</strong></p>
<p data-track="2"><strong>1.FutureTask(Future/Callable)的使用例子</strong></p>
<p data-track="3"><strong>2.FutureTask(Future/Callable)的实现原理</strong></p>
<p data-track="4"><strong>3.FutureTask(Future/Callable)的源码分析</strong></p>
<p data-track="5"><strong>4.CompletableFuture的基本介绍</strong></p>
<p data-track="6"><strong>5.CompletionStage方法及作用说明</strong></p>
<p data-track="7"><strong>6.CompletableFuture的实现原理分析</strong></p>
<p data-track="8"><strong>7.CompletableFuture的核心源码分析</strong></p>
<p data-track="9">&nbsp;</p>
<p data-track="10"><strong>1.FutureTask(Future/Callable)的使用例子</strong></p>
<p data-track="11">Future/Callable实现了一个异步执行并带有返回结果的功能。Future表示获取一个异步执行的结果，Callable表示一个异步执行的任务，Callable会产生一个结果并给到Future。</p>
<p data-track="12">&nbsp;</p>
<p data-track="13">Future/Callable的使用例子如下：</p>
<pre class="highlighter-hljs"><code>public class FutureCallableExample {
    static class CalculationCallable implements Callable&lt;Integer&gt; {
        private int x;
        private int y;

        public CalculationCallable(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public Integer call() throws Exception {
            System.out.println("开始执行：" + new Date());
            TimeUnit.SECONDS.sleep(2);//模拟任务执行的耗时
            return x + y;
        }
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CalculationCallable calculationCallable = new CalculationCallable(1, 2);
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(calculationCallable);
        new Thread(futureTask).start();
        System.out.println("开始执行futureTask：" + new Date());
        Integer rs = futureTask.get();
        System.out.println("执行结果：" + rs);
        System.out.println("结束执行futureTask：" + new Date());
    }
}</code></pre>
<p data-track="15">首先定义一个CalculationCallable类。该类实现了Callable接口，并重写了call()方法，它的功能就是定义一个具有返回值的任务。</p>
<p data-track="16">&nbsp;</p>
<p data-track="17">然后用FutureTask声明一个带有返回值的任务，把CalculationCallable作为构造参数传递进去。</p>
<p data-track="18">&nbsp;</p>
<p data-track="19">FutureTask实现了Future接口和Runnable接口。我们知道线程执行完之后是不可能获得一个返回值的。Future之所以能够获得返回值，是因为在线程执行中做了相关处理。FutureTask就是用来获得线程执行结果的。</p>
<p data-track="20">&nbsp;</p>
<p data-track="21">接着把FutureTask作为一个任务传入Thread的构造方法，让线程去执行。FutureTask既然实现了Runnable接口，创建FutureTask时又把实现了Callable接口的任务传递到其构造方法中，那么FutureTask的run()方法中会调用Callable接口的call()方法的实现，最终在获得返回值之后保存到某个属性中。</p>
<p data-track="22">&nbsp;</p>
<p data-track="23">最后使用FutureTask.get()方法来获得返回值，这个get()方法是个阻塞方法。当线程还没有执行完FutureTask之前，主线程会阻塞在get()方法中。直到FutureTask执行结束，主线程才会被唤醒。</p>
<p data-track="24">&nbsp;</p>
<p data-track="25"><strong>2.FutureTask(Future/Callable)的实现原理</strong></p>
<p data-track="26"><strong>(1)FutureTask的类关系</strong></p>
<p data-track="27"><strong>(2)FutureTask的实现核心</strong></p>
<p data-track="28">&nbsp;</p>
<p data-track="29"><strong>(1)FutureTask的类关系</strong></p>
<p data-track="30">Runnable接口的实现可以被线程执行，Future接口提供了获取线程执行结果的方法。RunnableFuture接口同时继承了Runnable接口和Future接口，而FutureTask类则实现了RunnableFuture接口。</p>
<p data-track="31">&nbsp;</p>
<p data-track="32">创建FutureTask类实例时，会传入Callable接口的实现类实例作为构造参数，也就是FutureTask类会封装Callable接口的实现类。这样在启动线程后执行FutureTask类重写Runnable接口的run()方法时，FutureTask类实例就会把执行Callable接口call()方法的运行结果保存起来，然后通过Future接口提供的get()方法来获取运行结果。</p>
<p data-track="33">&nbsp;</p>
<p data-track="34"><strong>一.FutureTask的类关系源码</strong></p>
<pre class="highlighter-hljs"><code>//A cancellable asynchronous computation.
//This class provides a base implementation of Future, with methods to start and cancel a computation, 
//query to see if the computation is complete, and retrieve the result of the computation.
//The result can only be retrieved when the computation has completed; 
//the get methods will block if the computation has not yet completed.
//Once the computation has completed, the computation cannot be restarted or cancelled 
//(unless the computation is invoked using #runAndReset).

//A FutureTask can be used to wrap a Callable or Runnable object.  
//Because FutureTask implements Runnable, 
//a FutureTask can be submitted to an Executor for execution.

//In addition to serving as a standalone class, 
//this class provides protected functionality that may be useful when creating customized task classes.
public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {
    ...
    //Creates a FutureTask that will, upon running, execute the given Callable.
    public FutureTask(Callable&lt;V&gt; callable) {
        if (callable == null) {
            throw new NullPointerException();
        }
        this.callable = callable;
        this.state = NEW;//ensure visibility of callable
    }
    ...
}

//A Future that is Runnable.
//Successful execution of the run method causes completion of the Future and allows access to its results.
public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {
    //Sets this Future to the result of its computation unless it has been cancelled.
    void run();
}

//A Future represents the result of an asynchronous computation.
//Methods are provided to check if the computation is complete, 
//to wait for its completion, and to retrieve the result of the computation.  
//The result can only be retrieved using method get when the computation has completed, 
//blocking if necessary until it is ready.
//Cancellation is performed by the cancel method.  
//Additional methods are provided to determine if the task completed normally or was cancelled. 
//Once a computation has completed, the computation cannot be cancelled.
//If you would like to use a Future for the sake of cancellability but not provide a usable result, 
//you can declare types of the form Future&lt;?&gt; and return null as a result of the underlying task.
public interface Future&lt;V&gt; {
    //用来取消任务，取消成功则返回true，取消失败则返回false
    //mayInterruptIfRunning参数表示是否允许取消正在执行却没有执行完毕的任务，设为true，则表示可以取消正在执行过程中的任务
    //如果任务已完成，则无论mayInterruptIfRunning为true还是false，此方法都返回false，即如果取消已经完成的任务会返回false
    //如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false
    //如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true
    boolean cancel(boolean mayInterruptIfRunning);

    //表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回true
    boolean isCancelled();

    //表示任务是否已经完成，若任务完成，则返回true
    boolean isDone();

    //获取执行结果，如果最终结果还没得出该方法会产生阻塞，直到任务执行完毕返回结果
    V get() throws InterruptedException, ExecutionException;

    //获取执行结果，如果在指定时间内，还没获取到结果，则抛出TimeoutException
    V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
}

@FunctionalInterface
public interface Runnable {
    public abstract void run();
}</code></pre>
<p data-track="36"><strong>二.FutureTask的类关系图</strong></p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a00493c3bf5d4025b050612d72caedea~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250226234130A3C12FC515AB5628CF1E&amp;x-expires=2147483647&amp;x-signature=DGKZf7aYJDwIRtscAieaqAwA%2BCM%3D" data-ic="false" data-width="1080" data-height="545" data-ic-uri=""></div>
<p data-track="37"><strong>(2)FutureTask的实现核心</strong></p>
<p data-track="38"><strong>一.FutureTask本身是一个线程</strong></p>
<p data-track="39">通过new Thread(new FutureTask(callable)).start()来启动，必然会执行FutureTask实现Runnable接口的run()方法。</p>
<p data-track="40">&nbsp;</p>
<p data-track="41"><strong>二.Runnable接口的run()方法是没有返回值的</strong></p>
<p data-track="42">实际上返回值是由Callable接口的call()方法提供，所以调用FutureTask的run()方法，会触发调用Callable的call()方法。</p>
<p data-track="43">&nbsp;</p>
<p data-track="44"><strong>三.通过Future接口的get()方法阻塞式获得返回值</strong></p>
<p data-track="45">如果在FutureTask的run()方法中调用Callable接口的call()方法执行任务时，需要比较长的时间，那么为了能够正确获得返回值，Future接口的get()方法必须实现阻塞，直到call()方法执行完毕。</p>
<p data-track="46">&nbsp;</p>
<p data-track="47"><strong>四.需要一个队列来保存阻塞的线程</strong></p>
<p data-track="48">涉及线程阻塞和唤醒，要使用LockSupport来阻塞和唤醒队列中的线程。</p>
<p data-track="49">&nbsp;</p>
<p data-track="50"><strong>3.FutureTask(Future/Callable)的源码分析</strong></p>
<p data-track="51"><strong>(1)FutureTask的核心属性</strong></p>
<p data-track="52"><strong>(2)FutureTask的run()方法</strong></p>
<p data-track="53"><strong>(3)FutureTask的get()方法</strong></p>
<p data-track="54"><strong>(4)FutureTask的finishCompletion()方法</strong></p>
<p data-track="55"><strong>(5)FutureTask的实现原理总结</strong></p>
<p data-track="56">&nbsp;</p>
<p data-track="57"><strong>(1)FutureTask的核心属性</strong></p>
<p data-track="58">一.state</p>
<p data-track="59">代表任务在运行过程中的状态(7种)。</p>
<p data-track="60">二.callable</p>
<p data-track="61">当前要执行的任务。</p>
<p data-track="62">三.outcome</p>
<p data-track="63">任务的执行结果，通过Future.get()获取的值。</p>
<p data-track="64">四.runner</p>
<p data-track="65">当前执行callable任务的线程。</p>
<p data-track="66">五.waiter</p>
<p data-track="67">用来保存所有等待任务执行结束的线程的单向链表。</p>
<pre class="highlighter-hljs"><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {
    //The run state of this task, initially NEW. 
    //The run state transitions to a terminal state only in methods set, setException, and cancel.
    //During completion, state may take on transient values of COMPLETING (while outcome is being set) 
    //or INTERRUPTING (only while interrupting the runner to satisfy a cancel(true)). 
    //Transitions from these intermediate to final states use cheaper ordered/lazy writes 
    //because values are unique and cannot be further modified.
    //Possible state transitions:
    //NEW(初始状态) -&gt; COMPLETING(正在设置任务结果) -&gt; NORMAL，这是任务正常执行完毕时状态的变更流程
    //NEW(初始状态) -&gt; COMPLETING(正在设置任务结果) -&gt; EXCEPTIONAL，这是任务执行异常时状态的变更流程
    //NEW(初始状态) -&gt; CANCELLED(任务被取消)，这是调用了Future.cancel()方法
    //NEW(初始状态) -&gt; INTERRUPTING(正在中断执行任务的线程) -&gt; INTERRUPTED(任务被中断)
    //代表任务在运行过程中的状态(7种)
    private volatile int state;
    private static final int NEW          = 0;
    private static final int COMPLETING   = 1;
    private static final int NORMAL       = 2;
    private static final int EXCEPTIONAL  = 3;
    private static final int CANCELLED    = 4;
    private static final int INTERRUPTING = 5;
    private static final int INTERRUPTED  = 6;

    //The underlying callable; nulled out after running
    //当前要执行的任务
    private Callable&lt;V&gt; callable;
    
    //The result to return or exception to throw from get()
    //任务的执行结果，通过Future.get()获取的值
    private Object outcome;
    
    //The thread running the callable; CASed during run()
    //当前执行callable任务的线程
    private volatile Thread runner;
    
    //Treiber stack of waiting threads
    //用来保存所有等待任务执行结束的线程的单向链表
    private volatile WaitNode waiters;
    ...
}</code></pre>
<p data-track="69"><strong>(2)FutureTask的run()方法</strong></p>
<p data-track="70">使用线程来执行FutureTask任务时，比如new Thread(new FutureTask(callable)).start()，会回调FutureTask的run()方法。</p>
<p data-track="71">&nbsp;</p>
<p data-track="72">FutureTask的run()方法的执行流程如下：</p>
<p data-track="73">首先判断当前状态是否为NEW，并使用CAS设置runner属性为当前线程。如果当前状态不是NEW或者CAS设置失败，则说明已经有其他线程正在执行当前任务了，于是直接返回。然后获取通过构造方法传入的Callable接口的实现类实例callable，接着调用Callable接口的实现类实例callable中的call()方法获得执行结果，最后调用FutureTask的set()方法把执行结果保存到outcome属性中。</p>
<pre class="highlighter-hljs"><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {
    ...
    //代表任务在运行过程中的状态(7种)
    private volatile int state;
    
    //当前要执行的任务
    private Callable&lt;V&gt; callable;
    
    //任务的执行结果，通过Future.get()获取的值
    private Object outcome;
    
    //当前执行callable任务的线程
    private volatile Thread runner;
    
    //用来保存所有等待任务执行结束的线程的单向链表
    private volatile WaitNode waiters;
    
    private static final sun.misc.Unsafe UNSAFE;
    private static final long stateOffset;
    private static final long runnerOffset;
    private static final long waitersOffset;
    static {
        try {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class&lt;?&gt; k = FutureTask.class;
            stateOffset = UNSAFE.objectFieldOffset(k.getDeclaredField("state"));
            runnerOffset = UNSAFE.objectFieldOffset(k.getDeclaredField("runner"));
            waitersOffset = UNSAFE.objectFieldOffset(k.getDeclaredField("waiters"));
        } catch (Exception e) {
            throw new Error(e);
        }
    }
    
    public void run() {
        //首先判断当前状态是否为NEW，并使用CAS把runner属性设置为当前线程
        //如果当前状态不是NEW或者CAS设置失败，说明已经有其他线程正在执行当前任务了，于是直接返回
        if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) { 
            return;
        }
        try {
            //获取通过构造方法传入的Callable接口的实现类实例callable
            Callable&lt;V&gt; c = callable;
            if (c != null &amp;&amp; state == NEW) {
                V result;
                boolean ran;
                try {
                    //然后调用callable中的call()方法获得执行结果
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran) {
                    //调用set()方法把执行结果保存到outcome属性中
                    set(result);
                }
            }
        } finally {
            //runner must be non-null until state is settled to prevent concurrent calls to run()
            runner = null;
            //state must be re-read after nulling runner to prevent leaked interrupts
            int s = state;
            if (s &gt;= INTERRUPTING) {
                handlePossibleCancellationInterrupt(s);
            }
        }
    }
    
    //Sets the result of this future to the given value unless this future has already been set or has been cancelled.
    //This method is invoked internally by the run method upon successful completion of the computation.
    protected void set(V v) {
        //CAS修改任务状态为COMPLETING
        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
            //把调用call()方法获取到的结果保存到outcome
            outcome = v;
            //CAS修改任务状态为NORMAL
            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state
            finishCompletion();
        }
    }
    ...
}</code></pre>
<p data-track="75"><strong>(3)FutureTask的get()方法</strong></p>
<p data-track="76">FutureTask的get()方法的逻辑很简单，如果当前状态不是COMPLETING，就调用awaitDone()方法让当前线程阻塞等待，直到任务执行完成。其中awaitDone()方法的返回值表示任务的状态，当任务进入终止状态后，会调用reports()方法，根据状态类型来决定是返回运行结果还是抛异常。</p>
<p data-track="77">&nbsp;</p>
<p data-track="78">在FutureTask的awaitDone()方法中会进行自旋。首先如果检测到线程被中断，则把加入等待队列中的线程移除。然后如果发现任务已经进入终止状态，则直接返回任务状态。如果任务正在设置执行结果，则通过Thread.yield()让出当前线程的CPU资源。</p>
<p data-track="79">&nbsp;</p>
<p data-track="80">当FutureTask.awaitDone()方法第一次调用时，在第一次for循环中会初始化一个WaitNode结点，这个WaitNode结点便保存了调用FutureTask.get()方法的线程。在第二次for循环中会通过CAS按头插法将WaitNode结点插入waiters链表。在之后的for循环中，也就是当前线程已经加入了等待队列后，如果发现任务还没有执行完成，则通过LockSupport的方法阻塞线程。</p>
<p data-track="81">&nbsp;</p>
<p data-track="82">注意，被阻塞的线程在如下两种情况下会被唤醒：</p>
<p data-track="83">一.任务执行完成后，在set()方法中调用finishCompletion()方法</p>
<p data-track="84">二.线程被中断，在awaitDone()方法中执行中断检测if(Thread.interrupted())</p>
<pre class="highlighter-hljs"><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {
    ...
    //代表任务在运行过程中的状态(7种)
    private volatile int state;
    //当前要执行的任务
    private Callable&lt;V&gt; callable;
    //任务的执行结果，通过Future.get()获取的值
    private Object outcome;
    //当前执行callable任务的线程
    private volatile Thread runner;
    //用来保存所有等待任务执行结束的线程的单向链表
    private volatile WaitNode waiters;
    
    public V get() throws InterruptedException, ExecutionException {
        int s = state;
        if (s &lt;= COMPLETING) {
            s = awaitDone(false, 0L);
        }
        return report(s);
    }
    
    //Awaits completion or aborts on interrupt or timeout.
    //@param timed true if use timed waits
    //@param nanos time to wait, if timed
    //@return state upon completion
    private int awaitDone(boolean timed, long nanos) throws InterruptedException {
        //阻塞超时时间，timed表示是否传递阻塞时间的参数
        final long deadline = timed ? System.nanoTime() + nanos : 0L;
        WaitNode q = null;
        boolean queued = false;
        for (;;) {//自旋
            //如果检测到线程被中断，则把加入等待队列中的线程移除
            if (Thread.interrupted()) {
                removeWaiter(q);
                //抛出中断异常
                throw new InterruptedException();
            }
            int s = state;
            //如果任务已经进入终止状态，则直接返回任务状态
            if (s &gt; COMPLETING) {
                if (q != null) {
                    q.thread = null;
                }
                return s;
            } else if (s == COMPLETING) {// cannot time out yet
                //如果任务正在设置执行结果，则通过Thread.yield()让出当前线程的CPU资源
                Thread.yield();
            } else if (q == null) {
                //awaitDone()方法被第一次调用时，q == null为true
                //此时会初始化一个WaitNode结点并赋值给q，这个WaitNode结点保存了调用FutureTask.get()的线程 
                q = new WaitNode();
            } else if (!queued) {
                //awaitDone()方法被第一次调用时，进入的第二次for循环
                //便会通过CAS将q结点按头插法插入waiters单向链表中
                queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q);
            } else if (timed) {
                //如果当前线程加入等待队列后，任务还没有执行完成，则通过LockSupport的方法阻塞线程
                nanos = deadline - System.nanoTime();
                if (nanos &lt;= 0L) {
                    removeWaiter(q);
                    return state;
                }
                LockSupport.parkNanos(this, nanos);
            } else {
                LockSupport.park(this);
            }
        }
    }
    
    //Returns result or throws exception for completed task.
    //@param s completed state value
    @SuppressWarnings("unchecked")
    private V report(int s) throws ExecutionException {
        Object x = outcome;
        if (s == NORMAL) {
            return (V)x;
        }
        if (s &gt;= CANCELLED) {
            throw new CancellationException();
        }
        throw new ExecutionException((Throwable)x);
    }
    
    static final class WaitNode {
        volatile Thread thread;
        volatile WaitNode next;
        WaitNode() {
            thread = Thread.currentThread();
        }
    }
    
    private void removeWaiter(WaitNode node) {
        if (node != null) {
            node.thread = null;
            retry:
            for (;;) {//restart on removeWaiter race
                for (WaitNode pred = null, q = waiters, s; q != null; q = s) {
                    s = q.next;
                    if (q.thread != null) {
                        pred = q;
                    } else if (pred != null) {
                        pred.next = s;
                        if (pred.thread == null) {// check for race
                            continue retry;
                        }
                    } else if (!UNSAFE.compareAndSwapObject(this, waitersOffset, q, s)) {
                        continue retry;
                    }
                }
                break;
            }
        }
    }
    ...
}</code></pre>
<p data-track="86"><strong>(4)FutureTask的finishCompletion()方法</strong></p>
<p data-track="87">当Callable任务执行完成后，FutureTask的set()方法会调用finishCompletion()方法唤醒链表中的阻塞线程。</p>
<pre class="highlighter-hljs"><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {
    ...
    //代表任务在运行过程中的状态(7种)
    private volatile int state;
    //当前要执行的任务
    private Callable&lt;V&gt; callable;
    //任务的执行结果，通过Future.get()获取的值
    private Object outcome;
    //当前执行callable任务的线程
    private volatile Thread runner;
    //用来保存所有等待任务执行结束的线程的单向链表
    private volatile WaitNode waiters;
    
    ...
    //Removes and signals all waiting threads, invokes done(), and nulls out callable.
    private void finishCompletion() {
        for (WaitNode q; (q = waiters) != null;) {
            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {
                for (;;) {
                    Thread t = q.thread;
                    if (t != null) {
                        q.thread = null;
                        LockSupport.unpark(t);
                    }
                    WaitNode next = q.next;
                    if (next == null) {
                        break;
                    }
                    q.next = null; // unlink to help gc
                    q = next;
                }
                break;
            }
        }
        done();
        callable = null;
    }
    ...
}</code></pre>
<p data-track="89"><strong>(5)FutureTask的实现原理总结</strong></p>
<p data-track="90">FutureTask实现了Runnable和Future接口，FutureTask表示一个带有状态及执行结果的任务，而任务执行结果的获取是基于阻塞的方式来实现的。</p>
<p data-track="91">&nbsp;</p>
<p data-track="92">在Callable接口的call()方法没有返回结果之前，其他线程调用FutureTask的get()方法获取结果时，FutureTask会构建一个waiters链表，把当前线程存储到链表中并通过LockSupport进行阻塞，直到call()方法返回后把结果设置到outcome属性以及唤醒阻塞的线程。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/792734b84b40440ba8b0049fb288d9a0~tplv-obj.image?lk3s=ef143cfe&amp;traceid=20250226234130A3C12FC515AB5628CF1E&amp;x-expires=2147483647&amp;x-signature=xam9A%2F8pRcVJlDG2JQ3mjUh1lmY%3D" data-ic="false" data-width="1080" data-height="632" data-ic-uri=""></div>
<p data-track="93"><strong>(6)FutureTask的局限性</strong></p>
<p data-track="94">局限性一：</p>
<p data-track="95">在获取异步任务的执行结果时，要么调用get()方法阻塞等待返回结果，要么耗费CPU资源通过轮询调用FutureTask.isDone()方法来判断任务的执行状态，然后再调用get()方法获取返回结果。</p>
<p data-track="96">&nbsp;</p>
<p data-track="97">局限性二：</p>
<p data-track="98">FutureTask没有提供通知机制，没有办法知道任务什么时候执行完成。</p>
<p data-track="99">&nbsp;</p>
<p data-track="100"><strong>4.CompletableFuture的基本介绍</strong></p>
<p data-track="101"><strong>(1)CompletableFuture的介绍</strong></p>
<p data-track="102"><strong>(2)CompletableFuture的类关系图</strong></p>
<p data-track="103"><strong>(3)CompletableFuture的方法说明</strong></p>
<p data-track="104">&nbsp;</p>
<p data-track="105"><strong>(1)CompletableFuture的介绍</strong></p>
<p data-track="106">CompletableFuture针对Future做了改进，也就是在异步任务执行完成后，主线程如果需要依赖该任务的执行结果来继续后面的操作，则可以不用通过等待来实现，只需向CompletableFuture传入一个回调对象。当异步任务执行完毕后，便会自动调用该回调对象(异步回调通知功能)。</p>
<p data-track="107">&nbsp;</p>
<p data-track="108">CompletableFuture还提供了非常强大的功能。对于回调对象的执行，可以放到非任务线程中，也可以放到任务线程中。CompletableFuture提供了函数式编程能力，简化了异步编程的复杂性。还提供了多个CompletableFuture的组合与转化功能。</p>
<p data-track="109">&nbsp;</p>
<p data-track="110"><strong>(2)CompletableFuture的类关系</strong></p>
<p data-track="111">CompletableFuture类实现了Future和CompletionStage这两个接口，其中Future接口提供了获取任务执行结果及任务执行状态的功能，CompletionStage接口表示任务执行的一个阶段。CompletionStage接口定义了很多方法，比如thenApply()、thenAccept()等。通过这些方法可以实现多个任务之间的时序关系，比如串行、并行、聚合等。</p>
<p data-track="112">&nbsp;</p>
<p data-track="113">因此CompletableFuture既提供了Future阻塞式获取结果 + 任务状态的功能，也提供了CompletionStage的任务执行后触发回调 + 多个任务聚合的功能。</p>
<p data-track="114">&nbsp;</p>
<p data-track="115"><strong>(3)CompletableFuture的方法说明</strong></p>
<p data-track="116"><strong>一.构建CompletableFuture的静态方法</strong></p>
<p data-track="117"><strong>二.runAsync()和supplyAsync()静态方法</strong></p>
<p data-track="118"><strong>三.allOf()和anyOf()静态方法</strong></p>
<p data-track="119"><strong>四.主动获取任务执行结果的方法</strong></p>
<p data-track="120">&nbsp;</p>
<p data-track="121"><strong>一.构建CompletableFuture的静态方法</strong></p>
<p data-track="122">CompletableFuture提供了4个静态方法来构建一个异步事件。由于传递进CompletableFuture这4个方法的任务需要异步执行，所以默认会使用ForkJoinPool.commonPool()提供的线程池来执行异步任务，当然也可以自定义一个线程池传入这些静态方法来执行异步任务。</p>
<pre class="highlighter-hljs"><code>//A Future that may be explicitly completed (setting its value and status), 
//and may be used as a CompletionStage,
//supporting dependent functions and actions that trigger upon its completion.
public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletableFuture that is asynchronously completed 
    //by a task running in the ForkJoinPool#commonPool() 
    //with the value obtained by calling the given Supplier.
    //@param supplier a function returning the value to be used to complete the returned CompletableFuture 
    //@param &lt;U&gt; the function's return type
    //@return the new CompletableFuture
    //带有返回值的异步执行方法，传入一个函数式接口，返回一个新的CompletableFuture对象
    //默认使用ForkJoinPool.commonPool()作为线程池执行异步任务
    public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) {
        return asyncSupplyStage(asyncPool, supplier);
    }

    //Returns a new CompletableFuture that is asynchronously completed 
    //by a task running in the given executor with the value obtained by calling the given Supplier.
    //@param supplier a function returning the value to be used to complete the returned CompletableFuture
    //@param executor the executor to use for asynchronous execution
    //@param &lt;U&gt; the function's return type
    //@return the new CompletableFuture
    //带有返回值的异步执行方法，传入一个函数式接口 + 一个线程池，返回一个新的CompletableFuture对象
    //多了一个Executor参数，表示使用自定义线程池来执行任务
    public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor) {
        return asyncSupplyStage(screenExecutor(executor), supplier);
    }
    
    static &lt;U&gt; CompletableFuture&lt;U&gt; asyncSupplyStage(Executor e, Supplier&lt;U&gt; f) {
        if (f == null) throw new NullPointerException();
        CompletableFuture&lt;U&gt; d = new CompletableFuture&lt;U&gt;();
        e.execute(new AsyncSupply&lt;U&gt;(d, f));
        return d;
    }

    //Returns a new CompletableFuture that is asynchronously completed
    //by a task running in the ForkJoinPool#commonPool() after it runs the given action.
    //@param runnable the action to run before completing the returned CompletableFuture
    //@return the new CompletableFuture
    //不带返回值的异步执行方法，传入一个Runnable参数，返回一个新的CompletableFuture对象
    //默认使用ForkJoinPool.commonPool()作为线程池执行异步任务
    public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) {
        return asyncRunStage(asyncPool, runnable);
    }

    //Returns a new CompletableFuture that is asynchronously completed 
    //by a task running in the given executor after it runs the given action.
    //@param runnable the action to run before completing the returned CompletableFuture
    //@param executor the executor to use for asynchronous execution
    //@return the new CompletableFuture
    //不带返回值的异步执行方法，传入一个Runnable参数 + 一个线程池，返回一个新的CompletableFuture对象
    //多了一个Executor参数，表示使用自定义线程池来执行任务
    public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor) {
        return asyncRunStage(screenExecutor(executor), runnable);
    }
    
    static CompletableFuture&lt;Void&gt; asyncRunStage(Executor e, Runnable f) {
        if (f == null) throw new NullPointerException();
        CompletableFuture&lt;Void&gt; d = new CompletableFuture&lt;Void&gt;();
        e.execute(new AsyncRun(d, f));
        return d;
    }
    ...
}</code></pre>
<p data-track="124"><strong>二.runAsync()和supplyAsync()静态方法</strong></p>
<p data-track="125">下面使用runAsync()方法来构建一个异步执行事件，由于runAsync()方法是没有返回值的，所以get()这个阻塞等待任务执行完成的方法返回的还是null。</p>
<pre class="highlighter-hljs"><code>CompletableFuture cf = CompletableFuture.runAsync(() -&gt; {
    System.out.println(Thread.currentThread().getName() + ":异步执行一个任务");
});
cf.get();//阻塞等待任务执行完成</code></pre>
<p data-track="127">下面使用supplyAsync()方法来构建一个异步执行事件，由于supplyAsync()方法具有返回值，所以get()方法会返回"supplyAsync"。</p>
<pre class="highlighter-hljs"><code>CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; {
    System.out.println("supplyAsync");
});
cf.get();//阻塞等待任务执行完成</code></pre>
<p data-track="129"><strong>三.allOf()和anyOf()静态方法</strong></p>
<p data-track="130">allOf()方法接收多个CompletableFuture的无返回值的任务。当所有的任务都执行结束后，返回一个新的CompletableFuture对象。</p>
<p data-track="131">&nbsp;</p>
<p data-track="132">allOf()方法相当于实现了等待多个任务执行结束后再返回的功能，并且接收的CompletableFuture任务是通过runAsync()方法构建的。之所以无返回值，是因为当多个任务都具有返回值时get()方法不知取哪个。</p>
<pre class="highlighter-hljs"><code>public class CompletableFutureExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Void&gt; v1 = CompletableFuture.runAsync(() -&gt; {
            System.out.println("任务v1没有返回值");
        });
        CompletableFuture&lt;Void&gt; v2 = CompletableFuture.runAsync(() -&gt; {
            System.out.println("任务v2没有返回值");
        });
        //通过join()方法让主线程阻塞等待allOf()方法中的所有任务都执行完成后再继续执行
        CompletableFuture.allOf(v1, v2).join();
    }
}</code></pre>
<p data-track="134">anyOf()方法接收多个CompletableFuture的带有返回值的任务。当任何一个任务执行完成后，返回一个新的CompletableFuture对象。</p>
<p data-track="135">&nbsp;</p>
<p data-track="136">anyOf()方法实现了等待多个任务中任何一个任务执行结束便返回的功能，接收的CompletableFuture任务是通过supplyAsync()方法构建的。</p>
<pre class="highlighter-hljs"><code>public class CompletableFutureExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; v1 = CompletableFuture.supplyAsync(() -&gt; {
            return "任务v1的返回值";
        });
        CompletableFuture&lt;String&gt; v2 = CompletableFuture.supplyAsync(() -&gt; {
            return "任务v2的返回值";
        });
        //通过join()方法让主线程阻塞等待anyOf()方法中的任何一个任务执行完成后再继续执行
        CompletableFuture.anyOf(v1, v2).thenAccept(value -&gt; System.out.println(value)).join();
    }
}</code></pre>
<p data-track="138"><strong>四.主动获取任务执行结果的方法</strong></p>
<p data-track="139">由于CompletableFuture实现了Future接口，所以它可以像Future那样主动通过阻塞或轮询的方式来获得执行结果。比如可以通过get()方法阻塞式获取异步任务的执行结果(可中断)，比如也可以通过join()方法阻塞式获取异步任务的执行结果(不可中断)，此外通过complete()方法可实现线程间的数据传递 + 唤醒被get()阻塞的线程。</p>
<pre class="highlighter-hljs"><code>public class CompleteMethodExample {
    public static class ClientThread implements Runnable {
        private CompletableFuture completableFuture;
        
        public ClientThread(CompletableFuture completableFuture) {
            this.completableFuture = completableFuture;
        }
        
        @Override
        public void run() {
            log.info(Thread.currentThread().getName() + ":" + completableFuture.get());
        }
    }
    
    public static void main(String[] args) {
        //在ClientThread线程中使用completableFuture.get()获取返回值时，
        //由于传入的cf并没有使用runAsync()等方法构建具体的异步任务，
        //所以ClientThread线程中的completableFuture.get()方法必然会阻塞；
        CompletableFuture cf = new CompletableFuture();
        new Thread(new ClientThread(cf)).start();
        new Thread(new ClientThread(cf)).start();
        System.out.println("此时两个客户端线程正在被get()方法阻塞");
        //通过compelete()方法来完成cf任务，并且设置了任务的返回结果为"finish"
        cf.complete("finish");//此时会将值为"finish"传入两个线程，并唤醒这两个线程
    }
}</code></pre>
<p data-track="9" data-pm-slice="1 1 []">&nbsp;</p>
<p data-track="142"><strong>5.CompletionStage方法及作用说明</strong></p>
<p data-track="143"><strong>(1)CompletionStage示例</strong></p>
<p data-track="144"><strong>(2)CompletionStage的方法概述</strong></p>
<p data-track="145"><strong>(3)有传参但没返回值的方法</strong></p>
<p data-track="146"><strong>(4)有传参且有返回值的方法</strong></p>
<p data-track="147"><strong>(5)没传参也没返回值的方法</strong></p>
<p data-track="148"><strong>(6)组合起来串行执行的方法</strong></p>
<p data-track="149"><strong>(7)异常处理方法</strong></p>
<p data-track="150">&nbsp;</p>
<p data-track="151"><strong>(1)CompletionStage示例</strong></p>
<p data-track="152">CompletionStage表示任务执行的一个阶段，每个异步任务都会返回一个新的CompletionStage对象，可针对多个CompletionStage对象进行串行、并行、聚合等操作。简单来说，CompletionStage就是实现异步任务执行后的自动回调功能。</p>
<p data-track="153">&nbsp;</p>
<p data-track="154">下面的CompletionStage例子：首先需要调用一个远程方法获得结果，然后把返回结果保存到数据库。所以代码中先定义一个异步任务处理远程调用，并返回CompletionStage，接着调用thenAccept()方法把第一步的执行结果保存到数据库中。</p>
<pre class="highlighter-hljs"><code>public class CompletionStageExample {
    public static void main(String[] args) {
        CompletionStage&lt;String&gt; cf = CompletableFuture.supplyAsync(() -&gt; "远程调用的返回结果");
        cf.thenAccept(result -&gt; {
            System.out.println("第一个异步任务的返回值是：" + result);
            System.out.println("把result保存到数据库");
        });
    }
}</code></pre>
<p data-track="156">可以看见和Future明显不一样的地方就是：thenAccept()方法中传入的回调对象是第一个异步任务执行完后自动触发的，不需要像Future那样去阻塞当前线程等待返回结果，还可以使用thenAcceptAsync()方法让保存到数据库的任务使用独立线程池。</p>
<p data-track="157">&nbsp;</p>
<p data-track="158"><strong>(2)CompletionStage的方法概述</strong></p>
<p data-track="159">CompletionStage总共提供了38个方法来实现多个任务的串行、并行、聚合等功能，这些方法可以按功能进行如下的分类：</p>
<p data-track="160">一.有传参但没返回值的方法</p>
<p data-track="161">二.有传参且有返回值的方法</p>
<p data-track="162">三.没传参也没返回值的方法</p>
<p data-track="163">四.组合起来串行执行的方法</p>
<p data-track="164">五.异常处理的方法</p>
<p data-track="165">&nbsp;</p>
<p data-track="166">注意：Accept关键字有传参没有返回值，Run关键字没传参没返回值。</p>
<p data-track="167">&nbsp;</p>
<p data-track="168"><strong>(3)有传参但没返回值的方法</strong></p>
<p data-track="169">有传参但没返回值的方法就是：用上一个异步任务的结果作为当前方法的参数进行下一步运算，并且当前方法会产生一个新的没有返回值的CompletionStage对象。有传参但没返回值的方法都包含Accept关键字。</p>
<p data-track="170">&nbsp;</p>
<p data-track="171"><strong>一.依赖单个CompletionStage任务完成</strong></p>
<p data-track="172">thenAccept()相关方法用上一个任务的执行结果作为参数执行当前的action，这些方法接收的参数是一个函数式接口Consumer，表示一个待执行的任务。这些方法的返回值是CompletionStage，表示没有返回值。</p>
<p data-track="173">&nbsp;</p>
<p data-track="174">注意：方法以Async结尾，表示使用单独的线程池来执行action，否则使用执行当前任务的线程来执行action。</p>
<pre class="highlighter-hljs"><code>public interface CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletionStage that, when this stage completes normally, 
    //is executed with this stage's result as the argument to the supplied action.
    //@param action the action to perform before completing the returned CompletionStage
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action);

    //Returns a new CompletionStage that, when this stage completes normally, 
    //is executed using this stage's default asynchronous execution facility, 
    //with this stage's result as the argument to the supplied action.
    //@param action the action to perform before completing the returned CompletionStage
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action);

    //Returns a new CompletionStage that, when this stage completes normally, 
    //is executed using the supplied Executor, 
    //with this stage's result as the argument to the supplied action.
    //@param action the action to perform before completing the returned CompletionStage
    //@param executor the executor to use for asynchronous execution
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor);
    ...
}

public class CompletionStageExample {
    //当cf实例的任务执行完成后，会回调传入thenAcceptAsync()方法中的回调函数
    //其中回调函数的result表示cf异步任务的返回结果
    public static void main(String[] args) throws IOException, ExecutionException, InterruptedException { 
        CompletableFuture&lt;String&gt; cf = CompletableFuture.supplyAsync(() -&gt; "thenAccept message");
        cf.thenAcceptAsync((result) -&gt; {
            System.out.println(Thread.currentThread().getName() + "第一个异步任务的返回值:" + result);
        });
    }
}</code></pre>
<p data-track="176"><strong>二.依赖两个CompletionStage任务都完成</strong></p>
<p data-track="177">thenAcceptBoth()相关方法提供了与thenAccept()相关方法类似的功能。不同点在于thenAcceptBoth()相关方法多了一个CompletionStage参数，表示当两个CompletionStage任务都完成后，才执行后面的action。而且这个action可以接收两个参数，这两个参数分别表示两个任务的返回值。thenAcceptBoth()相关方法相当于实现了两个异步任务的组合。</p>
<pre class="highlighter-hljs"><code>public interface CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletionStage that, 
    //when this and the other given stage both complete normally, 
    //is executed with the two results as arguments to the supplied action.
    //@param other the other CompletionStage
    //@param action the action to perform before completing the returned CompletionStage
    //@param &lt;U&gt; the type of the other CompletionStage's result
    //@return the new CompletionStage
    public &lt;U&gt; CompletionStage&lt;Void&gt; thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action); 

    //Returns a new CompletionStage that, 
    //when this and the other given stage complete normally, 
    //is executed using this stage's default asynchronous execution facility, 
    //with the two results as arguments to the supplied action.
    //@param other the other CompletionStage
    //@param action the action to perform before completing the returned CompletionStage
    //@param &lt;U&gt; the type of the other CompletionStage's result
    //@return the new CompletionStage
    public &lt;U&gt; CompletionStage&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action); 

    //Returns a new CompletionStage that, 
    //when this and the other given stage complete normally, 
    //is executed using the supplied executor, 
    //with the two results as arguments to the supplied function.
    //@param other the other CompletionStage
    //@param action the action to perform before completing the returned CompletionStage
    //@param executor the executor to use for asynchronous execution
    //@param &lt;U&gt; the type of the other CompletionStage's result
    //@return the new CompletionStage
    public &lt;U&gt; CompletionStage&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action, Executor executor); 
    ...
}

public class ThenAcceptBothExample {
    //task1和task2都执行完成后，会得到两个任务的返回值AcceptBoth和message，
    //接着开始执行thenAcceptBoth()中的action，
    //这个action会接收前面两个任务的执行结果r1和r2，并最终打印出：执行结果为"AcceptBoth+message"
    public static void main(String[] args) {
        CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; "AcceptBoth");
        CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; "message");
        task1.thenAcceptBoth(task2, (r1, r2) -&gt; {
            System.out.println("执行结果" + r1 + "+" + r2);
        });
       
        //或者采用Fluent风格来写
        //CompletableFuture.supplyAsync(() -&gt; "AcceptBoth").thenAcceptBoth(
        //    CompletableFuture.supplyAsync(() -&gt; "message"), (r1, r2) -&gt; {
        //      System.out.println("执行结果：" + r1 + ", " + r2);
        //    }
        //);
    }
}</code></pre>
<p data-track="179"><strong>三.依赖两个CompletionStage任务中的任何一个完成</strong></p>
<p data-track="180">acceptEither()相关方法和thenAcceptBoth()相关方法几乎一样。它同样接收两个CompletionStage任务，但是只需要保证其中一个任务完成，就会回调acceptEither()方法中传入的action任务。这两个CompletionStage任务谁先完成就会获得谁的返回值，作为参数传给后续的action任务。</p>
<pre class="highlighter-hljs"><code>public interface CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletionStage that, 
    //when either this or the other given stage complete normally, 
    //is executed with the corresponding result as argument to the supplied action.
    //@param other the other CompletionStage
    //@param action the action to perform before completing the returned CompletionStage
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action);

    //Returns a new CompletionStage that, 
    //when either this or the other given stage complete normally, 
    //is executed using this stage's default asynchronous execution facility, 
    //with the corresponding result as argument to the supplied action.
    //@param other the other CompletionStage
    //@param action the action to perform before completing the returned CompletionStage
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action);

    //Returns a new CompletionStage that, 
    //when either this or the other given stage complete normally, 
    //is executed using the supplied executor, 
    //with the corresponding result as argument to the supplied function.
    //@param other the other CompletionStage
    //@param action the action to perform before completing the returned CompletionStage
    //@param executor the executor to use for asynchronous execution
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor); 
    ...
}</code></pre>
<p data-track="182"><strong>(4)有传参且有返回值的方法</strong></p>
<p data-track="183">有传参且有返回值的方法就是：用上一个异步任务的执行结果作为当前方法的参数进行下一步计算，并且当前方法会产生一个新的有返回值的CompletionStage对象。</p>
<p data-track="184">&nbsp;</p>
<p data-track="185"><strong>一.依赖单个CompletionStage任务完成</strong></p>
<p data-track="186">thenApply()这一组方法的功能是等上一个CompletionStage任务执行完后，就会把执行结果传递给函数fn，将函数fn作为一个新的执行任务去执行，最后返回一个新的有返回值的CompletionStage对象。</p>
<p data-track="187">&nbsp;</p>
<p data-track="188">其中以Async结尾的方法表示函数fn这个任务将采用单独的线程池来执行。</p>
<pre class="highlighter-hljs"><code>public interface CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletionStage that, when this stage completes normally, 
    //is executed with this stage's result as the argument to the supplied function.
    //@param fn the function to use to compute the value of the returned CompletionStage
    //@param &lt;U&gt; the function's return type
    //@return the new CompletionStage
    public &lt;U&gt; CompletionStage&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn);

    //Returns a new CompletionStage that, when this stage completes normally, 
    //is executed using this stage's default asynchronous execution facility, 
    //with this stage's result as the argument to the supplied function.
    //@param fn the function to use to compute the value of the returned CompletionStage
    //@param &lt;U&gt; the function's return type
    //@return the new CompletionStage
    public &lt;U&gt; CompletionStage&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn);

    //Returns a new CompletionStage that, when this stage completes normally, 
    //is executed using the supplied Executor, 
    //with this stage's result as the argument to the supplied function.
    //@param fn the function to use to compute the value of the returned CompletionStage
    //@param executor the executor to use for asynchronous execution
    //@param &lt;U&gt; the function's return type
    //@return the new CompletionStage
    public &lt;U&gt; CompletionStage&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor); 
    ...
}</code></pre>
<p data-track="190"><strong>二.依赖两个CompletionStage任务都完成</strong></p>
<p data-track="191">thenCombine()这一组方法的功能类似于thenAcceptBoth()方法。它表示两个CompletionStage任务并行执行结束后，把这两个CompletionStage任务的执行结果传递给函数fn，函数fn执行后返回一个新的有返回值的CompletionStage对象。</p>
<pre class="highlighter-hljs"><code>public interface CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletionStage that, 
    //when this and the other given stage both complete normally, 
    //is executed with the two results as arguments to the supplied function.
    //@param other the other CompletionStage
    //@param fn the function to use to compute the value of the returned CompletionStage
    //@param &lt;U&gt; the type of the other CompletionStage's result
    //@param &lt;V&gt; the function's return type
    //@return the new CompletionStage
    public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn);

    //Returns a new CompletionStage that, 
    //when this and the other given stage complete normally, 
    //is executed using this stage's default asynchronous execution facility, 
    //with the two results as arguments to the supplied function.
    //@param other the other CompletionStage
    //@param fn the function to use to compute the value of the returned CompletionStage
    //@param &lt;U&gt; the type of the other CompletionStage's result
    //@param &lt;V&gt; the function's return type
    //@return the new CompletionStage
    public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn);

    //Returns a new CompletionStage that, 
    //when this and the other given stage complete normally, 
    //is executed using the supplied executor, 
    //with the two results as arguments to the supplied function.  
    //@param other the other CompletionStage
    //@param fn the function to use to compute the value of the returned CompletionStage
    //@param executor the executor to use for asynchronous execution
    //@param &lt;U&gt; the type of the other CompletionStage's result
    //@param &lt;V&gt; the function's return type
    //@return the new CompletionStage
    public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor); 
    ...
}

public class ThenCombineExample {
    public static void main(String[] args) {
        CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; "Combine");
        CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; "message");
        CompletableFuture&lt;String&gt; cf = task1.thenCombineAsync(task2, (r1, r2) -&gt; {
            System.out.println("执行结果：" + r1 + ", " + r2);
            return r1 + r2;
        });
        System.out.println(cf.get());
      
        //或者采用Fluent风格来写
        //CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; "Combine").thenCombineAsync(
        //    CompletableFuture.supplyAsync(() -&gt; "message"), (r1, r2) -&gt; {
        //        System.out.println("执行结果：" + r1 + ", " + r2);
        //        return r1 + r2;
        //    }
        //);
        //System.out.println(cf.get());
    }
}</code></pre>
<p data-track="193"><strong>三.依赖两个CompletionStage任务中的任何一个完成</strong></p>
<p data-track="194">applyToEither()方法表示两个CompletionStage任务中任意一个任务完成后，都执行传入applyToEither()方法中的函数fn，函数fn执行后返回一个新的有返回值的CompletionStage对象。</p>
<pre class="highlighter-hljs"><code>public interface CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletionStage that, 
    //when either this or the other given stage complete normally, 
    //is executed with the corresponding result as argument to the supplied function.
    //@param other the other CompletionStage
    //@param fn the function to use to compute the value of the returned CompletionStage
    //@param &lt;U&gt; the function's return type
    //@return the new CompletionStage
    public &lt;U&gt; CompletionStage&lt;U&gt; applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn);

    //Returns a new CompletionStage that, 
    //when either this or the other given stage complete normally, 
    //is executed using this stage's default asynchronous execution facility, 
    //with the corresponding result as argument to the supplied function.
    //@param other the other CompletionStage
    //@param fn the function to use to compute the value of the returned CompletionStage
    //@param &lt;U&gt; the function's return type
    //@return the new CompletionStage
    public &lt;U&gt; CompletionStage&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn);

    //Returns a new CompletionStage that, 
    //when either this or the other given stage complete normally, 
    //is executed using the supplied executor, 
    //with the corresponding result as argument to the supplied function.
    //@param other the other CompletionStage
    //@param fn the function to use to compute the value of the returned CompletionStage
    //@param executor the executor to use for asynchronous execution
    //@param &lt;U&gt; the function's return type
    //@return the new CompletionStage
    public &lt;U&gt; CompletionStage&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn, Executor executor); 
    ...
}</code></pre>
<p data-track="196"><strong>(5)没传参也没返回值的方法</strong></p>
<p data-track="197">没传参也没返回值的方法就是：当前方法不依赖上一个异步任务的执行结果，只要上一个异步任务执行完成就执行当前方法，并且当前方法会产生一个新的没有返回值的CompletionStage对象，没传参也没返回值的方法都包含Run关键字。</p>
<p data-track="198">&nbsp;</p>
<p data-track="199"><strong>一.依赖单个CompletionStage任务完成</strong></p>
<p data-track="200">thenRun()方法只要上一个阶段的任务执行完成后，便立即执行指定action。thenRunAsync()表示采用ForkjoinPool.commonPool()线程池来执行action，action执行完成后会返回一个新的没有返回值的CompletionStage对象。</p>
<pre class="highlighter-hljs"><code>public interface CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletionStage that, 
    //when this stage completes normally, executes the given action.
    //@param action the action to perform before completing the returned CompletionStage
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; thenRun(Runnable action);

    //Returns a new CompletionStage that, when this stage completes normally, 
    //executes the given action using this stage's default asynchronous execution facility.
    //@param action the action to perform before completing the returned CompletionStage
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; thenRunAsync(Runnable action);

    //Returns a new CompletionStage that, when this stage completes normally, 
    //executes the given action using the supplied Executor.
    //@param action the action to perform before completing the returned CompletionStage
    //@param executor the executor to use for asynchronous execution
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; thenRunAsync(Runnable action, Executor executor);
    ...
}</code></pre>
<p data-track="202"><strong>二.依赖两个CompletionStage任务都完成</strong></p>
<p data-track="203">runAfterBoth()方法接收一个CompletionStage任务。该方法要保证两个CompletionStage任务都完成，再执行指定的action。action执行完成后会返回一个新的没有返回值的CompletionStage对象。</p>
<pre class="highlighter-hljs"><code>public interface CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletionStage that, 
    //when this and the other given stage both complete normally, executes the given action.
    //@param other the other CompletionStage
    //@param action the action to perform before completing the returned CompletionStage
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other, Runnable action);

    //Returns a new CompletionStage that, 
    //when this and the other given stage complete normally, 
    //executes the given action using this stage's default asynchronous execution facility.
    //@param other the other CompletionStage
    //@param action the action to perform before completing the returned CompletionStage
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other, Runnable action);

    //Returns a new CompletionStage that, 
    //when this and the other given stage complete normally, 
    //executes the given action using the supplied executor.
    //@param other the other CompletionStage
    //@param action the action to perform before completing the returned CompletionStage
    //@param executor the executor to use for asynchronous execution
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other, Runnable action, Executor executor); 
    ...
}</code></pre>
<p data-track="205"><strong>三.依赖两个CompletionStage任务中的任何一个完成</strong></p>
<p data-track="206">runAfterEither()方法接收一个CompletionStage任务。它只需要保证两个任务中任意一个任务执行完成，即可执行指定的action，action执行完成后会返回一个新的没有返回值的CompletionStage对象。</p>
<pre class="highlighter-hljs"><code>public interface CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletionStage that, 
    //when either this or the other given stage complete normally, executes the given action.
    //@param other the other CompletionStage
    //@param action the action to perform before completing the returned CompletionStage
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other, Runnable action);

    //Returns a new CompletionStage that, 
    //when either this or the other given stage complete normally, 
    //executes the given action using this stage's default asynchronous execution facility.
    //@param other the other CompletionStage
    //@param action the action to perform before completing the returned CompletionStage
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other, Runnable action);

    //Returns a new CompletionStage that, 
    //when either this or the other given stage complete normally, 
    //executes the given action using the supplied executor.
    //@param other the other CompletionStage
    //@param action the action to perform before completing the returned CompletionStage
    //@param executor the executor to use for asynchronous execution
    //@return the new CompletionStage
    public CompletionStage&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other, Runnable action, Executor executor); 
    ...
}</code></pre>
<p data-track="208"><strong>(6)组合起来串行执行的方法</strong></p>
<p data-track="209">thenCompose()是多任务组合方法，它的作用是把两个CompletionStage任务进行组合达到串行执行的目的，也就是把第一个任务的执行结果作为参数传递给第二个任务执行。</p>
<p data-track="210">&nbsp;</p>
<p data-track="211">thenCompose()方法有点类似于thenCombine()方法，但thenCompose()方法中的两个任务存在先后关系，而thenCombine()方法中的两个任务是并行执行的。</p>
<pre class="highlighter-hljs"><code>public interface CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletionStage that, when this stage completes normally, 
    //is executed with this stage as the argument to the supplied function.
    //@param fn the function returning a new CompletionStage
    //@param &lt;U&gt; the type of the returned CompletionStage's result
    //@return the CompletionStage
    public &lt;U&gt; CompletionStage&lt;U&gt; thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn);

    //Returns a new CompletionStage that, when this stage completes normally, 
    //is executed using this stage's default asynchronous execution facility,
    //with this stage as the argument to the supplied function.
    //@param fn the function returning a new CompletionStage
    //@param &lt;U&gt; the type of the returned CompletionStage's result
    //@return the CompletionStage
    public &lt;U&gt; CompletionStage&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn);

    //Returns a new CompletionStage that, when this stage completes normally, 
    //is executed using the supplied Executor, 
    //with this stage's result as the argument to the supplied function.
    //@param fn the function returning a new CompletionStage
    //@param executor the executor to use for asynchronous execution
    //@param &lt;U&gt; the type of the returned CompletionStage's result
    //@return the CompletionStage
    public &lt;U&gt; CompletionStage&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor); 
    ...
}

public class ThenComposeExample {
    //下面使用supplyAsync()方法构建了一个异步带返回值的任务，返回值为"Compose Message"；
    //接着使用thenCompose()方法组合另外一个任务，并把前面任务的返回值r作为参数传递给第二个任务
    //在第二个任务中同样使用supplyAsync()方法构建了一个新的任务将参数r转为大写
    //最后thenCompose()方法返回一个新的没有返回值的CompletionStage对象
    public static void main(String[] args) {
        CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; "Compose Message");
        CompletableFuture&lt;String&gt; cf = task1.thenCompose(r -&gt; CompletableFuture.supplyAsync(() -&gt; r.toUpperCase()));
        System.out.println(cf.get());
      
        //或者采用Fluent风格来写
        //CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; "Compose Message")
        //     .thenCompose(r -&gt; CompletableFuture.supplyAsync(() -&gt; r.toUpperCase())
        //);
        //System.out.println(cf.get());
    }
}</code></pre>
<p data-track="213"><strong>(7)异常处理方法</strong></p>
<p data-track="214">上述介绍的方法都是CompletionStage任务正常执行时的处理方法。如果依赖的前一个任务出现异常，那么会导致后续的任务无法正常执行。比如下述代码，如果前置任务cf出现异常，那么会影响后置任务的执行。</p>
<pre class="highlighter-hljs"><code>public class RunAfterBothExample {
    public static void main(String[] args) {
        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; {
            throw new RuntimeException("Exception");
        }).runAfterBoth(CompletableFuture.supplyAsync(() -&gt; "Message"), () -&gt; {
            System.out.println("Done");
        });
        System.out.println(cf.get());
    }
}</code></pre>
<p data-track="216">CompletionStage提供了3类异常处理的方法。</p>
<p data-track="217">&nbsp;</p>
<p data-track="218"><strong>一.whenComplete()方法</strong></p>
<p data-track="219">whenComplete()这一组方法表示的是：不论前置的CompletionStage任务是正常执行结束还是出现异常，都能触发执行指定action，最后返回一个没返回值的CompletionStage对象。</p>
<pre class="highlighter-hljs"><code>public interface CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletionStage with the same result or exception as this stage, 
    //that executes the given action when this stage completes.
    //@param action the action to perform
    //@return the new CompletionStage
    public CompletionStage&lt;T&gt; whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action);

    //Returns a new CompletionStage with the same result or exception as this stage, 
    //that executes the given action using this stage's default asynchronous execution facility when this stage completes.
    //@param action the action to perform
    //@return the new CompletionStage
    public CompletionStage&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action);

    //Returns a new CompletionStage with the same result or exception as this stage, 
    //that executes the given action using the supplied Executor when this stage completes.
    //@param action the action to perform
    //@param executor the executor to use for asynchronous execution
    //@return the new CompletionStage
    public CompletionStage&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action, Executor executor); 
    ...
}</code></pre>
<p data-track="221"><strong>二.handle()方法</strong></p>
<p data-track="222">handle()这一组方法表示的是：不论前置的CompletionStage任务是正常执行结束还是出现异常，都会执行其中的函数fn，最后返回一个有返回值的CompletionStage对象。</p>
<pre class="highlighter-hljs"><code>public interface CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletionStage that, 
    //when this stage completes either normally or exceptionally, 
    //is executed with this stage's result and exception as arguments to the supplied function.
    //@param fn the function to use to compute the value of the returned CompletionStage
    //@param &lt;U&gt; the function's return type
    //@return the new CompletionStage
    public &lt;U&gt; CompletionStage&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);

    //Returns a new CompletionStage that, 
    //when this stage completes either normally or exceptionally, 
    //is executed using this stage's default asynchronous execution facility, 
    //with this stage's result and exception as arguments to the supplied function.
    //@param fn the function to use to compute the value of the returned CompletionStage
    //@param &lt;U&gt; the function's return type
    //@return the new CompletionStage
    public &lt;U&gt; CompletionStage&lt;U&gt; handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);

    //Returns a new CompletionStage that, 
    //when this stage completes either normally or exceptionally, 
    //is executed using the supplied executor, 
    //with this stage's result and exception as arguments to the supplied function.
    //@param fn the function to use to compute the value of the returned CompletionStage
    //@param executor the executor to use for asynchronous execution
    //@param &lt;U&gt; the function's return type
    //@return the new CompletionStage
    public &lt;U&gt; CompletionStage&lt;U&gt; handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor); 
    ...
}

public class HandleExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; {
            throw new RuntimeException("Exception");
        }).handleAsync((r, th) -&gt; {
           return th != null ? "出现异常" : "正常执行";
        });
        System.out.println(cf.get());
    }
}</code></pre>
<p data-track="224"><strong>三.exceptionally()方法</strong></p>
<p data-track="225">exceptionally()方法接收一个函数fn，当上一个CompletionStage任务出现异常时，会把该异常作为参数传递给fn，最后返回一个有返回值的CompletionStage对象。</p>
<pre class="highlighter-hljs"><code>public interface CompletionStage&lt;T&gt; {
    ...
    //Returns a new CompletionStage that, 
    //when this stage completes exceptionally, 
    //is executed with this stage's exception as the argument to the supplied function.
    //Otherwise, if this stage completes normally, 
    //then the returned stage also completes normally with the same value.
    //@param fn the function to use to compute the value of the returned CompletionStage if this CompletionStage completed exceptionally
    //@return the new CompletionStage
    public CompletionStage&lt;T&gt; exceptionally(Function&lt;Throwable, ? extends T&gt; fn);
    ...
}

public class ExceptionallyExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; {
            throw new RuntimeException("Exception");
        }).exceptionally(e -&gt; {
            log.error(e);
            return "ExceptionallyExample";
        });
        System.out.println(cf.get());
    }
}</code></pre>
<p data-track="227">&nbsp;</p>
<p data-track="228"><strong>6.CompletableFuture的实现原理分析</strong></p>
<p data-track="229"><strong>(1)CompletableFuture实现回调的例子</strong></p>
<p data-track="230"><strong>(2)CompletableFuture如何存储任务</strong></p>
<p data-track="231"><strong>(3)Completion的几个实现类</strong></p>
<p data-track="232"><strong>(4)Completion的栈结构存储回调任务</strong></p>
<p data-track="233"><strong>(5)Completion中的回调任务的执行和总结</strong></p>
<p data-track="234">&nbsp;</p>
<p data-track="235"><strong>(1)CompletableFuture实现回调的例子</strong></p>
<p data-track="236">CompletableFuture实现了Future接口和CompletionStage接口，CompletionStage接口为CompletableFuture提供了丰富的异步回调接口，CompletableFuture可以使用这些接口来实现复杂的异步计算工作。</p>
<p data-track="237">&nbsp;</p>
<p data-track="238">下面是一个使用CompletableFuture回调的例子。其中构建了两个CompletionStage任务，第一个任务是返回"thenAccept message"字符串，第二个任务是打印第一个任务的返回值。注意：Accept关键字有传参没有返回值，Run关键字没传参没返回值。</p>
<p data-track="239">&nbsp;</p>
<p data-track="240">这两个任务建立了串行执行的关系，第二个任务相当于第一个任务执行结束后的异步回调，并且多个CompletionStage任务可以使用链式风格串联。</p>
<pre class="highlighter-hljs"><code>public class CompletionStageExample {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        CompletableFuture&lt;Void&gt; cf = CompletableFuture.supplyAsync(() -&gt; "thenAccept message")
            .thenAcceptAsync((result) -&gt; {
                System.out.println("第一个异步任务的返回值：" + result);
            });
        cf.get();
    }
}</code></pre>
<p data-track="242"><strong>(2)CompletableFuture如何存储任务</strong></p>
<p data-track="243"><strong>一.CompletableFuture的成员变量</strong></p>
<p data-track="244">CompletableFuture的成员变量只有两个：result和stack。</p>
<pre class="highlighter-hljs"><code>public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; {
    ...
    //表示CompletionStage任务的返回结果或者一个异常的封装对象AltResult
    volatile Object result;//Either the result or boxed AltResult
    
    //表示依赖操作栈的栈顶，链式调用中传递的任务都会被压入这个stack中
    volatile Completion stack;//Top of Treiber stack of dependent actions
    ...
}</code></pre>
<p data-track="246"><strong>二.表示具体执行任务的Completion</strong></p>
<p data-track="247">成员变量stack是一个存储Completion对象的Treiber Stack结构，Treiber Stack是一种基于CAS机制实现的无锁并发栈。</p>
<p data-track="248">&nbsp;</p>
<p data-track="249">Completion表示一个具体的执行任务。每个回调任务都会封装成Completion对象，然后放入Treiber Stack中。Completion中的成员变量next保存了栈中的下一个回调任务。</p>
<pre class="highlighter-hljs"><code>public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; {
    ...
    abstract static class Completion extends ForkJoinTask&lt;Void&gt; implements Runnable, AsynchronousCompletionTask {
        volatile Completion next;//Treiber stack link

        //Performs completion action if triggered, returning a dependent that may need propagation, if one exists.
        //@param mode SYNC, ASYNC, or NESTED
        abstract CompletableFuture&lt;?&gt; tryFire(int mode);

        //Returns true if possibly still triggerable. Used by cleanStack.
        abstract boolean isLive();

        public final void run() {
            tryFire(ASYNC);
        }

        public final boolean exec() {
            tryFire(ASYNC);
            return true;
        }

        public final Void getRawResult() {
            return null;
        }

        public final void setRawResult(Void v) {
      
        }
    }
    ...
}</code></pre>
<p data-track="251"><strong>(3)Completion的几个实现类</strong></p>
<p data-track="252"><strong>一.UniCompletion</strong></p>
<p data-track="253">当使用如thenRun()、thenApply()等方法处理单个任务的，那么这些任务就会封装成UniCompletion对象。</p>
<p data-track="254">&nbsp;</p>
<p data-track="255"><strong>二.CoCompletion</strong></p>
<p data-track="256">当使用如thenCombine()、applyToEither()等方法处理两个任务的，那么这些任务会封装成CoCompletion对象。</p>
<p data-track="257">&nbsp;</p>
<p data-track="258"><strong>三.Signaller</strong></p>
<p data-track="259">当使用如get()、join()等方法处理任务时，那么调用方也会作为任务被封装成Signaller对象。</p>
<p data-track="260">&nbsp;</p>
<p data-track="261"><strong>(4)Completion的栈结构存储回调任务</strong></p>
<p data-track="262">以如下创建一个CompletableFuture任务为例，说明在CompletableFuture中是如何存储这些回调任务的。注意：该例子在Debug中没有发现baseFuture的成员变量stack的变化。</p>
<pre class="highlighter-hljs"><code>public class CompletionStackExample {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        //创建一个CompletableFuture任务对象
        CompletableFuture&lt;String&gt; baseFuture = CompletableFuture.supplyAsync(() -&gt; {
            try {
                System.out.println("开始执行入栈baseFuture的第一个异步任务");
                Thread.sleep(5000);
                System.out.println("第一个异步任务执行完毕");
            } catch (Exception e) {
            }
            return "BaseFuture";
        });
        System.out.println("主线程第一次打印");

        baseFuture.thenApply(r -&gt; {
            System.out.println("开始执行入栈baseFuture的第二个异步任务");
            try {
                Thread.sleep(5000);
                System.out.println("第二个异步任务执行完毕");
            } catch (Exception e) {
            }
            return "Then Apply";
        });//输出结果中没有"Then Apply"，因为没有任务使用"Then Apply"这个返回值
        System.out.println("主线程第二次打印");

        baseFuture.thenAccept(r -&gt; {
            System.out.println("开始执行入栈baseFuture的第三个异步任务");
            try {
                Thread.sleep(5000);
                System.out.println("第三个异步任务执行完毕: " + r);
            } catch (Exception e) {
            }
        }).thenAccept(Void -&gt; {
            System.out.println("baseFuture的第三个异步任务返回的新CompletableFuture，入栈第一个异步任务");
            try {
                Thread.sleep(5000);
                System.out.println("第三个异步任务的子任务执行完毕");
            } catch (Exception e) {
            }
        });
        System.out.println("主线程第三次打印");

        baseFuture.thenApply(r -&gt; {
            System.out.println("开始执行入栈baseFuture的第四个异步任务");
            try {
                Thread.sleep(5000);
                System.out.println("第四个异步任务执行完毕");
            } catch (Exception e) {
            }
            return "Apply Message";
        }).thenAccept(r -&gt; {
            System.out.println("baseFuture的第四个异步任务返回的新CompletableFuture，入栈第一个异步任务");
            try {
                Thread.sleep(5000);
                System.out.println("第四个异步任务的子任务执行完毕: " + r);
            } catch (Exception e) {
            }
        });

        System.out.println("主线程第四次打印");
        System.out.println("finish: " + baseFuture.get());
    }
    //输出的结果如下：
    //主线程第一次打印
    //开始执行入栈baseFuture的第一个异步任务
    //主线程第二次打印
    //主线程第三次打印
    //主线程第四次打印
    //第一个异步任务执行完毕
    //开始执行入栈baseFuture的第四个异步任务
    //开始执行入栈baseFuture的第三个异步任务
    //第四个异步任务执行完毕
    //第三个异步任务执行完毕: BaseFuture
    //baseFuture的第三个异步任务返回的新CompletableFuture，入栈第一个异步任务
    //baseFuture的第四个异步任务返回的新CompletableFuture，入栈第一个异步任务
    //第三个异步任务的子任务执行完毕
    //第四个异步任务的子任务执行完毕: Apply Message
    //开始执行入栈baseFuture的第二个异步任务
    //第二个异步任务执行完毕
    //finish: BaseFuture
}</code></pre>
<p data-track="264"><strong>一.第一阶段的Completion Stack结构</strong></p>
<p data-track="265">主线程第一次打印和第二次打印执行完成后，会创建如下图所示的结构。此时Completion类型是UniCompletion，因为thenApply()方法只接收一个任务。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/8fc2724e3fd44fffaba42c2ee8118aa9~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202502262341361806DA50A4974D62CFAF&amp;x-expires=2147483647&amp;x-signature=DzXf1ftEsu3kE8X74m1Y9NbaaG0%3D" data-ic="false" data-width="1080" data-height="484" data-ic-uri=""></div>
<p data-track="266"><strong>二.第二阶段的Completion Stack结构</strong></p>
<p data-track="267">主线程第三次打印执行完成后，就会创建如下图所示的结构。</p>
<p data-track="268">&nbsp;</p>
<p data-track="269">首先使用baseFuture.thenAccept()方法在baseFuture上增加一个回调，此时会把这个回调对应的Completion压入baseFuture的stack的栈顶。</p>
<p data-track="270">&nbsp;</p>
<p data-track="271">然后会产生一个新的CompletableFuture对象实例继续执行thenAccept()，由于这个新的CompletableFuture对象实例是在栈顶的Completion中产生的，因此在栈顶的Completion中会有一个dep属性指向这个新的对象实例。</p>
<p data-track="272">&nbsp;</p>
<p data-track="273">在新的CompletableFuture对象中又调用thenAccept()来构建一个回调任务，所以又会有一个新的Completion Stack结构。</p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/0fd74521d1f34e78aad01991cfb98871~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202502262341361806DA50A4974D62CFAF&amp;x-expires=2147483647&amp;x-signature=ikhiHa%2B5ENokdgvBYaHMmt2qXlk%3D" data-ic="false" data-width="1080" data-height="691" data-ic-uri=""></div>
<p data-track="274"><strong>三.第三阶段的Completion Stack结构</strong></p>
<p data-track="275">主线程第四次打印执行完成后，就会创建如下图所示的结构。</p>
<p data-track="276">&nbsp;</p>
<p data-track="277">首先是在baseFuture上使用thenApply()方法创建一个带有返回值的回调，这个回调对应的Completion同样会压入baseFuture的stack的栈顶。然后同样会创建一个新的CompletableFuture对象实例。接着在这个新的对象实例中继续使用thenAccept()方法添加另外一个回调，这个回调对应的Completion会压入新的CompletableFuture的stack的栈顶<strong>。</strong></p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/9af83d935209477a8baff8efab91da21~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202502262341361806DA50A4974D62CFAF&amp;x-expires=2147483647&amp;x-signature=719RHnPS2if6er5mRKZJ%2BprI27U%3D" data-ic="false" data-width="1080" data-height="739" data-ic-uri=""></div>
<p data-track="278"><strong>(5)Completion中的回调任务的执行和总结</strong></p>
<p data-track="279">从Completion Stack的栈顶中逐个出栈来执行。</p>
<p data-track="280">&nbsp;</p>
<p data-track="281">如果当前出栈的Completion存在一个子Completion Stack，那么就优先执行这一条链路的Completion任务。</p>
<p data-track="282">&nbsp;</p>
<p data-track="283">CompletableFuture中的回调任务，是基于Completion来实现的。针对CompletionStage中不同类型的方法，Completion有不同的子类处理。</p>
<p data-track="284">&nbsp;</p>
<p data-track="285">Completion表示一个具体的回调任务，这些Completion采用了一种Treiber Stack结构来存储。由于每个Completion都可能会产生新的CompletableFuture，所以整个结构看起来像一棵很深的树。</p>
<p data-track="286">&nbsp;</p>
<p data-track="287"><strong>7.CompletableFuture的核心源码分析</strong></p>
<p data-track="288"><strong>(1)CompletableFuture的核心源码</strong></p>
<p data-track="289"><strong>(2)CompletableFuture对象的创建</strong></p>
<p data-track="290"><strong>(3)Completion Stack的构建</strong></p>
<p data-track="291"><strong>(4)Completion任务的执行流程</strong></p>
<p data-track="292"><strong>(5)Completion任务的执行结果获取</strong></p>
<p data-track="293"><strong>(6)总结</strong></p>
<p data-track="294">&nbsp;</p>
<p data-track="295"><strong>(1)CompletableFuture的核心源码</strong></p>
<p data-track="296">CompletableFuture的源码主要分四部分：</p>
<p data-track="297">一.CompletableFuture对象的创建</p>
<p data-track="298">二.Completion Stack的构建</p>
<p data-track="299">三.get()方法获取任务处理结果时阻塞和唤醒线程</p>
<p data-track="300">四.当前置任务执行完成后，Completion Stack的执行流程</p>
<p data-track="301">&nbsp;</p>
<p data-track="302"><strong>(2)CompletableFuture对象的创建</strong></p>
<p data-track="303">假设使用supplyAsync()方法来创建一个CompletableFuture对象。那么在执行supplyAsync()方法时触发调用的asyncSupplyStage()方法中，便会使用线程池来执行一个由AsyncSupply()构造方法构建的任务，这个线程池默认情况下是由ForkJoinPool的commonPool()方法返回的。</p>
<p data-track="304">&nbsp;</p>
<p data-track="305">当线程池执行由AsyncSupply()构造方法构建的任务时，会调用AsyncSupply的run()方法来执行具体的任务。</p>
<p data-track="306">&nbsp;</p>
<p data-track="307">在AsyncSupply的run()方法中：首先会使用f.get()来获得Supplier这个函数式接口的执行结果，然后通过执行CompletableFuture的completeValue()方法，把执行结果通过CAS设置到CompletableFuture的成员变量result中。最后调用CompletableFuture的postComplete()方法表示执行完成，该postComplete()方法会执行Completion Stack中的所有回调任务。</p>
<pre class="highlighter-hljs"><code>//Represents a supplier of results.
//There is no requirement that a new or distinct result be returned each time the supplier is invoked.
//This is a functional interface whose functional method is get().
//@param &lt;T&gt; the type of results supplied by this supplier
@FunctionalInterface
public interface Supplier&lt;T&gt; {
    //Gets a result.
    //@return a result
    T get();
}

public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; {
    volatile Object result;       // Either the result or boxed AltResult
    volatile Completion stack;    // Top of Treiber stack of dependent actions
    
    //Returns a new CompletableFuture that is asynchronously completed by a task 
    //running in the ForkJoinPool#commonPool() with the value obtained by calling the given Supplier.
    //@param supplier a function returning the value to be used to complete the returned CompletableFuture
    //@param &lt;U&gt; the function's return type
    //@return the new CompletableFuture
    public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) {
        return asyncSupplyStage(asyncPool, supplier);
    }
    
    static &lt;U&gt; CompletableFuture&lt;U&gt; asyncSupplyStage(Executor e, Supplier&lt;U&gt; f) {
        if (f == null) throw new NullPointerException();
        CompletableFuture&lt;U&gt; d = new CompletableFuture&lt;U&gt;();
        //使用线程池来执行一个由AsyncSupply()方法构建的任务
        e.execute(new AsyncSupply&lt;U&gt;(d, f));
        //返回一个新的CompletableFuture对象
        return d;
    }
    
    static final class AsyncSupply&lt;T&gt; extends ForkJoinTask&lt;Void&gt; implements Runnable, AsynchronousCompletionTask {
        CompletableFuture&lt;T&gt; dep;
        Supplier&lt;T&gt; fn;
        AsyncSupply(CompletableFuture&lt;T&gt; dep, Supplier&lt;T&gt; fn) {
            this.dep = dep;
            this.fn = fn;
        }
       
        public final Void getRawResult() {
            return null;
        }
        public final void setRawResult(Void v) {
            
        }
        public final boolean exec() {
            run();
            return true;
        }
       
        public void run() {
            CompletableFuture&lt;T&gt; d;
            Supplier&lt;T&gt; f;
            if ((d = dep) != null &amp;&amp; (f = fn) != null) {
                dep = null; fn = null;
                if (d.result == null) {
                    try {
                        //首先使用f.get()来获得Supplier这个函数式接口中的执行结果
                        //然后通过执行CompletableFuture的completeValue()方法，
                        //把执行结果设置到CompletableFuture的成员变量result中；
                        d.completeValue(f.get());
                    } catch (Throwable ex) {
                        d.completeThrowable(ex);
                    }
                }
                //最后调用CompletableFuture的postComplete()方法执行Completion Stack中的所有回调任务
                d.postComplete();
            }
        }
    }
    
    //Completes with a non-exceptional result, unless already completed.
    final boolean completeValue(T t) {
        return UNSAFE.compareAndSwapObject(this, RESULT, null, (t == null) ? NIL : t);
    }
    
    //Pops and tries to trigger all reachable dependents. Call only when known to be done.
    final void postComplete() {
        //On each step, variable f holds current dependents to pop and run.  
        //It is extended along only one path at a time, pushing others to avoid unbounded recursion.
        CompletableFuture&lt;?&gt; f = this;
        Completion h;
        while ((h = f.stack) != null || (f != this &amp;&amp; (h = (f = this).stack) != null)) {
            CompletableFuture&lt;?&gt; d;
            Completion t;
            if (f.casStack(h, t = h.next)) {
                if (t != null) {
                    if (f != this) {
                        pushStack(h);
                        continue;
                    }
                    h.next = null;    // detach
                }
                f = (d = h.tryFire(NESTED)) == null ? this : d;
            }
        }
    }
    
    private static final sun.misc.Unsafe UNSAFE;
    private static final long RESULT;
    private static final long STACK;
    private static final long NEXT;
    static {
        try {
            final sun.misc.Unsafe u;
            UNSAFE = u = sun.misc.Unsafe.getUnsafe();
            Class&lt;?&gt; k = CompletableFuture.class;
            RESULT = u.objectFieldOffset(k.getDeclaredField("result"));
            STACK = u.objectFieldOffset(k.getDeclaredField("stack"));
            NEXT = u.objectFieldOffset(Completion.class.getDeclaredField("next"));
        } catch (Exception x) {
            throw new Error(x);
        }
    }
    ...
}</code></pre>
<p data-track="309"><strong>(3)Completion Stack的构建</strong></p>
<p data-track="310">假设已经使用了CompletableFuture的supplyAsync()方法创建了源任务，接着需要使用CompletionStage的thenApply()等方法来构建回调任务。</p>
<p data-track="311">&nbsp;</p>
<p data-track="312">源任务 -&gt; Supplier接口的实现类对象(get()方法)，回调任务 -&gt; Function接口的实现类对象(apply()方法)。</p>
<p data-track="313">&nbsp;</p>
<p data-track="314">CompletableFuture的thenApply()方法会触发执行uniApplyStage()方法。在uniApplyStage()方法中，首先会创建一个新的CompletableFuture对象，然后根据CompletableFuture的uniApply()方法判断源任务是否已经完成。如果源任务已经完成，则不需要入栈，直接执行回调任务的apply()方法。如果源任务还没执行完成，才将回调任务封装为UniApply对象并入栈。</p>
<p data-track="315">&nbsp;</p>
<p data-track="316">源任务还没执行完成的处理过程具体如下：首先把回调任务封装成一个UniApply对象，然后调用CompletableFuture的push()方法，把UniApply对象压入源任务所在CompletableFuture对象中的stack的栈顶，最后调用UniApply的tryFire()方法来尝试执行该回调任务。</p>
<p data-track="317">&nbsp;</p>
<p data-track="318">注意：UniApply对象其实是一个Completion对象，因为UniApply类继承自UniCompletion类，而UniCompletion类又继承自Completion类。</p>
<pre class="highlighter-hljs"><code>//Represents a function that accepts one argument and produces a result.
//This is a functional interface whose functional method is apply(Object).
//@param &lt;T&gt; the type of the input to the function
//@param &lt;R&gt; the type of the result of the function
@FunctionalInterface
public interface Function&lt;T, R&gt; {
    //Applies this function to the given argument.
    //@param t the function argument
    //@return the function result
    R apply(T t);
    ...
}
    
public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; {
    volatile Object result;       // Either the result or boxed AltResult
    volatile Completion stack;    // Top of Treiber stack of dependent actions
    
    public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn) {
        return uniApplyStage(null, fn);
    }
    
    private &lt;V&gt; CompletableFuture&lt;V&gt; uniApplyStage(Executor e, Function&lt;? super T,? extends V&gt; f) {
        if (f == null) throw new NullPointerException();
        //创建一个新的CompletableFuture对象
        CompletableFuture&lt;V&gt; d =  new CompletableFuture&lt;V&gt;();
        //根据CompletableFuture的uniApply()方法判断源任务是否已经完成
        //如果源任务已经完成，则不需要入栈
        if (e != null || !d.uniApply(this, f, null)) {
            //首先把回调任务f封装成一个UniApply对象
            UniApply&lt;T,V&gt; c = new UniApply&lt;T,V&gt;(e, d, this, f);
            //然后调用CompletableFuture的push()方法
            //把UniApply对象压入源任务所在的CompletableFuture对象中的stack的栈顶
            push(c);
            //最后调用UniApply的tryFire()方法来尝试执行该回调任务
            c.tryFire(SYNC);
        }
        return d;
    }
    
    final &lt;S&gt; boolean uniApply(CompletableFuture&lt;S&gt; a, Function&lt;? super S,? extends T&gt; f, UniApply&lt;S,T&gt; c) { 
        Object r;
        Throwable x;
        //如果任务还没完成(result == null)，直接返回false
        if (a == null || (r = a.result) == null || f == null) {
            return false;
        }
        tryComplete: if (result == null) {
            //判断result是否为异常类型
            if (r instanceof AltResult) {
                if ((x = ((AltResult)r).ex) != null) {
                    //如果result是异常类型，则使用completeThrowable()方法处理，并返回true
                    completeThrowable(x, r);
                    break tryComplete;
                }
                r = null;
            }
            //如果result不为空，任务已经执行完成，并且没有出现异常
            try {
                if (c != null &amp;&amp; !c.claim()) {
                    return false;
                }
                //把源任务的执行结果s作为参数传给回调任务f
                //直接执行回调任务的apply()方法，并将结果设置到CompletableFuture对象的成员变量result中
                @SuppressWarnings("unchecked") S s = (S) r;
                completeValue(f.apply(s)); 
            } catch (Throwable ex) {
                completeThrowable(ex);
            }
        }
        return true;
    }
    
    //Pushes the given completion (if it exists) unless done.
    final void push(UniCompletion&lt;?,?&gt; c) {
        if (c != null) {
            while (result == null &amp;&amp; !tryPushStack(c)) {
                lazySetNext(c, null); // clear on failure
            }
        }
    }
    
    final boolean tryPushStack(Completion c) {
        Completion h = stack;
        lazySetNext(c, h);
        return UNSAFE.compareAndSwapObject(this, STACK, h, c);
    }
    
    static void lazySetNext(Completion c, Completion next) {
        UNSAFE.putOrderedObject(c, NEXT, next);
    }
    
    ...
    
    static final class UniApply&lt;T,V&gt; extends UniCompletion&lt;T,V&gt; {
        Function&lt;? super T,? extends V&gt; fn;
        UniApply(Executor executor, CompletableFuture&lt;V&gt; dep, CompletableFuture&lt;T&gt; src, Function&lt;? super T,? extends V&gt; fn) {
            super(executor, dep, src);
            this.fn = fn;
        }
        //尝试执行当前CompletableFuture中的Completion
        final CompletableFuture&lt;V&gt; tryFire(int mode) {
            CompletableFuture&lt;V&gt; d;
            CompletableFuture&lt;T&gt; a;
            //执行CompletableFuture的uniApply()方法尝试执行回调任务
            if ((d = dep) == null || !d.uniApply(a = src, fn, mode &gt; 0 ? null : this)) {
                return null;
            }
            dep = null;
            src = null;
            fn = null;
            //执行CompletableFuture的postFire()方法
            return d.postFire(a, mode);
        }
    }
    
    final CompletableFuture&lt;T&gt; postFire(CompletableFuture&lt;?&gt; a, int mode) {
        if (a != null &amp;&amp; a.stack != null) {
            if (mode &lt; 0 || a.result == null) {
                a.cleanStack();
            } else {
                a.postComplete();
            }
        }
        if (result != null &amp;&amp; stack != null) {
            if (mode &lt; 0) {
                return this;
            } else {
                postComplete();
            }
        }
        return null;
    }
    
    abstract static class UniCompletion&lt;T,V&gt; extends Completion {
        Executor executor;//执行当前任务的线程池
        CompletableFuture&lt;V&gt; dep;//构建当前任务的CompletableFuture对象
        CompletableFuture&lt;T&gt; src;//指向源任务

        UniCompletion(Executor executor, CompletableFuture&lt;V&gt; dep, CompletableFuture&lt;T&gt; src) {
            this.executor = executor;
            this.dep = dep;
            this.src = src;
        }

        //判断是否使用单独的线程池来执行任务
        final boolean claim() {
            Executor e = executor;
            if (compareAndSetForkJoinTaskTag((short)0, (short)1)) {
                if (e == null) {
                    return true;
                }
                executor = null; // disable
                e.execute(this);
            }
            return false;
        }
        //判断任务是否存活
        final boolean isLive() {
            return dep != null;
        }
    }
}</code></pre>
<p data-track="320"><strong>(4)Completion任务的执行流程</strong></p>
<p data-track="321"><strong>一.CompletableFuture的postComplete()方法</strong></p>
<p data-track="322">CompletableFuture中的任务完成后即源任务完成后，会通过CompletableFuture.postComplete()方法来完成后置逻辑，也就是把当前CompletableFuture.stack中存储的Completion逐项出栈执行。</p>
<p data-track="323">&nbsp;</p>
<p data-track="324">postComplete()方法会触发stack中所有可执行的回调任务Completion，该方法会遍历整个stack，并通过Completion任务的tryFire()方法来尝试执行。</p>
<pre class="highlighter-hljs"><code>public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; {
    volatile Object result;
    volatile Completion stack;
    
    public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) {
        return asyncSupplyStage(asyncPool, supplier);
    }
    
    static &lt;U&gt; CompletableFuture&lt;U&gt; asyncSupplyStage(Executor e, Supplier&lt;U&gt; f) {
        if (f == null) throw new NullPointerException();
        CompletableFuture&lt;U&gt; d = new CompletableFuture&lt;U&gt;();
        //使用线程池来执行一个由AsyncSupply()方法构建的任务
        e.execute(new AsyncSupply&lt;U&gt;(d, f));
        //返回一个新的CompletableFuture对象
        return d;
    }
    
    static final class AsyncSupply&lt;T&gt; extends ForkJoinTask&lt;Void&gt; implements Runnable, AsynchronousCompletionTask {
        CompletableFuture&lt;T&gt; dep;
        Supplier&lt;T&gt; fn;
        AsyncSupply(CompletableFuture&lt;T&gt; dep, Supplier&lt;T&gt; fn) {
            this.dep = dep;
            this.fn = fn;
        }
        ...
        public void run() {
            CompletableFuture&lt;T&gt; d;
            Supplier&lt;T&gt; f;
            if ((d = dep) != null &amp;&amp; (f = fn) != null) {
                dep = null; fn = null;
                if (d.result == null) {
                    try {
                        //首先使用f.get()来获得Supplier这个函数式接口中的执行结果
                        //然后通过执行CompletableFuture的completeValue()方法，
                        //把执行结果设置到CompletableFuture的成员变量result中；
                        d.completeValue(f.get());
                    } catch (Throwable ex) {
                        d.completeThrowable(ex);
                    }
                }
                //最后调用CompletableFuture的postComplete()方法执行Completion Stack中的所有回调任务
                d.postComplete();
            }
        }
    }
    
    final boolean completeValue(T t) {
        return UNSAFE.compareAndSwapObject(this, RESULT, null, (t == null) ? NIL : t);
    }
    
    final void postComplete() {
        CompletableFuture&lt;?&gt; f = this;
        Completion h;
        //如果stack不为空，则不断循环从stack中出栈Completion任务
        while ((h = f.stack) != null || (f != this &amp;&amp; (h = (f = this).stack) != null)) {
            CompletableFuture&lt;?&gt; d;
            Completion t;
            //通过CAS逐个取出stack中的Completion任务并重置stack
            if (f.casStack(h, t = h.next)) {
                if (t != null) {
                    //表示h.tryFire()返回了另外一个CompleableFuture对象
                    if (f != this) {
                        pushStack(h);
                        continue;
                    }
                    h.next = null;    // detach
                }
                //执行指定Completion的tryFire()方法，比如UniApply.tryFire()方法
                f = (d = h.tryFire(NESTED)) == null ? this : d;
            }
        }
    }
    ...
}</code></pre>
<p data-track="326">二.<strong>Completion任务的执行流程图</strong></p>
<div class="pgc-img"><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/519d9425670e404b8208b2fc98af02dd~tplv-obj.image?lk3s=ef143cfe&amp;traceid=202502262341361806DA50A4974D62CFAF&amp;x-expires=2147483647&amp;x-signature=yQUcvoFwhLPEBXeJ0EN8%2FGYvT98%3D" data-ic="false" data-width="1080" data-height="964" data-ic-uri=""></div>
<p data-track="327"><strong>(5)Completion任务的执行结果获取</strong></p>
<p data-track="328">可以通过get()或join()方法获取CompletableFuture的执行结果。当任务还没执行结束时(r == null)，则调用waitingGet()方法进行阻塞等待。主要会先自旋256次判断执行是否结束，如果不是才挂起线程进行阻塞，从而避免直接挂起线程带来的性能开销。</p>
<pre class="highlighter-hljs"><code>public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; {
    ...
    //Waits if necessary for this future to complete, and then returns its result.
    public T get() throws InterruptedException, ExecutionException {
        Object r;
        return reportGet((r = result) == null ? waitingGet(true) : r);
    }
    
    //Returns raw result after waiting, or null if interruptible and interrupted.
    private Object waitingGet(boolean interruptible) {
        Signaller q = null;
        boolean queued = false;
        int spins = -1;
        Object r;
        while ((r = result) == null) {
            if (spins &lt; 0) {
                spins = (Runtime.getRuntime().availableProcessors() &gt; 1) ? 1 &lt;&lt; 8 : 0;
            } else if (spins &gt; 0) {
                if (ThreadLocalRandom.nextSecondarySeed() &gt;= 0) {
                    --spins;
                }
            } else if (q == null) {
                q = new Signaller(interruptible, 0L, 0L);
            } else if (!queued) {
                queued = tryPushStack(q);
            } else if (interruptible &amp;&amp; q.interruptControl &lt; 0) {
                q.thread = null;
                cleanStack();
                return null;
            } else if (q.thread != null &amp;&amp; result == null) {
                try {
                    ForkJoinPool.managedBlock(q);
                } catch (InterruptedException ie) {
                    q.interruptControl = -1;
                }
            }
        }
        if (q != null) {
            q.thread = null;
            if (q.interruptControl &lt; 0) {
                if (interruptible) {
                    r = null; // report interruption
                } else {
                    Thread.currentThread().interrupt();
                }
            }
        }
        postComplete();
        return r;
    }
    ...
}</code></pre>
<p data-track="330"><strong>(6)总结</strong></p>
<p data-track="331">CompletableFuture的核心在于CompletionStage，CompletionStage提供了最基础的异步回调机制。也就是主线程不需要通过阻塞方式来等待异步任务的执行结果，而是当异步任务执行完成后主动通知来触发执行下一个任务。此外，CompletionStage全部采用了函数式接口的方式来实现，可以通过链式的方式来对多个CompletionStage进行组合。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.025335627903935187" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-26 23:43">2025-02-26 23:43</span>&nbsp;
<a href="https://www.cnblogs.com/mjunz">东阳马生架构</a>&nbsp;
阅读(<span id="post_view_count">3</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18740060" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18740060);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18740060', targetLink: 'https://www.cnblogs.com/mjunz/p/18740060', title: 'JUC并发—14.Future模式和异步编程分析' })">举报</a>
</div>
        