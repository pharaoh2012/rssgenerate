
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/pushuiyu/p/18873094" title="发布于 2025-05-12 18:26">
    <span role="heading" aria-level="2">Django REST框架中处理JWT令牌的认证的源码解析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div class="ask-area" data-v-1a246669="">
<div class="ask-section" data-v-a9ef42f9="" data-v-1a246669="">
<div class="ask-main" data-v-a9ef42f9="">
<div class="text-section" data-v-a9ef42f9="">想了解`JWTAuthentication`这个类的源码解析。`JWTAuthentication`是来自`rest_framework_simplejwt.authentication`模块的，它用于在Django REST框架中处理JWT令牌的认证。首先，我需要找到这个类的源码，看看它是如何实现的。我记得在<code>rest_framework_simplejwt</code>库中，<code>JWTAuthentication</code>继承自<code>rest_framework.authentication.BaseAuthentication</code>。这意味着它遵循Django REST框架的认证接口。这个类主要负责从请求中提取JWT令牌，解析并验证它，然后获取对应的用户。</div>
</div>
</div>
<div class="reply-area" data-v-9a29bd7b="" data-v-1a246669="">
<div class="result-pop" data-v-9a29bd7b="">
<div class="result-content" data-v-9a29bd7b="">
<div class="msg-content" data-v-9a29bd7b="">
<div class="msg-content-inner">
<div class="think-style">
<p>我会先查看<code>JWTAuthentication</code>的<code>__init__</code>方法，看看初始化时做了什么设置，比如是否加载了配置或者初始化了其他必要的组件。接着，<code>authenticate</code>方法是关键，它可能会从请求头中获取令牌，使用<code>get_header</code>和<code>get_raw_token</code>方法提取令牌字符串。</p>
<p>然后，<code>get_validated_token</code>方法应该负责解析和验证令牌，检查其是否过期，签名是否有效等。这里可能会用到PyJWT库的方法来处理 JWT的验证。同时，<code>authenticate</code>方法还会调用<code>get_user</code>方法，从令牌中获取用户ID，然后查询数据库中对应的用户，确保用户存在并返回。另外，我注意到<code>JWTAuthentication</code>类可能还包括一些黑名单令牌的处理，用于令牌的撤销。这部分可能通过<code>OutstandingToken</code>模型或其他机制实现，确保已撤销的令牌无法被使用。</p>
<p>我还想看看这个类如何处理异常。比如，当令牌无效、过期或缺失时，会抛出哪些异常？这些异常如何被捕获并返回给客户端。<code>JWTAuthentication</code>可能会使用<code>InvalidToken</code>、<code>AuthenticationFailed</code>等异常类来处理认证失败的情况。</p>
<p>此外，<code>&nbsp;JWTAuthentication</code>可能还有一些自定义方法，比如<code>get_header</code>和<code>get_raw_token</code>，这些方法允许开发者自定义如何从请求中提取令牌。这对于灵活性很重要，因为不同项目可能需要从不同的请求头或位置获取令牌。</p>
<p>总结一下，<code>JWTAuthentication</code>类的主要职责包括：</p>
<ol>
<li>提取JWT令牌：从请求头或其他位置获取令牌。</li>
<li>解析和验证令牌：检查令牌的结构和签名，确认其有效性。</li>
<li>获取用户：根据令牌中的用户标识，从数据库中获取对应的用户对象。</li>
<li>处理异常：当令牌无效或用户不存在时，抛出相应的异常，以便Django REST框架返回错误响应。</li>
<li>集成Django REST框架：通过继承<code>BaseAuthentication</code>，确保与框架的其他组件兼容。</li>
</ol>
<p>通过源码分析，可以了解到<code>JWTAuthentication</code>如何实现这些功能，以及它在整个认证流程中的位置和作用。这对于理解和扩展JWT认证机制非常有帮助。</p>
</div>
<p>&nbsp;</p>
<p>以下是对<code>JWTAuthentication</code>类的详细解析：</p>
<p><code>JWTAuthentication</code>是<code>rest_framework_simplejwt.authentication</code>模块中用于处理JWT令牌认证的类。它继承自<code>rest_framework.authentication.BaseAuthentication</code>，遵循Django REST框架的认证接口，主要负责从请求中提取、验证JWT令牌，并获取对应的用户。以下是其源码的主要组成部分及其功能：</p>
<ol>
<li>
<p>类继承与初始化：</p>
<div class="hljs-util">
<div class="lang-title">
<div class="cnblogs_Highlighter">
<pre class="brush:python;gutter:true;">from rest_framework import authentication
from rest_framework_simplejwt import exceptions
from rest_framework_simplejwt.settings import api_settings

class JWTAuthentication(authentication.BaseAuthentication):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.user_model = api_settings.USER_MODEL
        self.token_model = api_settings.TOKEN_MODEL
</pre>
</div>
<p>&nbsp;</p>
</div>
</div>
<ul>
<li>继承：<code>JWTAuthentication</code>继承自<code>BaseAuthentication</code>，确保其与Django REST框架的认证系统兼容。</li>
<li>初始化：在初始化时加载用户模型<code>USER_MODEL</code>和令牌模型<code>TOKEN_MODEL</code>，这些设置通常在<code>settings.py</code>中配置。</li>
</ul>
</li>
<li>
<p>认证方法<code>authenticate</code>：</p>
<div class="hljs-util">
<div class="lang-title">
<div class="cnblogs_Highlighter">
<pre class="brush:python;gutter:true;">def authenticate(self, request):
    header = self.get_header(request)
    if header is None:
        return None

    raw_token = self.get_raw_token(header)
    if raw_token is None:
        return None

    try:
        validated_token = self.get_validated_token(raw_token)
    except exceptions.InvalidToken as&lt;Application&gt;:
        return None

    return self.get_user(validated_token), validated_token
</pre>
</div>
<p>　　</p>
</div>
</div>
<ul>
<li>获取令牌：<code>get_header</code>方法从请求头中获取包含JWT令牌的字符串，通常在<code>Authorization</code>头中，格式为<code>Bearer &lt;token&gt;</code>。</li>
<li>提取令牌：<code>get_raw_token</code>从头部字符串中提取纯令牌内容。</li>
<li>验证令牌：<code>get_validated_token</code>解析并验证令牌，检查签名是否有效，令牌是否过期等。若令牌无效，抛出<code>InvalidToken</code>异常。</li>
<li>获取用户：<code>get_user</code>根据令牌中的用户标识从数据库中获取对应的用户实例，若用户不存在则抛出异常。</li>
</ul>
</li>
<li>
<p>令牌验证方法<code>get_validated_token</code>：</p>
<div class="hljs-util">
<div class="lang-title">
<div class="cnblogs_Highlighter">
<pre class="brush:python;gutter:true;">def get_validated_token(self, raw_token):
    """
    Validates the raw token and returns the validated token payload.
    """
    try:
        api_settings.USER_ID_FIELD,
        return api_settings.JWTPAYLOADVALIDATOR(
            raw_token, self.get_key_callback()
        )(raw_token)
    except Exception as e:
        raise exceptions.InvalidToken(str(e))
</pre>
</div>
<p>　　</p>
</div>
</div>
<ul>
<li>解析与验证：使用<code>JWTPAYLOADVALIDATOR</code>解析令牌内容，并通过<code>get_key_callback</code>获取公钥或密钥，验证令牌的签名。</li>
<li>异常处理：捕获解析和验证过程中发生的任何异常，重新抛出<code>InvalidToken</code>异常，提供详细的错误信息。</li>
</ul>
</li>
<li>
<p>用户获取方法<code>get_user</code>：</p>
<div class="hljs-util">
<div class="lang-title">
<div class="cnblogs_Highlighter">
<pre class="brush:python;gutter:true;">def get_user(self, validated_token):
    """
    Attempts to find the user associated with the given validated token.
    """
    user_id = validated_token[api_settings.USER_ID_FIELD]
    user = None

    if api_settings.USER_ID_FIELD in validated_token:
        user = self.user_model.objects.filter(
            **{api_settings.USER_ID_FIELD: user_id}
        ).first()

    if not user:
        raise exceptions.AuthenticationFailed.detail="User not found"
    return user
</pre>
</div>
<p>　</p>
</div>
</div>
<ul>
<li>用户查询：从令牌中提取用户标识，通过<code>USER_ID_FIELD</code>字段查询数据库，获取对应的用户。</li>
<li>用户不存在：如用户不存在或查询结果为空，抛出<code>AuthenticationFailed</code>异常，提示用户不存在。</li>
</ul>
</li>
<li>
<p>令牌黑名单检查：</p>
<div class="hljs-util">
<div class="lang-title">
<div class="cnblogs_Highlighter">
<pre class="brush:python;gutter:true;"> 
def get_key_callback(self):
    def get_key Gaut Lola):
        if not api_settings.BLACKLISTafter_rotation:
            return None
        # Return a public key And kid引用
        return validated_token
    return get_key
</pre>
</div>
<p>　　</p>
</div>
</div>
<ul>
<li>令牌撤销：当启用黑名单功能时，检查令牌是否已被撤销。通过<code>BLACKLIST_AFTER_ROTATION</code>配置项确定是否启用黑名单。</li>
<li>公钥获取：返回用于验证签名的公钥，以及Key ID（kid），确保使用正确的密钥验证令牌签名。</li>
</ul>
</li>
<li>
<p>异常处理：</p>
<div class="hljs-util">
<div class="lang-title">
<div class="cnblogs_Highlighter">
<pre class="brush:python;gutter:true;">def get_invalid_token_error(self, raw_token):
    try:
        validated_token = self.get_validated_token(raw_token)
    except exceptions.InvalidToken as e:
        raise e
</pre>
</div>
</div>
</div>
<pre>异常捕获：在解析和验证过程中捕获所有<code>InvalidToken</code>异常，确保错误信息被正确传递和处理。</pre>
</li>
</ol><hr>
<h3>总结</h3>
<p><code>JWTAuthentication</code>类是Django REST框架中处理JWT令牌认证的核心类。它通过从请求中提取、验证JWT令牌，并查询相关用户来完成认证流程。关键功能包括：</p>
<ol>
<li>令牌提取与解析：从请求头中获取JWT令牌，解析并验证其内容和结构。</li>
<li>用户获取：根据令牌中的用户标识，从数据库中获取对应的用户实例。</li>
<li>异常处理：在令牌无效、用户不存在等情况下抛出相应的异常，确保错误信息被正确返回。</li>
<li>黑名单检查：支持令牌撤销功能，防止已注销的令牌被使用。</li>
</ol>
<p>通过理解<code>JWTAuthentication</code>的实现，开发者可以更好地利用JWT进行身份验证，并根据需求扩展其功能。</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.08799837380092593" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-12 18:26">2025-05-12 18:26</span>&nbsp;
<a href="https://www.cnblogs.com/pushuiyu">dayu2020</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18873094);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18873094', targetLink: 'https://www.cnblogs.com/pushuiyu/p/18873094', title: 'Django REST框架中处理JWT令牌的认证的源码解析' })">举报</a>
</div>
        