
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/rust-tech/p/18994661" title="发布于 2025-07-20 21:31">
    <span role="heading" aria-level="2">Rust从入门到精通03-变量</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="1变量声明语法">1、变量声明语法</h3>
<p>Rust 变量必须先声明，后使用。</p>
<p>对于局部变量，常见是声明语法为：</p>
<blockquote>
<p>let variable : i32 = 100;</p>
</blockquote>
<p>由于 Rust 是有自动推导类型功能的，所以后面的 ：i32 是可以省略的。</p>
<h4 id="11-语法解析更容易">1.1 语法解析更容易</h4>
<p>局部变量声明一定是以 let 开头，类型一定是跟在冒号 : 的后面。语法歧义更少，语法分析器更容易编写。</p>
<h4 id="12-方便引入类型推导功能">1.2 方便引入类型推导功能</h4>
<p>Rust 声明变量的特点：要声明的变量前置，类型描述后置。<br>
这是因为在变量声明语句中，最重要的是变量本身，而类型其实是个附属的额外描述，并非必不可少的部分。如果我们可以通过上下文环境由编译器自动分析出这个变量的类型，那么这个类型描述完全可以省略不写。</p>
<p>PS：Rust 支持类型推导，在编译器能够推导类型的情况下，变量类型一般可以省略，但常量（const）和静态变量（static）必须声明类型。</p>
<p>Rust 从一开始就考虑了类型自动推导功能，因此类型后置的语法更加合适。</p>
<h4 id="13-模式解构">1.3 模式解构</h4>
<p><code>let</code> 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：</p>
<pre><code class="language-rust">fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
</code></pre>
<h3 id="2变量命名规则">2、变量命名规则</h3>
<p>Rust 里的合法标识符（包括变量名、函数名、trait名等）必须由：<br>
①、数字<br>
②、字母<br>
③、下划线<br>
注意：不能以数字开头！！！</p>
<p>另外：要注意下划线 _ 的特殊用法。 如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，为了去掉这个警告，可以用下划线用作变量的开头。</p>
<pre><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre>
<p>运行发现只有变量 y 提示警告了。</p>
<p><img alt="" loading="lazy" data-src="https://itcoke-pic.oss-cn-hangzhou.aliyuncs.com/202312/image-03-06.png" class="lazyload"></p>
<h3 id="3变量遮蔽">3、变量遮蔽</h3>
<p>Rust 允许在同一个代码块中声明同样名字的变量，后面声明的变量会将前面声明的变量“遮蔽”起来。</p>
<pre><code class="language-rust">//变量遮蔽
fn variable_masking(){
    let x = "123";
    println!("{}",x);

    let x = 1;
    println!("{}",x);
}
</code></pre>
<p><img alt="" loading="lazy" data-src="https://itcoke-pic.oss-cn-hangzhou.aliyuncs.com/rust/image-03-00.png" class="lazyload"></p>
<p>注意：这样做并不会产生内存安全问题，因为我们对这块内存拥有完整的所有权，且此时并没有任何其它引用指向这个变量，对这个变量的修改是完全合法的。</p>
<h3 id="4变量类型推导">4、变量类型推导</h3>
<p>Rust的类型推导有两种：<br>
①、从变量声明的当前语句中获取信息进行推导<br>
②、通过上下文信息进行推导</p>
<pre><code class="language-rust">//类型推导
fn type_derivation(){
    //1.1 没有明确标出变量类型，但是通过字面量的后缀，编译器知道x的类型是 u8
    let x = 5u8;
    //1.2 通过字面量值 1，编译器知道y 的类型是 i32
    let y = 1;

    //1.3 创建一个动态数组，但是没有声明数组里面是什么类型
    let mut vec = Vec::new();
    //编译器通过添加的元素 1 ，推导出 vec 的实际类型是 Vec&lt;i32&gt;
    vec.push(1);

    println!("{}",x);
    println!("{}",y);
    println!("{:?}",vec);

}
</code></pre>
<h3 id="5类型别名">5、类型别名</h3>
<p>通过 type 关键字给同一个类型起个别名。</p>
<pre><code class="language-rust">//类型别名
fn type_alias(){
    //将 i32 这种数据类型起别名为 int
    type int = i32;
    let x : int = 1;
    println!("{}",x);
}
</code></pre>
<p>类型别名还可以用于泛型场景：</p>
<blockquote>
<p>type Double<t> = (T,Vec<t>);</t></t></p>
</blockquote>
<p>那么，以后使用 Double<i32> 的时候，就等同于(i32,Vec<i32>)</i32></i32></p>
<h3 id="6不可变-mut">6、不可变 mut</h3>
<p>Rust 声明的变量默认是不可变的。</p>
<blockquote>
<p>默认不可变，这是一个很重要的特性，它符合最小权限原则，有助于我们写出正确且健壮的代码。</p>
</blockquote>
<pre><code class="language-rust">// 变量不可变
fn variable_mut(){
    let i = 123;
    i = 2;
}
</code></pre>
<p>编译报错：</p>
<p><img alt="" loading="lazy" data-src="https://itcoke-pic.oss-cn-hangzhou.aliyuncs.com/rust/image-03-03.png" class="lazyload"></p>
<p>如果要使得变量可变，必须要用关键字 <code>mut</code> 声明：</p>
<pre><code class="language-rust">fn variable_mut(){
    let mut i = 123;
    i = 2;
}
</code></pre>
<p>当你使用 mut 却没有修改变量，Rust 编译期会友好地报警，提示你移除不必要的 mut。</p>
<pre><code class="language-rust">fn main() {
    variable_mut();
}
// 变量不可变
fn variable_mut(){
    let mut i = 123;
    println!("{}",i);
}
</code></pre>
<p>编译器警告：</p>
<p><img alt="" loading="lazy" data-src="https://itcoke-pic.oss-cn-hangzhou.aliyuncs.com/rust/image-03-04.png" class="lazyload"></p>
<h3 id="7静态变量">7、静态变量</h3>
<p>在 Rust 中，静态变量（Static Variables）是一种全局变量，其生命周期从程序开始直到程序结束，具有静态的存储期。</p>
<p>静态变量与普通的局部变量和堆上的动态分配变量有所不同。它们在编译时被初始化，并在程序的整个执行期间保持不变。</p>
<p>静态变量存储在只读的静态数据段中，可以在整个程序的作用域内共享和访问。</p>
<p>Rust 中通过 static 关键字声明静态变量，如下：</p>
<blockquote>
<p>static NAME: Type = value;</p>
</blockquote>
<p>比如声明一个静态变量 GLOBAL：</p>
<blockquote>
<p>static GLOBAL : i32 = 0;</p>
</blockquote>
<p><strong>这也是 Rust 中唯一声明全局变量的方法。</strong></p>
<p>由于 Rust 非常注重内存安全，因此全局变量的使用有很多限制：<br>
①、全局变量必须在声明的时候马上初始化（对应局部变量可以先声明不初始化，只需要保证使用的时候初始化就行了，我们可以这样理解，全局变量是写在函数外面，而局部变量是写在函数内部，所以需要保证全局变量声明的时候就要初始化）；<br>
②、全局变量的初始化必须是编译期可确定的常量，不能包括执行期才能确定的表达式、语句和函数调用；<br>
③、带有 mut 修饰的全局变量，在使用的时候必须使用 unsafe 关键字。</p>
<h3 id="8常量">8、常量</h3>
<p>Rust 中通过 const 关键字声明常量。如下：</p>
<blockquote>
<p>const GLOBAL : i32  = 0;</p>
</blockquote>
<p>①、使用 const 声明的是常量，而不是变量。因此不允许使用 mut 关键字修饰这个变量绑定，也不允许使用 let 关键字。</p>
<p>②、常量的初始化表达式也一定要是一个编译期确定的常量，不能是运行期的值。</p>
<p>③、常量名通常约定全部字母都使用大写，并使用下划线分隔单词。</p>
<p>④、常量声明一定要<strong>显式声明类型</strong>，不能省略。否则会编译报错。</p>
<pre><code class="language-rust">const PI = 3.1415;  // ❌ 错误：missing type for `const` item
</code></pre>
<p>与静态变量相比，常量有以下几个区别：</p>
<ol>
<li><strong>不可变性</strong>：常量是不可变的，一旦初始化后就不能修改。而静态变量可以是可变的，但在 Rust 中通常也是不可变的。</li>
<li><strong>编译时确定</strong>：常量的值在编译时就被确定，并且在程序运行时不能改变。静态变量的值在程序运行时也是不可变的，但它们的初始化可以包含运行时计算的值。</li>
<li><strong>作用域和可见性</strong>：常量的作用域可以是全局的，也可以在特定的作用域内定义。它们可以通过使用 <code>pub</code> 关键字来进行公开，以便在其他模块中使用。静态变量具有全局可见性，可以在程序的任何位置访问和使用。</li>
<li><strong>存储位置</strong>：常量通常直接嵌入到使用它们的代码中，并不占用额外的存储空间。而静态变量存储在只读的静态数据段中，可能占用额外的存储空间。</li>
</ol>
<p>总结来说，常量是在编译时确定的不可变值，其值在运行时不可修改。它们在使用前就被初始化，并始终保持不变。常量具有诸如不可变性、编译时确定、作用域和存储位置等特性。静态变量与常量的区别在于可变性和初始化时机等方面。</p>
<h3 id="9变量声明常见错误">9、变量声明常见错误</h3>
<h4 id="91-变量必须初始化才能使用">9.1 变量必须初始化才能使用</h4>
<p>类型没有默认构造函数，变量值没有“默认值”</p>
<pre><code class="language-rust">fn main() {
    let x : i32;
    println!("{}",x);
}
</code></pre>
<p><img alt="" loading="lazy" data-src="https://itcoke-pic.oss-cn-hangzhou.aliyuncs.com/rust/image-03-01.png" class="lazyload"></p>
<h4 id="92-不能通过-mut-关键字修饰-const-声明的变量">9.2 不能通过 mut 关键字修饰 const 声明的变量</h4>
<p>这个很容易理解，常量是不可变的，mut 表示可变，放一起语义冲突了。</p>
<pre><code class="language-rust">//mut和 const 不能一起使用
fn const_mut_error(){
    const mut i : i32 = 1;
    println!("{}",i);
}
</code></pre>
<p><img alt="" loading="lazy" data-src="https://itcoke-pic.oss-cn-hangzhou.aliyuncs.com/rust/image-03-02.png" class="lazyload"></p>
<h4 id="93-使用下划线开头忽略未使用的变量">9.3 使用下划线开头忽略未使用的变量</h4>
<p>如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为这可能会是个 BUG。</p>
<p>但是有时创建一个不会被使用的变量是有用的，比如你刚刚开始创建一个项目。</p>
<p><strong>如果你希望Rust 不要警告未使用的变量，可以用下划线作为变量名的开头：</strong></p>
<pre><code class="language-rust">fn main() {
    let a = 5;
    let _b = 6;
}
</code></pre>
<p><img alt="" loading="lazy" data-src="https://itcoke-pic.oss-cn-hangzhou.aliyuncs.com/itcoke-202309/image-03-05.png" class="lazyload"></p>
<p>上面只有变量 a 警告了，变量 _b 没有警告。</p>
<h3 id="10为啥要手动设置变量可变性">10、为啥要手动设置变量可变性？</h3>
<p>对比其它语言，比如 Java，默认变量是可变的，如果添加 <code>final</code> 关键字，表示变量在初始化后不可再被修改。</p>
<p>而 Rust 中的变量默认是不可变的。如果你想修改一个变量的值，需要在声明时使用 <code>mut</code> 关键字显式指定它为可变。</p>
<p>大概对比一下，从内存管理来看，Java是面向对象语言，内存管理依靠垃圾收集器，程序员不需要直接管理内存分配和释放。而Rust 则依赖所有权和生命周期系统提供了无垃圾收集的内存安全保证，编译器通过所有权规则来保证在任何给定时间，数据要么只有一个可变引用，要么有多个不可变引用，所以默认不可变是很有必要的。</p>
<p>另外，默认声明不可变，也会使得代码意图更明显，想要修改变量，必须增加额外的操作。</p>
<p>默认不可变，也可以防止数据被意外修改，rust 编译器也能够对不可变数据进行更多优化，提高程序的执行效率。</p>
<p>从并发上来讲，如果数据不会改变，就不需要加锁来同步访问，因此可以避免锁带来的开销和复杂性。这使得 Rust 在编写高效且安全的并发代码方面具有天然的优势。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-20 21:31">2025-07-20 21:31</span>&nbsp;
<a href="https://www.cnblogs.com/rust-tech">Rust技术指南</a>&nbsp;
阅读(<span id="post_view_count">19</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18994661);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18994661', targetLink: 'https://www.cnblogs.com/rust-tech/p/18994661', title: 'Rust从入门到精通03-变量' })">举报</a>
</div>
        