
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huntto/p/19007435" title="发布于 2025-07-27 16:07">
    <span role="heading" aria-level="2">匀速二阶贝塞尔曲线</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>关于二阶贝塞尔曲线匀速运动的实现，网上有很多文章介绍：</p>
<p><a href="https://www.thecodeway.com/blog/2025/03/BezierLine01.html" target="_blank" rel="noopener nofollow">匀速贝塞尔曲线运动的实现(一) | 我的博客和笔记</a></p>
<p><a href="https://blog.csdn.net/auccy/article/details/100746760" target="_blank" rel="noopener nofollow">匀速贝塞尔曲线运动算法-CSDN博客</a></p>
<p><a href="https://gamedev.stackexchange.com/questions/27056/how-to-achieve-uniform-speed-of-movement-on-a-bezier-curve" target="_blank" rel="noopener nofollow">How to achieve uniform speed of movement on a bezier curve?</a></p>
<p>但每次艰难理解后，下次再看时又得重头再来，所以这次准备把自己的理解过程记录下来留待后观。</p>
<h2 id="二阶贝塞尔曲线长度">二阶贝塞尔曲线长度</h2>
<p>给定3个点<span class="math inline">\(P_0\)</span> <span class="math inline">\(P_1\)</span> <span class="math inline">\(P_2\)</span>，用<span class="math inline">\(B(t)\)</span>表示二阶贝塞尔曲线：</p>
<p></p><div class="math display">\[\begin{align}
B(t)&amp;=(1-t)^2P_0+2t(1-t)P_1+t^2P_2, &amp;t\in[0,1] \\

\begin{bmatrix}
x(t) \\
y(t) \\
\end{bmatrix}
&amp;=(1-t)^2
\begin{bmatrix}
x_0 \\
y_0 \\
\end{bmatrix}
+2t(1-t)
\begin{bmatrix}
x_1 \\
y_1 \\
\end{bmatrix}
+t^2
\begin{bmatrix}
x_2 \\
y_2 \\
\end{bmatrix}
, &amp;t\in[0,1]
\end{align}
\]</div><p></p><p>求二阶贝塞尔曲线相对于<span class="math inline">\(t\)</span>的速度：</p>
<p></p><div class="math display">\[\begin{align}
V(t)&amp;=B'(t)\\
&amp;=
\begin{bmatrix}
x'(t) \\
y'(t) \\
\end{bmatrix}\\
&amp;=-2(1-t)
\begin{bmatrix}
x_0 \\
y_0 \\
\end{bmatrix}
+2(1-2t)
\begin{bmatrix}
x_1 \\
y_1 \\
\end{bmatrix}
+2t
\begin{bmatrix}
x_2 \\
y_2 \\
\end{bmatrix}
, &amp;t\in[0,1]
\end{align}
\]</div><p></p><p>速度<span class="math inline">\(V(t)\)</span>是一个二维向量，计算曲线长度不需要速度的方向，因此取其标量：</p>
<p></p><div class="math display">\[\begin{align}

s(t) &amp;= \Vert B'(t) \Vert \\
&amp;= \sqrt{{x'(t)}^2 + {y'(t)}^2} \\

\end{align}
\]</div><p></p><p>其中<span class="math inline">\(x'(t)\)</span>可以进一步变换为：</p>
<p></p><div class="math display">\[\begin{align}
x'(t)&amp;=-2x_0+2x_0t+2x_1-4x_1t+2x_2t \\
&amp;=(2x_0-4x_1+2x_2)t-2x_0+2x_1

\end{align}
\]</div><p></p><p>同理<span class="math inline">\(y'(t)\)</span>可以进一步变换为：</p>
<p></p><div class="math display">\[\begin{align}
y'(t)&amp;=-2y_0+2y_0t+2y_1-4y_1t+2y_2t \\
&amp;=(2y_0-4y_1+2y_2)t-2y_0+2y_1

\end{align}
\]</div><p></p><p>分别用<span class="math inline">\(a_x\)</span> <span class="math inline">\(b_x\)</span> <span class="math inline">\(a_y\)</span> <span class="math inline">\(b_y\)</span> 替换<span class="math inline">\(x'(t)\)</span>和<span class="math inline">\(y'(t)\)</span>中复杂的部分：</p>
<p></p><div class="math display">\[\begin{align}
x'(t)&amp;=a_xt+b_x \\
a_x&amp;=2x_0-4x_1+2x_2 \\
b_x&amp;=-2x_0+2x_1 \\
\end{align}
\]</div><p></p><p></p><div class="math display">\[\begin{align}
y'(t)&amp;=a_yt+b_y \\
a_y&amp;=2y_0-4y_1+2y_2 \\
b_y&amp;=-2y_0+2y_1 \\
\end{align}
\]</div><p></p><p>那么<span class="math inline">\(s(t)\)</span>可以进一步简化为：</p>
<p></p><div class="math display">\[\begin{align}

s(t) &amp;= \sqrt{{x'(t)}^2 + {y'(t)}^2} \\
&amp;= \sqrt{a_x^2t^2+2a_xb_xt+b_x^2+a_y^2t^2+2a_yb_yt+b_y^2} \\
&amp;= \sqrt{(a_x^2+a_y^2)t^2+(2a_xb_x+2a_yb_y)t+b_x^2+b_y^2}
\end{align}
\]</div><p></p><p>再一次用<span class="math inline">\(A\)</span> <span class="math inline">\(B\)</span> <span class="math inline">\(C\)</span>代替<span class="math inline">\(s(t)\)</span>中复杂的部分：</p>
<p></p><div class="math display">\[\begin{align}

s(t) &amp;= \sqrt{At^2+Bt+C} \\
A &amp;= a_x^2+a_y^2  \\
B &amp;= 2a_xb_x+2a_yb_y \\
C &amp;= b_x^2+b_y^2
\end{align}
\]</div><p></p><p>这里的<span class="math inline">\(A\)</span> <span class="math inline">\(B\)</span> <span class="math inline">\(C\)</span>和<a href="https://www.thecodeway.com/blog/2025/03/BezierLine01.html" target="_blank" rel="noopener nofollow">[1]</a>和<a href="https://blog.csdn.net/auccy/article/details/100746760" target="_blank" rel="noopener nofollow">[2]</a>中的不太一样，但最终结果是一样的。对速度<span class="math inline">\(s(t)\)</span>进行积分可求得距离，可以使用<a href="https://www.wolframalpha.com/input?i2d=true&amp;i=Integrate%5BSqrt%5BA*Square%5Bt%5D%2BB*t%2BC%5D%2Ct%5D&amp;lang=zh" target="_blank" rel="noopener nofollow">积分计算器</a>进行计算：</p>
<p></p><div class="math display">\[\begin{align}

\int s(t) &amp;= \int \sqrt{At^2+Bt+C} \\
&amp;= \frac{1}{8A^\frac{3}{2}} \big(2\sqrt{A}(B+2At)\sqrt{C+Bt+At^2}-(B^2-4AC)ln(B+2At+2\sqrt{A}\sqrt{C+Bt+At^2})\big)
\end{align}
\]</div><p></p><p>由于<span class="math inline">\(t\)</span>的取值范围是0到1，因此二阶贝塞尔曲线的长度公式应该写为：</p>
<p></p><div class="math display">\[\begin{align}

L(t) =&amp; \int_0^t s(t) \\
=&amp; \int s(t) - \int s(t) |_{t=0} \\
=&amp; \frac{1}{8A^\frac{3}{2}} \big(2\sqrt{A}(B+2At)\sqrt{C+Bt+At^2}-(B^2-4AC)ln(B+2At+2\sqrt{A}\sqrt{C+Bt+At^2})\big) \\
&amp;- \frac{1}{8A^\frac{3}{2}} \big(2B\sqrt{AC}-(B^2-4AC)ln(B+2\sqrt{AC})\big) \\
=&amp; \frac{1}{8A^\frac{3}{2}} \big(2\sqrt{A}(B+2At)\sqrt{C+Bt+At^2}-(B^2-4AC)ln(B+2At+2\sqrt{A}\sqrt{C+Bt+At^2}) \\
&amp;- 2B\sqrt{AC}+(B^2-4AC)ln(B+2\sqrt{AC}) \big) \\

=&amp; \frac{1}{8A^\frac{3}{2}} \big(T_1T_0-T_2ln(T_1+T_0) \\
&amp;- BT_3+T_2ln(B+T_3) \big) \\
\end{align}
\]</div><p></p><p>其中<span class="math inline">\(T_0\)</span> <span class="math inline">\(T_1\)</span> <span class="math inline">\(T_2\)</span>表示为：</p>
<p></p><div class="math display">\[\begin{align}

T_0 =&amp; 2\sqrt{A}\sqrt{C+Bt+At^2} \\
T_1 =&amp; B+2At \\
T_2 =&amp; B^2-4AC \\
T_3 =&amp; 2\sqrt{AC}

\end{align}
\]</div><p></p><p>为了避免括号层级太多，这里没有进一步提取公因子，最终保持两层括号，如果提取公因子后和<a href="https://www.thecodeway.com/blog/2025/03/BezierLine01.html" target="_blank" rel="noopener nofollow">[1]</a><a href="https://blog.csdn.net/auccy/article/details/100746760" target="_blank" rel="noopener nofollow">[2]</a>的结果是一致的。</p>
<h2 id="匀速二阶贝塞尔曲线">匀速二阶贝塞尔曲线</h2>
<p>现在已经有了二阶贝塞尔曲线的长度公式，要沿贝塞尔曲线进行运动，也就是每次移动的距离相等，首先<span class="math inline">\(L(1.0)\)</span>为贝塞尔曲线的总长度，如果移动<span class="math inline">\(N\)</span>次，那么每次移动的距离为<span class="math inline">\(\frac{1}{N}L(1.0)\)</span>。如果已知第<span class="math inline">\(n\)</span>次的等距移动的<span class="math inline">\(t\)</span>表示为<span class="math inline">\(t_n\)</span>，那么<span class="math inline">\(t_{n+1}\)</span>可以表示为：</p>
<p></p><div class="math display">\[\begin{align}

t_{n}=t_{n-1}+\frac{\frac{1}{N}L(1.0)}{s(t_{n-1})} \quad,\quad n\in[1, N]

\end{align}
\]</div><p></p><p>其中<span class="math inline">\(s(t_n)\)</span>为<span class="math inline">\(t_n\)</span>处的速度，那么移动<span class="math inline">\(\frac{1}{N}L(1.0)\)</span>的距离所需的时间为<span class="math inline">\(\frac{\frac{1}{N}L(1.0)}{s(t_n)}\)</span>，当然这种计算方式仅能求得近似值，这也是<a href="https://gamedev.stackexchange.com/questions/27056/how-to-achieve-uniform-speed-of-movement-on-a-bezier-curve" target="_blank" rel="noopener nofollow">[3]</a>给出的方法。如果仔细看<a href="https://www.thecodeway.com/blog/2025/03/BezierLine01.html" target="_blank" rel="noopener nofollow">[1]</a><a href="https://blog.csdn.net/auccy/article/details/100746760" target="_blank" rel="noopener nofollow">[2]</a>的代码实现对上式进行了修正：</p>
<p></p><div class="math display">\[\begin{align}

t_n=t_{n-1}+\frac{\frac{n}{N}L(1.0)-L(t_{n-1})}{s(t_{n-1})} \quad,\quad n\in[1, N]

\end{align}

\]</div><p></p><p>但最终求得的解仍然是近似解。</p>
<h2 id="python实现">Python实现</h2>
<p>最终匀速贝塞尔曲线的Python实现代码如下：</p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import sys


def bezier_length(A, B, C, t):  # 二阶贝塞尔曲线长度
    T0 = 2 * np.sqrt(A) * np.sqrt(C + B * t + A * t * t)
    T1 = B + 2 * A * t
    T2 = B * B - 4 * A * C
    T3 = 2 * np.sqrt(A * C)
    return 1 / (8 * np.pow(A, 1.5)) * (T0 * T1 - T2 * np.log(T1 + T0) - B * T3 + T2 * np.log(B + T3))


def bezier_velocity(A, B, C, t):  # 二阶贝塞尔曲线速度
    return np.sqrt(C + B * t + A * t * t)


def bezier_movement(p0, p1, p2, N):  # 二阶贝塞尔曲线等距移动
    a = 2 * p0 - 4 * p1 + 2 * p2
    b = -2 * p0 + 2 * p1
    A = a[0] * a[0] + a[1] * a[1]
    B = 2 * a[0] * b[0] + 2 * a[1] * b[1]
    C = b[0] * b[0] + b[1] * b[1]
    L1 = bezier_length(A, B, C, 1)
    tn = 0
    res = np.zeros((N + 1, 2))
    for n in range(N + 1): # 注意这里n的取值范围是[0, N]
        res[n] = (1 - tn) * (1 - tn) * p0 + 2 * tn * (1 - tn) * p1 + tn * tn * p2
        tn = tn + ((n + 1) / N * L1 - bezier_length(A, B, C, tn)) / bezier_velocity(A, B, C, tn)
    return res


P0 = np.array([0, 0])  # 起点
P1 = np.array([3, 8])  # 控制点
P2 = np.array([6, 0])  # 终点

N = 10
if len(sys.argv) &gt; 1:
    N = int(sys.argv[1])

curve = bezier_movement(P0, P1, P2, N)

plt.figure(figsize=(10, 6))

plt.plot([P0[0], P1[0], P2[0]], [P0[1], P1[1], P2[1]], 'ro--', label='Control-Line')
plt.plot(curve[:, 0], curve[:, 1], 'o', linewidth=2, label='Bezier movement')

plt.text(P0[0], P0[1], 'P0', fontsize=12, ha='right', va='top')
plt.text(P1[0], P1[1], 'P1', fontsize=12, ha='center', va='bottom')
plt.text(P2[0], P2[1], 'P2', fontsize=12, ha='left', va='top')

plt.title('Bezier Curve(N=' + str(N) + ')', fontsize=14)
plt.xlabel('X-axis', fontsize=12)
plt.ylabel('Y-axis', fontsize=12)
plt.grid(True, linestyle='--', alpha=0.7)
plt.legend()
plt.axis('equal')
plt.show()
</code></pre>
<p>当<span class="math inline">\(N=10\)</span>，<span class="math inline">\(N=20\)</span>，<span class="math inline">\(N=30\)</span>的运行结果如下：</p>
<p><img alt="Figure_1" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3093519/202507/3093519-20250727155354324-69590906.png" class="lazyload"></p>
<p><img alt="Figure_2" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3093519/202507/3093519-20250727155620238-756582614.png" class="lazyload"></p>
<p><img alt="Figure_3" loading="lazy" data-src="https://img2024.cnblogs.com/blog/3093519/202507/3093519-20250727155629739-437509309.png" class="lazyload"></p>
<p>在<span class="math inline">\(N=10\)</span>时，最后一个点明显与端点不重合（运行Python脚本后，放大后也可观察），因此贝塞尔曲线匀速运动只能求得近似解。在使用中，需要根据实际情况选择合适的<span class="math inline">\(N\)</span>，以及如何处理最后一个点。</p>
<h2 id="参考">参考</h2>
<ol>
<li>
<p><a href="https://www.thecodeway.com/blog/2025/03/BezierLine01.html" target="_blank" rel="noopener nofollow">匀速贝塞尔曲线运动的实现(一) | 我的博客和笔记</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/auccy/article/details/100746760" target="_blank" rel="noopener nofollow">匀速贝塞尔曲线运动算法-CSDN博客</a></p>
</li>
<li>
<p><a href="https://gamedev.stackexchange.com/questions/27056/how-to-achieve-uniform-speed-of-movement-on-a-bezier-curve" target="_blank" rel="noopener nofollow">How to achieve uniform speed of movement on a bezier curve?</a></p>
</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-27 16:08">2025-07-27 16:07</span>&nbsp;
<a href="https://www.cnblogs.com/huntto">Huntto</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19007435);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19007435', targetLink: 'https://www.cnblogs.com/huntto/p/19007435', title: '匀速二阶贝塞尔曲线' })">举报</a>
</div>
        