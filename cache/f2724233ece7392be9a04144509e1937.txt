
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cikiss/p/18684045" title="发布于 2025-01-21 18:07">
    <span role="heading" aria-level="2">「全网最细 + 实战源码案例」设计模式——单例设计模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="核心思想">核心思想：</h1>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/9cfc5a70c108406a91775914eab66b37~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1737540386&amp;x-orig-sign=BkeiIWxw2Fp%2FSCuVm7597uw%2Bah8%3D" alt="" loading="lazy"></p>
<ul>
<li>属于<strong>创建型设计模式</strong>，核心目的是<strong>确保一个类在整个程序运行期间只有一个实例</strong>，并提供一个全局访问点来获取该实例。</li>
<li>控制共享资源的访问（如数据库链接、配置管理、日志处理器等）</li>
<li>真实世界类比：政府是单例模式的一个很好的示例。 一个国家只有一个官方政府。 不管组成政府的每个人的身份是什么，“某政府” 这一称谓总是鉴别那些掌权者的全局访问节点。</li>
</ul>
<hr>
<h1 id="结构">结构</h1>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/7096960f15f545b397821137a674e51e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1737540386&amp;x-orig-sign=tjpANO0FwlotgqG2fe6WryzpdLQ%3D" alt="" loading="lazy"></p>
<p>所有单例的实现都包含以下两个相同的步骤：</p>
<ul>
<li>将默认<strong>构造函数设为私有</strong>，防止其他对象使用单例类的 <code>new</code> 运算符。</li>
<li>新建一个<strong>静态构建方法作为构造函数</strong>。该函数会“偷偷”调用私有构造函数来创建对象，并将其保存在一个静态成员变量中。此后所有对于该函数的调用都将返回这一缓存对象。</li>
</ul>
<p>如果你的代码能够访问单例类，那它就能调用单例类的静态方法。无论何时调用该方法，它总是会返回相同的对象。</p>
<hr>
<h1 id="使用场景">使用场景：</h1>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/0d4d1401c2794c6f9d7ab492d62bdb85~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1737540386&amp;x-orig-sign=kPilxu9xrF4NzX2MONkHEM2shTY%3D" alt="" loading="lazy"></p>
<h2 id="1-需要唯一实例的场景">1. 需要唯一实例的场景：</h2>
<ul>
<li>配置管理类</li>
<li>日志记录器</li>
<li>数据库连接池</li>
<li>多线程环境中的任务调度器</li>
</ul>
<h2 id="2-需要全局共享实例">2. 需要全局共享实例</h2>
<ul>
<li>以避免多个实例引发资源冲突或影响程序逻辑。</li>
</ul>
<hr>
<h1 id="实现方式">⭐实现方式：</h1>
<h2 id="1-饿汉式线程安全类加载时初始化">1. 饿汉式（线程安全，类加载时初始化）</h2>
<h3 id="11-静态变量式常见方式">1.1. 静态变量式（常见方式）</h3>
<pre><code>// 饿汉式（静态变量）
public class Singleton {

    // 1. 私有化构造方法
    private Singleton() {}

    // 2. 创建一个静态变量，保存实例
    private static final Singleton instance = new Singleton();

    // 3. 提供一个公共的静态方法获取实例
    public static Singleton getInstance() {
        return instance;
    }
}
</code></pre>
<p>特点：</p>
<ul>
<li>线程安全：类加载时实例化，JVM 保证线程安全。</li>
<li>缺点：类加载时即创建实例，即使未使用也会占用内存。</li>
</ul>
<hr>
<h3 id="12-静态代码块式">1.2. 静态代码块式</h3>
<pre><code>// 饿汉式（静态代码块）
public class Singleton {

    // 1. 私有化构造方法
    private Singleton(){}

    // 2. 创建一个静态对象
    private static Singleton instance;

    // 3. 在静态代码块中创建对象
    static {
        instance = new Singleton();
    }

    // 4. 提供获取对象的方法
    public static Singleton getInstance(){
        return instance;
    }
}
</code></pre>
<p>特点：</p>
<ul>
<li>和静态变量方式类似，在类加载时实例化。</li>
<li>可以在静态代码块中加入额外逻辑，例如异常处理或配置初始化。</li>
</ul>
<hr>
<h2 id="2-懒汉式线程不安全延迟加载">2. 懒汉式（线程不安全，延迟加载）</h2>
<pre><code>// 懒汉式，线程不安全
public class Singleton {

    // 1. 私有化构造方法
    private Singleton() {}

    // 2. 定义一个静态变量，用于存储唯一实例
    private static Singleton instance;

    // 3. 定义一个静态方法，用于获取唯一实例
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
</code></pre>
<p>优点：</p>
<ul>
<li>实例在第一次使用时才初始化，节约资源。</li>
</ul>
<p>缺点：</p>
<ul>
<li>多线程情况下可能创建多个实例，线程不安全。</li>
</ul>
<hr>
<h2 id="3-线程安全的懒汉式">3. 线程安全的懒汉式</h2>
<h3 id="31-同步方法">3.1. 同步方法</h3>
<pre><code>// 懒汉式，同步式，线程安全
public class Singleton {

    // 1. 私有化构造方法
    private Singleton() {}

    // 2. 定义一个静态变量，用于存储
    private static Singleton instance;

    // 3. 定义一个静态方法，用于获取唯一实例
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
</code></pre>
<p>缺点：</p>
<ul>
<li>同步方法会导致性能下降，尤其是高并发访问时。</li>
</ul>
<h3 id="32-双重检查锁推荐">3.2. 双重检查锁（推荐）</h3>
<pre><code>// 懒汉式，双重检查锁方式
public class Singleton {

    // 1. 私有化构造方法
    private Singleton() {}

    // 2. 定义一个静态变量，用于存储实例，volatile保证可见性与有序性，避免指令重排
    private static volatile Singleton instance;

    // 3. 定义一个静态方法，用于获取唯一实例
    public static Singleton getInstance() {
        // 1.第一次判断，如果instance的值为null，则进入同步代码块
        if (instance == null) {
            // 2.同步代码块，保证线程安全
            synchronized (Singleton.class) {
                // 3.第二次判断，如果instance的值为null，则创建实例
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
</code></pre>
<p>优点：</p>
<ul>
<li>高效，只有在首次实例化时会加锁，之后不会。</li>
</ul>
<p>注意：<code>volatile</code> 关键字防止指令重排，确保线程安全。</p>
<h4 id="为什么必须要加-volatile">⭐为什么必须要加 <code>volatile</code>？</h4>
<ol>
<li><strong>防止指令重排</strong></li>
</ol>

<ol>
<li>
<ol>
<li>在 Java 中，对象的实例化过程分为三步：</li>
</ol>
</li>
</ol>

<ol>
<li>
<ol>
<li>
<ol>
<li><strong>分配内存</strong>空间</li>
<li><strong>初始化</strong>对象</li>
<li>将内存地址<strong>赋值</strong>给变量</li>
</ol>
</li>
</ol>
</li>
</ol>

<ol>
<li>
<ol start="2">
<li>由于指令重排的存在，步骤 2 和步骤 3 可能被调换执行。例如：</li>
</ol>
</li>
</ol>

<ol>
<li>
<ol>
<li>
<ol>
<li>线程 A 在执行 <code>instance = new Singleton()</code> 时，可能执行了分配内存和赋值操作，但还未完成初始化。</li>
<li>此时，<code>instance</code> 已经不为 <code>null</code>，但它指向的对象尚未完全初始化。</li>
</ol>
</li>
</ol>
</li>
</ol>

<ol>
<li>
<ol start="3">
<li>如果线程 B 此时调用 <code>getInstance()</code>，判断 <code>instance != null</code> 为真，但实际访问的是一个未初始化完全的对象，这将导致程序出错。</li>
<li>加上 <code>volatile</code> 后，禁止指令重排序，确保初始化顺序正确。</li>
</ol>
</li>
</ol>

<ol start="2">
<li><strong>保证变量的可见性</strong></li>
</ol>

<ol>
<li>
<ol>
<li>Java 的内存模型中，每个线程有自己的<strong>工作内存</strong>。一个线程对变量的修改，可能不会立即被其他线程所见。</li>
<li>加上 <code>volatile</code> 后，保证每次对 <code>instance</code> 的<strong>读操作都能获取到最新的值</strong>。</li>
</ol>
</li>
</ol>

<ol>
<li>
<ol>
<li>
<ol>
<li>当线程 A 完成 <code>instance</code> 初始化后，其他线程（如 B 线程）立刻可见，而不会读取到旧值或中间状态。</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h3 id="33-静态内部类推荐">3.3. ⭐静态内部类（推荐）</h3>
<pre><code>// 懒汉式，静态内部类方式
public class Singleton {
    
    // 1.构造函数私有化，外部不能new
    private Singleton() {}
    
    // 2.创建静态内部类
    private static class SingletonHolder {
        // 3.创建静态变量，保存实例
        private static final Singleton INSTANCE = new Singleton();
    }
    
    // 3.定义一个静态方法，用于获取唯一实例
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
</code></pre>
<p>原理：</p>
<ul>
<li>由于 JVM 加载外部类的过程中，不会加载静态内部类，只有内部类的属性/方法被调用时才会被加载，并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只会被实例化一次，并且严格保证实例化顺序。</li>
</ul>
<p>优点：</p>
<ul>
<li>线程安全</li>
<li>实现了延迟加载，按需初始化</li>
</ul>
<hr>
<h2 id="4-枚举单例最安全推荐">4. ⭐枚举单例（最安全，推荐）</h2>
<pre><code>// 枚举单例
public enum Singleton {
    INSTANCE;
}
</code></pre>
<p>优点：</p>
<ul>
<li>简单</li>
<li>天然防止反射和序列化破坏单例</li>
</ul>
<hr>
<h1 id="破坏单例">破坏单例</h1>
<h2 id="1-序列化破坏单例">1. <strong>序列化破坏单例</strong></h2>
<p><strong>问题</strong>：<br>
序列化和反序列化可以通过 <code>ObjectInputStream</code> 创建一个新的实例，而不是返回现有的单例实例。</p>
<p><strong>示例代码：</strong></p>
<pre><code>import java.io.*;

public class Singleton implements Serializable {
    private static final long serialVersionUID = 1L;

    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return INSTANCE;
    }

    public static void main(String[] args) throws Exception {
        Singleton instance1 = Singleton.getInstance();

        // 将对象序列化到文件
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("singleton.obj"));
        oos.writeObject(instance1);
        oos.close();

        // 从文件反序列化对象
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("singleton.obj"));
        Singleton instance2 = (Singleton) ois.readObject();

        // 验证是否为同一个实例
        System.out.println(instance1 == instance2); // 输出：false
    }
}
</code></pre>
<p><strong>原因</strong>：</p>
<ul>
<li>序列化机制会通过反序列化的过程创建一个新的对象实例，而不会调用单例类中的 <code>getInstance()</code> 方法。</li>
</ul>
<p><strong>解决方案</strong>：<br>
实现 <code>readResolve()</code> 方法，确保反序列化时返回现有实例。</p>
<pre><code>private Object readResolve() {
    return INSTANCE;
}
</code></pre>
<hr>
<h2 id="2-反射破坏单例">2. <strong>反射破坏单例</strong></h2>
<p><strong>问题</strong>：<br>
通过反射，能够直接调用私有构造方法，创建多个实例。</p>
<p><strong>示例代码：</strong></p>
<pre><code>import java.lang.reflect.Constructor;

public class Singleton {
    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return INSTANCE;
    }

    public static void main(String[] args) throws Exception {
        Singleton instance1 = Singleton.getInstance();

        // 使用反射创建新实例
        Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();
        constructor.setAccessible(true);
        Singleton instance2 = constructor.newInstance();

        // 验证是否为同一个实例
        System.out.println(instance1 == instance2); // 输出：false
    }
}
</code></pre>
<p><strong>原因</strong>：</p>
<ul>
<li>反射可以访问私有构造方法并直接调用，从而绕过单例模式的限制。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>在构造方法中防止重复实例化</strong>：</li>
</ol>
<pre><code>private static boolean isCreated = false;

private Singleton() {
    if (isCreated) {
        throw new RuntimeException("Singleton instance already created!");
    }
    isCreated = true;
}
</code></pre>
<ol start="2">
<li><strong>使用枚举单例</strong>：<br>
枚举类的单例天然防止反射和序列化破坏。</li>
</ol>
<pre><code>public enum Singleton {
    INSTANCE;
}
</code></pre>
<hr>
<h2 id="3-总结">3. 总结</h2>
<ul>
<li><strong>序列化破坏</strong>：通过 <code>readResolve()</code> 方法解决。</li>
<li><strong>反射破坏</strong>：通过构造方法检查或使用枚举单例解决。</li>
<li><strong>推荐方式</strong>：使用 <strong>枚举单例</strong>，最简单且最安全，能有效防止这两种破坏。</li>
</ul>
<hr>
<h1 id="在源码中的应用">在源码中的应用</h1>
<h2 id="1-runtime-类">1. ****<code>Runtime</code> <strong>类</strong></h2>
<ul>
<li><strong>简介</strong>：<code>Runtime</code> 类允许应用程序与运行时环境交互，比如调用垃圾回收、运行外部命令等。</li>
<li><strong>实现方式</strong>：通过 <strong>饿汉式单例</strong> 实现。</li>
</ul>
<h4 id="源码分析"><strong>源码分析</strong>：</h4>
<pre><code>public class Runtime {
    private static final Runtime currentRuntime = new Runtime(); // 饿汉式实例化

    private Runtime() {} // 私有化构造方法

    public static Runtime getRuntime() {
        return currentRuntime; // 返回唯一实例
    }

    public void gc() {
        // 调用垃圾回收
    }

    public void exit(int status) {
        // 退出 JVM
    }
}
</code></pre>
<h4 id="特点"><strong>特点</strong>：</h4>
<ul>
<li>全局唯一实例。</li>
<li>使用饿汉式，保证线程安全。</li>
</ul>
<hr>
<h2 id="2-desktop-类">2. ****<code>Desktop</code> <strong>类</strong></h2>
<ul>
<li><strong>简介</strong>：<code>Desktop</code> 类用来打开用户默认的应用程序（如浏览器、邮件客户端等）。</li>
<li><strong>实现方式</strong>：通过 <strong>懒汉式单例</strong> 实现。</li>
</ul>
<h4 id="源码分析-1"><strong>源码分析</strong>：</h4>
<pre><code>public final class Desktop {
    private static Desktop desktop;

    private Desktop() {}

    public static synchronized Desktop getDesktop() {
        if (desktop == null) {
            desktop = new Desktop(); // 懒汉式单例
        }
        return desktop;
    }

    public void browse(URI uri) {
        // 打开 URI
    }
}
</code></pre>
<h4 id="特点-1"><strong>特点</strong>：</h4>
<ul>
<li>使用同步方法保证线程安全。</li>
<li>懒加载，实例在需要时创建。</li>
</ul>
<hr>
<h2 id="3-logger-类-javautillogginglogger-">3. ****<code>Logger</code> <strong>类（</strong> <code>java.util.logging.Logger</code> <strong>）</strong></h2>
<ul>
<li><strong>简介</strong>：<code>Logger</code> 是 Java 的日志工具类，用于记录和管理应用程序日志。</li>
<li><strong>实现方式</strong>：内部使用单例模式管理全局日志管理器（<code>LogManager</code>）。</li>
</ul>
<h4 id="源码分析核心部分"><strong>源码分析</strong>（核心部分）：</h4>
<pre><code>public class Logger {
    private static final LogManager manager = LogManager.getLogManager(); // 单例的 LogManager

    protected Logger(String name, String resourceBundleName) {
        // Logger 构造方法
    }

    public static Logger getLogger(String name) {
        return manager.getLogger(name); // 通过单例 LogManager 获取 Logger
    }
}
</code></pre>
<h4 id="特点-2"><strong>特点</strong>：</h4>
<ul>
<li><code>LogManager</code> 作为单例管理所有 <code>Logger</code> 实例。</li>
<li><code>getLogger</code> 方法确保每个名称对应的 <code>Logger</code> 是唯一的。</li>
</ul>
<hr>
<h2 id="4-总结">4. <strong>总结</strong></h2>
<p>在 JDK 源码中，单例模式被广泛应用于需要 <strong>全局唯一实例</strong> 或 <strong>资源共享</strong> 的场景：</p>
<ol>
<li><strong>饿汉式</strong>：<code>Runtime</code> 类。</li>
<li><strong>懒汉式</strong>：<code>Desktop</code> 类。</li>
<li><strong>组合模式</strong>：<code>Logger</code> 类中的 <code>LogManager</code> 单例。</li>
</ol>
<p>这些设计的核心目标是：<strong>确保全局状态的一致性、节省资源以及简化管理</strong>。</p>
<h1 id="单例模式优缺点">单例模式优缺点：</h1>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/a11771a8900745faabe8d5c083fa46fc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1737540386&amp;x-orig-sign=drYtfKwkyvFT228PyU8eFbP%2BfEw%3D" alt="" loading="lazy"></p>
<hr>
<h1 id="与其他模式的关系">与其他模式的关系：</h1>
<ol>
<li><a href="https://refactoringguru.cn/design-patterns/facade" target="_blank" rel="noopener nofollow">外观模式</a>类通常可以转换为<a href="https://refactoringguru.cn/design-patterns/singleton" target="_blank" rel="noopener nofollow">单例模式</a>类， 因为在大部分情况下一个外观对象就足够了。</li>
<li>如果你能将对象的所有共享状态简化为一个享元对象， 那么<a href="https://refactoringguru.cn/design-patterns/flyweight" target="_blank" rel="noopener nofollow">享元模式</a>就和<a href="https://refactoringguru.cn/design-patterns/singleton" target="_blank" rel="noopener nofollow">单例</a>类似了。 但这两个模式有两个根本性的不同。</li>
</ol>

<ol>
<li>
<ol>
<li>只会有一个单例实体， 但是<em>享元</em>类可以有多个实体， 各实体的内在状态也可以不同。</li>
<li><em>单例</em>对象可以是可变的。 享元对象是不可变的。</li>
</ol>
</li>
</ol>

<ol start="3">
<li><a href="https://refactoringguru.cn/design-patterns/abstract-factory" target="_blank" rel="noopener nofollow">抽象工厂模式</a>、 <a href="https://refactoringguru.cn/design-patterns/builder" target="_blank" rel="noopener nofollow">生成器模式</a>和<a href="https://refactoringguru.cn/design-patterns/prototype" target="_blank" rel="noopener nofollow">原型模式</a>都可以用<a href="https://refactoringguru.cn/design-patterns/singleton" target="_blank" rel="noopener nofollow">单例</a>来实现。</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.011724458770833333" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-21 18:08">2025-01-21 18:07</span>&nbsp;
<a href="https://www.cnblogs.com/cikiss">SlackClimb</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18684045" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18684045);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18684045', targetLink: 'https://www.cnblogs.com/cikiss/p/18684045', title: '「全网最细 + 实战源码案例」设计模式——单例设计模式' })">举报</a>
</div>
        