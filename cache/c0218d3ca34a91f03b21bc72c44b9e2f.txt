
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/nanyanxin/p/18675714" title="发布于 2025-01-16 20:23">
    <span role="heading" aria-level="2">2 应用层</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="2-应用层">2 应用层</h1>
<h2 id="21-网络应用原理">2.1 网络应用原理</h2>
<p><strong>网络应用</strong>：能够运行在不同的端系统和通过网络彼此通信的程序。</p>
<ul>
<li>注：在端系统上运行，而不是在网络核心上运行。</li>
</ul>
<p>网络应用是计算机网络<strong>存在的理由</strong>。</p>
<h3 id="211-应用体系结构application-architecture">2.1.1 应用体系结构（application architecture）</h3>
<p><strong>客户-服务器体系结构（client-server architecture）</strong></p>
<ul>
<li>server：响应client的请求，总是开启，固定、周知的IP地址。</li>
<li>client：向server发送请求，clients之间不直接通信。</li>
<li>举例：Web，FTP，Telnet，Email。</li>
</ul>
<p><strong>P2P体系结构（peer-to-peer architecture）</strong></p>
<ul>
<li>peer：所有的对等方不总是开启，间断连接，直接通信，对专用服务器依赖很小或没有依赖。</li>
<li>自扩展性（self-scalability）：对等方的加入会为系统增加服务能力，即系统服务能力一般不会耗尽。</li>
<li>缺点：P2P的高度非集中式结构，面临安全性、性能、可靠性等挑战。</li>
<li>举例：BitTorrent。</li>
</ul>
<h3 id="212-进程通信">2.1.2 进程通信</h3>
<p>进程（process）：运行在端系统中的程序。</p>
<p>在两个不同端系统上的进程，通过跨越计算机网络交换报文（message）而相互通信。</p>
<h4 id="2121-client进程和server进程">2.1.2.1 client进程和server进程</h4>
<p>在一对进程之间的通信会话场景中，<strong>发起通信</strong>（即在会话开始时发起与其他进程的联系）的进程是<strong>client进程</strong>，在会话开始时<strong>等待联系</strong>的进程是<strong>server进程</strong>。</p>
<p>无论是client-server架构还是P2P架构，在进程间进行通信时，都会分为client进程和server进程（客户端和服务器端进程）。</p>
<h4 id="2122-进程与计算机网络之间的接口">2.1.2.2 进程与计算机网络之间的接口</h4>
<p><strong>套接字（socket）</strong>/<strong>应用编程接口（Application Programming Interface，API）</strong>：同一台主机内，应用层与运输层之间的接口。</p>
<p>发送方进程通过套接字将报文传递到运输层，该报文在运输层中被分为报文段经过网络运输到接收方的运输层，接收方的运输层去掉运输层首部，并将报文分发到接收方进程的套接字，报文经过接收方进程的套接字被接收方进程接收。</p>
<p>应用程序开发者可以控制套接字的应用层端，但在运输层端，只能做以下控制：</p>
<ul>
<li>选择运输层协议</li>
<li>设定几个运输层参数（最大缓存、最大报文段长度等）</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250116201739232-849705006.png" alt="" loading="lazy"></p>
<h4 id="2123-进程寻址">2.1.2.3 进程寻址</h4>
<p>报文中包含以下两个字段：</p>
<ul>
<li>目的IP地址（IP address）：32bits，确定目的主机的地址。</li>
<li>目的端口号（port number）：确定目的主机上运行的哪个目的进程（为不同的网络应用分配不同的端口号）。</li>
</ul>
<h3 id="213-应用程序可以使用的运输服务">2.1.3 应用程序可以使用的运输服务</h3>
<p><strong>可靠数据传输（reliable data transfer）</strong></p>
<ul>
<li>确保发送方发出的数据正确并完全地交付给接收方。</li>
<li>容忍丢失的应用（loss-tolerant application）：可以不提供可靠数据传输，如交谈式音频/视频等多媒体应用。</li>
</ul>
<p><strong>吞吐量（throughput）</strong></p>
<ul>
<li>可用吞吐量（available throughput）：发送进程能够向接收进程交付比特的速率。</li>
<li>确保吞吐量（guaranteed throughput）：确保可用吞吐量至少为r bps，则应用程序可以申请r bps的确保吞吐量。</li>
<li>带宽敏感的应用（bandwidth-sensitive application）：具有吞吐量要求的应用程序，如多媒体应用。</li>
<li>弹性应用（elastic application）：能够根据当前可用的带宽使用可用吞吐量，如Email，FTP，Web。</li>
</ul>
<p><strong>定时（timing）</strong></p>
<ul>
<li>交互式实时应用程序（interactive real-time application）：可能会要求发送方注入套接字的每个比特到达接收方的套接字不迟于某一时间，如因特网电话、虚拟环境、视频会议、多方游戏。</li>
</ul>
<p><strong>安全（security）</strong></p>
<ul>
<li>发送前加密，接收后解密</li>
</ul>
<h3 id="214-因特网提供的运输服务">2.1.4 因特网提供的运输服务</h3>
<p><strong>TCP（详见运输层）</strong></p>
<ul>
<li>面向连接的服务</li>
<li>可靠的数据传输服务</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<p><strong>UDP（详见运输层）</strong></p>
<ul>
<li>无连接</li>
<li>不可靠</li>
</ul>
<p><strong>因特网运输协议不能提供吞吐量保证和定时服务</strong></p>
<h3 id="215-应用层协议">2.1.5 应用层协议</h3>
<p>应用层协议：定义了运行在不同端系统上的应用程序进程如何相互传递报文，包括：</p>
<ul>
<li>交换的报文类型（请求报文、响应报文）</li>
<li>各种报文类型的语法（报文结构、字段）</li>
<li>各字段的语义（字段中信息的含义）</li>
<li>确定一个进程何时以及如何发送报文，对报文进行响应的规则</li>
</ul>
<h2 id="22-web和http">2.2 Web和HTTP</h2>
<p><strong>Web</strong>：基于<strong>client-server架构</strong>的因特网<strong>应用</strong>，通过交换HTTP报文进行会话，包括以下组成部分：</p>
<ul>
<li>Web浏览器（Web browser，是client端）</li>
<li>Web服务器（Web server，是server端）</li>
<li>文档格式标准（HTML）</li>
<li>应用层协议（HTTP）</li>
<li>可能包括Web缓存（Web cache/proxy server）</li>
</ul>
<p><strong>HTTP</strong>：Web使用的<strong>应用层协议</strong>，是<strong>无状态（stateless）</strong>协议，但可以使用<strong>cookie</strong>，分为<strong>持续连接（persistent connection）</strong>和<strong>非持续连接（non-persistent connection）</strong>，基于<strong>TCP运输层协议</strong>，故可以提供：</p>
<ul>
<li>面向连接的服务</li>
<li>可靠的数据传输服务</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<h3 id="221-http概述">2.2.1 HTTP概述</h3>
<p><strong>超文本传输协议（HyperText Transfer Protocol，HTTP）</strong>：通过客户程序和服务器程序实现，定义了HTTP报文结构以及客户和服务器进程报文交换（用户请求Web页面和服务器传输Web页面）的方式。</p>
<p><strong>Web页面</strong>（Web page）是由<strong>对象</strong>（object，如HTML、CSS、JS文件，JPEG图形等）组成的。多数Web页面含有一个HTML基本文件以及几个引用对象。HTML基本文件通过URL引用其他对象。</p>
<p><strong>URL</strong>：主机名+路径名</p>
<ul>
<li>例如：<a href="http://www.someSchool.edu/someDepartment/picture.gif" target="_blank" rel="noopener nofollow">http://www.someSchool.edu/someDepartment/picture.gif</a></li>
<li>主机名：www.someSchool.edu</li>
<li>路径名：/someDepartment/picture.gif</li>
</ul>
<p><strong>Web浏览器（Web browser）</strong>实现了HTTP的客户端，如Internet Explorer、Chrome。</p>
<p><strong>Web服务器（Web server）</strong>实现了HTTP的服务器端，用于存储Web对象，这些对象用URL寻址。</p>
<p><strong>HTTP工作流程</strong></p>
<ul>
<li>HTTP client向HTTP server发起一个TCP连接</li>
<li>一旦连接建立，client向它的套接字发送HTTP请求报文，并从它的套接字接收HTTP响应报文</li>
<li>类似地，server从它的套接字接收HTTP请求报文，并向它的套接字发送HTTP响应报文</li>
<li>传输结束后，TCP连接关闭</li>
</ul>
<p><strong>分层体系结构的优点</strong>：HTTP不必担心数据的丢失，也不必关注TCP从网络的数据丢失和乱序故障中恢复的细节。</p>
<p><strong>无状态协议（stateless protocol）</strong>：HTTP服务器向客户发送被请求的文件（Web页面），而不存储该客户的任何信息。</p>
<p><strong>client-server架构</strong>：Web服务器总是开启，且具有固定的IP地址。</p>
<h3 id="222-非持续连接和持续连接">2.2.2 非持续连接和持续连接</h3>
<p>HTTP默认使用带流水线的持续连接，但HTTP客户和服务器也能配置成使用非持续连接。</p>
<h4 id="2221-非持续连接non-persistent-connection">2.2.2.1 非持续连接（non-persistent connection）</h4>
<p>对于每一个对象，client在发送请求报文前要先发起TCP连接，server传输数据后要关闭TCP连接。</p>
<p>因此，传输一个页面可能产生并关闭多个TCP连接。</p>
<p>每次传输需要花费两倍的<strong>往返时间（Round-Trip Time，RTT）</strong></p>
<ul>
<li>RTT：一个短分组从客户到服务器然后再返回客户所花费的时间（包括传播时延、排队时延、分组处理时延）。</li>
<li>三次握手（申请TCP连接的过程，其中第三次包含请求报文）+   一次传输（响应报文）</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250116201833669-18198403.png" alt="" loading="lazy"></p>
<p><strong>缺点</strong>：必须为每一个请求的对象建立和维护一个全新的连接，每一个对象经受两倍RTT的交付时延。</p>
<h4 id="2222-持续连接persistent-connection">2.2.2.2 持续连接（persistent connection）</h4>
<p>在一次TCP连接期间，client发送多个请求报文（可以以流水线方式发送，即不必等待未决请求的响应），server传输多个对象。</p>
<p>通常，若一条连接经过一定时间间隔（可配置的超时间隔）仍未被使用，HTTP服务器关闭TCP连接。</p>
<h3 id="223-http报文格式">2.2.3 HTTP报文格式</h3>
<p><strong>HTTP请求报文</strong></p>
<p>请求行（request line）：方法字段（GET, POST, HEAD, PUT, DELETE）、URL字段、HTTP版本字段</p>
<p>首部行（header line）：Host（提供给Web cache）、Connection（声名传输结束是否关闭连接）、User-agent（声名用户浏览器类型）、Accept-language（用户想要的语言版本）......</p>
<p>空行（blank line）：分隔</p>
<p>实体体（entity body）：GET方法中实体体为空，POST方法中实体体包含用户在表单中的输入值（也可以用GET在URL中包含该输入值——扩展URL）</p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250116201847338-626362597.png" alt="" loading="lazy"></p>
<p><strong>HTTP响应报文</strong></p>
<p>状态行（status line）：HTTP版本字段、状态码和响应状态信息（<a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener nofollow">HTTP 状态码 | 菜鸟教程</a>）</p>
<p>首部行（header line）：Connection、Date（报文发送时间）、Server（服务器类型）、Last-Modified（对象创建或上一次修改时间）、Content-Length（对象字节数）、Content-Type（对象类型）</p>
<p>空行（blank line）</p>
<p>实体体（entity body）：包含了请求的对象本身</p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250116201900736-652253195.png" alt="" loading="lazy"></p>
<h3 id="224-cookie">2.2.4 cookie</h3>
<p>HTTP是无状态协议，服务器无法存储用户信息。</p>
<p><strong>cookie</strong>：为了使服务器能够识别用户，cookie允许站点对用户进行跟踪，在无状态的HTTP之上建立了一个用户会话层。</p>
<p><strong>构成</strong></p>
<ul>
<li>HTTP请求报文中包含cookie首部行</li>
<li>HTTP响应报文中包含cookie首部行</li>
<li>用户端系统保留一个cookie文件，由浏览器管理</li>
<li>Web服务器后端数据库存储用户信息</li>
</ul>
<p><strong>cookie工作流程</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250116201912846-1685517176.png" alt="" loading="lazy"></p>
<h3 id="225-web缓存">2.2.5 Web缓存</h3>
<p><strong>Web缓存器（Web cache）</strong>也叫<strong>代理服务器（proxy server）</strong>，代表初始Web服务器满足HTTP请求的网络实体。</p>
<p>Web缓存器有自己的存储空间，用来保存最近请求过的对象的副本。</p>
<p><strong>工作流程</strong></p>
<ul>
<li>浏览器创建对Web缓存的TCP连接，并向Web缓存器发送HTTP请求（此时Web缓存器作为服务器）</li>
<li>Web缓存器检查本地是否存储了请求对象的副本，若有则向客户发送包含该对象的HTTP响应</li>
<li>若无则创建对初始服务器的TCP连接，请求该对象，初始服务器收到请求后发送响应（此时Web缓存器作为客户）</li>
<li>Web缓存器接收到对象后，在本地存储该对象的副本，并向客户发送包含该副本的HTTP响应</li>
</ul>
<p><strong>好处</strong></p>
<ul>
<li>减少对客户请求的响应时间（考虑客户与初始服务器之间的瓶颈带宽低于客户与Web缓存器之间的瓶颈带宽）</li>
<li>减少一个机构接入到因特网中的通信量（机构不必急于增加带宽，降低费用；减少因特网上Web流量，改善所有应用性能）</li>
</ul>
<p><strong>内容分发网络（Content Distribute Network，CDN）</strong>：CDN公司在因特网上安装了许多地理上分散的缓存器，使大量流量实现了本地化。</p>
<p><strong>条件GET（conditional GET）</strong>：缓存器中对象副本可能是陈旧的</p>
<ul>
<li>Web cache向初始服务器发送条件GET请求（包含字段If-modified-since）</li>
<li>若请求报文的If-modified-since等于server中对象上一次修改的时间，则server发送不包含该对象的响应报文（304 Not Modified）</li>
<li>若请求报文的If-modified-since不等于server中对象上一次修改的时间，则server发送包含该对象的响应报文</li>
</ul>
<h3 id="226-http2">2.2.6 HTTP/2</h3>
<p>目标：减小感知时延</p>
<p>手段：经单一TCP连接使请求与响应多路复用，提供请求优先次序和服务器推，提供HTTP首部字段的有效压缩</p>
<h3 id="227-http3">2.2.7 HTTP/3</h3>
<p>使用QUIC协议（基于UDP）</p>
<h2 id="23-电子邮件">2.3 电子邮件</h2>
<p><strong>组成</strong></p>
<ul>
<li>用户代理（user agent）</li>
<li>邮件服务器（mail server）：接收方在服务器中有一个邮箱（mailbox）</li>
<li>简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）：基于TCP</li>
</ul>
<p><strong>邮件传输协议SMTP</strong></p>
<ul>
<li>客户端：发送方邮件服务器</li>
<li>服务器端：接收方邮件服务器</li>
<li>一般不使用中间邮件服务器（邮件不在中间的某个邮件服务器中存留）</li>
<li>也可以使用SMTP将邮件从用户代理上传到邮件服务器</li>
</ul>
<p><strong>邮件访问协议</strong></p>
<ul>
<li>POP3（Post Office Protocol 3，邮局协议版本3）：从邮件服务器下载邮件到本地用户代理，并将邮件服务器上的邮件删除。</li>
<li>IMAP（Internet Mail Access Protocol，因特网邮件访问协议）：通过用户代理访问服务器上的邮件，多种操作同步，反馈同步，也可以下载到本地。</li>
<li>HTTP：通过基于Web的电子邮件或手机上的客户端（Gmail）管理邮件，包括上传和拉取。</li>
</ul>
<p><strong>协议使用</strong></p>
<ul>
<li>发送方用户代理-发送方邮件服务器（push操作）：SMTP/HTTP</li>
<li>发送方邮件服务器-接收方邮件服务器：SMTP</li>
<li>接收方邮件服务器-接收方用户代理（pull操作，接收方用户主动拉取邮件）：POP3/IMAP/HTTP</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250116201946492-1546925745.png" alt="" loading="lazy"></p>
<h2 id="24-dns">2.4 DNS</h2>
<p><strong>域名系统（Domain Name System，DNS）</strong>：提供主机名到IP地址转换的目录服务。</p>
<p><strong>组成</strong></p>
<ul>
<li>
<p>分层的DNS服务器实现的分布式数据库（<strong>Distributed, Hierarchical Database</strong>）</p>
<ol>
<li>根DNS服务器（root）</li>
<li>顶级域DNS服务器（Top-Level Domain，TLD）</li>
<li>权威DNS服务器（authoritative）</li>
<li>*本地DNS服务器（local）：不属于DNS服务器的层次结构，是DNS缓存（接收到DNS响应后，将响应中包含的映射缓存在本地存储器中），可以减少时延和因特网中DNS报文的数量</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250116202000234-654624446.png" alt="" loading="lazy"></p>
</li>
<li>
<p>主机查询该数据库的应用层协议DNS：基于UDP，为了减少时延</p>
</li>
</ul>
<p><strong>分布式的原因</strong></p>
<p>集中式的缺点：</p>
<p>单点故障（single point of failure）：该DNS的崩溃将导致整个网络的瘫痪</p>
<p>通信容量（traffic volume）：单个DNS服务器将处理所有DNS查询</p>
<p>时延：客户距离集中式数据库较远将导致严重的时延</p>
<p>维护（maintenance）：存储的DNS记录数量庞大，更新困难，可扩展性差</p>
<p><strong>提供服务</strong></p>
<ul>
<li>主机名-IP地址</li>
<li>主机别名-规范主机名、IP地址：有着复杂主机名的主机可以拥有一个或多个主机别名（host aliasing），规范主机名（canonical hostname）即主机名</li>
<li>邮件服务器别名-规范主机名、IP地址</li>
<li>负载分配：一个IP地址集合与同一个规范主机名对应，对该主机名的DNS请求，服务器在响应中循环这些IP地址，从而循环分配了负载</li>
</ul>
<p><strong>工作流程</strong></p>
<ul>
<li>应用程序调用DNS客户端（在客户主机上），并指明需要被转换的主机名（包含在URL中）</li>
<li>DNS客户端发送DNS查询报文（使用UDP经端口53传输）</li>
<li>DNS服务器使用迭代查询（iterative query）和/或递归查询（recursive query），最终向DNS客户端发送包含目的IP地址的DNS响应报文</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250116202018610-1644873269.png" alt="" loading="lazy"><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250116202029335-1105310266.png" alt="" loading="lazy"></p>
<p>（左图从请求主机到本地DNS服务器的查询是递归的，其余查询是迭代的；右图是递归查询的例子）</p>
<p><strong>DNS记录和报文</strong></p>
<p>DNS报文</p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250116202039866-1402996876.png" alt="" loading="lazy"></p>
<p>资源记录（Resource Record，RR）：提供了主机名到IP地址的映射，是一个四元组（Name，Value，Type，TTL）</p>
<ul>
<li>
<p>TTL：记录的生存时间</p>
</li>
<li>
<p>Type：记录类型</p>
<ul>
<li>
<p>Type = A，Name为主机名，Value为该主机名对应的IP地址</p>
</li>
<li>
<p>Type = NS，Name为域，Value为知道如何获取该域中主机IP地址的权威DNS服务器的主机名</p>
</li>
<li>
<p>Type = CNAME，Name为主机别名，Value为该主机别名对应的规范主机名</p>
</li>
<li>
<p>Type = MX，Name为邮件服务器别名，Value为该邮件服务器别名对应的规范主机名</p>
</li>
</ul>
</li>
</ul>
<h2 id="25-p2p文件分发">2.5 P2P文件分发</h2>
<p>在P2P文件分发中，每个对等方能够向任何其他对等方重新分发它已经收到的文件的任何部分，从而在分发过程中协助服务器。</p>
<p>分发时间（distribution time）：所有对等方得到分发的文件副本所需要的时间。</p>
<h3 id="251-自扩展性的分析">2.5.1 自扩展性的分析</h3>
<p>考虑以下情况：</p>
<p>一个服务器，N个对等方，服务器要向所有对等方分发一个长度为F的文件，服务器上传时间为u_s，第i个对等方下载时间为d_i，上传时间为u_i，完成文件分发的时间为D。</p>
<p><img src="https://img2024.cnblogs.com/blog/3583944/202501/3583944-20250116202051550-1088823954.png" alt="" loading="lazy"></p>
<p>client-server架构：随着对等放数量的增加，分发时间呈线性增长且无界<br>
$$<br>
D_{cs}\geq max{ \frac{NF}{u_s}, \frac{F}{d_{min}} }<br>
$$<br>
P2P架构：随着对等放数量的增加，分发时间增速趋缓且有界<br>
$$<br>
D_{P2P}\geq max{ \frac F {u_s},\frac F {d_{min}},\frac {NF}{u_s+\sum_{i=1}^{N} u_i} }<br>
$$</p>
<h3 id="252-bittorrent">2.5.2 BitTorrent</h3>
<p>BitTorrent：是一种用于文件分发的P2P协议</p>
<p>洪流（torrent）：参与一个特定文件分发的所有对等方的集合</p>
<p>块（chunk）：一个洪流中的对等方彼此下载等长度的文件块</p>
<p><strong>工作流程</strong></p>
<ul>
<li>
<p>每个洪流有一个基础设施节点<strong>追踪器（tracker）</strong>，新对等方向追踪器注册自己，并周期性地通知追踪器自己仍在洪流中</p>
</li>
<li>
<p>新对等方首次加入洪流时没有块，追踪器从洪流中<strong>随机</strong>选择对等方的子集，并将它们的IP地址发给新对等方</p>
</li>
<li>
<p>新对等方试图与已知对等方建立并行的TCP连接，这些与它成功建立TCP连接的对等方称为它的<strong>邻近对等方</strong></p>
</li>
<li>
<p>新对等方周期性地询问每个邻近对等方拥有的块列表，并基于<strong>最稀缺优先（rarest first）</strong>技术向它当前没有的块发出请求</p>
<ul>
<li>最稀缺优先：优先向邻居中副本数量最少的块发出请求</li>
<li>好处：大致均衡每个块在洪流中的副本数目</li>
</ul>
</li>
<li>
<p>若有其他对等方向它发起请求，它将优先选择当前能够以最高速率向它提供数据的邻居</p>
<ul>
<li>持续测量接收到每个邻居发送的比特的速率，选出以最高速率流入的几个邻居，它们被称为<strong>疏通（unchoked）</strong>，优先响应疏通中的对等方的请求</li>
<li>每过一段时间，还要随机选择另一个邻居（不在疏通中）的请求</li>
<li>好处：能够发现更好的伴侣，使对等方以趋向于找到彼此的协调的速率上载，这种机制被称为“一报还一报”（tit-for-tat）</li>
</ul>
</li>
<li>
<p>一旦某个对等方获得了整个文件，它可能离开洪流，或是留在洪流中继续为其他对等方上载块；任何对等方可能在未获取完整文件时就离开洪流，并可能在以后重新加入洪流</p>
</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0020368018310185187" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-16 20:23">2025-01-16 20:23</span>&nbsp;
<a href="https://www.cnblogs.com/nanyanxin">nanyanxin</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18675714" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18675714);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18675714', targetLink: 'https://www.cnblogs.com/nanyanxin/p/18675714', title: '2 应用层' })">举报</a>
</div>
        