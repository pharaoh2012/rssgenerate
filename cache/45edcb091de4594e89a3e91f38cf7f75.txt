
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/smartloli/p/18639878" title="发布于 2024-12-30 01:15">
    <span role="heading" aria-level="2">深度解析Mamba与状态空间模型：一图带你轻松入门</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h1>1.概述</h1>
<p>Transformer架构无疑是大型语言模型（LLMs）成功背后的核心动力。从开源的Mistral到封闭的ChatGPT，几乎所有主流的LLM都在使用这一架构。然而，随着技术的不断进步，研究者们已经开始探索新的架构，有望在未来挑战Transformer的地位。其中，Mamba作为一种状态空间模型，正在成为备受关注的潜力新星。</p>
<h1>2.内容</h1>
<h2>2.1 什么是Mamba？</h2>
<p>Mamba 是一种新型的架构，通常被归类为状态空间模型（State Space Model，SSM）。它是为了克服传统神经网络架构（如 Transformer）在处理长期依赖和复杂序列数据时的一些局限性而提出的。Mamba 作为一种新的架构，旨在改进大规模语言模型（LLMs）和其他任务的表现，尤其是在生成任务、自然语言理解、时间序列建模等方面。</p>
<h3><strong>1. 背景</strong></h3>
<p>传统的 Transformer 架构虽然在许多任务上表现出色，但它在处理非常长的序列时，尤其是需要捕捉长期依赖关系的任务中，面临着计算和内存瓶颈的问题。Mamba 的提出，正是为了解决这些问题，它借用了状态空间模型的原理，从而能够更高效地建模复杂的时间依赖和序列关系。</p>
<h3><strong>2. 状态空间模型（SSM）是什么？</strong></h3>
<p>状态空间模型是一类数学模型，广泛应用于信号处理和时间序列分析中。其基本思想是通过一个隐含的“状态”来描述系统的演化，而观察到的数据（即输出）是基于这个隐状态的。状态空间模型通常包括一个状态转移方程和一个观测方程，能够有效地捕捉系统的动态变化。</p>
<h3><strong>3. Mamba的核心创新</strong></h3>
<p>Mamba 是在状态空间模型的基础上发展出来的一种架构，它通过引入可变性和灵活性，试图解决 Transformer 在长序列建模中的一些缺陷。具体来说，Mamba 通过设计更高效的模型参数化和状态空间更新机制，使得模型在捕捉长期依赖时不仅更加高效，同时也能够处理更大规模的数据集和更长的序列。</p>
<h3><strong>4.&nbsp;Mamba与Transformer的对比</strong></h3>
<p>&nbsp;</p>
<ul>
<li><strong>计算效率</strong>：Mamba 架构能在处理长序列时显著降低计算和内存的开销，相比于 Transformer 中的自注意力机制，Mamba 更适合于大规模数据的高效处理。</li>
<li><strong>长期依赖捕捉</strong>：Mamba 在处理长期依赖关系方面具有优势，因为它更善于通过状态空间的更新机制维持长期的记忆。</li>
<li><strong>灵活性与扩展性</strong>：Mamba 在多个任务上的表现均有所提升，尤其是在需要动态调节模型参数的场景中，Mamba 表现得更加灵活。</li>
</ul>
<p>Mamba 是在论文《<a href="https://arxiv.org/pdf/2312.00752" target="_blank" rel="noopener nofollow">Mamba: Linear-Time Sequence Modeling with Selective State Spaces</a>》中首次提出的一种新型架构。该论文详细介绍了如何通过选择性状态空间来实现线性时间的序列建模。</p>
<h2>2.2&nbsp;Transformer回顾</h2>
<p>在了解Mamba架构的独特之处之前，我们先回顾一下Transformer模型及其局限性。Transformer以其将文本输入视作由多个标记构成的序列而著称，但这一视角也带来了一些固有的问题。具体来说，Transformer的一个显著缺点是它对长距离依赖的处理方式，这限制了它在某些任务中的表现。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229211926668-1346873051.png" alt="" loading="lazy"></p>
<p>&nbsp;Transformer的一个重要优势在于它能够灵活地“回顾”输入序列中的任何一个先前的标记，无论输入的长度如何。这种自注意力机制使得Transformer能够捕捉到输入中的全局依赖关系，从而生成更准确的表示，尤其适用于处理复杂的文本数据。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229212017148-1731503850.png" alt="" loading="lazy"></p>
<h2>&nbsp;2.3&nbsp;Transformer 的核心组件</h2>
<p>Transformer模型由编码器和解码器两个主要部分组成。编码器负责将输入文本转换为高维表示，而解码器则基于这些表示生成目标文本。通过这种结构的协同工作，Transformer不仅能高效地进行语言翻译，还能广泛应用于文本生成、摘要提取等多种任务。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229212202904-1259891679.png" alt="" loading="lazy"></p>
<p>&nbsp;通过只使用解码器部分，我们可以将Transformer架构应用于生成任务，形成一种新的模型——生成式预训练变换器（GPT）。GPT通过解码器块处理输入文本，并生成相关的输出文本，广泛应用于文本生成、对话系统等领域。与传统的编码器-解码器结构不同，GPT通过纯解码器方式直接进行自回归生成，使得它在生成式任务中表现出色。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229212250231-1621312696.png" alt="" loading="lazy"></p>
<p>解码器块是GPT模型的核心单元，主要包括两个部分：首先是遮蔽自注意力机制，它允许模型在生成文本时只能关注当前及之前的标记，从而避免信息泄漏；其次是前馈神经网络，它对经过自注意力处理后的表示进行进一步的转换和处理。这两个组件的组合使得GPT能够高效地进行文本生成，同时确保生成内容的连贯性和一致性。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229212358667-1846186430.png" alt="" loading="lazy"></p>
<p>&nbsp;自注意力机制是Transformer和GPT模型成功的关键。它使得模型能够在处理输入时同时考虑整个序列的上下文，而无需依赖于传统的局部视窗或固定的窗口大小。具体来说，自注意力通过构建一个矩阵，比较每个标记与前面的标记，矩阵中的权重则反映了标记对之间的相关性强弱。通过这种方式，模型能够更灵活地捕捉到长距离依赖关系，同时保持较高的训练效率。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229212453020-1686022090.png" alt="" loading="lazy"></p>
<p>&nbsp;自注意力机制的一个重要优势是，它能够一次性创建整个矩阵，这意味着在计算注意力时，模型可以同时考虑所有的标记对，而不是依赖于顺序计算。这种并行化处理大大提高了训练效率，尤其是在处理大规模数据时。通过并行计算，不仅加速了训练过程，还使得Transformer模型在处理复杂任务时更加高效和灵活。在训练过程中，这个矩阵是一次性创建的。我们不需要先计算“My”和“name”之间的注意力，再计算“name”和“is”之间的注意力。这使得并行化成为可能，从而大大加速了训练过程！</p>
<p>尽管自注意力机制提供了显著的优势，但在生成下一个标记时，它仍然面临一个挑战：每次生成新标记时，模型都需要重新计算整个序列的注意力。这意味着即使已经生成了一部分文本，模型也需要考虑到整个序列的上下文，重新评估每个标记之间的关系。这种计算开销随着序列长度的增加而加剧，可能影响生成效率。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229221602167-1667547595.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>生成长度为L的序列的标记大约需要L² 的计算，如果序列长度增加，则成本会很高。</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229221626600-1438422277.png" alt="" loading="lazy"></p>
<p>&nbsp;每次生成新标记时，重新计算整个序列的注意力关系使得Transformer架构面临一个显著的瓶颈。这种计算负担随着生成的文本长度增加而加重，导致在生成长文本或进行实时推理时，效率显著下降。因此，尽管Transformer在许多任务中表现出色，但在某些应用场景下，其计算开销可能成为限制性能的关键因素。</p>
<h2>2.4 RNN</h2>
<p>RNN是一种处理序列数据的神经网络，每个时间步不仅依赖当前输入，还会结合前一时间步的隐藏状态，从而生成新的隐藏状态并预测下一步的输出。它通过循环机制在每个时间步传递信息，使得模型能够捕捉序列中的时间依赖关系。为了更直观地理解这一过程，我们可以将RNN“展开”，从而将其表现为一个层层连接的链条，使得每个时间步的信息流动更加清晰。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229222447565-411425913.png" alt="" loading="lazy"></p>
<p>&nbsp;在生成输出时，RNN只需依赖当前时间步的输入和前一个时间步的隐藏状态，这使得它避免了像Transformer那样需要重新计算所有历史隐藏状态的开销。因此，RNN能够在推理阶段高效地进行计算，且随着序列长度的增加，它的计算开销是线性增长的。而在理论上，RNN还可以处理无限长度的上下文，这使得它在一些需要长序列依赖的任务中具有独特优势。为了更好地理解这一点，我们可以将RNN应用到之前的输入文本示例中进行说明。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229222526302-922508773.png" alt="" loading="lazy"></p>
<p>虽然RNN通过将历史信息压缩为隐藏状态来进行序列建模，但这种方式也带来了一个问题——信息的丢失。具体来说，当生成如“Maarten”这样的后续文本时，RNN的最后隐藏状态已经不再记得之前序列中的内容（如“Hello”）。这是因为RNN仅依赖一个前一步的状态来决定当前的隐藏状态，这导致了时间上的信息遗忘。</p>
<p>虽然RNN在推理和训练速度上具有优势，但其准确性往往无法与Transformer等模型相比。为了克服这一缺点，我们转向了状态空间模型，它们能够更高效地利用RNN的优点，同时有时还结合卷积操作，以进一步提高性能。</p>
<h1>3.状态空间模型</h1>
<h2>3.1&nbsp;什么是状态空间</h2>
<p>状态空间是一种数学工具，用来描述一个系统的所有可能状态。在一个问题中，状态空间包含了系统所能达到的所有可能情形。以迷宫为例，状态空间就像是迷宫中所有位置的地图，每个位置代表着一个状态。状态空间表示则是对这张地图的简化，它不仅告诉你当前所处的位置，还会指示你能去的下一个位置以及如何从一个状态转移到另一个状态（例如，向右或向左）。通过这种方式，状态空间模型能够有效地表达复杂系统的动态过程和决策路径。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229222752375-715904222.png" alt="" loading="lazy"></p>
<p>&nbsp;状态空间模型通过方程和矩阵来数学化描述系统的行为，但其核心目的是跟踪系统的状态以及状态之间的转移。例如，在迷宫问题中，我们关心的是当前位置、可以前往的下一步位置，以及如何从当前位置移动到下一个状态。描述这些信息的变量——比如X和Y坐标，以及当前位置到出口的距离——可以通过“状态向量”来表示。状态向量是一个包含所有必要信息的数学向量，用于全面描述系统的当前状态，并为后续的状态转移提供基础。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229222844070-585254912.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;这与语言模型中的 embeddings 或向量非常相似，它们通常用来表示输入序列的“状态”。例如，在处理文本时，每个词语或句子的嵌入向量实际上就是该词或句子的“状态向量”。类似地，状态向量在状态空间模型中用于描述系统在特定时刻的状态，这为模型在后续步骤中进行决策或生成输出提供了基础。比如，假设你在迷宫中的当前位置可以用一个向量表示，在语言模型中，当前句子的嵌入向量也可以用来表示该句子的“状态”。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229223402820-1432717949.png" alt="" loading="lazy"></p>
<p>&nbsp;在神经网络中，系统的“状态”通常指的是其隐藏状态，这个隐藏状态捕捉了模型在特定时间点的所有重要信息。在大型语言模型中，隐藏状态是生成下一个标记的关键，它携带了关于输入序列的上下文信息。每次生成新标记时，模型会根据当前的隐藏状态来决定最可能的下一个标记，从而确保生成的文本与上下文一致。通过这种方式，隐藏状态不仅仅是一个模型的“记忆”，它还在模型的推理过程中起着至关重要的作用。</p>
<h2>3.2&nbsp;什么是状态空间模型</h2>
<p>状态空间模型（SSMs）是一类通过描述状态的表示来做出预测的模型。在传统的状态空间模型中，系统在每个时间步都会根据输入序列（如“向左和向下移动”）更新其状态表示（如“距离出口的距离”和“x/y坐标”），并生成预测输出（如“再次向左移动以更快到达出口”）。然而，与传统的离散序列不同，现代的状态空间模型能够处理连续输入序列，并基于这些连续输入预测输出序列。这种方法使得SSM在处理更复杂和动态的系统时更具灵活性和精确性，尤其是在需要连续决策的任务中。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229223836760-2046438860.png" alt="" loading="lazy"></p>
<p>&nbsp;状态空间模型（SSMs）假设动态系统（例如物体在三维空间中的运动）可以通过其在某一时刻（时间 t）的状态来进行预测。这个预测过程通常依赖于两个关键方程：第一个方程描述了系统的状态如何随时间变化（即系统的动力学），而第二个方程则将该状态映射到系统的观测值或输出。这种建模方式使得SSMs能够准确捕捉系统的动态行为，并根据当前状态预测其未来的状态或输出。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229223952850-1815165378.png" alt="" loading="lazy"></p>
<p>&nbsp;通过求解状态空间模型的方程，我们旨在揭示一种统计原理，即通过观察到的输入数据和先前的状态来预测系统的未来状态。核心目标是找到一个合适的状态表示 h(t)，使得系统能够从给定的输入序列生成对应的输出序列。这种方法使得我们能够在动态系统中进行有效的建模和预测，从而为复杂任务（如机器人控制或自然语言处理）提供一种更加精确的处理框架。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229224035094-2001490621.png" alt="" loading="lazy"></p>
<p>&nbsp;这两个方程构成了状态空间模型的核心，它们分别描述了系统的动态演化和从状态到输出的映射。</p>
<p>在状态空间模型中，状态方程通过矩阵 A 和矩阵 B 来描述系统的动态演化。矩阵 A 表示系统的内在动力学，定义了系统状态如何随着时间变化；而矩阵 B 则表示输入如何影响系统状态的变化。通过这两个矩阵的结合，状态方程能够有效地捕捉输入与系统状态之间的关系，进而预测系统在不同时间步的演化过程。这种建模方式为动态系统的预测和控制提供了强大的数学工具。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229224243484-992640634.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>正如我们之前看到的，h(t) 表示在任意时刻 t 的潜在状态表示，x(t) 表示某些输入。输出方程描述了状态如何被转化为输出（通过矩阵 C），以及输入如何影响输出（通过矩阵 D）。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229224333491-2085545205.png" alt="" loading="lazy"></p>
<p>&nbsp;注意：矩阵A 、B 、C和D也通常被称为参数，因为它们是可学习的。将这两个方程可视化，我们可以得到以下架构：</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229224411703-1238805997.png" alt="" loading="lazy"></p>
<p>让我们逐步了解通用技术，以了解这些矩阵如何影响学习过程。假设我们有一些输入信号x(t)，该信号首先乘以矩阵 B ，该矩阵描述输入如何影响系统。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229224443452-247430471.png" alt="" loading="lazy"></p>
<p>&nbsp;更新后的状态（类似于神经网络的隐藏状态）是一个潜在空间，其中包含环境的核心“知识”。我们将状态与矩阵 A相乘，该矩阵描述了所有内部状态如何连接，因为它们代表了系统的底层动态。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229224506551-1103388128.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>矩阵 A在创建状态表示之前应用，并在状态表示更新后更新。然后，我们使用矩阵 C来描述如何将状态转化为输出。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229224540383-1975968757.png" alt="" loading="lazy"></p>
<p>&nbsp;最后，我们可以利用矩阵 D提供从输入到输出的直接信号。这也通常被称为跳跃连接。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241229224602844-1862098206.png" alt="" loading="lazy"></p>
<p>&nbsp;由于矩阵D类似于跳过连接，因此SSM通常被认为是没有跳过连接的。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241230002236347-1274542478.png" alt="" loading="lazy"></p>
<p>&nbsp;回到简化的视角，我们现在可以将重点放在矩阵A 、B和C作为 SSM 的核心。</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241230002321580-493848394.png" alt="" loading="lazy"></p>
<h2>&nbsp;3.3&nbsp;连续到离散</h2>
<p>在处理连续信号时，找到状态表示 h(t) 是一个挑战，尤其是当信号本身是连续的情况下。为了将模型离散化以适应离散输入（例如文本序列），我们可以使用零阶保持（Zero-order hold）技术。其工作原理是：每次接收到一个离散信号时，我们保持该信号的值，直到下一个新的离散信号到来。这种方法将离散输入信号转化为一个连续信号，从而使得状态空间模型可以更容易地进行处理和计算。通过这种方式，SSM能够在离散输入序列的基础上推导出连续的状态表示。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241230002453030-654467217.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>我们保持该值的时间长短由一个新的可学习参数表示，称为步长∆ 。它表示输入的分辨率。</p>
<p>现在我们有了连续的输入信号，我们可以生成连续的输出，并且仅根据输入的时间步长对值进行采样。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241230002524098-894769734.png" alt="" loading="lazy"></p>
<h2>&nbsp;3.4&nbsp;循环表示</h2>
<p>我们的离散化 SSM 允许我们以特定的时间步长而不是连续信号来制定问题。正如我们之前在 RNN 中看到的，循环方法在这里非常有用。</p>
<p>如果我们考虑离散时间步长而不是连续信号，我们可以用时间步长重新表述问题：</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241230004945631-1603261007.png" alt="" loading="lazy"></p>
<p>&nbsp;在每个时间步，我们计算当前输入（Bxₖ）如何影响之前的状态（Ahₖ₋₁ ），然后计算预测输出（Chₖ）。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241230005010398-316720112.png" alt="" loading="lazy"></p>
<p>这种表示可能看起来有点熟悉！我们可以用之前对 RNN 进行处理的方式来处理它。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241230005039863-1047223632.png" alt="" loading="lazy"></p>
<p>&nbsp;我们可以将其展开（或展开）如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241230005141641-493074782.png" alt="" loading="lazy"></p>
<h2>&nbsp;3.5&nbsp;卷积表示</h2>
<p>我们可以用于 SSM 的另一种表示是卷积。回想一下经典的图像识别任务，我们应用过滤器（内核）来导出聚合特征：</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241230010526088-681033758.png" alt="" loading="lazy"></p>
<p>由于我们处理的是文本而不是图像，因此我们需要一维视角：&nbsp;</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241230010550734-1839250617.png" alt="" loading="lazy"></p>
<p>在实际应用中，SSM核的工作方式与卷积操作类似。我们可以将SSM核应用于输入序列中的每一组标记（tokens），逐步计算每个标记的状态表示，并根据当前的状态和输入计算输出。每次处理一组标记时，核会根据状态空间模型的动态方程来更新状态，最终生成相应的输出。这种方法使得SSM能够在处理序列数据时动态地捕捉每个时间步的变化，从而进行有效的预测和推理，类似于卷积神经网络（CNN）在图像处理中的作用。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241230010627794-318592618.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>这一过程展示了填充操作可能对输出产生的影响。为了更好地进行可视化，我们改变了填充的顺序，但实际上，填充通常会在句子的末尾进行，以保持序列的长度一致。当进行下一步计算时，SSM核会将其移动一个时间步，以便对接下来的标记进行状态更新和输出计算。这种方式确保了整个序列中每个标记都能参与到模型的计算中，同时填充操作在处理变长输入时可以避免信息丢失。</p>
<p>&nbsp;</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241230010651882-1788036104.png" alt="" loading="lazy"></p>
<p>在最终步骤中，我们可以清楚地看到核在整个序列处理中的影响。通过核的每次移动和计算，模型会逐步更新状态表示并生成输出。此时，所有输入标记都已被处理，填充的影响也得到了体现。核的作用不仅仅是捕捉局部信息，还会根据整个序列的上下文对输出做出最终的预测，从而确保模型对输入序列的全面理解。</p>
<p><img src="https://img2024.cnblogs.com/blog/666745/202412/666745-20241230011055625-607142844.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>将SSM表示为卷积的一个重要优点是，它能够像卷积神经网络（CNNs）一样实现并行训练。这使得SSM在处理大规模数据时具有较高的计算效率。然而，尽管并行计算使得训练速度较快，固定的核大小使得它们在推理时不如RNN那样具有快速且不受限制的处理能力。RNN能够根据需要动态调整其计算步长，从而实现对序列的快速推理，而SSM则在推理时受限于核大小，无法像RNN那样灵活地处理无限长的输入序列。</p>
<h1>4.总结</h1>
<p>Mamba结合了状态空间模型（SSM）和卷积架构的优势，通过并行化训练提高了计算效率。在这种架构中，状态通过固定大小的核进行更新，类似于卷积神经网络（CNN）。尽管这种方法在训练上具有优势，推理速度和灵活性不如RNN，后者能够动态处理长序列。总的来说，Mamba与SSM为序列建模提供了一种高效、灵活的框架，尤其适用于需要高效计算和状态转移建模的任务。</p>
<h1>5.结束语</h1>
<p>这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！</p>
<p>另外，博主出新书了《<span style="color: rgba(0, 0, 255, 1)"><strong><a href="https://item.jd.com/14699434.html" rel="noopener nofollow" target="_blank"><span style="color: rgba(0, 0, 255, 1)">深入理解Hive</span></a></strong></span>》、同时已出版的《<strong><a href="https://item.jd.com/12455361.html" rel="noopener nofollow" target="_blank">Kafka并不难学</a></strong>》和《<strong><a href="https://item.jd.com/12371763.html" rel="noopener nofollow" target="_blank">Hadoop大数据挖掘从入门到进阶实战</a></strong>》也可以和新书配套使用，喜欢的朋友或同学， 可以<span style="color: rgba(255, 0, 0, 1)"><strong>在公告栏那里点击购买链接购买博主的书</strong></span>进行学习，在此感谢大家的支持。关注下面公众号，根据提示，可免费获取书籍的教学视频。</p>
</div>
<div id="MySignature" role="contentinfo">
    <div>
<b class="b1"></b><b class="b2 d1"></b><b class="b3 d1"></b><b class="b4 d1"></b>
<div class="b d1 k">  
联系方式：
<br>
邮箱：smartloli.org@gmail.com
<br>
<strong style="color: green">QQ群（Hive与AI实战【新群】）：935396818</strong>
<br>
QQ群（Hadoop - 交流社区1）：424769183
<br>
QQ群（Kafka并不难学）：825943084
<br>
温馨提示：请大家加群的时候写上加群理由（姓名＋公司/学校），方便管理员审核，谢谢！
<br>
<h3>热爱生活，享受编程，与君共勉！</h3>  
</div>
<b class="b4b d1"></b><b class="b3b d1"></b><b class="b2b d1"></b><b class="b1b"></b>
</div>
<br>
<div>
<b class="b1"></b><b class="b2 d1"></b><b class="b3 d1"></b><b class="b4 d1"></b>
<div class="b d1 k">
<h3>公众号：</h3>
<h3><img style="width: 8%; margin-left: 10px" src="https://www.cnblogs.com/images/cnblogs_com/smartloli/1324636/t_qr.png"></h3>
</div>
<b class="b4b d1"></b><b class="b3b d1"></b><b class="b2b d1"></b><b class="b1b"></b>
</div>
<br>
<div>
<b class="b1"></b><b class="b2 d1"></b><b class="b3 d1"></b><b class="b4 d1"></b>
<div class="b d1 k">
<h3>作者：哥不是小萝莉 ［<a style="color: green" href="http://www.kafka-eagle.org/" target="_blank">关于我</a>］［<a style="color: green" href="http://www.cnblogs.com/smartloli/p/4241701.html" target="_blank">犒赏</a>］</h3>
<h3>出处：<a style="color: green" href="http://www.cnblogs.com/smartloli/" target="_blank">http://www.cnblogs.com/smartloli/</a></h3>
<h3>转载请注明出处，谢谢合作！</h3>
</div>
<b class="b4b d1"></b><b class="b3b d1"></b><b class="b2b d1"></b><b class="b1b"></b>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.7093105611458334" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-30 01:15">2024-12-30 01:15</span>&nbsp;
<a href="https://www.cnblogs.com/smartloli">哥不是小萝莉</a>&nbsp;
阅读(<span id="post_view_count">70</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18639878" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18639878);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18639878', targetLink: 'https://www.cnblogs.com/smartloli/p/18639878', title: '深度解析Mamba与状态空间模型：一图带你轻松入门' })">举报</a>
</div>
        