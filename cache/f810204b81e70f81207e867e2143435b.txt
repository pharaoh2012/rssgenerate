
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18925651" title="发布于 2025-06-12 16:09">
    <span role="heading" aria-level="2">接口被刷百万QPS，怎么防？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>大家好，我是苏三。</p>
<p>今天我们不聊风花雪月，只讲这个让无数开发者夜不能寐的终极命题：<strong>当恶意流量如海啸般扑来，如何守住你的系统防线？</strong></p>
<p>有些小伙伴在工作中可能经历过接口被刷的噩梦，但百万QPS量级的攻击完全是另一个维度的战争。</p>
<p>今天这篇文章跟大家一起聊聊接口被刷百万QPS，如何防御，希望对你会有所帮助。</p>
<h2 id="为什么百万qps如此致命">为什么百万QPS如此致命？</h2>
<p>用一张图给解释一下百万QPS的危害：<br>
<img src="https://img2024.cnblogs.com/blog/2238006/202506/2238006-20250612160644725-1742108363.webp" alt="image" loading="lazy"></p>
<p><strong>攻击者三大核心武器：</strong></p>
<ol>
<li><strong>IP海洋战术</strong>：10万+代理IP池动态轮转，传统IP限流失效。</li>
<li><strong>设备克隆技术</strong>：伪造浏览器指纹，模拟真实设备行为。</li>
<li><strong>协议级精准攻击</strong>：精心构造的HTTP请求，绕过基础WAF规则。</li>
</ol>
<p><strong>系统崩溃的致命链反应：</strong></p>
<ul>
<li>线程池100%占用 → 新请求排队超时</li>
<li>数据库连接耗尽 →  SQL执行阻塞</li>
<li>Redis响应飙升 →  缓存穿透雪崩</li>
<li>微服务连环熔断 →  服务不可用</li>
</ul>
<p>那么，我们该如何防御呢？</p>
<h2 id="第一道防线基础限流与熔断">第一道防线：基础限流与熔断</h2>
<h3 id="1-网关层限流">1. 网关层限流</h3>
<p>我们需要在网关层做限流，目前主流的解决方案是：Nginx + Lua。</p>
<p>下面是Nginx的限流配置：</p>
<pre><code class="language-lua">location /api/payment {
    access_by_lua_block {
        local limiter = require "resty.limit.req"
        -- 令牌桶配置：1000QPS + 2000突发容量
        local lim, err = limiter.new("payment_limit", 1000, 2000)
        if not lim then
            ngx.log(ngx.ERR, "限流器初始化失败: ", err)
            return ngx.exit(500)
        end
        
        -- 基于客户端IP限流
        local key = ngx.var.remote_addr
        local delay, err = lim:incoming(key, true)
        
        if not delay then
            if err == "rejected" then
                -- 返回429状态码+JSON错误信息
                ngx.header.content_type = "application/json"
                ngx.status = 429
                ngx.say([[{"code":429,"msg":"请求过于频繁"}]])
                return ngx.exit(429)
            end
            ngx.log(ngx.ERR, "限流错误: ", err)
            return ngx.exit(500)
        end
    }
}
</code></pre>
<p><strong>代码解析：</strong></p>
<ol>
<li>使用OpenResty的<code>lua-resty-limit-req</code>模块</li>
<li>令牌桶算法：1000QPS常规流量 + 2000突发流量缓冲</li>
<li>基于客户端IP维度限流</li>
<li>超出限制返回429状态码和JSON格式错误</li>
</ol>
<h3 id="2-分布式熔断">2. 分布式熔断</h3>
<p>面对大流量时，我们需要增加分布式熔断机制，比如使用Sentinel集群流控。</p>
<p>下面是Sentinel集群的流控配置：</p>
<pre><code class="language-java">public class SentinelConfig {
    @PostConstruct
    public void initFlowRules() {
        // 创建集群流控规则
        ClusterFlowRule rule = new ClusterFlowRule();
        rule.setResource("createOrder"); // 受保护资源
        rule.setGrade(RuleConstant.FLOW_GRADE_QPS); // QPS限流
        rule.setCount(50000); // 集群阈值5万QPS
        rule.setClusterMode(true); // 开启集群模式
        rule.setClusterConfig(new ClusterRuleConfig()
            .setFlowId(123) // 全局唯一ID
            .setThresholdType(1) // 全局阈值
        );
        
        // 注册规则
        ClusterFlowRuleManager.loadRules(Collections.singletonList(rule));
    }
}
</code></pre>
<p>流程图如下：<br>
<img src="https://img2024.cnblogs.com/blog/2238006/202506/2238006-20250612160730609-873957231.webp" alt="image" loading="lazy"></p>
<p><strong>实现原理：</strong></p>
<ol>
<li>Token Server集中管理全集群流量配额</li>
<li>网关节点实时向Token Server申请令牌</li>
<li>当集群总QPS超过阈值时，按比例限制各节点流量</li>
<li>避免单节点限流导致的集群流量不均衡问题</li>
</ol>
<h2 id="第二道防线设备指纹与行为分析">第二道防线：设备指纹与行为分析</h2>
<h3 id="1-浏览器指纹生成">1. 浏览器指纹生成</h3>
<p>前端可以在浏览器上生成指纹，即使客户端IP换了，但相同设备的指纹还是一样的。</p>
<p>前端设备指纹生成方案，这里使用了Canvas+WebGL。</p>
<pre><code class="language-javascript">// 前端设备指纹生成方案
function generateDeviceFingerprint() {
  // 1. 获取基础设备信息
  const baseInfo = [
    navigator.userAgent,
    navigator.platform,
    screen.width + 'x' + screen.height,
    navigator.language
  ].join('|');
  
  // 2. 生成Canvas指纹
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#f60';
  ctx.fillRect(0, 0, 100, 30);
  ctx.fillStyle = '#069';
  ctx.font = '16px Arial';
  ctx.fillText('防御即艺术', 10, 20);
  const canvasData = canvas.toDataURL();
  
  // 3. 生成WebGL指纹
  const gl = canvas.getContext('webgl');
  const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
  const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
  
  // 4. 组合生成最终指纹
  const fingerprint = md5(baseInfo + canvasData + renderer);
  return fingerprint;
}
</code></pre>
<p><strong>指纹特性分析：</strong></p>
<ul>
<li><strong>稳定性</strong>：相同设备多次生成一致性 &gt; 98%</li>
<li><strong>唯一性</strong>：不同设备碰撞概率 &lt; 0.1%</li>
<li><strong>隐蔽性</strong>：用户无感知，无法简单清除</li>
</ul>
<h3 id="2-行为分析模型">2. 行为分析模型</h3>
<p>我们还可以分析用户的行为。</p>
<p>使用下面的鼠标行为分析引擎：</p>
<pre><code class="language-python">import numpy as np

def analyze_mouse_behavior(move_events):
    """
    分析鼠标移动行为特征
    :param move_events: 鼠标移动事件列表 [{'x':100, 'y':200, 't':1680000000}, ...]
    :return: 异常概率(0-1)
    """
    # 1. 计算移动速度序列
    speeds = []
    for i in range(1, len(move_events)):
        prev = move_events[i-1]
        curr = move_events[i]
        dx = curr['x'] - prev['x']
        dy = curr['y'] - prev['y']
        distance = (dx**2 + dy**2) ** 0.5
        time_diff = curr['t'] - prev['t']
        # 防止除零
        speed = distance / max(0.001, time_diff) 
        speeds.append(speed)
    
    # 2. 计算加速度变化
    accelerations = []
    for i in range(1, len(speeds)):
        acc = speeds[i] - speeds[i-1]
        accelerations.append(acc)
    
    # 3. 提取关键特征
    features = {
        'speed_mean': np.mean(speeds),
        'speed_std': np.std(speeds),
        'acc_max': max(accelerations),
        'acc_std': np.std(accelerations),
        'linearity': calc_linearity(move_events)
    }
    
    # 4. 使用预训练模型预测
    return risk_model.predict([features])
</code></pre>
<p><strong>行为特征维度：</strong></p>
<ol>
<li><strong>移动速度</strong>：机器人速度恒定，真人波动大</li>
<li><strong>加速度</strong>：机器人加速度变化呈锯齿状</li>
<li><strong>移动轨迹线性度</strong>：机器人多为直线运动</li>
<li><strong>操作间隔</strong>：机器人操作间隔高度一致</li>
</ol>
<h2 id="第三道防线动态规则引擎">第三道防线：动态规则引擎</h2>
<h3 id="1-实时规则配置">1. 实时规则配置</h3>
<p>我们还可以使用动态规则引擎（比如：Drools引擎），可以配置风控规则。</p>
<p>Drools风控规则示例：</p>
<pre><code class="language-java">rule "高频访问敏感接口"
    // 规则元数据
    salience 100  // 优先级
    no-loop true  // 防止规则循环触发
    
    // 条件部分
    when
        $req : Request(
            path == "/api/coupon/acquire", // 敏感接口
            $uid : userId != null,        // 登录用户
            $ip : clientIp
        )
        
        // 统计同一用户10秒内请求次数
        accumulate(
            Request(
                userId == $uid,
                path == "/api/coupon/acquire",
                this != $req,  // 排除当前请求
                $ts : timestamp
            );
            $count : count($ts),
            $minTime : min($ts),
            $maxTime : max($ts)
        )
        
        // 判断条件：10秒内超过30次请求
        eval($count &gt; 30 &amp;&amp; ($maxTime - $minTime) &lt; 10000)
    then
        // 执行动作：阻断并记录
        insert(new BlockEvent($uid, $ip, "高频领券"));
        $req.setBlock(true);
end
</code></pre>
<p><strong>规则引擎优势：</strong></p>
<ul>
<li><strong>实时生效</strong>：新规则秒级推送</li>
<li><strong>复杂条件</strong>：支持多维度联合判断</li>
<li><strong>动态更新</strong>：无需重启服务</li>
</ul>
<h3 id="2-多维关联分析模型">2. 多维关联分析模型</h3>
<p>我们需要建立一套多维关联分析模型：<br>
<img src="https://img2024.cnblogs.com/blog/2238006/202506/2238006-20250612160754306-337509977.webp" alt="image" loading="lazy"></p>
<p>使用风险评分机制。</p>
<p><strong>评分模型公式：</strong></p>
<pre><code>风险分 = 
  IP风险权重 × IP评分 +
  设备风险权重 × 设备评分 +
  行为异常权重 × 行为异常度 +
  历史画像权重 × 历史风险值
</code></pre>
<h2 id="终极防御架构">终极防御架构</h2>
<p>下面用用一张图总结一下百万QPS防御的架构体系：<br>
<img src="https://img2024.cnblogs.com/blog/2238006/202506/2238006-20250612160812162-1216071696.webp" alt="image" loading="lazy"></p>
<p><strong>核心组件解析：</strong></p>
<ol>
<li>
<p><strong>流量清洗层（CDN）</strong></p>
<ul>
<li>过滤静态资源请求</li>
<li>吸收70%以上流量冲击</li>
</ul>
</li>
<li>
<p><strong>安全防护层（网关集群）</strong></p>
<ul>
<li>设备指纹生成：标记每个请求源</li>
<li>分布式限流：集群级QPS控制</li>
<li>规则引擎：实时判断风险</li>
</ul>
</li>
<li>
<p><strong>实时风控层（Flink计算）</strong></p>
</li>
</ol>
<pre><code class="language-scala">// Flink实时风控处理
riskStream
  .keyBy(req =&gt; req.getDeviceId()) // 按设备ID分组
  .timeWindow(Time.seconds(10))   // 10秒滚动窗口
  .aggregate(new RiskAggregator)  // 聚合风险指标
  .map(riskData =&gt; {
    val score = riskModel.predict(riskData)
    if(score &gt; RISK_THRESHOLD) {
      // 高风险请求阻断
      blockRequest(riskData.getRequestId())
    }
  })
</code></pre>
<ol start="4">
<li><strong>数据支撑层</strong>
<ul>
<li>Redis：存储实时风险画像</li>
<li>Flink：计算行为特征指标</li>
<li>规则管理台：动态调整策略</li>
</ul>
</li>
</ol>
<h2 id="血泪教训">血泪教训</h2>
<h3 id="1-ip白名单的陷阱">1. IP白名单的陷阱</h3>
<p><strong>场景</strong>：将合作方IP加入白名单<br>
<strong>灾难</strong>：攻击者入侵合作方服务器发起攻击<br>
<strong>解决方案</strong>：<br>
<img src="https://img2024.cnblogs.com/blog/2238006/202506/2238006-20250612160829472-879571879.webp" alt="image" loading="lazy"></p>
<p>使用设备指纹校验和行为分析。</p>
<h3 id="2-限流阈值静态设置的灾难">2. 限流阈值静态设置的灾难</h3>
<p><strong>场景</strong>：设置固定5000QPS阈值<br>
<strong>问题</strong>：大促时正常流量超阈值被误杀<br>
<strong>优化方案</strong>：</p>
<pre><code class="language-java">// 动态阈值调整算法
public class DynamicThreshold {
    // 基于历史流量自动调整
    public static int calculateThreshold(String api) {
        // 1. 获取上周同时段流量
        double base = getHistoricalQps(api); 
        // 2. 考虑当日增长系数
        double growth = getGrowthFactor(); 
        // 3. 保留20%安全余量
        return (int)(base * growth * 0.8); 
    }
}
</code></pre>
<h3 id="3-忽略带宽成本">3. 忽略带宽成本</h3>
<p><strong>教训</strong>：10Gbps流量攻击导致月度预算超支200%<br>
<strong>应对策略</strong>：</p>
<ul>
<li>前置CDN吸收静态流量</li>
<li>配置云厂商DDoS防护服务</li>
<li>设置带宽自动熔断机制</li>
</ul>
<blockquote>
<p>真正的防御不是让攻击无法发生，而是让攻击者付出十倍代价却一无所获。当你的防御成本低于对手的攻击成本时，战争就结束了。</p>
</blockquote>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，我的所有文章都会在公众号上首发，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-12 16:09">2025-06-12 16:09</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18925651);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18925651', targetLink: 'https://www.cnblogs.com/12lisu/p/18925651', title: '接口被刷百万QPS，怎么防？' })">举报</a>
</div>
        