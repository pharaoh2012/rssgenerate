<!----> <meta itemprop="headline" content="🔥🔥什么？LocalStorage 也能被监听？为什么我试了却不行？"> <meta itemprop="keywords" content="前端,JavaScript,面试"> <meta itemprop="datePublished" content="2024-09-25T05:47:38.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Sailing"> <meta itemprop="url" content="https://juejin.cn/user/307518988100237"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-7cdd11fb="">
            🔥🔥什么？LocalStorage 也能被监听？为什么我试了却不行？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-7cdd11fb=""><div class="author-info-box" data-v-7cdd11fb=""><div class="author-name" data-v-7cdd11fb=""><a href="/user/307518988100237/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-1800aadb="" data-v-7cdd11fb=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-1800aadb="">
    Sailing
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-7cdd11fb=""><time datetime="2024-09-25T05:47:38.000Z" title="Wed Sep 25 2024 05:47:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-7cdd11fb="">
                    2024-09-25
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-7cdd11fb=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-7cdd11fb=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-7cdd11fb=""></circle></svg> <span class="views-count" data-v-7cdd11fb="">
                    8,663
                  </span> <span class="read-time" data-v-7cdd11fb=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7cdd11fb=""><rect width="16" height="16" fill="none" data-v-7cdd11fb=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-7cdd11fb=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-7cdd11fb=""></path></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-7cdd11fb=""></div> <!----> <!----></div> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-7cdd11fb=""><div class="article-viewer markdown-body result"><blockquote>
<p>引言：最近，团队的伙伴需要实现监听 <code>localStorage</code> 数据变化，但开发中却发现无法直接监听。</p>
</blockquote>
<p>在团队的一个繁重项目中，我们发现一个新功能的实现成本很大，因此开始思考：<strong>能否通过实时监听 LocalStorage 的变化并自动触发相关操作</strong>。我们尝试使用 <code>addEventListener</code> 来监听 <code>localStorage</code> 的变化，但令人意外的是，这种方法仅在<strong>不同浏览器标签页之间</strong>有效，而在<strong>同一标签页内</strong>却无法实现监听。这是怎么回事？</p>
<div align="center">
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a3a62547cf0942b085c7e6148f1e1e06~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2FpbGluZw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1735183721&amp;x-signature=hyivBvRrXIVVm3IZaCkz9lLIJi4%3D" width="80%" loading="lazy">
</div>
<p>经过调研了解到，浏览器确实提供了 <code>storage</code> 事件机制，但它仅适用于同源的不同标签页之间。对于<strong>同一标签页内的 LocalStorage 变化</strong>，却没有直接的方法来实现实时监听。最初，我们考虑使用 <code>setInterval</code> 进行定时轮询来获取变化，但这种方式要么导致性能开销过大，要么无法第一时间捕捉到变化。</p>
<p>今天，我们探讨下几种<strong>高效且实用</strong>的解决方案，是否可以帮助轻松应对<code>LocalStorage</code>这种监听需求？希望对你有所帮助，有所借鉴！</p>
<h3 data-id="heading-0">传统方案的痛点🎯🎯</h3>
<p>先来看看浏览器是如何帮助我们处理<strong>不同页签</strong>的 LocalStorage 变化：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"storage"</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {      
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">key</span> === <span class="hljs-string">"myKey"</span>) {
    <span class="hljs-comment">// 执行相应操作</span>
  }
});
</code></pre>
<p>通过监听 <code>storage</code> 事件，当在其他页签修改 LocalStorage 时，你可以在当前页签捕获到这个变化。但问题是：<strong>这种方法只适用于跨页签的 LocalStorage 修改，在同一页签下无法触发该事件</strong>。于是，很多开发者开始寻求替代方案，比如：</p>
<h4 data-id="heading-1">1、<strong>轮询（Polling）</strong></h4>
<p>轮询是一种最直观的方式，它定期检查 <code>localStorage</code> 的值是否发生变化。然而，这种方法性能较差，尤其在高频轮询时会对浏览器性能产生较大的影响，因此不适合作为长期方案。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">let</span> lastValue = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'myKey'</span>);

<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> newValue = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'myKey'</span>);
  <span class="hljs-keyword">if</span> (newValue !== lastValue) {
    lastValue = newValue;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Detected localStorage change:'</span>, newValue);
  }
}, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 每秒检查一次</span>
</code></pre>
<p>这种方式实现简单，不依赖复杂机制。但是性能较差，频繁轮询会影响浏览器性能。</p>
<h4 data-id="heading-2">2、<strong>监听代理（Proxy）或发布-订阅模式</strong></h4>
<p>这种方式通过创建一个代理来拦截 <code>localStorage.setItem</code> 的调用。每次数据变更时，我们手动发布一个事件，通知其他监听者。</p>
<pre><code class="hljs language-javascript" lang="javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> originalSetItem = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-property">setItem</span>;
  <span class="hljs-keyword">const</span> subscribers = [];

  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-property">setItem</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) {
    originalSetItem.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);
    subscribers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(key, value));
  };

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">callback</span>) {
    subscribers.<span class="hljs-title function_">push</span>(callback);
  }

  <span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'myKey'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Detected localStorage change:'</span>, value);
    }
  });

  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'myKey'</span>, <span class="hljs-string">'newValue'</span>);
})();
</code></pre>
<p>这种比较灵活，可以用于复杂场景。但是需要手动拦截 <code>setItem</code>，维护成本高（但也是值得推荐的）。</p>
<div align="center">
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9bd3ab3acaff433fb0b40d499281dac0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2FpbGluZw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1735183721&amp;x-signature=5qwk1h%2FP8kXH81sh8gwiN5Yixac%3D" width="80%" loading="lazy">
</div>
<p>然而，这些方案往往存在性能问题或者开发的复杂度，在高频数据更新的情况下，有一定的性能问题，而且存在一定的风险性。那么有没有可以简单快速，风险性还小的方案呢？</p>
<h3 data-id="heading-3">高效的解决方案 🚀🚀</h3>
<p>既然浏览器不支持同一页签的 <code>storage</code> 事件，我们可以<strong>手动触发事件</strong>，以此来实现同一页签下的 LocalStorage 变化监听。</p>
<h4 data-id="heading-4">1、自定义 Storage 事件</h4>
<p>通过手动触发 <code>StorageEvent</code>，你可以在 LocalStorage 更新时同步分发事件，从而实现同一页签下的监听。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'myKey'</span>, <span class="hljs-string">'value'</span>);

<span class="hljs-comment">// 手动创建并分发 StorageEvent</span>
<span class="hljs-keyword">const</span> storageEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StorageEvent</span>(<span class="hljs-string">'storage'</span>, {
  <span class="hljs-attr">key</span>: <span class="hljs-string">'myKey'</span>,
  <span class="hljs-attr">url</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>
});
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">dispatchEvent</span>(storageEvent);
</code></pre>
<p>你可以使用相同的监听逻辑来处理数据变化，无论是同一页签还是不同页签：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"storage"</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">key</span> === <span class="hljs-string">"myKey"</span>) {
    <span class="hljs-comment">// 处理 LocalStorage 更新</span>
  }
});
</code></pre>
<p>这种实现简单、轻量、快捷。但是需要手动触发事件。</p>
<h4 data-id="heading-5">2、基于 <code>CustomEvent</code> 的自定义事件</h4>
<p>与 <code>StorageEvent</code> 类似，你可以使用 <code>CustomEvent</code> 手动创建并分发事件，实现 <code>localStorage</code> 的同步监听。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'myKey'</span>, <span class="hljs-string">'newValue'</span>);

<span class="hljs-keyword">const</span> customEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">'localStorageChange'</span>, {
  <span class="hljs-attr">detail</span>: { <span class="hljs-attr">key</span>: <span class="hljs-string">'myKey'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'newValue'</span> }
});
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">dispatchEvent</span>(customEvent);

</code></pre>
<p>这种方式适合更加灵活的事件触发场景。<code>CustomEvent</code>不局限于 <code>localStorage</code> 事件，可以扩展到其他功能。</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'localStorageChange'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { key, value } = event.<span class="hljs-property">detail</span>;
  <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'myKey'</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Detected localStorage change:'</span>, value);
  }
});
</code></pre>
<h4 data-id="heading-6">3、MessageChannel（消息通道）</h4>
<p><code>MessageChannel</code> API 可以在同一个浏览器上下文中发送和接收消息。我们可以通过 <code>MessageChannel</code> 将 <code>localStorage</code> 的变化信息同步到其他部分，起到类似事件监听的效果。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();

channel.<span class="hljs-property">port1</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Detected localStorage change:'</span>, event.<span class="hljs-property">data</span>);
};

<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'myKey'</span>, <span class="hljs-string">'newValue'</span>);
channel.<span class="hljs-property">port2</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'myKey'</span>));
</code></pre>
<p>适合组件通信和复杂应用场景，消息机制较为灵活。相对复杂的实现，可能不适合简单场景。</p>
<h4 data-id="heading-7">4、BroadcastChannel</h4>
<p><code>BroadcastChannel</code> 提供了一种更高级的浏览器通信机制，允许多个窗口或页面之间广播消息。你可以通过这个机制将 <code>localStorage</code> 变更同步到多个页面或同一页面的不同部分。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadcastChannel</span>(<span class="hljs-string">'storage_channel'</span>);

channel.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Detected localStorage change:'</span>, event.<span class="hljs-property">data</span>);
};

<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'myKey'</span>, <span class="hljs-string">'newValue'</span>);
channel.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">key</span>: <span class="hljs-string">'myKey'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'newValue'</span> });
</code></pre>
<p>支持跨页面通信，方便在不同页面间同步数据，易于实现。适用场景较为具体，通常用于复杂的页面通信需求。</p>
<p>这4个方法，主打的就是一个见缝插针，简单快速，风险性低。但是客观角度来讲，每种方案都是有各自优势的。</p>
<h3 data-id="heading-8">优势对比</h3>















































<table><thead><tr><th>方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>轮询</td><td>实现简单，适合低频监控需求</td><td>性能差，频繁轮询影响浏览器性能</td><td>简单场景或临时方案</td></tr><tr><td>监听代理/发布-订阅模式</td><td>灵活扩展，适合复杂项目</td><td>需要手动拦截 <code>setItem</code>，维护成本高</td><td>需要手动事件发布的场景</td></tr><tr><td>自定义 <code>StorageEvent</code></td><td>实现简单，原生支持 <code>storage</code> 事件监听</td><td>需要手动触发事件</td><td>同页签下 <code>localStorage</code> 监听</td></tr><tr><td>自定义事件</td><td>灵活的事件管理，适合不同场景</td><td>需要手动触发事件</td><td>需要自定义触发条件的场景</td></tr><tr><td><code>MessageChannel</code></td><td>适合组件通信和复杂应用场景</td><td>实现复杂，不适合简单场景</td><td>高级组件通信需求</td></tr><tr><td><code>BroadcastChannel</code></td><td>跨页面通信，适合复杂通信需求</td><td>使用场景较具体</td><td>复杂的多窗口通信</td></tr></tbody></table>
<h3 data-id="heading-9">如何在 React / Vue 使用</h3>
<p>在主流前端框架（如 React 和 Vue）中，监听 LocalStorage 变化并不困难。无论是 React 还是 Vue，你都可以使用自定义的 <code>StorageEvent</code> 或其他方法来实现监听。在此，我们以<strong>自定义 <code>StorageEvent</code></strong> 为例，展示如何在 React 和 Vue 中实现 LocalStorage 的监听。</p>
<div align="center">
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6905f4242f91472595aeeb41e8b89872~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2FpbGluZw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1735183721&amp;x-signature=9mo4jxtRbFb1wQrgSsl%2B%2BrzOHII%3D" width="80%" loading="lazy">
</div>
<h4 data-id="heading-10">1. 在 React 中使用自定义 <code>StorageEvent</code></h4>
<p>React 是一个基于组件的框架，我们可以使用 React 的生命周期函数（如 <code>useEffect</code>）来监听和处理 LocalStorage 的变化。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">LocalStorageListener</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 定义 storage 事件监听器</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleStorageChange</span> = (<span class="hljs-params">event</span>) =&gt; {
      <span class="hljs-keyword">if</span> (event.<span class="hljs-property">key</span> === <span class="hljs-string">'myKey'</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Detected localStorage change:'</span>, event.<span class="hljs-property">newValue</span>);
      }
    };

    <span class="hljs-comment">// 添加监听器</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'storage'</span>, handleStorageChange);

    <span class="hljs-comment">// 模拟触发自定义的 StorageEvent</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">triggerCustomStorageEvent</span> = (<span class="hljs-params"></span>) =&gt; {
      <span class="hljs-keyword">const</span> storageEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StorageEvent</span>(<span class="hljs-string">'storage'</span>, {
        <span class="hljs-attr">key</span>: <span class="hljs-string">'myKey'</span>,
        <span class="hljs-attr">newValue</span>: <span class="hljs-string">'newValue'</span>,
        <span class="hljs-attr">url</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>,
      });
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">dispatchEvent</span>(storageEvent);
    };

    <span class="hljs-comment">// 组件卸载时移除监听器</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'storage'</span>, handleStorageChange);
    };
  }, []); <span class="hljs-comment">// 空依赖数组表示该 effect 只会在组件挂载时运行</span>

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> localStorage.setItem('myKey', 'newValue')}&gt;
        修改 localStorage
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> window.dispatchEvent(new StorageEvent('storage', {
        key: 'myKey',
        newValue: localStorage.getItem('myKey'),
        url: window.location.href,
      }))}&gt;
        手动触发 StorageEvent
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">LocalStorageListener</span>;
</code></pre>
<ul>
<li><code>useEffect</code> 是 React 的一个 Hook，用来处理副作用，在这里我们用它来注册和清除事件监听器。</li>
<li>我们手动触发了 <code>StorageEvent</code>，以便在同一页面中监听 LocalStorage 的变化。</li>
</ul>
<h4 data-id="heading-11">2. 在 Vue 中使用自定义 <code>StorageEvent</code></h4>
<p>在 Vue 3 中，我们可以使用 <code>onMounted</code> 和 <code>onUnmounted</code> 这两个生命周期钩子来管理事件监听器。（Vue 3 Composition API）：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click="updateLocalStorage"&gt;修改 localStorage&lt;/button&gt;
    &lt;button @click="triggerCustomStorageEvent"&gt;手动触发 StorageEvent&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { onMounted, onUnmounted } from 'vue';

const handleStorageChange = (event: StorageEvent) =&gt; {
  if (event.key === 'myKey') {
    console.log('Detected localStorage change:', event.newValue);
  }
};

const updateLocalStorage = () =&gt; {
  localStorage.setItem('myKey', 'newValue');
};

const triggerCustomStorageEvent = () =&gt; {
  const storageEvent = new StorageEvent('storage', {
    key: 'myKey',
    newValue: 'newValue',
    url: window.location.href,
  });
  window.dispatchEvent(storageEvent);
};

onMounted(() =&gt; {
  window.addEventListener('storage', handleStorageChange);
});

onUnmounted(() =&gt; {
  window.removeEventListener('storage', handleStorageChange);
});
&lt;/script&gt;
</code></pre>
<ul>
<li>使用了 Vue 的 Composition API，其中 <code>onMounted</code> 和 <code>onUnmounted</code> 类似于 React 的 <code>useEffect</code>，用于在组件挂载和卸载时管理副作用。</li>
<li>同样手动触发了 <code>StorageEvent</code> 来监听同一页面中的 LocalStorage 变化。</li>
</ul>
<h3 data-id="heading-12">提炼封装一下 🚀🚀</h3>
<p>无论是 React 还是 Vue，将自定义 <code>StorageEvent</code> 实现为一个组件或工具函数是常见的做法。你可以将上面的逻辑提取到一个独立的 hook 或工具函数中，方便在项目中多次使用。</p>
<h4 data-id="heading-13">在 React 中提取为 Hook</h4>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">useLocalStorageListener</span> = (<span class="hljs-params">key, callback</span>) =&gt; {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleStorageChange</span> = (<span class="hljs-params">event</span>) =&gt; {
      <span class="hljs-keyword">if</span> (event.<span class="hljs-property">key</span> === key) {
        <span class="hljs-title function_">callback</span>(event.<span class="hljs-property">newValue</span>);
      }
    };

    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'storage'</span>, handleStorageChange);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'storage'</span>, handleStorageChange);
    };
  }, [key, callback]);
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useLocalStorageListener;
</code></pre>
<h4 data-id="heading-14">在 Vue 中提取为工具函数</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { onMounted, onUnmounted } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useLocalStorageListener</span> = (<span class="hljs-params">key: <span class="hljs-built_in">string</span>, callback: (value: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>) =&gt; <span class="hljs-built_in">void</span></span>) =&gt; {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleStorageChange</span> = (<span class="hljs-params">event: StorageEvent</span>) =&gt; {
    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">key</span> === key) {
      <span class="hljs-title function_">callback</span>(event.<span class="hljs-property">newValue</span>);
    }
  };

  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'storage'</span>, handleStorageChange);
  });

  <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'storage'</span>, handleStorageChange);
  });
};
</code></pre>
<ul>
<li>在 React 中，我们创建了一个自定义 Hook <code>useLocalStorageListener</code>，通过传入监听的 key 和回调函数来捕获 LocalStorage 的变化。</li>
<li>在 Vue 中，我们创建了一个工具函数 <code>useLocalStorageListener</code>，同样通过传入 key 和回调函数来监听变化。</li>
</ul>
<h3 data-id="heading-15">总结</h3>
<div align="center">
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f1f01ca364ac48cbbc84aa53b7b9ab23~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2FpbGluZw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1735183721&amp;x-signature=cvTUHzadfckMWeeM%2BD%2BYQBXG79Q%3D" width="80%" loading="lazy">
</div>
<p>在同一个浏览器页签中监听 <code>localStorage</code> 的变化并非难事，但不同场景下需要不同的方案。从简单的轮询到高级的 <code>BroadcastChannel</code>，本文介绍的几种方案各有优缺点。根据你的实际需求，选择合适的方案可以帮助你更高效地解决问题。</p>
<ul>
<li><strong>简单需求</strong>：可以考虑使用自定义 <code>StorageEvent</code> 或 <code>CustomEvent</code> 实现监听。</li>
<li><strong>复杂需求</strong>：对于更高级的场景，如跨页面通信，<code>MessageChannel</code> 或 <code>BroadcastChannel</code> 是更好的选择。</li>
</ul>
<p>如果你有其他的优化技巧或问题，欢迎在评论区分享，让我们一起交流更多的解决方案！</p></div></div>