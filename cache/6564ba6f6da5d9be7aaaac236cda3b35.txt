
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hk416hasu/p/18820166" title="发布于 2025-04-11 16:17">
    <span role="heading" aria-level="2">慢查询解决思路</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文梳理了一些应对数据库慢查询的思路，涵盖索引、存储方式、读写分离、分库分表等方式，不涉及具体实现。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="慢查询解决思路">慢查询解决思路</h1>
<h2 id="1-复现问题">1. 复现问题</h2>
<p>慢查询的出现是常态还是偶尔？是否在业务允许范围内？</p>
<blockquote>
<p>"不要过早优化，先 <strong>Make it work</strong> / right，再 Make it fast。"</p>
</blockquote>
<p>建议先将查询语句及其触发条件记录下来，便于后续测试、分析和对比。</p>
<hr>
<h2 id="2-定位问题">2. 定位问题</h2>
<h3 id="21-单机数据库-explain查询执行计划">2.1 单机数据库: <code>explain</code>查询执行计划</h3>
<p>数据库默认优化后的执行计划是否使用了合适的索引、是否走了全表扫描、排序是否使用了临时表等。然后我们可以进行一些手动优化。</p>
<h3 id="22-分布式场景-尾部延迟放大">2.2 分布式场景: 尾部延迟放大</h3>
<p>任务分片后，部分节点可能由于数据倾斜、垃圾收集、网络丢包等各种原因导致“<strong>尾部慢任务</strong>”，<strong>拖累整体响应时间</strong>。这也要结合业务场景进行适当优化。DDIA中<a href="https://vonng.gitbooks.io/ddia-cn/content/ch1.html#%E6%8F%8F%E8%BF%B0%E6%80%A7%E8%83%BD" target="_blank" rel="noopener nofollow">第三章</a>有详细介绍。</p>
<hr>
<h2 id="3-索引">3. 索引</h2>
<p>索引未命中是常见的慢查询原因，当然前提是得有个索引。如果数据库还没有索引，就赶紧建立一个来加速读取吧。</p>
<h3 id="31-加索引">3.1 加索引</h3>
<p>索引背后的大致思想是：通过保存一下额外的“路标”，从而帮助你<strong>加速</strong>找到想要的数据。</p>
<p>索引是额外衍生的数据，它不会干扰数据系统本身的内容，只会影响查询的性能。</p>
<p>然鹅，<strong>索引不是越多越好</strong>。维护这些索引数据会产生额外的开销，尤其是在写入的时候。如果维护了多份索引，原本仅需一次对主数据的写入，就需要额外再附加多个对于索引的维护操作，造成了<strong>写放大</strong>，可能会大大影响性能。</p>
<p>另外，我们有各种数据结构可用来保存索引数据，如哈希表、B树族、跳表、红黑树等。尽管做业务的时候大概不需要我们去实现某种索引或是存储引擎，但是<strong>了解我们的业务场景与不同数据结构的优劣，并选取其中最合适的那个是相当重要的</strong>。</p>
<h3 id="32-索引未命中场景与解决方案">3.2 索引未命中场景与解决方案</h3>
<ul>
<li><code>LIKE '%xxx'</code> 模糊匹配 → 使用 <strong>全文索引</strong> 或 建立<strong>倒排索引</strong>机制</li>
<li>函数包裹字段，如<code>WHERE DATE(create_time) = '2024-01-01'</code> → 使用 <strong>函数索引</strong> 或 <strong>冗余字段</strong></li>
<li>复合索引未命中 → 遵循 <strong>最左前缀匹配原则</strong></li>
</ul>
<hr>
<h2 id="4-业务场景oltp-or-olap">4. 业务场景：OLTP or OLAP？</h2>
<p>OLTP（OnLine Transaction Processing，联机事务处理）和 OLAP（OnLine Analytical Processing，联机分析处理）是两类典型的数据处理场景：</p>
<ul>
<li><strong>OLTP</strong>：高并发、低延迟，面向单条或少量记录的精准读写（如用户下单、更新库存）。</li>
<li><strong>OLAP</strong>：低并发、大吞吐，面向大批量数据的复杂分析查询（如销售趋势分析、用户画像）。</li>
</ul>
<p>不同的业务场景会对数据库的<strong>存储方式</strong>提出不同需求，尤其是在 Join 操作频繁出现的 OLAP 场景下。</p>
<h3 id="41-行存储row-oriented-storage">4.1 行存储（Row-Oriented Storage）</h3>
<pre><code class="language-txt">[1, "Alice", 20]|[2, "Bob", 21]
</code></pre>
<p>行存储中，数据库以<strong>整行为单位</strong>进行物理存储：同一行的所有字段在磁盘上是<strong>连续</strong>存放的。这使行存储方式很适合适合 OLTP：单行数据的读取与写入非常高效（信息局部性），符合“按主键查找”的常见模式。</p>
<p>然而，行存储的优势在<strong>大数据分析场景</strong>下却变成了劣势： 访问任意列时，都必须读取整行数据，这对于<strong>只需要部分列的分析型查询来说是一种浪费</strong>。比如行存储导致Join操作前不得不将整行加载进内存，即使只依赖部分字段作为连接条件。</p>
<h3 id="42-列存储column-oriented-storage">4.2 列存储（Column-Oriented Storage）</h3>
<pre><code class="language-txt">[1|2],["Alice"|"Bob"],[20|21]
</code></pre>
<p>列存储就是为了解决上述痛点而产生，列存储将每一列<strong>单独存储</strong>为一段连续的数据。这使得它非常适合如下场景：</p>
<ul>
<li>只查询部分字段，如 SELECT name FROM students；</li>
<li>列上的过滤操作，如 <code>WHERE age &gt; 30</code>；</li>
<li><strong>OLAP 场景下的大规模聚合和扫描</strong>；</li>
<li><strong>Join 操作前只需读取连接键列</strong>，极大降低 I/O 成本。</li>
</ul>
<p>在query执行内部阶段，列存储可以大大减少磁盘I/O，只读取参与查询的字段，避免读取非必需的数据，类似于某种“投影下推”。</p>
<p>而在query输出阶段，如果需要其他字段，可以通过如字段相对位置等方式来获取到同元组的其他字段。</p>
<p>当然，<strong>列存储也有缺点</strong>：比如当我们需要写入一行时，每个列page都需要被写入，这显然又增加了磁盘I/O，导致了写入放大，不适合OLTP场景。</p>
<h3 id="43-混合存储-hybrid-storage">4.3 混合存储 （Hybrid Storage）</h3>
<p>计算机系统各部件（包括其子部件）的实现方案似乎都存在不同程度的权衡与取舍，<strong>“我全都要”</strong>似乎是工程师们最常见也最实用的策略：从段页式内存管理，到多层级Cache-RAM-SSD-HDD混合存储体系，再到数据库中的<strong>混合存储</strong>。</p>
<p>它试图融合 <strong>行存储（Row-Oriented）与列存储（Column-Oriented）</strong> 的优势。其核心理念是：</p>
<blockquote>
<p><strong>热数据行存，冷数据列存</strong><br>
—— 对频繁更新的数据采用行存储格式，对只读或历史数据转为列存储格式，提高分析性能。</p>
</blockquote>
<p>具体也有各种实现方式吧，就不详细展开了。</p>
<h3 id="44-冗余字段--反规范化-denormalization">4.4 冗余字段 / 反规范化 （Denormalization）</h3>
<p>那可能有的朋友会说: "我没办法改数据库存储引擎啊，有没有行存储也能加速的方案？"。</p>
<p>有的兄弟，有的！</p>
<p>数据库设计中<strong>规范化（Normalization）</strong>指导着我们要削减冗余，能不重复存储的字段就不重复存储，而是拆成其他表，有需要时再Join起来。</p>
<p>虽然说Hash_Join等Join算法确实很快，但是大数据或业务要求下，我们可以尝试<strong>空间换时间</strong>，在表中存储一些冗余字段来避免大量Join操作。这就是<strong>反规范化（Denormalization）</strong>。</p>
<p>它适用于读多写少、Join操作很频繁、能容忍短时非一致性的业务场景。</p>
<h3 id="45-oltp中online的含义">4.5 OLTP中Online的含义</h3>
<p>“<strong>Online</strong>” 指的是用户操作能<strong>实时</strong>生效，系统<strong>立刻响应</strong>，区别于早期那种<strong>离线批处理系统</strong>（Batch Processing）。</p>
<ul>
<li>批处理：一天处理一次，延迟高但效率高</li>
<li>Online：实时响应，适合交互式应用，比如下单、转账、修改信息等</li>
</ul>
<hr>
<h2 id="5-读写分离">5. 读写分离</h2>
<blockquote>
<p>从一个数据库进行所有的读写操作，现在把它拆分成一个主库、两个从库，并且读写分离。这么做的好处有几点：存储容量增加了，有了备份，使<br>
得安全性增加了，读写分离使得读写效率得以提升（写要比读更加消耗资源，分开后互不干扰） —— 《淘宝技术这十年》</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3320890/202504/3320890-20250411161217267-1363434316.jpg" alt="image" loading="lazy"></p>
<p>读写分离的好处很多，但是也带来了<strong>不一致性</strong>的问题，这是分布式的经典困境：</p>
<blockquote>
<p>分布式追求高性能 -&gt; 多服务器上Shard数据 -&gt; 用复制方案实现Shard -&gt; 一致性问题 -&gt; 强一致性要求会导致低性能</p>
</blockquote>
<p>因此还是需要结合业务场景来决定主从复制的同步细节问题。（实际是笔者菜了，写不来）</p>
<hr>
<h2 id="6-连接池">6. 连接池</h2>
<p>数据库连接是昂贵资源，频繁地建立与释放会造成大量性能浪费。<strong>连接池</strong>的作用就是：创建/复用一批已打开的数据库连接，避免每次都重新连接数据库。</p>
<p>除此之外，连接池还可以限制连接数量上限。避免同时间连接数太多，数据库处理不过来，拖慢整体响应时间。</p>
<p>同理，线程池或者xx池也是类似的，都是为了<strong>复用连接 + 限流保护</strong>。</p>
<hr>
<h2 id="7-分库分表">7. 分库分表</h2>
<ul>
<li><strong>分库</strong>：单台数据库“生命不可承受之重”，需要把数据表拆到多个数据库实例上（通常部署在不同机器）</li>
<li><strong>分表</strong>：某个单表中包含了大量数据，读写压力很大，需要拆分。</li>
</ul>
<p>分库分表主要有<strong>两大问题</strong>：<strong>资源定位</strong> + <strong>跨库/表操作</strong></p>
<h3 id="71-资源拆分与定位">7.1 资源拆分与定位</h3>
<p>资源的拆分通常有两种：</p>
<ul>
<li><strong>按范围拆分（Range Sharding）</strong>：用户ID小于100万的进<code>user_1</code>表，100万~200万进<code>user_2</code>表</li>
<li><strong>按哈希拆分（Hash Sharding）</strong>：<code>user_id % 4</code> 分到4张表
<ul>
<li>但是hash扩容时会导致大量数据的迁移，因此产生了<strong>一致性哈希</strong> 来避免该现象。</li>
</ul>
</li>
</ul>
<p>当上层query来了之后，我们的可以根据当前的资源拆分方式，将query发给持有该资源的服务器，即资源定位。</p>
<h3 id="72-跨库表操作">7.2 跨库/表操作</h3>
<p>当资源分散在各数据库与数据表中，单台数据库是无法完成数据的Join与聚合等操作的。因此我们还需要加个抽象层，来个<strong>Middleware</strong>。</p>
<p>它就可以负责7.1的资源定位工作，还可以将结果获取到自身内存中，并在其内部执行Join与聚合等操作，再返回给上层。</p>
<hr>
<h2 id="8-redis结果缓存">8. Redis结果缓存</h2>
<p>数据库查询慢，那就用缓存挡一挡，就如同：TLB 之于 页表，CPU Cache 之于 内存，浏览器http缓存 之于 应用服务器。</p>
<p><strong>缓存</strong>的核心目标只有一个：用更小、更快的存储，拦住大部分<strong>热点</strong>，减少下层系统压力。</p>
<p>在Redis - 数据库缓冲机制中，除了仅仅缓存热点数据，我们甚至可以缓存热点query，只要有必要。</p>
<p>之于Redis-数据库的数据流向与一致性保证，其他博客已经讲得很好，这里就不赘述了。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.1147881264525463" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-12 09:33">2025-04-11 16:17</span>&nbsp;
<a href="https://www.cnblogs.com/hk416hasu">hk416hasu</a>&nbsp;
阅读(<span id="post_view_count">163</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18820166" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18820166);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18820166', targetLink: 'https://www.cnblogs.com/hk416hasu/p/18820166', title: '慢查询解决思路' })">举报</a>
</div>
        