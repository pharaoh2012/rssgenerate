
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aaronlinv/p/18688725" title="发布于 2025-01-24 08:46">
    <span role="heading" aria-level="2">重拾 SSH：从基础到安全加固</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>安全外壳协议（Secure Shell Protocol，简称SSH）是一种加密的网络传输协议，属于应用层协议。<a href="https://www.openssh.com/" target="_blank" rel="noopener nofollow">OpenSSH</a> 是最流行的 SSH 实现，它是大量操作系统的默认组件</p>
<p>OpenSSH 套件由以下工具组成：</p>
<ul>
<li>远程操作使用：<strong>ssh</strong>, <strong>scp</strong> 和 sftp</li>
<li>密钥管理：ssh-add, ssh-keysign, ssh-keyscan 和 <strong>ssh-keygen</strong></li>
<li>服务端： <strong>sshd</strong>, sftp-server 和 ssh-agent</li>
</ul>
<h2 id="使用-ssh-连接服务器">使用 SSH 连接服务器</h2>
<h3 id="1-客户端创建公私钥对">1. 客户端创建公私钥对</h3>
<p>密钥类型选择 <code>ed25519</code> 椭圆曲线，它生成的公私钥都要比 <code>RSA</code> 更短，具有较高的安全性和性能</p>
<pre><code class="language-sh"># - a KDF (Key Derivation Function) 的迭代次数 默认：16 ，防止暴力破解
# - t 类型
# Ubuntu 22.04 默认：RSA 3072；Mac OS 默认：ED25519 256

# - C 备注，可以备注上创建年月，定期更换私钥
ssh-keygen -a 256 -t ed25519 -C "Brandon+2025-01@MacBook"
# 可以手动指定路径和密码，也可以一路回车
</code></pre>
<p>在 <code>~/.ssh</code> 下会生成公私钥对</p>
<pre><code class="language-sh">.
├── [ 411]  id_ed25519
├── [  98]  id_ed25519.pub

# 私钥需要妥善保管，避免暴露
cat id_ed25519

-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
QyNTUxOQAAACCRtC9cJJBFwvVsp4vV058ci8lSHNrf2qcx8W+umtK7OwAAAKArJx9PKycf...
-----END OPENSSH PRIVATE KEY-----

# .pub 结尾为公钥
cat id_ed25519.pub

ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJG0L1wkkEXC9Wyni9XTnxyLIt/zHxb66a0rs7 Brandon+2025-01@MacBook
</code></pre>
<h3 id="2-在服务器上添加公钥">2. 在服务器上添加公钥</h3>
<p>将上面客户端生成的公钥 <code>ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJG0L1wkkEXC9Wyni9XTnxyLIt/zHxb66a0rs7 Brandon+2025-01@MacBook</code><br>
加入到服务端 <code>~/.ssh/authorized_keys</code>，每个私钥占据一行</p>
<p>也可以使用 `ssh-copy-id</p>
<pre><code class="language-sh">ssh-copy-id -i ~/.ssh/id_ed25519.pub ubuntu@192.168.64.6
</code></pre>
<h3 id="3-客户端-ssh-连接">3. 客户端 ssh 连接</h3>
<pre><code class="language-sh"># 登录的用户名@目标主机的 IP 地址
ssh root@192.168.16.13

# 首次连接某个服务器会提示
The authenticity of host '192.168.16.13 (192.168.16.13)' can't be established.
ED25519 key fingerprint is SHA256:QawKK4qYtzv/WyymFO64Yby5oxo9bVYZu0TQRvLZsL8.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])?
</code></pre>
<p>这是需要要求你通过 <strong>服务端公钥指纹</strong> 来验证服务端的身份，避免中间人攻击。在确认指纹后输入 <code>yes</code> 完成连接，ssh 会将公钥信息写入到 <code>~/.ssh/known_hosts</code> 中。后续连接如果服务端指纹变更，就说明可能出现了中间人攻击，ssh 会在连接时提示指纹不一致</p>
<h4 id="获取服务端公钥指纹">获取服务端公钥指纹</h4>
<p>在 <strong>服务端</strong> <code>/etc/ssh/</code> 下有多对公私钥：</p>
<pre><code class="language-sh">├── [1.3K]  ssh_host_dsa_key
├── [ 609]  ssh_host_dsa_key.pub
├── [ 513]  ssh_host_ecdsa_key
├── [ 181]  ssh_host_ecdsa_key.pub
├── [ 411]  ssh_host_ed25519_key
├── [ 101]  ssh_host_ed25519_key.pub
├── [2.5K]  ssh_host_rsa_key
├── [ 573]  ssh_host_rsa_key.pub
</code></pre>
<p>以 <code>ed25519</code> 为例，查看公钥指纹：</p>
<pre><code class="language-sh"># -l：列出密钥的指纹
# -f：后面跟要查看的文件路径
ssh-keygen -lf /etc/ssh/ssh_host_ed25519_key.pub
256 SHA256:WykOLKFPEwaC42OM8B5EgFBS5RlgV4qvXxkCIxPE6h4 root@VM-12-5-ubuntu (ED25519)
</code></pre>
<p>如果无法登陆服务器，可以直接获取，相对来说还是找管理员索要指纹更加安全</p>
<pre><code class="language-sh">ssh-keyscan -t ed25519 -p 22 192.168.16.13 2&gt;/dev/null | ssh-keygen -E sha256 -lf -
256 SHA256:WykOLKFPEwaC42OM8B5EgFBS5RlgV4qvXxkCIxPE6h4 root@VM-12-5-ubuntu (ED25519)
</code></pre>
<p>关于 ssh 还有一个常见用法，就是测试 GitHub 连通性</p>
<pre><code class="language-sh"># 测试 GitHub 连接
# -T: 禁用伪终端分配

ssh -T git@github.com

# 回应：
# Hi someone! You've successfully authenticated, but GitHub does not provide shell access.
</code></pre>
<h2 id="连接过程">连接过程</h2>
<p>加密连接最重要的就是解决 <strong>密钥传递</strong> 的问题，如果传递密钥时密钥被窃取，那么后续的加密将毫无意义</p>
<p>为了避免传递时泄露密钥，ssh 采用了 <strong>非对称加密算法</strong>，即公私钥的这种方式。服务器和客户端在 <strong>确认对方的公钥是安全的</strong> 之后，就可以通过对方的公钥加密数据，对方通过私钥解密数据，实现安全地传输数据。客户端与服务器连接的具体过程：</p>
<ol>
<li>建立 TCP 连接</li>
<li>协商 <strong>SSH 版本</strong>：SSH1 或 SSH2</li>
<li>协商使用的 <strong>算法</strong>：加密、密钥交换、消息认证码等</li>
<li>用协商好的密钥交换算法（例如 Elliptic Curve Diffie-Hellman）<strong>生成共享密钥</strong>，通过它进行回话的对称加密5</li>
<li>客户端验证服务器身份: 为了防止中间人攻击，比较服务器的公钥指纹或密钥与客户端已知的主机是否一致, 不一致或者首次连接会提示用户验证服务器的公钥指纹</li>
<li>服务器验证用户身份: 服务器验证客户端的身份</li>
<li>会话建立: 身份验证成功后，客户端和服务器之间建立加密的会话</li>
</ol>
<p><a href="https://zh.wikipedia.org/wiki/%E6%A9%A2%E5%9C%93%E6%9B%B2%E7%B7%9A%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E9%87%91%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener nofollow">Elliptic Curve Diffie-Hellman</a>：<br>
双方分别生成一对临时 <strong>公私钥对</strong>，将自己的 <strong>临时公钥</strong> 发送给对方，双方都可以通过 对方临时公钥 + 自己临时私钥 生成 <strong>共享密钥</strong>，这个共享密钥双方相同。<strong>共享密钥</strong> 作为 KDF 的输入，生成多个密钥，用于加密、完整性校验</p>
<p>交换哈希 (Exchange Hash)：为了确保密钥交换过程没有被篡改，SSH 会计算一个交换哈希值，服务器会对交换哈希进行签名（这里用的是服务器私钥，即 <code>/etc/ssh/</code> 下的私钥）。哈希值包含了密钥交换过程中交换的所有数据，包括客户端和服务器版本、算法协商结果、密钥交换参数等</p>
<p>ssh 连接过程的数据包：</p>
<p><img src="https://img2024.cnblogs.com/blog/1929786/202501/1929786-20250123170050410-1584713012.png" alt="" loading="lazy"></p>
<p>从流程可以看出，ssh 虽然可以保证会话传输安全，但是无法保证对方身份的真实性，所以在连接时要 <strong>确认公钥指纹</strong></p>
<h2 id="常见问题">常见问题</h2>
<h3 id="回话保持">回话保持</h3>
<p>删除 <code>authorized_keys</code> 中的 key，该 key 已打开的会话不会被断开</p>
<p>可以通过 pkill 终止特定用户的 SSH 会话：</p>
<pre><code class="language-sh">pkill -u $username sshd
</code></pre>
<h3 id="权限导致登陆失败">权限导致登陆失败</h3>
<p>在 <code>man ssh</code> 中：</p>
<blockquote>
<p>~/.ssh/: the recommended permissions are read/write/execute for the user, and not accessible by others.<br>
~/.ssh/authorized_keys: the recommended permissions are read/write for the user, and not accessible by others.</p>
</blockquote>
<p>保证 <code>~/.ssh</code> <code>authorized_keys</code> 只有 <strong>所有者</strong> 可以访问修改</p>
<p>如果我们修改权限：<code>chmod 666 authorized_keys</code>，这样登陆会失败：</p>
<pre><code class="language-sh">shell failed: ssh failed to authenticate: 'Access denied for 'publickey'. Authentication that can continue: publickey'
</code></pre>
<p>在 sshd 的日志中也可以看到原因：</p>
<pre><code class="language-sh">tail -f /var/log/auth.log

2025-01-17T11:36:41.734631+08:00 iptables sshd[1294]: Authentication refused: bad ownership or modes for file /home/ubuntu/.ssh/authorized_keys
</code></pre>
<h3 id="ssh-子目录中的-config">.ssh 子目录中的 config</h3>
<p>通过 config 简化 ssh 连接</p>
<pre><code class="language-config">Host aliyun
    HostName 192.168.1.100
    User tom
    IdentityFile ~/.ssh/id_rsa
    Port 22
</code></pre>
<pre><code class="language-sh"># ssh $Host 快速连接
ssh aliyun
</code></pre>
<h2 id="安全防护">安全防护</h2>
<h3 id="查看连接">查看连接</h3>
<pre><code class="language-sh"># who 查看当前登录用户的方法。它会显示用户名、终端、登录时间以及远程主机（如果是 SSH 连接）
who

ubuntu   pts/0        2025-01-20 17:43 (192.168.64.1)
</code></pre>
<pre><code class="language-sh"># w 命令提供更详细的信息，包括当前登录用户、他们正在运行的进程、系统负载等。
w
 19:44:32 up 14:48,  2 users,  load average: 0.06, 0.04, 0.00

USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU  WHAT
ubuntu            192.168.64.1     17:43    3days  0.00s  0.05s sshd: ubuntu [priv]
ubuntu            192.168.64.1     17:43    3days  0.00s   ?    sshd: ubuntu [priv]
</code></pre>
<pre><code class="language-sh"># last 命令显示最近登录的用户列表，包括用户名、终端、登录时间、远程主机和登出时间
last

ubuntu   pts/0        192.168.64.1     Mon Jan 20 17:43   still logged in
ubuntu   pts/0        192.168.64.1     Fri Jan 17 11:33 - 11:47  (00:13)
reboot   system boot  6.8.0-51-generic Fri Jan 17 11:33   still running
reboot   system boot  6.8.0-51-generic Thu Jan  9 16:58 - 17:11  (00:13)
ubuntu   pts/0        192.168.64.1     Thu Jan  9 16:57 - 16:58  (00:00)
</code></pre>
<pre><code class="language-sh"># lastlog 命令显示每个用户最后一次登录的时间
lastlog

Username         Port     From                                       Latest
root                                                                **Never logged in**
daemon                                                              **Never logged in**
bin                                                                 **Never logged in**
sys                                                                 **Never logged in**
ubuntu           pts/0    192.168.64.1                              Mon Jan 20 17:43:58 +0800 2025
</code></pre>
<h3 id="安全策略">安全策略</h3>
<h4 id="pkill-会话">pkill 会话</h4>
<pre><code class="language-sh">ps ajfx

   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
1 1621867 1621867 1621867 ?             -1 Ss       0   0:49 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 sta
1621867 2226258 2226258 2226258 ?             -1 Ss       0   0:00  \_ sshd: root@pts/5
2226258 2226414 2226414 2226414 pts/5    2227480 Ss       0   0:00      \_ bash --rcfile /dev/fd/63
2226414 2227480 2227480 2226414 pts/5    2227480 R+       0   0:00          \_ ps ajfx
</code></pre>
<p>通过 SID 可以 kill 掉整个 session，如果 pikill <code>tmux</code> 等软件创建的 session，这些 session 的进程还是会继续运行</p>
<pre><code class="language-sh"># -e: 显示进程将被终止
# -s: 指定一个或多个会话 ID
# pkill -e -s  $SID
pkill -e -s 2226258
</code></pre>
<h3 id="排查用户和密钥">排查用户和密钥</h3>
<p>查看非 root 可登录的账号</p>
<pre><code class="language-bash">awk -F: 'BEGIN {OFS=":"} $3 != 0 &amp;&amp; $7 !~ /\/bin\/false|\/nologin/ {print $1}' /etc/passwd
</code></pre>
<p>查看允许 ssh 登陆的公钥：</p>
<p><strong><code>cat ~/.ssh/authorized_keys</code></strong></p>
<h3 id="禁用密码登陆">禁用密码登陆</h3>
<pre><code class="language-sh">grep PasswordAuthentication /etc/ssh/sshd_config
</code></pre>
<p>注意：这里是 <code>sshd_config</code>，而不是少了 <code>d</code> 的 <code>ssh_config</code></p>
<p>如果 <code>/etc/ssh/sshd_config.d</code> 中的某个文件中定义了某个配置选项，那么它会覆盖 <code>/etc/ssh/sshd_config</code> 文件中相同的配置</p>
<p>例如在 <code>/etc/ssh/sshd_config.d/50-cloud-init.conf</code> 中配置了 <code>PasswordAuthentication yes</code>，那么 <code>/etc/ssh/sshd_config</code> 中修改 <code>PasswordAuthentication</code> 的值都会被覆盖，即密码登陆一直有效，修改为 <code>PasswordAuthentication no</code> 后重新 sshd：<code>sudo systemctl restart sshd</code>，就会提示只允许密钥登陆：</p>
<pre><code class="language-sh">ssh root@192.168.64.6

root@192.168.64.6: Permission denied (publickey).
</code></pre>
<p>如果没有关闭密码登陆，就可能会被暴力破解，查询不同用户被尝试登陆的次数：</p>
<pre><code class="language-bash">grep "Failed password" /var/log/auth.log|perl -e 'while($_=&lt;&gt;){ /for(.*?)from/; print "$1\n";}'|sort|uniq -c|sort -nr
</code></pre>
<pre><code class="language-bash">   5611  root 
   2013  invalid user hadoop 
   1975  invalid user inspur 
   1973  invalid user cloud 
    285  invalid user roo 
    101  invalid user test 
     84  invalid user user 
     72  invalid user admin 
     68  invalid user oracle 
     61  invalid user postgres 
     61  invalid user git 
     48  invalid user ubuntu 
     31  invalid user test1 
     28  invalid user amandabackup 
     24  invalid user pcpqa 
     22  invalid user ftpuser 
     21  invalid user test2 
     21  invalid user chenly 
</code></pre>
<p>查询登陆成功的 IP</p>
<pre><code class="language-bash">grep "Accepted" /var/log/auth.log | awk '{print $11}' | sort | uniq
</code></pre>
<p>其他安全配置可以参考：</p>
<p><a href="https://github.com/Just-Hack-For-Fun/Linux-INCIDENT-RESPONSE-COOKBOOK" target="_blank" rel="noopener nofollow">Linux 应急响应手册 v1.9 - NOP Team</a><br>
<a href="https://learnku.com/server/t/36120" target="_blank" rel="noopener nofollow">如何配置安全的 SSH 服务</a><br>
<a href="https://www.freebuf.com/articles/system/246994.html" target="_blank" rel="noopener nofollow">SSH安全加固指南</a></p>
<h2 id="登陆告警">登陆告警</h2>
<p>在用户登陆时向钉钉发送告警，参考自：<a href="https://blog.k8s.li/linux-login-alarm-telegram.html" target="_blank" rel="noopener nofollow">VPS 安全加固之用户登录后向 telegram 发送登录信息</a></p>
<pre><code class="language-sh">cd /etc/profile.d/
vim ssh-login-alerm.sh
</code></pre>
<pre><code class="language-sh">#!/bin/bash

# 钉钉机器人 Webhook URL
dingtalk_webhook="https://oapi.dingtalk.com/robot/send?access_token=$token" 

# 获取系统信息，并进行转义以避免 JSON 解析错误
message=$(hostname &amp;&amp; TZ=UTC-8 date '+%Y-%m-%d %H:%M:%S' &amp;&amp; who &amp;&amp; w | awk 'BEGIN{OFS="\t"}{print $1,$8}' | sed 's/\\/\\\\/g;s/\n/\\n/g;s/"/\\"/g')

# 使用 curl 发送消息到钉钉机器人
curl -s -X POST \
  -H "Content-Type: application/json" \
  -d "{\"msgtype\":\"text\",\"text\":{\"content\":\"ssh: ${message}\"}}" \
  "${dingtalk_webhook}" || echo "Error sending DingTalk message."

#可选：添加日志记录
echo "$(date '+%Y-%m-%d %H:%M:%S') - SSH login detected. Message sent to DingTalk (or error occurred)." &gt;&gt; /var/log/ssh_login_dingtalk.log
</code></pre>
<pre><code class="language-sh"># 权限设置为 555 ，这样登陆任何用户都会执行告警
chmod 555 /etc/profile.d/ssh-login-alerm.sh
</code></pre>
<p>登陆后钉钉会收到一条消息:</p>
<pre><code>ssh: localhost
2025-01-23 22:17:16
root     pts/0        2025-01-23 22:17 (192.168.64.5)
22:17:16	load
USER	WHAT
root	bash
</code></pre>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener nofollow">Secure Shell - wiki</a><br>
<a href="https://zh.wikipedia.org/wiki/OpenSSH" target="_blank" rel="noopener nofollow">OpenSSH - wiki</a><br>
<a href="https://luciochen.com/archives/189" target="_blank" rel="noopener nofollow">SSH-Keygen的更安全用法</a><br>
<a href="https://www.brandonchecketts.com/archives/its-2023-you-should-be-using-an-ed25519-ssh-key-and-other-current-best-practices" target="_blank" rel="noopener nofollow">It’s 2023. You Should Be Using an Ed25519 SSH Key (And Other Current Best Practices)</a><br>
<a href="https://www.cnblogs.com/LiuYanYGZ/p/14803012.html" target="_blank">验证远程主机SSH指纹</a><br>
<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/SSH.html" target="_blank" rel="noopener nofollow">什么是SSH？</a><br>
<a href="https://www.cnblogs.com/diffx/p/9553587.html" target="_blank">图解SSH原理</a><br>
<a href="https://blog.csdn.net/chen1415886044/article/details/118650286" target="_blank" rel="noopener nofollow">SSH协议解析及wireshark抓包分析</a><br>
<a href="https://www.bilibili.com/video/BV13P4y1o76u" target="_blank" rel="noopener nofollow">SSH协议握手核心过程</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4383980866805556" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-24 13:47">2025-01-24 08:46</span>&nbsp;
<a href="https://www.cnblogs.com/aaronlinv">AaronLin</a>&nbsp;
阅读(<span id="post_view_count">347</span>)&nbsp;
评论(<span id="post_comment_count">3</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18688725" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18688725);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18688725', targetLink: 'https://www.cnblogs.com/aaronlinv/p/18688725', title: '重拾 SSH：从基础到安全加固' })">举报</a>
</div>
        