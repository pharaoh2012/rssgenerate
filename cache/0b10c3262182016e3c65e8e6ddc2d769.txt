
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/SmalBox/p/19034076" title="发布于 2025-08-12 16:00">
    <span role="heading" aria-level="2">【渲染流水线】[几何阶段]-[顶点着色]以UnityURP为例</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/3685400/202508/3685400-20250812160701253-568568307.png" alt="【渲染流水线】[几何阶段]-[顶点着色]以UnityURP为例" class="desc_img">
        URP顶点着色器核心围绕空间变换体系展开，通过模型矩阵(M)、观察矩阵(V)、投影矩阵(P)三级联运算实现模型空间到裁剪空间转换。其特有实现包含TransformObjectToWorld等专用宏替代传统函数，并强制使用Varyings/Attributes结构体命名规范。数据处理模块负责法线/切线计算及TEXCOORD多通道UV传递，通过语义绑定类自动关联输入输出数据。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<ul>
<li><strong>作用</strong>‌：处理模型顶点数据（坐标、法线、UV），输出裁剪空间位置（如顶点的MVP矩阵转换顶点从模型空间到裁剪空间）。</li>
<li><strong>裁剪空间</strong>‌：MVP变换的终点，顶点坐标未归一化，需保留w分量用于深度计算‌</li>
<li>‌<strong>可配置</strong>‌：通过 Shader 代码重写顶点函数（如&nbsp;<code>#pragma vertex vert</code>）。</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<h1 id="核心功能">核心功能</h1>
<ul>
<li><strong>顶点变换‌</strong>：将模型空间顶点位置转换为齐次裁剪空间坐标（positionOS → positionHCS），这是渲染的基础步骤。顶点着色器输出的 SV_POSITION 语义变量决定了最终屏幕位置。</li>
<li>‌<strong>数据预处理‌</strong>：计算法线、切线、UV 等属性，并传递给片元着色器进行光照或纹理采样。例如，对 UV 进行 Tilling 和 Offset 操作以适应贴图重复。</li>
<li>‌<strong>插值数据生成‌</strong>：为片元着色器准备插值数据（如光照贴图坐标、雾效混合因子），确保三角面片内属性的平滑过渡。</li>
</ul>
<h1 id="关键技术应用">关键技术应用‌</h1>
<ul>
<li>‌<strong>GPU Instancing 支持‌</strong>：通过 UNITY_MATRIX_MVP 等宏处理实例化对象的变换矩阵，提升批量渲染效率。</li>
<li>‌<strong>特效实现‌：</strong>
<ul>
<li><strong>顶点偏移‌</strong>：动态修改顶点位置（如 v.positionOS.x += sin(_Time.y)），实现模型扭曲、幽灵效果等动态视觉。</li>
<li><strong>描边技术‌</strong>：通过平滑法线计算（存储在顶点色中）并外扩顶点，实现卡通渲染中的描边效果，避免尖端断裂问题</li>
</ul>
</li>
</ul>
<h1 id="注意事项">注意事项‌</h1>
<ul>
<li><strong>空间转换顺序‌</strong>：透视矫正插值必须在片元着色器中进行，顶点着色器中直接使用屏幕坐标会导致错误。</li>
<li><strong>渲染流程触发‌</strong>：通过 CommandBuffer 提交绘制命令后，GPU 自动执行顶点着色器，无需手动调用</li>
</ul>
<h1 id="顶点的空间转换"><strong>顶点的空间转换</strong></h1>
<ul>
<li>
<p><strong>空间转换的必要性</strong></p>
<p>在渲染管线中，顶点数据需要经历多次坐标变换才能最终呈现在屏幕上。空间转换的核心目的是：</p>
<ol>
<li><strong>统一计算基准</strong>：将模型、光照、相机等数据对齐到同一坐标系</li>
<li><strong>优化渲染效率</strong>：裁剪空间转换后可直接进行视锥剔除</li>
<li><strong>实现视觉效果</strong>：如透视投影、法线贴图等特效依赖特定空间的计算</li>
</ol>
</li>
<li>
<p><strong>模型矩阵（M矩阵）</strong></p>
<p>相关空间：模型空间 → 世界空间</p>
<ul>
<li>
<p><strong>作用</strong>：将顶点从模型局部坐标系转换到全局世界坐标系</p>
</li>
<li>
<p><strong>必要性</strong>‌：</p>
<p>模型空间（局部坐标）仅描述物体自身结构，但场景中所有物体需统一参考系进行交互（如光照、碰撞）。</p>
</li>
<li>
<p>‌<strong>功能</strong>‌：</p>
<ul>
<li>
<p>‌<strong>全局定位</strong>‌：物体位置、旋转、缩放统一到世界坐标系，实现场景布局。</p>
</li>
<li>
<p>‌<strong>物理计算</strong>‌：光照方向（如平行光）、碰撞检测依赖世界坐标。</p>
</li>
<li>
<p>‌<strong>空间关系</strong>‌：计算物体间距离或相对方向（如粒子特效跟随）。</p>
</li>
<li>
<p><strong>关键参数</strong>：</p>
<p><code>unity_ObjectToWorld // 模型→世界矩阵 unity_WorldToObject // 世界→模型逆矩阵</code></p>
</li>
</ul>
</li>
<li>
<p><strong>典型应用</strong>：</p>
<ul>
<li>计算世界坐标：<code>mul(unity_ObjectToWorld, v.vertex)</code></li>
<li>法线转换需使用逆转置矩阵：<code>UnityObjectToWorldNormal()</code></li>
</ul>
</li>
</ul>
<p>技术细节：</p>
<ul>
<li>包含旋转(R)、平移(T)、缩放(S)分量：<strong>M = T × R × S</strong></li>
<li>非统一缩放会导致法线扭曲，必须特殊处理</li>
</ul>
</li>
<li>
<p><strong>观察矩阵（V矩阵）</strong></p>
<p>相关空间：世界空间 → 观察空间</p>
<ul>
<li>
<p><strong>作用</strong>：以摄像机为原点建立右手坐标系</p>
</li>
<li>
<p><strong>必要性</strong>‌：</p>
<p>世界坐标需转换为以摄像机为原点的坐标系，确定顶点相对于摄像机的可见性。</p>
</li>
<li>
<p>‌<strong>功能</strong>‌：</p>
<ul>
<li>‌<strong>裁剪准备</strong>‌：后续裁剪操作需基于摄像机视角（如视锥体裁剪）。</li>
<li>‌<strong>视角相关效果</strong>‌：实现边缘光、雾效等依赖视角方向的特效。</li>
<li><strong>透视校正</strong>‌：齐次除法（<code>x/w, y/w</code>）实现近大远小效果。</li>
<li><strong>深度缓冲</strong>‌：<code>z/w</code>&nbsp;生成标准化深度值 [0,1]，用于遮挡排序。</li>
<li>‌<strong>简化投影</strong>‌：观察空间是投影变换的输入基准。</li>
<li><strong>特性</strong>：
<ul>
<li>Z轴指向摄像机前方</li>
<li>坐标系原点在摄像机位置</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>URP接口</strong>：</p>
<p><code>UNITY_MATRIX_V // 世界→观察矩阵 GetWorldSpaceViewDir() // 获取观察方向</code></p>
</li>
</ul>
<p>计算原理：</p>
<ul>
<li>由摄像机位置/旋转参数构建</li>
<li>实际是<strong>世界→观察</strong>的逆变换</li>
</ul>
</li>
<li>
<p><strong>投影矩阵（P矩阵）</strong></p>
<p>相关空间：观察空间 → 裁剪空间</p>
<ul>
<li><strong>核心功能</strong>：
<ol>
<li>透视/正交投影转换</li>
<li>定义视锥体范围（近/远裁剪面）</li>
<li>生成齐次坐标（w分量用于透视除法）</li>
</ol>
</li>
<li><strong>URP实现</strong>：</li>
</ul>
</li>
</ul>
<p><code>UNITY_MATRIX_P // 观察→裁剪矩阵 UnityObjectToClipPos() // 整合MVP的快捷宏</code><br>
透视矩阵特性：</p>
<ul>
<li>
<p>产生近大远小效果</p>
</li>
<li>
<p>计算公式：</p>
</li>
<li>
<p><code>[x'] = [ (2n)/(r-l) 0 (r+l)/(r-l) 0 ] [x]</code></p>
</li>
<li>
<p><code>[y'] = [ 0 (2n)/(t-b) (t+b)/(t-b) 0 ] [y]</code></p>
</li>
<li>
<p><code>[y'] = [ 0 (2n)/(t-b) (t+b)/(t-b) 0 ] [y]</code></p>
</li>
<li>
<p><code>[w'] = [ 0 0 -1 0 ] [w]</code></p>
</li>
<li>
<p><strong>矩阵组合与应用</strong></p>
<ol>
<li>
<p><strong>完整变换链</strong>：</p>
<p><code>MVP = P × V × M</code></p>
<p><code>clipPos = mul(UNITY_MATRIX_VP, mul(unity_ObjectToWorld, v.vertex))</code></p>
</li>
<li>
<p><strong>URP优化策略</strong>：</p>
<ul>
<li>预计算VP矩阵减少乘法次数</li>
<li>使用<code>TransformXXX</code>系列宏保证跨平台一致性</li>
</ul>
</li>
<li>
<p><strong>调试技巧</strong>：</p>
<ul>
<li>通过Frame Debugger验证各空间坐标</li>
<li>使用<code>Visualize Space</code>着色器调试工具</li>
</ul>
</li>
</ol>
<pre><code class="language-glsl">// URP 顶点着色器片段
v2f vert (Attributes v) {
    v2f o;
    // M 转换：模型 → 世界
    float3 worldPos = TransformObjectToWorld(v.positionOS);
    // V 转换：世界 → 观察
    float3 viewPos = TransformWorldToView(worldPos);
    // P 转换：观察 → 裁剪
    o.positionCS = TransformWViewToHClip(viewPos);
    return o;
}
</code></pre>
</li>
</ul>
<h1 id="urp-顶点着色器中关键功能">URP 顶点着色器中关键功能</h1>
<ul>
<li>
<p><strong>MVP矩阵应用‌</strong></p>
<ul>
<li>
<p>‌<strong>模型空间→裁剪空间转换</strong>‌使用&nbsp;<code>UnityObjectToClipPos</code>&nbsp;宏（内部封装 MVP 矩阵乘法）将顶点坐标转换到裁剪空间：</p>
<pre><code class="language-glsl">hlsl
v2f vert (appdata v) {
    v2f o;
    o.pos = UnityObjectToClipPos(v.vertex); // 等效于 mul(UNITY_MATRIX_VP, mul(unity_ObjectToWorld, v.vertex))
    return o;
}
</code></pre>
</li>
<li>
<p>‌<strong>手动拆分计算</strong>‌（需处理实例化）：</p>
<pre><code class="language-glsl">hlsl
float4 worldPos = mul(unity_ObjectToWorld, v.vertex);
o.pos = mul(UNITY_MATRIX_VP, worldPos);
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>UV采样与变形‌</strong></p>
<ul>
<li>
<p>‌<strong>基础UV传递</strong>‌：通过&nbsp;<code>TEXCOORD0</code>&nbsp;语义传递UV坐标：</p>
<pre><code class="language-glsl">hlsl
struct v2f {
    float2 uv : TEXCOORD0;
    //...
};
o.uv = v.uv; // 直接传递
</code></pre>
</li>
<li>
<p>‌<strong>动态UV偏移</strong>‌（如水流效果）：</p>
<pre><code class="language-glsl">hlsl
o.uv = v.uv + float2(0, _Time.y * _Speed); // 垂直滚动
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>法线处理‌</strong></p>
<ul>
<li>
<p>‌<strong>世界空间法线计算</strong>‌：使用&nbsp;<code>UnityObjectToWorldNormal</code>&nbsp;宏处理非统一缩放：</p>
<pre><code class="language-glsl">hlsl
o.worldNormal = UnityObjectToWorldNormal(v.normal); // 自动处理逆转置矩阵
</code></pre>
</li>
<li>
<p>‌<strong>法线贴图支持</strong>‌：传递切线空间基向量：</p>
<pre><code class="language-glsl">hlsl
o.tangent = UnityObjectToWorldDir(v.tangent.xyz);
o.bitangent = cross(o.normal, o.tangent) * v.tangent.w;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>切线处理‌</strong></p>
<ul>
<li>
<p>‌<strong>切线空间转换</strong>‌：用于法线贴图采样：</p>
<pre><code class="language-glsl">hlsl
struct appdata {
    float4 tangent : TANGENT; // 切线（w分量决定副切线方向）
};
v2f vert(appdata v) {
    o.tangent = mul(unity_ObjectToWorld, float4(v.tangent.xyz, 0)).xyz;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>‌常用功能扩展‌</strong></p>
<ul>
<li>
<p>‌<strong>顶点动画</strong>‌（如正弦波动画）：</p>
<pre><code class="language-glsl">hlsl
v.vertex.y += sin(_Time.y + v.vertex.x) * _Amplitude;
</code></pre>
</li>
</ul>
</li>
<li>
<p>‌<strong>GPU实例化支持</strong>‌：通过&nbsp;<code>UNITY_INSTANCING_BUFFER_START</code>&nbsp;宏传递实例数据。</p>
</li>
<li>
<p>‌<strong>雾效坐标生成</strong>‌：使用&nbsp;<code>UNITY_TRANSFER_FOG</code>&nbsp;宏计算雾效混合因子</p>
</li>
</ul>
<h1 id="urp-顶点着色器-写法与内置管线的区别">URP 顶点着色器 写法与内置管线的区别</h1>
<p>Unity URP 顶点着色器的写法相较内置管线有多处关键差异，主要体现在宏函数、结构命名、Pass配置、文件包含和数据类型上。核心区别如下：</p>
<ul>
<li>
<p>‌<strong>坐标变换宏的使用</strong>‌：</p>
<p>内置管线使用&nbsp;<code>UnityObjectToClipPos</code>（或旧版&nbsp;<code>mul(UNITY_MATRIX_VP, ...)</code>）进行模型到裁剪空间转换；URP 中也支持此宏，但需通过&nbsp;<code>HLSLPROGRAM</code>&nbsp;声明并包含 URP 专属库文件（如&nbsp;<code>Core.hlsl</code>）。</p>
<pre><code class="language-glsl">hlsl
// URP 顶点着色器示例
v2f vert (Attributes v) {
    v2f o;
    o.vertex = TransformObjectToHClip(v.positionOS); // URP 专用宏
    return o;
}
</code></pre>
</li>
<li>
<p>‌<strong>输入输出结构命名惯例</strong>‌：</p>
<p>内置管线常用&nbsp;<code>appdata</code>（输入）和&nbsp;<code>v2f</code>（输出）结构体3；URP 推荐改用&nbsp;<code>Attributes</code>（输入）和&nbsp;<code>Varying</code>（输出）作为命名约定，但非强制要求。</p>
</li>
<li>
<p>‌<strong>Pass 标签与光照处理</strong>‌：</p>
<p>内置管线依赖多 Pass 处理光源（每个动态光源独立 Pass）；URP 通过单 Pass 前向渲染实现光源计算，Pass 标签需设为&nbsp;<code>"LightMode"="UniversalForward"</code>&nbsp;或省略（默认&nbsp;<code>"SRPDefaultUnlit"</code>）。</p>
</li>
<li>
<p>‌<strong>文件包含与编程块</strong>‌：</p>
<p>内置管线使用&nbsp;<code>CGPROGRAM/ENDCG</code>&nbsp;并包含&nbsp;<code>UnityCG.cginc</code>；URP 必须改用&nbsp;<code>HLSLPROGRAM/ENDHLSL</code>，并包含 URP 库文件（如&nbsp;<code>Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl</code>），以避免宏冲突。</p>
</li>
<li>
<p>‌<strong>数据类型限制</strong>‌：</p>
<p>内置管线支持&nbsp;<code>fixed</code>&nbsp;精度类型；URP 中需替换为&nbsp;<code>half</code>（中等精度）。</p>
</li>
<li>
<p>‌<strong>不支持的特性</strong>‌：</p>
<p>URP 完全弃用表面着色器（<code>#pragma surface</code>），仅支持顶点/片元着色器；同时不支持&nbsp;<code>GrabPass</code>，需改用相机不透明纹理或自定义渲染命令实现类似效果</p>
</li>
</ul>
<h1 id="urp中语义解析的核心机制">URP中语义解析的核心机制</h1>
<ul>
<li>
<p><strong>‌语义解析的底层类‌</strong></p>
<ul>
<li>‌<code>ShaderPass</code>&nbsp;与&nbsp;<code>ShaderCompiler</code>：URP 通过&nbsp;<code>ShaderCompiler</code>&nbsp;解析 HLSL 代码中的语义（如&nbsp;<code>POSITION</code>、<code>NORMAL</code>），并将其映射到 GPU 输入槽位。<code>ShaderPass</code>&nbsp;负责将语义与渲染管线阶段绑定。</li>
<li>‌<code>InputLayoutBuilder</code>：在 Unity 底层（如&nbsp;<code>InputLayoutBuilder</code>&nbsp;类）中，语义会被转换为 Direct3D/OpenGL 的顶点属性描述符，定义数据在 GPU 内存中的布局。</li>
</ul>
</li>
<li>
<p><strong>‌自动识别机制‌</strong></p>
<ul>
<li>‌<strong>系统值语义 SV_前缀</strong>‌
<ul>
<li><code>SV_POSITION</code>&nbsp;等系统语义由 GPU 驱动直接识别，光栅化阶段自动读取其值进行屏幕映射和裁剪。</li>
<li>例如，顶点着色器输出的&nbsp;<code>SV_POSITION</code>&nbsp;会被固定管线用于透视除法和视口变换，无需开发者干预。</li>
</ul>
</li>
<li>‌<strong>自定义语义 如&nbsp;TEXCOORD0</strong>‌
<ul>
<li>通过&nbsp;<code>VertexAttribute</code>&nbsp;特性或 HLSL 结构体声明，URP 在编译时自动关联插值器寄存器（如&nbsp;<code>TEXCOORD0</code>&nbsp;对应插值器 0）。</li>
<li>光栅化阶段根据插值规则（如透视校正）生成片元数据，传递给片元着色器。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>‌管线阶段协同‌</strong></p>
<ul>
<li>‌<strong>顶点着色器输出到片元着色器</strong>‌：
<ul>
<li>语义标记的数据（如&nbsp;<code>TEXCOORD0</code>）在几何阶段处理后，由光栅化器插值，最终被片元着色器通过相同语义名读取。</li>
</ul>
</li>
<li>‌<strong>平台适配</strong>‌：
<ul>
<li>URP 的&nbsp;<code>ShaderLibrary</code>&nbsp;通过宏（如&nbsp;<code>UNITY_VERTEX_INPUT_INSTANCE_ID</code>）处理跨平台语义差异，确保 Vulkan/Metal 等 API 兼容。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>‌调试与验证‌</strong></p>
<ul>
<li>‌<strong>帧调试器Frame Debugger</strong>‌：可查看语义数据在管线各阶段的状态（如顶点着色器输出的裁剪空间坐标）。</li>
<li>‌<strong>Shader 变体日志</strong>‌：通过&nbsp;<code>Shader Variant Log Level</code>&nbsp;检查语义是否被正确剥离或保留。</li>
</ul>
</li>
<li>
<p>‌URP 通过&nbsp;<code>ShaderCompiler</code>&nbsp;和底层图形 API 协作解析语义，系统值语义由硬件自动处理，自定义语义则通过插值器寄存器传递，最终实现数据在管线中的流动</p>
</li>
</ul>
<h1 id="常用语义"><strong>常用语义</strong></h1>
<table>
<thead>
<tr>
<th>‌<strong>语义</strong>‌</th>
<th>‌<strong>数据类型</strong>‌</th>
<th>‌<strong>描述</strong>‌</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>POSITION</code></td>
<td><code>float3/float4</code></td>
<td>模型空间顶点坐标‌</td>
</tr>
<tr>
<td><code>NORMAL</code></td>
<td><code>float3</code></td>
<td>模型空间法线向量‌</td>
</tr>
<tr>
<td><code>TANGENT</code></td>
<td><code>float4</code></td>
<td>模型空间切线向量（<code>.w</code>分量存储副切线方向标志）‌</td>
</tr>
<tr>
<td><code>TEXCOORDn</code></td>
<td><code>float2/float4</code></td>
<td>顶点纹理坐标（<code>n=0-7</code>，如<code>TEXCOORD0</code>表示第一组UV）‌</td>
</tr>
<tr>
<td><code>COLOR</code></td>
<td><code>fixed4/float4</code></td>
<td>顶点颜色‌</td>
</tr>
<tr>
<td><code>SV_VertexID</code></td>
<td><code>uint</code></td>
<td>顶点ID</td>
</tr>
<tr>
<td><code>SV_InstanceID</code></td>
<td><code>uint</code></td>
<td>实例ID</td>
</tr>
</tbody>
</table>
<h1 id="texcoord常见用途"><strong>TEXCOORD常见用途</strong></h1>
<p>0: 主UV坐标<br>
1: 光照贴图UV/次UV<br>
2: 动态光照UV<br>
3: 顶点动画数据<br>
4: 烘焙数据/自定义数据<br>
5: 地形混合权重<br>
6: GPU实例化数据<br>
7: 自定义用途</p>
<h1 id="展示了urp顶点着色器中所有常用语义的使用方式"><strong>展示了URP顶点着色器中所有常用语义的使用方式</strong></h1>
<ul>
<li>
<p>包含了POSITION/NORMAL/TANGENT等基础语义</p>
</li>
<li>
<p>演示了TEXCOORD0-7的典型用途分配</p>
</li>
<li>
<p>使用了SV_VertexID和SV_InstanceID实现特殊效果</p>
</li>
<li>
<p>包含了完整的URP着色器结构和必要的HLSL包含文件</p>
</li>
<li>
<p>展示了顶点着色器到片段着色器的数据传递方式</p>
</li>
<li>
<p>URPVertexShaderExample.shader</p>
<pre><code class="language-glsl">// HLSL
Shader "Custom/URPVertexShaderExample"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
        _Color ("Color", Color) = (1,1,1,1)
    }

    SubShader
    {
        Tags { "RenderType"="Opaque" "RenderPipeline"="UniversalPipeline" }
        
        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            struct Attributes
            {
                float4 positionOS   : POSITION;
                float3 normalOS     : NORMAL;
                float4 tangentOS    : TANGENT;
                float4 color        : COLOR;
                float2 uv0          : TEXCOORD0;
                float2 uv1          : TEXCOORD1;
                float2 uv2          : TEXCOORD2;
                float3 uv3          : TEXCOORD3;
                float4 uv4          : TEXCOORD4;
                float2 uv5          : TEXCOORD5;
                float4 uv6          : TEXCOORD6;
                float2 uv7          : TEXCOORD7;
                uint vertexID       : SV_VertexID;
                uint instanceID     : SV_InstanceID;
            };

            struct Varyings
            {
                float4 positionCS   : SV_POSITION;
                float3 normalWS     : TEXCOORD0;
                float4 tangentWS    : TEXCOORD1;
                float4 color        : TEXCOORD2;
                float2 uv           : TEXCOORD3;
                float2 lightmapUV   : TEXCOORD4;
                float3 dynamicLight : TEXCOORD5;
                float3 animData     : TEXCOORD6;
                float4 bakedData    : TEXCOORD7;
            };

            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            CBUFFER_START(UnityPerMaterial)
                float4 _MainTex_ST;
                float4 _Color;
            CBUFFER_END

            Varyings vert(Attributes IN)
            {
                Varyings OUT;
                
                // 使用所有输入语义
                VertexPositionInputs positionInputs = GetVertexPositionInputs(IN.positionOS.xyz);
                VertexNormalInputs normalInputs = GetVertexNormalInputs(IN.normalOS, IN.tangentOS);
                
                OUT.positionCS = positionInputs.positionCS;
                OUT.normalWS = normalInputs.normalWS;
                OUT.tangentWS = float4(normalInputs.tangentWS, IN.tangentOS.w);
                OUT.color = IN.color * _Color;
                
                // 处理各种UV用途
                OUT.uv = TRANSFORM_TEX(IN.uv0, _MainTex);  // 主UV
                OUT.lightmapUV = IN.uv1;                   // 光照贴图UV
                OUT.dynamicLight = float3(IN.uv2, 0);      // 动态光照数据
                OUT.animData = IN.uv3;                     // 顶点动画数据
                OUT.bakedData = IN.uv4;                    // 烘焙数据
                
                // 使用顶点ID和实例ID进行特殊处理
                if (IN.vertexID % 2 == 0) {
                    OUT.color.rgb *= 0.9;
                }
                
                if (IN.instanceID &gt; 0) {
                    OUT.positionCS.y += sin(_Time.y * 2.0 + IN.instanceID) * 0.1;
                }
                
                return OUT;
            }

            half4 frag(Varyings IN) : SV_Target
            {
                half4 col = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, IN.uv) * IN.color;
                return col;
            }
            ENDHLSL
        }
    }
}

</code></pre>
</li>
</ul>
<hr>
<blockquote>
<p><a href="https://blog.csdn.net/chenghai37/category_13021255.html?fromshare=blogcolumn&amp;sharetype=blogcolumn&amp;sharerId=13021255&amp;sharerefer=PC&amp;sharesource=chenghai37&amp;sharefrom=from_link" target="_blank" rel="noopener nofollow">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></p>
</blockquote>
<p>（欢迎点赞留言探讨，更多人加入进来能更加完善这个探索的过程，🙏）</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.004861111111111111" data-date-updated="2025-08-12 16:07">2025-08-12 16:00</span>&nbsp;
<a href="https://www.cnblogs.com/SmalBox">SmalBox</a>&nbsp;
阅读(<span id="post_view_count">60</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19034076);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19034076', targetLink: 'https://www.cnblogs.com/SmalBox/p/19034076', title: '【渲染流水线】[几何阶段]-[顶点着色]以UnityURP为例' })">举报</a>
</div>
        