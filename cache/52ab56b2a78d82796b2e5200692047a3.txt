
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/noear/p/19049421" title="发布于 2025-08-20 20:15">
    <span role="heading" aria-level="2">轻量级流程编排框架，Solon Flow v3.5.0 发布</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        Solon Flow 是一个轻量级流程编排框架，支持 yaml/json 扁平式编排，具有可视化设计器。框架特点包括：支持无状态流程（计算/任务编排、业务规则处理）和有状态流程（审批、长流程）；兼容 Java8-Java24 及主流框架；提供表达式脚本、元数据扩展、事件广播等功能。最新更新统一了状态处理机制，优化了上下文设计，新增循环网关、节点模式等特性，同时调整了接口命名和架构分层。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Solon Flow 是一个轻量级流程编排框架（采用 yaml 或 json 偏平式编排格式）</p>
<ul>
<li>支持无状态流程
<ul>
<li>可用于计算（或任务）的编排场景</li>
<li>可用于业务规则和决策处理型的编排场景</li>
</ul>
</li>
<li>支持有状态流程
<ul>
<li>可用于办公审批型（有状态、可中断，人员参与）的编排场景</li>
<li>可用于长时间流程（结合自动前进，等待介入）的编排场景</li>
</ul>
</li>
</ul>
<p>有可视化的设计器：</p>
<ul>
<li><a href="https://solon.noear.org/flow/designer/" target="_blank" rel="noopener nofollow">https://solon.noear.org/flow/designer/</a></li>
</ul>
<p>同时兼容 java8 ~ java24。也可嵌入到 SpringBoot、jFinal、Vert.x 等框架中使用。嵌入第三方框架的示例：</p>
<ul>
<li><a href="https://gitee.com/solonlab/solon-flow-embedded-examples" target="_blank" rel="noopener nofollow">https://gitee.com/solonlab/solon-flow-embedded-examples</a></li>
<li><a href="https://gitcode.com/solonlab/solon-flow-embedded-examples" target="_blank" rel="noopener nofollow">https://gitcode.com/solonlab/solon-flow-embedded-examples</a></li>
<li><a href="https://github.com/solonlab/solon-flow-embedded-examples" target="_blank" rel="noopener nofollow">https://github.com/solonlab/solon-flow-embedded-examples</a></li>
</ul>
<h2 id="一最近更新了什么">一、最近更新了什么？</h2>
<p>本次更新，统一了“无状态”、“有状态”流程的基础：引擎、驱动。通过上下文来识别是否为有状态及相关支持。</p>
<p>FlowContext 改为接口，增加了两个重要的方法：</p>
<pre><code class="language-java">boolean isStateful();
StatefulSupporter statefulSupporter();
</code></pre>
<p>且，FlowContext 做了分离。解决了，之前在实例范围内不可复用的问题。</p>
<h4 id="兼容说明">兼容说明</h4>
<ul>
<li>stateful 相关概念与接口有调整</li>
<li>FlowContext 改为接口，并移除 result 字段（所有数据基于 model 交换）</li>
<li>FlowContext 内置实现分为：StatelessFlowContext 和 StatefulFlowContext。通过 <code>FlowContext.of(...)</code> 实例化。（也可按需定制）</li>
<li>StateRepository 接口的方法命名调整，与 StatefulSupporter 保持一致性</li>
</ul>
<p>升级请做好调整与测试。</p>
<h4 id="具体更新">具体更新</h4>
<ul>
<li>新增 solon-flow iterator 循环网关（<code>$for</code>, <code>$in</code>）</li>
<li>新增 solon-flow activity 节点流入流出模式（<code>$imode</code>, <code>$omode</code>），用于二次定制开发</li>
<li>添加 solon-flow ChainInterceptor:onNodeStart, onNodeEnd 方法（扩展拦截的能力）</li>
<li>添加 solon-flow 操作：Operation.BACK_JUMP, FORWARD_JUMP</li>
<li>添加 solon-flow FlowContext:incrGet, incrAdd</li>
<li>添加 solon-flow aot 配置</li>
<li>添加 solon-flow StatefulSupporter 接口，方便 FlowContext 对有状态流程提供支持</li>
<li>添加 solon-flow FlowDriver:postHandleTask 方法（允许两段式提交任务执行，利于有状态与无状态的驱动定制）</li>
<li>添加 solon-flow FlowContext:exchanger 方法（可获取 FlowExchanger 实例）</li>
<li>调整 solon-flow FlowContext 拆分为：FlowContext（对外，可复用） 和 FlowExchanger（对内）</li>
<li>调整 solon-flow FlowContext 移除 result 字段（所有数据基于 model 交换）</li>
<li>调整 solon-flow FlowContext get 改为返回 Object（之前为 T），新增 getAs 返回 T（解决 get 不能直接打印的问题）</li>
<li>调整 solon-flow 移除 StatefulSimpleFlowDriver 功能合并到 SimpleFlowDriver（简化为一个驱动，同时支持有状态与无状态流程）</li>
<li>调整 solon-flow 新增 stateless 包，明确 “有状态” 与 “无状态” 两个概念（StatelessFlowContext 和 StatefulFlowContext）</li>
<li>调整 solon-flow FlowStatefulService 接口，每个方法的 context 参数移到最后位（保持一致性）</li>
<li>调整 solon-flow StateRepository 接口的方法命名，与 StatefulSupporter 保持一致性</li>
<li>调整 solon-flow Chain 拆分为：Chain 和 ChainDecl</li>
</ul>
<p>两对拆分类的定位：</p>
<ul>
<li>FlowContext 侧重对外，可复用（用于传参、策略，状态）。有 StatelessFlowContext 和 StatefulFlowContext 两种内置实现。</li>
<li>FlowExchanger 侧重对内，不可复用（用于控制、中间临时状态或变量）</li>
<li>Chain 为运行态（不可修改）</li>
<li>ChainDecl 为声明或配置态（可以随时修改）</li>
</ul>
<p>应用示例：</p>
<pre><code class="language-java">//FlowContext 构建
FlowContext context = FlowContext.of(); //无状态的
FlowContext context = FlowContext.of("1"); //无状态的
FlowContext context = FlowContext.of("1", stateController); //有状态控制的
FlowContext context = FlowContext.of("1", stateController, stateRepository); //有状态控制的和状态持久化的


//Chain 手动声明
Chain chain = new ChainDecl("d3", "风控计算").create(decl -&gt; {
            decl.addNode(NodeDecl.startOf("s").linkAdd("n2"));
            decl.addNode(NodeDecl.activityOf("n1").title("基本信息评分").linkAdd("g1").task("@base_score"));
            decl.addNode(NodeDecl.exclusiveOf("g1").title("分流")
                    .linkAdd("e", l -&gt; l.title("优质用户（评分90以上）").condition("score &gt; 90"))
                    .linkAdd("n2", l -&gt; l.title("普通用户")) //没条件时，做为默认
            );
            decl.addNode(NodeDecl.activityOf("n2").title("电商消费评分").linkAdd("n3").task("@ec_score"));
            decl.addNode(NodeDecl.activityOf("n3").title("黑名单检测").linkAdd("e").task("@bl_score"));
            decl.addNode(NodeDecl.endOf("e").task("."));
        });
</code></pre>
<h2 id="二特色展示">二、特色展示</h2>
<h3 id="1采用-yaml-或-json-偏平式编排格式">1、采用 yaml 或 json 偏平式编排格式</h3>
<p>偏平式编排，没有深度结构（所有节点平铺，使用 link 描述连接关系）。配置简洁，关系清晰</p>
<pre><code class="language-yaml"># c1.yml
id: "c1"
layout: 
  - { id: "n1", type: "start", link: "n2"}
  - { id: "n2", type: "activity", link: "n3"}
  - { id: "n3", type: "end"}
</code></pre>
<p>还支持简化模式（能自动推断的，都会自动处理），具体参考相关说明</p>
<pre><code class="language-yaml"># c1.yml
id: "c1"
layout: 
  - { type: "start"}
  - { task: ""}
  - { type: "end"}
</code></pre>
<h3 id="2表达式与脚本自由">2、表达式与脚本自由</h3>
<pre><code class="language-yaml"># c2.yml
id: "c2"
layout: 
  - { type: "start"}
  - { when: "order.getAmount() &gt;= 100", task: "order.setScore(0);"}
  - { when: "order.getAmount() &gt; 100 &amp;&amp; order.getAmount() &lt;= 500", task: "order.setScore(100);"}
  - { when: "order.getAmount() &gt; 500 &amp;&amp; order.getAmount() &lt;= 1000", task: "order.setScore(500);"}
  - { type: "end"}
</code></pre>
<h3 id="3元数据配置为扩展提供了无限空间">3、元数据配置，为扩展提供了无限空间</h3>
<p>元数据主要有两个作用：（1）为任务运行提供配置支持（2）为视图编辑提供配置支持</p>
<pre><code class="language-yaml"># c3.yml
id: "c3"
layout: 
  - { id: "n1", type: "start", link: "n2"}
  - { id: "n2", type: "activity", link: "n3", meta: {cc: "demo@noear.org"}, task: "@MetaProcessCom"}
  - { id: "n3", type: "end"}
</code></pre>
<p>通过组件方式，实现元数据的抄送配置效果</p>
<pre><code class="language-java">@Component("MetaProcessCom")
public class MetaProcessCom implements TaskComponent {
    @Override
    public void run(FlowContext context, Node node) throws Throwable {
       String cc = node.getMeta("cc");
       if(Utils.isNotEmpty(cc)){
           //发送邮件...
       }
    }
}
</code></pre>
<h3 id="4事件广播与回调支持">4、事件广播与回调支持</h3>
<p>广播（即只需要发送），回调（即发送后要求给答复）</p>
<pre><code class="language-yaml">id: f4
layout:
  - task: |
      //只发送
      context.&lt;String,String&gt;eventBus().send("demo.topic", "hello");  //支持泛型（类型按需指定，不指定时为 object）
  - task: |
      //发送并要求响应（就是要给答复）
      String rst = context.&lt;String,String&gt;eventBus().sendAndRequest("demo.topic.get", "hello");
      System.out.println(rst);
</code></pre>
<h3 id="5支持无状态有状态两种应用">5、支持无状态、有状态两种应用</h3>
<p>支持丰富的应用场景：</p>
<ul>
<li>无状态流程
<ul>
<li>可用于计算（或任务）的编排场景</li>
<li>可用于业务规则和决策处理型的编排场景</li>
</ul>
</li>
<li>有状态流程
<ul>
<li>可用于办公审批型（有状态、可中断，人员参与）的编排场景</li>
<li>可用于长时间流程（结合自动前进，等待介入）的编排场景</li>
</ul>
</li>
</ul>
<p>自身也相当于一个低代码的运行引擎（单个配置文件，也可满足所有的执行需求）。</p>
<h3 id="6驱动定制是像-jdbc-有-mysql-postgresql还可能有-elasticsearch">6、驱动定制（是像 JDBC 有 MySql, PostgreSQL，还可能有 Elasticsearch）</h3>
<p>这是一个定制后的，支持基于状态驱动的流引擎效果。</p>
<pre><code class="language-java">public class DemoFlowDriver implements FlowDriver {
    ...
}

FlowEngine flowEngine =FlowEngine.newInstance(new DemoFlowDriver());

StateController stateController = new ActorStateController("actor");
StateRepository stateRepository = new InMemoryStateRepository();
                
var context = FlowContext.of("i1", stateController, stateRepository).put("actor", "陈鑫");

//获取上下文用户的活动节点
var task = flowEngine.statefulService().getTask("f1", context);

assert "step2".equals(task.getNode().getId());
assert StateType.UNKNOWN == task.getState(); //没有权限启动任务（因为没有配置操作员）

//提交操作
flowEngine.statefulService().postOperation(context, "f1", task.getNode().getId(), Operation.FORWARD);
</code></pre>
<p>流程配置样例：</p>
<pre><code class="language-yaml">id: f1
layout:
  - {id: step1, title: "发起审批", type: "start"}
  - {id: step2, title: "抄送", meta: {cc: "吕方"}, task: "@OaMetaProcessCom"}
  - {id: step3, title: "审批", meta: {actor: "陈鑫", cc: "吕方"}, task: "@OaMetaProcessCom"}
  - {id: step4, title: "审批", type: "parallel", link: [step4_1, step4_2]}
  - {id: step4_1, meta: {actor: "陈宇"}, link: step4_end}
  - {id: step4_2, meta: {actor: "吕方"}, link: step4_end}
  - {id: step4_end, type: "parallel"}
  - {id: step5, title: "抄送", meta: {cc: "吕方"}, task: "@OaMetaProcessCom"}
  - {id: step6, title: "结束", type: "end"}
</code></pre>
<p>对于驱动器的定制，我们还可以：定制（或选择）不同的脚本执行器、组件容器实现等。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-20 20:15">2025-08-20 20:15</span>&nbsp;
<a href="https://www.cnblogs.com/noear">带刺的坐椅</a>&nbsp;
阅读(<span id="post_view_count">63</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19049421);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19049421', targetLink: 'https://www.cnblogs.com/noear/p/19049421', title: '轻量级流程编排框架，Solon Flow v3.5.0 发布' })">举报</a>
</div>
        