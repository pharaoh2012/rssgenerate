
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/1214804270hacker/p/18823452" title="发布于 2025-04-13 17:24">
    <span role="heading" aria-level="2">微信助手的开发思路及作品</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p><span data-cke-copybin-start="1">​</span></p>
<p><span id="cke_bm_287S">&nbsp;</span></p>
<p><img src="https://img2024.cnblogs.com/blog/1113894/202504/1113894-20250413172102064-464725540.png" alt="" height="895" width="1200"></p>
<p id="1744536064134"></p>
<h1>开发初衷</h1>
<p>微信当今成为现代国人离不开的通讯的工具，已然成为了作为人的“一部分”，随之弊端也愈演愈烈，工作、社交、日常生活都渗透在微信中，一时间不关注它就生怕错过了什么。我便思考：有没有什么助手可以帮助我托管微信，就像玩斗地主或者打游戏，我不得不离开电脑或手机时，它可以临时的替代我机械的“在线”。我在网上找各种各样的助手，但是没有合适的，我便想着能不能自己做一款。</p>
<h2><a id="_6"></a>思路</h2>
<p>微信软件本身的思路非常简单，信息的接收无非是通讯消息，这一块的处理方式我们只需要劫持通讯信息，获取通讯信息后再将信息放回原来的通讯即可；难点就在于发送消息，发送消息该如何做？这一定要渗透到微信的内存和进程内部才行，就不得不使用注入技术。</p>
<h2><a id="_10"></a>探寻底层原理</h2>
<p>如果要做获取微信本身信息的操作，则一定是获取微信占用的内存进行读取，比如：</p>
<ul>
<li>获取联系人，则是遍历一块特定的内存空间；</li>
<li>获取当前登录微信信息，则是获取一块特定的内存空间；</li>
<li>获取当前微信的设置项，也是获取一块特别的内存空间；</li>
<li>…</li>
</ul>
<p>如果要做一些“行为”，则一定是获取微信的进程，调用进程中的模块，比如：</p>
<ul>
<li>需要发送消息时，模拟微信发送消息，组装好消息体，调用微信发送消息的模块；</li>
<li>通过好友验证，则是组装好验证信息，调用微信的验证模块；</li>
<li>转发信息，则是拿到劫持的信息获取指定ID，组装转发信息，调用微信转发模块；</li>
<li>…</li>
</ul>
<p>如果要做一些需要调用微信协议获取的信息，依然是调用模块，自然会通过模块触发协议，比如：</p>
<ul>
<li>获取指定好友的全部信息，需要组装好请求体，直接调用获取好友详情模块即可。</li>
</ul>
<p>打个比方，这就需要我们派一个间谍打入微信内部，通过电报（RPC）和间谍（DLL）对外进行消息交换：</p>
<p><strong>DLL 负责拦截、伪装，这就需要拦截技术（Hook）；</strong><br><strong>RPC 负责传送消息，涉及到跨进程间通信，本项目使用的是远程过程调用（Remote Procedure Call）；</strong></p>
<p>当微信收到消息时，间谍（DLL）把消息通过 RPC 传给 外部；<br>需要发送消息时，会将信息通过 RPC 传递给间谍（DLL） “假传圣旨”发送出去</p>
<p>这一切的实现都要基于注入技术，也就是进入微信的进程才能达到目的。</p>
<h2><a id="_37"></a>注入原理</h2>
<p>首先介绍一下注入（Inject）技术。</p>
<p>注入技术通常都跟恶意软件有关，一般是为了在目标进程中执行自定义代码。注入技术有很多，本项目选取了最经典的一种：<strong>将 DLL 的路径写入微信进程的虚拟地址空间，然后通过在微信进程中创建一个远程线程来加载DLL</strong>。</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" tabindex="-1" role="region" contenteditable="false" aria-label="代码段 小部件" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="6" data-cke-widget-wrapper="1">
<pre class="cke_widget_element highlighter-hljs" data-cke-widget-data="%7B%22code%22%3A%22%20%2F%2F%201.%20%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%B9%B6%E5%9C%A8%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8C%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%5Cn%20%20%20%20HANDLE%20hProcess%20%20%20%20%20%20%20%3D%20OpenProcess(PROCESS_ALL_ACCESS%2C%20FALSE%2C%20pid)%3B%5Cn%20%20%20%20LPVOID%20pRemoteAddress%20%3D%20VirtualAllocEx(hProcess%2C%20NULL%2C%201%2C%20MEM_COMMIT%2C%20PAGE_READWRITE)%3B%5Cn%5Cn%20%20%20%20%2F%2F%202.%20%E6%8A%8A%20dll%20%E7%9A%84%E8%B7%AF%E5%BE%84%E5%86%99%E5%85%A5%E5%88%B0%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%AD%5Cn%20%20%20%20if%20(pRemoteAddress)%20%7B%5Cn%20%20%20%20%20%20%20%20WriteProcessMemory(hProcess%2C%20pRemoteAddress%2C%20dllPath%2C%20wcslen(dllPath)%20*%202%20%2B%202%2C%20%26dwWriteSize)%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20MessageBox(NULL%2C%20L%5C%22DLL%20%E8%B7%AF%E5%BE%84%E5%86%99%E5%85%A5%E5%A4%B1%E8%B4%A5%5C%22%2C%20L%5C%22InjectDll%5C%22%2C%200)%3B%5Cn%20%20%20%20%20%20%20%20return%20-1%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%2F%2F%203.%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%AE%A9%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E8%B0%83%E7%94%A8%20LoadLibrary%5Cn%20%20%20%20hThread%20%3D%20CreateRemoteThread(hProcess%2C%20NULL%2C%200%2C%20(LPTHREAD_START_ROUTINE)LoadLibrary%2C%20pRemoteAddress%2C%20NULL%2C%20NULL)%3B%5Cn%20%20%20%20if%20(hThread)%20%7B%5Cn%20%20%20%20%20%20%20%20WaitForSingleObject(hThread%2C%20-1)%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20MessageBox(NULL%2C%20L%5C%22LoadLibrary%20%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%5C%22%2C%20L%5C%22InjectDll%5C%22%2C%200)%3B%5Cn%20%20%20%20%20%20%20%20return%20-2%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20CloseHandle(hThread)%3B%5Cn%20%20%20%20VirtualFreeEx(hProcess%2C%20pRemoteAddress%2C%200%2C%20MEM_RELEASE)%3B%5Cn%20%20%20%20CloseHandle(hProcess)%3B%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code> // 1. 获取目标进程，并在目标进程的内存里开辟空间
    HANDLE hProcess       = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    LPVOID pRemoteAddress = VirtualAllocEx(hProcess, NULL, 1, MEM_COMMIT, PAGE_READWRITE);

    // 2. 把 dll 的路径写入到目标进程的内存空间中
    if (pRemoteAddress) {
        WriteProcessMemory(hProcess, pRemoteAddress, dllPath, wcslen(dllPath) * 2 + 2, &amp;dwWriteSize);
    } else {
        MessageBox(NULL, L"DLL 路径写入失败", L"InjectDll", 0);
        return -1;
    }

    // 3. 创建一个远程线程，让目标进程调用 LoadLibrary
    hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibrary, pRemoteAddress, NULL, NULL);
    if (hThread) {
        WaitForSingleObject(hThread, -1);
    } else {
        MessageBox(NULL, L"LoadLibrary 调用失败", L"InjectDll", 0);
        return -2;
    }
    CloseHandle(hThread);
    VirtualFreeEx(hProcess, pRemoteAddress, 0, MEM_RELEASE);
    CloseHandle(hProcess);</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1113894/202504/1113894-20250413172030608-1924371212.gif" class="cke_reset cke_widget_drag_handler" height="15" width="15" data-cke-widget-drag-handler="1"></span></div>
<h3><a id="_69"></a>拦截伪装</h3>
<p>通过注入技术，成功将 DLL（间谍）打入了微信内部，下一步要做的事情便是让DLL（间谍）能“劫持”微信消息和“假传圣旨”，这需要使用拦截、伪装技术。</p>
<h3><a id="_72"></a>拦截</h3>
<p>拦截技术通常被称为 Hook。</p>
<p>为了介绍拦截技术，需要先说一说运行的流程。运行大体需要经历：</p>
<ol>
<li>创建程序进程，加载程序代码、数据，创建、映射虚拟地址空间</li>
<li>创建主线程，运行程序</li>
<li>在编译阶段，编译器便把代码里的指令安放到代码段。当程序被加载到虚拟地址空间的时候，代码段便被映射过去。于是，我们程序里的函数，便可以用一个地址（是不是想起了指针？）代替。</li>
</ol>
<p>当微信接收到一条新消息，需要展示给用户的时候，可以想象，肯定会调用某个函数，把消息展示出来。<strong>如果我们把这个函数换成咱们的函数，就可以拦截微信的消息了。</strong>&nbsp;前面提到，在程序运行的时候，所谓函数不过是个地址指向，所以我们只要把这个地址指向咱们自己的函数，便实现了拦截。</p>
<p>举个例子：</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" tabindex="-1" role="region" contenteditable="false" aria-label="代码段 小部件" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="5" data-cke-widget-wrapper="1">
<pre class="cke_widget_element highlighter-hljs" data-cke-widget-data="%7B%22code%22%3A%22%23%20%E6%89%93%E4%B8%AA%E6%AF%94%E6%96%B9%EF%BC%8C%E5%BD%93%E5%BE%AE%E4%BF%A1%E6%94%B6%E5%88%B0%E6%B6%88%E6%81%AF%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%81%87%E8%AE%BE%E8%B0%83%E7%94%A8%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%87%BD%E6%95%B0%5Cn%23%20%E5%9C%B0%E5%9D%80%20%20%20%20%20%20%20%E6%9C%BA%E5%99%A8%E7%A0%81%20%20%20%20%20%20%20%20%20%20%20%20%E5%8F%8D%E6%B1%87%E7%BC%96%5Cn0F8F0F6C%20%20%20%20E8%20FF525200%20%20%20%20%20call%20WeChatWi.0FD26250%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code># 打个比方，当微信收到消息的时候，假设调用下面的函数
# 地址       机器码            反汇编
0F8F0F6C    E8 FF525200     call WeChatWi.0FD26250</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1113894/202504/1113894-20250413172030608-1924371212.gif" class="cke_reset cke_widget_drag_handler" height="15" width="15" data-cke-widget-drag-handler="1"></span></div>
<p>我们只要把&nbsp;<code>0F8F0F6C</code>&nbsp;里的&nbsp;<code>call WeChatWi.0FD36350</code>，替换成&nbsp;<code>call 咱们自己的函数</code>，便可以对消息进行拦截了。同时，为了不影响原有的功能，我们还需要在&nbsp;<code>咱们自己的函数</code>&nbsp;的最后，调用&nbsp;<code>WeChatWi.0FD26250</code>。</p>
<p>我们把&nbsp;<code>0F8F0F6C</code>&nbsp;叫做&nbsp;<code>Hook</code>&nbsp;地址，把&nbsp;<code>WeChatWi.0FD26250</code>&nbsp;叫做&nbsp;<code>Call 地址</code>。这里&nbsp;<code>0F8F0F6C</code>&nbsp;和&nbsp;<code>FF525200</code>&nbsp;都是“相对”地址——相对&nbsp;<code>WeChatWin.dll</code>&nbsp;的地址；而&nbsp;<code>WeChatWin.dll</code>&nbsp;的地址称为&nbsp;<code>基址（Base）</code>。</p>
<h3><a id="_94"></a>伪装</h3>
<p>当我们需要在微信上发送一条新消息的时候，可以想象，微信肯定会调用某个函数，把消息发送出去。如果我们找到这个函数，组装好发送内容，调用它，就可以发送微信的消息了。</p>
<p>下面举个例子：</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" tabindex="-1" role="region" contenteditable="false" aria-label="代码段 小部件" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="4" data-cke-widget-wrapper="1">
<pre class="cke_widget_element highlighter-hljs" data-cke-widget-data="%7B%22code%22%3A%220F44FBF3%20%20%20%208D46%2038%20%20%20%20%20%20%20%20%20lea%20eax%2Cdword%20ptr%20ds%3A%5Besi%2B0x38%5D%5Cn0F44FBF6%20%20%20%206A%2001%20%20%20%20%20%20%20%20%20%20%20push%200x1%5Cn0F44FBF8%20%20%20%2050%20%20%20%20%20%20%20%20%20%20%20%20%20%20push%20eax%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3B%20At%20members%5Cn0F44FBF9%20%20%20%2057%20%20%20%20%20%20%20%20%20%20%20%20%20%20push%20edi%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3B%20Message%5Cn0F44FBFA%20%20%20%208D55%2090%20%20%20%20%20%20%20%20%20lea%20edx%2Cdword%20ptr%20ss%3A%5Bebp-0x70%5D%20%20%20%20%20%20%20%20%20%20%3B%20Receiver%20wxid%5Cn0F44FBFD%20%20%20%208D8D%2050FCFFFF%20%20%20lea%20ecx%2Cdword%20ptr%20ss%3A%5Bebp-0x3B0%5D%20%20%20%20%20%20%20%20%20%3B%20Buffer%5Cn%23%20%E6%89%93%E4%B8%AA%E6%AF%94%E6%96%B9%EF%BC%8C%E5%BD%93%E5%BE%AE%E4%BF%A1%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%81%87%E8%AE%BE%E4%BD%BF%E7%94%A8%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%87%BD%E6%95%B0%5Cn0F44FC03%20%20%20%20E8%2028213700%20%20%20%20%20call%20WeChatWi.0F7C1D30%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3B%20Send%20Msg%5Cn0F44FC08%20%20%20%2083C4%200C%20%20%20%20%20%20%20%20%20add%20esp%2C0xC%5Cn0F44FC0B%20%20%20%20C645%20FC%2005%20%20%20%20%20%20mov%20byte%20ptr%20ss%3A%5Bebp-0x4%5D%2C0x5%5Cn0F44FC0F%20%20%20%208B85%2070FCFFFF%20%20%20mov%20eax%2Cdword%20ptr%20ss%3A%5Bebp-0x390%5D%5Cn0F44FC15%20%20%20%200B85%2074FCFFFF%20%20%20or%20eax%2Cdword%20ptr%20ss%3A%5Bebp-0x38C%5D%5Cn0F44FC1B%20%20%20%2075%2010%20%20%20%20%20%20%20%20%20%20%20jnz%20short%20WeChatWi.0F44FC2D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code>0F44FBF3    8D46 38         lea eax,dword ptr ds:[esi+0x38]
0F44FBF6    6A 01           push 0x1
0F44FBF8    50              push eax                                 ; At members
0F44FBF9    57              push edi                                 ; Message
0F44FBFA    8D55 90         lea edx,dword ptr ss:[ebp-0x70]          ; Receiver wxid
0F44FBFD    8D8D 50FCFFFF   lea ecx,dword ptr ss:[ebp-0x3B0]         ; Buffer
# 打个比方，当微信发送消息的时候，假设使用下面的函数
0F44FC03    E8 28213700     call WeChatWi.0F7C1D30                   ; Send Msg
0F44FC08    83C4 0C         add esp,0xC
0F44FC0B    C645 FC 05      mov byte ptr ss:[ebp-0x4],0x5
0F44FC0F    8B85 70FCFFFF   mov eax,dword ptr ss:[ebp-0x390]
0F44FC15    0B85 74FCFFFF   or eax,dword ptr ss:[ebp-0x38C]
0F44FC1B    75 10           jnz short WeChatWi.0F44FC2D</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1113894/202504/1113894-20250413172030608-1924371212.gif" class="cke_reset cke_widget_drag_handler" height="15" width="15" data-cke-widget-drag-handler="1"></span></div>
<p>于是，当我们需要发送消息的时候，只要调用 0x521D30（0x0F7C1D30 - 0x0F2A0000）即可。</p>
<h3><a id="RPC_117"></a>RPC</h3>
<p>前面我们成功打入微信内部，并且也可以拦截消息并“假传圣旨”，那么，我们怎么把消息传出去或者传进来呢？</p>
<p>微信和我们的应用，在不同的进程。如果我们的应用需要和微信通信，则涉及到进程间通信（Inter Process Communication）。</p>
<p>Windows 支持的 IPC 方式包括：</p>
<ul>
<li>剪贴板</li>
<li>COM</li>
<li>数据复制</li>
<li>DDE</li>
<li>文件映射</li>
<li>Mailslots</li>
<li>管道</li>
<li>RPC</li>
<li>Windows 套接字</li>
</ul>
<p>RPC 指远程过程调用（Remote Procedure Call）。这里的远程指的是不在同一个进程，可以是一台电脑上的不同进程；也可以是不个电脑上的不同进程。使用 RPC，可以创建高性能紧密耦合的分布式应用程序。</p>
<p>本项目选择了 RPC，结果惹了一身麻烦。但是通过 RPC，进程间通信就变得很简单。RPC 工具使用户看起来就像客户端直接调用位于远程服务器程序中的过程一样。客户端和服务器各自有自己的地址空间；也就是说，每个资源都有自己的内存资源分配给过程使用的数据。</p>
<p>&nbsp;</p>
<p>于是，我拿来开发一款软件，适配微信版本<strong>3.9.11.25</strong>，功能丰富，目前支持如下功能：</p>
<ol>
<li>
<p><strong>关键词回复，</strong>即对指定好友的指定消息回复预设的消息。</p>
</li>
<li>
<p><strong>消息转发</strong>，即将好友A的指定消息转发至好友B。</p>
</li>
<li>
<p><strong>定时群发，</strong>即在指定时间向指定的好友或群聊发送指定消息。</p>
</li>
<li>
<p><strong>进群欢迎语</strong>，当群聊有新人加入时，发送指定的消息，且可选Excel统计邀请人数。</p>
</li>
<li>
<p><strong>自动收款</strong>，当有好友向您转账时，自动收款，并回复指定消息。</p>
</li>
<li>
<p><strong>自动通过好友申请</strong>，当有新好友申请时，自动同意通过，可选回复指定消息，可选邀请加入群聊。</p>
</li>
<li>
<p><strong>关键词进群</strong>，当有好友发送指定关键词的消息时，可邀请好友加入指定群聊。</p>
</li>
<li>
<p><strong>关键词踢人</strong>，当指定群聊中有成员发送指定关键词的消息时，可将该群成员移出这个群聊。</p>
</li>
<li>
<p><strong>群成员去重</strong>，对指定的几个群聊进行群成员去重，确保每个群成员仅存在一个群聊。</p>
</li>
<li>
<p><strong>公众号文章转发</strong>，当指定公众号发布新文章时，第一时间将文章转发至指定群聊或好友，从而实现群聊文章自动推送。</p>
</li>
<li>
<p><strong>群聊积分签到</strong>，对指定的几个群聊进行签到积分管理，即设定指定的签到时间，群成员发送指定口令为签到成功，可在“群签到积分.xlsx”文件中查看群成员、签到积分。</p>
</li>
<li>
<p><strong>群成员消息转发</strong>，将指定群聊中的指定群成员发送的消息转发至好友或群聊。</p>
</li>
<li>
<p><strong>退群监测</strong>，对指定的几个群聊进行群成员退群监测。</p>
</li>
<li>
<p><strong>批量加好友</strong>，对设定好的微信号列表，批量添加好友。</p>
</li>
<li>
<p><strong>添加群成员为好友</strong>，添加指定群聊中的指定群聊成员。</p>
</li>
<li>
<p><strong>定时娱乐</strong>，在指定时间向指定的好友或群聊发送娱乐信息。</p>
</li>
<li>
<p><strong>群活跃</strong>，好友或群聊以关键词的方式触发工具使用。</p>
</li>
</ol>
<p>&nbsp;</p>
<hr>
<p>界面美观易用，例如<strong>关键词回复</strong>功能界面：</p>
<p><img src="https://img2024.cnblogs.com/blog/1113894/202504/1113894-20250413172230206-1926249352.png" alt="" height="895" width="1200"></p>
<p id="1744536152063"></p>
<p>且每个功能模块都适配了使用说明，点击“帮助”即可获得使用方式：</p>
<p><img src="https://img2024.cnblogs.com/blog/1113894/202504/1113894-20250413172312234-1733068698.png" alt="" height="895" width="1200"></p>
<p><img src="https://img2024.cnblogs.com/blog/1113894/202504/1113894-20250413172329404-1734119907.png" alt="" height="895" width="1200"></p>
<p id="1744536210707"></p>
<p id="1744536193831"></p>
<p id="1744536177031"></p>
<hr>
<p>软件安装完成后就可立即使用，开发这款软件的初衷就是为了方便有这方面需求的朋友。</p>
<p>网站：<span class="cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_wrapper_link-info cke_widget_selected" tabindex="-1" role="region" contenteditable="false" aria-label="a 小部件" data-cke-display-name="a" data-cke-filter="off" data-cke-widget-id="0" data-cke-widget-wrapper="1"><a class="link-info cke_widget_editable cke_widget_element" title="oss.zuoyu.top" contenteditable="true" href="http://oss.zuoyu.top" data-cke-enter-mode="2" data-cke-saved-href="http://oss.zuoyu.top" data-cke-widget-data="%7B%22url%22%3A%22http%3A%2F%2Foss.zuoyu.top%22%2C%22text%22%3A%22oss.zuoyu.top%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.3.8%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DP1C7%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.3.8%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DP1C7%22%2C%22id%22%3A%22xheYAR-1744535786067%22%2C%22classes%22%3A%7B%22link-info%22%3A1%7D%7D" data-cke-widget-editable="text" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=P1C7" data-link-title="oss.zuoyu.top" data-widget="csdnlink" rel="noopener nofollow">oss.zuoyu.top</a></span></p>
<p>网站内有详细的安装说明，和软件的下载地址。</p>
<p>&nbsp;</p>
<p><span data-cke-copybin-end="1">​</span></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03662338694212963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-13 17:24">2025-04-13 17:24</span>&nbsp;
<a href="https://www.cnblogs.com/1214804270hacker">左羽</a>&nbsp;
阅读(<span id="post_view_count">3</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18823452);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18823452', targetLink: 'https://www.cnblogs.com/1214804270hacker/p/18823452', title: '微信助手的开发思路及作品' })">举报</a>
</div>
        