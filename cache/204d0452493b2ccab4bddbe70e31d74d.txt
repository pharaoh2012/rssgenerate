
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/san-mu/p/19007791" title="发布于 2025-08-03 14:58">
    <span role="heading" aria-level="2">MySQL 24 MySQL是怎么保证主备一致的？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h3 id="mysql主备的基本原理">MySQL主备的基本原理</h3>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727194947084-1614727565.png" width="50%"></div>
<p>状态1中，客户端读写都是直接访问节点A，节点B只是将节点A的更新同步过来在本地执行。当需要主备切换时，就变成状态2。</p>
<p>状态1中没有直接访问节点B，但仍然建议把节点B设置成只读模式，原因如下：</p>
<ul>
<li>
<p>有时一些运营类的查询语句会被放到备库上查看，设置为只读可以防止误操作；</p>
</li>
<li>
<p>防止切换逻辑出现双写等bug，造成主备不一致；</p>
</li>
<li>
<p>可以用readonly状态来判断节点角色。</p>
</li>
</ul>
<p>把备库设置成只读，还怎么跟主库保持同步更新呢？这是由于readonly设置对超级权限的用户是无效的，而对于同步更新的线程，就拥有超级权限。</p>
<p>而一个update语句在节点A执行，然后同步到节点B的完整流程如下：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727195207164-868764597.png" width="50%"></div>
<p>主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写binlog。备库和主库之间维持了一个长连接，主库内部有一个线程专门服务该长连接。一个事务日志同步的完整过程为：</p>
<ul>
<li>
<p>备库B通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，位置包含文件名和日志偏移量；</p>
</li>
<li>
<p>备考B上执行start slave，会启动两个线程io_thread和sql_thread，其中io_thread负责与主库建立连接；</p>
</li>
<li>
<p>主库A校验完用户名、密码后，按照备库B传过来的位置，从本地读取binlog发给B；</p>
</li>
<li>
<p>备库B拿到binlog后，写到本地未见，称为中转日志relay log；</p>
</li>
<li>
<p>sql_thread读取中转日志，解析出日志里的命令并执行。</p>
</li>
</ul>
<p>由于多线程复制方案的引入，sql_thread后来实际上演化成为了多个线程。</p>
<p>分析完长连接的逻辑，再来看一个问题：binlog里面到底是什么内容，为什么备库拿过去可以直接执行。</p>
<h3 id="binlog的三种格式对比">binlog的三种格式对比</h3>
<p>为了方便描述binlog的三种格式，以如下数据为例：</p>
<pre><code class="language-sql">mysql&gt; CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `a` int(11) DEFAULT NULL,
  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `a` (`a`),
  KEY `t_modified`(`t_modified`)
) ENGINE=InnoDB;

insert into t values(1,1,'2018-11-13');
insert into t values(2,2,'2018-11-12');
insert into t values(3,3,'2018-11-11');
insert into t values(4,4,'2018-11-10');
insert into t values(5,5,'2018-11-09');
</code></pre>
<p>假设要在表中删除一行：</p>
<pre><code class="language-sql">mysql&gt; delete from t /*comment*/  where a&gt;=4 and t_modified&lt;='2018-11-10' limit 1;
</code></pre>
<p>可以用下面的命令查看binlog中的内容：</p>
<pre><code class="language-sql">mysql&gt; show binlog events in 'master.000001';
</code></pre>
<p>当<code>binlog_format=statement</code>，binlog里记录的就是SQL语句的原文。statement格式的binlog内容：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727195251186-459672322.png" width="90%"></div>
<ul>
<li>
<p>第二行的begin与第四行的commit对应，表示中间是一个事务；</p>
</li>
<li>
<p>第三行是真实执行的语句。在真实执行的delete命令前，MySQL根据当前要操作的表所在的数据库，自行添加了一个命令，这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能正确更新到test库的表t。</p>
</li>
</ul>
<p>这条delete命令的执行效果图：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727195318541-1988315615.png" width="85%"></div>
<p>产生了一个warning，原因是当前binlog设置的是statement格式，且语句中有limit，因此该命令可能是unsafe的。具体来说，delete带limit，可能出现主备数据不一致情况，在上面的例子中：</p>
<ul>
<li>
<p>如果delete用的是索引a，那么会根据索引a找到第一个满足条件的行<code>a=4</code>；</p>
</li>
<li>
<p>如果delete用的是索引t_modified，那么删除的就是<code>t_modified='2018-11-09'</code>，是<code>a=5</code>。</p>
</li>
</ul>
<p>由于statement格式下binlog记录语句原文，因此可能出现：主库用的是索引a，备库使用的是索引t_modified，所以MySQL认为这样写是有风险的。</p>
<p>如果将binlog格式改为row，此时binlog内容：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727195346791-88332019.png" width="60%"></div>
<p>这时没有了sql原文，而是替换成了两个event：</p>
<ul>
<li>
<p>Table_map event：说明接下来要操作的表是test库的表t；</p>
</li>
<li>
<p>Delete_rows event：用于定义删除的行为。</p>
</li>
</ul>
<p>row格式下，通过binlog还看不到详细信息，还需要借助mysqlbinlog工具解析和查看binlog中的内容。从上面的binlog中可以看出，事务的binlog从8900位置开始，因此可以用start-position参数指定从该位置的日志开始解析：</p>
<pre><code class="language-sql">mysqlbinlog  -vv data/master.000001 --start-position=8900;
</code></pre>
<p>解析出的binlog详细内容：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727195415675-1407175505.png" width="70%"></div>
<p>对于解析结果：</p>
<ul>
<li>
<p>server id 1，表示事务是在<code>server_id=1</code>库上执行的；</p>
</li>
<li>
<p>Table_map event显示了接下来要打开的表，map到数字226。当前SQL语句只操作了一张表，如果要操作多张表，那么每个表都有一个对应的Table_map event，都会map到一个单独的数字，用于区分对不同表的操作；</p>
</li>
<li>
<p><code>@1=4, @2=4</code>这些表示各个字段的值，即<code>id=4,a=4</code>；</p>
</li>
<li>
<p>Xid event，用于表示事务被正确提交。</p>
</li>
</ul>
<p>可以看到，binlog使用row格式时，会记录真实删除行的主键id，这样binlog传到备库时，肯定会删除<code>id=4</code>的行，不会有主备删除不同行的问题。</p>
<h3 id="为什么会有mixed格式的binlog">为什么会有mixed格式的binlog？</h3>
<p>首先可以根据上面的分析来推一下：</p>
<ul>
<li>
<p>因为某些statement格式的binlog可能导致主备不一致，所以要使用row格式；</p>
</li>
<li>
<p>row格式缺点是很占空间，比如delete语句删除10万行数据，用statement就是一个SQL语句，而row格式需要把10万条记录都写到binlog，这样会占用更大的空间，同时写binlog会耗费IO资源；</p>
</li>
<li>
<p>因此MySQL取折中方案，即mixed格式，MySQL自己判断SQL语句是否可能引起主备不一致，如果可能就用row，否则用statement。</p>
</li>
</ul>
<p>可以看出，如果MySQL设置binlog为statement格式，基本可以认为是一个不合理的设置，至少可以设置为mixed。不过现在越来越多的场景要求把MySQL的binlog设置为row，理由有很多，其中有一点就是恢复数据。</p>
<p>从增删改来看数据恢复的问题：</p>
<ul>
<li>
<p>delete语句，row格式的binlog会把删掉的行的整行信息保存起来，如果发现删错数据，可以直接把binlog中记录的delete语句转成insert，将错删的数据插入；</p>
</li>
<li>
<p>insert语句，row格式的binlog会记录所有字段信息，可以转成delete删掉误插入的数据；</p>
</li>
<li>
<p>update语句，row格式的binlog会记录修改前和修改后的整行数据，如果误执行，只需要把前后两行消息对调一下，再去数据库里执行。</p>
</li>
</ul>
<h3 id="循环复制问题">循环复制问题</h3>
<p>最开始的图中MySQL主备切换流程是M-S结构，实际生产上使用比较多的是双M结构：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202507/3389949-20250727195458326-1404936057.png" width="50%"></div>
<p>对比两图，可以发现双M结构和M-S结构区别只是多了一条线，即节点A和B之间总是互为主备关系，这样切换时就不用再修改主备关系。</p>
<p>双M结构有一个问题。如果业务逻辑在节点A上更新一条语句，再把生成的binlog发给节点B，节点B执行完这条更新语句后也会生成binlog，会发送给节点A，相当于节点A又把节点B新生成的binlog拿过来执行了一次，然后两个节点会不断循环执行这个更新语句，即循环复制。</p>
<p>循环复制的解决：</p>
<ul>
<li>
<p>规定两个库的server id必须不同，如果相同则它们之间不能设为主备关系；</p>
</li>
<li>
<p>一个备库在重放binlog的过程中，会生成与原binlog的server id相同的新binlog；</p>
</li>
<li>
<p>每个库在收到从自己的主库发过来的日志后，先判断server id，如果和自己的相同，表示该日志由自己生成，直接丢弃。</p>
</li>
</ul>
<p>按这个逻辑，如果设置了双M结构，日志的执行流就为：</p>
<ul>
<li>
<p>从节点A更新的事务，binlog里面记的都是A的server id；</p>
</li>
<li>
<p>传到节点B执行一次以后，节点B生成的binlog的server id也是A的server id；</p>
</li>
<li>
<p>再传回给节点A，A判断到这个server id与自己的相同，就不会再处理这个日志，死循环在这里就断掉了。</p>
</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-03 14:58">2025-08-03 14:58</span>&nbsp;
<a href="https://www.cnblogs.com/san-mu">叁沐</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19007791);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19007791', targetLink: 'https://www.cnblogs.com/san-mu/p/19007791', title: 'MySQL 24 MySQL是怎么保证主备一致的？' })">举报</a>
</div>
        