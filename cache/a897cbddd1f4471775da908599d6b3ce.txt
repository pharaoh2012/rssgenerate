
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wavky/p/18810145" title="发布于 2025-04-07 09:18">
    <span role="heading" aria-level="2">Koin 依赖注入: 在 Android 模块化项目中定义 Room 数据库的最佳实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        通过 Koin 依赖注入，找到在 Android 的模块化架构中使用 Room 数据库的最佳方案
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前置">前置</h2>
<p>本文发布于个人小站：<a href="https://wavky.top/db-in-multi-modules/" target="_blank" rel="noopener nofollow">https://wavky.top/db-in-multi-modules/</a></p>
<p>欢迎移步至小站，关注更多技术分享，获得更佳阅读体验</p>
<p>（不保证所有技术文章都会同步发表到博客园）</p>
<h2 id="什么是模块化架构">什么是模块化架构</h2>
<p>Android 模块化架构是一种将应用程序拆分为多个独立模块的设计方法，以提高代码复用性、可维护性和团队协作效率。</p>
<p>例如，一个 Android 项目以模块化的方式设计组织之后，大概会形成以下的目录结构：</p>
<pre><code>Android 模块化架构
│
├── 应用层 (App Module): App 的主入口
│   ├── 主体界面 (Activity / Fragment)
│   ├── 业务逻辑 (ViewModel / UseCase)
│   ├── 数据层 (Repository)
│   └── 依赖（组装）功能模块、共享模块
│
├── 功能模块 (Feature Modules)
│   ├── 某个具体功能 (如支付模块) 的具体实现
│   ├── 功能界面 (Activity / Fragment)
│   ├── 业务逻辑 (ViewModel / UseCase)
│   ├── 数据层 (Repository)
│   └── 依赖共享模块
│
└── 共享模块 (Common Modules)
    ├── 主题与样式 (UI Components / Theme)
    ├── 全局通用资源文件 (Strings / Colors / Drawables)
    ├── 公共库 (如通用 View 组件 / 基础 Activity / 通用数据类型 / 全局常量 / 算法库)
    ├── 工具类 (Utils / Extensions)
    ├── 依赖库
    └── 其他可复用的代码
</code></pre>
<p><strong>应用模块、功能模块的模板目录结构和一键批量创建的方法：</strong> <a href="https://wavky.top/MyTricks/#%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BA-Android-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener nofollow">一键创建 Android 项目模板目录</a></p>
<p><strong>这种架构的优点：</strong></p>
<ul>
<li>解耦：不同功能模块可以独立开发和维护，为后期重构创造便利。</li>
<li>团队协作：不同团队可以并行开发不同模块，减少代码合并冲突。</li>
<li>复用性：多个应用可以共享核心模块或公共库。</li>
<li>加速构建：模块可以独立编译，加快 Gradle 构建速度。</li>
</ul>
<p><strong>模块间的依赖关系如下图所示</strong><br>
<img src="https://img2024.cnblogs.com/blog/539308/202504/539308-20250405154614231-1725714073.png" alt="" loading="lazy"></p>
<h2 id="简单介绍一下-room">简单介绍一下 Room</h2>
<p>Room 是 Android Jetpack 中的一个 SQLite 封装库，它提供了一个抽象层来简化 SQLite 数据库的使用，提供一组基于注解的 API 来标准化数据库操作，并提供类型安全支持。</p>
<h3 id="使用方式">使用方式</h3>
<p><strong>以实体类方式定义数据表</strong></p>
<pre><code class="language-kotlin">@Entity
data class User(
    @PrimaryKey val id: Long,
    val firstName: String?,
    val lastName: String?
)
</code></pre>
<p><strong>定义增删改查的 Dao</strong></p>
<pre><code class="language-kotlin">@Dao
interface UserDao {
    @Query("SELECT * FROM user")
    fun getAll(): Flow&lt;User&gt;

    @Query("SELECT * FROM user WHERE uid IN (:userIds)")
    fun loadAllByIds(userIds: IntArray): List&lt;User&gt;

    @Query("SELECT * FROM user WHERE first_name LIKE :first AND last_name LIKE :last LIMIT 1")
    fun findByName(first: String, last: String): User

    @Insert
    fun insertAll(vararg users: User)

    @Update
    fun update(user: User)

    @Delete
    fun delete(user: User)
}
</code></pre>
<p><strong>定义数据库 AppDatabase</strong></p>
<p>下文使用 AppDatabase 指代自定义 Room 数据库类</p>
<pre><code class="language-kotlin">// 定义数据库时需要访问到 App 中所有的 Entity 和 Dao 接口
@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
</code></pre>
<p><strong>读写数据</strong></p>
<pre><code class="language-kotlin">val db = Room.databaseBuilder(
        applicationContext,
        AppDatabase::class.java, "database-name"
    ).build()

// 需要通过数据库对象来获取 Dao 对象，进行数据操作
val userDao = db.userDao()
val user = User(1, "John", "Doe")
userDao.insertAll(user)
val allUsers: Flow&lt;List&lt;User&gt;&gt; = userDao.getAll()
</code></pre>
<p>值得一提的是，Room 支持直接返回 Flow 类型的查询结果（也支持 LiveData），为 Compose 的数据订阅提供了基础支持。</p>
<h2 id="在模块化架构中的争议点">在模块化架构中的争议点</h2>
<p>如前面所述，在 Android 模块化架构中，依赖关系是单向的：</p>
<ul>
<li>应用模块依赖：功能模块，共享模块</li>
<li>功能模块依赖：共享模块，或者其他子功能模块</li>
<li>共享模块依赖：不依赖任何自定义模块</li>
</ul>
<p>在这种依赖关系中，下层模块看不到（访问不到）上层模块的实现，例如共享模块内是访问不到应用模块中的 MainActivity 的。</p>
<p>在实际开发中，应用模块和功能模块往往都需要使用 Room 来存取数据，在各模块内自定义独有的数据表和 Dao，甚至在共享模块中也可能会有一些基础的公共数据表和 Dao 的定义。</p>
<p>在 Room 中对数据的操作依赖各个 Dao 对象来执行，而 Dao 对象依赖 AppDatabase 实例来创建，因此 AppDatabase 应该放置在比较底层的位置，以便所有模块都能访问到所需的 Entity 和 Dao 实例。</p>
<p>但在上面的 Room 介绍一节中我们可以看到，在定义和实例化 AppDatabase 时，是需要访问到 App 中所有的 Entity 和 Dao 接口，这就导致了一个关于可见性的问题：</p>
<ul>
<li>如果我们在最底层的共享模块中定义并实例化 AppDatabase，AppDatabase 就无法访问到位于应用模块和功能模块中定义的 Entity 和 Dao 接口，继而无法实例化各个 Dao 对象；</li>
<li>而如果我们将所有的 Entity 和 Dao 接口也都放在共享模块中，那么又会破坏模块化的设计原则，导致本应定义在应用模块和功能模块中的代码被耦合到了共享模块中，产生代码污染；</li>
<li>为了让 AppDatabase 能访问到所有的 Entity 和 Dao 接口，我们需要将其挪到最上层的应用模块中，但这样又会导致较下层的功能模块无法访问到 Room 实例化的 Dao 对象，无法进行数据操作。</li>
</ul>
<p>就这样，产生了一个先有鸡还是先有蛋的哲学问题：<br>
AppDatabase 依赖各模块的 Entity 和 Dao 定义（所以 AppDatabase 应该放在顶层）；<br>
各个模块又依赖 AppDatabase 对象提供的 Dao 实例对象（所以 AppDatabase 应该放在底层）。</p>
<p>那么，AppDatabase、Entity 和 Dao 接口的定义应该放在哪里呢？</p>
<h2 id="网上大佬的解决方案">网上大佬的解决方案</h2>
<p>在探索这个问题如何解决的过程中，我发现了网上大佬的解决方案：<a href="https://juejin.cn/post/7005135352604131358" target="_blank" rel="noopener nofollow">模块化架构下 Room 数据库的使用设计</a></p>
<p>简单引述一下：</p>
<h3 id="方案一在共享模块中定义整个-room-数据库">方案一：在共享模块中定义整个 Room 数据库</h3>
<p>将 App 中所有的 Entity 和 Dao 都定义在共享模块中，这种方法简单容易操作，但缺点之前也提到过，原本应该在各个模块内各自维护的代码都被统一下放到共享模块中，导致代码污染，背离模块化设计的初衷。</p>
<p><img src="https://img2024.cnblogs.com/blog/539308/202504/539308-20250405154631847-1565381515.webp" alt="" loading="lazy"></p>
<h3 id="方案二在应用模块和功能模块中各自实例化自己的-room-database">方案二：在应用模块和功能模块中各自实例化自己的 Room Database</h3>
<p>这种方法将各个 Dao 和 Entity 保留在了各自的模块中，践行了模块化设计原则，避免了代码污染，但缺点是会导致多个 Room 数据库实例的创建，据文档所言会极大增加资源开销，还可能产生复杂的使用问题。</p>
<p><img src="https://img2024.cnblogs.com/blog/539308/202504/539308-20250405154654454-343385011.webp" alt="" loading="lazy"></p>
<h3 id="方案三在应用模块中定义-appdatabase在各个模块中定义各自的-entity-和-dao-接口">方案三：在应用模块中定义 AppDatabase，在各个模块中定义各自的 Entity 和 Dao 接口</h3>
<p>这就是网上大佬最后得出的解决方案：</p>
<ol>
<li>在顶层应用模块中定义 AppDatabase，实例化所有的 Dao 接口</li>
<li>在各个功能模块中定义各自的 Entity 和 Dao 接口</li>
<li>在各个功能模块中定义获取 Dao 对象的功能接口，接口中通过 callback 字段缓存 Room 创建的 Dao 实例</li>
<li>最后在 Application 中进行对各个模块的这种 Dao 对象获取接口进行实例化填充。</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/539308/202504/539308-20250405154702926-796764981.webp" alt="" loading="lazy"></p>
<p>我没有尝试这个方案，是因为直觉上认为这个方案存在缺点：</p>
<ol>
<li>应用层创建的 Dao 实例下放到各个模块的设计实现过于复杂，代码不直观，增加了维护难度</li>
<li>我不喜欢这种基于全局单例的缓存设计</li>
</ol>
<p>我追求的设计是简单直观，减少引入不必要的复杂性，在尽可能少的代码实装下实现与这个方案相同的功能。</p>
<h2 id="找到最终方案koin">找到最终方案：Koin</h2>
<p>Koin 是一个轻量级的依赖注入框架，与 Dagger 和 Google 推荐的 Hilt 类似，但与后面两者相比，Koin 更加轻量易用，不需要复杂的配置就能实现基本的依赖注入功能，并且 <strong>Koin 是运行时注入，而 Dagger 与 Hilt 是编译时注入。</strong></p>
<p>Koin 是 100% Kotlin 编写的第三方库，基于 Kotlin DSL 语法，可以用非常 Kotlin 风格的方式简单地定义依赖关系，并在运行时按需动态注入。</p>
<p>Koin 是运行时动态注入的，而不是编译时注入，这意味着 Koin 不会在编译时检查依赖关系，不会由于模块间的相互依赖而导致编译失败。（在下文中会再详细说明）</p>
<h3 id="简单说说-koin-的使用方式">简单说说 Koin 的使用方式</h3>
<p>Koin 的使用方式非常简单，主要分为以下几个步骤：</p>
<ol>
<li>在项目中添加 Koin 库的依赖</li>
<li>定义 Koin 模块 (Module)</li>
<li>定义依赖关系</li>
<li>运行应用并动态完成依赖注入</li>
</ol>
<p><strong>定义 Koin Module</strong><br>
Koin Module 简单理解是一个预定义的实例工厂池，这个工厂池是 App 全局共享的，里面存放了 App 中各处需要被注入的对象的实例化方法，Koin 默认通过对象的类型来进行依赖对象的匹配和注入。（根据需要也可以选择更复杂和精细的匹配模式）</p>
<pre><code class="language-kotlin">val appModule = module {
  // 以工厂模式实例化自定义的 Printer 对象
  factory { Printer() }
}
</code></pre>
<p><strong>定义依赖注入</strong><br>
在需要使用的地方通过 Koin API 注入对象实例，在 App 运行期间，Koin 会自动匹配、按需实例化并注入对应的对象实例。</p>
<pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {
  // 声明一个 Printer 类型变量，指定通过 Koin 注入来赋值
  val printer: Printer by inject()

  override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState)
      setContentView(R.layout.activity_main)
  
      // 使用注入的 Printer 对象
      printer.print("Hello, Koin!")
  }
}
</code></pre>
<h3 id="使用-koin-实现模块化架构中-room-数据库的最佳实践">使用 Koin 实现模块化架构中 Room 数据库的最佳实践</h3>
<p>我们将沿用上面方案三的思路：</p>
<p><strong>在应用模块中定义 AppDatabase，在各个功能模块中定义各自的 Entity 和 Dao 接口。</strong></p>
<p>但是我们不需要设计和定义将应用层中实例化的 Dao 对象下放到各个模块的方法，只需要在各个模块中需要使用 Dao 对象的地方指定依赖注入，交由 Koin 动态注入来实现即可。</p>
<p><img src="https://img2024.cnblogs.com/blog/539308/202504/539308-20250405154717238-1051977543.png" alt="" loading="lazy"></p>
<p><strong>应用模块定义数据库，并创建数据库 Module</strong></p>
<pre><code class="language-kotlin">val appModule = module {
  // 单例方式实例化数据库对象
  single&lt;AppDatabase&gt; {
    Room.databaseBuilder(
      androidContext(),
      AppDatabase::class.java,
      AppDatabase.DATABASE_NAME
    ).build()
  }

  // 单例方式实例化 UserDao 对象
  // 这里的 UserDao 是在功能模块中定义的
  single { get&lt;AppDatabase&gt;().userDao() }
}
</code></pre>
<p><strong>在 Application 中初始化 Module</strong></p>
<pre><code class="language-kotlin">class MyApplication : Application() {
  override fun onCreate() {
    super.onCreate()

    startKoin {
      androidLogger()
      androidContext(this@MyApplication)
      modules(appModule)
    }
  }
}
</code></pre>
<p><strong>在功能模块的 Repository 中注入 Dao 对象</strong></p>
<pre><code class="language-kotlin">// 在构造函数参数中声明对 Dao 的依赖
class UserRepository(private val userDao: UserDao) {
  fun getAllUsers(): Flow&lt;List&lt;User&gt;&gt; {
    return userDao.getAll()
  }
}
</code></pre>
<p><strong>在功能模块中定义 Repository 的 Module</strong></p>
<pre><code class="language-kotlin">val userModule = module {
  // 通过 get() 匹配并注入与参数相同类型的实例
  factory { UserRepository(get()) }
}
</code></pre>
<p><strong>在功能模块的 UI 层中注入 Repository 对象</strong></p>
<pre><code class="language-kotlin">// 在 ViewModel 中注入 Repository
class UserViewModel(
  private val userRepository: UserRepository
) : ViewModel() {
  val allUsers: Flow&lt;List&lt;User&gt;&gt; = userRepository.getAllUsers()
}

// 在 Activity 中注入 ViewModel
class UserActivity : AppCompatActivity() {
  private val userViewModel: UserViewModel by viewModel()
  
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_user)

    userViewModel.allUsers.collect { users -&gt;
      // 更新 UI
    }
  }
}
</code></pre>
<p><strong>⚠️ 上面的代码并非完整代码，仅为说明而摘取的核心部分</strong></p>
<h4 id="纵观整个实现的依赖关系">纵观整个实现的依赖关系</h4>
<ul>
<li>应用模块中定义了 AppDatabase</li>
<li>功能模块中定义了 Entity、Dao，上层的应用模块基于此进行实例化</li>
<li>应用模块在 Koin Module 中实例化 AppDatabase 和 App 内所有的 Dao 对象</li>
<li>功能模块根据需要，在 Repository 或其他类中注入 Dao 对象，利用 Dao 对象进行数据操作</li>
</ul>
<p>在这里，我们似乎遇到了一个循环依赖问题：</p>
<ul>
<li>应用模块依赖功能模块提供 Entity 和 Dao 接口的实现</li>
<li>功能模块依赖应用模块提供 Dao 对象的实例化</li>
</ul>
<p>但实际上，Dao 对象的实例化和注入是由 Koin 在 App 运行时动态完成的，Koin 会在运行时自动解析依赖关系并实例化对象，因此不会出现编译期的循环依赖的问题。</p>
<p><strong>Koin 是运行时动态注入的，而不是编译时注入，不会产生模块间的循环依赖问题导致编译失败。</strong></p>
<p>通过这种方式，我们在模块化架构中实现了 Room 数据库的定义和使用，避免了代码污染和复杂的对象传递设计，同时也保持了模块化设计的纯净。</p>
<p>举一反三，除了 Room 数据库，对于 Retrofit 等其他常用库的使用也可以采用类似的方式进行依赖注入，Koin 提供了非常灵活和强大的依赖注入功能，可以帮助我们更好地实现模块化架构。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07250937972222223" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-07 09:19">2025-04-07 09:18</span>&nbsp;
<a href="https://www.cnblogs.com/wavky">wavky</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18810145" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18810145);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18810145', targetLink: 'https://www.cnblogs.com/wavky/p/18810145', title: 'Koin 依赖注入: 在 Android 模块化项目中定义 Room 数据库的最佳实践' })">举报</a>
</div>
        