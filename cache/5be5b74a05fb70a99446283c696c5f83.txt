
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhanggaoxing/p/18791377" title="发布于 2025-03-25 14:57">
    <span role="heading" aria-level="2">张高兴的大模型开发实战：（三）使用 LangGraph 为对话添加历史记录</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#基础概念" rel="noopener nofollow">基础概念</a></li><li><a href="#环境搭建与配置" rel="noopener nofollow">环境搭建与配置</a></li><li><a href="#将对话历史存储至内存" rel="noopener nofollow">将对话历史存储至内存</a></li><li><a href="#将对话历史存储至-postgresql" rel="noopener nofollow">将对话历史存储至 PostgreSQL</a></li></ul></div><p></p>
<p>在构建聊天机器人时，对话历史记录是提升用户体验的核心功能之一，用户希望机器人能够记住之前的对话内容，从而避免重复提问。LangGraph 是 LangChain 生态中一个工具，通过将应用逻辑组织成有向图（Graph）的形式，可以轻松实现对话历史的管理和复杂的对话流程。本文将通过一个示例，展示如何使用 LangGraph 实现这一功能。</p>
<p>在上一篇博客中提到，链（Chain）在 LangChain 中是一种基本的构建块，用于将多个 LLM 调用和工具调用链接在一起。然而，链在处理复杂、动态的对话流程时存在一些局限性，例如，链通常是线性的，这种线性结构只能按照预定义的顺序执行，限制了在对话中进行动态路由和条件分支的能力。LangGraph 的设计目标是提供一个更灵活、更强大的框架来构建复杂的智能体应用。</p>
<table>
<thead>
<tr>
<th style="text-align: center"></th>
<th style="text-align: center">LangGraph</th>
<th style="text-align: center">LangChain</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">核心设计</td>
<td style="text-align: center">循环图结构：支持条件分支、循环和反馈机制，适合复杂多步骤任务。</td>
<td style="text-align: center">线性流程（DAG）：以链式结构为主，适合线性任务（如文档检索、文本生成）。</td>
</tr>
<tr>
<td style="text-align: center">控制能力</td>
<td style="text-align: center">高度可控：通过节点（Node）和边（Edge）精细控制流程，支持条件逻辑和动态修改。</td>
<td style="text-align: center">中等可控：依赖链式编排，灵活性较低，难以处理复杂循环或动态分支。</td>
</tr>
<tr>
<td style="text-align: center">持久化与状态管理</td>
<td style="text-align: center">内置持久化：支持状态检查点（Checkpoints），可中断/恢复任务，适合长期任务。</td>
<td style="text-align: center">基础记忆功能：依赖对话历史记录，但无法持久化复杂状态或跨会话共享。</td>
</tr>
<tr>
<td style="text-align: center">人在环（Human-in-the-Loop）</td>
<td style="text-align: center">深度支持：可在任意节点插入人工审核、干预，适合医疗、金融等需人工决策的场景。</td>
<td style="text-align: center">弱支持：需手动集成人工干预逻辑，流程中断后难以恢复。</td>
</tr>
<tr>
<td style="text-align: center">多代理（Multi-Agent）</td>
<td style="text-align: center">原生支持：通过共享状态实现多Agent协作，适合复杂任务拆分与协同。</td>
<td style="text-align: center">较弱：需手动协调多个链，难以实现动态任务分配。</td>
</tr>
<tr>
<td style="text-align: center">错误处理</td>
<td style="text-align: center">容错性强：支持失败节点跳转或重试，流程可恢复。</td>
<td style="text-align: center">基础重试：依赖单链重试，无法处理复杂流程中的错误传播。</td>
</tr>
<tr>
<td style="text-align: center">适用场景</td>
<td style="text-align: center">复杂多步骤任务、需人工干预的场景（如医疗诊断）、多Agent协作系统、长期任务（如持续对话）</td>
<td style="text-align: center">线性任务（文档检索、文本生成）、快速原型开发、简单对话系统</td>
</tr>
<tr>
<td style="text-align: center">开发复杂度</td>
<td style="text-align: center">中等：需定义节点、边和状态，但提供了灵活的编排能力。</td>
<td style="text-align: center">低：开箱即用的链式结构，适合快速开发。</td>
</tr>
</tbody>
</table>
<h2 id="基础概念">基础概念</h2>
<p>LangGraph 的核心是 State Graph，它通过状态（State）、节点（Node）和边（Edge）的组合，定义对话的流程和逻辑。每个状态可以保存对话的上下文（如历史消息、总结等），节点定义了在不同状态下如何处理输入和生成输出，边定义了处理流程。</p>
<ol>
<li>State（状态）<br>
用于存储对话中的临时数据，例如用户消息、模型响应、总结内容等。例如 <code>class State(MessagesState): messages: str</code> 表示一个状态，其中 <code>messages</code> 字段用于存储对话的具体信息。</li>
<li>Node（节点）<br>
定义了对话流程中的具体操作，通常是具体的函数，例如调用模型、判断是否需要总结、生成总结等。</li>
<li>Edge（边）<br>
用于连接不同的节点，定义了节点之间的关系和流程。边可以包含条件逻辑、循环、分支等，用于控制对话流程的走向。</li>
</ol>
<p>我们来看一个最简单的示例，下图是一个 LangGraph 实现的聊天机器人。</p>
<p><img src="https://img2024.cnblogs.com/blog/1085877/202503/1085877-20250325145646976-185638227.png" alt="" loading="lazy"></p>
<p>起始节点为 <code>__start__</code>，结束节点为 <code>__end__</code>，<code>chatbot</code> 表示调用大模型处理对话。<code>__start__</code> 节点存储了应用的 <code>State</code> 数据。节点之间带箭头的线段表示边，实线代表<code>普通边 →</code>，虚线代表<code>条件边 ⇢</code>，条件边根据当前的具体条件而选择哪一条边执行，选择不同的边，则到达的节点不同。</p>
<h2 id="环境搭建与配置">环境搭建与配置</h2>
<p>在上一篇博客创建的 Python 虚拟环境中执行以下命令，安装需要的包：</p>
<pre><code class="language-shell">pip install langgraph langgraph-checkpoint-postgres psycopg[binary,pool]
</code></pre>
<h2 id="将对话历史存储至内存">将对话历史存储至内存</h2>
<p>在开始之前，先构建一个图，实现一个最简单的聊天机器人。</p>
<pre><code class="language-python">from typing import Annotated
from typing_extensions import TypedDict
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
from langchain_ollama import ChatOllama

class State(TypedDict):
    """存储对话状态信息"""
    messages: Annotated[list, add_messages]

def chatbot(state: State):
    """调用模型处理对话"""
    return {"messages": [llm.invoke(state["messages"])]}

llm = ChatOllama(model="qwen2.5:1.5b")

# 创建图
graph_builder = StateGraph(State)
graph_builder.add_node("chatbot", chatbot)  # 添加节点
graph_builder.add_edge(START, "chatbot")    # 添加边
graph_builder.add_edge("chatbot", END)
graph = graph_builder.compile()
</code></pre>
<p>使用下面的代码输出图的结构：</p>
<pre><code class="language-python">png = graph.get_graph().draw_mermaid_png()
with open("chatbot.png", "wb") as f:
    f.write(png)
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1085877/202503/1085877-20250325145646976-185638227.png" alt="" loading="lazy"></p>
<p>接下来，使用 <code>graph.stream()</code> 方法执行图，即可开始对话。</p>
<pre><code class="language-python">events = graph.stream({"messages": [{"role": "user", "content": "你可以做些什么？"}]})
for event in events:
    last_event = event
print("AI: ", last_event["messages"][-1].content)
</code></pre>
<p>下面使用 <code>MemorySaver</code> 将对话历史存储在内存中。</p>
<pre><code class="language-python">from langgraph.checkpoint.memory import MemorySaver

checkpointer = MemorySaver()
# 创建图
# ...
graph = graph_builder.compile(checkpointer=checkpointer)
</code></pre>
<p>在对话时要记录对话历史，还需要在 <code>graph.stream()</code> 方法中传入 <code>config</code> 参数，<code>thread_id</code> 用于标识对话的唯一性，不同的对话 <code>thread_id</code> 不同。</p>
<pre><code class="language-python">import uuid

config = {"configurable": {"thread_id": uuid.uuid4().hex}}
events = graph.stream({"messages": [{"role": "user", "content": "你好，我的名字是张三"}]}, config)
</code></pre>
<p>最后，我们将对话的代码封装成 <code>stream_graph_updates()</code> 方法，通过对话检测一下历史信息是否被正确保存。</p>
<pre><code class="language-python">def stream_graph_updates(user_input: str, config: dict):
    """对话"""
    events = graph.stream({"messages": [{"role": "user", "content": user_input}]}, config, stream_mode="values")
    for event in events:
        last_event = event
    print("AI: ", last_event["messages"][-1].content)

if __name__ == "__main__":
    config = {"configurable": {"thread_id": uuid.uuid4().hex}}

    while True:
        user_input = input("User: ")    # 用户输入问题进行对话
        if user_input.lower() in ["exit", "quit"]:
            break
        stream_graph_updates(user_input, config)

    print("\nHistory: ")    # 输出对话历史
    for message in graph.get_state(config).values["messages"]:
        if isinstance(message, AIMessage):
            prefix = "AI"
        else:
            prefix = "User"
        print(f"{prefix}: {message.content}")
</code></pre>
<pre><code class="language-shell">User: 你好，我的名字是张三
AI:  你好！很高兴认识你。有什么可以帮忙的吗？
User: 我叫什么名字
AI:  你的名字确实是“张三”。很高兴认识你！有什么问题或需要帮助的地方吗？
</code></pre>
<h2 id="将对话历史存储至-postgresql">将对话历史存储至 PostgreSQL</h2>
<p>对话历史存储至内存中，当应用关闭时，对话历史也会消失，有时无法满足持久化的需求。LangGraph 提供了一些数据库持久化方式，支持的数据库有 PostgreSQL、MongoDB、Redis。下面使用 PostgreSQL 数据库为例。在开始之前，执行以下命令创建一个 PostgreSQL 数据库：</p>
<pre><code class="language-shell">psql -U postgres -c "CREATE DATABASE llm"
</code></pre>
<p>接着，在代码中替换 <code>MemorySaver</code> 为 <code>PostgresSaver</code>，连接并初始化数据库：</p>
<pre><code class="language-python">from psycopg import Connection
from langgraph.checkpoint.postgres import PostgresSaver

DB_URI = "postgresql://postgres:YOUR_PASSW0RD@localhost:5432/llm"   # 记得替换数据库密码

conn = Connection.connect(DB_URI)   # 连接数据库
checkpointer = PostgresSaver(conn)
checkpointer.setup()    # 初始化数据库
</code></pre>
<p>使用数据库管理工具查看数据库，可以看到 LangGraph 在数据库初始化时帮我们创建了四张表：<code>checkpoint</code>、<code>checkpoint_blobs</code>、<code>checkpoint_writes</code>、<code>checkpoint_migrations</code>。</p>
<p><img src="https://img2024.cnblogs.com/blog/1085877/202503/1085877-20250325145701855-135624280.png" alt="" loading="lazy"></p>
<p>完整的程序代码如下：</p>
<pre><code class="language-python">import uuid
from typing import Annotated
from typing_extensions import TypedDict
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
from langchain_ollama import ChatOllama
from langchain_core.messages import AIMessage, HumanMessage
from psycopg import Connection
from langgraph.checkpoint.postgres import PostgresSaver

class State(TypedDict):
    messages: Annotated[list, add_messages]

def chatbot(state: State):
    return {"messages": [llm.invoke(state["messages"])]}

DB_URI = "postgresql://postgres:%40Passw0rd@localhost:5432/llm"

llm = ChatOllama(model="qwen2.5:1.5b")

conn = Connection.connect(DB_URI)
checkpointer = PostgresSaver(conn)
checkpointer.setup()

graph_builder = StateGraph(State)
graph_builder.add_node("chatbot", chatbot)
graph_builder.add_edge(START, "chatbot")
graph_builder.add_edge("chatbot", END)

graph = graph_builder.compile(checkpointer=checkpointer)

def stream_graph_updates(user_input: str, config: dict):
    events = graph.stream({"messages": [{"role": "user", "content": user_input}]}, config, stream_mode="values")
    for event in events:
        last_event = event
    print("AI: ", last_event["messages"][-1].content)

if __name__ == "__main__":
    config = {"configurable": {"thread_id": uuid.uuid4().hex}}

    while True:
        user_input = input("User: ")
        if user_input.lower() in ["exit", "quit"]:
            break
        stream_graph_updates(user_input, config)

    print("\nHistory: ")
    for message in checkpointer.get(config)["channel_values"]["messages"]:
        if isinstance(message, AIMessage):
            prefix = "AI"
        else:
            prefix = "User"
        print(f"{prefix}: {message.content}")

    conn.close()
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.05778029439930556" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-25 14:58">2025-03-25 14:57</span>&nbsp;
<a href="https://www.cnblogs.com/zhanggaoxing">张高兴</a>&nbsp;
阅读(<span id="post_view_count">9</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18791377" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18791377);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18791377', targetLink: 'https://www.cnblogs.com/zhanggaoxing/p/18791377', title: '张高兴的大模型开发实战：（三）使用 LangGraph 为对话添加历史记录' })">举报</a>
</div>
        