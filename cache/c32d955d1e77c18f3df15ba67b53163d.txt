
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/fkxxgis/p/18637792" title="发布于 2024-12-28 18:33">
    <span role="heading" aria-level="2">Python读取栅格图像并对像元数据处理后导出到表格文件中</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文介绍基于Python语言中的gdal模块，读取一景.tif格式的栅格遥感影像文件，提取其中每一个像元的像素数值，对像素值加以计算（辐射定标）后，再以一列数据的形式将计算后的各像元像素数据保存在一个.csv格式文件中的方法~
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>  本文介绍基于<strong>Python</strong>语言中的<code>gdal</code>模块，读取一景<code>.tif</code>格式的<strong>栅格遥感影像</strong>文件，提取其中每一个像元的<strong>像素数值</strong>，对像素值加以<strong>计算</strong>（辐射定标）后，再以<strong>一列数据</strong>的形式将<strong>计算后的各像元像素数据</strong>保存在一个<code>.csv</code>格式文件中的方法。</p>
<p>  首先，我们明确一下本文的需求。现在有一个<strong>栅格遥感影像</strong>文件，其为<code>.tiff</code>格式的文件（但其实和<code>.tif</code>格式文件的操作方法是一样的），且像元的数值都是真实数值乘上<code>10000</code>之后的。这一遥感影像如下图所示，可以看到其各个波段的像元像素数据都是几百、几千的范围。</p>
<p><img src="https://img2024.cnblogs.com/blog/3080295/202412/3080295-20241228183122627-1760205794.png" alt="image" loading="lazy"></p>
<p>  我们现在希望，对于这一景遥感影像的第一个波段（如果大家需要对多个波段加以这一操作，那么就在本文的代码中加以循环，分别对多个波段依次加以同样的处理就好），提取出其中每一个像元的数值；随后对提取出来的数据加以辐射定标，即除以<code>10000</code>，并将结果保存在一个<code>.csv</code>格式文件中，且以<strong>一列</strong>的形式来保存。这里本文之所以需要用<strong>多行一列</strong>而非<strong>多行多列</strong>的<strong>矩阵</strong>格式来存放数据，是因为后面需要将这些像素数据当作神经网络的预测样本，即<strong>一行</strong>表示<strong>一个样本</strong>，所以就需要保存为<strong>多行一列</strong>；如果大家需要保存为<strong>多行多列</strong>的<strong>矩阵</strong>格式，那代码的思路还是一致的，就是在导出数据之前将其保存为二维矩阵格式的变量就好。</p>
<p>  知道了需求，我们就可以开始代码的撰写；具体代码如下。</p>
<pre><code class="language-python"># -*- coding: utf-8 -*-
"""
Created on Wed Nov 29 01:32:28 2023

@author: fkxxgis
"""

import csv
from osgeo import gdal

file_path = "E:/04_Reconstruction/05_Image_Test/GF1WFV4.16m.2021252035621.48STB.000000_SR.tiff"
dataset = gdal.Open(file_path, gdal.GA_ReadOnly)

band = dataset.GetRasterBand(1)
data = band.ReadAsArray()
dataset = None

data = data * 0.0001
data_one_column = data.flatten()

csv_file = "E:/04_Reconstruction/05_Image_Test/column_1.csv"
with open(csv_file, 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(["Value"])
    writer.writerows([[value] for value in data_one_column])
</code></pre>
<p>  其中，我们首先导入所需的库。在这里，<code>csv</code>库用于处理<code>.csv</code>格式文件，<code>gdal</code>库（从<code>osgeo</code>模块中导入）则用于读取和处理遥感影像文件；随后，定义遥感影像文件路径——<code>file_path</code>用来指定要读取的遥感影像文件的路径。</p>
<p>  接下来，我们打开遥感影像文件。<code>dataset = gdal.Open(file_path, gdal.GA_ReadOnly)</code>意味着我们以只读方式打开遥感影像文件，并将返回的<code>Dataset</code>对象赋值给变量<code>dataset</code>；随后，获取第一个波段的像元值，这可以通过<code>band = dataset.GetRasterBand(1)</code>来完成（需要注意，这里波段编号的索引是从<code>1</code>开始的）；随后，<code>data = band.ReadAsArray()</code>意思是将波段的像元值读取为一个二维数组，并将结果赋值给变量<code>data</code>。随后，我们需要关闭遥感影像文件，通过将<code>dataset</code>变量设为<code>None</code>，释放对遥感影像文件的引用，从而关闭文件。</p>
<p>  其次，我们对像元值进行处理。首先，完成辐射定标，也就是通过<code>data = data * 0.0001</code>将像元值乘以<code>0.0001</code>；随后，将处理后的像元值按列展平——在这里，<code>data_one_column = data.flatten()</code>表示我们使用<code>flatten()</code>方法将二维数组展平为一维数组，并将结果赋值给变量<code>data_one_column</code>。</p>
<p>  最后，将上述处理好的数据写入<code>.csv</code>格式文件。其中，<code>csv_file</code>指定要写入的<code>.csv</code>格式文件的路径；<code>with open(csv_file, 'w', newline='') as file</code>表示我们使用<code>open()</code>函数打开<code>.csv</code>格式文件，并创建一个<code>csv.writer</code>对象，同时指定文件的写入模式为覆盖写入<code>'w'</code>；<code>writer.writerow(["Value"])</code>意味着我们写入<code>.csv</code>格式文件的第一行，即表头，这里是一个标题为<code>Value</code>的列；最后，<code>writer.writerows([[value] for value in data_one_column])</code>通过迭代<code>data_one_column</code>中的每个值，并将其作为单独的列表传递给<code>writer.writerows()</code>方法，从而将每个值写入<code>.csv</code>格式文件的一行中。</p>
<p>  运行上述代码，即可得到如下图所示的结果<code>.csv</code>格式文件。</p>
<p><img src="https://img2024.cnblogs.com/blog/3080295/202412/3080295-20241228183118400-1608478260.png" alt="" loading="lazy"></p>
<p>  其中，第一行就是我们的列名；后面几行数据都是<code>0</code>，这是由于原本的遥感影像在<strong>左上角区域</strong>是<strong>NoData</strong>值（大家看我们本文的第一张图就能看到）导致的。如果往下继续拖动这个<code>.csv</code>格式文件，就会看到处理后的非<code>0</code>数据了。</p>
<p>  至此，大功告成。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.08649037928125" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-28 18:33">2024-12-28 18:33</span>&nbsp;
<a href="https://www.cnblogs.com/fkxxgis">疯狂学习GIS</a>&nbsp;
阅读(<span id="post_view_count">8</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18637792" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18637792);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18637792', targetLink: 'https://www.cnblogs.com/fkxxgis/p/18637792', title: 'Python读取栅格图像并对像元数据处理后导出到表格文件中' })">举报</a>
</div>
        