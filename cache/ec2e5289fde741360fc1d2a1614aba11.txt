
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/chingho/p/18913876" title="发布于 2025-06-06 13:11">
    <span role="heading" aria-level="2">C#实现Stdio通信方式的MCP Server</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>该专栏优先在飞书发布，欢迎收藏关注！</p>
<p><a href="https://www.feishu.cn/community/article?id=7507084665509904403" target="_blank" rel="noopener nofollow">https://www.feishu.cn/community/article?id=7507084665509904403</a></p>
</blockquote>
<p>前面的课程，我们已经<strong>实现SSE通信方式的MCP Server。</strong></p>
<p><strong>下面来实现Stdio通信方式的MCP Server。</strong></p>
<p><strong>SSE方式，让我们可以与远程服务器交互。Stdio的方式，让我们可以与本地电脑交互，比如操作文件、操作数据库、与其他应用程序交互。</strong></p>
<h1 id="一创建项目"><strong>一、创建项目</strong></h1>
<p>创建控制台应用项目。</p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202506/93789-20250606130910703-2126811398.png" alt="图片" loading="lazy"></p>
<p>项目名称</p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202506/93789-20250606130910750-998900329.png" alt="图片" loading="lazy"></p>
<p>勾选配置如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202506/93789-20250606130910646-83070624.png" alt="图片" loading="lazy"></p>
<p>项目创建完成后。</p>
<p>添加依赖库：ModelContextProtocolServer.Stdio，版本为：0.0.1-preview-05。<strong>添加的时候记得勾选：包括预发行版。</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202506/93789-20250606130910745-762748050.png" alt="图片" loading="lazy"></p>
<h1 id="二代码实现">二、代码实现</h1>
<p>===</p>
<h2 id="21-programcs">2.1 Program.cs</h2>
<p>启动一个基于标准输入/输出（stdin/stdout）通信的协议服务器</p>
<pre><code>// 标准输入/输出协议服务器相关的类和方法。
using&nbsp;ModelContextProtocolServer.Stdio;
// 使用 StdioServer 类的 RunAsync 方法启动一个异步的标准输入/输出服务器。
await&nbsp;StdioServer.RunAsync(args);
</code></pre>
<h2 id="22-stadi-实例代码">2.2 Stadi 实例代码</h2>
<p>添加类：FileTool</p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202506/93789-20250606130910662-749061774.png" alt="图片" loading="lazy"></p>
<p>FileTool的代码如下，这里有几个关键点，通过为类、方法、参数来添加标识，这样才能被识别 MCP tool：</p>
<p>1、[<strong>McpServerToolType</strong>] 标记此类为 MCP 服务器工具类型</p>
<p>2、[<strong>McpServerTool</strong>] 标记的方法会被框架识别并注册为可用工具。</p>
<p>3、[<strong>Description</strong>("获取服务器时间")] &nbsp;描述方法的工具。</p>
<p>4、[<strong>Description</strong>("格式")] &nbsp; 描述参数。</p>
<p>5、提供2个工具方法：<strong>读取本地文件内容，保存内容至本地文件。</strong></p>
<pre><code>// MCP 协议服务端所需的核心特性与类型。
using&nbsp;ModelContextProtocol.Server;
// 用于支持 [Description] 特性，提供描述信息。
using&nbsp;System.ComponentModel;
namespace&nbsp;MCPServer.Stdio
{
&nbsp; &nbsp;&nbsp;///&nbsp;&lt;summary&gt;
&nbsp; &nbsp;&nbsp;///&nbsp;标记此类为 MCP 服务器可用的工具类型，客户端可通过协议调用其中的方法。
&nbsp; &nbsp;&nbsp;///&nbsp;&lt;/summary&gt;
&nbsp; &nbsp; [McpServerToolType]
&nbsp; &nbsp;&nbsp;public&nbsp;static&nbsp;class&nbsp;FileTool
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;读取指定路径的文件内容。
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;/summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;param name="path"&gt;要读取的文件的完整路径&lt;/param&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;returns&gt;文件的内容字符串&lt;/returns&gt;
&nbsp; &nbsp; &nbsp; &nbsp; [McpServerTool, Description("读取文件")]
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;public&nbsp;static&nbsp;async&nbsp;Task&lt;string&gt;&nbsp;ReadFile([Description("文件路径")]&nbsp;string&nbsp;path)
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 检查文件是否存在，若不存在则抛出异常
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!File.Exists(path))
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;FileNotFoundException("文件不存在");
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 异步读取文件内容并返回
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;await&nbsp;File.ReadAllTextAsync(path);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;将指定内容保存到指定路径的文件中。
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;如果目标目录不存在，则自动创建。
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;/summary&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;param name="path"&gt;要保存的文件路径&lt;/param&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;param name="content"&gt;要写入文件的内容字符串&lt;/param&gt;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;///&nbsp;&lt;returns&gt;操作结果信息&lt;/returns&gt;
&nbsp; &nbsp; &nbsp; &nbsp; [McpServerTool, Description("保存文件")]
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;public&nbsp;static&nbsp;async&nbsp;Task&lt;string&gt;&nbsp;SaveFile([Description("文件路径")]&nbsp;string&nbsp;path, [Description("内容")]&nbsp;string&nbsp;content)
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;try
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 获取文件所在目录路径
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;var&nbsp;directory = Path.GetDirectoryName(path);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 如果目录不为空且不存在，则创建目录
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!string.IsNullOrEmpty(directory) &amp;&amp; !Directory.Exists(directory))
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Directory.CreateDirectory(directory);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 使用异步方式将内容写入文件（覆盖模式）
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;await&nbsp;File.WriteAllTextAsync(path, content);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 返回成功提示
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;$"文件已成功保存至:&nbsp;{path}";
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;catch&nbsp;(Exception ex)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 捕获所有异常并返回错误信息，防止崩溃并便于调试
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;$"保存文件时发生错误:&nbsp;{ex.Message}";
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
}
</code></pre>
<h2 id="23-项目发布">2.3 项目发布</h2>
<p><img src="https://img2024.cnblogs.com/blog/93789/202506/93789-20250606130910677-1373784459.png" alt="图片" loading="lazy"></p>
<h1 id="三结合mcp-client-测试效果">三、结合MCP Client 测试效果</h1>
<p>===</p>
<p>使用上一个课程：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;mid=2449946251&amp;idx=1&amp;sn=d4cd6345e9bff7b40c5d72c4d1b5a0ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">C#实现MCP Client 与 LLM 连接，抓取网页内容功能！</a> 的Client示例。</p>
<p>修改 Program.cs 的代码。</p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202506/93789-20250606130910718-424193264.png" alt="图片" loading="lazy"></p>
<p>其中Command为项目发布后的程序路径。<strong>备注：路径记得修改为自己的！</strong></p>
<pre><code>// 创建一个基于标准输入/输出（stdio）的客户端传输配置对象
var&nbsp;config&nbsp;=&nbsp;new&nbsp;StdioClientTransport(new&nbsp;StdioClientTransportOptions()
{
&nbsp; &nbsp;&nbsp;// 设置要启动的服务端可执行文件路径
&nbsp; &nbsp;&nbsp;Command&nbsp;=&nbsp;"e:\\project\\mcpdemo\\mcpserver.stdio\\bin\\release\\net8.0\\publish\\win-x64\\MCPServer.Stdio.exe"
});
</code></pre>
<p>运行MCP Client，成功连接MCP Server，并打印出工具列表。</p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202506/93789-20250606130910797-1833603306.png" alt="图片" loading="lazy"></p>
<p>输入以下命令：</p>
<pre><code>读取 &nbsp;e:\本地文件.txt 的内容
</code></pre>
<p>大模型会调用本地工具，读取本地文件的内容，并返回结果如下。</p>
<p><strong>备注：</strong>本地文件 <strong>e:\本地文件.txt</strong>，需要提前创建。</p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202506/93789-20250606130910656-1053865109.png" alt="图片" loading="lazy"></p>
<p>输入以下命令：</p>
<pre><code>将内容：这是MPC&nbsp;Server实例，保存到文件路径：e:\stdio.txt
</code></pre>
<p>大模型会调用本地工具，将内容保存至本地文件，并返回结果如下。</p>
<p><img src="https://img2024.cnblogs.com/blog/93789/202506/93789-20250606130910630-1483743687.png" alt="图片" loading="lazy"></p>
<p>也可以直接刚才保存的内容。</p>
<p>好了，今天就分享到这边！</p>
<p><strong>文中示例代码：</strong><a href="https://pan.quark.cn/s/a4f479c2eed2" target="_blank" rel="noopener nofollow">https://pan.quark.cn/s/a4f479c2eed2</a></p>
<p>- End -</p>
<p>推荐阅读</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;mid=2449946266&amp;idx=1&amp;sn=681c2b4e3debbbad29fff199b4658b6b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">C#实现SSE通信方式的MCP Server</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;mid=2449946251&amp;idx=1&amp;sn=d4cd6345e9bff7b40c5d72c4d1b5a0ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">C#实现MCP Client 与 LLM 连接，抓取网页内容功能！</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;mid=2449946235&amp;idx=1&amp;sn=a56c877cf4e1ddbccc157de1ee060f8b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">VS Code + Cline + 魔搭MCP Server 实现抓取网页内容。</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;mid=2449946207&amp;idx=1&amp;sn=e2650b43d0019b2f222762545bf73a43&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">C#实现自己的MCP Client</a></p>

</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04929618073726852" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-06 13:12">2025-06-06 13:11</span>&nbsp;
<a href="https://www.cnblogs.com/chingho">chingho</a>&nbsp;
阅读(<span id="post_view_count">16</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18913876);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18913876', targetLink: 'https://www.cnblogs.com/chingho/p/18913876', title: 'C#实现Stdio通信方式的MCP Server' })">举报</a>
</div>
	