
        <h2>
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wuhuacong/p/18643743" title="发布于 2024-12-31 21:34">
    <span role="heading" aria-level="2">WxPython跨平台开发框架之前后端结合实现附件信息的上传及管理</span>
    

</a>

        </h2>
        <div class="postbody">
                <div id="cnblogs_post_description" style="display: none">
        
        在使用 wxPython 开发跨平台应用时，结合后端实现附件信息的上传和管理是一种常见需求。WxPython跨平台开发框架是前后端分离的框架，前端采用的是WxPython + aiohttp 来构建跨平台的界面展示和处理，后端使用 FastAPI, SQLAlchemy, Pydantic, Redis 等技术构建的项目。后端数据库访问采用异步方式；数据库操作和控制器操作，采用基类继承的方式减少重复代码，提高代码复用性。支持Mysql、Mssql、Postgresql、Sqlite等多种数据库接入，通过配置可以指定数据库连接方式。
本篇随笔介绍WxPython跨平台开发框架之前后端结合实现附件信息的上传及管理，介绍附件管理中的前端展示、上传等操作，后端的接收附件以及存储文件和数据库信息等相关操作。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>在使用 wxPython 开发跨平台应用时，结合后端实现附件信息的上传和管理是一种常见需求。WxPython跨平台开发框架是前后端分离的框架，前端采用的是WxPython + aiohttp&nbsp;来构建跨平台的界面展示和处理，后端使用 FastAPI, SQLAlchemy, Pydantic, Redis 等技术构建的项目。后端数据库访问采用异步方式；数据库操作和控制器操作，采用基类继承的方式减少重复代码，提高代码复用性。<span>支持Mysql、Mssql、Postgresql、Sqlite等多种数据库接入，通过配置可以指定数据库连接方式。</span></p>
<div>
<div>&nbsp;本篇随笔介绍WxPython跨平台开发框架之前后端结合实现附件信息的上传及管理，介绍附件管理中的前端展示、上传等操作，后端的接收附件以及存储文件和数据库信息等相关操作。</div>
</div>
<h3>1、功能描述和界面</h3>
<ul>
<li><strong>前端（wxPython GUI）</strong>：
<ul>
<li>提供文件选择、显示文件列表的界面。</li>
<li>支持上传、删除和下载附件。</li>
<li>展示上传状态和附件信息（如文件名、大小、上传时间）。</li>
</ul>
</li>
<li><strong>后端（REST API 服务）</strong>：
<ul>
<li>提供上传、删除、获取附件信息的接口。</li>
<li>使用常见的 Web 框架（如 Flask 或 FastAPI）实现。</li>
</ul>
</li>
</ul>
<p>首先前端我们需要一个对所有附件进行管理的界面，以便对于附件进行统一的维护处理。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241231162425557-1822601342.png" alt="" width="885" height="555" loading="lazy"></p>
<p>前端发起上传附件的处理，如下界面所示，可以选择多个不同类型的文件。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241231163226333-1049460447.png" alt="" width="883" height="554" loading="lazy"></p>
<p>&nbsp;上传成功后，我们可以打开附件信息记录，如果是图片会显示出来，如果是其他格式，可以通过打开链接方式下载查看。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241231163444683-948982934.png" alt="" width="554" height="445" loading="lazy"></p>
<p>&nbsp;</p>
<h3>2、功能的实现处理</h3>
<p>如果附件是简单的上传，比较容易处理，我们可以先了解一下简单的做法，然后在深入探讨实际框架中对于附件的处理。</p>
<h4>1) FastAPI 端实现文件上传接口</h4>
<p>首先，在 FastAPI 中创建一个接收文件的接口：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">from</span> fastapi <span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> FastAPI, File, UploadFile

app </span>=<span style="color: rgba(0, 0, 0, 1)"> FastAPI()

@app.post(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/upload/</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
async </span><span style="color: rgba(0, 0, 255, 1)">def</span> upload_file(file: UploadFile =<span style="color: rgba(0, 0, 0, 1)"> File(...)):
    with open(file.filename, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">wb</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">) as f:
        f.write(await file.read())
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> {<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">filename</span><span style="color: rgba(128, 0, 0, 1)">"</span>: file.filename}</pre>
</div>
<p>在公布对应的API接口后，在 前端的 wxPython 项目中，您可以通过 <code>requests</code> 库 或者&nbsp;aiohttp 库 与&nbsp;FastAPI 交互来实现文件上传。以下是简单的实现步骤和示例代码</p>
<div>&nbsp;
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> wx
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> requests

</span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> FileUploadFrame(wx.Frame):
    </span><span style="color: rgba(0, 0, 255, 1)">def</span> <span style="color: rgba(128, 0, 128, 1)">__init__</span>(self, *args, **<span style="color: rgba(0, 0, 0, 1)">kwargs):
        super().</span><span style="color: rgba(128, 0, 128, 1)">__init__</span>(*args, **<span style="color: rgba(0, 0, 0, 1)">kwargs)

        panel </span>=<span style="color: rgba(0, 0, 0, 1)"> wx.Panel(self)
        self.upload_button </span>= wx.Button(panel, label=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">上传文件</span><span style="color: rgba(128, 0, 0, 1)">"</span>, pos=(20, 20<span style="color: rgba(0, 0, 0, 1)">))
        self.upload_button.Bind(wx.EVT_BUTTON, self.on_upload)

        self.status_text </span>= wx.StaticText(panel, label=<span style="color: rgba(128, 0, 0, 1)">""</span>, pos=(20, 60<span style="color: rgba(0, 0, 0, 1)">))

    </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> on_upload(self, event):
        with wx.FileDialog(
            self, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">选择文件</span><span style="color: rgba(128, 0, 0, 1)">"</span>, wildcard=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">所有文件 (*.*)|*.*</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
            style</span>=wx.FD_OPEN |<span style="color: rgba(0, 0, 0, 1)"> wx.FD_FILE_MUST_EXIST
        ) as file_dialog:
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> file_dialog.ShowModal() ==<span style="color: rgba(0, 0, 0, 1)"> wx.ID_CANCEL:
                </span><span style="color: rgba(0, 0, 255, 1)">return</span>  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 用户取消选择</span>

            <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 获取文件路径</span>
            file_path =<span style="color: rgba(0, 0, 0, 1)"> file_dialog.GetPath()
            </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)">:
                self.upload_file(file_path)
            </span><span style="color: rgba(0, 0, 255, 1)">except</span><span style="color: rgba(0, 0, 0, 1)"> Exception as e:
                wx.LogError(f</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">文件上传失败: {e}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

    </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> upload_file(self, file_path):
        url </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">http://127.0.0.1:8000/upload/</span><span style="color: rgba(128, 0, 0, 1)">"</span>  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> FastAPI 服务器的上传接口</span>
        with open(file_path, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">rb</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">) as file:
            files </span>= {<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">file</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">: file}
            response </span>= requests.post(url, files=<span style="color: rgba(0, 0, 0, 1)">files)
        
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> response.status_code == 200<span style="color: rgba(0, 0, 0, 1)">:
            self.status_text.SetLabel(f</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">上传成功: {response.json().get('filename')}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
        </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">:
            self.status_text.SetLabel(f</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">上传失败: {response.status_code}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

</span><span style="color: rgba(0, 0, 255, 1)">if</span> <span style="color: rgba(128, 0, 128, 1)">__name__</span> == <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">__main__</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">:
    app </span>=<span style="color: rgba(0, 0, 0, 1)"> wx.App(False)
    frame </span>= FileUploadFrame(None, title=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">文件上传</span><span style="color: rgba(128, 0, 0, 1)">"</span>, size=(300, 150<span style="color: rgba(0, 0, 0, 1)">))
    frame.Show()
    app.MainLoop()</span></pre>
</div>
<p>&nbsp;</p>
<h4>2) 上传多个文件的处理方式</h4>
<p>上面是单个文件的上传处理，如果要一次性提交多个文件到 FastAPI 接口，可以使用 FastAPI 的 <code>List[UploadFile]</code> 类型接收多个文件。以下是完整的实现方法。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">from</span> fastapi <span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> FastAPI, File, UploadFile
</span><span style="color: rgba(0, 0, 255, 1)">from</span> typing <span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> List

app </span>=<span style="color: rgba(0, 0, 0, 1)"> FastAPI()

@app.post(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/upload/</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
async </span><span style="color: rgba(0, 0, 255, 1)">def</span> upload_files(files: List[UploadFile] =<span style="color: rgba(0, 0, 0, 1)"> File(...)):
    saved_files </span>=<span style="color: rgba(0, 0, 0, 1)"> []
    </span><span style="color: rgba(0, 0, 255, 1)">for</span> file <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> files:
        file_path </span>= f<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">./uploaded/{file.filename}</span><span style="color: rgba(128, 0, 0, 1)">"</span>  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 保存到 uploaded 目录</span>
        with open(file_path, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">wb</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">) as f:
            f.write(await file.read())
        saved_files.append(file.filename)
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> {<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">uploaded_files</span><span style="color: rgba(128, 0, 0, 1)">"</span>: saved_files}</pre>
</div>
<p>而在前端WxPython的处理中，需要对多个文件进行上传处理即可，可以使用 <code>wx.FileDialog</code> 的多选功能，并通过 <code>requests</code> 库批量上传多个文件。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> wx
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> requests

</span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> MultiFileUploadFrame(wx.Frame):
    </span><span style="color: rgba(0, 0, 255, 1)">def</span> <span style="color: rgba(128, 0, 128, 1)">__init__</span>(self, *args, **<span style="color: rgba(0, 0, 0, 1)">kwargs):
        super().</span><span style="color: rgba(128, 0, 128, 1)">__init__</span>(*args, **<span style="color: rgba(0, 0, 0, 1)">kwargs)

        panel </span>=<span style="color: rgba(0, 0, 0, 1)"> wx.Panel(self)
        self.upload_button </span>= wx.Button(panel, label=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">上传多个文件</span><span style="color: rgba(128, 0, 0, 1)">"</span>, pos=(20, 20<span style="color: rgba(0, 0, 0, 1)">))
        self.upload_button.Bind(wx.EVT_BUTTON, self.on_upload)

        self.status_text </span>= wx.StaticText(panel, label=<span style="color: rgba(128, 0, 0, 1)">""</span>, pos=(20, 60), size=(300, -1<span style="color: rgba(0, 0, 0, 1)">))

    </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> on_upload(self, event):
        with wx.FileDialog(
            self, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">选择文件</span><span style="color: rgba(128, 0, 0, 1)">"</span>, wildcard=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">所有文件 (*.*)|*.*</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
            style</span>=wx.FD_OPEN |<span style="color: rgba(0, 0, 0, 1)"> wx.FD_MULTIPLE
        ) as file_dialog:
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> file_dialog.ShowModal() ==<span style="color: rgba(0, 0, 0, 1)"> wx.ID_CANCEL:
                </span><span style="color: rgba(0, 0, 255, 1)">return</span>  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 用户取消选择</span>

            <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 获取选择的多个文件路径</span>
            file_paths =<span style="color: rgba(0, 0, 0, 1)"> file_dialog.GetPaths()
            </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)">:
                self.upload_files(file_paths)
            </span><span style="color: rgba(0, 0, 255, 1)">except</span><span style="color: rgba(0, 0, 0, 1)"> Exception as e:
                wx.LogError(f</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">文件上传失败: {e}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

    </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> upload_files(self, file_paths):
        url </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">http://127.0.0.1:8000/upload/</span><span style="color: rgba(128, 0, 0, 1)">"</span>  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> FastAPI 服务器的上传接口</span>
        files = [(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">files</span><span style="color: rgba(128, 0, 0, 1)">"</span>, (file_path.split(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/</span><span style="color: rgba(128, 0, 0, 1)">"</span>)[-1], open(file_path, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">rb</span><span style="color: rgba(128, 0, 0, 1)">"</span>))) <span style="color: rgba(0, 0, 255, 1)">for</span> file_path <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> file_paths]
        
        response </span>= requests.post(url, files=<span style="color: rgba(0, 0, 0, 1)">files)
        
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> response.status_code == 200<span style="color: rgba(0, 0, 0, 1)">:
            uploaded_files </span>= response.json().get(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">uploaded_files</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, [])
            self.status_text.SetLabel(f</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">上传成功: {', '.join(uploaded_files)}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
        </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">:
            self.status_text.SetLabel(f</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">上传失败: {response.status_code}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

</span><span style="color: rgba(0, 0, 255, 1)">if</span> <span style="color: rgba(128, 0, 128, 1)">__name__</span> == <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">__main__</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">:
    app </span>=<span style="color: rgba(0, 0, 0, 1)"> wx.App(False)
    frame </span>= MultiFileUploadFrame(None, title=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">多文件上传</span><span style="color: rgba(128, 0, 0, 1)">"</span>, size=(400, 200<span style="color: rgba(0, 0, 0, 1)">))
    frame.Show()
    app.MainLoop()</span></pre>
</div>
</div>
<p>不过我们附件的上传，往往还需要伴随着一些额外的信息，方便把这些信息存储在数据库中供查询参考，同时也是关联业务模块和附件信息的重要依据。</p>
<p>如果需要在上传多个文件的同时传递额外参数（如 <code>guid</code> 和 <code>folder</code>），可以将这些参数通过 POST 请求的表单数据 (<code>data</code>) 传递。FastAPI 可以同时处理文件和表单数据。&nbsp;</p>
<p>修改 FastAPI 接口以支持接收额外参数：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">from</span> fastapi <span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> FastAPI, File, UploadFile, Form
</span><span style="color: rgba(0, 0, 255, 1)">from</span> typing <span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> List

app </span>=<span style="color: rgba(0, 0, 0, 1)"> FastAPI()

@app.post(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/upload/</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
async </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> upload_files(
    guid: str </span>= Form(...),  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 接收 GUID 参数</span>
    folder: str = Form(...),  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 接收 folder 参数</span>
    files: List[UploadFile] = File(...),  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 接收文件</span>
<span style="color: rgba(0, 0, 0, 1)">):
    saved_files </span>=<span style="color: rgba(0, 0, 0, 1)"> []
    </span><span style="color: rgba(0, 0, 255, 1)">for</span> file <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> files:
        file_path </span>= f<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">./{folder}/{file.filename}</span><span style="color: rgba(128, 0, 0, 1)">"</span>  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 保存到指定的文件夹</span>
        with open(file_path, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">wb</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">) as f:
            f.write(await file.read())
        saved_files.append(file.filename)
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> {<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">guid</span><span style="color: rgba(128, 0, 0, 1)">"</span>: guid, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">folder</span><span style="color: rgba(128, 0, 0, 1)">"</span>: folder, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">uploaded_files</span><span style="color: rgba(128, 0, 0, 1)">"</span>: saved_files}</pre>
</div>
<p>而前端WxPython中对上传文件的地方进行适当的修改即可。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> upload_files(self, file_paths, guid, folder):
        url </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">http://127.0.0.1:8000/upload/</span><span style="color: rgba(128, 0, 0, 1)">"</span>  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> FastAPI 服务器的上传接口</span>
        data = {<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">guid</span><span style="color: rgba(128, 0, 0, 1)">"</span>: guid, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">folder</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">: folder}
        files </span>= [(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">files</span><span style="color: rgba(128, 0, 0, 1)">"</span>, (file_path.split(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/</span><span style="color: rgba(128, 0, 0, 1)">"</span>)[-1], open(file_path, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">rb</span><span style="color: rgba(128, 0, 0, 1)">"</span>))) <span style="color: rgba(0, 0, 255, 1)">for</span> file_path <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> file_paths]

        response </span>= requests.post(url, data=data, files=<span style="color: rgba(0, 0, 0, 1)">files)
        
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 释放文件资源</span>
        <span style="color: rgba(0, 0, 255, 1)">for</span> _, file_obj <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> files:
            file_obj[</span>1<span style="color: rgba(0, 0, 0, 1)">].close()

        </span><span style="color: rgba(0, 0, 255, 1)">if</span> response.status_code == 200<span style="color: rgba(0, 0, 0, 1)">:
            uploaded_files </span>= response.json().get(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">uploaded_files</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, [])
            self.status_text.SetLabel(f</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">上传成功: {', '.join(uploaded_files)}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
        </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">:
            self.status_text.SetLabel(f</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">上传失败: {response.status_code}</span><span style="color: rgba(128, 0, 0, 1)">"</span>)</pre>
</div>
<p>如果需要使用 <code>aiohttp</code> 进行异步数据请求，可以将 <code>aiohttp</code> 集成到 wxPython 的事件处理流程中，利用 <code>asyncio</code> 的事件循环处理异步任务。</p>
<p>客户端使用 <code>aiohttp</code> 进行异步请求。<code>wxasync</code> 库可以将 wxPython 和 asyncio 集成，从而支持异步操作。</p>
<div class="cnblogs_code">
<pre>    async <span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> upload_files(self, file_paths, guid, folder):
        url </span>= <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">http://127.0.0.1:8000/upload/</span><span style="color: rgba(128, 0, 0, 1)">"</span>  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> FastAPI 服务器的上传接口</span>
        data = {<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">guid</span><span style="color: rgba(128, 0, 0, 1)">"</span>: guid, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">folder</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">: folder}
        files </span>=<span style="color: rgba(0, 0, 0, 1)"> [
            (</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">files</span><span style="color: rgba(128, 0, 0, 1)">"</span>, (file_path.split(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/</span><span style="color: rgba(128, 0, 0, 1)">"</span>)[-1], open(file_path, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">rb</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">).read()))
            </span><span style="color: rgba(0, 0, 255, 1)">for</span> file_path <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> file_paths
        ]

        async with aiohttp.ClientSession() as session:
            </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 构造文件表单</span>
            form_data =<span style="color: rgba(0, 0, 0, 1)"> aiohttp.FormData()
            </span><span style="color: rgba(0, 0, 255, 1)">for</span> key, value <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> data.items():
                form_data.add_field(key, value)
            </span><span style="color: rgba(0, 0, 255, 1)">for</span> name, (filename, file_content) <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> files:
                form_data.add_field(name, file_content, filename</span>=<span style="color: rgba(0, 0, 0, 1)">filename)

            </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 异步 POST 请求</span>
            async with session.post(url, data=<span style="color: rgba(0, 0, 0, 1)">form_data) as response:
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> response.status == 200<span style="color: rgba(0, 0, 0, 1)">:
                    result </span>=<span style="color: rgba(0, 0, 0, 1)"> await response.json()
                    uploaded_files </span>= result.get(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">uploaded_files</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, [])
                    self.status_text.SetLabel(f</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">上传成功: {', '.join(uploaded_files)}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
                </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">:
                    self.status_text.SetLabel(f</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">上传失败: {response.status}</span><span style="color: rgba(128, 0, 0, 1)">"</span>)</pre>
</div>
<h4>3）文件名出现乱码的解决</h4>
<p>在 FastAPI 中处理中文文件名时，如果不希望上传后的文件名被改变为其他编码（例如 UTF-8 编码被转为 ASCII 或其他编码），可以确保文件名在上传和保存时都以正确的编码进行处理。在使用 <code>aiohttp</code> 提交 <code>FormData</code> 时，中文文件名可能会因为编码不一致或处理不当而导致乱码。</p>
<p>当服务器接收到一个经过 URL 编码（也叫百分号编码）的文件名，如 <code>'%E5%A4%87%E8%B4%A7%E8%AE%A2%E5%8D%95%E5%AF%BC%E5%87%BA.xls'</code>，你可以使用 Python 的 <code>urllib.parse</code> 模块来解码它，从而得到正确的文件名。</p>
<p>URL 编码是将非 ASCII 字符（如中文字符）转换为 <code>%</code> 后跟随两个十六进制数字的格式。因此，你需要使用 <code>urllib.parse.unquote</code> 或 <code>urllib.parse.unquote_plus</code> 来将其还原为原始字符串。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> urllib.parse

</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 经过 URL 编码的文件名</span>
encoded_filename = <span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">%E5%A4%87%E8%B4%A7%E8%AE%A2%E5%8D%95%E5%AF%BC%E5%87%BA.xls</span><span style="color: rgba(128, 0, 0, 1)">'</span>

<span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 使用 unquote 解码</span>
decoded_filename =<span style="color: rgba(0, 0, 0, 1)"> urllib.parse.unquote(encoded_filename)

</span><span style="color: rgba(0, 0, 255, 1)">print</span>(decoded_filename)  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 输出：备货订单导出.xls</span></pre>
</div>
<p>urllib.parse.unquote()：用于解码 URL 编码的字符串，将百分号编码（如 %E5%A4%87）还原为原始字符。</p>
<p>如果文件名中有 + 符号代表空格（例如 Hello+World.txt），你可以使用 urllib.parse.unquote_plus()，它会将 + 转换为空格。&nbsp;</p>
<p>假设你在 FastAPI 中接收一个 URL 编码的文件名，并想要将其解析为正确的中文文件名：&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">from</span> fastapi <span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> FastAPI, File, UploadFile
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> urllib.parse

app </span>=<span style="color: rgba(0, 0, 0, 1)"> FastAPI()

@app.post(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/upload/</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
async </span><span style="color: rgba(0, 0, 255, 1)">def</span> upload_file(file: UploadFile =<span style="color: rgba(0, 0, 0, 1)"> File(...)):
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 获取 URL 编码的文件名</span>
    encoded_filename =<span style="color: rgba(0, 0, 0, 1)"> file.filename
    
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 解码文件名</span>
    decoded_filename =<span style="color: rgba(0, 0, 0, 1)"> urllib.parse.unquote(encoded_filename)
    
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 保存文件</span>
    file_location = f<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">uploads/{decoded_filename}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
    with open(file_location, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">wb</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">) as buffer:
        buffer.write(await file.read())
    
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> {<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">filename</span><span style="color: rgba(128, 0, 0, 1)">"</span>: decoded_filename, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">file_path</span><span style="color: rgba(128, 0, 0, 1)">"</span>: file_location}</pre>
</div>
<h4>4）后端提供提供静态文件访问，实现通过&nbsp;URL 地址访问上传的文件</h4>
<p>在 FastAPI 中上传文件后，默认情况下，文件存储在服务器的某个路径中。如果你想通过 URL 地址访问上传的文件，你需要确保文件保存的位置可以通过静态文件服务器访问，并且文件路径是公开可访问的。</p>
<p>FastAPI 提供了 <code>StaticFiles</code> 类，用于处理静态文件（如图片、CSS 文件等）的托管。你可以使用 <code>StaticFiles</code> 将上传的文件夹暴露为静态文件夹，并通过 URL 地址访问这些文件。</p>
<p>步骤：</p>
<ol>
<li><strong>设置静态文件目录</strong>：将上传的文件存储在一个公共目录中，并将该目录配置为静态文件目录。</li>
<li><strong>访问文件</strong>：通过 URL 访问这些文件。</li>
</ol>
<p>假设你希望将上传的文件存储在 <code>uploads</code> 目录，并能够通过 <code>http://127.0.0.1:8000/uploads/{filename}</code> 访问文件。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">from</span> fastapi <span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> FastAPI, File, UploadFile
</span><span style="color: rgba(0, 0, 255, 1)">from</span> fastapi.staticfiles <span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> StaticFiles
</span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> os

app </span>=<span style="color: rgba(0, 0, 0, 1)"> FastAPI()

</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 将 uploads 目录映射为静态文件路径</span>
app.mount(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/uploads</span><span style="color: rgba(128, 0, 0, 1)">"</span>, StaticFiles(directory=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">uploads</span><span style="color: rgba(128, 0, 0, 1)">"</span>), name=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">uploads</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建上传文件的 API</span>
@app.post(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/upload/</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
async </span><span style="color: rgba(0, 0, 255, 1)">def</span> upload_file(file: UploadFile =<span style="color: rgba(0, 0, 0, 1)"> File(...)):
    file_location </span>= f<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">uploads/{file.filename}</span><span style="color: rgba(128, 0, 0, 1)">"</span>
    
    <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 保存上传的文件</span>
    with open(file_location, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">wb</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">) as buffer:
        buffer.write(await file.read())
    
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> {<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">filename</span><span style="color: rgba(128, 0, 0, 1)">"</span>: file.filename, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">file_path</span><span style="color: rgba(128, 0, 0, 1)">"</span>: file_location}</pre>
</div>
<p>代码解释：</p>
<ul>
<li><strong><code>app.mount("/uploads", StaticFiles(directory="uploads"), name="uploads")</code></strong>：这行代码将 <code>uploads</code> 目录挂载为静态文件目录。即，FastAPI 会将该目录中的文件作为静态文件提供服务，URL 访问时通过 <code>/uploads</code> 路径访问这些文件。</li>
<li><strong>上传文件</strong>：上传的文件会被保存到 <code>uploads</code> 目录中。</li>
<li><strong>访问文件</strong>：文件上传后，你可以通过 <code>http://127.0.0.1:8000/uploads/{filename}</code> 来访问上传的文件。</li>
</ul>
<p>重要提示：</p>
<ul>
<li><strong>目录权限</strong>：确保 FastAPI 进程对上传目录（如 <code>uploads</code>）有写权限，且该目录可公开访问。</li>
<li><strong>文件安全</strong>：通过 URL 访问文件时要小心文件路径的安全性，避免恶意用户访问服务器上的敏感文件。你可以通过验证文件名或添加身份验证来保护这些文件。</li>
</ul>
<p>进一步增强：</p>
<ol>
<li>
<p><strong>自定义文件路径</strong>：如果你想使用更加结构化的文件路径（例如按用户、日期等组织文件），你可以动态创建文件路径，并确保文件夹存在。</p>
</li>
<li>
<p><strong>限制文件大小和类型</strong>：你可以在上传文件时限制文件的类型和大小，确保上传的文件符合预期。</p>
</li>
</ol>
<p>&nbsp;</p>
<h3>3、WxPython跨平台框架的实现方式</h3>
<p>上面介绍了很多上传文件的前端后端处理方式的细节，基于上面的各个地方我们进行了整合优化，因此实现方式上有所差异。</p>
<p>首先，在FastAPI的启动的时候，我们通过一个函数来注册静态文件的处理，方便上传文件后，可以通过上传文件的静态路径打开文件。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> register_static_file(app: FastAPI):
    </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">
    静态文件交互开发模式, 生产使用 nginx 静态资源服务

    :param app:
    :return:
    </span><span style="color: rgba(128, 0, 0, 1)">"""</span>
    <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> settings.STATIC_FILES:
        </span><span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> os
        </span><span style="color: rgba(0, 0, 255, 1)">from</span> fastapi.staticfiles <span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> StaticFiles

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 静态文件</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> <span style="color: rgba(0, 0, 255, 1)">not</span><span style="color: rgba(0, 0, 0, 1)"> os.path.exists(STATIC_DIR):
            os.mkdir(STATIC_DIR)
        app.mount(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/static</span><span style="color: rgba(128, 0, 0, 1)">"</span>, StaticFiles(directory=STATIC_DIR), name=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">static</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 上传文件</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> <span style="color: rgba(0, 0, 255, 1)">not</span><span style="color: rgba(0, 0, 0, 1)"> os.path.exists(UPLOAD_FILES_DIR):
            os.mkdir(UPLOAD_FILES_DIR)
        app.mount(
            </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">/uploadfiles</span><span style="color: rgba(128, 0, 0, 1)">"</span>, StaticFiles(directory=UPLOAD_FILES_DIR), name=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">uploadfiles</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
        )</span></pre>
</div>
<p>然后在FastAPI的路由器上提供上传文件的接口定义，如下所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241231211125233-1919630420.png" alt="" loading="lazy"></p>
<p>&nbsp;接着通过遍历文件集合的方式，获得文件的名称、扩展名、字节集合、字节长度、以及其他相关的附带参数等等，从而构建附件的信息，方便保存到数据库进行存储。</p>
<div class="cnblogs_code">
<pre>    res_list =<span style="color: rgba(0, 0, 0, 1)"> []
    </span><span style="color: rgba(0, 0, 255, 1)">for</span> file <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> files:
        file_bytes </span>= await file.read()  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 读取文件内容</span>
        extension = Path(file.filename).suffix  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 使用 pathlib</span>
        file_name = urllib.parse.unquote(Path(file.filename).name)  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 对文件名进行解码</span>
        <span style="color: rgba(0, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">file_name:</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, file_name)

        dto </span>=<span style="color: rgba(0, 0, 0, 1)"> FileUploadDto(
            id</span>=<span style="color: rgba(0, 0, 0, 1)">uuid.uuid4().hex,
            filename</span>=<span style="color: rgba(0, 0, 0, 1)">file_name,
            fileextend</span>=<span style="color: rgba(0, 0, 0, 1)">extension,
            filedata</span>=<span style="color: rgba(0, 0, 0, 1)">file_bytes,
            filesize</span>=<span style="color: rgba(0, 0, 0, 1)">len(file_bytes),
            category</span>=<span style="color: rgba(0, 0, 0, 1)">folder,
            attachmentguid</span>=<span style="color: rgba(0, 0, 0, 1)">guid,
            addtime</span>=<span style="color: rgba(0, 0, 0, 1)">datetime.now(),
        )</span></pre>
</div>
<p>文件信息，我们是另外存储在文件系统中的，需要判断文件是否存在，如果存在，使用另外的名称，然后在进行写入。</p>
<div class="cnblogs_code">
<pre>        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 创建目录</span>
        os.makedirs(os.path.dirname(file_location), exist_ok=<span style="color: rgba(0, 0, 0, 1)">True)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 保存文件到文件系统</span>
        with open(file_location, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">wb</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">) as buffer:
            buffer.write(file_bytes)</span></pre>
</div>
<p>然后就是把文件的相关信息写入数据库，并返回相关的实体对象给前端即可。</p>
<div class="cnblogs_code">
<pre>        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 保存文件信息到数据库</span>
        res =<span style="color: rgba(0, 0, 0, 1)"> await fileupload_crud.create(db, dto)

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 上传成功后，获取对应的地址返回</span>
        url =<span style="color: rgba(0, 0, 0, 1)"> get_file_url(request, dto.basepath, dto.savepath)
        res_list.append(ResponseFileInfo(id</span>=dto.id, name=dto.filename, url=url))</pre>
</div>
<p>Wxpython的前端需要封装对文件上传的API的调用，如下所示。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241231211839967-1083125831.png" alt="" loading="lazy"></p>
<p>&nbsp;其中有一个ApiClient来代替通用的文件上传处理逻辑。其中主要就是构建一个FormData,把上传操作的额外参数和文件信息填入其中。</p>
<div class="cnblogs_code">
<pre>        form_data =<span style="color: rgba(0, 0, 0, 1)"> aiohttp.FormData()
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> key, value <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> data.items():
            form_data.add_field(key, value)</span></pre>
</div>
<p>文件信息，一样的处理方式，根据文件路径获得相关的文件名称和字节内容，然后添加到其中即可。</p>
<div class="cnblogs_code">
<pre>        <span style="color: rgba(0, 0, 255, 1)">if</span> filepath_list <span style="color: rgba(0, 0, 255, 1)">and</span> len(filepath_list) &gt;<span style="color: rgba(0, 0, 0, 1)"> 0:
            files </span>=<span style="color: rgba(0, 0, 0, 1)"> [
                (</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">files</span><span style="color: rgba(128, 0, 0, 1)">"</span>, (Path(file_path).name, open(file_path, <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">rb</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)))
                </span><span style="color: rgba(0, 0, 255, 1)">for</span> file_path <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> filepath_list
            ]
            </span><span style="color: rgba(0, 0, 255, 1)">for</span> name, (filename, file_content) <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> files:
                </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> print(f"name:{name},filename:{filename}")</span>
<span style="color: rgba(0, 0, 0, 1)">                form_data.add_field(
                    name, file_content, filename</span>=filename, content_type=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">text/plain</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">
                )</span></pre>
</div>
<p>由于文件是我们用户登录后的操作，因此需要添加用户令牌。</p>
<div class="cnblogs_code">
<pre>        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 请求头默认为：multipart/form-data，需要增加只定义的信息</span>
        headers =<span style="color: rgba(0, 0, 0, 1)"> {}
        access_token </span>=<span style="color: rgba(0, 0, 0, 1)"> ApiClient.get_access_token()
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> access_token:
            headers[</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Authorization</span><span style="color: rgba(128, 0, 0, 1)">"</span>] = f<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Bearer {access_token}</span><span style="color: rgba(128, 0, 0, 1)">"</span></pre>
</div>
<p>最后按常规的Post方式处理即可</p>
<p>WxPython的前端界面，我们添加一个按钮，</p>
<div class="cnblogs_code">
<pre>self.btnUpload =<span style="color: rgba(0, 0, 0, 1)"> ControlUtil.create_button(
 pane,
 btn_name</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">上传附件</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
 icon_name</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">upload</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">,
 icon_size</span>=16<span style="color: rgba(0, 0, 0, 1)">,
 handler</span>=<span style="color: rgba(0, 0, 0, 1)">self.OnUpload,
 is_async</span>=<span style="color: rgba(0, 0, 0, 1)">True,
)</span></pre>
</div>
<p>然后使用其按钮事件上传文件操作，如下代码所示。</p>
<div class="cnblogs_code">
<pre>    async <span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> OnUpload(self, event: wx.Event):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">上传附件</span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 打开文件选择对话框, 返回以逗号分隔的多个文件路径</span>
        filePaths = FileDialogUtil.open_file(self, multiple=True, title=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">选择文件</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> filePaths:
            </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 上传文件</span>
            guid = str(uuid4())  <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 生成GUID</span>
            await self.upload_files(filePaths.split(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">,</span><span style="color: rgba(128, 0, 0, 1)">"</span>), guid=guid, folder=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">业务附件</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
        </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">:
            MessageUtil.show_info(self, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">未选择文件</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

    async </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> upload_files(
        self, file_list: list[str], guid: str </span>= <span style="color: rgba(128, 0, 0, 1)">""</span>, folder: str = <span style="color: rgba(128, 0, 0, 1)">""</span><span style="color: rgba(0, 0, 0, 1)">
    ):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">上传文件</span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        res </span>= await api.postupload(file_list, guid=guid, folder=<span style="color: rgba(0, 0, 0, 1)">folder)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> print(res)</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> res:
            MessageUtil.show_notification(self, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">上传成功</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
            </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 刷新表格数据</span>
<span style="color: rgba(0, 0, 0, 1)">            await self.update_grid()
        </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">:
            MessageUtil.show_error(self, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">上传失败</span><span style="color: rgba(128, 0, 0, 1)">"</span>)</pre>
</div>
<p>上传文件成功后，附件列表界面，展示所有相关的附件列表。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241231162425557-1822601342.png" alt="" width="885" height="555" loading="lazy"></p>
<p>附件上传后，我们如果需要查看附件，双击列表即可打开相关的记录，显示我们附件的的相关信息。</p>
<p><img src="https://img2024.cnblogs.com/blog/8867/202412/8867-20241231163444683-948982934.png" alt="" width="554" height="445" loading="lazy"></p>
<p>以上就是对于FastApi后端+WxPython的前端对上传文件的相关协同操作实现过程。</p>
<p>&nbsp;</p>
</div>
<div id="MySignature" role="contentinfo">
    <div style="border-right-color: #cccccc; border-right-width: 1px; border-right-style: solid; padding-right: 5px; border-top-color: #cccccc; border-top-width: 1px; border-top-style: solid; padding-left: 4px; font-size: 13px; padding-bottom: 4px; border-left-color: #cccccc; border-left-width: 1px; border-left-style: solid; width: 98%; padding-top: 4px; border-bottom-color: #cccccc; border-bottom-width: 1px; border-bottom-style: solid; background-color: #eeeeee;">
    <img src="http://www.cnblogs.com/Images/OutliningIndicators/None.gif" align="top" alt="">
    <span style="color: #000000"><span class="Apple-tab-span" style="white-space: pre"></span>
     专注于代码生成工具、.Net/.NetCore 框架架构及软件开发，以及各种Vue.js的前端技术应用。著有Winform开发框架/混合式开发框架、微信开发框架、Bootstrap开发框架、ABP开发框架、SqlSugar开发框架等框架产品。
     <br>&nbsp;&nbsp;转载请注明出处：撰写人：伍华聪&nbsp;&nbsp;<a href="http://www.iqidi.com/" target="_blank">http://www.iqidi.com</a>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
</div>
<div class="clear"></div>

        </div>
        <p class="postfoot">
            posted on 
<span id="post-date" data-last-update-days="0.5557896302106482" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-31 21:35">2024-12-31 21:34</span>&nbsp;
<a href="https://www.cnblogs.com/wuhuacong">伍华聪</a>&nbsp;
阅读(<span id="post_view_count">43</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18643743" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18643743);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18643743', targetLink: 'https://www.cnblogs.com/wuhuacong/p/18643743', title: 'WxPython跨平台开发框架之前后端结合实现附件信息的上传及管理' })">举报</a>

        </p>
    