
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Amd794/p/18858902" title="发布于 2025-05-04 01:55">
    <span role="heading" aria-level="2">DDD分层设计与异步职责划分：让你的代码不再“异步”混乱</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<hr>
<p>title: DDD分层设计与异步职责划分：让你的代码不再“异步”混乱<br>
date: 2025/05/04 00:18:53<br>
updated: 2025/05/04 00:18:53<br>
author: <a href="https://cmdragon.cn" target="_blank" rel="noopener nofollow"> cmdragon </a></p>
<p>excerpt:<br>
DDD分层架构将系统分为用户接口层、应用层、领域层和基础设施层，各层职责明确。领域层处理同步业务逻辑，基础设施层负责异步数据库操作，应用层协调两者。评论模块使用pydantic定义领域模型，保持业务逻辑完整性。Tortoise-ORM实现基础设施层的异步仓储操作。应用层整合领域逻辑与基础设施的异步调用，确保事务管理策略通过原子操作实现。分层调用规则强调领域对象不包含await调用，仓储接口定义在领域层，实现在基础设施层。</p>
<p>categories:</p>
<ul>
<li>后端开发</li>
<li>FastAPI</li>
</ul>
<p>tags:</p>
<ul>
<li>DDD分层架构</li>
<li>异步编程</li>
<li>FastAPI</li>
<li>领域驱动设计</li>
<li>Tortoise-ORM</li>
<li>事务管理</li>
<li>代码示例</li>
</ul>
<hr>
<img src="https://static.shutu.cn/shutu/jpeg/open40/2025/05/04/8c0e943689688158f624cd829c58ee70.jpeg" title="cmdragon_cn.png" alt="cmdragon_cn.png">
<img src="https://api2.cmdragon.cn/upload/cmder/20250304_012821924.jpg" title="cmdragon_cn.png" alt="cmdragon_cn.png">
<p>扫描<a href="https://api2.cmdragon.cn/upload/cmder/20250304_012821924.jpg" target="_blank" rel="noopener nofollow">二维码</a><br>
关注或者微信搜一搜：<code>编程智域 前端至全栈交流与成长</code></p>
<p><a href="https://tools.cmdragon.cn/zh/apps?category=ai_chat" target="_blank" rel="noopener nofollow">探索数千个预构建的 AI 应用，开启你的下一个伟大创意</a>：<a href="https://tools.cmdragon.cn/" target="_blank" rel="noopener nofollow">https://tools.cmdragon.cn/</a></p>
<h1 id="第一章ddd分层设计与异步职责划分">第一章：DDD分层设计与异步职责划分</h1>
<h2 id="11-ddd分层架构解析">1.1 DDD分层架构解析</h2>
<p>领域驱动设计（DDD）将系统分为四层：用户接口层、应用层、领域层和基础设施层。在FastAPI异步架构中，各层职责需要特别关注异步处理边界：</p>
<ul>
<li><strong>领域层</strong>：包含纯业务逻辑（同步）</li>
<li><strong>基础设施层</strong>：处理数据库操作（异步）</li>
<li>应用层作为协调者，负责调用领域服务和基础设施的异步方法</li>
</ul>
<p>架构示例：</p>
<pre><code class="language-python"># 同步领域服务
class CommentService:
    def validate_comment(self, content: str):
        """领域层保持同步逻辑"""
        if len(content) &gt; 1000:
            raise ValueError("评论内容过长")
        # 其他业务规则...


# 异步基础设施
class CommentRepository:
    async def save(self, comment):
        """基础设施层处理异步IO"""
        await comment.save()
</code></pre>
<h2 id="12-评论模块领域模型设计">1.2 评论模块领域模型设计</h2>
<p>使用pydantic定义领域模型，保持业务逻辑完整性：</p>
<pre><code class="language-python">from pydantic import BaseModel, Field
from datetime import datetime


class User(BaseModel):
    id: int
    username: str = Field(..., max_length=50)


class Comment(BaseModel):
    content: str = Field(..., min_length=1, max_length=1000)
    author: User
    created_at: datetime = datetime.now()

    def edit(self, new_content: str):
        """领域方法保持同步"""
        if len(new_content) &gt; 1000:
            raise ValueError("内容超过最大限制")
        self.content = new_content
        self.updated_at = datetime.now()
</code></pre>
<h2 id="13-基础设施层实现">1.3 基础设施层实现</h2>
<p>Tortoise-ORM仓储实现示例：</p>
<pre><code class="language-python">from tortoise.models import Model
from tortoise import fields


class CommentDBModel(Model):
    """数据库模型"""
    id = fields.IntField(pk=True)
    content = fields.TextField()
    author_id = fields.IntField()
    created_at = fields.DatetimeField(auto_now_add=True)


class TortoiseCommentRepository:
    async def save(self, comment: Comment) -&gt; int:
        """异步保存方法"""
        db_model = await CommentDBModel.create(
            content=comment.content,
            author_id=comment.author.id
        )
        return db_model.id

    async def get(self, comment_id: int) -&gt; Comment:
        """异步查询方法"""
        db_model = await CommentDBModel.get(id=comment_id)
        return Comment(
            content=db_model.content,
            author=User(id=db_model.author_id, username=""),
            created_at=db_model.created_at
        )
</code></pre>
<h2 id="14-应用层整合">1.4 应用层整合</h2>
<p>协调领域逻辑与基础设施的异步调用：</p>
<pre><code class="language-python">from fastapi import APIRouter, Depends

router = APIRouter()


@router.post("/comments")
async def create_comment(
        comment: Comment,
        repo: TortoiseCommentRepository = Depends()
):
    # 调用同步领域验证
    CommentService().validate_comment(comment.content)

    # 异步保存操作
    comment_id = await repo.save(comment)
    return {"id": comment_id}
</code></pre>
<h1 id="第二章异步职责边界控制">第二章：异步职责边界控制</h1>
<h2 id="21-分层调用规则">2.1 分层调用规则</h2>
<p>异步调用链示例：</p>
<pre><code>HTTP请求 -&gt; 路由层（async）-&gt; 应用层（async）-&gt; 领域层（sync）-&gt; 基础设施层（async）
</code></pre>
<p>关键原则：</p>
<ol>
<li>领域对象不包含await调用</li>
<li>仓储接口定义在领域层，实现在基础设施层</li>
<li>应用服务负责编排异步流程</li>
</ol>
<h2 id="22-事务管理策略">2.2 事务管理策略</h2>
<p>使用Tortoise的原子事务：</p>
<pre><code class="language-python">from tortoise.transactions import atomic


class CommentRepository:
    @atomic()
    async def create_with_user(self, comment: Comment, user: User):
        """事务操作示例"""
        await UserDBModel.create(id=user.id, username=user.username)
        await CommentDBModel.create(
            content=comment.content,
            author_id=user.id
        )
</code></pre>
<h1 id="课后quiz">课后Quiz</h1>
<p><strong>问题1</strong>：为什么领域层的方法要保持同步？<br>
A. 简化异步编程复杂度<br>
B. 保证业务逻辑的原子性<br>
C. 提高代码执行速度<br>
D. 方便单元测试</p>
<p><strong>答案</strong>：A<br>
解析：业务逻辑保持同步可以避免复杂的async/await处理，使领域模型更专注于业务规则本身。</p>
<p><strong>问题2</strong>：在事务处理中应该在哪一层实现原子操作？<br>
A. 应用层调用基础设施层的原子方法<br>
B. 领域层直接处理事务<br>
C. 用户接口层控制事务边界<br>
D. 数据库自动处理所有事务</p>
<p><strong>答案</strong>：A<br>
解析：事务属于基础设施实现细节，应用层通过调用基础设施提供的原子方法来管理事务。</p>
<h1 id="常见报错解决方案">常见报错解决方案</h1>
<p><strong>422 Validation Error</strong><br>
现象：请求返回422状态码<br>
原因分析：</p>
<ol>
<li>请求体不符合pydantic模型定义</li>
<li>字段类型不匹配或约束不满足<br>
解决方法：</li>
<li>检查请求JSON结构</li>
<li>验证字段类型和长度限制</li>
<li>使用try/except捕获ValidationError</li>
</ol>
<p><strong>RuntimeError: Event loop is closed</strong><br>
原因：在同步方法中调用了异步代码<br>
解决方法：</p>
<ol>
<li>检查领域层是否混入了await调用</li>
<li>确保所有异步操作都在async方法中执行</li>
<li>使用asyncio.run()包装测试代码</li>
</ol>
<p><strong>安装与运行</strong></p>
<pre><code class="language-bash"># 环境要求
pip install fastapi uvicorn tortoise-orm pydantic

# 启动命令
uvicorn main:app --reload
</code></pre>
<p>余下文章内容请点击跳转至 个人博客页面 或者 扫码关注或者微信搜一搜：<code>编程智域 前端至全栈交流与成长</code>，阅读完整的文章：<a href="https://blog.cmdragon.cn/posts/62012cf83e26/" target="_blank" rel="noopener nofollow">DDD分层设计与异步职责划分：让你的代码不再“异步”混乱 | cmdragon's Blog</a></p>
<h2 id="往期文章归档">往期文章归档：</h2>
<ul>
<li><a href="https://blog.cmdragon.cn/posts/c195d6c4d0b5/" target="_blank" rel="noopener nofollow">异步数据库事务锁：电商库存扣减的防超卖秘籍 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/f0e851eb1a74/" target="_blank" rel="noopener nofollow">FastAPI中的复杂查询与原子更新指南 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/512d338e0833/" target="_blank" rel="noopener nofollow">深入解析Tortoise-ORM关系型字段与异步查询 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/7649fa5d5b04/" target="_blank" rel="noopener nofollow">FastAPI与Tortoise-ORM模型配置及aerich迁移工具 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/c9824156400c/" target="_blank" rel="noopener nofollow">异步IO与Tortoise-ORM的数据库 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/74b39391a524/" target="_blank" rel="noopener nofollow">FastAPI数据库连接池配置与监控 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/f05753c1a8af/" target="_blank" rel="noopener nofollow">分布式事务在点赞功能中的实现 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/644d88ac6ff1/" target="_blank" rel="noopener nofollow">Tortoise-ORM级联查询与预加载性能优化 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/d7fcb94d965b/" target="_blank" rel="noopener nofollow">使用Tortoise-ORM和FastAPI构建评论系统 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/a344f0dfbdbf/" target="_blank" rel="noopener nofollow">分层架构在博客评论功能中的应用与实现 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/823cb13844de/" target="_blank" rel="noopener nofollow">深入解析事务基础与原子操作原理 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/0df919d7ff39/" target="_blank" rel="noopener nofollow">掌握Tortoise-ORM高级异步查询技巧 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/2c8d6d6e8c53/" target="_blank" rel="noopener nofollow">FastAPI与Tortoise-ORM实现关系型数据库关联 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/4b40fac9a431/" target="_blank" rel="noopener nofollow">Tortoise-ORM与FastAPI集成：异步模型定义与实践 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/ec70904aad68/" target="_blank" rel="noopener nofollow">异步编程与Tortoise-ORM框架 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/7112d376156d/" target="_blank" rel="noopener nofollow">FastAPI数据库集成与事务管理 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/ac94f11d8558/" target="_blank" rel="noopener nofollow">FastAPI与SQLAlchemy数据库集成 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/b64fbd2d819d/" target="_blank" rel="noopener nofollow">FastAPI与SQLAlchemy数据库集成与CRUD操作 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/05564696277e/" target="_blank" rel="noopener nofollow">FastAPI与SQLAlchemy同步数据库集成 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/dc3f1adccf0a/" target="_blank" rel="noopener nofollow">SQLAlchemy 核心概念与同步引擎配置详解 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/5c3e3f847f09/" target="_blank" rel="noopener nofollow">FastAPI依赖注入性能优化策略 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/d1b6b80e8665/" target="_blank" rel="noopener nofollow">FastAPI安全认证中的依赖组合 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/f5d382bc5354/" target="_blank" rel="noopener nofollow">FastAPI依赖注入系统及调试技巧 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/88761b137b82/" target="_blank" rel="noopener nofollow">FastAPI依赖覆盖与测试环境模拟 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/ef1282d9c9b8/" target="_blank" rel="noopener nofollow">FastAPI中的依赖注入与数据库事务管理 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/8b8658ec8dab/" target="_blank" rel="noopener nofollow">FastAPI依赖注入实践：工厂模式与实例复用的优化策略 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/0b359086bd7d/" target="_blank" rel="noopener nofollow">FastAPI依赖注入：链式调用与多级参数传递 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/ef71d1b7ddfb/" target="_blank" rel="noopener nofollow">FastAPI依赖注入：从基础概念到应用 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/1b01bf90607f/" target="_blank" rel="noopener nofollow">FastAPI中实现动态条件必填字段的实践 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/cda2eb13bf31/" target="_blank" rel="noopener nofollow">FastAPI中Pydantic异步分布式唯一性校验 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/18ef84c3b234/" target="_blank" rel="noopener nofollow">掌握FastAPI与Pydantic的跨字段验证技巧 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/9b9eb7489096/" target="_blank" rel="noopener nofollow">FastAPI中的Pydantic密码验证机制与实现 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/6e2a1c070e32/" target="_blank" rel="noopener nofollow">深入掌握FastAPI与OpenAPI规范的高级适配技巧 | cmdragon's Blog</a></li>
<li><a href="https://blog.cmdragon.cn/posts/11d2c39a300b/" target="_blank" rel="noopener nofollow">Pydantic字段元数据指南：从基础到企业级文档增强 | cmdragon's Blog</a></li>
<li><a href="https://tools.cmdragon.cn/sitemap_index.xml" target="_blank" rel="noopener nofollow">XML Sitemap</a></li>
<li></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.029948258016203703" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-04 01:56">2025-05-04 01:55</span>&nbsp;
<a href="https://www.cnblogs.com/Amd794">Amd794</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18858902);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18858902', targetLink: 'https://www.cnblogs.com/Amd794/p/18858902', title: 'DDD分层设计与异步职责划分：让你的代码不再“异步”混乱' })">举报</a>
</div>
        