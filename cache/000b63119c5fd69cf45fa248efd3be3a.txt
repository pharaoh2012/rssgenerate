
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ibigboy/p/18868563" title="发布于 2025-05-09 17:15">
    <span role="heading" aria-level="2">RocketMQ半消息对消费者不可见是如何实现的？——事务消息机制揭秘</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>首发于工号【BiggerBoy】，<a href="https://mp.weixin.qq.com/s/7xCAc7evPBhRjt0beqBaVw" target="_blank" rel="noopener nofollow">原文链接</a></p>
<p>——“半消息藏在这里，但为什么你偷看也没用？”</p>
<hr>
<p>上篇<a href="https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&amp;mid=2247486379&amp;idx=1&amp;sn=96315e327d21af973557189b08c5b130&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">《RocketMQ系列笔记（三）：消息模型与高阶玩法，顺序事务消息拿捏指南》</a>中提到“TBW102是RocketMQ预留的事务消息Topic”，是什么意思？为什么消费者看不到半消息？是如何实现的？带着这些疑问，开启今天的探索之旅！</p>
<hr>
<p>这句话隐藏的意思就是：生产者发送事务消息时实际Broker会把半消息存储到TBW102这个Topic。当生产者通知Broker提交时，Broker会将消息发送到生产者指定的Topic，此时消费者才能消费该消息。</p>
<p>以下是更详细的流程说明：</p>
<h2 id="事务消息一手交钱一手交货">事务消息：一手交钱一手交货</h2>
<p>再来回顾一下事务消息的流程：</p>
<h4 id="发送半消息"><strong>发送半消息</strong></h4>
<ul>
<li>生产者发送事务消息时，首先将消息作为<strong>半消息</strong>发送到Broker</li>
<li>这个半消息会被存储在RocketMQ的默认事务Topic <code>TBW102</code> 中</li>
<li>此时，消息对消费者是不可见的，因为它还没有被正式提交</li>
</ul>
<h4 id="执行本地事务"><strong>执行本地事务</strong></h4>
<ul>
<li>半消息提交成功后，生产者执行本地事务逻辑（例如数据库操作）</li>
<li>本地事务的执行结果（成功或失败）决定了后续的操作</li>
</ul>
<h4 id="通知broker提交或回滚"><strong>通知Broker提交或回滚</strong></h4>
<ul>
<li><strong>提交</strong>如果本地事务成功，生产者会通知Broker提交半消息。此时，Broker会将消息从 <code>TBW102</code> 移动到生产者指定的目标Topic，消息对消费者可见</li>
<li><strong>回滚</strong>如果本地事务失败，生产者会通知Broker回滚半消息。此时，<strong>Broker会丢弃 TBW102 中的半消息</strong>，消息不会被发送到目标Topic</li>
</ul>
<h2 id="事务消息的奥秘">事务消息的奥秘</h2>
<h4 id="消息可见性"><strong>消息可见性</strong></h4>
<ul>
<li><strong>半消息阶段</strong>消息存储在 <code>TBW102</code>，对消费者不可见</li>
<li><strong>提交后</strong>消息移动到目标Topic，对消费者可见</li>
</ul>
<h4 id="为什么设计为不可见"><strong>为什么设计为不可见？</strong></h4>
<ul>
<li><strong>事务消息的核心设计</strong></li>
<li>
<ul>
<li>RocketMQ的事务消息机制是为了保证消息的<strong>最终一致性</strong></li>
<li>在半消息阶段，消息对消费者不可见，是为了避免消费者处理到未确认的消息（可能导致数据不一致）</li>
<li>只有在生产者明确提交事务后，消息才会被移动到目标Topic，对消费者可见</li>
</ul>
</li>
</ul>
<p><strong>简单来说</strong>：</p>
<blockquote>
<p><code>TBW102</code>里的消息就像“加密文件”，只有事务完成后才会被“解密”到正确的位置。</p>
</blockquote>
<h4 id="配置"><strong>配置</strong></h4>
<ul>
<li><strong>自定义半消息Topic</strong>可通过配置<code>transactionTopic</code>参数指定其他Topic</li>
<li><strong>Broker配置</strong>在Broker配置文件中设置<code>transactionTopic</code>参数</li>
</ul>
<h4 id="注意事项"><strong>注意事项</strong></h4>
<ul>
<li><strong>可以自定义</strong>通过Broker配置<code>transactionTopic</code>参数，灵活指定事务消息的存储位置</li>
<li><strong>但没必要乱动</strong>如果没有特殊需求，直接用默认的<code>TBW102</code>反而更省心</li>
<li><strong>核心原则</strong>事务Topic是RocketMQ内部机制，业务代码无需感知，你的重点仍是本地事务和最终消息的一致性</li>
<li><strong>避免冲突</strong>不要在生产环境中使用<code>TBW102</code>作为业务Topic，以免冲突</li>
<li><strong>监控与维护</strong>需监控和维护事务Topic，确保事务消息机制正常运行</li>
</ul>
<h2 id="总结"><strong>总结</strong></h2>
<ul>
<li><strong>半消息</strong>存储在 <code>TBW102</code>，对消费者不可见</li>
<li><strong>提交后</strong>消息移动到目标Topic，对消费者可见</li>
<li><strong>回滚</strong>消息被丢弃，不会发送到目标Topic</li>
</ul>
<p>这种机制确保了事务消息的原子性，即消息的发送与本地事务的执行结果保持一致。</p>
<hr>
<p>有的小伙伴就会好奇问了：如果消费者订阅<code>TWB102</code>呢，不就可以消费了吗？刚刚说“生产者通知Broker回滚消息，Broker会丢弃<code>TWB102</code>中的半消息”，这里的丢弃是从Broker中删除吗？不会违背RocketMQ<code>顺序写</code>的特性吗？</p>
<p>这是个好问题！下面来揭秘一下：</p>
<hr>
<h3 id="消费者订阅-tbw102-的情况"><strong>消费者订阅 TBW102 的情况</strong></h3>
<ul>
<li><strong>理论上可以订阅</strong>消费者确实可以订阅 <code>TBW102</code> 这个Topic</li>
<li><strong>实际意义有限</strong></li>
<li>
<ul>
<li>TBW102是RocketMQ内部用于存储<strong>半消息</strong>的Topic，这些消息还未被确认提交或回滚</li>
<li>即使消费者订阅了 <code>TBW102</code>，也只能看到未完成事务的半消息，这些消息的状态是不确定的（可能最终会被提交或回滚）</li>
<li>从业务逻辑上来说，消费这些半消息是没有意义的，因为它们可能最终会被丢弃</li>
</ul>
</li>
</ul>
<p><strong>划重点</strong>：<br>
哪怕你订阅了<code>TBW102</code>，看到的也只是“未确认状态”的半消息，它们可能下一秒就被删除或转移，毫无业务价值。</p>
<hr>
<h3 id="消息被丢弃的含义"><strong>消息被丢弃的含义</strong></h3>
<ul>
<li><strong>回滚时的处理</strong></li>
<li>
<ul>
<li>当生产者通知Broker回滚事务时，Broker会将 <code>TBW102</code> 中对应的半消息标记为<strong>已回滚</strong></li>
<li>这些消息会被<strong>标记为已删除</strong>，消费者无法再访问这些消息</li>
</ul>
</li>
</ul>
<p>实际上被回滚的半消息还存储在<code>Commitlog</code>中，只是被标记为<code>已删除</code>，之所以没有物理删除和RocketMQ的存储机制有一定关系。</p>
<h3 id="rocketmq的存储机制"><strong>RocketMQ的存储机制</strong></h3>
<ul>
<li><strong>CommitLog</strong>：</li>
<li>
<ul>
<li>RocketMQ将所有消息（包括事务消息）<code>顺序写入</code>一个统一的文件，称为 <code>CommitLog</code></li>
<li>这种设计保证了高性能的写入，因为磁盘只需要顺序追加数据</li>
</ul>
</li>
<li><strong>ConsumeQueue</strong>：</li>
<li>
<ul>
<li>每个Topic的消息索引存储在 <code>ConsumeQueue</code> 中，消费者通过 <code>ConsumeQueue</code> 快速定位消息</li>
</ul>
</li>
<li><strong>事务消息的特殊性</strong>：</li>
<li>
<ul>
<li>事务消息（包括半消息）也会写入 <code>CommitLog</code>，但在事务未完成时，不会将消息索引写入目标Topic的 <code>ConsumeQueue</code></li>
</ul>
</li>
</ul>
<h3 id="消息删除的实现原理"><strong>消息删除的实现原理</strong></h3>
<p>删除操作的本质：RocketMQ的“删除”并不是直接从 CommitLog 中物理擦除数据，而是通过以下方式实现：标记删除：对于回滚的事务消息，RocketMQ会将其标记为“已删除”跳过消费：消费者从ConsumeQueue读取消息时，会跳过被标记为删除的消息物理删除：RocketMQ会定期执行文件清理（默认72小时），将过期的文件（包括已删除的消息）从磁盘中删除<strong>顺序写的保持：</strong></p>
<ul>
<li>
<ul>
<li>删除操作不会影响 <code>CommitLog</code> 的顺序写特性，因为删除只是标记消息状态，而不是立即修改 <code>CommitLog</code> 文件</li>
<li>物理删除是通过清理整个文件（而不是单独删除某条消息）来实现的，因此不会破坏顺序写的性能</li>
</ul>
</li>
</ul>
<p><strong>结论</strong>：</p>
<blockquote>
<p>删除操作既不会破坏顺序写，也不会让磁盘“千疮百孔”，RocketMQ早就想好了怎么优雅“扔垃圾”。</p>
</blockquote>
<h3 id="总结-1"><strong>总结</strong></h3>
<ul>
<li><strong>半消息</strong> 存储在 <code>TBW102</code>，对消费者不可见。</li>
<li><strong>提交后</strong> 消息移动到目标Topic，对消费者可见。</li>
<li><strong>回滚</strong> 消息被丢弃，不会发送到目标Topic。</li>
</ul>
<p>因此，RocketMQ的事务消息机制通过 <code>TBW102</code> 和半消息的设计，确保了消息的可靠性和一致性，避免了消费者处理到未确认的消息。</p>
<p>好了，今天的分享就到这里啦！如果对你有帮助，辛苦转发➕关注，感谢支持～</p>

</div>
<div id="MySignature" role="contentinfo">
    说的再好，不如行动。不怕慢，就怕站。
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5409216785219907" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-09 17:16">2025-05-09 17:15</span>&nbsp;
<a href="https://www.cnblogs.com/ibigboy">问北</a>&nbsp;
阅读(<span id="post_view_count">95</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18868563);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18868563', targetLink: 'https://www.cnblogs.com/ibigboy/p/18868563', title: 'RocketMQ半消息对消费者不可见是如何实现的？——事务消息机制揭秘' })">举报</a>
</div>
        