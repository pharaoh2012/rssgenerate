
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/jzzg/p/18653197" title="发布于 2025-01-05 11:00">
    <span role="heading" aria-level="2">Python学习（四）——配套《PyTorch深度学习实战》</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-python中字符串的相加和相乘">1. Python中字符串的相加和相乘</h2>
<p>在Python中，字符串可以通过加号（<code>+</code>）进行相加（连接），也可以通过乘号（<code>*</code>）进行相乘（重复）。以下是这两种操作的详细说明和示例：</p>
<h3 id="字符串的相加连接">字符串的相加（连接）</h3>
<p>字符串的相加是通过使用加号（<code>+</code>）运算符来实现的。它将两个或多个字符串连接成一个单一的字符串。</p>
<pre><code class="language-python">str1 = "Hello"
str2 = "World"
result = str1 + " " + str2
print(result)  # 输出 "Hello World"
</code></pre>
<p>在连接多个字符串时，可以连续使用加号：</p>
<pre><code class="language-python">str1 = "Hello"
str2 = "World"
str3 = "Python"
result = str1 + " " + str2 + " " + str3
print(result)  # 输出 "Hello World Python"
</code></pre>
<h3 id="字符串的相乘重复">字符串的相乘（重复）</h3>
<p>字符串的相乘是通过使用乘号（<code>*</code>）运算符来实现的。它将一个字符串重复指定的次数。</p>
<pre><code class="language-python">str1 = "Hello"
result = str1 * 3
print(result)  # 输出 "HelloHelloHello"
</code></pre>
<p>如果乘以0，结果将是一个空字符串：</p>
<pre><code class="language-python">str1 = "Hello"
result = str1 * 0
print(result)  # 输出 ""
</code></pre>
<h3 id="组合使用">组合使用</h3>
<p>你也可以将字符串的相加和相乘组合使用：</p>
<pre><code class="language-python">str1 = "Hello"
str2 = "World"
result = (str1 + " ") * 2 + str2
print(result)  # 输出 "Hello Hello World"
</code></pre>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>字符串的相加和相乘操作是不可逆的，即结果仍然是一个字符串，而不是一个列表或其他数据结构。</li>
<li>在连接大量字符串时，使用<code>join()</code>方法通常更高效，因为它避免了创建多个中间字符串对象。</li>
<li>字符串的相乘操作要求乘数是一个整数，否则会引发<code>TypeError</code>。</li>
</ul>
<p>通过这些操作，你可以灵活地处理字符串数据，满足不同的编程需求。</p>
<hr>
<h2 id="2-python中元祖的相加和相乘">2. Python中元祖的相加和相乘</h2>
<p>在Python中，元组（tuple）也可以通过加号（<code>+</code>）进行相加（连接），以及通过乘号（<code>*</code>）进行相乘（重复）。以下是对这两种操作的详细说明和示例：</p>
<h3 id="元组的相加连接">元组的相加（连接）</h3>
<p>元组的相加是通过使用加号（<code>+</code>）运算符来实现的。它将两个或多个元组连接成一个单一的元组。</p>
<pre><code class="language-python">tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)
result = tuple1 + tuple2
print(result)  # 输出 (1, 2, 3, 4, 5, 6)
</code></pre>
<p>在连接多个元组时，可以连续使用加号：</p>
<pre><code class="language-python">tuple1 = (1, 2)
tuple2 = (3, 4)
tuple3 = (5, 6)
result = tuple1 + tuple2 + tuple3
print(result)  # 输出 (1, 2, 3, 4, 5, 6)
</code></pre>
<h3 id="元组的相乘重复">元组的相乘（重复）</h3>
<p>元组的相乘是通过使用乘号（<code>*</code>）运算符来实现的。它将一个元组重复指定的次数。</p>
<pre><code class="language-python">tuple1 = (1, 2, 3)
result = tuple1 * 3
print(result)  # 输出 (1, 2, 3, 1, 2, 3, 1, 2, 3)
</code></pre>
<p>如果乘以0，结果将是一个空元组：</p>
<pre><code class="language-python">tuple1 = (1, 2, 3)
result = tuple1 * 0
print(result)  # 输出 ()
</code></pre>
<h3 id="组合使用-1">组合使用</h3>
<p>你也可以将元组的相加和相乘组合使用：</p>
<pre><code class="language-python">tuple1 = (1, 2)
tuple2 = (3, 4)
result = (tuple1 + tuple2) * 2
print(result)  # 输出 (1, 2, 3, 4, 1, 2, 3, 4)
</code></pre>
<h3 id="注意事项-1">注意事项</h3>
<ul>
<li>元组的相加和相乘操作是不可逆的，即结果仍然是一个元组，而不是其他数据结构。</li>
<li>元组的相乘操作要求乘数是一个整数，否则会引发<code>TypeError</code>。</li>
<li>元组是不可变的，因此相加和相乘操作不会改变原始元组，而是创建一个新的元组。</li>
</ul>
<p>通过这些操作，你可以灵活地处理元组数据，满足不同的编程需求。</p>
<hr>
<h2 id="3-python中列表的相加和相乘">3. Python中列表的相加和相乘</h2>
<p>是的，Python中的列表（list）也可以通过加号（<code>+</code>）进行相加（连接），以及通过乘号（<code>*</code>）进行相乘（重复）。以下是对这两种操作的详细说明和示例：</p>
<h3 id="列表的相加连接">列表的相加（连接）</h3>
<p>列表的相加是通过使用加号（<code>+</code>）运算符来实现的。它将两个或多个列表连接成一个单一的列表。</p>
<pre><code class="language-python">list1 = [1, 2, 3]
list2 = [4, 5, 6]
result = list1 + list2
print(result)  # 输出 [1, 2, 3, 4, 5, 6]
</code></pre>
<p>在连接多个列表时，可以连续使用加号：</p>
<pre><code class="language-python">list1 = [1, 2]
list2 = [3, 4]
list3 = [5, 6]
result = list1 + list2 + list3
print(result)  # 输出 [1, 2, 3, 4, 5, 6]
</code></pre>
<h3 id="列表的相乘重复">列表的相乘（重复）</h3>
<p>列表的相乘是通过使用乘号（<code>*</code>）运算符来实现的。它将一个列表重复指定的次数。</p>
<pre><code class="language-python">list1 = [1, 2, 3]
result = list1 * 3
print(result)  # 输出 [1, 2, 3, 1, 2, 3, 1, 2, 3]
</code></pre>
<p>如果乘以0，结果将是一个空列表：</p>
<pre><code class="language-python">list1 = [1, 2, 3]
result = list1 * 0
print(result)  # 输出 []
</code></pre>
<h3 id="组合使用-2">组合使用</h3>
<p>你也可以将列表的相加和相乘组合使用：</p>
<pre><code class="language-python">list1 = [1, 2]
list2 = [3, 4]
result = (list1 + list2) * 2
print(result)  # 输出 [1, 2, 3, 4, 1, 2, 3, 4]
</code></pre>
<h3 id="注意事项-2">注意事项</h3>
<ul>
<li>列表的相加和相乘操作是不可逆的，即结果仍然是一个列表，而不是其他数据结构。</li>
<li>列表的相乘操作要求乘数是一个整数，否则会引发<code>TypeError</code>。</li>
<li>列表是可变的，因此相加和相乘操作不会改变原始列表，而是创建一个新的列表。</li>
</ul>
<p>通过这些操作，你可以灵活地处理列表数据，满足不同的编程需求。</p>
<hr>
<h2 id="4-python中的与或非">4. Python中的与或非</h2>
<p>在Python中，与（AND）、或（OR）和非（NOT）是逻辑运算符，用于组合或修改布尔值（<code>True</code>或<code>False</code>）。以下是对这些逻辑运算符的详细说明和示例：</p>
<h3 id="与and">与（AND）</h3>
<ul>
<li><strong>功能</strong>：<code>and</code>运算符用于逻辑与运算。当两个操作数都为<code>True</code>时，结果为<code>True</code>，否则为<code>False</code>。</li>
<li><strong>示例</strong>：<pre><code class="language-python">result = True and True  # True
result = True and False  # False
result = False and True  # False
result = False and False  # False
</code></pre>
</li>
</ul>
<h3 id="或or">或（OR）</h3>
<ul>
<li><strong>功能</strong>：<code>or</code>运算符用于逻辑或运算。当两个操作数中至少有一个为<code>True</code>时，结果为<code>True</code>，否则为<code>False</code>。</li>
<li><strong>示例</strong>：<pre><code class="language-python">result = True or True  # True
result = True or False  # True
result = False or True  # True
result = False or False  # False
</code></pre>
</li>
</ul>
<h3 id="非not">非（NOT）</h3>
<ul>
<li><strong>功能</strong>：<code>not</code>运算符用于逻辑非运算。它将布尔值取反，即<code>True</code>变为<code>False</code>，<code>False</code>变为<code>True</code>。</li>
<li><strong>示例</strong>：<pre><code class="language-python">result = not True  # False
result = not False  # True
</code></pre>
</li>
</ul>
<h3 id="短路求值">短路求值</h3>
<p>Python的逻辑运算符具有短路求值的特性：</p>
<ul>
<li>
<p><strong>AND短路</strong>：如果第一个操作数为<code>False</code>，则整个表达式的结果必定为<code>False</code>，因此不会评估第二个操作数。</p>
<pre><code class="language-python">result = False and some_function()  # 不会调用some_function()
</code></pre>
</li>
<li>
<p><strong>OR短路</strong>：如果第一个操作数为<code>True</code>，则整个表达式的结果必定为<code>True</code>，因此不会评估第二个操作数。</p>
<pre><code class="language-python">result = True or some_function()  # 不会调用some_function()
</code></pre>
</li>
</ul>
<h3 id="实际应用">实际应用</h3>
<p>这些逻辑运算符可以用于复杂的条件判断，例如：</p>
<pre><code class="language-python">age = 25
is_student = True

# 判断是否为成年学生
if age &gt;= 18 and is_student:
    print("You are an adult student.")

# 判断是否为未成年或非学生
if age &lt; 18 or not is_student:
    print("You are either a minor or not a student.")
</code></pre>
<p>通过这些逻辑运算符，你可以构建复杂的逻辑条件来控制程序的流程。</p>
<hr>
<h2 id="5-python的赋值机制">5. Python的赋值机制</h2>
<p><img src="https://img2024.cnblogs.com/blog/2760960/202501/2760960-20250105102141999-1993176197.png" alt="赋值机制" loading="lazy"><br>
这张图片描述了Python中基本类型（如整数）的赋值机制。在Python中，基本类型是不可变的，这意味着一旦创建，它们的值就不能被改变。图片中的三行代码展示了变量赋值和内存地址的变化过程：</p>
<h3 id="step-1">Step 1</h3>
<ul>
<li><code>a = 100</code>：创建了一个变量<code>a</code>，并将其与值<code>100</code>关联。在内存中，<code>100</code>被存储在一个位置，我们称之为<code>pos1(100)</code>。</li>
<li><code>b = a</code>：创建了另一个变量<code>b</code>，并将<code>a</code>的值赋给它。在Python中，这意味着<code>b</code>也指向内存中的同一个位置<code>pos1(100)</code>。</li>
</ul>
<h3 id="step-2">Step 2</h3>
<ul>
<li><code>a = 200</code>：将新的值<code>200</code>赋给变量<code>a</code>。由于基本类型是不可变的，所以不会修改内存中<code>pos1(100)</code>的位置。相反，<code>a</code>现在指向内存中的另一个位置<code>pos2(200)</code>。而<code>b</code>仍然指向原来的<code>pos1(100)</code>，因为<code>b</code>的值没有被重新赋值。</li>
</ul>
<h3 id="step-3">Step 3</h3>
<ul>
<li>这个步骤强调了可以使用<code>id()</code>函数来验证变量的内存地址。<code>id()</code>函数返回对象的内存地址，可以用来检查两个变量是否指向同一个对象。</li>
</ul>
<p>这个过程说明了Python中变量赋值的机制，即变量实际上是对对象的引用。当一个变量被赋值给另一个变量时，它们都指向内存中的同一个对象。如果原始变量被赋予一个新的值，它将指向一个新的对象，而其他变量仍然指向原来的对象。</p>
<p>以下是这个过程的Python代码示例：</p>
<pre><code class="language-python">a = 100  # Step 1: a -&gt; pos1(100)
print(id(a))  # 输出a的内存地址

b = a    # b也指向a的内存地址
print(id(b))  # 输出b的内存地址，应该与a相同

a = 200  # Step 2: a -&gt; pos2(200), b仍然指向pos1(100)
print(id(a))  # 输出a的新内存地址
print(id(b))  # 输出b的内存地址，应该与最初的a相同
</code></pre>
<p>这段代码将展示<code>a</code>和<code>b</code>在内存中的地址变化，从而验证了上述的赋值机制。</p>
<blockquote>
<p>进行联想，这样的赋值机制和在C、C++、Verilog中的有什么区别？</p>
</blockquote>
<p>Python的赋值机制与C、C++和Verilog等语言有显著的不同，主要是因为这些语言在处理变量和内存管理方面的方式不同。以下是一些主要的区别：</p>
<h3 id="1-基本类型和对象引用">1. 基本类型和对象引用</h3>
<ul>
<li><strong>Python</strong>：Python中的变量总是指向对象的引用。对于基本类型（如整数、浮点数、字符串），Python使用一种称为“对象模型”的机制，其中每个值都是一个对象，变量存储的是对象的引用。这意味着即使两个变量指向同一个对象，修改其中一个变量的值不会影响另一个变量。</li>
<li><strong>C/C++</strong>：在C和C++中，基本类型（如<code>int</code>、<code>float</code>、<code>char</code>）直接存储值。变量赋值实际上是值的复制。如果一个变量被赋值给另一个变量，它们各自独立存储自己的值副本。</li>
<li><strong>Verilog</strong>：Verilog是一种硬件描述语言，用于设计和模拟数字系统。在Verilog中，变量的赋值可以是阻塞赋值（<code>=</code>）或非阻塞赋值（<code>&lt;=</code>），这影响赋值的执行顺序和时序。Verilog中的赋值更接近于硬件电路的行为。</li>
</ul>
<h3 id="2-可变性">2. 可变性</h3>
<ul>
<li><strong>Python</strong>：Python中的不可变类型（如整数、浮点数、字符串）一旦创建，其值就不能改变。这意味着任何赋值操作实际上都是创建一个新的对象，并让变量指向这个新对象。</li>
<li><strong>C/C++</strong>：C和C++中的变量可以直接修改其值，因为它们存储的是值本身。对于基本类型，赋值操作会直接改变变量的值。</li>
<li><strong>Verilog</strong>：Verilog中的变量赋值涉及到信号的更新，这些更新可能在模拟的下一个时间步发生，具体取决于赋值类型（阻塞或非阻塞）。</li>
</ul>
<h3 id="3-内存管理">3. 内存管理</h3>
<ul>
<li><strong>Python</strong>：Python自动管理内存，包括垃圾回收。对象的生命周期由引用计数和垃圾回收器共同管理。</li>
<li><strong>C/C++</strong>：C和C++要求程序员手动管理内存，包括分配和释放。这提供了更高的灵活性，但也增加了出错的风险。</li>
<li><strong>Verilog</strong>：Verilog不涉及传统的内存管理概念，因为它用于描述硬件行为，而不是软件中的内存操作。</li>
</ul>
<h3 id="4-赋值语句的执行">4. 赋值语句的执行</h3>
<ul>
<li><strong>Python</strong>：赋值语句创建或修改对象引用。如果一个变量被赋值给另一个变量，它们最初指向同一个对象。</li>
<li><strong>C/C++</strong>：赋值语句复制值到新的变量。如果一个变量被赋值给另一个变量，它们各自独立存储自己的值副本。</li>
<li><strong>Verilog</strong>：赋值语句定义了信号之间的逻辑关系，这些关系在硬件实现中表现为电路连接。</li>
</ul>
<p>总的来说，Python的赋值机制更侧重于对象的引用和不可变性，而C、C++和Verilog则更侧重于值的直接操作和硬件行为的描述。这些差异反映了不同语言的设计哲学和应用领域。</p>
<blockquote>
<p>如果更加形象化地解释，如下：</p>
</blockquote>
<p>让我们通过一个比喻来形象化地解释Python、C/C++和Verilog中的赋值机制：</p>
<h3 id="python图书馆的图书卡片">Python：图书馆的图书卡片</h3>
<p>想象一下，Python中的变量就像是图书馆里的图书卡片。每张卡片上写着一本书的标题和它在书架上的位置（内存地址）。当你创建一个变量并赋值时，就像你从书架上取出一本书，然后写一张卡片来记录这本书的信息。</p>
<ul>
<li><strong>基本类型赋值</strong>：假设你取出了一本名为“Python编程”的书，你写了一张卡片“a”，上面写着“Python编程”和它的位置。当你把变量<code>a</code>赋值给变量<code>b</code>时，你只是又写了一张相同的卡片“b”，两张卡片都指向同一本书。如果你在卡片“a”上写下了另一本书的名字“高级Python”，这并不会影响到卡片“b”，因为它仍然指向原来的那本书“Python编程”。在Python中，这意味着<code>b</code>的值不会随着<code>a</code>的赋值而改变。</li>
</ul>
<h3 id="cc图书馆的复印机">C/C++：图书馆的复印机</h3>
<p>在C或C++中，变量就像是图书馆里的复印机。当你创建一个变量并赋值时，就像你复印了一本书的内容，并把复印件给了变量。</p>
<ul>
<li><strong>基本类型赋值</strong>：如果你复印了“Python编程”这本书，并把复印件给了变量<code>a</code>，然后你又复印了<code>a</code>的内容给了变量<code>b</code>，那么<code>a</code>和<code>b</code>都有了“Python编程”的副本。如果你改变了<code>a</code>的副本，比如在上面写下了“高级Python”，这并不会影响到<code>b</code>的副本，因为它们是独立的。在C/C++中，这意味着<code>b</code>的值不会随着<code>a</code>的赋值而改变。</li>
</ul>
<h3 id="verilog电路板上的连线">Verilog：电路板上的连线</h3>
<p>Verilog中的赋值更像是电路板上的连线。当你在Verilog中赋值时，你定义了电路板上不同组件之间的连接。</p>
<ul>
<li><strong>赋值</strong>：如果你定义了一个信号<code>a</code>连接到一个LED灯，然后你定义了另一个信号<code>b</code>也连接到同一个LED灯，那么<code>a</code>和<code>b</code>都会影响到LED灯的状态。如果你改变了<code>a</code>的值，这将直接影响到<code>b</code>，因为它们是同一个电路的一部分。在Verilog中，这意味着<code>b</code>的值会随着<code>a</code>的赋值而改变，这取决于你使用的是阻塞赋值还是非阻塞赋值。</li>
</ul>
<p>通过这个比喻，我们可以看到Python中的赋值更像是创建指向同一对象的引用，而C/C++中的赋值是创建值的副本，Verilog中的赋值则是定义电路组件之间的逻辑关系。这些不同的赋值机制反映了各自语言的特性和用途。</p>
<blockquote>
<p>进一步联想，这和面向对象、面相过程的编程的区分有关系吗？</p>
</blockquote>
<p>是有关系的，Python、C/C++和Verilog中的赋值机制与面向对象（Object-Oriented Programming, OOP）和面向过程（Procedure-Oriented Programming, POP）编程范式有着紧密的联系。这些编程范式影响了语言的设计和赋值机制的实现。让我们看看它们之间的联系：</p>
<h3 id="面向对象编程oop">面向对象编程（OOP）</h3>
<ul>
<li><strong>Python</strong>：Python是一种多范式语言，支持OOP。在OOP中，数据和函数被封装在对象中，对象通过方法和属性相互交互。Python的赋值机制允许对象（包括基本类型）的引用被复制，而不是对象本身。这与OOP中对象的封装和隐藏原则相吻合，即对象的内部状态不应该被外部直接修改。</li>
</ul>
<h3 id="面向过程编程pop">面向过程编程（POP）</h3>
<ul>
<li><strong>C/C++</strong>：C是一种面向过程的语言，而C++支持POP和OOP。在POP中，程序是由一系列操作步骤（过程或函数）组成，数据通过参数在函数间传递。C/C++的赋值机制直接复制值，这与POP中函数间数据传递的方式相似，即函数调用时参数值被复制到函数内部。</li>
</ul>
<h3 id="硬件描述语言hdl">硬件描述语言（HDL）</h3>
<ul>
<li><strong>Verilog</strong>：Verilog是一种硬件描述语言，用于设计和模拟数字电路。它不直接属于OOP或POP范式，但它的赋值机制与硬件电路的行为紧密相关。Verilog中的赋值定义了电路组件之间的连接和信号流动，这与硬件设计中电路的物理连接相似。</li>
</ul>
<h3 id="赋值机制与编程范式的关系">赋值机制与编程范式的关系</h3>
<ul>
<li>
<p><strong>封装</strong>：在OOP中，封装是一个核心概念，它意味着对象的内部状态应该被保护起来，不被外部直接访问。Python的赋值机制支持这一点，因为变量赋值操作不会影响到其他指向同一对象的变量，除非使用特定的方法（如修改可变对象的属性）。</p>
</li>
<li>
<p><strong>数据流</strong>：在POP中，数据通过函数调用在程序中流动。C/C++的赋值机制反映了这种数据流，因为变量的值在函数间传递时会被复制。</p>
</li>
<li>
<p><strong>电路行为</strong>：Verilog的赋值机制模拟了硬件电路的行为，其中信号的赋值定义了电路组件之间的连接和数据流动。</p>
</li>
</ul>
<p>总的来说，编程范式影响了语言的赋值机制和数据管理方式。OOP强调对象的封装和交互，POP侧重于函数和过程的调用，而硬件描述语言则模拟电路的物理行为。这些范式在不同语言中的体现，决定了它们如何处理变量赋值和数据管理。</p>
<blockquote>
<p>更加形象地解释如下：</p>
</blockquote>
<p>让我们通过比喻来形象地解释面向对象（OOP）和面向过程（POP）编程的区分，以及这两种编程范式在Python、C、C++中的应用：</p>
<h3 id="面向对象编程oop建筑团队">面向对象编程（OOP）：建筑团队</h3>
<p>想象一下，你是一个建筑项目的负责人。在OOP中，每个对象就像是项目中的一个团队成员，他们各自有特定的职责和技能（属性和方法）。</p>
<ul>
<li><strong>Python</strong>：在Python中，OOP非常自然和直观。你可以将每个团队成员（对象）视为一个独立的实体，他们可以互相交流（方法调用）和协作（继承和多态）。例如，一个<code>House</code>类可以有<code>build()</code>、<code>paint()</code>等方法，而<code>Apartment</code>类可以继承这些方法并添加特定的功能。</li>
</ul>
<h3 id="面向过程编程pop食谱和烹饪步骤">面向过程编程（POP）：食谱和烹饪步骤</h3>
<p>面向过程编程就像是按照食谱烹饪。食谱中的每个步骤（函数）都是独立的，你需要按照一定的顺序执行这些步骤来完成菜肴。</p>
<ul>
<li>
<p><strong>C</strong>：C语言主要是面向过程的。你可以将每个烹饪步骤（函数）视为一个独立的指令，它们按照特定的顺序执行。例如，一个程序可能首先调用<code>prepare_ingredients()</code>函数，然后是<code>cook_meal()</code>，最后是<code>serve_dinner()</code>。</p>
</li>
<li>
<p><strong>C++</strong>：C++支持面向过程和面向对象编程。你可以将C++看作是食谱和建筑团队的结合。你仍然可以按照食谱（POP）的步骤来烹饪，但你也可以创建不同的食材（类）和烹饪工具（对象），它们可以有自己的特性和行为。</p>
</li>
</ul>
<h3 id="pythoncc中的oop和pop区别">Python、C、C++中的OOP和POP区别</h3>
<ul>
<li>
<p><strong>Python</strong>：在Python中，OOP是核心特性之一。你可以轻松地定义类和对象，以及它们之间的关系。Python的动态类型系统使得OOP更加灵活和强大。</p>
</li>
<li>
<p><strong>C</strong>：C语言不支持OOP的概念。你不能定义类或对象，只能使用结构体（structs）来模拟一些OOP的特性，如封装。C语言更侧重于过程和函数的调用。</p>
</li>
<li>
<p><strong>C++</strong>：C++是支持OOP的，它引入了类（class）的概念，允许你定义对象和它们的行为。C++也支持继承、多态和封装，这些都是OOP的关键特性。同时，C++也保持了C语言的面向过程特性，允许你使用函数和过程来组织代码。</p>
</li>
</ul>
<h3 id="形象比喻">形象比喻</h3>
<ul>
<li>
<p><strong>OOP</strong>：就像是一个由多个专业团队组成的项目，每个团队（类）都有自己的专长和任务，他们可以独立工作，也可以与其他团队合作完成更大的项目。</p>
</li>
<li>
<p><strong>POP</strong>：就像是一个详细的食谱，每一步（函数）都是独立的，你需要按照食谱的顺序来准备和烹饪食物。</p>
</li>
</ul>
<p>通过这些比喻，我们可以更直观地理解OOP和POP编程范式的区别，以及它们在不同编程语言中的实现和应用。</p>
<blockquote>
<p>附上另外一个案例</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/2760960/202501/2760960-20250105105939510-723924482.png" alt="案例" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4663969345798611" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-05 11:01">2025-01-05 11:00</span>&nbsp;
<a href="https://www.cnblogs.com/jzzg">江左子固</a>&nbsp;
阅读(<span id="post_view_count">63</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18653197" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18653197);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18653197', targetLink: 'https://www.cnblogs.com/jzzg/p/18653197', title: 'Python学习（四）——配套《PyTorch深度学习实战》' })">举报</a>
</div>
        