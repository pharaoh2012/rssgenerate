
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/du-hong/p/18686315" title="发布于 2025-05-27 11:41">
    <span role="heading" aria-level="2">PC端自动化测试实战教程-7-pywinauto等待方法大集合 （详细教程）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h3>1.简介</h3>
<p>经过上一篇的学习和讲解想必小伙伴或者童鞋们已经意识到等待的重要性了吧。宏哥在上一篇中在<code>start()</code>后，加入适当的等待时间（如<code>time.sleep()</code>），让应用程序有足够的时间初始化窗口和UI元素。之前我们在做web和app的ui自动化过程中，常用到等待机制，那PC端自动化有这个方法吗？答案是肯定的，python这么强大，肯定是有方法的。今天就跟随宏哥来一起看一下PC端自动化是如何等待的。应用程序行为通常不稳定，您的脚本需要等待，直到出现新窗口或关闭/隐藏现有窗口。 pywinauto可以隐式地（默认超时）灵活地等待对话框初始化，或者明确地使用专用方法/函数来帮助您使代码更容易和更可靠。</p>
<h3>2.等待机制</h3>
<p>宏哥将其分为三个大类（仅是自己的观点）：窗口/元素等待、应用程序等待和全局等待时间Timings。</p>
<h4>2.1窗口/元素等待</h4>
<p>Pywinauto是一个用于自动化Windows GUI应用程序的模块，提供了两种等待函数：wait()和wait_not()。</p>
<ul class="ul-level-0">
<li>wait() 等待窗口达到指定状态。</li>
<li>wait_not() 等待窗口不处于某种状态。</li>
</ul>
<h5>2.1.1wait()</h5>
<p>wait()函数用于等待指定窗口达到指定状态，例如“最大化”或“最小化”状态。你可以通过设置超时时间和重试间隔来控制等待的时间和频率。</p>
<p>1.跟随宏哥先来看一下wait()的源码，然后再进行下一步的学习。wait()的源码如下：</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> wait(self, wait_for, timeout=None, retry_interval=<span style="color: rgba(0, 0, 0, 1)">None):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">
        Wait for the window to be in a particular state/states.

        :param wait_for: The state to wait for the window to be in. It can
            be any of the following states, also you may combine the states by space key.

             * 'exists' means that the window is a valid handle
             * 'visible' means that the window is not hidden
             * 'enabled' means that the window is not disabled
             * 'ready' means that the window is visible and enabled
             * 'active' means that the window is active

        :param timeout: Raise an :func:`pywinauto.timings.TimeoutError` if the window
            is not in the appropriate state after this number of seconds.
            Default: :py:attr:`pywinauto.timings.Timings.window_find_timeout`.

        :param retry_interval: How long to sleep between each retry.
            Default: :py:attr:`pywinauto.timings.Timings.window_find_retry`.

        An example to wait until the dialog
        exists, is ready, enabled and visible: ::

            self.Dlg.wait("exists enabled visible ready")

        .. seealso::
            :func:`WindowSpecification.wait_not()`

            :func:`pywinauto.timings.TimeoutError`
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        check_method_names, timeout, retry_interval </span>= self.<span style="color: rgba(128, 0, 128, 1)">__parse_wait_args</span><span style="color: rgba(0, 0, 0, 1)">(wait_for, timeout, retry_interval)
        wait_until(timeout, retry_interval,
                   </span><span style="color: rgba(0, 0, 255, 1)">lambda</span>: self.<span style="color: rgba(128, 0, 128, 1)">__check_all_conditions</span><span style="color: rgba(0, 0, 0, 1)">(check_method_names, retry_interval))

        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> Return the wrapped control</span>
        <span style="color: rgba(0, 0, 255, 1)">return</span> self.wrapper_object()</pre>
</div>
<p>2.参数说明：</p>
<p><code>wait_for</code> 可选参数：</p>
<ul class="ul-level-0">
<li>‘exists’ 表示窗口存在，是一个有效的句柄</li>
<li>‘visible’ 表示窗口可见（不隐藏）</li>
<li>‘enabled’ 表示窗口未被禁用</li>
<li>‘ready’ 表示窗口可见且已启用</li>
<li>‘active’ 表示窗口处于活动状态</li>
</ul>
<p>timeout：表示超时时间</p>
<p>retry_interval：表示重试间隔</p>
<h5>2.1.2wait_not()</h5>
<p>其实和上面都是一样的，一种等待处于某种状态，一种等待不处于某种状态。wait_not()函数则用于等待指定窗口不处于某种状态，例如“关闭”状态。它的使用方式与wait()函数类似，但参数和返回值有所不同。</p>
<p>1.跟随宏哥先来看一下wait_not()的源码，然后再进行下一步的学习。wait_not()的源码如下：</p>
<div class="cnblogs_code">
<pre> <span style="color: rgba(0, 0, 255, 1)">def</span> wait_not(self, wait_for_not, timeout=None, retry_interval=<span style="color: rgba(0, 0, 0, 1)">None):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">
        Wait for the window to not be in a particular state/states.

        :param wait_for_not: The state to wait for the window to not be in. It can be any
            of the following states, also you may combine the states by space key.

             * 'exists' means that the window is a valid handle
             * 'visible' means that the window is not hidden
             * 'enabled' means that the window is not disabled
             * 'ready' means that the window is visible and enabled
             * 'active' means that the window is active

        :param timeout: Raise an :func:`pywinauto.timings.TimeoutError` if the window is sill in the
            state after this number of seconds.
            Default: :py:attr:`pywinauto.timings.Timings.window_find_timeout`.

        :param retry_interval: How long to sleep between each retry.
            Default: :py:attr:`pywinauto.timings.Timings.window_find_retry`.

        An example to wait until the dialog is not ready, enabled or visible: ::

            self.Dlg.wait_not("enabled visible ready")

        .. seealso::
            :func:`WindowSpecification.wait()`

            :func:`pywinauto.timings.TimeoutError`
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(0, 0, 0, 1)">
        check_method_names, timeout, retry_interval </span>=<span style="color: rgba(0, 0, 0, 1)"> \
            self.</span><span style="color: rgba(128, 0, 128, 1)">__parse_wait_args</span><span style="color: rgba(0, 0, 0, 1)">(wait_for_not, timeout, retry_interval)
        wait_until(timeout, retry_interval,
                   </span><span style="color: rgba(0, 0, 255, 1)">lambda</span>: <span style="color: rgba(0, 0, 255, 1)">not</span> self.<span style="color: rgba(128, 0, 128, 1)">__check_all_conditions</span><span style="color: rgba(0, 0, 0, 1)">(check_method_names, retry_interval))
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> None return value, since we are waiting for a `negative` state of the control.</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> Expect that you will have nothing to do with the window closed, disabled, etc.</span></pre>
</div>
<p>2.参数说明：</p>
<p><code>wait_not</code>&nbsp;可选参数：</p>
<ul class="ul-level-0">
<li>‘exists’ 表示窗口存在，是一个有效的句柄</li>
<li>‘visible’ 表示窗口可见（不隐藏）</li>
<li>‘enabled’ 表示窗口未被禁用</li>
<li>‘ready’ 表示窗口可见且已启用</li>
<li>‘active’ 表示窗口处于活动状态</li>
</ul>
<p>timeout：表示超时时间</p>
<p>retry_interval：表示重试间隔</p>
<h3>3.应用程序等待</h3>
<p>应用程序等待只是针对应用程序的。注意:此方法仅适用于整个应用程序进程,不适用于窗口/元素。</p>
<h4>3.1CPU使用率</h4>
<h4>3.1.1wait_cpu_usage_lower()</h4>
<p>wait_cpu_usage_lower()，等待该进程的cup的使用率低于某个阀值。</p>
<p>1.跟随宏哥先来看一下wait_cpu_usage_lower()的源码，然后再进行下一步的学习。wait_cpu_usage_lower()的源码如下：</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> wait_cpu_usage_lower(self, threshold=2.5, timeout=None, usage_interval=<span style="color: rgba(0, 0, 0, 1)">None):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">Wait until process CPU usage percentage is less than the specified threshold</span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> usage_interval <span style="color: rgba(0, 0, 255, 1)">is</span><span style="color: rgba(0, 0, 0, 1)"> None:
            usage_interval </span>=<span style="color: rgba(0, 0, 0, 1)"> Timings.cpu_usage_interval
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> timeout <span style="color: rgba(0, 0, 255, 1)">is</span><span style="color: rgba(0, 0, 0, 1)"> None:
            timeout </span>=<span style="color: rgba(0, 0, 0, 1)"> Timings.cpu_usage_wait_timeout

        start_time </span>=<span style="color: rgba(0, 0, 0, 1)"> timings.timestamp()

        </span><span style="color: rgba(0, 0, 255, 1)">while</span> self.cpu_usage(usage_interval) &gt;<span style="color: rgba(0, 0, 0, 1)"> threshold:
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> timings.timestamp() - start_time &gt;<span style="color: rgba(0, 0, 0, 1)"> timeout:
                </span><span style="color: rgba(0, 0, 255, 1)">raise</span> RuntimeError(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">Waiting CPU load &lt;= {}% timed out!</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">.format(threshold))

        </span><span style="color: rgba(0, 0, 255, 1)">return</span> self</pre>
</div>
<p>2.参数说明：</p>
<p>threshold：表示该进程cup占用率</p>
<p>timeout：表示超时时间</p>
<p>retry_interval：表示重试间隔</p>
<h4>3.2进程</h4>
<h5>3.2.1.wait_for_process_exit()</h5>
<p>wait_for_process_exit()，等待进程退出，直到超时。</p>
<p>1.跟随宏哥先来看一下wait_for_process_exit()的源码，然后再进行下一步的学习。wait_for_process_exit()的源码如下：</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span> wait_for_process_exit(self, timeout=None, retry_interval=<span style="color: rgba(0, 0, 0, 1)">None):
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span><span style="color: rgba(128, 0, 0, 1)">
        Waits for process to exit until timeout reaches

        Raises TimeoutError exception if timeout was reached
        </span><span style="color: rgba(128, 0, 0, 1)">"""</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> timeout <span style="color: rgba(0, 0, 255, 1)">is</span><span style="color: rgba(0, 0, 0, 1)"> None:
            timeout </span>=<span style="color: rgba(0, 0, 0, 1)"> Timings.app_exit_timeout
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> retry_interval <span style="color: rgba(0, 0, 255, 1)">is</span><span style="color: rgba(0, 0, 0, 1)"> None:
            retry_interval </span>=<span style="color: rgba(0, 0, 0, 1)"> Timings.app_exit_retry

        wait_until(timeout, retry_interval, self.is_process_running, value</span>=False)</pre>
</div>
<p>2.参数说明：</p>
<p>timeout：表示超时时间</p>
<p>retry_interval：表示重试间隔</p>
<h3>4.timings</h3>
<p>pywinauto 查找窗口和控件时会有超时时间与轮询机制，可以通过timings 模块设置全局等待时间。</p>
<h4>4.1timings模块</h4>
<p>timings 模块有三个模式可以设置</p>
<ul class="ul-level-0">
<li>timings.Timings.fast() 快速模式</li>
<li>timings.Timings.defaults() 默认模式</li>
<li>timings.Timings.slow() 慢速模式</li>
</ul>
<p>以下是可以调整的各个时序设置：</p>
<div class="cnblogs_code">
<pre>window_find_timeout (default 5<span style="color: rgba(0, 0, 0, 1)">)
window_find_retry (default .0</span>9<span style="color: rgba(0, 0, 0, 1)">)
app_start_timeout (default </span>10<span style="color: rgba(0, 0, 0, 1)">)
app_start_retry (default .</span>90<span style="color: rgba(0, 0, 0, 1)">)
app_connect_timeout (default </span>5<span style="color: rgba(0, 0, 0, 1)">.)
app_connect_retry (default .</span>1<span style="color: rgba(0, 0, 0, 1)">)
cpu_usage_interval (default .</span>5<span style="color: rgba(0, 0, 0, 1)">)
cpu_usage_wait_timeout (default </span>20<span style="color: rgba(0, 0, 0, 1)">)
exists_timeout (default .</span>5<span style="color: rgba(0, 0, 0, 1)">)
exists_retry (default .</span>3<span style="color: rgba(0, 0, 0, 1)">)
after_click_wait (default .0</span>9<span style="color: rgba(0, 0, 0, 1)">)
after_clickinput_wait (default .0</span>9<span style="color: rgba(0, 0, 0, 1)">)
after_menu_wait (default .</span>1<span style="color: rgba(0, 0, 0, 1)">)
after_sendkeys_key_wait (default .</span>01<span style="color: rgba(0, 0, 0, 1)">)
after_button_click_wait (default 0)
before_closeclick_wait (default .</span>1<span style="color: rgba(0, 0, 0, 1)">)
closeclick_retry (default .</span>05<span style="color: rgba(0, 0, 0, 1)">)
closeclick_dialog_close_wait (default </span>2<span style="color: rgba(0, 0, 0, 1)">)
after_closeclick_wait (default .</span>2<span style="color: rgba(0, 0, 0, 1)">)
after_windowclose_timeout (default </span>2<span style="color: rgba(0, 0, 0, 1)">)
after_windowclose_retry (default .</span>5<span style="color: rgba(0, 0, 0, 1)">)
after_setfocus_wait (default .</span>06<span style="color: rgba(0, 0, 0, 1)">)
setfocus_timeout (default </span>2<span style="color: rgba(0, 0, 0, 1)">)
setfocus_retry (default .</span>1<span style="color: rgba(0, 0, 0, 1)">)
after_setcursorpos_wait (default .</span>01<span style="color: rgba(0, 0, 0, 1)">)
sendmessagetimeout_timeout (default .</span>01<span style="color: rgba(0, 0, 0, 1)">)
after_tabselect_wait (default .</span>05<span style="color: rgba(0, 0, 0, 1)">)
after_listviewselect_wait (default .</span>01<span style="color: rgba(0, 0, 0, 1)">)
after_listviewcheck_wait default(.</span>001<span style="color: rgba(0, 0, 0, 1)">)
listviewitemcontrol_timeout default(</span>1.5<span style="color: rgba(0, 0, 0, 1)">)
after_treeviewselect_wait default(.</span>1<span style="color: rgba(0, 0, 0, 1)">)
after_toobarpressbutton_wait default(.</span>01<span style="color: rgba(0, 0, 0, 1)">)
after_updownchange_wait default(.</span>1<span style="color: rgba(0, 0, 0, 1)">)
after_movewindow_wait default(0)
after_buttoncheck_wait default(0)
after_comboboxselect_wait default(.</span>001<span style="color: rgba(0, 0, 0, 1)">)
after_listboxselect_wait default(0)
after_listboxfocuschange_wait default(0)
after_editsetedittext_wait default(0)
after_editselect_wait default(.</span>02<span style="color: rgba(0, 0, 0, 1)">)
drag_n_drop_move_mouse_wait default(.</span>1<span style="color: rgba(0, 0, 0, 1)">)
before_drag_wait default(.</span>2<span style="color: rgba(0, 0, 0, 1)">)
before_drop_wait default(.</span>1<span style="color: rgba(0, 0, 0, 1)">)
after_drag_n_drop_wait default(.</span>1<span style="color: rgba(0, 0, 0, 1)">)
scroll_step_wait default(.</span>1)</pre>
</div>
<h4>4.2设置模式</h4>
<p>你想让操作更快一点，可以设置快速模式。你想让操作更慢一点，可以设置慢速模式。设置方法还是比较简单的，导入模块后，一行代码即可搞定。</p>
<h5>4.2.1快速模式</h5>
<p>快速模式的设置方式如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">from</span> pywinauto.application <span style="color: rgba(0, 0, 255, 1)">import</span> Applicationfrom pywinauto.timings <span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> Timings

Timings.fast()</span></pre>
</div>
<h5>4.2.2慢速模式</h5>
<p>慢速模式的设置方式如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">from</span> pywinauto.application <span style="color: rgba(0, 0, 255, 1)">import</span> Applicationfrom pywinauto.timings <span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> Timings

Timings.slow()</span></pre>
</div>
<h3>5.趁热打铁</h3>
<p>经过上边宏哥的理论知识的介绍，想必小伙伴或者童鞋们已经对pywinauto的等待有了大致地了解和认识。理论讲的再好、再漂亮，也不如实践，毕竟伟人都说过，实践是检验真理的唯一标准。下边理论结合实际，实践一下。</p>
<h4>5.1测试场景</h4>
<p>测试场景：大致的测试场景就是，启动电脑的notepadd++编辑器这款软件，然后输入内容：北京宏哥，最后点击notepadd++编辑器左上角的【文件(F) -&gt; 另存为(A)...】，然后等待另存为的窗口出现即可！</p>
<h4>5.2代码设计</h4>
<p><img src="https://img2024.cnblogs.com/blog/1232840/202504/1232840-20250414083906824-1191132526.png" alt="" loading="lazy"></p>
<h4>5.3参考代码</h4>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> -*- coding:utf-8 -*-</span>

<span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 1.先设置编码，utf-8可支持中英文，如上，一般放在第一行</span>

<span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 2.注释：包括记录创建时间，创建人，项目名称。</span>
<span style="color: rgba(128, 0, 0, 1)">'''</span><span style="color: rgba(128, 0, 0, 1)">
Created on 2025-04-14
@author: 北京-宏哥
北京宏哥（微信搜索：北京宏哥，关注宏哥，提前解锁更多测试干货！）
Project: PC端自动化测试实战教程-7-pywinauto等待方法大集合 （详细教程）
</span><span style="color: rgba(128, 0, 0, 1)">'''</span>

<span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 3.导入模块</span>
<span style="color: rgba(0, 0, 255, 1)">from</span> pywinauto <span style="color: rgba(0, 0, 255, 1)">import</span><span style="color: rgba(0, 0, 0, 1)"> Application

</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 通过窗口打开</span>
app = Application(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">uia</span><span style="color: rgba(128, 0, 0, 1)">'</span>).start(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">D:/software/Notepad/Notepad++/notepad++.exe</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
app </span>= Application(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">uia</span><span style="color: rgba(128, 0, 0, 1)">'</span>).connect(class_name=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Notepad++</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> win = app['窗口的标题']</span>
<span style="color: rgba(0, 0, 0, 1)">
win </span>= app[<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">新文件1 - Notepad++</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">]
</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">输入内容：北京-宏哥</span>
win.type_keys(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">北京-宏哥</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

win. child_window(title</span>=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">应用程序</span><span style="color: rgba(128, 0, 0, 1)">"</span>, auto_id=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">MenuBar</span><span style="color: rgba(128, 0, 0, 1)">"</span>, control_type=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">MenuBar</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 文件-另存为</span>
win.menu_select(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">文件(F) -&gt; 另存为(A)...</span><span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)"> 等待另存为窗口出现</span>
win.child_window(title=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">另存为</span><span style="color: rgba(128, 0, 0, 1)">"</span>, control_type=<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Window</span><span style="color: rgba(128, 0, 0, 1)">"</span>).wait(<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">ready</span><span style="color: rgba(128, 0, 0, 1)">'</span>, timeout=5)</pre>
</div>
<h4>5.4运行代码</h4>
<p>1.运行代码，右键Run'Test'，就可以看到控制台输出，如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1232840/202504/1232840-20250414083517545-2040328065.png" alt="" loading="lazy"></p>
<p>2.运行代码后电脑端的动作（启动记事本）。如下图所示：</p>
<p><img src="https://img2024.cnblogs.com/blog/1232840/202504/1232840-20250414083730252-978786530.gif" alt="" loading="lazy"></p>
<h3>6.小结</h3>
<h4>6.1.基础窗口状态等待方法‌</h4>
<p>wait() 方法‌<br>支持等待窗口达到特定状态，包括：<br>'exists'：窗口句柄有效<br>'visible'：窗口未隐藏<br>'enabled'：窗口未被禁用<br>'ready'：窗口可见且已启用<br>'active'：窗口处于活动状态<br>参数说明：<br>timeout：超时时间（默认由全局配置决定）<br>retry_interval：重试间隔（默认由全局配置决定）‌</p>
<h4>6.2.高级场景等待方法‌</h4>
<p>wait_cpu_usage_lower()‌<br>适用于多线程应用中延迟初始化的场景，通过监控进程的CPU使用率判断任务是否完成（如后台计算未结束前保持等待）‌<br>wait_until_passes()‌<br>持续执行指定操作直至成功或超时，特别适用于动态加载的控件或异步操作后的状态检测‌</p>
<h4>6.3 ‌全局等待时间配置</h4>
<p>通过 timings 模块设置默认超时和轮询间隔：<br>Timings.Defaults.timeout：全局超时时间（默认30秒）<br>Timings.Defaults.retry_interval：全局重试间隔（默认0.5秒）</p>
<h4>6.4. ‌使用建议‌</h4>
<p>优先使用内置等待机制‌（如 wait() 和 wait_until_passes()），避免依赖 time.sleep()，以提高代码稳定性和执行效率‌<br>对于复杂界面，结合 print_control_identifiers() 输出控件信息以辅助定位目标元素‌</p>
<p>注：以上方法需根据具体场景选择，合理设置超时参数可避免因界面响应延迟导致的自动化失败。</p>
<p>好了，关于pywinauto等待方法大集合常用的也就那几个非常简单，时间不早了今天就分享到这里，感谢你耐心地阅读！</p>
</div>
<div id="MySignature" role="contentinfo">
    <div id="MySignature" style="display: block">
	<div style="font-size: 13px; border: 1px dashed rgb(45, 161, 45); padding: 10px 15px; background-color: rgb(248, 248, 248)">
		<label style="font-weight: bold">
			&nbsp;&nbsp;&nbsp;&nbsp;为了方便大家在移动端也能看到我分享的博文，现已注册个人微信公众号，扫描左下方二维码即可，欢迎大家关注，提前解锁更多测试干货！有时间会及时分享相关技术博文。
		</label>
		<br>
		<label style="font-weight: bold">
			&nbsp;&nbsp;&nbsp;&nbsp;为了方便大家互动讨论相关技术问题，刚刚建立了咱们的专门的微信群交流互动群，群内会分享交流测试领域前沿知识。  请您扫描中间的微信二维码进群 
		</label>
		<br>
		<label style="font-weight: bold">
			&nbsp;&nbsp;&nbsp;&nbsp;为了方便大家互动讨论相关技术问题，现已组建专门的微信群，由于微信群满100，请您扫描右下方宏哥个人微信二维码拉你进群
			<label style="font-weight: bold; color: red; font-size: 15px">
				（请务必备注：已关注公众号进群）平时上班忙（和你一样），所以加好友不及时，请稍安勿躁~
			</label>
			，欢迎大家加入这个大家庭，我们一起畅游知识的海洋。
		</label>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;感谢您花时间阅读此篇文章,如果您觉得这篇文章你学到了东西也是为了犒劳下博主的码字不易不妨打赏一下吧，让博主能喝上一杯咖啡，在此谢过了！
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;如果您觉得阅读本文对您有帮助，请点一下左下角
		<a id="recommend" style="font-weight: bold; color: red; font-size: 15px; text-decoration: underline">
			“推荐”
		</a>
		按钮，您的
		<label style="font-weight: bold; color: red; font-size: 15px">
			“推荐”
		</label>
		将是我最大的写作动力！另外您也可以选择
		<a id="follow_me_btn" style="cursor: pointer; color: blue; text-decoration: underline">
			【
			<strong>
				关注我
			</strong>
			】
		</a>
		，可以很方便找到我！
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;本文版权归作者和博客园共有，来源网址：
		<a href="https://www.cnblogs.com/du-hong" style="color: red; text-decoration: underline" target="_blank">
			https://www.cnblogs.com/du-hong
		</a>
		欢迎各位转载，但是未经作者本人同意，转载文章之后必须在文章页面明显位置给出作者和原文连接，否则保留追究法律责任的权利！
	</div>
	<div style="text-align: center; margin-top: 10px">
		<p style=" font-weight: bolder; color: red; ">
			公众号(关注宏哥)&nbsp; &nbsp;&nbsp;&nbsp;
			&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
			微信群(扫码进群) &nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;客服微信
		</p>
		<img style="width: 200px;padding-right: 50px;" alt="个人微信公众号" src="https://img2018.cnblogs.com/common/1741949/201911/1741949-20191119095948011-608816619.png">
		<img style="width: 200px;padding-right: 65px;" alt="微信群" src="https://img2024.cnblogs.com/blog/1232840/202505/1232840-20250527084315750-1972686124.png">
		<img style="width: 200px" alt="个人微信" src="https://img2018.cnblogs.com/common/1741949/201911/1741949-20191106101257091-849954564.png">
	</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5267850708865741" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-27 11:41">2025-05-27 11:41</span>&nbsp;
<a href="https://www.cnblogs.com/du-hong">北京-宏哥</a>&nbsp;
阅读(<span id="post_view_count">100</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18686315);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18686315', targetLink: 'https://www.cnblogs.com/du-hong/p/18686315', title: 'PC端自动化测试实战教程-7-pywinauto等待方法大集合 （详细教程）' })">举报</a>
</div>
        