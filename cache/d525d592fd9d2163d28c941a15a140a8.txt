
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18755276" title="发布于 2025-03-06 15:27">
    <span role="heading" aria-level="2">『Python底层原理』--GIL对多线程的影响</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在 <code>Python</code> 多线程编程中，全局解释器锁（<code>Global Interpreter Lock</code>，简称 <code>GIL</code>）是一个绕不开的话题。</p>
<p><code>GIL</code>是<code>CPython</code>解释器的一个机制，它限制了同一时刻只有一个线程可以执行 <code>Python</code> 字节码。</p>
<p>尽管多线程在某些场景下可以显著提升程序性能，但 <code>GIL</code> 的存在却让 <code>Python</code> 多线程在很多情况下无法充分发挥其优势。</p>
<p>本文将探讨 <code>GIL</code> 的工作机制、它对 <code>Python</code> 多线程的影响，以及解决相关问题的方法和未来的发展方向。</p>
<h1 id="1-python的多线程">1. Python的多线程</h1>
<p>当我们运行一个 <code>Python</code> 可执行文件时，操作系统会启动一个主线程。</p>
<p>这个主线程负责执行 <code>Python</code> 程序的初始化操作，包括加载模块、编译代码以及执行字节码等。</p>
<p>在多线程环境中，<code>Python</code> 线程由操作系统线程（<strong>OS 线程</strong>）和 <code>Python</code> 线程状态组成，</p>
<p>操作系统线程负责调度线程的执行，而 <code>Python</code> 线程状态则包含了线程的局部变量、堆栈信息等。</p>
<p>比如：</p>
<pre><code class="language-python">import threading

def worker():
    print(f"Thread {threading.current_thread().name} is running")

# 创建并启动两个线程
thread1 = threading.Thread(target=worker, name="Thread-1")
thread2 = threading.Thread(target=worker, name="Thread-2")
thread1.start()
thread2.start()
thread1.join()
thread2.join()
</code></pre>
<p>在上述代码中，我们创建了两个线程<code>Thread-1</code>和<code>Thread-2</code>。操作系统会为每个线程分配一个** OS 线程**，并在适当的时候切换它们的执行。</p>
<p>不过，<code>Python</code>中的多线程与其他语言不一样的地方在于，它有一个<code>GIL</code>的机制。</p>
<p><code>GIL</code>是<code>Python</code>解释器的一个重要机制，一个线程在进入运行之前，必须先获得 <code>GIL</code>。</p>
<p>如果 <code>GIL</code> 已被其他线程占用，那么当前线程将等待，直到 <code>GIL</code> 被释放。</p>
<p><code>GIL</code> 的释放规则如下：</p>
<ul>
<li>线程执行一定时间后，会主动释放 <code>GIL</code>，以便其他线程可以获取它</li>
<li>线程在执行 <code>I/O</code> 操作时，会释放 <code>GIL</code>，因为<code> I/O</code> 操作通常会阻塞线程，释放 <code>GIL</code> 可以让其他线程有机会运行。</li>
</ul>
<p>比如：</p>
<pre><code class="language-python">import time

def cpu_bound_task():
    # 模拟 CPU 密集型任务
    result = 0
    for i in range(10000000):
        result += i

def io_bound_task():
    # 模拟 I/O 密集型任务
    time.sleep(2)

# 创建两个线程分别执行 CPU 密集型和 I/O 密集型任务
thread_cpu = threading.Thread(target=cpu_bound_task)
thread_io = threading.Thread(target=io_bound_task)
thread_cpu.start()
thread_io.start()
thread_cpu.join()
thread_io.join()
</code></pre>
<p>在上述代码中，<code>cpu_bound_task</code>是一个 <code>CPU</code> 密集型任务，它会一直占用 <code>GIL</code>，直到任务完成。</p>
<p>而<code>io_bound_task</code>是一个 <code>I/O</code> 密集型任务，它在执行时会释放 <code>GIL</code>，让其他线程有机会运行。</p>
<h1 id="2-gil的影响">2. GIL的影响</h1>
<h2 id="21-对cpu密集型任务的影响">2.1. 对CPU密集型任务的影响</h2>
<p><code>GIL</code>对 <code>CPU</code> 密集型任务的影响巨大，使得<code>Python</code>的多线程在<code>CPU</code>密集型任务中几乎无法发挥优势。</p>
<p>因为即使有多个线程，同一时刻也只有一个线程可以执行 <code>Python</code> 字节码。</p>
<p>而且，线程之间的上下文切换还会增加额外的开销，导致程序性能下降。</p>
<pre><code class="language-python">import time
import threading

def cpu_bound_task():
    result = 0
    for i in range(10000000):
        result += i

def single_thread():
    start_time = time.time()
    cpu_bound_task()
    cpu_bound_task()
    print(f"Single-thread time: {time.time() - start_time:.2f} seconds")

def multi_thread():
    start_time = time.time()
    thread1 = threading.Thread(target=cpu_bound_task)
    thread2 = threading.Thread(target=cpu_bound_task)
    thread1.start()
    thread2.start()
    thread1.join()
    thread2.join()
    print(f"Multi-thread time: {time.time() - start_time:.2f} seconds")

single_thread()
multi_thread()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202503/83005-20250306152716151-1349722240.png" alt="" loading="lazy"></p>
<p>运行上述代码，我们会发现多线程版本的执行时间比单线程版本还要长，这正是因为 <code>GIL</code> 的存在导致了线程之间的上下文切换开销。</p>
<h2 id="22-对io密集型任务的影响">2.2. 对I/O密集型任务的影响</h2>
<p>与 <code>CPU</code> 密集型任务不同，多线程在 <code>I/O</code>密集型任务中可以显著提升性能。</p>
<p>因为当一个线程在执行 <code>I/O</code> 操作时，它会释放 <code>GIL</code>，其他线程可以利用这段时间执行其他任务。</p>
<pre><code class="language-python">import time
import threading

def io_bound_task():
    time.sleep(2)

def single_thread():
    start_time = time.time()
    io_bound_task()
    io_bound_task()
    print(f"Single-thread time: {time.time() - start_time:.2f} seconds")

def multi_thread():
    start_time = time.time()
    thread1 = threading.Thread(target=io_bound_task)
    thread2 = threading.Thread(target=io_bound_task)
    thread1.start()
    thread2.start()
    thread1.join()
    thread2.join()
    print(f"Multi-thread time: {time.time() - start_time:.2f} seconds")

single_thread()
multi_thread()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202503/83005-20250306152716182-1437717908.png" alt="" loading="lazy"></p>
<p>运行上述代码，我们会发现多线程版本的执行时间比单线程版本缩短了一半，这说明多线程在 <code>I/O</code> 密集型任务中可以有效提升性能。</p>
<h2 id="23-护航效应convoy-effect">2.3. 护航效应（Convoy Effect）</h2>
<p>当 <code>CPU</code> 密集型线程和<code> I/O</code> 密集型线程混合运行时，会出现一种称为<strong>“护航效应”</strong>的现象。</p>
<p><code>CPU</code> 密集型线程会一直占用 <code>GIL</code>，导致 <code>I/O </code>密集型线程无法及时获取 <code>GIL</code>，从而大幅降低 <code>I/O</code> 密集型线程的性能。</p>
<p>比如：</p>
<pre><code class="language-python">import time
import threading

def cpu_bound_task():
    result = 0
    for i in range(10000000):
        result += i

def io_bound_task():
    time.sleep(2)

def mixed_thread():
    start_time = time.time()
    thread_cpu = threading.Thread(target=cpu_bound_task)
    thread_io = threading.Thread(target=io_bound_task)
    thread_cpu.start()
    thread_io.start()
    thread_cpu.join()
    thread_io.join()
    print(f"Mixed-thread time: {time.time() - start_time:.2f} seconds")

mixed_thread()
</code></pre>
<p>在上述代码中，<code>cpu_bound_task</code>会一直占用<code>GIL</code>，导致<code>io_bound_task </code>无法及时运行，从而延长了整个程序的执行时间。</p>
<h1 id="3-gil存在的原因">3. GIL存在的原因</h1>
<p><code>GIL</code>给并发性能带来了很多的问题，为什么<code>Python</code>解释器中会有<code>GIL</code>这个方案呢？</p>
<p>因为<code>Python</code>历史悠久，当初<code>Python</code>流行的时候，针对多核的并发编程并不是主流，当时采用<code>GIL</code>主要是为了保证线程安全。</p>
<p><code>GIL</code>涵盖了以下几个方面：</p>
<ul>
<li><strong>引用计数</strong>：<code>Python</code> 使用引用计数来管理内存。如果多个线程同时修改引用计数，可能会导致内存泄漏或崩溃</li>
<li><strong>数据结构</strong>：许多 <code>Python</code> 内置数据结构（如列表、字典等）需要线程安全的访问</li>
<li><strong>全局数据</strong>：解释器的全局状态需要保护，以防止多线程访问时出现数据竞争</li>
<li><strong>C 扩展</strong>：许多 C 扩展模块依赖于<code>GIL</code>来保证线程安全。</li>
</ul>
<p>目前，尽管<code>GIL</code>带来了诸多限制，但移除它并非易事。主要困难包括：</p>
<ol>
<li><strong>垃圾回收机制</strong>：<code>Python</code> 的垃圾回收机制依赖于引用计数，移除 <code>GIL</code> 后需要重新设计垃圾回收机制</li>
<li><strong>C 扩展兼容性</strong>：许多现有的 <strong>C 扩展</strong>模块依赖于 <code>GIL</code> 来保证线程安全。移除 <code>GIL</code> 后，这些扩展模块可能需要重新编写</li>
</ol>
<p>例如，<code>Gilectomy</code>项目尝试移除 <code>GIL</code>，但最终因性能问题和兼容性问题而失败。</p>
<p>虽然移除了 <code>GIL</code>，但单线程性能大幅下降，且许多 C 扩展模块无法正常工作。</p>
<p><code>GIL</code>的实现细节可以通过阅读<code>CPython</code>源代码来进一步了解。</p>
<p>关键文件包括<code>Python/ceval.c</code>和<code>Python/thread.c</code>，其中定义了<code>GIL</code>的获取和释放机制。</p>
<h1 id="4-gil的未来">4. GIL的未来</h1>
<p><code>GIL</code>是一定要解决的问题，毕竟多核才是当前主流的发展方向。</p>
<p>目前，有些项目为了解决<code>GIL</code>对并发性能的影响，正在努力发展中，包括：</p>
<h2 id="41-子解释器计划">4.1. 子解释器计划</h2>
<p><code>Python</code> 的子解释器计划（<code>PEP 554</code>）试图通过引入多个独立的解释器（每个解释器拥有自己的 <code>GIL</code>）来实现多解释器并行。</p>
<p>这种方法可以在一定程度上绕过 <code>GIL</code> 的限制，但目前仍存在一些限制，例如跨解释器通信的开销较大。</p>
<h2 id="42-faster-cpython-项目">4.2. Faster CPython 项目</h2>
<p><code>Faster CPython</code> 项目专注于提升 <code>Python</code> 的单线程性能。</p>
<p>虽然它可能会进一步优化 <code>GIL</code> 的实现，但其主要目标是减少解释器的开销，而不是直接解决 <code>GIL</code> 问题。</p>
<p>这可能会使 <code>GIL</code> 问题在短期内受到较少的关注。</p>
<h2 id="43-sam-gross-的-cpython-fork">4.3. Sam Gross 的 CPython fork</h2>
<p><code>Sam Gross</code> 的 <code>CPython fork</code> 是一个值得关注的尝试，他成功移除了 <code>GIL</code>，并且在单线程性能上取得了显著提升。</p>
<p>他的工作为解决 <code>GIL</code> 问题带来了新的方向，但目前尚未被合并到主线 <code>CPython</code> 中。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.036595314768518517" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-06 15:28">2025-03-06 15:27</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18755276" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18755276);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18755276', targetLink: 'https://www.cnblogs.com/wang_yb/p/18755276', title: '『Python底层原理』--GIL对多线程的影响' })">举报</a>
</div>
        