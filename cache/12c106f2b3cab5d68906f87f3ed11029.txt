
		<div class="postcontent">
			    <div id="cnblogs_post_description" style="display: none">
        
        这个算是一个跨多个对象解决生命周期问题的例子吧
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Timer的实现挺值得拿出来聊一聊的</p>
<p>Anoii网络库的事件循环：</p>
<p><img src="https://img2024.cnblogs.com/blog/2771459/202502/2771459-20250212000739210-240784718.png" alt="image" loading="lazy"></p>
<p>Timer是使用poll的timeout参数实现的，所以定时的精度是毫秒，对于一个网络库而言这足够了。如果不够的话，还可以使用timerfd来提升精度。</p>
<p>由于需要计算poll的timeout是多少，就需要组织起来所有的Timer，计算下一次触发timeout的时间。所以我将所有的Timer用std::set组织起来了。具体的说是<code>std::set&lt;mstime_t, Timer*&gt;</code>，第一个参数是该Timer被触发的时间，第二个参数就是Timer本身。实际上组织Timer的对象就是TimerQueue</p>
<p>使用std::set而不是<code>std::map&lt;mstime_t, Timer*&gt;</code>的原因是，同一个时间可能存在两个Timer被触发，另一个做法是unordered_map，不过没必要这么做，而且用它的人也少。</p>
<h2 id="难点">难点</h2>
<p>实现可以见https://github.com/Afeather2017/anoii/blob/master/src/timer_queue.cc</p>
<p>设计一个Timer的难点是，如何确保其生命周期？</p>
<p>如果一个Timer的生命周期与程序差不多长，那么就不存在这种问题，但是如果一个临时的对象使用Timer呢？</p>
<p>Anoii中用于建立连接的Connector就存在这样的问题：</p>
<p>Connector在建立连接的过程中需要进行重试，每次重试的时间间隔是1s, 2s, 4s, 8s...，这样就必须使用定时器了。但是Connector建立连接的过程中，用户应当要能够随时取消建立连接，这意味Connector必须要能够取消Timer。</p>
<p>总不能Connector释放了，Timer还继续使用Connector吧？那么如何设计一个Timer的取消？</p>
<h3 id="智能指针">智能指针</h3>
<p>最容易想到的方案是，使用智能指针。Connector保留一份Timer的shared_ptr，然后Timer在调用之前检查一下引用计数，如果为1那么这个Timer就没必要继续调用了。反过来Timer也许要保留一份Connector的weak_ptr，在调用之前要升级为shared_ptr再调用。但是由于我确保了Connector和Timer的处理都是在同一个线程的，这种做法似乎不是很必要。</p>
<h3 id="直接释放内存">直接释放内存</h3>
<p>调用取消的时候马上就释放Timer是不可行的。对于一个多线程程序而言，一个线程调用Timer的取消的时候，另一个线程可能还在使用Timer。虽然可以通过确保二者在同一个线程来解决这个场景的问题，但是如果Timer进行了自取消呢？</p>
<h3 id="设置标志位">设置标志位</h3>
<p>所以给Timer设计一个统一的取消方式：Timer在调用回调的时候，根据返回值决定是否释放该Timer。返回为false就释放该Timer，返回为true，则该Timer继续定时。</p>
<p>然后，给Timer添加一个标志位，如果它被取消了，就设置该标志。如果标志被设置了，那么在下一次处理Timer的时候就释放它。设置标志位的好处是，别的对象可以正常取消Timer，一个Timer可以取消另一个Timer，Timer也可以自取消。</p>
<p>取消的操作移交到处理该Timer的线程操作，所以不需要锁也可以正常设置该标志位。</p>
<h3 id="取消操作的幂等性">取消操作的幂等性</h3>
<p>接下来还有一个问题，Timer的重复取消问题。</p>
<p>如果一个Timer被取消了，也被释放了，那么此时设置标志位就是个问题。</p>
<p>解决这个问题的方法是，在TimerQueue中添加一个<code>std::map&lt;TimerId, Timer*&gt;</code>，TimerId是一个64位整数，它只会递增。添加Timer的时候往里面添加其Id以及Timer指针，取消的时候检查一下该Id是否还存在，否则就直接返回。</p>
<p>这样一来，取消操作就具有幂等性了</p>
<h2 id="改进设计">改进设计</h2>
<ol>
<li>
<p>由于Timer的回调都能够返回值了，那么下一次定时的长度不妨就直接用这个返回值来做。即如果回调返回的值小于0，就可以释放该定时器，如果大于0，那么下一次定时的时间是当前时间+返回的值。这样一来Connector的逐渐增加定时时长就可以轻易的实现了，这样还可以节省malloc次数</p>
</li>
<li>
<p>Timer自己都带有标志位了，那么就让标志位为其Id得了。第一个Id的值是1，Id大于0表示该Timer还有效，否则无效且可以被释放。取消的时候设置为-Id，这样也不用担心负数设置的时候出现值溢出（因为整数的负数范围比正数的大1，据说Java有个著名的库，好像是Netty，曾经在这上面踩坑，即-INT_MIN = INT_MIN的问题）</p>
</li>
</ol>
<p>所以最终的Timer如下</p>
<pre><code class="language-cpp">class Timer {
  Timer(std::function&lt;mstime_t(mstime_t)&gt; cb, TimerId id);
  void Cancel();
  mstime_t Call(mstime_t mstime);
  std::function&lt;mstime_t(mstime_t)&gt; cb_;
  TimerId timer_id_;
  friend TimerQueue;
};
</code></pre>
<h2 id="已经修复的bug1-定时器时间错误">已经修复的BUG1: 定时器时间错误</h2>
<p>在编译安卓的时候，发现chargenserver时不时的会阻塞而没有反应。由于缺乏日志，在安卓上又缺乏调试手段，所以一开始没有找到问题。</p>
<p>发现阻塞问题后，我仔细回想了一下哪些地方可能造成长时间阻塞的。第一个是read没有设置非阻塞，第二个是poll中的timeout值为-1。于是在这些地方加了日志，发现poll的timeout设置为-1。果不其然，发现了timeout为-1。</p>
<p><img src="https://img2024.cnblogs.com/blog/2771459/202501/2771459-20250112222922305-811127146.png" alt="image" loading="lazy"></p>
<p>-1的来源是TimerQueue中的SleepTime():</p>
<pre><code class="language-c++">mstime_t TimerQueue::SleepTime() {
  struct timeval tv;
  gettimeofday(&amp;tv, NULL);
  mstime_t temp = timers_.begin()-&gt;first - (tv.tv_sec * 1000 + tv.tv_usec / 1000);
  if (temp &lt;= 0) {
    return 0;
  }
  return temp;
}
</code></pre>
<p>在temp获取之后，加了日志，发现temp的值为负数。</p>
<p><img src="https://img2024.cnblogs.com/blog/2771459/202501/2771459-20250112222425100-852006734.png" alt="image" loading="lazy"></p>
<p>为什么？后面仔细一想，这个函数的行为应当是这样的才对：</p>
<ol>
<li>如果没有定时，返回-1</li>
<li>如果有定时，获取第一个定时器的时间，与当前时间相减，如果是负数，返回0，否则返回相减的值</li>
</ol>
<p>但是上面代码的行为是：</p>
<ol>
<li>如果没有定时，返回timers_.begin()-&gt;first - 当前时间，但是由于没有定时，所以timers_.begin()的值可能是一个垃圾值，所以返回的值无法确定，返回-1也是有可能的</li>
<li>如果有定时，返回第一个定时器与当前的差值，如果为负数，返回-1，这会让poll阻塞了，否则返回差值</li>
</ol>
<p>所以修改很简单：</p>
<pre><code class="language-c++">mstime_t TimerQueue::SleepTime() {
  if (timers_.size() == 0) return -1;
  struct timeval tv;
  gettimeofday(&amp;tv, NULL);
  mstime_t temp = timers_.begin()-&gt;first - (tv.tv_sec * 1000 + tv.tv_usec / 1000);
  if (temp &lt;= 0) {
    return 0;
  }
  return temp;
}
</code></pre>

</div>
<div class="clear"></div>

		</div>
		<div class="itemdesc">
			发表于 
<span id="post-date" data-last-update-days="0.050250626704861114" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-12 01:05">2025-02-12 01:05</span>&nbsp;
<a href="https://www.cnblogs.com/Afeather">Afeather</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18667518" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18667518);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18667518', targetLink: 'https://www.cnblogs.com/Afeather/p/18667518', title: 'Anoii网络库之Timer实现' })">举报</a>

		</div>
	