
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/bcsg/p/18669618" title="发布于 2025-01-13 23:26">
    <span role="heading" aria-level="2">List.Insert 导致的 CPU 爆高</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>我们经常会使用 <code>List&lt;T&gt;</code> 作为数据存储容器。但在某些特殊场景下，<code>List.Insert</code> 方法可能会引发严重的性能问题，例如 CPU 占用率飙升。</p>
<hr>
<h2 id="示例程序">示例程序</h2>
<p>以下是一个简单的控制台程序，模拟在 <code>List</code> 的开头不断插入数据：</p>
<pre><code>internal class Program
{
    static void Main(string[] args)
{
    List&lt;string&gt; numbers = new List&lt;string&gt;();
    string orderNumber = "order12345678912456";
    Console.WriteLine($"从数据库读取到数据，逐条放入list");
    Stopwatch sw = Stopwatch.StartNew();
    for (int i = 0; i &lt; 100000; i++)
    {
        numbers.Insert(0, orderNumber); // 每次插入到列表开头
        //numbers.Add(orderNumber);
        if (i % 1000 == 0)
        {
            Console.WriteLine($"已插入 {i} 次");
        }
    }
    //numbers.Reverse();
    sw.Stop();
    Console.WriteLine($"插入完成，耗时：{sw.ElapsedMilliseconds} ms，按任意键退出...");
    Console.ReadLine();
}
}
</code></pre>
<p>运行上述代码后，当插入数据量逐渐增大时，CPU 的占用率会显著提升，执行完以后CPU恢复正常。原因何在？我们从源码和数据结构的角度进行分析。</p>
<hr>
<h2 id="listinsert-的底层实现">List.Insert 的底层实现</h2>
<p>以下是 <code>List.Insert</code> 方法的核心实现（通过ILSpy查看）：</p>
<pre><code>public void Insert(int index, T item)
{
    if ((uint)index &gt; (uint)_size)
    {
        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index, ExceptionResource.ArgumentOutOfRange_ListInsert);
    }
    if (_size == _items.Length)
    {
        Grow(_size + 1);
    }
    if (index &lt; _size)
    {
        Array.Copy(_items, index, _items, index + 1, _size - index);
    }
    _items[index] = item;
    _size++;
    _version++;
}
</code></pre>
<p>关键点：</p>
<p>1.<strong><code>Array.Copy</code></strong>：当插入位置在列表中间或开头时，需要将插入点之后的所有元素向后移动一位，以腾出空间存放新元素。<br>
2.<strong>时间复杂度</strong>：</p>
<p>•单次插入操作的时间复杂度为 (O(n))，其中 (n) 是列表的当前长度。<br>
•当在循环中多次调用 <code>Insert</code>，整体复杂度会累积。</p>
<hr>
<h2 id="插入过程的图解">插入过程的图解</h2>
<p>以下用一张图示意 <code>numbers.Insert(0, i)</code> 的操作过程：</p>
<p>1.初始状态：</p>
<p><code>[1, 2, 3, 4, 5] (原始数组)`` ^ Insert(0, 10)</code></p>
<p>2.插入后：</p>
<p><code>[10, 1, 2, 3, 4, 5] (新状态)</code></p>
<p>首先会进行扩容检查，如果<code>_size</code>已达到<code>_items.Length</code>，会调用<code>EnsureCapacity</code>扩容。在插入过程中， &nbsp;<code>Array.Copy</code> 从索引 0 开始，将每个元素向右移动一位，最终完成插入。</p>
<hr>
<h2 id="复杂度分析">复杂度分析</h2>
<p>对于长度为 (n) 的 <code>List</code>，在头部插入元素的时间复杂度为 (O(n))。在一个循环中执行 (m) 次插入操作，累积复杂度为：</p>
<p>[ O(1) + O(2) + O(3) + \ldots + O(m) = O\left(\frac{m^2}{2}\right) ]</p>
<h3 id="示例计算">示例计算</h3>
<p>假设 <code>List&lt;int&gt;</code> 的长度为 100,000，每次在头部插入数据：</p>
<p>•第 1 次插入移动 0 个元素•第 2 次插入移动 1 个元素•第 3 次插入移动 2 个元素•...•第 100,000 次插入移动 99,999 个元素</p>
<p>总移动次数为：</p>
<p>[ T = 0 + 1 + 2 + \ldots + (100,000 - 1) = \frac{(100,000) \times (100,000 - 1)}{2} = 4,999,950,000 ]</p>
<p><strong>移动了 49.9 亿次元素</strong>，这就是导致 CPU 爆高的根本原因。</p>
<hr>
<h2 id="解决方案">解决方案</h2>
<p>需要注意的是，<code>LinkedList</code> 的遍历效率不如 <code>List</code>，因此适用场景有限。</p>
<h3 id="1-使用-listadd--reverse-优化">1. 使用 <code>List.Add</code> + <code>Reverse</code> 优化</h3>
<p>可以先用 <code>List.Add</code> 插入，再调用 <code>Reverse</code> 方法。<code>List.Add</code> 方法，复杂度为 (O(1))。</p>
<pre><code>var numbers = new List&lt;int&gt;();
for (int i = 0; i &lt; 100000; i++)
{
    numbers.Add(orderNumber);
}
numbers.Reverse();
</code></pre>
<h3 id="2-使用-linkedlist">2. 使用 <code>LinkedList</code></h3>
<p>对于频繁在头部插入的场景，可以选择 <code>LinkedList</code>，插入操作复杂度为 (O(1))。</p>
<pre><code>var linkedNumbers = new LinkedList&lt;int&gt;();
for (int i = 0; i &lt; 100000; i++)
{
    linkedNumbers.AddFirst(i);
}
</code></pre>
<hr>
<h2 id="总结">总结</h2>
<p><code>List&lt;T&gt;</code> 存放的数据可能有一定量时候，要考虑的<code>List.Insert</code>性能问题。了解常见集合类型及其操作背后的数据结构原理，选择合适的数据结构。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.04719752632407408" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-13 23:29">2025-01-13 23:26</span>&nbsp;
<a href="https://www.cnblogs.com/bcsg">dotNet编程拾光</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18669618" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18669618);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18669618', targetLink: 'https://www.cnblogs.com/bcsg/p/18669618', title: 'List.Insert 导致的 CPU 爆高' })">举报</a>
</div>
        