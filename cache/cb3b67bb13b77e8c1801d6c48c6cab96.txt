
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/CUC-MenG/p/19023935" title="发布于 2025-08-05 20:10">
    <span role="heading" aria-level="2">2025牛客多校第五场 K.完美旅程 J.最快覆盖问题 E.神秘异或操作 个人题解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="emysterious-xor-operation">E.<a href="https://ac.nowcoder.com/acm/contest/108302/E" target="_blank" rel="noopener nofollow">Mysterious XOR Operation</a></h1>
<h1 id="位运算">位运算</h1>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250805200426485-954852941.png" alt="image" loading="lazy"></p>
<h2 id="思路">思路</h2>
<p>观察两个数<span class="math inline">\(a,b\)</span>，研究二者神秘异或后第<span class="math inline">\(pos\)</span>位对答案的贡献：<br>
设<span class="math inline">\(pos\)</span>位上二者的<span class="math inline">\(bit\)</span>不同，记二者<span class="math inline">\(0\sim pos-1\)</span>位上<span class="math inline">\(1\)</span>的个数为<span class="math inline">\(cnt_{a},cnt_{b}\)</span></p>
<ul>
<li>则<span class="math inline">\(a\wedge b\)</span>在<span class="math inline">\(0\sim pos\)</span>位上的<span class="math inline">\(1\)</span>个数为<span class="math inline">\(cnt_{a}-k+cnt_{b}-k\)</span>，其中<span class="math inline">\(k\)</span>为<span class="math inline">\(a,b\)</span>在<span class="math inline">\(0\sim pos\)</span>位上同时为<span class="math inline">\(1\)</span>的个数</li>
<li>则<span class="math inline">\(a\wedge b\)</span>在<span class="math inline">\(0\sim pos\)</span>位上的<span class="math inline">\(1\)</span>个数与<span class="math inline">\(cnt_{a}+cnt_{b}\)</span>的奇偶性直接挂钩</li>
</ul>
<p>创建三维数组<span class="math inline">\(cnt[28][2][2]\)</span>，其中<span class="math inline">\(cnt[pos][bit][1/0]\)</span>表示当前遍历到第<span class="math inline">\(pos\)</span>位，当前位为<span class="math inline">\(bit\)</span>，<span class="math inline">\(0\sim pos-1\)</span>位上<span class="math inline">\(1\)</span>的个数<span class="math inline">\(\&amp;1\)</span>后为<span class="math inline">\(1/0\)</span>的个数</p>
<p>每次插入一个新的数，都更新<span class="math inline">\(cnt[pos][bit][1/0]\)</span>，让贡献加上<span class="math inline">\(cnt\)</span>乘以当前<span class="math inline">\(pos\)</span>的十进制数即可</p>
<h2 id="代码实现">代码实现</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;unordered_map&gt;
#include&lt;set&gt;
using namespace std;
using ll = long long;
#define rep(i, a, b) for(ll i = (a); i &lt;= (b); i ++)
#define per(i, a, b) for(ll i = (a); i &gt;= (b); i --)
//#define see(stl) for(auto&amp;ele:stl)cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;'\n';

int cnt[28][2][2];
void eachT() {
    int n;cin&gt;&gt;n;
    ll ans=0;
    rep(i,1,n){
        int x;cin&gt;&gt;x;
        int cnt1=0;
        rep(pos,0,27){
            int nowbit=(x&gt;&gt;pos)&amp;1;
            ans+=1ll*(1&lt;&lt;pos)*cnt[pos][nowbit^1][cnt1&amp;1];
            cnt[pos][nowbit][cnt1&amp;1]++;
            if(nowbit)cnt1++;            
        }
    }
    cout&lt;&lt;ans&lt;&lt;'\n';
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    ll t = 1;
    //cin &gt;&gt; t;
    while (t--) { eachT(); }
}

</code></pre>
<hr>
<h1 id="jfastest-coverage-problem">J.<a href="https://ac.nowcoder.com/acm/contest/108302/J" target="_blank" rel="noopener nofollow">Fastest Coverage Problem</a></h1>
<h1 id="二分-bfs-优先队列-曼哈顿距离">二分 #BFS #优先队列 #曼哈顿距离</h1>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250805200441292-421154419.png" alt="image" loading="lazy"></p>
<h2 id="思路-1">思路</h2>
<p>要求最短时间，可以考虑二分答案判断合法性</p>
<p>对于每一个确定的时间<span class="math inline">\(tim\)</span>，我们可以求得当前未染色的点的曼哈顿距离最大的四个边界：</p>
<p></p><div class="math display">\[(x+y)_{max}
,(-x-y)_{max},(x-y)_{max},(y-x)_{max}
\]</div><p></p><p>由此可以算得未染色点所构成的区域的直径：</p>
<p></p><div class="math display">\[\begin{align}
&amp;d_{1}=(x+y)_{max}+(-x-y)_{max}\\ \\
&amp;d_{2}=|(x-y)_{max}+(y-x)_{max}|\\ \\
&amp;d=max\{ d_{1},d_{2} \}
\end{align}
\]</div><p></p><p><span class="math inline">\(2\times tim\)</span>表示在<span class="math inline">\(tim=0\)</span>时某个位置染成黑色可以染黑区域的直径，因此比较<span class="math inline">\(2\times tim\)</span>与<span class="math inline">\(d\)</span>即可判断当前二分的<span class="math inline">\(tim\)</span>是否合法</p>
<p>至于如何求得每个时间点的四个边界值，我们可以开四个优先队列<span class="math inline">\(priority\_{queue&lt;\!int\!&gt;}q[4]\)</span>进行储存<br>
带着时间戳对进行BFS，每当当前的时间发生了变化，就去更新四个优先队列，将队列中已经被染色的<span class="math inline">\(top\)</span>踢出</p>
<p>最后，需要特判全零的情况，此时的答案即为<span class="math inline">\(\left\lfloor  \frac{n}{2}  \right\rfloor+\left\lfloor  \frac{m}{2}  \right\rfloor\)</span></p>
<h2 id="代码实现-1">代码实现</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;unordered_map&gt;
#include&lt;bitset&gt;
using namespace std;
using ll = long long;
#define rep(i, a, b) for(ll i = (a); i &lt;= (b); i ++)
#define per(i, a, b) for(ll i = (a); i &gt;= (b); i --)
//#define see(stl) for(auto&amp;ele:stl)cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;'\n';
const ll inf = 1e7 + 5;

const int N = 2e5 + 5;
int n, m;

struct node {
    ll val, x, y;
    bool operator&lt;(const node&amp; t)const {
        return val &lt; t.val;
    }
};
priority_queue&lt;node&gt;q[4];//da根堆

struct Tim {
    ll d[4];
}t[N];

unordered_map&lt;int, unordered_map&lt;int, bool&gt;&gt;vis, a;

struct node2 {
    ll x, y, tim;
};

int dx[4] = { 0,1,0,-1 };
int dy[4] = { 1,0,-1,0 };

bool check(int tim) {
    int d1 = abs(t[tim].d[0] + t[tim].d[3]);
    int d2 = abs(t[tim].d[2] + t[tim].d[1]);
    int dd = max(d1, d2);
    if (dd &gt; 2 * tim)return 0;
    return 1;
}

void eachT() {
    cin &gt;&gt; n &gt;&gt; m;
    int cnt0=0;
    deque&lt;node2&gt;dq;
    rep(x, 1, n) {
        rep(y, 1, m) {
            a[x][y];
            cin &gt;&gt; a[x][y];
            if (!a[x][y]) {
                q[0].push({ x + y,x,y });
                q[1].push({ x - y,x,y });
                q[2].push({ y - x,x,y });
                q[3].push({ -x - y,x,y });
                cnt0++;
            }
            else {
                dq.push_back({ x,y,0 });
                vis[x][y] = 1;
            }
        }
    }
    if(cnt0==n*m){
        cout&lt;&lt;(n/2)+(m/2)&lt;&lt;'\n';
        return;
    }
    rep(j, 0, 3) {
        if(!q[j].empty())t[0].d[j] = q[j].top().val;
    }
    int nowt = 0,tmax=0;
    while (!dq.empty()) {
        int x = dq.front().x, y = dq.front().y, tim = dq.front().tim;
        dq.pop_front();
        tmax = max(tmax, tim);
        if (tim &gt; nowt) {
            nowt = tim;
            rep(j, 0, 3) {
                if (q[j].empty())continue;
                while (!q[j].empty()&amp;&amp;vis[q[j].top().x][q[j].top().y])q[j].pop();
                if(!q[j].empty())t[nowt].d[j] = q[j].top().val;
            }
        }
        rep(i, 0, 3) {
            int nx = x + dx[i], ny = dy[i] + y;
            if (nx &gt; n || nx&lt;1 || ny&gt;m || ny &lt; 1 || vis[nx][ny])continue;
            vis[nx][ny] = 1;
            dq.push_back({ nx,ny,nowt + 1 });
        }
    }
    int l = -1, r =tmax+ 1;
    while (l + 1 &lt; r) {
        int mid = l + r &gt;&gt; 1;
        if (check(mid))r = mid;
        else l = mid;
    }
    cout &lt;&lt; r &lt;&lt; '\n';
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    ll t = 1;
    //cin &gt;&gt; t;
    while (t--) { eachT(); }
}
</code></pre>
<hr>
<h1 id="kperfect-journey">K.<a href="https://ac.nowcoder.com/acm/contest/108302/K" target="_blank" rel="noopener nofollow">Perfect Journey</a></h1>
<h1 id="dfs-fwt-fmt-数学">dfs #FWT #FMT #数学</h1>
<h2 id="题目">题目</h2>
<p><img src="https://img2024.cnblogs.com/blog/3677788/202508/3677788-20250805200507339-1834291160.png" alt="image" loading="lazy"></p>
<h2 id="思路-2">思路</h2>
<p>由于给出的<span class="math inline">\(m\leq 22\)</span>，所以很容易想到需要对覆盖哪些特定道路进行状态压缩：<br>
第<span class="math inline">\(pos\)</span>位为<span class="math inline">\(1\)</span>代表第<span class="math inline">\(pos\)</span>个特定道路已经被覆盖，反之没有被覆盖</p>
<p>如何获取每个简单路径的状态掩码<span class="math inline">\(mask\)</span>呢？</p>
<p>可以在<span class="math inline">\(node\)</span>结构体中开一个<span class="math inline">\(mk(mask)\)</span>变量，代表当前点<span class="math inline">\(u\)</span>到根节点<span class="math inline">\(root\)</span>的简单路径上覆盖了哪些特定道路，跑dfs记录即可<br>
那么<span class="math inline">\(u\to v\)</span>的简单路径所覆盖的特定道路则为<span class="math inline">\(mk_{u}\wedge mk_{v}\)</span>，<span class="math inline">\(lca\to root\)</span>这一段路上共有的特定道路会因异或运算而消去</p>
<p>接下来提供两种计算答案的思路，分别是<span class="math inline">\(FWT\)</span>+容斥、<span class="math inline">\(FWT\)</span>+二分：</p>
<ul>
<li>解法一：<span class="math inline">\(FWT\)</span>+容斥（std解法）
<ul>
<li>创建数组<span class="math inline">\(dp_{i}[1\!&lt;\!&lt;23]\)</span>，其中<span class="math inline">\(dp_{i}[mask]\)</span>代表在选择了<span class="math inline">\(i\)</span>条旅游路线后，状态为<span class="math inline">\(mask\)</span>的子集的方案<strong>排列</strong>数</li>
</ul>
</li>
</ul>
<p></p><div class="math display">\[\begin{align}
&amp;FWT_{or}卷积:\ \ [x^m]FWT_{or}(f)=\sum_{i|m=m}f_{i}\\ \\
&amp;IFWT_{or}卷积:\ \ IFWT_{or}(FWT_{or}(f))=f\\ \\ 
\end{align} 
\]</div><p></p><p><em><span class="math inline">\([x^m]A\)</span>代表多项式<span class="math inline">\(A\)</span>中<span class="math inline">\(x^m\)</span>的系数</em></p>
<ul>
<li>正常<span class="math inline">\(FWT\)</span>做法：</li>
</ul>
<p></p><div class="math display">\[\begin{align}
&amp;ans=[x^m]IFWT[\ FWT(dp)·FWT(dp)·\dots·FWT(dp)\ ]=[x^m]IFWT[\ FWT^{cnt}(dp)\ ]
\end{align}
\]</div><p></p><ul>
<li>对<span class="math inline">\(dp\)</span>数组<span class="math inline">\(FWT\)</span>卷积的结果累乘<span class="math inline">\(cnt\)</span>次就代表选择了<span class="math inline">\(cnt\)</span>条旅游路线</li>
<li>遍历<span class="math inline">\(cnt\)</span>来尝试选择的数量</li>
<li>使用快速幂来计算<span class="math inline">\(FWT^{cnt}(dp)\)</span></li>
<li>使用<span class="math inline">\(IFWT(dp)\)</span>来还原<span class="math inline">\(dp\)</span>数组，<span class="math inline">\([x^{one}]IFWT(dp)\)</span>就是当前<span class="math inline">\(cnt\)</span>的答案</li>
<li>判断<span class="math inline">\(dp[one]\)</span>是否非零，是则直接输出即可</li>
</ul>
<pre><code class="language-cpp">void fwt_or(int *a, int op, int len) {
    for (int i = 1; i &lt; len; i &lt;&lt;= 1) {
        for (int p = i &lt;&lt; 1, j = 0; j &lt; len; j += p) {
            rep(k, 0, i - 1) {
                a[i + j + k] = (a[i + j + k] + a[j + k] * op + mod) % mod;
            }
        }
    }
}
//eachT():
fwt_or(dp, 1, len);
rep(i, 0, len - 1) dp1[i] = dp[i];
rep(cnt, 1, M) {
	rep(mask, 0, len - 1) tmp[mask] = qpow(dp1[mask], cnt);
	fwt_or(tmp, -1, len);
	int ans = tmp[len - 1];
	if (ans) {
		cout &lt;&lt; cnt &lt;&lt; " " &lt;&lt; ans * inv[cnt] % mod &lt;&lt; '\n';
		return;
	}
}
cout &lt;&lt; -1 &lt;&lt; '\n';
</code></pre>
<ul>
<li>但是由于每次确定一个<span class="math inline">\(i\)</span>，<span class="math inline">\(FWT\)</span>的复杂度都是<span class="math inline">\(m·2^m\)</span>，最终复杂度为<span class="math inline">\(m^2·2^m\)</span>会<strong>TLE</strong>，所以需要单独对于<span class="math inline">\([x^i]\)</span>系数进行讨论
<ul>
<li>容斥+<span class="math inline">\(FWT\)</span>做法
<ul>
<li>由于我们只需要求<span class="math inline">\([x^{one}]IFWT(dp)\)</span>，即全集项的系数，因此没有必要每一次都对整个<span class="math inline">\(dp\)</span>数组做<span class="math inline">\(IFWT\)</span>变换（<span class="math inline">\(m·2^m\)</span>）</li>
<li>注意到上述正常做法实际上对于一个确定的<span class="math inline">\(cnt\)</span>仅需要进行一次<span class="math inline">\(FWT\)</span>与<span class="math inline">\(IFWT\)</span>，中间的<span class="math inline">\(cnt\)</span>项为累乘，可以使用快速幂计算，因此降低时间复杂度的关键就在于如何免去<span class="math inline">\(IFWT\)</span>的过程</li>
<li>因此这里需要对单一项进行<span class="math inline">\(IFWT\)</span>，这实际上就是莫比乌斯反演：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p></p><div class="math display">\[\begin{align} 
&amp;f(S)=\sum_{T\in S}(-1)^{|S-T|}g(T)\\ \\
&amp;[x^{one}]IFWT(dp)=\sum_{mask|one=one}(-1)^{popcount(mask\wedge one)}dp[mask]
\end{align}
\]</div><p></p><ul>
<li>其中<span class="math inline">\(one\)</span>对应全集<span class="math inline">\(S\)</span>，<span class="math inline">\(mask\)</span>对应子集<span class="math inline">\(T\)</span>，<span class="math inline">\(popcount(x)\)</span>代表二进制数<span class="math inline">\(x\)</span>中的1个数，<span class="math inline">\(mask\wedge one\)</span>对应全集减去子集的状态<span class="math inline">\(|S-T|\)</span></li>
<li>由此可以枚举<span class="math inline">\(mask\)</span>实现莫比乌斯反演，复杂度为<span class="math inline">\(2^m\)</span>，总复杂度来到<span class="math inline">\(m·2^m\)</span>可以接受</li>
<li>最后输出的时候需要除以<span class="math inline">\(!cnt\)</span>以将排列数转换为组合数</li>
</ul>
<pre><code class="language-cpp">    while(m--){
        cnt++;        
        int ans=0;
        rep(mk,0,one){
            int sign=(__builtin_popcount((mk^one))&amp;1)?-1:1;
            ans+=sign*qpow(dp[mk],cnt);
            ans=(ans+mod)%mod;
        }
        if(ans){
            cout&lt;&lt;cnt&lt;&lt;" "&lt;&lt;(ans*inv[cnt])%mod&lt;&lt;'\n';return;
        }      
    }
    cout&lt;&lt;-1&lt;&lt;'\n';
</code></pre>
<ul>
<li>解法二：<span class="math inline">\(FWT\)</span>+二分（来自<span class="math inline">\(fisher\ go\)</span>大佬）
<ul>
<li>由于要求最少的路径选择数，所以可以二分这个<span class="math inline">\(cnt\)</span></li>
<li>对于一个确定的<span class="math inline">\(cnt\)</span>，转换过程如下：</li>
</ul>
</li>
</ul>
<p></p><div class="math display">\[\begin{align}
&amp;dp[mask]:一定能覆盖状态mask的路径数\\ \\
&amp;dp[mask]=[x^{mask}]FWT(dp):一定能覆盖状态mask的子集的路径数\\  \\
&amp;dp[mask]=C_{dp[mask]}^{num}:一定能覆盖状态mask的子集的路径数中选num个的组合数\\ \\
&amp;dp[mask]=[x^{mask}]IFWT(dp):一定能覆盖状态mask的路径数中选num个 的组合数
\end{align}
\]</div><p></p><ul>
<li>最终的答案即为<span class="math inline">\(dp[one]\)</span></li>
</ul>
<h2 id="代码实现-2">代码实现</h2>
<h4 id="容斥"><span class="math inline">\(FWT\)</span>+容斥</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;unordered_map&gt;
#include&lt;map&gt;
#include&lt;iomanip&gt;
using namespace std;
using ll = long long;
#define rep(i, a, b) for(ll i = (a); i &lt;= (b); i ++)
#define per(i, a, b) for(ll i = (a); i &gt;= (b); i --)
#define see(stl) for(auto&amp;ele:stl)cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;'\n';
#define int ll

const int N = 2e5 + 5, mod = 998244353;
int n, m, k,tag[N];
struct node {
    vector&lt;pair&lt;int,int&gt;&gt;e;//next,id
    int mk;
}a[N];

void dfs(int u, int fa, int mk) {
    a[u].mk = mk;
    for (auto&amp; next : a[u].e) {
        int son=next.first,id=next.second;
        if (son == fa)continue;
        if(tag[id])dfs(son, u, mk|(1&lt;&lt;(tag[id]-1)));
        else dfs(son, u, mk);
    }
}

int dp[1 &lt;&lt; 23], dp1[1 &lt;&lt; 23], one;

ll qpow(ll a, ll b) {
    ll res = 1;
    for (; b; b &gt;&gt;= 1, a = a * a % mod) {
        if (b &amp; 1) res = res * a % mod;
    }
    return res;
}

vector&lt;int&gt;inv,A;
void inv0(){
    inv.resize(23);A.resize(23);
    inv[0]=1;A[0]=1;
    rep(i,1,22){
        A[i]=(A[i-1]*i)%mod;
        inv[i]=qpow(A[i],mod-2);
    }
}

void fwt_or(int *a,int op){
    for(int i=1;i&lt;one;i&lt;&lt;=1){
        for(int p=i&lt;&lt;1,j=0;j&lt;one;j+=p){
            rep(k,0,i-1){
                (a[i+j+k]+=a[j+k]*op+mod)%=mod;
            }
        }
    }
}

void eachT() {
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    one = (1 &lt;&lt; m) - 1;
    rep(mk,0,one)dp[mk]=0,dp1[mk]=0;
    rep(i, 1, n) {
        a[i].e.clear();
        tag[i]=0;
    }
    rep(i, 1, n - 1) {
        int u, v; cin &gt;&gt; u &gt;&gt; v;
        a[u].e.push_back({v,i});
        a[v].e.push_back({u,i});
    }
    rep(i, 1, m) {
        int x; cin &gt;&gt; x;
        tag[x]=i;
    }
    dfs(1, 0, 0);
    rep(i, 1, k) {
        int s, t; cin &gt;&gt; s &gt;&gt; t;
        int mk=a[s].mk^a[t].mk;
        dp[mk]++;
    }
    int cnt=0;
    rep(i, 0, m - 1) {
        rep(mk, 0, one) {
            if ((1 &lt;&lt; i) &amp; mk) {
                dp[mk] += dp[mk ^ (1 &lt;&lt; i)];
                dp[mk] %= mod;
            }
        }
    }
    while(m--){
        cnt++;        
        int ans=0;
        rep(mk,0,one){
            int sign=(__builtin_popcount((mk^one))&amp;1)?-1:1;
            ans+=sign*qpow(dp[mk],cnt);
            ans=(ans+mod)%mod;
        }
        if(ans){
            cout&lt;&lt;cnt&lt;&lt;" "&lt;&lt;(ans*inv[cnt])%mod&lt;&lt;'\n';return;
        }      
    }
    cout&lt;&lt;-1&lt;&lt;'\n';
}

signed main() {
    inv0();
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int t = 1;
    //cin&gt;&gt;t;
    while (t--)eachT();
}
</code></pre>
<h4 id="二分"><span class="math inline">\(FWT\)</span>+二分</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;unordered_map&gt;
#include&lt;map&gt;
#include&lt;iomanip&gt;
using namespace std;
using ll = long long;
#define rep(i, a, b) for(ll i = (a); i &lt;= (b); i ++)
#define per(i, a, b) for(ll i = (a); i &gt;= (b); i --)
#define see(stl) for(auto&amp;ele:stl)cout&lt;&lt;ele&lt;&lt;" "; cout&lt;&lt;'\n';
#define int ll

const int N = 2e5 + 5, mod = 998244353;
int n, m, k,tag[N];
struct node {
    vector&lt;pair&lt;int,int&gt;&gt;e;//next,id
    int mk;
}a[N];

void dfs(int u, int fa, int mk) {
    a[u].mk = mk;
    for (auto&amp; next : a[u].e) {
        int son=next.first,id=next.second;
        if (son == fa)continue;
        if(tag[id])dfs(son, u, mk|(1&lt;&lt;(tag[id]-1)));
        else dfs(son, u, mk);
    }
}

ll qpow(ll a, ll b) {
    a %= mod; ll res = 1;
    while (b) {
        if (b % 2) { res *= a; res %= mod; }
        a *= a; a %= mod; b &gt;&gt;= 1;
    }
    return res % mod;
}
vector&lt;ll&gt;A, inv;
void inv0(ll len) {
    A.resize(len + 1), inv.resize(len + 1);
    A[0] = 1, inv[0] = 1;
    rep(i, 1, len) {
        A[i] = A[i - 1] * i % mod;
        inv[i] = qpow(A[i], mod - 2);
    }
}
ll C(ll n, ll m) {
    if (m &gt; n)return 0;
    return A[n] * inv[m] % mod * inv[n - m] % mod;
}

int dp[1 &lt;&lt; 23], dp1[1 &lt;&lt; 23], one;

void see2(int x) {
    while (x) {
        cout &lt;&lt; (x &amp; 1);
        x &gt;&gt;= 1;
    }
}

pair&lt;bool,ll&gt;check(int num) {//judge,val
    rep(mk, 0, one) {
        dp1[mk] = C(dp[mk], num);
    }
    rep(i, 0, m - 1) {
        rep(mk, 0, one) {
            if ((1 &lt;&lt; i) &amp; mk) {
                dp1[mk] -= dp1[mk ^ (1 &lt;&lt; i)];
                dp1[mk] = (dp1[mk] + mod) % mod;
            }
        }
    }
    if (dp1[one])return {1,dp1[one]};
    return {0,0};
}

void eachT() {
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    one = (1 &lt;&lt; m) - 1;
    rep(i, 1, n) {
        a[i].e.clear();
        tag[i]=0;
    }
    rep(i, 1, n - 1) {
        int u, v; cin &gt;&gt; u &gt;&gt; v;
        a[u].e.push_back({v,i});
        a[v].e.push_back({u,i});
    }
    rep(i, 1, m) {
        int x; cin &gt;&gt; x;
        tag[x]=i;
    }
    dfs(1, 0, 0);
    rep(i, 1, k) {
        int s, t; cin &gt;&gt; s &gt;&gt; t;
        int mk=a[s].mk^a[t].mk;
        dp[mk]++;
    }
    rep(i, 0, m - 1) {
        rep(mk, 0, one) {
            if ((1 &lt;&lt; i) &amp; mk) {
                dp[mk] += dp[mk ^ (1 &lt;&lt; i)];
                dp[mk] %= mod;
            }
        }
    }
    int l = 0, r = m + 1;
    ll ans=0;
    while (l + 1 &lt; r) {
        int mid = l + r &gt;&gt; 1;
        pair&lt;bool,ll&gt;pd=check(mid);
        if (pd.first)r = mid,ans=pd.second;
        else l = mid;
    }
    if (r == m + 1) {
        cout &lt;&lt; -1 &lt;&lt; '\n'; return;
    }
    cout &lt;&lt; r &lt;&lt; " " &lt;&lt; ans&lt;&lt; '\n';
}

signed main() {
    inv0(2e5 + 5);
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int t = 1;
    //cin&gt;&gt;t;
    while (t--)eachT();
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.002777777777777778" data-date-updated="2025-08-05 20:14">2025-08-05 20:10</span>&nbsp;
<a href="https://www.cnblogs.com/CUC-MenG">CUC-MenG</a>&nbsp;
阅读(<span id="post_view_count">7</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19023935);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19023935', targetLink: 'https://www.cnblogs.com/CUC-MenG/p/19023935', title: '2025牛客多校第五场 K.完美旅程 J.最快覆盖问题 E.神秘异或操作 个人题解' })">举报</a>
</div>
        