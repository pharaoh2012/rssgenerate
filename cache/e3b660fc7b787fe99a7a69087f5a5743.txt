
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/vipstone/p/18657860" title="发布于 2025-01-07 16:14">
    <span role="heading" aria-level="2">场景题：假设有40亿QQ号，但只有1G内存，如何实现去重？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>当数据量比较大时，使用常规的方式来判重就不行了。例如，使用 MySQL 数据库判重，或使用 List.contains() 或 Set.contains() 判重就不行了，因为数据量太大会导致内存放不下，或查询速度太慢等问题。</p>
<h2 id="1空间占用量预测">1.空间占用量预测</h2>
<p>正常情况下，如果将 40 亿 QQ 号存储在 Java 中的 int 类型的话，一个 int 占 4 字节（byte）那么 40 亿占用空间大小为：</p>
<blockquote>
<p>4000000000*4/1024/1024/1024=14.9 GB</p>
<p>1GB=1024MB，1MB=1024KB，1KB=1024B（byte）</p>
</blockquote>
<p>所以，我们无法使用正常的手段进行 40 亿 QQ 号的存储和去重判断，那怎么实现呢？</p>
<h2 id="2解决方案">2.解决方案</h2>
<p>此问题的常见解决方案有两种：</p>
<ol>
<li><strong>使用位数组 BitMap 实现判重。</strong></li>
<li>使用<strong>布隆过滤器</strong>实现判重。</li>
</ol>
<p>具体来说。</p>
<h3 id="21-位数组实现判重">2.1 位数组实现判重</h3>
<p>位数组是指使用位（bit）组成的数组，每个 QQ 号使用 1 位（bit）来存储，如下图所示：<img src="https://cdn.nlark.com/yuque/0/2025/png/92791/1736234535674-318cc2b7-5651-4acf-a9a6-5eaaa098ce39.png" alt="" loading="lazy">其中下标用来标识具体的数字，例如以上图片标识 1、3 数字存在，如果值为 0 表示不存在，这样的话 40 亿占用的位数组空间位 40 亿 bit，也就是 4000000000/1024/1024/1024/8=0.465 GB，不到 1G 的内存就可以存储 40 亿 QQ 号了，查询某个 QQ 号是否在线，只需要看这个 QQ 下标对应的位置是否为 1，1 表示存在，0 表示不存在。</p>
<h4 id="位数组代码实现">位数组代码实现</h4>
<p>位数组可以使用 Java 自带的 BitSet 来实现，它位于 java.util 包中，具体实现代码如下：</p>
<pre><code class="language-java">import java.util.BitSet;

public class BitmapExample {
    public static void main(String[] args) {
        // 创建一个BitSet实例
        BitSet bitmap = new BitSet();

        // 设置第5个位置为1，表示第5个元素存在
        bitmap.set(5);

        // 检查第5个位置是否已设置
        boolean exists = bitmap.get(5);
        System.out.println("Element exists: " + exists);  // 输出: Element exists: true

        // 设置从索引10到20的所有位置为1
        bitmap.set(10, 21);  // 参数是包含起始点和不包含终点的区间

        // 计算bitset中所有值为1的位的数量，相当于计算设置了的元素个数
        int count = bitmap.cardinality();
        System.out.println("Number of set bits: " + count);

        // 清除第5个位置
        bitmap.clear(5);

        // 判断位图是否为空
        boolean isEmpty = bitmap.isEmpty();
        System.out.println("Is the bitset empty? " + isEmpty);
    }
}
</code></pre>
<h3 id="22-布隆过器实现">2.2 布隆过器实现</h3>
<blockquote>
<p>布隆过滤器是基于位数组实现的，它是一种高效的数据结构，由布隆在 1970 年提出。<strong>它主要用于判断一个元素可能是否存在于集合中</strong>，其核心特性包括高效的插入和查询操作，但<strong>存在一定的假阳性（False Positives）</strong>可能性。</p>
</blockquote>
<p>布隆过滤器实现如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/92791/1736234626068-1b99c9fe-aab9-4608-801d-25fad7f35108.png" alt="" loading="lazy"></p>
<p>根据 key 值计算出它的存储位置，然后将此位置标识全部标识为 1（未存放数据的位置全部为 0），查询时也是查询对应的位置是否全部为 1，如果全部为 1，则说明<strong>数据是可能存在的，否则一定不存在</strong>。</p>
<blockquote>
<p><strong>布隆过器特性</strong>：如果布隆过滤器说一个元素不在集合中，那么它一定不在这个集合中；但如果它说一个元素在集合中，则有可能是不存在的（存在误差，假阳性）。</p>
</blockquote>
<h4 id="布隆过器代码实现">布隆过器代码实现</h4>
<p>布隆过滤器的常见实现有以下几种方式：</p>
<ol>
<li>使用 Google Guava BloomFilter 实现布隆过滤器，具体实现代码如下：</li>
</ol>
<pre><code class="language-java">import com.google.common.hash.BloomFilter;
import com.google.common.hash.Funnels;
public class BloomFilterExample {
    public static void main(String[] args) {
        // 创建一个布隆过滤器，设置期望插入的数据量为10000，期望的误判率为0.01
        BloomFilter&lt;String&gt; bloomFilter = 
        BloomFilter.create(Funnels.unencodedCharsFunnel(), 10000, 0.01);
        // 向布隆过滤器中插入数据
        bloomFilter.put("data1");
        bloomFilter.put("data2");
        bloomFilter.put("data3");
        // 查询元素是否存在于布隆过滤器中
        System.out.println(bloomFilter.mightContain("data1")); // true
        System.out.println(bloomFilter.mightContain("data4")); // false
    }
}
</code></pre>
<ol start="2">
<li>使用 Hutool 框架 BitMapBloomFilter 实现布隆过滤器，如下代码所示：</li>
</ol>
<pre><code class="language-java">// 初始化
BitMapBloomFilter filter = new BitMapBloomFilter(10);
// 存放数据
filter.add("123");
filter.add("abc");
filter.add("ddd");
// 查找
filter.contains("abc");
</code></pre>
<ol start="3">
<li>使用 Redisson 框架中的 RBloomFilter 实现布隆过滤器，如下代码所示：</li>
</ol>
<pre><code class="language-java">Config config = new Config();
config.useSingleServer().setAddress("redis://127.0.0.1:6379");
RedissonClient redissonClient = Redisson.create(config);
// 创建布隆过滤器，设置名称和期望容量与误报率
RBloomFilter&lt;String&gt; bloomFilter = 
redissonClient.getBloomFilter("myBloomFilter");
bloomFilter.tryInit(10000, 0.03); // 期望容量 10000，误报率 3%
// 添加元素到布隆过滤器
String element1 = "element1";
bloomFilter.add(element1);
// 判断元素是否存在
boolean mightExist = bloomFilter.contains(element1);
System.out.println("元素 " + element1 + " 可能存在: " + mightExist);
String element2 = "element2";
boolean mightExist2 = bloomFilter.contains(element2);
System.out.println("元素 " + element2 + " 可能存在: " + mightExist2);
</code></pre>
<p>其中 Google Guava BloomFilter 和 Hutool 框架 BitMapBloomFilter 为单机版的布隆过滤器实现，不适用分布式环境。<strong>分布式环境要使用 Redisson 框架中的 RBloomFilter 来实现布隆过滤器</strong>，因为它的数据是保存在 Redis 中间件的，而中间件天生支持分布式系统。</p>
<h2 id="小结">小结</h2>
<p>位数组和布隆过滤器的区别如下：</p>
<ul>
<li><strong>位数组</strong>：没有误判，但空间利用率低。</li>
<li><strong>布隆过滤器</strong>：空间利用率高，但存在对已经存在的数据的误判（不存在的数据没有误判）。</li>
</ul>
<p>因此，如果对精准度要求高可以使用位数组；如果对空间要求苛刻，可以考虑布隆过滤器。</p>
<blockquote>
<p>本文已收录到我的面试小站 <a href="https://www.javacn.site" target="_blank" rel="noopener nofollow">www.javacn.site</a>，其中包含的内容有：场景题、并发编程、MySQL、Redis、Spring、Spring MVC、Spring Boot、Spring Cloud、MyBatis、JVM、设计模式、消息队列等模块。</p>
</blockquote>

</div>
<div id="MySignature" role="contentinfo">
    <div style="text-align: center; color: red">
关注下面二维码，订阅更多精彩内容。
<br>
<img style="margin-left: 0px" src="https://images.cnblogs.com/cnblogs_com/vipstone/848916/o_211225130402_gognzhonghao.jpg">
</div>

<div style="display: none">
    <img src="http://icdn.apigo.cn/gitchat/rabbitmq.png?imageView2/0/w/500/h/400">
</div>
<div style="margin-bottom: 50px; display: none">

<img title="微信打赏" src="http://icdn.apigo.cn/myinfo/wchat-pay.png" alt="微信打赏">
<br>

<div style="display: none">
<span style="display: block; position: absolute; height: 40px; top: 50%; margin-top: -20px">关注公众号（加好友）：</span>

<img style="margin-left: 144px" src="http://icdn.apigo.cn/gongzhonghao2.png?imageView2/0/w/120/h/120">
</div>
<p></p>

<div id="AllanboltSignature">
    <p style="border-top: #e0e0e0 1px dashed; border-right: #e0e0e0 1px dashed; border-bottom: #e0e0e0 1px dashed; border-left: #e0e0e0 1px dashed; padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 60px; background: url(&quot;https://images.cnblogs.com/cnblogs_com/lloydsheng/239039/o_copyright.gif&quot;) #e5f1f4 no-repeat 1% 50%; font-family: 微软雅黑; font-size: 11px" id="PSignature">
        <br> 作者：
        <a href="http://vipstone.cnblogs.com/" target="_blank">王磊的博客</a>
        <br> 出处：
        <a href="http://vipstone.cnblogs.com/" target="_blank">http://vipstone.cnblogs.com/</a>
        <br>
    </p>
</div></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0033231978981481483" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-07 16:15">2025-01-07 16:14</span>&nbsp;
<a href="https://www.cnblogs.com/vipstone">磊哥|www.javacn.site</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18657860" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18657860);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18657860', targetLink: 'https://www.cnblogs.com/vipstone/p/18657860', title: '场景题：假设有40亿QQ号，但只有1G内存，如何实现去重？' })">举报</a>
</div>
        