
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/gfuran/p/18882579" title="发布于 2025-05-18 20:24">
    <span role="heading" aria-level="2">C语言函数指针解析</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="c语言函数指针解析">C语言函数指针解析</h1>
<h2 id="一函数指针的本质">一、函数指针的本质</h2>
<p>函数指针是存储函数内存地址的变量，它允许程序在运行时动态调用不同的函数。与数据指针不同，函数指针指向的是可执行代码段。</p>
<pre><code class="language-c">/* 典型声明方式 */
int (*func_ptr)(int, int);  // 可指向任何接受两个int参数且返回int的函数
</code></pre>
<h2 id="二核心语法详解">二、核心语法详解</h2>
<h3 id="1-声明与初始化">1. 声明与初始化</h3>
<p>函数指针的声明必须与目标函数签名严格匹配：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// 基础函数定义
int Add(int a, int b) { return a + b; }
int Sub(int a, int b) { return a - b; }

int main() {
    // 初始化方式（两种等效）
    int (*fp1)(int, int) = Add;   // 直接赋值
    int (*fp2)(int, int) = &amp;Sub;  // 取地址赋值
    
    printf("5+3=%d\n", fp1(5, 3));  // 输出8
    printf("5-3=%d\n", (*fp2)(5, 3)); // 输出2
    
    return 0;
}
</code></pre>
<h3 id="2-类型定义简化">2. 类型定义简化</h3>
<p>使用<code>typedef</code>提升代码可读性：</p>
<pre><code class="language-c">typedef int (*ArithmeticFunc)(int, int);

ArithmeticFunc fp = Add;  // 简化后的声明
</code></pre>
<h2 id="三实际应用场景">三、实际应用场景</h2>
<h3 id="1-回调函数实现">1. 回调函数实现</h3>
<p>函数指针最常见的用途是实现回调机制：</p>
<pre><code class="language-c">// 回调函数类型定义
typedef void (*Logger)(const char*);

// 业务函数
void ProcessData(int data, Logger log) {
    char buf[50];
    sprintf(buf, "Processing: %d", data);
    log(buf);  // 通过函数指针回调
}

// 具体回调实现
void ConsoleLogger(const char* msg) {
    printf("[LOG] %s\n", msg);
}

int main() {
    ProcessData(42, ConsoleLogger);  // 输出：[LOG] Processing: 42
    return 0;
}
</code></pre>
<h3 id="2-函数指针数组">2. 函数指针数组</h3>
<p>创建可扩展的操作表：</p>
<pre><code class="language-c">ArithmeticFunc operations[] = {
    Add,
    Sub,
    [](int a, int b) { return a * b; },  // 注意：此lambda语法为C++特性，纯C需替换为具名函数
    [](int a, int b) { return a / b; }
};

// 纯C替代方案
int Multiply(int a, int b) { return a * b; }
int Divide(int a, int b) { return a / b; }
ArithmeticFunc c_operations[] = {Add, Sub, Multiply, Divide};
</code></pre>
<h2 id="四工程实践建议">四、工程实践建议</h2>
<h3 id="1-错误预防">1. 错误预防</h3>
<pre><code class="language-c">/* 必须检查空指针 */
if (func_ptr != NULL) {
    func_ptr(1, 2);
}

/* 避免签名不匹配 */
// int WrongFunc(float a, float b); 
// func_ptr = WrongFunc;  // 编译错误！
</code></pre>
<h3 id="2-典型应用案例">2. 典型应用案例</h3>
<pre><code class="language-c">/* 标准库qsort用法 */
#include &lt;stdlib.h&gt;
int CompareInt(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

int main() {
    int arr[] = {5, 2, 9, 1};
    qsort(arr, 4, sizeof(int), CompareInt);
    // 排序结果：1, 2, 5, 9
    return 0;
}
</code></pre>
<h2 id="五总结对比">五、总结对比</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>函数指针</th>
<th>普通函数调用</th>
</tr>
</thead>
<tbody>
<tr>
<td>运行时灵活性</td>
<td>可在运行时改变指向</td>
<td>编译期固定</td>
</tr>
<tr>
<td>性能开销</td>
<td>无额外开销</td>
<td>无额外开销</td>
</tr>
<tr>
<td>典型用途</td>
<td>回调/插件/策略模式</td>
<td>直接功能实现</td>
</tr>
</tbody>
</table>
<blockquote>
<p>提示：在C++中可考虑更安全的<code>std::function</code>，但在C项目中函数指针仍是核心机制。</p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0022301572465277778" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-18 20:24">2025-05-18 20:24</span>&nbsp;
<a href="https://www.cnblogs.com/gfuran">复然</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18882579);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18882579', targetLink: 'https://www.cnblogs.com/gfuran/p/18882579', title: 'C语言函数指针解析' })">举报</a>
</div>
        