
	<div class="postTitle">
		<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Colin-Cai/p/18931900" title="发布于 2025-07-31 12:06">
    <span role="heading" aria-level="2">有限Abel群的结构(3)</span>
    

</a>

	</div>
	    <div id="cnblogs_post_description" style="display: none">
        
        本章给出产生给定阶数的所有Abel群的程序，主要是Python，附带有Scheme。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<div class="cnblogs_Highlighter">
<pre class="brush:sql;gutter:true;">　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址

　　 https://www.cnblogs.com/Colin-Cai/p/18931900.html

　　作者：窗户

　　QQ/微信：6679072

　　E-mail：6679072@qq.com</pre>
</div>
<p>本节在上一节的结论基础上，通过程序对于给定阶数生成该阶下所有可能的Abel群。</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt">有限Abel群结构定理</span></strong></p>
<p>我们再回忆一下有限Abel群的所有可能结构：</p>
<p>任何一个阶数大于1的有限Abel群都可以同构为数个阶数大于1的循环群的直积$Z_{a_1} \otimes Z_{a_2} \otimes ... \otimes Z_{a_n}$，并满足各循环群的阶数从左到右为约数关系，也就是$a_1|a_2|...|a_n$，另外$a_1,a_2,...,a_n$相乘等于原Abel群的阶数。</p>
<p>另外，</p>
<p>如果$a_1,a_2,...,a_n$都是大于1的整数，$b_1,b_2,...,b_m$也都是大于1的整数,</p>
<p>$a_1|a_2|...|a_n$，并且$b_1|b_2|...|b_m$，</p>
<p>那么$Z_{a_1} \otimes&nbsp;Z_{a_2} \otimes ... \otimes&nbsp;Z_{a_n} \cong Z_{b_1} \otimes&nbsp;Z_{b_2} \otimes ... \otimes&nbsp;Z_{b_m}$</p>
<p>的充要条件是</p>
<p>$m=n \land a_1=b_1 \land a_2=b_2 \land ... \land a_n = b_n$</p>
<p>也就是只要有一个循环群不同，两个Abel群就不同构。</p>
<p>比如$72$阶Abel群，总共有以下几个同构：</p>
<p>$Z_{72}$</p>
<p>$Z_2 \otimes Z_{36}$</p>
<p>$Z_3 \otimes Z_{24}$</p>
<p>$Z_6 \otimes Z_{12}$</p>
<p>$Z_2 \otimes Z_2 \otimes Z_{18}$</p>
<p>$Z_2 \otimes Z_6 \otimes Z_6$</p>
<p>以下，我们用程序实现，还是继续选择Python语言。</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt">生成器递归实现</span></strong></p>
<p>我们首先考虑生成器，我想程序员们大多对于此问题应该有递归的直觉。递归很多时候在于问题的分解。</p>
<p>Python的生成器其实是有点拗口的，它从语法上并非那么自然，使得像我这样有点语法洁癖的人，总觉得有点疙瘩。</p>
<p>比如如下代码：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> f(x):
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> x &lt;=<span style="color: rgba(0, 0, 0, 1)"> 0:
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> -<span style="color: rgba(0, 0, 0, 1)">x
    </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">:
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> i <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> range(x):
            </span><span style="color: rgba(0, 0, 255, 1)">yield</span><span style="color: rgba(0, 0, 0, 1)"> i
</span><span style="color: rgba(0, 0, 255, 1)">for</span> i <span style="color: rgba(0, 0, 255, 1)">in</span> f(10<span style="color: rgba(0, 0, 0, 1)">):
    </span><span style="color: rgba(0, 0, 255, 1)">print</span><span style="color: rgba(0, 0, 0, 1)">(i)
</span><span style="color: rgba(0, 0, 255, 1)">print</span>(f(-10))</pre>
</div>
<p>它最后对于f(-10)的返回居然是&lt;generator object f at 0x7f38ee923740&gt;</p>
<p>Python对其解释是，一日生成器终身生成器，也就是生成器和函数是不一样的东西。好吧，唐僧取经最后都有几卷经书晒在礁石上撕不下来，世间很难完美。</p>
<p>生成器中，部分流是从另外一个生成器中来的话，可以</p>
<p><span style="color: rgba(0, 0, 255, 1)">for i in generator2(args):</span></p>
<p><span style="color: rgba(0, 0, 255, 1)">&nbsp; &nbsp; yield i</span></p>
<p>不可以直接</p>
<p><span style="color: rgba(0, 0, 255, 1)">generator2(args)</span></p>
<p>因为如此，Python会当成只是执行了一个函数。比较简洁的写法是</p>
<p><span style="color: rgba(0, 0, 255, 1)">yield from generator2(args)</span></p>
<p>以上可以用于我们生成器的递归，而我们工作的核心在于如何分解任务。</p>
<p>其实，DC(分治)对一个问题可能有多种分解方式，这里我们就想一种最简单明了的。</p>
<p>打个比方，我们来求$180$的所有可能。</p>
<p>那么，它可以是单独的</p>
<p>$(180)$</p>
<p>也可能是</p>
<p>$(2 ...)$</p>
<p>也可能是</p>
<p>$(3 ...)$</p>
<p>也可能是</p>
<p>$(6 ...)$</p>
<p>注意，如果至少有两个数，那么后面至少会有一个数，而且必须是前面数的倍数，也就是说，第一个数的平方必须是整体的约数，</p>
<p>$2^2|180$</p>
<p>$3^2|180$</p>
<p>$6^2|180$</p>
<p>当然，我们不用考虑$1$(这种平凡的Abel群我们可以当特例直接排除)的分解，那么，既然要考虑递归，就要更一般的考虑下去</p>
<p>假如我们已经把数字$N$分解到</p>
<p>$(a_1,a_2...a_n,...)$</p>
<p>当然，其中</p>
<p>$a_1|a_2...|a_n$</p>
<p>假设能分解到这步，也就是后面至少还有一项是$a_n$的倍数，从而</p>
<p>$(\prod_{i=1}^{i\le n}{a_i})*a_n|N$</p>
<p>也就是</p>
<p>$(a_1,a_2...a_n,\frac{N}{\prod_{i=1}^{i\le n}{a_i}})$</p>
<p>是后面仅剩一项的情况</p>
<p>如果</p>
<p>$\exists a_{n+1}:a_n|a_{n+1} \land (\prod_{i=1}^{i\le n}{a_i})*a_{n+1}^2|N$</p>
<p>那，我们可以继续安插进下一项，这里找到的$a_{n+1}是合适的下一项，</p>
<p>$(a_1,a_2...a_n,a_{n+1}...)$</p>
<p>其实也就是，如果</p>
<p>$\exists m \in Z^+ : (m*a_n)^2|\frac{N}{\prod_{i=1}^{i\le n}{a_i}}$</p>
<p>&nbsp;那么是可以继续安插进下一项，</p>
<p>$(a_1,a_2...a_n,a_{n+1}...)$</p>
<p>于是，我们先给定生成器用来生成$(a_1,a_2...,a_n)$开头的所有的有效分解。</p>
<p>按照刚才的分析，生成器gen(remained, a)可以如下编写，其中这里的remained则是刚才的$\frac{N}{\prod_{i=1}^{i\le n}{a_i}}$</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> gen(remained, a):
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">自身是一个合理的分解</span>
    <span style="color: rgba(0, 0, 255, 1)">yield</span> a +<span style="color: rgba(0, 0, 0, 1)"> [remained]
    </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> a:
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">如果a里面有元素，那么挨个m*a[-1]遍历试除一下</span>
        x = a[-1<span style="color: rgba(0, 0, 0, 1)">]
        </span><span style="color: rgba(0, 0, 255, 1)">while</span> x * x &lt;=<span style="color: rgba(0, 0, 0, 1)"> remained:
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> remained % (x * x) ==<span style="color: rgba(0, 0, 0, 1)"> 0:
                </span><span style="color: rgba(0, 0, 255, 1)">yield</span> <span style="color: rgba(0, 0, 255, 1)">from</span> gen(remained // x, a +<span style="color: rgba(0, 0, 0, 1)"> [x])
            x </span>+= a[-1<span style="color: rgba(0, 0, 0, 1)">]
    </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">:
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">如果a是空列，那么挨个大于等于1的整数遍历试除一下</span>
        x = 2
        <span style="color: rgba(0, 0, 255, 1)">while</span> x * x &lt;=<span style="color: rgba(0, 0, 0, 1)"> remained:
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> remained % (x * x) ==<span style="color: rgba(0, 0, 0, 1)"> 0:
                </span><span style="color: rgba(0, 0, 255, 1)">yield</span> <span style="color: rgba(0, 0, 255, 1)">from</span> gen(remained // x, a +<span style="color: rgba(0, 0, 0, 1)"> [x])
            x </span>+= 1</pre>
</div>
<p>然后，最终的我们要的生成器，</p>
<div class="cnblogs_code">
<pre>gen_all_abel = <span style="color: rgba(0, 0, 255, 1)">lambda</span> N:gen(N,[])</pre>
</div>
<p>嗯，这里可以像函数一样，lambda也是支持生成器的。</p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt"><strong>因式分解</strong></span></p>
<p>考虑上面慢在哪里，找因子是依次这样试除找过来，如果我们一早知道因式分解，应该是可以提升效率的。</p>
<p>因式分解就采用最简单的试除如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> factor(N):
    ret </span>=<span style="color: rgba(0, 0, 0, 1)"> []
    n </span>= 2
    <span style="color: rgba(0, 0, 255, 1)">while</span> n * n &lt;=<span style="color: rgba(0, 0, 0, 1)"> N:
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> N % n ==<span style="color: rgba(0, 0, 0, 1)"> 0:
            k </span>=<span style="color: rgba(0, 0, 0, 1)"> 0
            </span><span style="color: rgba(0, 0, 255, 1)">while</span> N % n ==<span style="color: rgba(0, 0, 0, 1)"> 0:
                N </span>//=<span style="color: rgba(0, 0, 0, 1)"> n
                k </span>+= 1<span style="color: rgba(0, 0, 0, 1)">
            ret.append((n, k))
        n </span>+= 1
    <span style="color: rgba(0, 0, 255, 1)">if</span> N != 1<span style="color: rgba(0, 0, 0, 1)">:
        ret.append((N, </span>1<span style="color: rgba(0, 0, 0, 1)">))
    </span><span style="color: rgba(0, 0, 255, 1)">return</span> ret</pre>
</div>
<p>所用算法没啥大技巧，唯一要提的也就是和之前一样，合数一定有一个约数小于等于自己的平方根。</p>
<p>有了这个之后，前面的算法可以先因式分解，然后再不需要依次试除，此处省略优化后的实现，由读者自己去思考吧。</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18pt">迭代器字序列实现</span></strong></p>
<p>我们再来考虑迭代器序列的实现。</p>
<p>首先，我们意识到因式分解的好处，自然有很多计算基于因式分解。我们可以建立一个类来实现因式分解的运算。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Factor(object):
    </span><span style="color: rgba(0, 0, 255, 1)">def</span> <span style="color: rgba(128, 0, 128, 1)">__init__</span>(self, arg=<span style="color: rgba(0, 0, 0, 1)">[]):
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> isinstance(arg, list): <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">传入为因式分解list</span>
            self.factor_list =<span style="color: rgba(0, 0, 0, 1)"> arg
        </span><span style="color: rgba(0, 0, 255, 1)">elif</span> isinstance(arg, Factor): <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">传入为别的Factor对象，复制对象</span>
            self.factor_list = [i <span style="color: rgba(0, 0, 255, 1)">for</span> i <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> arg.factor_list]
        </span><span style="color: rgba(0, 0, 255, 1)">elif</span> isinstance(arg, int): <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">传入是数字</span>
<span style="color: rgba(0, 0, 0, 1)">            self._factor(arg)
    </span><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> _factor(self, n):
        self.factor_list </span>=<span style="color: rgba(0, 0, 0, 1)"> []
        x </span>= 2
        <span style="color: rgba(0, 0, 255, 1)">while</span> (x * x &lt;=<span style="color: rgba(0, 0, 0, 1)"> n):
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> n % x ==<span style="color: rgba(0, 0, 0, 1)"> 0:
                k </span>=<span style="color: rgba(0, 0, 0, 1)"> 0
                </span><span style="color: rgba(0, 0, 255, 1)">while</span> n % x ==<span style="color: rgba(0, 0, 0, 1)"> 0:
                    n </span>//=<span style="color: rgba(0, 0, 0, 1)"> x
                    k </span>+= 1<span style="color: rgba(0, 0, 0, 1)">
                self.factor_list.append((x, k))
            x </span>+= 1
        <span style="color: rgba(0, 0, 255, 1)">if</span> n != 1<span style="color: rgba(0, 0, 0, 1)">:
            self.factor_list.append((n, </span>1))</pre>
</div>
<p>上面Factor()不带参数时，实际上等同于Factor(1)。</p>
<p>再加入一些运算，包括转整数、乘法、乘方、除法、n次根等，而加、减法我们并不关心，毕竟对我们问题的解决没有任何帮助。另外，我们希望这些因式分解对象使用平常的Python运算符，比如乘法的*,乘方的**,除法的/，这样可以做到运算符的多态(polymorphic)，从而达到泛型(generic)。这一点在别的语言里也可以做到，比如C++我们可以为各个类型重载运算符、函数，再比如Haskell的typeclass也可以让各个类型使用相同的函数名、运算符。我们在这里使用Python，语言级别提供了自定义class对运算符的支持，那就是魔术方法(magic method)，也就是那些两个下划线开头两个下划线结尾的方法，比如__add__(用来重载加法)，__mul__(用来重载乘法)。我们把乘方和n次方根都用乘方符号(**)来表示，但浮点数一般并不能精确的反应分数，我们就采用Python自带的分数类(from fractions import Fraction)。</p>
<p>考虑一下开方运算，对于解题有帮助的开方运算定义如下:a开n次方意思是$max\{x|x \in Z^+ \land x^n|a\}$</p>
<p>比如$72$开$2$次方结果为$6$</p>
<p>在这样的定义下，我们重载__int__, __mul__, __truediv__, __power__以实现Factor对象的加法、乘法、除法、乘方</p>
<p>其中除法我们只考虑整除的情况，这些并不难实现，读者可以自行实现。</p>
<p>再者，我们自然得定义一下序列以便把所有的分解排成一个全序集。</p>
<p>比如，我们考虑$5400$的所有分解，如下：</p>
<p>$(5400)$<br>$(2&nbsp;\quad&nbsp;2700)$<br>$(3&nbsp;\quad&nbsp;1800)$<br>$(6 \quad&nbsp;900)$<br>$(5 \quad&nbsp;1080)$<br>$(10 \quad&nbsp;540)$<br>$(15 \quad&nbsp;360)$<br>$(30 \quad&nbsp;180)$<br>$(2 \quad&nbsp;2 \quad&nbsp;1350)$<br>$(2 \quad&nbsp;6 \quad&nbsp;450)$<br>$(2 \quad&nbsp;10 \quad&nbsp;270)$<br>$(2 \quad&nbsp;30 \quad&nbsp;90)$<br>$(3 \quad&nbsp;3 \quad&nbsp;600)$<br>$(3 \quad&nbsp;6 \quad&nbsp;300)$<br>$(3 \quad&nbsp;15 \quad&nbsp;120)$<br>$(3 \quad&nbsp;30 \quad&nbsp;60)$<br>$(6 \quad&nbsp;6 \quad&nbsp;150)$<br>$(6 \quad&nbsp;30 \quad&nbsp;30)$</p>
<p>考虑$5400$因式分解为$2^3\times 3^3 \times 5^2$</p>
<p>它有三个质因数$2,3,5$</p>
<p>将上面的每一行里的每个数都写为$2,3,5$的幂乘积(没有则填0次幂)，并且顺序为$5,3,2$这样从大到小，那么则为</p>
<p>$({5}^{2} \times {3}^{3} \times {2}^{3})$<br>$({5}^{0} \times {3}^{0} \times {2}^{1} \quad {5}^{2} \times {3}^{3} \times {2}^{2})$<br>$({5}^{0} \times {3}^{1} \times {2}^{0} \quad {5}^{2} \times {3}^{2} \times {2}^{3})$<br>$({5}^{0} \times {3}^{1} \times {2}^{1} \quad {5}^{2} \times {3}^{2} \times {2}^{2})$<br>$({5}^{1} \times {3}^{0} \times {2}^{0} \quad {5}^{1} \times {3}^{3} \times {2}^{3})$<br>$({5}^{1} \times {3}^{0} \times {2}^{1} \quad {5}^{1} \times {3}^{3} \times {2}^{2})$<br>$({5}^{1} \times {3}^{1} \times {2}^{0} \quad {5}^{1} \times {3}^{2} \times {2}^{3})$<br>$({5}^{1} \times {3}^{1} \times {2}^{1} \quad {5}^{1} \times {3}^{2} \times {2}^{2})$<br>$({5}^{0} \times {3}^{0} \times {2}^{1} \quad {5}^{0} \times {3}^{0} \times {2}^{1} \quad {5}^{2} \times {3}^{3} \times {2}^{1})$<br>$({5}^{0} \times {3}^{0} \times {2}^{1} \quad {5}^{0} \times {3}^{1} \times {2}^{1} \quad {5}^{2} \times {3}^{2} \times {2}^{1})$<br>$({5}^{0} \times {3}^{0} \times {2}^{1} \quad {5}^{1} \times {3}^{0} \times {2}^{1} \quad {5}^{1} \times {3}^{3} \times {2}^{1})$<br>$({5}^{0} \times {3}^{0} \times {2}^{1} \quad {5}^{1} \times {3}^{1} \times {2}^{1} \quad {5}^{1} \times {3}^{2} \times {2}^{1})$<br>$({5}^{0} \times {3}^{1} \times {2}^{0} \quad {5}^{0} \times {3}^{1} \times {2}^{0} \quad {5}^{2} \times {3}^{1} \times {2}^{3})$<br>$({5}^{0} \times {3}^{1} \times {2}^{0} \quad {5}^{0} \times {3}^{1} \times {2}^{1} \quad {5}^{2} \times {3}^{1} \times {2}^{2})$<br>$({5}^{0} \times {3}^{1} \times {2}^{0} \quad {5}^{1} \times {3}^{1} \times {2}^{0} \quad {5}^{1} \times {3}^{1} \times {2}^{3})$<br>$({5}^{0} \times {3}^{1} \times {2}^{0} \quad {5}^{1} \times {3}^{1} \times {2}^{1} \quad {5}^{1} \times {3}^{1} \times {2}^{2})$<br>$({5}^{0} \times {3}^{1} \times {2}^{1} \quad {5}^{0} \times {3}^{1} \times {2}^{1} \quad {5}^{2} \times {3}^{1} \times {2}^{1})$<br>$({5}^{0} \times {3}^{1} \times {2}^{1} \quad {5}^{1} \times {3}^{1} \times {2}^{1} \quad {5}^{1} \times {3}^{1} \times {2}^{1})$</p>
<p>取指数，则为以下的列</p>
<p>$2, 3, 3$<br>$0, 0, 1, 2, 3, 2$<br>$0, 1, 0, 2, 2, 3$<br>$0, 1, 1, 2, 2, 2$<br>$1, 0, 0, 1, 3, 3$<br>$1, 0, 1, 1, 3, 2$<br>$1, 1, 0, 1, 2, 3$<br>$1, 1, 1, 1, 2, 2$<br>$0, 0, 1, 0, 0, 1, 2, 3, 1$<br>$0, 0, 1, 0, 1, 1, 2, 2, 1$</p>
<p>$...$</p>
<p>这个顺序关系一目了然，是以指数序列大小的顺序排列的。</p>
<p>我们考虑用这个顺序来取出一个正整数所有的正约数，让Factor加入一个next函数，来取下一个约数。</p>
<p>于是以下代码遍历参数n的所有正约数:</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> traverse_all_divisors(n):
    a </span>=<span style="color: rgba(0, 0, 0, 1)"> Factor(n)
    b </span>=<span style="color: rgba(0, 0, 0, 1)"> Factor()
    </span><span style="color: rgba(0, 0, 255, 1)">print</span><span style="color: rgba(0, 0, 0, 1)">(int(b))
    </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">循环获得排序下的下一个约数直到不再有约数</span>
    <span style="color: rgba(0, 0, 255, 1)">while</span><span style="color: rgba(0, 0, 0, 1)"> a.next(b):
        </span><span style="color: rgba(0, 0, 255, 1)">print</span>(int(b))</pre>
</div>
<p><span style="color: rgba(0, 0, 0, 1)">比如，traverse_all_divisors(72)会依次打印72所有的正约数</span></p>
<p>1<br>2<br>4<br>8<br>3<br>6<br>12<br>24<br>9<br>18<br>36<br>72</p>
<p>以上来看并非数值从小到大，但是如果分解成指数的形式</p>
<p>1 [0, 0]<br>2 [0, 1]<br>4 [0, 2]<br>8 [0, 3]<br>3 [1, 0]<br>6 [1, 1]<br>12 [1, 2]<br>24 [1, 3]<br>9 [2, 0]<br>18 [2, 1]<br>36 [2, 2]<br>72 [2, 3]</p>
<p>上面则很容易看出其升序</p>
<p>Factor的next方法实现并不难，从低位往高位依次遍历，和数数一样的做法。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> next(self, s):
        len_self </span>=<span style="color: rgba(0, 0, 0, 1)"> len(self.factor_list)
        len_s </span>=<span style="color: rgba(0, 0, 0, 1)"> len(s.factor_list)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">用index_self和index_s作为下标来遍历</span>
        index_self =<span style="color: rgba(0, 0, 0, 1)"> 0
        index_s </span>=<span style="color: rgba(0, 0, 0, 1)"> 0
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">依次来比较self和s</span>
        <span style="color: rgba(0, 0, 255, 1)">while</span><span style="color: rgba(0, 0, 0, 1)"> True:
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> index_self &gt;=<span style="color: rgba(0, 0, 0, 1)"> len_self:
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> False
            xa, ya </span>=<span style="color: rgba(0, 0, 0, 1)"> self.factor_list[index_self]
            index_self </span>+= 1
            <span style="color: rgba(0, 0, 255, 1)">if</span> index_s &gt;=<span style="color: rgba(0, 0, 0, 1)"> len_s:
                s.factor_list </span>= [(xa, 1<span style="color: rgba(0, 0, 0, 1)">)]
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> True
            xb, yb </span>=<span style="color: rgba(0, 0, 0, 1)"> s.factor_list[index_s]
            index_s </span>+= 1
            <span style="color: rgba(0, 0, 255, 1)">if</span> xa != xb <span style="color: rgba(0, 0, 255, 1)">or</span> ya !=<span style="color: rgba(0, 0, 0, 1)"> yb:
                </span><span style="color: rgba(0, 0, 255, 1)">break</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span> xa !=<span style="color: rgba(0, 0, 0, 1)"> xb:
            s.factor_list </span>= [(xa, 1), (xb, yb)] +<span style="color: rgba(0, 0, 0, 1)"> s.factor_list[index_s:]
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> True
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">ya != yb</span>
        s.factor_list = [(xa, yb + 1)] +<span style="color: rgba(0, 0, 0, 1)"> s.factor_list[index_s:]
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> True</pre>
</div>
<p>Python没有do/while结构，上面的while True与最后if-break是模拟do/while的写法。</p>
<p>有了以上完整的Factor实现之后，我们就可以按照上述所说的顺序来依次生成所有的分解，串成一个迭代器。</p>
<p>Python对迭代器的实现其实很简单：迭代器是一个class，实现__iter__方法返回self，__next__方法每次调用返回下一个值，当没有下一个值则发出StopIteration异常。</p>
<p>按照上述所说，以下给出了gen_abel的构造函数，__iter__和__next__：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> gen_abel(object):
    </span><span style="color: rgba(0, 0, 255, 1)">def</span> <span style="color: rgba(128, 0, 128, 1)">__init__</span><span style="color: rgba(0, 0, 0, 1)">(self, n):
        self.whole_factor </span>=<span style="color: rgba(0, 0, 0, 1)"> Factor(n)
        self.next_value </span>=<span style="color: rgba(0, 0, 0, 1)"> [self.whole_factor]
    </span><span style="color: rgba(0, 0, 255, 1)">def</span> <span style="color: rgba(128, 0, 128, 1)">__iter__</span><span style="color: rgba(0, 0, 0, 1)">(self):
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> self
    </span><span style="color: rgba(0, 0, 255, 1)">def</span> <span style="color: rgba(128, 0, 128, 1)">__next__</span><span style="color: rgba(0, 0, 0, 1)">(self):
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> self.next_value:
            ret </span>=<span style="color: rgba(0, 0, 0, 1)"> list(map(int, self.next_value))
            self._next()
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> ret
        </span><span style="color: rgba(0, 0, 255, 1)">raise</span> StopIteration</pre>
</div>
<p>可以看到，保留两个属性，一个是whole_factor来表示n的因式分解，另一个next_value是下一次next所得到的结果，为了区分是否下一次next还有结果，则此处我们先约定没有下一次next结果则next_value为None。按照之前所说的顺序，长度为1的分解是排在最开始的，所以构造函数里给next_value的初值为 [self.whole_factor]。</p>
<p>接下去最后的任务就是实现这个_next函数了，它就是找whole_factor的下一个分解</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> _next(self):
        length </span>=<span style="color: rgba(0, 0, 0, 1)"> len(self.next_value)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">依次调整self.next_value[i:]的分解</span>
        <span style="color: rgba(0, 0, 255, 1)">for</span> i <span style="color: rgba(0, 0, 255, 1)">in</span> range(length - 2, -1, -1<span style="color: rgba(0, 0, 0, 1)">):
            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> self._try_next(length, i):
                </span><span style="color: rgba(0, 0, 255, 1)">return</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">只能分解长度加1</span>
        length += 1
        <span style="color: rgba(0, 0, 255, 1)">for</span> a, k <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> self.whole_factor.factor_list:
            </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">只需要找到第一个质数的幂不小于length的即可完成分解</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> k &gt;=<span style="color: rgba(0, 0, 0, 1)"> length:
                t </span>= Factor([(a, 1<span style="color: rgba(0, 0, 0, 1)">)])
                t2 </span>= self.whole_factor / Factor([(a, length - 1<span style="color: rgba(0, 0, 0, 1)">)])
                self.next_value </span>= [t] * (length - 1) +<span style="color: rgba(0, 0, 0, 1)"> [t2]
                </span><span style="color: rgba(0, 0, 255, 1)">return</span>
        <span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">实在没有了，则遍历完了所有分解，设置为None</span>
        self.next_value = None</pre>
</div>
<p>_try_next的实现</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 0, 255, 1)">def</span><span style="color: rgba(0, 0, 0, 1)"> _try_next(self, length, index):
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">把最后几项乘起来,尝试重新分配</span>
        t =<span style="color: rgba(0, 0, 0, 1)"> Factor()
        </span><span style="color: rgba(0, 0, 255, 1)">for</span> i <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> self.next_value[index:]:
            t </span>*=<span style="color: rgba(0, 0, 0, 1)"> i
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">r1是总共还可以分配的</span>
        r1 =<span style="color: rgba(0, 0, 0, 1)"> Factor(t)
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> index !=<span style="color: rgba(0, 0, 0, 1)"> 0:
            r1 </span>/= Factor(self.next_value[index - 1]) ** (length -<span style="color: rgba(0, 0, 0, 1)"> index)
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">这个时候就是开方运算了</span>
        r1 = r1 ** Fraction(1, length -<span style="color: rgba(0, 0, 0, 1)"> index)
        r2 </span>=<span style="color: rgba(0, 0, 0, 1)"> Factor(self.next_value[index])
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> index !=<span style="color: rgba(0, 0, 0, 1)"> 0:
            r2 </span>/= self.next_value[index - 1<span style="color: rgba(0, 0, 0, 1)">]
        </span><span style="color: rgba(0, 128, 0, 1)">#</span><span style="color: rgba(0, 128, 0, 1)">r2找个紧接着排序的值</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> r1.next(r2):
            ret </span>=<span style="color: rgba(0, 0, 0, 1)"> self.next_value[0:index]
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> index !=<span style="color: rgba(0, 0, 0, 1)"> 0:
                r2 </span>*= self.next_value[index - 1<span style="color: rgba(0, 0, 0, 1)">]
            </span><span style="color: rgba(0, 0, 255, 1)">for</span> j <span style="color: rgba(0, 0, 255, 1)">in</span> range(length - index - 1<span style="color: rgba(0, 0, 0, 1)">):
                ret.append(r2)
            ret.append(t </span>/ r2 ** (length - index - 1<span style="color: rgba(0, 0, 0, 1)">))
            self.next_value </span>=<span style="color: rgba(0, 0, 0, 1)"> ret
            </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> True
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> False</pre>
</div>
<p>&nbsp;</p>
<p><span style="font-size: 18pt"><strong>Scheme实现</strong></span></p>
<p>我钟爱的Lisp，怎么可以少得了它呢，以下链接是我写的实现代码。</p>
<p><a href="https://files.cnblogs.com/files/Colin-Cai/abel-scheme.tar.gz" target="_blank">&nbsp;Scheme实现</a></p>
<p>它用了Lisp的一种惰性计算模型——流(stream)，其实和Python的生成器/迭代器没啥本质上的区别。</p>
<p>三个实现包含着之前的两种Python实现，以及未写的基于因式分解提速的递归生成器同样算法。</p>
</div>
<div class="clear"></div>

	<div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-31 12:07">2025-07-31 12:06</span>&nbsp;
<a href="https://www.cnblogs.com/Colin-Cai">窗户</a>&nbsp;
阅读(<span id="post_view_count">110</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18931900);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18931900', targetLink: 'https://www.cnblogs.com/Colin-Cai/p/18931900', title: '有限Abel群的结构(3)' })">举报</a>
</div>
