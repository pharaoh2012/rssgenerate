
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ifmeme/p/19065186" title="发布于 2025-08-29 21:18">
    <span role="heading" aria-level="2">Mock 在 API 研发中的痛点、价值与进化及Apipost解决方案最佳实践</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p data-track="1">在日常 API 研发过程中，Mock 是一个几乎无法绕开的话题。无论是项目初期的快速迭代，还是接口尚未就绪的场景，Mock 都能帮助我们在「没有真实后端数据」的情况下，保障前端开发的连续性和效率。</p>
<p data-track="2"><strong>一、真实场景中的痛点</strong></p>
<p data-track="3">设想这样一个场景：</p>
<p data-track="4">你正在开发一个电商平台的前端页面，用户点击&nbsp;“立即支付”&nbsp;后，前端需要调用后端的支付接口&nbsp;/pay，返回类似这样的结果：</p>
<pre class="syl-page-code"><code class="hljs json">{
    <span class="hljs-attr">"data": {
        <span class="hljs-attr">"code": <span class="hljs-number">0,
        <span class="hljs-attr">"message": <span class="hljs-string">"success",
        <span class="hljs-attr">"pay_dtime":<span class="hljs-string">"2025-08-10 10:00:00",
        <span class="hljs-attr">"order_id":<span class="hljs-string">"sn12345678"
    }
}
</span></span></span></span></span></span></span></span></span></code></pre>
<p data-track="6">但是问题是：</p>
<ul>
<li data-track="7">后端接口还没开发完，你没办法调试支付成功后的页面逻辑；</li>
<li data-track="8">支付接口依赖外部网关，测试环境尚未配置好，接口无法返回结果；</li>
<li data-track="9">部分接口依赖复杂鉴权和数据准备，前期根本无法调用。</li>
</ul>
<p data-track="10">如果前端只能干等后端接口，就会直接导致开发进度被卡死。这时，Mock 就显得尤为重要。</p>
<p class="syl-page-br" data-track="11">&nbsp;</p>
<p data-track="12"><strong>二、常见Mock方案及其弊端</strong></p>
<p data-track="13">1. 本地 JSON 文件 Mock</p>
<p data-track="14">最简单的方法是写个本地mock/data.json，然后在接口请求时读取该文件：</p>
<pre class="syl-page-code"><code class="hljs less"><span class="hljs-selector-tag">fetch(<span class="hljs-string">'/mock/pay.json')
</span></span></code></pre>
<p data-track="16">问题：</p>
<ul>
<li data-track="17">数据固定，无法模拟不同场景；</li>
<li data-track="18">无法满足分页、条件查询等复杂逻辑。</li>
</ul>
<p data-track="19">2. 前端拦截请求（如&nbsp;axios-mock-adapter、Mock.js）</p>
<p data-track="20">通过拦截请求，在浏览器里返回 Mock 数据：</p>
<pre class="syl-page-code"><code class="hljs bash">mock.onPost(<span class="hljs-string">'/api/pay/confirm').reply(200, {
    <span class="hljs-string">"data": {
        <span class="hljs-string">"code": 0,
        <span class="hljs-string">"message": <span class="hljs-string">"success",
        <span class="hljs-string">"pay_dtime":<span class="hljs-string">"2025-08-10 10:00:00",
        <span class="hljs-string">"order_id":<span class="hljs-string">"sn12345678" 
    }
});
</span></span></span></span></span></span></span></span></span></code></pre>
<p data-track="22">问题：</p>
<ul>
<li data-track="23">只能在前端项目内使用，难以复用；</li>
<li data-track="24">数据写在代码里，后期清理和维护成本高。</li>
</ul>
<p data-track="25">3. 自建 Mock 服务（如&nbsp;json-server、Easy Mock）</p>
<p data-track="26">搭建独立 Mock 服务，前端请求时返回数据。问题：</p>
<ul>
<li data-track="27">搭建和维护成本高；</li>
<li data-track="28">复杂逻辑需要额外开发脚本，灵活度有限。</li>
</ul>
<p data-track="29">这些方案虽然解决了一部分问题，但随着项目复杂度增加，缺乏灵活性、无法动态生成数据&nbsp;的弊端会越来越突出。</p>
<p class="syl-page-br" data-track="30">&nbsp;</p>
<p data-track="31"><strong>三、Apipost 的 Mock 能力与实战场景</strong></p>
<p data-track="32">Apipost 在 Mock 方面提供了更加灵活的解决方案，既能覆盖前期快速开发，又能满足复杂场景的数据模拟需求。</p>
<p data-track="33">我们就以支付接口 /pay 为例，假如我们希望 Mock 一个API 返回如下几种场景。</p>
<h1 class="pgc-h-arrow-right" data-track="34">1. Mock能力第一重—模拟固定值返回</h1>
<p data-track="35">如果你要模拟一个固定的返回响应体。例如：</p>
<pre class="syl-page-code"><code class="hljs json">{
    <span class="hljs-attr">"data": {
        <span class="hljs-attr">"code": <span class="hljs-number">0,
        <span class="hljs-attr">"message": <span class="hljs-string">"success"
    }
}</span></span></span></span></span></code></pre>
<p data-track="37">我们在Apipost 中新建一个 API，请求方式取POST，URL为/pay ，然后在「设计」-「预定义响应期望」中通过可视化定义如下：</p>
<div class="pgc-img"><img class="syl-page-img lazyload" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-axegupay5k/5d0da058aee542278bb034940b38aebe~tplv-tt-origin-web:gif.jpeg?_iz=58558&amp;from=article.pc_detail&amp;lk3s=953192f4&amp;x-expires=1757077395&amp;x-signature=I7fLWM9cYYxmpxWHVmOYYfnHQcc%3D">
<p class="pgc-img-caption">&nbsp;</p>
</div>
<p data-track="38">接下来我们切换到 「Mock」标签，可以看到自动生成一个Mock URL&nbsp;，这个URL即为生成的 Mock 链接。</p>
<div class="pgc-img"><img class="syl-page-img lazyload" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/67f8832f49f44a5f8d12a56622717101~tplv-tt-origin-web:gif.jpeg?_iz=58558&amp;from=article.pc_detail&amp;lk3s=953192f4&amp;x-expires=1757077395&amp;x-signature=tWR28Nawro9V%2BuZg3P70w2xF8rg%3D">
<p class="pgc-img-caption">&nbsp;</p>
</div>
<p data-track="40">我们可以当这个链接作为真实的API请求地址，访问即可获得预期的返回结果：</p>
<div class="pgc-img"><img class="syl-page-img lazyload" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/69cf4a9cbe324b7caef085b87332f162~tplv-tt-origin-web:gif.jpeg?_iz=58558&amp;from=article.pc_detail&amp;lk3s=953192f4&amp;x-expires=1757077395&amp;x-signature=54%2B7ClgDVfMXpHY7iDwc%2FhFUMrE%3D">
<p class="pgc-img-caption">&nbsp;</p>
</div>
<h1 class="pgc-h-arrow-right" data-track="42">2. Mock能力第二重—利用内置函数生成随机值</h1>
<p data-track="43">假如我们返回的结果增加一些字段，而且某字段都是实时随机生成的，就像上面例子中，我们增加一个时间日期字段pay_dtime。Apipost 提供丰富的内置变量，可以快速生成不同类型的数据。例如：</p>
<pre class="syl-page-code"><code class="hljs json">{
    <span class="hljs-attr">"data": {
        <span class="hljs-attr">"code": <span class="hljs-number">0,
        <span class="hljs-attr">"message": <span class="hljs-string">"success",
        <span class="hljs-attr">"pay_dtime":<span class="hljs-string">"2025-08-10 10:00:00" <span class="hljs-comment">// 此字段需要每次变化，不用固定值
    }
}</span></span></span></span></span></span></span></span></code></pre>
<p data-track="45">我们只需新增一个字段，取值来源选择「Mock数据」，找到内置的日期变量插入使用即可。</p>
<div class="pgc-img"><img class="syl-page-img lazyload" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/1d6ba3d5b1034adb81d18ca5fe149e32~tplv-tt-origin-web:gif.jpeg?_iz=58558&amp;from=article.pc_detail&amp;lk3s=953192f4&amp;x-expires=1757077395&amp;x-signature=5jOgxaHfcOgpVHgma4CjX8ci7ww%3D">
<p class="pgc-img-caption">&nbsp;</p>
</div>
<p data-track="47">返回示例如下：</p>
<div class="pgc-img"><img class="syl-page-img lazyload" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/3f489be2090d478692ef8ad594cd9d34~tplv-tt-origin-web:gif.jpeg?_iz=58558&amp;from=article.pc_detail&amp;lk3s=953192f4&amp;x-expires=1757077395&amp;x-signature=3w7fGBBL9et6rYbRMulk8yuXC8w%3D">
<p class="pgc-img-caption">&nbsp;</p>
</div>
<p data-track="49">这样避免了本地 JSON 的固定数据问题，每次请求都能返回不同结果。</p>
<h1 class="pgc-h-arrow-right" data-track="50">3. Mock能力第三重—自定义函数</h1>
<p data-track="51">当内置变量不够时，可以利用自定义函数实现复杂逻辑。例如上述返回需要增加一个订单号字段order_id，且订单号字段的要求为以&nbsp;sn 开头+8位数字组成的字符串，此字段需要高度自定义。</p>
<pre class="syl-page-code"><code class="hljs json">{
    <span class="hljs-attr">"data": {
        <span class="hljs-attr">"code": <span class="hljs-number">0,
        <span class="hljs-attr">"message": <span class="hljs-string">"success",
        <span class="hljs-attr">"pay_dtime":<span class="hljs-string">"2025-08-10 10:00:00", <span class="hljs-comment">// 此字段需要每次变化，不用固定值
        <span class="hljs-attr">"order_id":<span class="hljs-string">"sn12345678" <span class="hljs-comment">// 此字段需要高度自定义
    }
}</span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p data-track="53">我们可以使用「自定义函数」，如图：</p>
<div class="pgc-img"><img class="syl-page-img lazyload" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/c95bb224ce624a83a48e75a6180dc253~tplv-tt-origin-web:gif.jpeg?_iz=58558&amp;from=article.pc_detail&amp;lk3s=953192f4&amp;x-expires=1757077395&amp;x-signature=wlN%2FHDNMj%2B7G62TAiBJFF2TU3RA%3D">
<p class="pgc-img-caption">&nbsp;</p>
</div>
<p data-track="55">新建一个函数fn_orderno，通过 Apipost内置的 AI 能力 或者手动编写一个订单号生成函数即可：</p>
<div class="pgc-img"><img class="syl-page-img lazyload" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7b73a41bac5944b8b0beb8fe64ea6257~tplv-tt-origin-web:gif.jpeg?_iz=58558&amp;from=article.pc_detail&amp;lk3s=953192f4&amp;x-expires=1757077395&amp;x-signature=y%2Bit0ti%2B%2F5EtB4yXTwCydw10mA4%3D">
<p class="pgc-img-caption">&nbsp;</p>
</div>
<div class="pgc-img"><img class="syl-page-img lazyload" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/9d81859b07d24ab59be20f9420a91d11~tplv-tt-origin-web:gif.jpeg?_iz=58558&amp;from=article.pc_detail&amp;lk3s=953192f4&amp;x-expires=1757077395&amp;x-signature=mXyIUHVUqtyXW8eCT8u4UXo%2FbRE%3D">
<p class="pgc-img-caption">&nbsp;</p>
</div>
<p data-track="58">返回示例如下：</p>
<div class="pgc-img"><img class="syl-page-img lazyload" data-src="https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/496b0fcdf5394827aa9f94b97894122e~tplv-tt-origin-web:gif.jpeg?_iz=58558&amp;from=article.pc_detail&amp;lk3s=953192f4&amp;x-expires=1757077395&amp;x-signature=Rijb1SPc%2FyU8s6teTQ8%2B5s5o4Jg%3D">
<p class="pgc-img-caption">&nbsp;</p>
</div>
<h1 class="pgc-h-arrow-right" data-track="60">4. Mock能力第四重—按请求参数返回不同响应</h1>
<p data-track="61">支付功能需要考虑&nbsp;支付成功、余额不足、账号锁定&nbsp;等情况。</p>
<p data-track="62">我们新建一个「余额不足」的期望，并设置相关返回的参数信息：</p>
<div class="pgc-img"><img class="syl-page-img lazyload" data-src="https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/5f5ac83e15124e0894cf1d27cd5b51b1~tplv-tt-origin-web:gif.jpeg?_iz=58558&amp;from=article.pc_detail&amp;lk3s=953192f4&amp;x-expires=1757077395&amp;x-signature=ku%2FBSBIxNiodaSXyE%2BMyDPhzmsE%3D">
<p class="pgc-img-caption">&nbsp;</p>
</div>
<div class="pgc-img"><img class="syl-page-img lazyload" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/ca8e18e43fcd4e21b8f0db0adc7a0f5c~tplv-tt-origin-web:gif.jpeg?_iz=58558&amp;from=article.pc_detail&amp;lk3s=953192f4&amp;x-expires=1757077395&amp;x-signature=VmmKvvbMHP%2FIOyn0RArLPJfRPk0%3D">
<p class="pgc-img-caption">&nbsp;</p>
</div>
<p data-track="65">返回示例如下：</p>
<div class="pgc-img"><img class="syl-page-img lazyload" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/11973dc2cb554a349930d3078f03bed0~tplv-tt-origin-web:gif.jpeg?_iz=58558&amp;from=article.pc_detail&amp;lk3s=953192f4&amp;x-expires=1757077395&amp;x-signature=TQzK3izUtYA13kfEC5OctaqhGvo%3D">
<p class="pgc-img-caption">&nbsp;</p>
</div>
<div class="pgc-img"><img class="syl-page-img lazyload" data-src="https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/8e6e97dcc4424ab1a385f9aeb8e53f4f~tplv-tt-origin-web:gif.jpeg?_iz=58558&amp;from=article.pc_detail&amp;lk3s=953192f4&amp;x-expires=1757077395&amp;x-signature=HxsSmk3Z4eVQhQG97d4YmyeeAKM%3D">
<p class="pgc-img-caption">&nbsp;</p>
</div>
<p data-track="68">这种方式比静态 JSON 更贴近真实业务，能帮助前端测试多种逻辑分支。</p>
<p class="syl-page-br" data-track="69">&nbsp;</p>
<p data-track="70"><strong>四、总结</strong></p>
<p data-track="72">Mock 在前端开发中并不是“可有可无”的工具，而是显著提升开发效率的核心能力。</p>
<p data-track="73">这意味着：</p>
<ul>
<li data-track="74">前端可以独立开发，不再依赖后端接口完成度；</li>
<li data-track="75">测试人员也能直接复用 Mock 链接，在接口未就绪时提前联调。</li>
</ul>
<p data-track="76">同时，Apipost 的 Mock 功能则提供了更现代化的方案：</p>
<ul>
<li data-track="77">内置变量：快速生成多样数据；</li>
<li data-track="78">自定义函数：支持复杂业务逻辑，并支持 AI 编写自定义函数；</li>
</ul>
<p data-track="79">在前端需要&nbsp;快速迭代、独立开发、模拟复杂场景&nbsp;时，Apipost 的 Mock 功能无疑是一个高效且专业的选择。</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-29 21:18">2025-08-29 21:18</span>&nbsp;
<a href="https://www.cnblogs.com/ifmeme">Codebill</a>&nbsp;
阅读(<span id="post_view_count">86</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19065186);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19065186', targetLink: 'https://www.cnblogs.com/ifmeme/p/19065186', title: 'Mock 在 API 研发中的痛点、价值与进化及Apipost解决方案最佳实践' })">举报</a>
</div>
        