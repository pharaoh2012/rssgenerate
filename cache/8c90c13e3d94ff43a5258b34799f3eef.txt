
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/naturl/p/18714920" title="发布于 2025-02-14 11:39">
    <span role="heading" aria-level="2">鸿蒙开发 - 数据持久化 Preferences (内存存储) (封装)</span>
    

</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>这篇文章介绍鸿蒙中的 <code>Preferences</code>，它是一种轻量级存储方式，数据存储在内存中，用于存储少量的数据。</p>
<p>可以执行 <code>flush()</code> 方法将内存中的数据写入到磁盘文件，保证下次重启后数据可以继续使用，下面会有介绍到</p>
<p><strong>主要特性：</strong></p>
<ul>
<li>数据存储形式：键值对，键的类型为字符串，值的存储数据类型包括数字型、字符型、布尔型以及这3种类型的数组类型 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-data-preferences-V5#valuetype" target="_blank" rel="noopener nofollow">点击查看</a></li>
<li>轻量级：Preferences主要用于存储少量的数据，不适合用来存储大量的数据集。所有数据会被加载到内存中，过多的数据可能导致内存占用过高</li>
<li>快速访问：由于数据被缓存在内存中，因此读取速度非常快</li>
<li>同步与异步操作：提供了同步和异步两种方式来处理数据的读写操作</li>
</ul>
<h2 id="初始化-preferences-实例">初始化 Preferences 实例</h2>
<pre><code class="language-TypeScript">import { preferences } from '@kit.ArkData'
import { BusinessError } from '@kit.BasicServicesKit'

@Entry
@Component
struct Index {
  dataPreferences: preferences.Preferences | null = null
  
  aboutToAppear(): void {
    let options: preferences.Options = { name: 'myStore' }
    this.dataPreferences = preferences.getPreferencesSync(getContext(this), options)
  }
}
</code></pre>
<ul>
<li><code>preferences.getPreferencesSync(context: Context, options: Options)</code> 获取 Preferences 实例</li>
<li><code>Options: { name: string }</code> 指定 Preferences 实例的名称</li>
</ul>
<h2 id="操作数据的方法以下都是异步写法下面会有同步写法">操作数据的方法（以下都是异步写法，下面会有同步写法）</h2>
<h4 id="写入数据-put">写入数据 put</h4>
<p>将数据写入缓存中</p>
<p><strong>示例代码：</strong></p>
<pre><code class="language-TypeScript">build() {
  Column() {
    Button('登录')
      .onClick(async () =&gt; {
        this.dataPreferences?.put('name', '诡术妖姬', (err: BusinessError) =&gt; {
          if (err) {
            console.error(`写入数据失败：code=${err.code}，message=${err.message}`)
            return
          }
          console.log('写入数据成功')
        })
      }
  }
}
</code></pre>
<p>当我们写入数据的时候，如果不需要关注回调通知，可以忽略掉，如下：</p>
<pre><code class="language-typescript">this.dataPreferences?.put('name', '诡术妖姬')
</code></pre>
<h4 id="获取数据-get">获取数据 get</h4>
<p>从缓存中获取键对应的值</p>
<p><code>get</code> 方法中第一个参数是Key，第二个参数是默认值，如果获取的数据为null或者非默认值类型就会返回默认值</p>
<p><strong>示例代码：</strong></p>
<pre><code class="language-typescript">this.dataPreferences?.get('name', '默认值', (err: BusinessError, val: preferences.ValueType) =&gt; {
  if (err) {
    console.error(`获取数据失败： code=${err.code}, message=${err.message}`)
    return
  }
  console.log(`获取数据成功： val=${val}`)
})
</code></pre>
<h4 id="获取所有数据-getall">获取所有数据 getAll</h4>
<p>从缓存中获取所有的键值数据</p>
<p><strong>示例代码：</strong></p>
<pre><code class="language-typescript">this.dataPreferences?.getAll((err: BusinessError, val: preferences.ValueType) =&gt; {
  console.log('获取所有数据：', JSON.stringify(val)) // 获取所有数据： {"name1":"武器","name2":"杰斯","name3":"酒桶"}
})
</code></pre>
<h4 id="检查是否存在-has">检查是否存在 has</h4>
<p>检查是否存在指定Key的键值数据，返回值是 <code>boolean</code></p>
<p><strong>示例代码：</strong></p>
<pre><code class="language-typescript">this.dataPreferences?.has('name', (err: BusinessError, flag: boolean) =&gt; {
  if (err) {
    console.error(`检查失败： code=${err.code}, message=${err.message}`)
    return
  }
  console.log('检查的key值是否存在：', flag) // true
})

this.dataPreferences?.has('name22222', (err: BusinessError, flag: boolean) =&gt; {
  if (err) {
    console.error(`检查失败：code=${err.code}, message=${err.message}`)
    return
  }
  console.log('检查的key值是否存在：', flag) // false
})
</code></pre>
<h4 id="删除数据-delete">删除数据 delete</h4>
<p>删除指定key的键值数据</p>
<p><strong>示例代码：</strong></p>
<pre><code class="language-typescript">this.dataPreferences?.delete('name', (err: BusinessError) =&gt; {
  if (err) {
    console.error(`删除失败： code=${err.code}, message=${err.message}`)
    return
  }
  console.log('删除成功')
})
</code></pre>
<h4 id="删除所有数据-clear">删除所有数据 clear</h4>
<p>删除缓存中的所有数据</p>
<p><strong>示例代码：</strong></p>
<pre><code class="language-typescript">this.dataPreferences?.clear((err: BusinessError) =&gt; {
  if (err) {
    console.error(`删除所有数据失败： code=${err.code}, message=${err.message}`)
  }
  console.log('删除所有数据成功')
})
</code></pre>
<h4 id="将缓存数据同步到磁盘文件-flush">将缓存数据同步到磁盘文件 flush</h4>
<p><strong>作用：</strong> <code>flush</code> 主要用于将内存的更改同步到磁盘文件中。当操作了数据（例如添加、更新、删除）后，这些更改首先会保存在内存中。调用<br>
<code>flush</code> 会将这些更改写入到磁盘中，从而确保数据在应用程序重启或设备重启后仍然可用。</p>
<p><strong>示例代码：</strong></p>
<pre><code class="language-typescript">this.dataPreferences?.flush((err: BusinessError) =&gt; {
  if (err) {
    console.log(`Failed to flush：code=${err.code}，message：${err.message}}`)
    return
  }
  console.log('Succeeded in flush')
})
</code></pre>
<p>如果不执行 flush() 方法，可能会有以下影响：</p>
<ol>
<li>数据丢失风险：如果应用程序在数据同步到持久化存储之前崩溃或被强制终止，那么内存中的更改可能会丢失。这意味着用户的数据可能无法被正确保存。</li>
<li>数据不一致性：在某些情况下，如果没有及时调用 flush()，可能会导致数据在不同时间点读取时出现不一致的情况。例如，一个进程可能已经更新了数据但尚未同步，而另一个进程读取的仍然是旧数据。</li>
<li>性能考虑：虽然 flush() 方法可以确保数据持久化，但频繁调用它可能会影响性能。因此，开发者通常会在合适的时间点（如用户明确保存操作或应用程序即将退出时）调用 flush()。 最佳实践</li>
</ol>
<p>为了确保数据的完整性和一致性，开发者应该遵循以下最佳实践：</p>
<ul>
<li>在关键数据修改后，及时调用 flush() 方法。</li>
<li>考虑在应用程序的生命周期事件中（如 onPause() 或 onDestroy()）调用 flush()，以确保在应用程序退出前数据被正确保存。</li>
<li>避免在性能敏感的操作中频繁调用 flush()，而是根据实际需求选择合适的时间点进行同步。</li>
</ul>
<p>总之，虽然不调用 flush() 方法在某些情况下可能不会立即导致问题，但为了确保数据的可靠性和持久性，开发者应该养成良好的习惯，在适当的时候调用 flush() 方法。</p>
<h2 id="另外一种异步写法">另外一种异步写法</h2>
<p>上面方法示例代码都是用的 <strong>callback异步回调</strong> 这种方式，除了这种，还有另外一种方式 <strong>Promise异步回调</strong>，如下：</p>
<pre><code class="language-typescript">let promise = this.dataPreferences?.get('name', '默认值',)
promise?.then((val: preferences.ValueType) =&gt; {
  console.log(`获取数据成功： val=${val}`)
}).catch((err: BusinessError) =&gt; {
  console.error(`获取数据失败： code=${err.code}, message=${err.message}`)
})
</code></pre>
<p>如果不愿意使用<code>Promise</code>链式回调，也可以使用<strong>async/await</strong>：</p>
<pre><code class="language-typescript">let res = await this.dataPreferences?.get('name', '默认值',)
console.log('获取数据：', res)
</code></pre>
<h2 id="同步写法">同步写法</h2>
<p>上面方法除了 <code>flush</code> 没有同步写法，其他方法都有同步写法，比如：</p>
<ul>
<li>get</li>
</ul>
<pre><code class="language-typescript">let value = dataPreferences?.getSync('name', '默认值')
</code></pre>
<ul>
<li>put</li>
</ul>
<pre><code class="language-typescript">let value = dataPreferences?.putSync('name', '小鲁班')
</code></pre>
<h2 id="监听数据变更">监听数据变更</h2>
<h4 id="监听所有key的数据变更">监听所有key的数据变更</h4>
<p>监听所有key，其中一个键值发生变化，就会触发回调。<strong>（只有在执行flush方法后，才会触发callback回调）</strong></p>
<p><strong>语法：</strong> <code>on(type: 'change', callback: Callback&lt;string&gt;): void</code></p>
<p><strong>示例代码：</strong></p>
<pre><code class="language-TypeScript">@Entry
@Component
struct Index {
  aboutToAppear(): void {
    let observer = (key: string) =&gt; {
      console.log('发生数据变更的key：', key) // 发生数据变更的key：name,诡术妖姬
    }
    this.dataPreferences.on('change', observer)
  }
  
  build() {
    Column() {
      Button('按钮')
        .onClick(() =&gt; {
          this.dataPreferences?.delete('name', (err: BusinessError) =&gt; {
            if (err) {
              console.error(`删除失败： code=${err.code}, message=${err.message}`)
              return
            }
            console.log('删除成功')
          })
          this.dataPreferences?.flush()
        })
    }
  }
}
</code></pre>
<h4 id="监听指定key的数据变更">监听指定key的数据变更</h4>
<p>可以传入一个数组，指定一部分key进行监听</p>
<p><strong>语法：</strong> <code>on(type: 'dataChange', keys: Array&lt;string&gt;, callback: Callback&lt;Record&lt;string, ValueType&gt;&gt;): void</code></p>
<p><strong>示例代码：</strong></p>
<pre><code class="language-TypeScript">let keys = ['name', 'age']
let observer = (data: Record&lt;string, preferences.ValueType&gt;) =&gt; {
  for (const keyValue of Object.entries(data)) {
    console.info(`observer : ${keyValue}`)
  }
  console.info("The observer called.") 
}
this.dataPreferences.on('dataChange', keys, observer);
</code></pre>
<h4 id="监听进程间的数据变更">监听进程间的数据变更</h4>
<p>监听进程间数据变更，多个进程持有同一个首选项文件时，在任意一个进程（包括本进程）执行flush方法，持久化文件发生变更后，触发callback回调。</p>
<p><strong>语法：</strong> <code>on(type: 'multiProcessChange', callback: Callback&lt;string&gt;): void</code></p>
<p><strong>示例代码：</strong></p>
<pre><code class="language-TypeScript">let observer = (key: string) =&gt; {
  console.log('发生数据变更的key：', key)
}
this.dataPreferences?.on('multiProcessChange', observer)
</code></pre>
<h4 id="取消监听">取消监听</h4>
<p><strong>语法：</strong> <code>off(type: 'change', callback?: Callback&lt;string&gt;): void</code></p>
<p>如果需要取消指定的回调函数，就需要填写callback，不填写则全部取消。</p>
<p><strong>示例代码：</strong> <code>dataPreferences.off('change', observer);</code></p>
<p><code>multiProcessChange</code> 和 <code>dataChange</code> 同理</p>
<h2 id="preferences使用的约束限制">Preferences使用的约束限制</h2>
<ul>
<li>首选项无法保证进程并发安全，会有文件损坏和数据丢失的风险，不支持在多进程场景下使用</li>
<li>Key键为string类型，要求非空且长度不超过1024个字节</li>
<li>如果Value值为string类型，请使用UTF-8编码格式，可以为空，不为空时长度不超过16 * 1024 * 1024个字节</li>
<li>内存会随着存储数据量的增大而增大，所以存储的数据量应该是轻量级的，建议存储的数据不超过一万条，否则会在内存方面产生较大的开销</li>
</ul>
<h2 id="封装">封装</h2>
<p>做一个简单的封装玩玩，没有经历过多的测试</p>
<ul>
<li>封装一个 PreferencesUtil 类</li>
</ul>
<pre><code class="language-TypeScript">import { preferences } from '@kit.ArkData'
import { BusinessError } from '@kit.BasicServicesKit'

class PreferenceUtil {
  private _preferences?: preferences.Preferences
  private context?: Context
  private fileName?: string

  constructor(t?: Context, fileName: string = 'myStore') {
    this.context = t || getContext(this)
    this.fileName = fileName
    this.init()
  }

  init() {
    if (this._preferences) {
      this._preferences = preferences.getPreferencesSync(this.context, { name: this.fileName })
    }
  }

  get(key: string): Promise&lt;preferences.ValueType&gt; {
    return new Promise(resolve =&gt; {
      this._preferences?.get(key, '', (err: BusinessError, val: preferences.ValueType) =&gt; {
        resolve(val)
      })
    })
  }

  getSync(key: string): Promise&lt;preferences.ValueType | undefined&gt; {
    return new Promise(resolve =&gt; {
      resolve(this._preferences?.getSync(key, ''))
    })
  }

  put(key: string, value: preferences.ValueType) {
    this._preferences?.put(key, value, (err: BusinessError) =&gt; {
      if (err) {
        console.error(`写入数据失败：code=${err.code}，message=${err.message}`)
        return
      }
      console.log('写入数据成功')
      this.flush()
    })
  }

  putSync(key: string, value: preferences.ValueType) {
      this._preferences?.putSync(key, value)
      this.flush()
  }

  delete(key: string) {
    this._preferences?.delete(key, (err: BusinessError) =&gt; {
      if (err) {
        console.error(`删除失败： code=${err.code}, message=${err.message}`)
        return
      }
      console.log('删除成功')
      this.flush()
    })
  }

  deleteSync(key: string) {
    this._preferences?.deleteSync(key)
    this.flush()
  }

  clear() {
    this._preferences?.clear((err: BusinessError) =&gt; {
      if (err) {
        console.error(`清空所有数据失败： code=${err.code}, message=${err.message}`)
      }
      console.log('清空所有数据成功')
      this.flush()
    })
  }

  clearSync() {
    this._preferences?.clearSync()
    this.flush()
  }

  has(key: string): Promise&lt;boolean&gt; {
    return new Promise(resolve =&gt; {
      this._preferences?.has(key, (err: BusinessError, flag: boolean) =&gt; {
        if (err) {
          console.error(`检查失败： code=${err.code}, message=${err.message}`)
          return
        }
        resolve(flag)
        console.log('检查的key值是否存在：', flag) // true
      })
    })
  }

  hasSync(key: string): Promise&lt;boolean | undefined&gt; {
    return new Promise(resolve =&gt; {
      resolve(this._preferences?.hasSync(key))
    })
  }

  flush() {
    this._preferences?.flush((err: BusinessError) =&gt; {
      if (err) {
        console.log(`Failed to flush：code=${err.code}，message：${err.message}}`)
        return
      }
      console.log('Succeeded in flush')
    })
  }
}

export default PreferenceUtil 
</code></pre>
<ul>
<li>组件内使用</li>
</ul>
<pre><code class="language-TypeScript">import PreferenceUtil from './storage'

@Entry
@Component
struct Index {
  preferences?: PreferencesUtil
  
  async aboutToAppear(): Promise&lt;void&gt;{
    this.preferenceUtil = new PreferenceUtil()
    console.log('Get name', await this.preferenceUtil?.get('name')) 
  }
}
</code></pre>
<h2 id="问题">问题</h2>
<h4 id="数据不一致问题">数据不一致问题</h4>
<p><a href="https://developer.huawei.com/consumer/cn/doc/architecture-guides/develop-data-12-0000002124619656" target="_blank" rel="noopener nofollow">点这里查看</a></p>
<h2 id="最后">最后</h2>
<p>如果大家有不理解的地方可以留言，或自行阅读文档 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-data-preferences-V5#%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener nofollow">文档地址</a></p>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：<a href="https://www.cnblogs.com/naturl/" target="_blank">时光凉忆</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/naturl/p/18714920" target="_blank">https://www.cnblogs.com/naturl/p/18714920</a></p>
</div>
<div class="clear"></div>

		</div>
		<div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.026389907412037037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-14 11:39">2025-02-14 11:39</span>&nbsp;
<a href="https://www.cnblogs.com/naturl">时光凉忆</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18714920" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18714920);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18714920', targetLink: 'https://www.cnblogs.com/naturl/p/18714920', title: '鸿蒙开发 - 数据持久化 Preferences (内存存储) (封装)' })">举报</a>
</div>
	