
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/XuYueming/p/18656288" title="发布于 2025-01-09 12:59">
    <span role="heading" aria-level="2">一种调试 线段树 / Treap / Splay / 左偏树 / LCT 等树形结构的技巧</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>如果我们需要观察程序运行过程中，某一个变量、某一个序列的变化情况，你可以在修改的地方打断点 debug，或者直接在需要的地方输出就行了。</p>
<p>但是对于一些树形结构，我们不好将其直观地呈现出来，常常只是输出每一个结点的值，但是这就丢失了结点之间的连边情况。有时候不得不手动画图。</p>
<p>所以我们经常累死。</p>
<p>于是，为了让我们活着，我想到了一种轻量级的，在终端直观呈现树形结构的方法。</p>
<h2 id="正文">正文</h2>
<h3 id="经典例子">经典例子</h3>
<p>回顾如下场景：</p>
<ul>
<li>Windows 下命令行中，我们使用 <code>tree</code> 来观察目录结构。</li>
</ul>
<p>比如，在某一目录下，使用 <code>tree /A /F</code> 的输出如下：</p>
<pre><code class="language-plaintext">+---.vscode
|       launch.json
|
+---blog-prettier
|       LICENSE
|       README.md
|
+---web server
|   |   checkstatues.log
|   |   client.html
|   |   data.txt
|   |   gen-key.py
|   |   main_service.log
|   |   script-obfsed.js
|   |   test.html
|   |
|   \---fetch-new-url
|       |   README.md
|       |
|       \---docs
|               test
|
\---test
        a.html
        b.html
        index.html
        script.js
        style.css
</code></pre>
<p>这种经典的方法显然可以运用到我们的调试中。</p>
<h3 id="分析">分析</h3>
<h4 id="二叉树">二叉树</h4>
<p>我们不妨来考虑简单的二叉树，例如线段树、Treap、Splay 等平衡树。</p>
<p>我们考虑一种最简单的递归过程，仅在参数中传递输出的前缀。简单码出以下代码：</p>
<pre><code class="language-cpp">void output(int x, string pre) {
    cout &lt;&lt; pre &lt;&lt; "-" &lt;&lt; x &lt;&lt; ": " &lt;&lt; tr[x].val &lt;&lt; endl;
    if (!x) return;
    output(tr[x].son[1], pre + "   |");
    output(tr[x].son[0], pre + "   |");
}

void output() {
    output(root, "&gt;");
}
</code></pre>
<p>这里先输出再 <code>return</code> 是为了让输出的二叉树更好看，不然遇到一个孩子不知道是左儿子还是右儿子。</p>
<p>将右儿子作为第一个儿子输出，是为了符合二叉查找树。</p>
<details>
<summary>可能的输出：一棵不断插入的 Splay</summary>
<pre><code class="language-plaintext">&gt;-1: 1
&gt;   |-0: 0
&gt;   |-0: 0
&gt;-2: 1
&gt;   |-1: 1
&gt;   |   |-0: 0
&gt;   |   |-0: 0
&gt;   |-0: 0
&gt;-3: 4
&gt;   |-0: 0
&gt;   |-1: 1
&gt;   |   |-0: 0
&gt;   |   |-2: 1
&gt;   |   |   |-0: 0
&gt;   |   |   |-0: 0
&gt;-4: 5
&gt;   |-0: 0
&gt;   |-3: 4
&gt;   |   |-0: 0
&gt;   |   |-1: 1
&gt;   |   |   |-0: 0
&gt;   |   |   |-2: 1
&gt;   |   |   |   |-0: 0
&gt;   |   |   |   |-0: 0
&gt;-5: 1
&gt;   |-3: 4
&gt;   |   |-4: 5
&gt;   |   |   |-0: 0
&gt;   |   |   |-0: 0
&gt;   |   |-2: 1
&gt;   |   |   |-1: 1
&gt;   |   |   |   |-0: 0
&gt;   |   |   |   |-0: 0
&gt;   |   |   |-0: 0
&gt;   |-0: 0
&gt;-6: 4
&gt;   |-3: 4
&gt;   |   |-4: 5
&gt;   |   |   |-0: 0
&gt;   |   |   |-0: 0
&gt;   |   |-0: 0
&gt;   |-5: 1
&gt;   |   |-1: 1
&gt;   |   |   |-0: 0
&gt;   |   |   |-2: 1
&gt;   |   |   |   |-0: 0
&gt;   |   |   |   |-0: 0
&gt;   |   |-0: 0
</code></pre>
</details>
<p>这对于考场上调试来说已经足够了，仅需将头逆时针旋转 <span class="math inline">\(45^\circ\)</span> 就能看到一棵完美的二叉树了。你可以在每个结点之后输出更多的信息。</p>
<p>但是，我们怎样达到更完美的效果呢，比如第二个孩子之前不输出树杈、第二个孩子后输出空行（多个第二个孩子仅输出一个空行）等等。</p>
<p>我们仅需多记录是否是第一个孩子即可。</p>
<pre><code class="language-cpp">void output(int x, string pre, bool firstSon) {
    cout &lt;&lt; pre &lt;&lt; (firstSon ? "+" : "\\") &lt;&lt; "---" &lt;&lt; x &lt;&lt; ": " &lt;&lt; tr[x].val &lt;&lt; endl;
    if (!x) return;
    pre += firstSon ? "|" : " ";
    output(tr[x].son[1], pre + "   ", true);
    output(tr[x].son[0], pre + "   ", false);
    if (firstSon) cout &lt;&lt; pre &lt;&lt; endl;
}

void output() {
    output(root, "", false);
}
</code></pre>
<p>效果见文末。</p>
<h4 id="多叉树">多叉树</h4>
<p>多叉树就只能是 LCT 了吧，还有什么扭曲的树你必须要打印出来的？</p>
<p>虽然好像打印出来还是不方便调试……</p>
<p>我们加以改进，由于有了虚实链之分，我们在空节点不直接 <code>return</code>，而是输出一条边。然后把是否是第一个孩子，变成是否是最后一个孩子。</p>
<p>代码：</p>
<pre><code class="language-cpp">vector&lt;int&gt; edge[N];

void output(int x, string pre, bool lastSon, bool real) {
    cout &lt;&lt; pre &lt;&lt; (!lastSon ? "+" : "\\") &lt;&lt; "---";
    if (x) cout &lt;&lt; x &lt;&lt; ": " &lt;&lt; tr[x].val &lt;&lt; endl;
    else cout &lt;&lt; "null" &lt;&lt; endl;
    pre += !lastSon ? (real ? "|" : "`") : " ";
    if (x &amp;&amp; (tr[x].son[0] || tr[x].son[1] || edge[x].size())) {
        pushdown(x);
        output(tr[x].son[1], pre + "   ", false, true);
        output(tr[x].son[0], pre + "   ", edge[x].empty(), false);
        for (int y : edge[x])
            output(y, pre + "   ", y == edge[x].back(), false);
    }
    if (!lastSon) cout &lt;&lt; pre &lt;&lt; endl;
}

void output(int n) {
    for (int i = 1; i &lt;= n; ++i)
        edge[i].clear();
    for (int i = 1; i &lt;= n; ++i)
        if (isRoot(i))
            edge[tr[i].fa].emplace_back(i);
    cout &lt;&lt; "==== LCT forest ====" &lt;&lt; endl;
    for (int i = 1; i &lt;= n; ++i)
        if (!tr[i].fa)
            output(i, "", true, false);
    cout &lt;&lt; "====================" &lt;&lt; endl;
}
</code></pre>
<p>效果见文末。</p>
<h3 id="代码">代码</h3>
<details codes="" open="">
<summary>二叉树</summary>
<pre><code class="language-cpp">void output(int x, string pre, bool firstSon) {
    cout &lt;&lt; pre &lt;&lt; (firstSon ? "+" : "\\") &lt;&lt; "---" &lt;&lt; x &lt;&lt; ": " &lt;&lt; tr[x].val &lt;&lt; endl;
    if (!x) return;
    pre += firstSon ? "|" : " ";
    output(tr[x].son[1], pre + "   ", true);
    output(tr[x].son[0], pre + "   ", false);
    if (firstSon) cout &lt;&lt; pre &lt;&lt; endl;
}

void output() {
    output(root, "", false);
}
</code></pre>
</details>
<details codes="" open="">
<summary>多叉树 LCT</summary>
<pre><code class="language-cpp">vector&lt;int&gt; edge[N];

void output(int x, string pre, bool lastSon, bool real) {
    cout &lt;&lt; pre &lt;&lt; (!lastSon ? "+" : "\\") &lt;&lt; "---";
    if (x) cout &lt;&lt; x &lt;&lt; ": " &lt;&lt; tr[x].val &lt;&lt; endl;
    else cout &lt;&lt; "null" &lt;&lt; endl;
    pre += !lastSon ? (real ? "|" : "`") : " ";
    if (x &amp;&amp; (tr[x].son[0] || tr[x].son[1] || edge[x].size())) {
        pushdown(x);
        output(tr[x].son[1], pre + "   ", false, true);
        output(tr[x].son[0], pre + "   ", edge[x].empty(), false);
        for (int y : edge[x])
            output(y, pre + "   ", y == edge[x].back(), false);
    }
    if (!lastSon) cout &lt;&lt; pre &lt;&lt; endl;
}

void output(int n) {
    for (int i = 1; i &lt;= n; ++i)
        edge[i].clear();
    for (int i = 1; i &lt;= n; ++i)
        if (isRoot(i))
            edge[tr[i].fa].emplace_back(i);
    cout &lt;&lt; "==== LCT forest ====" &lt;&lt; endl;
    for (int i = 1; i &lt;= n; ++i)
        if (!tr[i].fa)
            output(i, "", true, false);
    cout &lt;&lt; "====================" &lt;&lt; endl;
}
</code></pre>
</details>
<h3 id="输出效果">输出效果</h3>
<details>
<summary>可能的输出：一棵不断插入的 Splay</summary>
<pre><code class="language-plaintext">\---1: 1
    +---0: 0
    \---0: 0
\---2: 1
    +---1: 1
    |   +---0: 0
    |   \---0: 0
    |
    \---0: 0
\---3: 4
    +---0: 0
    \---1: 1
        +---0: 0
        \---2: 1
            +---0: 0
            \---0: 0
\---4: 5
    +---0: 0
    \---3: 4
        +---0: 0
        \---1: 1
            +---0: 0
            \---2: 1
                +---0: 0
                \---0: 0
\---5: 1
    +---3: 4
    |   +---4: 5
    |   |   +---0: 0
    |   |   \---0: 0
    |   |
    |   \---2: 1
    |       +---1: 1
    |       |   +---0: 0
    |       |   \---0: 0
    |       |
    |       \---0: 0
    |
    \---0: 0
\---6: 4
    +---3: 4
    |   +---4: 5
    |   |   +---0: 0
    |   |   \---0: 0
    |   |
    |   \---0: 0
    |
    \---5: 1
        +---1: 1
        |   +---0: 0
        |   \---2: 1
        |       +---0: 0
        |       \---0: 0
        |
        \---0: 0
</code></pre>
</details>
<details>
<summary>可能的输出：一棵带有左右边界的不断插入的 Treap</summary>
<pre><code class="language-plaintext">\---2: inf
    +---0: 0
    \---1: -inf
        +---3: 1
        |   +---0: 0
        |   \---0: 0
        |
        \---0: 0
\---2: inf
    +---0: 0
    \---1: -inf
        +---3: 1
        |   +---0: 0
        |   \---0: 0
        |
        \---0: 0
\---2: inf
    +---0: 0
    \---1: -inf
        +---3: 1
        |   +---4: 4
        |   |   +---0: 0
        |   |   \---0: 0
        |   |
        |   \---0: 0
        |
        \---0: 0
\---2: inf
    +---0: 0
    \---1: -inf
        +---3: 1
        |   +---5: 5
        |   |   +---0: 0
        |   |   \---4: 4
        |   |       +---0: 0
        |   |       \---0: 0
        |   |
        |   \---0: 0
        |
        \---0: 0
\---2: inf
    +---0: 0
    \---1: -inf
        +---3: 1
        |   +---5: 5
        |   |   +---0: 0
        |   |   \---4: 4
        |   |       +---0: 0
        |   |       \---0: 0
        |   |
        |   \---0: 0
        |
        \---0: 0
\---2: inf
    +---0: 0
    \---1: -inf
        +---3: 1
        |   +---5: 5
        |   |   +---0: 0
        |   |   \---4: 4
        |   |       +---0: 0
        |   |       \---0: 0
        |   |
        |   \---0: 0
        |
        \---0: 0
</code></pre>
</details>
<details>
<summary>可能的输出：一棵不断插入的无旋 Treap</summary>
<pre><code class="language-plaintext">\---1: 1
    +---0: 0
    \---0: 0
\---1: 1
    +---0: 0
    \---2: 1
        +---0: 0
        \---0: 0
\---3: 4
    +---0: 0
    \---1: 1
        +---0: 0
        \---2: 1
            +---0: 0
            \---0: 0
\---3: 4
    +---4: 5
    |   +---0: 0
    |   \---0: 0
    |
    \---1: 1
        +---0: 0
        \---2: 1
            +---0: 0
            \---0: 0
\---5: 1
    +---3: 4
    |   +---4: 5
    |   |   +---0: 0
    |   |   \---0: 0
    |   |
    |   \---1: 1
    |       +---0: 0
    |       \---2: 1
    |           +---0: 0
    |           \---0: 0
    |
    \---0: 0
\---5: 1
    +---6: 4
    |   +---3: 4
    |   |   +---4: 5
    |   |   |   +---0: 0
    |   |   |   \---0: 0
    |   |   |
    |   |   \---0: 0
    |   |
    |   \---1: 1
    |       +---0: 0
    |       \---2: 1
    |           +---0: 0
    |           \---0: 0
    |
    \---0: 0
</code></pre>
</details>
<details>
<summary>可能的输出：一棵动态开点线段树</summary>
<pre><code class="language-plaintext">\---[1, 5]: 1
    +---[1, 3]: 0
    \---[4, 5]: 1
        +---[4, 4]: 0
        \---[5, 5]: 1
\---[1, 5]: 6
    +---[1, 3]: 0
    \---[4, 5]: 6
        +---[4, 4]: 0
        \---[5, 5]: 6
\---[1, 5]: 10
    +---[1, 3]: 0
    \---[4, 5]: 10
        +---[4, 4]: 4
        \---[5, 5]: 6
\---[1, 5]: 12
    +---[1, 3]: 2
    |   +---[1, 2]: 0
    |   \---[3, 3]: 2
    |
    \---[4, 5]: 10
        +---[4, 4]: 4
        \---[5, 5]: 6
\---[1, 5]: 15
    +---[1, 3]: 5
    |   +---[1, 2]: 3 (with lazy = 3)
    |   |   +---[1, 1]: 0
    |   |   \---[2, 2]: 0
    |   |
    |   \---[3, 3]: 2
    |
    \---[4, 5]: 10
        +---[4, 4]: 4
        \---[5, 5]: 6
\---[1, 5]: 15
    +---[1, 3]: 5
    |   +---[1, 2]: 3 (with lazy = 3)
    |   |   +---[1, 1]: 0
    |   |   \---[2, 2]: 0
    |   |
    |   \---[3, 3]: 2
    |
    \---[4, 5]: 10
        +---[4, 4]: 4
        \---[5, 5]: 6
\---[1, 5]: 19
    +---[1, 3]: 5
    |   +---[1, 2]: 3 (with lazy = 3)
    |   |   +---[1, 1]: 0
    |   |   \---[2, 2]: 0
    |   |
    |   \---[3, 3]: 2
    |
    \---[4, 5]: 14
        +---[4, 4]: 6
        \---[5, 5]: 8
\---[1, 5]: 19
    +---[1, 3]: 5
    |   +---[1, 2]: 3 (with lazy = 3)
    |   |   +---[1, 1]: 0
    |   |   \---[2, 2]: 0
    |   |
    |   \---[3, 3]: 2
    |
    \---[4, 5]: 14
        +---[4, 4]: 6
        \---[5, 5]: 8
\---[1, 5]: 24 (with lazy = 1)
    +---[1, 3]: 5
    |   +---[1, 2]: 3 (with lazy = 3)
    |   |   +---[1, 1]: 0
    |   |   \---[2, 2]: 0
    |   |
    |   \---[3, 3]: 2
    |
    \---[4, 5]: 14
        +---[4, 4]: 6
        \---[5, 5]: 8
\---[1, 5]: 24 (with lazy = 1)
    +---[1, 3]: 5
    |   +---[1, 2]: 3 (with lazy = 3)
    |   |   +---[1, 1]: 0
    |   |   \---[2, 2]: 0
    |   |
    |   \---[3, 3]: 2
    |
    \---[4, 5]: 14
        +---[4, 4]: 6
        \---[5, 5]: 8
</code></pre>
</details>
<details>
<summary>可能的输出：一棵树状数组</summary>
<p>这玩意你还要调试？</p>
</details>
<details>
<summary>可能的输出：左偏树森林</summary>
<pre><code class="language-plaintext">==== 左偏树 1 ====
\---5: &lt;4, 2&gt;
    +---3: &lt;4, 3&gt;
    |   +---4: &lt;5, 2&gt;
    |   |   +---0: &lt;0, 0&gt;
    |   |   \---7: &lt;9, 4&gt;
    |   |       +---0: &lt;0, 0&gt;
    |   |       \---0: &lt;0, 0&gt;
    |   |
    |   \---0: &lt;0, 0&gt;
    |
    \---0: &lt;0, 0&gt;

==== 左偏树 2 ====
\---1: &lt;3, 3&gt;
    +---6: &lt;8, 4&gt;
    |   +---0: &lt;0, 0&gt;
    |   \---2: &lt;9, 3&gt;
    |       +---0: &lt;0, 0&gt;
    |       \---0: &lt;0, 0&gt;
    |
    \---0: &lt;0, 0&gt;

==== 左偏树 1 ====
\---5: &lt;4, 2&gt;
    +---3: &lt;4, 3&gt;
    |   +---4: &lt;5, 2&gt;
    |   |   +---0: &lt;0, 0&gt;
    |   |   \---7: &lt;9, 4&gt;
    |   |       +---0: &lt;0, 0&gt;
    |   |       \---0: &lt;0, 0&gt;
    |   |
    |   \---0: &lt;0, 0&gt;
    |
    \---1: &lt;5, 3&gt;
        +---6: &lt;8, 4&gt;
        |   +---0: &lt;0, 0&gt;
        |   \---2: &lt;9, 3&gt;
        |       +---0: &lt;0, 0&gt;
        |       \---0: &lt;0, 0&gt;
        |
        \---0: &lt;0, 0&gt;

==== 左偏树 1 ====
\---3: &lt;4, 3&gt;
    +---4: &lt;5, 2&gt;
    |   +---0: &lt;0, 0&gt;
    |   \---7: &lt;9, 4&gt;
    |       +---0: &lt;0, 0&gt;
    |       \---0: &lt;0, 0&gt;
    |
    \---1: &lt;5, 3&gt;
        +---6: &lt;8, 4&gt;
        |   +---0: &lt;0, 0&gt;
        |   \---2: &lt;9, 3&gt;
        |       +---0: &lt;0, 0&gt;
        |       \---0: &lt;0, 0&gt;
        |
        \---0: &lt;0, 0&gt;

==== 左偏树 1 ====
\---4: &lt;5, 2&gt;
    +---1: &lt;5, 3&gt;
    |   +---6: &lt;10, 4&gt;
    |   |   +---0: &lt;0, 0&gt;
    |   |   \---2: &lt;9, 3&gt;
    |   |       +---0: &lt;0, 0&gt;
    |   |       \---0: &lt;0, 0&gt;
    |   |
    |   \---7: &lt;11, 4&gt;
    |       +---0: &lt;0, 0&gt;
    |       \---0: &lt;0, 0&gt;
    |
    \---0: &lt;0, 0&gt;

==== 左偏树 1 ====
\---1: &lt;5, 3&gt;
    +---6: &lt;10, 4&gt;
    |   +---0: &lt;0, 0&gt;
    |   \---2: &lt;9, 3&gt;
    |       +---0: &lt;0, 0&gt;
    |       \---0: &lt;0, 0&gt;
    |
    \---7: &lt;11, 4&gt;
        +---0: &lt;0, 0&gt;
        \---0: &lt;0, 0&gt;

==== 左偏树 1 ====
\---6: &lt;10, 4&gt;
    +---2: &lt;11, 3&gt;
    |   +---0: &lt;0, 0&gt;
    |   \---7: &lt;11, 4&gt;
    |       +---0: &lt;0, 0&gt;
    |       \---0: &lt;0, 0&gt;
    |
    \---0: &lt;0, 0&gt;

==== 左偏树 1 ====
\---2: &lt;11, 3&gt;
    +---0: &lt;0, 0&gt;
    \---7: &lt;11, 4&gt;
        +---0: &lt;0, 0&gt;
        \---0: &lt;0, 0&gt;

==== 左偏树 1 ====
\---7: &lt;11, 4&gt;
    +---0: &lt;0, 0&gt;
    \---0: &lt;0, 0&gt;

==== 左偏树 1 ====
\---0: &lt;0, 0&gt;
</code></pre>
</details>
<details>
<summary>可能的输出：Link Cut Tree</summary>
<pre><code class="language-plaintext">==== LCT forest ====
\---1: 114
\---2: 514
\---3: 19
\---4: 19
\---5: 810
====================

link 1 and 2 success

==== LCT forest ====
\---2: 514
    +---null
    |
    +---null
    `
    \---1: 114
\---3: 19
\---4: 19
\---5: 810
====================

cut 1 and 2 success

==== LCT forest ====
\---1: 114
\---2: 514
\---3: 19
\---4: 19
\---5: 810
====================

link 1 and 2 success

==== LCT forest ====
\---2: 514
    +---null
    |
    +---null
    `
    \---1: 114
\---3: 19
\---4: 19
\---5: 810
====================

link 2 and 3 success

==== LCT forest ====
\---3: 19
    +---null
    |
    +---null
    `
    \---2: 514
        +---null
        |
        +---null
        `
        \---1: 114
\---4: 19
\---5: 810
====================

cut 1 and 3 failed

==== LCT forest ====
\---1: 114
    +---2: 514
    |   +---3: 19
    |   |
    |   \---null
    |
    \---null
\---4: 19
\---5: 810
====================

link 1 and 3 failed

==== LCT forest ====
\---1: 114
    +---3: 19
    |   +---null
    |   |
    |   \---2: 514
    |
    \---null
\---4: 19
\---5: 810
====================

link 4 and 5 success

==== LCT forest ====
\---1: 114
    +---3: 19
    |   +---null
    |   |
    |   \---2: 514
    |
    \---null
\---5: 810
    +---null
    |
    +---null
    `
    \---4: 19
====================

link 2 and 5 success

==== LCT forest ====
\---5: 810
    +---null
    |
    +---null
    `
    +---2: 514
    `   +---1: 114
    `   |
    `   +---null
    `   `
    `   \---3: 19
    `
    \---4: 19
====================

modify value 5 to 233333 success

==== LCT forest ====
\---5: 233333
    +---null
    |
    +---null
    `
    +---2: 514
    `   +---1: 114
    `   |
    `   +---null
    `   `
    `   \---3: 19
    `
    \---4: 19
====================

access 3 success

==== LCT forest ====
\---5: 233333
    +---2: 514
    |   +---3: 19
    |   |
    |   +---null
    |   `
    |   \---1: 114
    |
    +---null
    `
    \---4: 19
====================

split 2 ~ 4 success

==== LCT forest ====
\---4: 19
    +---null
    |
    \---5: 233333
        +---null
        |
        \---2: 514
            +---null
            |
            +---null
            `
            +---1: 114
            `
            \---3: 19
====================

split 2 ~ 5 success

==== LCT forest ====
\---5: 233333
    +---null
    |
    +---2: 514
    `   +---null
    `   |
    `   +---null
    `   `
    `   +---1: 114
    `   `
    `   \---3: 19
    `
    \---4: 19
====================
</code></pre>
</details>
</div>
<div id="MySignature" role="contentinfo">
    <p>
  本文作者：<a href="https://www.cnblogs.com/XuYueming/" target="_blank">XuYueming</a>，转载请注明原文链接：<a href="https://www.cnblogs.com/XuYueming/p/18656288" target="_blank">https://www.cnblogs.com/XuYueming/p/18656288</a>。
</p>

<p>
  若未作特殊说明，本作品采用
  <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="license">
    知识共享署名-非商业性使用 4.0 国际许可协议
  </a>
  进行许可。
</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5550270630451389" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-09 13:01">2025-01-09 12:59</span>&nbsp;
<a href="https://www.cnblogs.com/XuYueming">XuYueming</a>&nbsp;
阅读(<span id="post_view_count">101</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18656288" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18656288);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18656288', targetLink: 'https://www.cnblogs.com/XuYueming/p/18656288', title: '一种调试 线段树 / Treap / Splay / 左偏树 / LCT 等树形结构的技巧' })">举报</a>
</div>
        