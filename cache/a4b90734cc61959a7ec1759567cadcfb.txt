
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hunterxiong/p/19014225" title="发布于 2025-07-30 22:10">
    <span role="heading" aria-level="2">Golang基础笔记十六之反射</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<blockquote>
<p>本文首发于公众号：Hunter后端</p>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/HvO4dogdcfzzyF8nq3IruQ" target="_blank" rel="noopener nofollow">Golang基础笔记十六之反射</a></p>
</blockquote>
<p>反射可以用于程序在运行时检查、修改自身类型和值，主要通过 <code>reflect</code> 包实现。</p>
<p>首先，我们提出一个需求，要打印出一个结构体 struct 的各个字段及其对应的标签数据，按照当前的笔记内容是无法解决该问题的，但是我们可以使用反射操作来完成。</p>
<p>以下是本篇笔记目录：</p>
<ol>
<li>变量的类型和值</li>
<li>修改变量的值</li>
<li>遍历结构体字段</li>
<li>动态调用函数</li>
</ol>
<h3 id="1变量的类型和值">1、变量的类型和值</h3>
<p>先引入 reflect 模块：</p>
<pre><code class="language-go">import (
    "reflect"
)
</code></pre>
<p>我们可以通过 reflect.TypeOf() 获取变量的类型：</p>
<pre><code class="language-go">var x float64 = 3.5

t := reflect.TypeOf(x)
</code></pre>
<p>返回的 t 是 <code>Type</code>  接口，我们可以进一步调用 t 的方法来获取类型信息：</p>
<pre><code class="language-go">// 变量的类型名称：
fmt.Println("x 的类型名称是: ", t.Name())

// 判断类型的类别：
fmt.Println("x 的类型是否是 float64: ", t.Kind() == reflect.Float64)
</code></pre>
<p>获取变量的值信息：</p>
<pre><code class="language-go">v := reflect.ValueOf(x)
fmt.Println("value: ", v.Float() == 3.5)
</code></pre>
<h3 id="2修改变量的值">2、修改变量的值</h3>
<p>如果要修改这个变量的值，我们需要用到指针，以下是操作示例：</p>
<pre><code class="language-go">var x float64 = 3.5

// 这里获取的是变量的地址的值，如果直接 reflect.ValueOf(x) 获取的是 x 的副本
p := reflect.ValueOf(&amp;x)

// Elem() 方法获取指针指向的实际值，是解引用的操作
v := p.Elem()

// 重新赋值的操作
v.SetFloat(4.9)
fmt.Println("new value: ", x)
</code></pre>
<h3 id="3遍历结构体字段">3、遍历结构体字段</h3>
<p>我们先定义一个结构体如下：</p>
<pre><code class="language-go">type Person struct {
	Id   int    `json:"id" form:"id"`
	Name string `json:"name"`
}
</code></pre>
<p>打印一个 Person 示例各个字段的名称及其值的操作如下：</p>
<pre><code class="language-go">p := Person{
    Id:   1,
    Name: "hunter",
}
t := reflect.TypeOf(p)
v := reflect.ValueOf(p)

for i := 0; i &lt; t.NumField(); i++ {
    field := t.Field(i)
    value := v.Field(i)

    fmt.Printf("field_name:%s, field_type:%s, value:%v\n", field.Name, field.Type, value.Interface())
}
</code></pre>
<p>在这里，我们通过 <code>t.NumField()</code> 方法获取到 p 的字段个数，并使用 <code>t.Field(i)</code> 和 <code>v.Field(i)</code> 获取到对应字段类型和值。</p>
<p>接着对于每个 field 和 value，我们可以打印出对应的字段名称，字段类型和值。</p>
<p>我们还可以使用 field.Tag.Get() 的方式获取到字段标签的值：</p>
<pre><code class="language-go">fmt.Printf("json_tag:%s, form_tag:%s\n", field.Tag.Get("json"), field.Tag.Get("form"))
</code></pre>
<p>如果后续我们介绍 Golang 的 validator 模块，可以了解到，validator 就是通过 struct 定义的标签使用反射来对字段值进行验证的。</p>
<h3 id="4动态调用函数">4、动态调用函数</h3>
<p>我们还可以使用反射来动态调用函数，比如某个函数如下：</p>
<pre><code class="language-go">func Add(a, b int) int {
    return a + b
}
</code></pre>
<p>使用反射动态调用的操作如下：</p>
<pre><code class="language-go">func main() {
    targetFunc := reflect.ValueOf(Add)

    args := []reflect.Value{reflect.ValueOf(2), reflect.ValueOf(5)}

    result := targetFunc.Call(args)
    fmt.Println("动态调用 Add 函数，result: ", result[0].Int())
}
</code></pre>
<p><strong>注意</strong>：虽然反射可以为我们提供一些便利的操作，但是代码的可读性和可维护性会降低，且会降低性能，需要在实际生产中谨慎使用。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-30 22:10">2025-07-30 22:10</span>&nbsp;
<a href="https://www.cnblogs.com/hunterxiong">XHunter</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19014225);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19014225', targetLink: 'https://www.cnblogs.com/hunterxiong/p/19014225', title: 'Golang基础笔记十六之反射' })">举报</a>
</div>
        