
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/eanojiang/p/18859717" title="发布于 2025-05-05 02:22">
    <span role="heading" aria-level="2">查找</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        Hello算法——查找
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="顺序查找">顺序查找</h1>
<h2 id="概念">概念</h2>
<p>暴力穷举，从头遍历，用if 将当前值与带查找值进行比较。</p>
<h2 id="时间复杂度">时间复杂度</h2>
<p>查找成功的平均长度ASL</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022056101-1353194628.png" alt="1746265867411" loading="lazy"></p>
<p>如果每个查找每个值的概率相等，pi = 1/n，那么 <strong>ASL = (n+1) / 2</strong></p>
<p>所以时间复杂度为O(n)</p>
<h2 id="代码实现">代码实现</h2>
<blockquote>
<p>实例：</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022056831-971818466.png" alt="1746266106626" loading="lazy"></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void search(char *arr, int length, int key) {
    for(int i = 0; i &lt; length; i++) {
        if(arr[i] == key) {
            printf("%d found at index %d\n", key, i);
            return;
        }
    }
    printf("%d not found\n", key);
}

int main(){
    char arr[] = {8,12,5,16,55,24,20,18,36,6,50};
    search(arr,sizeof(arr)/sizeof(arr[0]), 55);
    return 0;
}
</code></pre>
<h1 id="折半查找二分查找">折半查找(二分查找)</h1>
<blockquote>
<p>问题引入：给定一个长度为 n 的数组 <code>nums</code> ，元素按从小到大的顺序排列且不重复,请查找并返回元素 <code>target</code> 在该数组中的索引。若数组不包含该元素，则返回 −1 。</p>
</blockquote>
<h2 id="概念-1"><strong>概念</strong></h2>
<p><strong>必须是已经排好序的有序数组</strong>，每次和中间的元素比较，如果比中间元素小，就在前半部分查找；否则在后半部分查找。</p>
<h2 id="步骤">步骤：</h2>
<ol>
<li>
<p>初始化 i=0 和 j=n−1 ，分别指向数组首元素和尾元素，代表搜索区间 [0,n−1]</p>
</li>
<li>
<p>while( i &lt;= j )</p>
<ol>
<li>
<p>计算中点索引 m=⌊(i+j)/2⌋ ，其中 ⌊⌋ 表示向下取整操作。</p>
</li>
<li>
<p>判断 <code>nums[m]</code> 和 <code>target</code> 的大小关系，分为以下三种情况。</p>
<ol>
<li>当 <code>nums[m] &lt; target</code> 时，说明 <code>target</code> 在区间 [m+1,j] 中，因此执行 i=m+1 。</li>
<li>当 <code>nums[m] &gt; target</code> 时，说明 <code>target</code> 在区间 [i,m−1] 中，因此执行 j=m−1 。</li>
<li>else 当 <code>nums[m] = target</code> 时，说明找到 <code>target</code> ，因此返回索引 m 。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>若数组不包含目标元素，搜索区间最终会缩小为空。也就是循环结束还没有返回m，那么此时返回 −1 。</p>
</li>
</ol>
<p><strong>可视化过程</strong>(具体可看<a href="https://www.hello-algo.com/chapter_searching/binary_search/#__tabbed_1_7" target="_blank" rel="noopener nofollow">《Hello算法》二分查找</a>)：</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022057536-962136712.png" alt="1746285642861" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022058306-1008454088.png" alt="1746285674950" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022059022-1545797454.png" alt="1746285696699" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022059626-1011498825.png" alt="1746285709636" loading="lazy"></p>
<blockquote>
<p>值得注意的是，由于 i 和 j 都是 <code>int</code> 类型， <strong>因此 i+j 可能会超出 <code>int</code> 类型的取值范围</strong> 。为了避免大数越界，我们通常采用公式 m=⌊i+(j−i)/2⌋ 来计算中点。</p>
</blockquote>
<h2 id="代码实现-1">代码实现</h2>
<blockquote>
<p>实例：</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022100222-1865296713.png" alt="1746286647925" loading="lazy"></p>
<h3 id="非递归实现">非递归实现：</h3>
<pre><code class="language-c">int binarySearch(int *arr, int length, int target) {
    //初始化左右边界
    int i = 0, j = length - 1, mid;
    //区间[i,j]存在
    while(i &lt;= j){
        mid = i + (j - i) / 2;
        //目标在右半部分，也就是[mid+1,j]
        if(arr[mid] &lt; target){
            i = mid+1;
        }
        //目标在左半部分，也就是[i,mid-1]
        else if(arr[mid] &gt; target){
            j = mid-1;
        }
        //找到目标元素,arr[mid] == target
        else{
            return mid;
        }
    }
    //没找到目标元素
    return -1;
}
</code></pre>
<h3 id="递归实现">递归实现：</h3>
<pre><code class="language-c">int binarySearch_Recursive(int *arr, int target, int low, int high) {
    //递归结束条件  
    if(low &gt; high) return -1;
    int mid = low + (high - low) / 2;

    //目标在右半部分，也就是[mid+1,high]
    if(arr[mid] &lt; target){
        return binarySearch_Recursive(arr, target, mid+1, high);
    }
    //目标在左半部分，也就是[low,mid-1]
    else if(arr[mid] &gt; target){
        return binarySearch_Recursive(arr, target, low, mid-1);
    }
    //找到目标元素,arr[mid] == target
    else{
        return mid;
    }
}
</code></pre>
<h2 id="二分查找的优缺点">二分查找的优缺点</h2>
<blockquote>
<p>下面直接照搬了<a href="https://www.hello-algo.com/chapter_searching/binary_search/#1011" target="_blank" rel="noopener nofollow">《Hello算法》二分查找</a> 的总结：</p>
</blockquote>
<p>二分查找在时间和空间方面都有较好的性能。</p>
<ul>
<li>二分查找的时间效率高。在大数据量下，对数阶的时间复杂度具有显著优势。例如，当数据大小 n=220 时，线性查找需要 220=1048576 轮循环，而二分查找仅需 log2⁡220=20 轮循环。</li>
<li>二分查找无须额外空间。相较于需要借助额外空间的搜索算法（例如哈希查找），二分查找更加节省空间。</li>
</ul>
<p>然而，二分查找并非适用于所有情况，主要有以下原因。</p>
<ul>
<li>二分查找仅适用于有序数据。若输入数据无序，为了使用二分查找而专门进行排序，得不偿失。因为排序算法的时间复杂度通常为 O(nlog⁡n) ，比线性查找和二分查找都更高。对于频繁插入元素的场景，为保持数组有序性，需要将元素插入到特定位置，时间复杂度为 O(n) ，也是非常昂贵的。</li>
<li>二分查找仅适用于数组。二分查找需要跳跃式（非连续地）访问元素，而在链表中执行跳跃式访问的效率较低，因此不适合应用在链表或基于链表实现的数据结构。</li>
<li>小数据量下，线性查找性能更佳。在线性查找中，每轮只需 1 次判断操作；而在二分查找中，需要 1 次加法、1 次除法、1 ~ 3 次判断操作、1 次加法（减法），共 4 ~ 6 个单元操作；因此，当数据量 n 较小时，线性查找反而比二分查找更快。</li>
</ul>
<h1 id="二叉树查找">二叉树查找</h1>
<h2 id="二叉排序树">二叉排序树</h2>
<p><strong>左 &lt; 根 &lt; 右，除非左右子树是空</strong></p>
<ol>
<li>如果左子树非空，那么就要满足： 左子树上所有结点的值 &lt; 根结点的值</li>
<li>如果右子树非空，那么就要满足： 右子树上所有结点的值 &gt; 根结点的值</li>
<li>左右子树本身各自也是一颗二叉排序树</li>
</ol>
<blockquote>
<p>举例</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022100969-595934786.png" alt="1746368353762" loading="lazy"></p>
<p>第二个图不是二叉排序树</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022101689-797694185.png" alt="1746370487626" loading="lazy"></p>
<p>中序遍历：3 12 24 37 45 53 61 78 90 100</p>
<blockquote>
<p>二叉排序树的特性：<strong>中序遍历二叉排序树，可以得到key的递增有序序列</strong></p>
</blockquote>
<h2 id="二叉排序树的查找">二叉排序树的查找</h2>
<p>左 &lt; 根 &lt; 右</p>
<ol>
<li>key == 根结点 ，返回</li>
<li>否则：
<ol>
<li>key &lt; 根结点，去这个结点的左子树找</li>
<li>key &gt; 根结点，去这个结点的右子树找</li>
</ol>
</li>
</ol>
<p>比较的是key和T-&gt;data.key (根结点的key)</p>
<h3 id="代码实现-2">代码实现</h3>
<p>递归实现：</p>
<pre><code class="language-c">BSTree SearchBST(BSTree T,KeyType key) 
{
   if((!T) || key==T-&gt;data.key) 
	return T;       	 
   else if (key&lt;T-&gt;data.key)  
	return SearchBST(T-&gt;lchild,key);	//在左子树中继续查找
   else 
	return SearchBST(T-&gt;rchild,key);  	//在右子树中继续查找  		   
}

</code></pre>
<p>非递归实现：</p>
<pre><code class="language-c">TreeNode *search(BinarySearchTree *bst, int num) {
    TreeNode *cur = bst-&gt;root;
    // 循环查找，越过叶节点后跳出
    while (cur != NULL) {
        if (cur-&gt;val &lt; num) {
            // 目标节点在 cur 的右子树中
            cur = cur-&gt;right;
        } else if (cur-&gt;val &gt; num) {
            // 目标节点在 cur 的左子树中
            cur = cur-&gt;left;
        } else {
            // 找到目标节点，跳出循环
            break;
        }
    }
    // 返回目标节点
    return cur;
}
</code></pre>
<h2 id="二叉排序树的插入">二叉排序树的插入</h2>
<ul>
<li>树中已有，不再插入</li>
<li>树中没有，查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子</li>
</ul>
<blockquote>
<p>插入的元素一定在叶结点上</p>
</blockquote>
<p>举例说明：插入20</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022102433-164066228.png" alt="1746374993719" loading="lazy"></p>
<h3 id="代码实现-3">代码实现</h3>
<p>递归实现：</p>
<pre><code class="language-c">void InsertBST(BSTree &amp;T,ElemType e ) {
  //当二叉排序树T中不存在关键字等于e.key的数据元素时，则插入该元素
  if(!T) {                			//找到插入位置，递归结束
         BSTree S = new BSTNode;            	//生成新结点*S
         S-&gt;data = e;                  		//新结点*S的数据域置为e   
         S-&gt;lchild = S-&gt;rchild = NULL;	//新结点*S作为叶子结点
         T =S;            		//把新结点*S链接到已找到的插入位置
  }
  else if (e.key&lt; T-&gt;data.key) 
      InsertBST(T-&gt;lchild, e );			//将*S插入左子树
  else if (e.key&gt; T-&gt;data.key) 
      InsertBST(T-&gt;rchild, e);			//将*S插入右子树
}
</code></pre>
<p>非递归实现：</p>
<pre><code class="language-c">/* 插入节点 */
void insert(BinarySearchTree *bst, int num) {
    // 若树为空，则初始化根节点
    if (bst-&gt;root == NULL) {
        bst-&gt;root = newTreeNode(num);
        return;
    }
    TreeNode *cur = bst-&gt;root, *pre = NULL;
    // 循环查找，越过叶节点后跳出
    while (cur != NULL) {
        // 找到重复节点，直接返回
        if (cur-&gt;val == num) {
            return;
        }
        pre = cur;
        if (cur-&gt;val &lt; num) {
            // 插入位置在 cur 的右子树中
            cur = cur-&gt;right;
        } else {
            // 插入位置在 cur 的左子树中
            cur = cur-&gt;left;
        }
    }
    // 插入节点
    TreeNode *node = newTreeNode(num);
    if (pre-&gt;val &lt; num) {
        pre-&gt;right = node;
    } else {
        pre-&gt;left = node;
    }
}
</code></pre>
<p>经过查找和插入，可以生成一颗二叉排序树</p>
<blockquote>
<p>习题</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022103088-302370381.png" alt="1746375302199" loading="lazy"></p>
<p>结果</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022103740-1054227290.png" alt="1746375314258" loading="lazy"></p>
<blockquote>
<p>不同插入次序的序列生成不同形态的二叉排序树</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022104444-626369322.png" alt="1746375414887" loading="lazy"></p>
<h2 id="二叉排序树的删除">二叉排序树的删除</h2>
<ul>
<li>
<p><strong>删除叶结点</strong>，只需将其双亲结点指向它的指针清零，再释放它即可。</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022105049-560818266.png" alt="1746382144766" loading="lazy"></p>
</li>
<li>
<p><strong>被删结点只有左子树</strong>，可以拿它的左子结点顶替它的位置，再释放它。</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022105991-1229751367.png" alt="1746382212367" loading="lazy"></p>
</li>
<li>
<p><strong>被删结点只有右子树</strong>，可以拿它的右子结点顶替它的位置，再释放它。</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022106653-951902882.png" alt="1746382244694" loading="lazy"></p>
</li>
<li>
<p><strong>被删结点左、右子树都存在</strong>，可以在它的右子树中寻找中序下的第一个结点(关键码最小),用它的值填补到被删结点中，再来处理这个最小结点的删除问题。</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022107359-1412701726.png" alt="1746382330902" loading="lazy"></p>
</li>
</ul>
<h2 id="二叉排序树的性能分析">二叉排序树的性能分析</h2>
<p>第i层的结点，需要比较i次</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022108120-1967217972.png" alt="1746382393753" loading="lazy"></p>
<p><strong>平均：</strong></p>
<ol>
<li>ASL = (1 + 2 * 2 + 2 * 3) * (1/5) = 2.2</li>
<li>ASL = (1 + 2 + 3 + 4 +5) / 5 = 3</li>
</ol>
<p>最好：log2(n)</p>
<p>最坏：(n+1)/2</p>
<h2 id="二叉排序树的优点">二叉排序树的优点</h2>
<p>适合需要经常进行插入、删除和查找运算的表</p>
<h2 id="平衡二叉树">平衡二叉树</h2>
<blockquote>
<p>怎么提高二叉排序树的查找效率呢？</p>
</blockquote>
<p>尽量让二叉树的形状均衡 —— 平衡二叉树</p>
<p>(所有结点的左、右子树深度之差的绝对值≤ 1)</p>
<p>平衡因子：该结点左子树与右子树的高度差</p>
<p>平衡二叉树的平衡因子只能是0、-1、1</p>
<p>性质：对于一棵有n个结点的AVL树，其高度保持在O(log2n)数量级，ASL也保持在O(log2n)量级。</p>
<h1 id="哈希表查找">哈希表查找</h1>
<p>哈希表(hash table)又称散列表，它通过建立键 <code>key</code> 与值 <code>value</code> 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 <code>key</code> ，则可以在 O(1) 时间内获取对应的值 <code>value</code>。</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022108869-410121475.png" alt="1746343929135" loading="lazy"></p>
<p>比如上面的图，只要键入一个key(学号)就能在O(1)内查找到value(姓名)。</p>
<h2 id="哈希函数">哈希函数</h2>
<p>将关键字 <code>key</code> 映射到存储地址的函数，记为hash(key) = Addr</p>
<p>设计哈希函数：</p>
<ol>
<li>直接定址法：取key的某个线性函数作为哈希函数，hash(key) = a * key + b</li>
<li>除留余数法(最常用)：取一个不大于表长的最大素数p，hash(key) = key % p</li>
</ol>
<h2 id="解决哈希冲突">解决哈希冲突</h2>
<p>哈希冲突：多个输入对应同一输出</p>
<blockquote>
<p><strong>建立哈希表的步骤：</strong></p>
</blockquote>
<ol>
<li>hash(key)</li>
<li>判断是否解决冲突</li>
<li>根据选择的冲突处理方法计算H'，H'就是冲突key的存储地址</li>
</ol>
<h3 id="链式地址法">链式地址法</h3>
<h4 id="链式地址的基本概念">链式地址的基本概念：</h4>
<ol>
<li>相同哈希地址的key 链成一个单链表，m个哈希地址就设m个单链表</li>
<li>然后<strong>用一个数组存储每个单链表的头指针</strong>，形成一个动态的结构</li>
</ol>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022109675-141316936.png" alt="1746345041081" loading="lazy"></p>
<h4 id="链式地址的优点">链式地址的优点：</h4>
<ol>
<li>非同义词不会冲突，无“聚集”现象</li>
<li>链表上结点空间动态申请，更适合于表长不确定的情况</li>
</ol>
<h2 id="开放寻址法">开放寻址法</h2>
<p>di 为增量序列，<strong>m是表长</strong></p>
<h3 id="1-线性探测">1. 线性探测<a href="https://www.hello-algo.com/chapter_hashing/hash_collision/#1" title="Permanent link" target="_blank" rel="noopener nofollow">¶</a></h3>
<p>Hi = ( hash(key) + di) % m</p>
<p>di = i ，(i = 1,2,...)</p>
<p>线性探测采用<strong>固定步长</strong>的线性搜索来进行探测。若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 <code>value</code> 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 <code>None</code> 。</p>
<p>删除一个key后要打上删除标记。</p>
<blockquote>
<p>习题</p>
</blockquote>
<p>第一题</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022110470-2145878721.png" alt="1746361058766" loading="lazy"></p>
<p>解题步骤：</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022111327-1002886524.jpg" alt="1746360969649" loading="lazy"></p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022112007-740989989.png" alt="1746361071519" loading="lazy"></p>
<p>第二题</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022112684-589625553.png" alt="1746358724433" loading="lazy"></p>
<p>注意这里表长m = 15</p>
<p>Hi = (hash(key)+di) % 15</p>
<p>比较次数要加上第一次判断是否冲突的一次</p>
<p>解题步骤：</p>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022113426-1615464223.png" alt="1746363202587" loading="lazy"></p>
<h3 id="2-二次探测平方探测">2. 二次探测（平方探测）<a href="https://www.hello-algo.com/chapter_hashing/hash_collision/#2" title="Permanent link" target="_blank" rel="noopener nofollow">¶</a></h3>
<p>Hi=( Hash(key) ± di ) % m</p>
<p>di = i^2</p>
<p>平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即 1,4,9,… 步。</p>
<blockquote>
<p>习题</p>
</blockquote>
<p><img src="https://img2023.cnblogs.com/blog/3614909/202505/3614909-20250505022114277-1894720744.png" alt="1746363585111" loading="lazy"></p>
<p>解题步骤：</p>
<h3 id="3伪随机探测">3.伪随机探测</h3>
<p>Hi = ( Hash(key) + di ) % m</p>
<p>di为随机数</p>
<p>和线性探测一样，删除一个key后也要打上删除标记</p>
<h3 id="4-多次哈希">4. 多次哈希<a href="https://www.hello-algo.com/chapter_hashing/hash_collision/#3" title="Permanent link" target="_blank" rel="noopener nofollow">¶</a></h3>
<p>多次哈希方法使用多个哈希函数 f1(x)、f2(x)、f3(x)、… 进行探测。</p>
<blockquote>
<p>这个方法一般不用</p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07857738006597222" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-05 02:23">2025-05-05 02:22</span>&nbsp;
<a href="https://www.cnblogs.com/eanojiang">EanoJiang</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18859717);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18859717', targetLink: 'https://www.cnblogs.com/eanojiang/p/18859717', title: '查找' })">举报</a>
</div>
        