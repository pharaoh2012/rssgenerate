
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/madtom/p/19050937" title="发布于 2025-08-21 15:35">
    <span role="heading" aria-level="2">[.NET] Aspire Dashboard: 云原生可观测性</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="aspire-dashboard-遥测数据采集机制详解">Aspire Dashboard 遥测数据采集机制详解</h1>
<h2 id="概述">概述</h2>
<p>.NET Aspire Dashboard是一个专门为分布式应用程序设计的可观测性平台，它通过OpenTelemetry协议(OTLP)采集和展示应用程序的<strong>日志(Logs)</strong>、<strong>指标(Metrics)</strong>和<strong>追踪(Traces)</strong>三大类遥测数据。Dashboard同时支持gRPC和HTTP两种传输协议，为应用程序提供了灵活的数据上报方式。</p>
<h2 id="整体架构">整体架构</h2>
<p>Aspire Dashboard的遥测数据采集架构主要包含以下几个核心组件：</p>
<div class="mermaid">graph TB
    subgraph "应用程序/服务"
        A1["日志生成"]
        A2["指标生成"] 
        A3["追踪生成"]
        A1 --&gt; OTEL
        A2 --&gt; OTEL
        A3 --&gt; OTEL
        OTEL["OpenTelemetry SDK&lt;br/&gt;(OTLP Export)"]
    end
    
    OTEL --&gt;|HTTP/gRPC| DASHBOARD
    
    subgraph DASHBOARD ["Aspire Dashboard"]
        subgraph ENDPOINTS ["OTLP 接收端点"]
            subgraph HTTP_EP ["HTTP 端点"]
                H1["/v1/logs"]
                H2["/v1/traces"]
                H3["/v1/metrics"]
            end
            
            subgraph GRPC_EP ["gRPC 端点"]
                G1["OtlpGrpcLogsService"]
                G2["OtlpGrpcTraceService"]
                G3["OtlpGrpcMetricsService"]
            end
        end
        
        ENDPOINTS --&gt; STORAGE
        
        subgraph STORAGE ["数据处理与存储层"]
            subgraph REPO ["TelemetryRepository"]
                subgraph STORES ["存储组件"]
                    S1["Logs 存储&lt;br/&gt;CircularBuffer&amp;lt;OtlpLogEntry&amp;gt;"]
                    S2["Metrics 存储&lt;br/&gt;Resource Based Storage"]
                    S3["Traces 存储&lt;br/&gt;CircularBuffer&amp;lt;OtlpTrace&amp;gt;"]
                end
            end
        end
        
        STORAGE --&gt; UI
        
        subgraph UI ["Dashboard UI"]
            U1["日志查看器"]
            U2["指标图表"]
            U3["追踪分析器"]
        end
    end
    
    style A1 fill:#e1f5fe
    style A2 fill:#e8f5e8
    style A3 fill:#fff3e0
    style OTEL fill:#f3e5f5
    style S1 fill:#e1f5fe
    style S2 fill:#e8f5e8
    style S3 fill:#fff3e0
</div><h2 id="核心组件详解">核心组件详解</h2>
<h3 id="1-otlp接收端点">1. OTLP接收端点</h3>
<p>Dashboard提供两种接收遥测数据的方式：</p>
<h4 id="http端点-otlphttpendpointsbuilder">HTTP端点 (<code>OtlpHttpEndpointsBuilder</code>)</h4>
<ul>
<li><strong>路径</strong>: <code>/v1/logs</code>, <code>/v1/traces</code>, <code>/v1/metrics</code></li>
<li><strong>支持格式</strong>: Protocol Buffers (application/x-protobuf)</li>
<li><strong>CORS支持</strong>: 可配置跨域资源共享</li>
<li><strong>认证</strong>: 支持API Key认证</li>
</ul>
<pre><code class="language-csharp">// HTTP端点映射示例
group.MapPost("logs", static (MessageBindable&lt;ExportLogsServiceRequest&gt; request, OtlpLogsService service) =&gt;
{
    if (request.Message == null)
    {
        return Results.Empty;
    }
    return OtlpResult.Response(service.Export(request.Message));
});
</code></pre>
<h4 id="grpc端点">gRPC端点</h4>
<ul>
<li><strong>服务</strong>: <code>OtlpGrpcLogsService</code>, <code>OtlpGrpcTraceService</code>, <code>OtlpGrpcMetricsService</code></li>
<li><strong>协议</strong>: OpenTelemetry标准gRPC服务</li>
<li><strong>性能</strong>: 更高效的二进制传输</li>
</ul>
<pre><code class="language-csharp">[Authorize(Policy = OtlpAuthorization.PolicyName)]
public class OtlpGrpcLogsService : LogsService.LogsServiceBase
{
    public override Task&lt;ExportLogsServiceResponse&gt; Export(ExportLogsServiceRequest request, ServerCallContext context)
    {
        return Task.FromResult(_logsService.Export(request));
    }
}
</code></pre>
<h3 id="2-数据处理服务">2. 数据处理服务</h3>
<h4 id="日志处理-otlplogsservice">日志处理 (<code>OtlpLogsService</code>)</h4>
<pre><code class="language-csharp">public ExportLogsServiceResponse Export(ExportLogsServiceRequest request)
{
    var addContext = new AddContext();
    _telemetryRepository.AddLogs(addContext, request.ResourceLogs);
    
    return new ExportLogsServiceResponse
    {
        PartialSuccess = new ExportLogsPartialSuccess
        {
            RejectedLogRecords = addContext.FailureCount
        }
    };
}
</code></pre>
<h4 id="追踪处理-otlptraceservice">追踪处理 (<code>OtlpTraceService</code>)</h4>
<pre><code class="language-csharp">public ExportTraceServiceResponse Export(ExportTraceServiceRequest request)
{
    var addContext = new AddContext();
    _telemetryRepository.AddTraces(addContext, request.ResourceSpans);
    
    return new ExportTraceServiceResponse
    {
        PartialSuccess = new ExportTracePartialSuccess
        {
            RejectedSpans = addContext.FailureCount
        }
    };
}
</code></pre>
<h4 id="指标处理-otlpmetricsservice">指标处理 (<code>OtlpMetricsService</code>)</h4>
<pre><code class="language-csharp">public ExportMetricsServiceResponse Export(ExportMetricsServiceRequest request)
{
    var addContext = new AddContext();
    _telemetryRepository.AddMetrics(addContext, request.ResourceMetrics);
    
    return new ExportMetricsServiceResponse
    {
        PartialSuccess = new ExportMetricsPartialSuccess
        {
            RejectedDataPoints = addContext.FailureCount
        }
    };
}
</code></pre>
<h3 id="3-数据存储层-telemetryrepository">3. 数据存储层 (<code>TelemetryRepository</code>)</h3>
<p>TelemetryRepository是Dashboard的核心数据管理组件，负责：</p>
<h4 id="存储结构">存储结构</h4>
<ul>
<li><strong>日志存储</strong>: <code>CircularBuffer&lt;OtlpLogEntry&gt;</code> - 循环缓冲区，FIFO方式管理</li>
<li><strong>追踪存储</strong>: <code>CircularBuffer&lt;OtlpTrace&gt;</code> - 支持容量管理和自动清理</li>
<li><strong>指标存储</strong>: 基于Resource的存储模式</li>
<li><strong>资源管理</strong>: <code>ConcurrentDictionary&lt;ResourceKey, OtlpResource&gt;</code></li>
</ul>
<h4 id="数据容量管理">数据容量管理</h4>
<pre><code class="language-csharp">public sealed class TelemetryLimitOptions
{
    public int MaxLogCount { get; set; } = 10_000;        // 最大日志条数
    public int MaxTraceCount { get; set; } = 10_000;      // 最大追踪条数  
    public int MaxMetricsCount { get; set; } = 50_000;    // 最大指标点数
    public int MaxAttributeCount { get; set; } = 128;     // 最大属性数量
    public int MaxAttributeLength { get; set; } = int.MaxValue; // 最大属性长度
    public int MaxSpanEventCount { get; set; } = int.MaxValue;  // 最大Span事件数
}
</code></pre>
<h4 id="数据插入机制">数据插入机制</h4>
<p><strong>日志插入</strong>：支持乱序插入和时间戳排序</p>
<pre><code class="language-csharp">public void AddLogsCore(AddContext context, OtlpResourceView resourceView, RepeatedField&lt;ScopeLogs&gt; scopeLogs)
{
    _logsLock.EnterWriteLock();
    try
    {
        foreach (var record in sl.LogRecords)
        {
            var logEntry = new OtlpLogEntry(record, resourceView, scope, _otlpContext);
            
            // 基于时间戳插入到正确位置
            var added = false;
            for (var i = _logs.Count - 1; i &gt;= 0; i--)
            {
                if (logEntry.TimeStamp &gt; _logs[i].TimeStamp)
                {
                    _logs.Insert(i + 1, logEntry);
                    added = true;
                    break;
                }
            }
            if (!added)
            {
                _logs.Insert(0, logEntry);
            }
        }
    }
    finally
    {
        _logsLock.ExitWriteLock();
    }
}
</code></pre>
<h3 id="4-实时订阅机制">4. 实时订阅机制</h3>
<p>Dashboard使用发布-订阅模式实现实时数据更新：</p>
<pre><code class="language-csharp">// 订阅管理
private readonly List&lt;Subscription&gt; _resourceSubscriptions = new();
private readonly List&lt;Subscription&gt; _logSubscriptions = new();
private readonly List&lt;Subscription&gt; _metricsSubscriptions = new();
private readonly List&lt;Subscription&gt; _tracesSubscriptions = new();

// 触发订阅更新
private void RaiseSubscriptionChanged(List&lt;Subscription&gt; subscriptions)
{
    lock (_lock)
    {
        foreach (var subscription in subscriptions)
        {
            subscription.TryExecute();
        }
    }
}
</code></pre>
<h3 id="5-暂停管理-pausemanager">5. 暂停管理 (<code>PauseManager</code>)</h3>
<p>支持暂停数据采集功能，避免在调试期间数据过载：</p>
<pre><code class="language-csharp">public void AddLogs(AddContext context, RepeatedField&lt;ResourceLogs&gt; resourceLogs)
{
    if (_pauseManager.AreStructuredLogsPaused(out _))
    {
        _logger.LogTrace("{Count} incoming structured log(s) ignored because of an active pause.", resourceLogs.Count);
        return;
    }
    // ... 处理日志
}
</code></pre>
<h3 id="6-组件关系图">6. 组件关系图</h3>
<div class="mermaid">graph TD
    subgraph "Dashboard Web Application"
        DWA[DashboardWebApplication] --&gt; OTLP_HTTP[OtlpHttpEndpointsBuilder]
        DWA --&gt; OTLP_GRPC[gRPC Services]
        DWA --&gt; CONFIG[Configuration]
        
        subgraph "OTLP Services"
            OTLP_HTTP --&gt; LS[OtlpLogsService]
            OTLP_HTTP --&gt; TS[OtlpTraceService]
            OTLP_HTTP --&gt; MS[OtlpMetricsService]
            
            OTLP_GRPC --&gt; GLS[OtlpGrpcLogsService]
            OTLP_GRPC --&gt; GTS[OtlpGrpcTraceService]
            OTLP_GRPC --&gt; GMS[OtlpGrpcMetricsService]
            
            GLS --&gt; LS
            GTS --&gt; TS
            GMS --&gt; MS
        end
        
        subgraph "Data Layer"
            LS --&gt; TR[TelemetryRepository]
            TS --&gt; TR
            MS --&gt; TR
            
            TR --&gt; PM[PauseManager]
            TR --&gt; CB1[CircularBuffer&amp;lt;Logs&amp;gt;]
            TR --&gt; CB2[CircularBuffer&amp;lt;Traces&amp;gt;]
            TR --&gt; RM[Resource Manager]
            TR --&gt; SUB[Subscription System]
        end
        
        subgraph "UI Components"
            SUB --&gt; LV[Log Viewer]
            SUB --&gt; MV[Metrics Viewer]
            SUB --&gt; TV[Trace Viewer]
        end
    end
    
    subgraph "Host Integration"
        RP[ResourcePublisher] --&gt; DC[DashboardClient]
        DC --&gt; TR
    end
    
    style DWA fill:#f9f,stroke:#333,stroke-width:3px
    style TR fill:#bbf,stroke:#333,stroke-width:2px
    style SUB fill:#bfb,stroke:#333,stroke-width:2px
</div><h2 id="配置与端点">配置与端点</h2>
<h3 id="端点配置-otlpoptions">端点配置 (<code>OtlpOptions</code>)</h3>
<pre><code class="language-csharp">public sealed class OtlpOptions
{
    public string? PrimaryApiKey { get; set; }          // 主API密钥
    public string? SecondaryApiKey { get; set; }        // 备用API密钥  
    public OtlpAuthMode? AuthMode { get; set; }         // 认证模式
    public string? GrpcEndpointUrl { get; set; }        // gRPC端点URL
    public string? HttpEndpointUrl { get; set; }        // HTTP端点URL
    public OtlpCors Cors { get; set; } = new();         // CORS配置
}
</code></pre>
<h3 id="cors配置">CORS配置</h3>
<pre><code class="language-csharp">public sealed class OtlpCors
{
    public string? AllowedOrigins { get; set; }   // 允许的来源域名
    public string? AllowedHeaders { get; set; }   // 允许的请求头
    
    [MemberNotNullWhen(true, nameof(AllowedOrigins))]
    public bool IsCorsEnabled =&gt; !string.IsNullOrEmpty(AllowedOrigins);
}
</code></pre>
<h3 id="应用程序配置">应用程序配置</h3>
<p>Dashboard在<code>DashboardWebApplication</code>中进行完整的服务配置：</p>
<pre><code class="language-csharp">// 注册OTLP服务
builder.Services.AddSingleton&lt;TelemetryRepository&gt;();
builder.Services.AddTransient&lt;OtlpLogsService&gt;();
builder.Services.AddTransient&lt;OtlpTraceService&gt;();
builder.Services.AddTransient&lt;OtlpMetricsService&gt;();

// 配置gRPC
builder.Services.AddGrpc();

// 映射端点
_app.MapHttpOtlpApi(dashboardOptions.Otlp);      // HTTP端点
_app.MapGrpcService&lt;OtlpGrpcMetricsService&gt;();   // gRPC指标服务
_app.MapGrpcService&lt;OtlpGrpcTraceService&gt;();     // gRPC追踪服务  
_app.MapGrpcService&lt;OtlpGrpcLogsService&gt;();      // gRPC日志服务
</code></pre>
<h2 id="与aspire宿主的集成">与Aspire宿主的集成</h2>
<h3 id="资源发布-resourcepublisher">资源发布 (<code>ResourcePublisher</code>)</h3>
<p>Dashboard通过ResourcePublisher与Aspire宿主通信，获取应用程序资源信息：</p>
<pre><code class="language-csharp">internal sealed class ResourcePublisher
{
    private readonly Dictionary&lt;string, SourceAndResourceSnapshot&gt; _snapshot = [];
    private ImmutableHashSet&lt;Channel&lt;ResourceSnapshotChange&gt;&gt; _outgoingChannels = [];
    
    // 集成资源变更并广播给订阅者
    internal async ValueTask IntegrateAsync(IResource source, ResourceSnapshot snapshot, ResourceSnapshotChangeType changeType)
    {
        lock (_syncLock)
        {
            switch (changeType)
            {
                case ResourceSnapshotChangeType.Upsert:
                    _snapshot[snapshot.Name] = new SourceAndResourceSnapshot(source, snapshot);
                    break;
                case ResourceSnapshotChangeType.Delete:
                    _snapshot.Remove(snapshot.Name);
                    break;
            }
        }
        
        // 通知所有订阅者
        foreach (var channel in channels)
        {
            await channel.Writer.WriteAsync(new(changeType, snapshot), cancellationToken);
        }
    }
}
</code></pre>
<h3 id="dashboard客户端-dashboardclient">Dashboard客户端 (<code>DashboardClient</code>)</h3>
<p>实现与资源服务的gRPC通信：</p>
<pre><code class="language-csharp">internal sealed class DashboardClient : IDashboardClient
{
    private readonly Dictionary&lt;string, ResourceViewModel&gt; _resourceByName = new();
    private readonly GrpcChannel? _channel;
    private Aspire.DashboardService.Proto.V1.DashboardService.DashboardServiceClient? _client;
    
    // 订阅资源变更
    public async IAsyncEnumerable&lt;IReadOnlyList&lt;ResourceViewModelChange&gt;&gt; SubscribeResourcesAsync()
    {
        // 通过gRPC流式接收资源更新
    }
}
</code></pre>
<h2 id="数据流转过程">数据流转过程</h2>
<h3 id="1-数据接收流程">1. 数据接收流程</h3>
<div class="mermaid">sequenceDiagram
    participant App as 应用程序
    participant OTLP as OTLP Exporter
    participant HTTP as HTTP端点
    participant GRPC as gRPC端点
    participant Service as 数据处理服务
    participant Repo as TelemetryRepository
    participant Storage as 存储层

    App-&gt;&gt;OTLP: 生成遥测数据
    OTLP-&gt;&gt;HTTP: HTTP/JSON 请求
    OTLP-&gt;&gt;GRPC: gRPC 调用
    
    HTTP-&gt;&gt;Service: OtlpLogsService.Export()
    GRPC-&gt;&gt;Service: OtlpGrpcLogsService.Export()
    
    Service-&gt;&gt;Repo: AddLogs/AddTraces/AddMetrics
    Repo-&gt;&gt;Storage: 写入CircularBuffer
    Storage--&gt;&gt;Repo: 存储确认
    Repo--&gt;&gt;Service: 处理结果
    Service--&gt;&gt;HTTP: ExportResponse
    Service--&gt;&gt;GRPC: ExportResponse
</div><h3 id="2-数据查询流程">2. 数据查询流程</h3>
<div class="mermaid">sequenceDiagram
    participant UI as Dashboard UI
    participant Sub as 订阅系统
    participant Repo as TelemetryRepository
    participant Filter as 数据过滤器
    participant Storage as 存储层

    UI-&gt;&gt;Sub: 订阅数据更新
    Sub-&gt;&gt;Repo: 注册订阅回调
    
    loop 实时数据查询
        UI-&gt;&gt;Repo: 查询遥测数据
        Repo-&gt;&gt;Filter: 应用过滤条件
        Filter-&gt;&gt;Storage: 读取数据
        Storage--&gt;&gt;Filter: 返回数据
        Filter--&gt;&gt;Repo: 过滤后数据
        Repo--&gt;&gt;UI: 返回结果
    end
    
    Note over Storage: 数据变更时
    Storage-&gt;&gt;Repo: 触发变更事件
    Repo-&gt;&gt;Sub: 通知订阅者
    Sub-&gt;&gt;UI: 实时推送更新
</div><h3 id="3-实时更新机制">3. 实时更新机制</h3>
<div class="mermaid">flowchart LR
    A[数据变更] --&gt; B[触发订阅]
    B --&gt; C[推送到UI组件]
    C --&gt; D[前端实时刷新]
    
    subgraph 订阅管理
        E[ResourceSubscriptions]
        F[LogSubscriptions]
        G[MetricsSubscriptions]
        H[TracesSubscriptions]
    end
    
    B --&gt; E
    B --&gt; F
    B --&gt; G
    B --&gt; H
</div><h2 id="性能优化特性">性能优化特性</h2>
<h3 id="1-内存管理">1. 内存管理</h3>
<ul>
<li><strong>循环缓冲区</strong>: 自动清理老数据，避免内存泄漏</li>
<li><strong>容量限制</strong>: 可配置的数据条数上限</li>
<li><strong>分段锁</strong>: 使用ReaderWriterLockSlim减少锁争用</li>
</ul>
<h3 id="2-数据压缩">2. 数据压缩</h3>
<ul>
<li><strong>HTTP压缩</strong>: 支持响应压缩</li>
<li><strong>Protocol Buffers</strong>: 高效的二进制序列化</li>
</ul>
<h3 id="3-异步处理">3. 异步处理</h3>
<ul>
<li><strong>流式处理</strong>: 支持大批量数据的流式处理</li>
<li><strong>异步订阅</strong>: 非阻塞的实时数据推送</li>
</ul>
<h2 id="总结">总结</h2>
<p>Aspire Dashboard采用了模块化的架构设计，通过标准的OpenTelemetry协议接收遥测数据，使用高效的存储机制和实时订阅模式，为分布式应用程序提供了完整的可观测性解决方案。其核心优势包括：</p>
<ol>
<li><strong>标准化</strong>: 完全基于OpenTelemetry标准，确保与各种应用程序的兼容性</li>
<li><strong>高性能</strong>: 使用循环缓冲区和异步处理，支持高吞吐量的数据采集</li>
<li><strong>实时性</strong>: 基于订阅模式的实时数据更新机制</li>
<li><strong>可配置</strong>: 灵活的配置选项，支持不同的部署场景</li>
<li><strong>多协议</strong>: 同时支持HTTP和gRPC两种传输协议</li>
</ol>
<p>该架构为.NET生态系统中的分布式应用程序监控和调试提供了强大的基础设施支持。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-21 15:36">2025-08-21 15:35</span>&nbsp;
<a href="https://www.cnblogs.com/madtom">MadLongTom</a>&nbsp;
阅读(<span id="post_view_count">120</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19050937);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19050937', targetLink: 'https://www.cnblogs.com/madtom/p/19050937', title: '[.NET] Aspire Dashboard: 云原生可观测性' })">举报</a>
</div>
        