
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/alexander17/p/18884879" title="发布于 2025-05-19 20:58">
    <span role="heading" aria-level="2">ISCC2025破阵夺旗赛三阶段Misc详解  By Alexander</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="iscc2025破阵夺旗赛三阶段misc详解--by-alexander">ISCC2025破阵夺旗赛三阶段Misc详解  By Alexander</h1>
<p>写在前面：十八天吃石终于结束了，第一次就让我见到了这个比赛有多么的构式，平台是构式的，睡一觉就1000解了，全是对flag的渴望，对比赛的认可。</p>
<h2 id="校赛阶段">校赛阶段</h2>
<h3 id="书法大师">书法大师</h3>
<p>下载图片<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204057420-982671232.png" alt="" loading="lazy"></p>
<p>随波逐流检测</p>
<p><img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204113953-1344073658.png" alt="" loading="lazy"></p>
<p>有很多zip</p>
<p>foremost分离出来</p>
<p><img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204139084-870778226.png" alt="" loading="lazy"></p>
<p>第二个zip（plus:当时解出来的时候，有50zip,50个全是flag,那我问你，你是把所有人flag放一起了?)</p>
<p>图片注释有密码</p>
<p><img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204152783-121045380.png" alt="" loading="lazy"></p>
<p>起初解法</p>
<pre><code>import binascii
import base64
import os
import pyzipper
import requests
import urllib.parse
import json

# foremost -i 分离图片压缩包，然后删除所有压缩包内容为 message.txt 的，保留 message1-50.txt
# 压缩包密码在图片属性中

path = r"output_Wed_Apr_30_22_56_59_2025\zip"
pwd = 'L9k8JhGfDsA'

for file in os.listdir(path):
    tmp_path = path + '\\' + file
    zipfile = pyzipper.ZipFile(tmp_path)
    zipfile.extractall(pwd=pwd.encode())
    zipfile.close()

url = "https://unpkg.com/cnchar-data@1.1.0/draw/"


def get_strokes(x):
    res = requests.get(url + urllib.parse.quote(x) + ".json")
    j = json.loads(res.text)['strokes']
    return str(hex(len(j))[2:])


data = ''
for i in range(1, 51):
    data += open(f'message{i}.txt', 'r', encoding='UTF-8', errors='ignore').read() + ' '

output = ''
for char in data[:72]:
    if char == ' ':
        pass
    else:
        output += get_strokes(char)

print(output)
print(base64.b64decode(binascii.unhexlify(output)))
</code></pre>
<p>修复后的解法</p>
<p>解压</p>
<pre><code>巧卫 正西 贝旗 太贝 丙乙 大马 没少 远国 为靠 巧切 片海 个一 那乙 西海 石真 马卫 为数 圾谁 早林 众谁 年圾 丙一 个罪 工数
</code></pre>
<pre><code>53 56 4E 44 51 33 74 78 4F 54 4A 31 61 6A 5A 33 4D 6A 68 6A 66 51 3D 3D
</code></pre>
<p>每两位对应笔划组成2位16进制，base64解码</p>
<pre><code>import base64
hex_str = "53564E44513374784F544A31616A5A334D6A686A66513D3D"
bytes_data = bytes.fromhex(hex_str)
decoded_data = base64.b64decode(bytes_data).decode('utf-8', errors='ignore')
print(decoded_data)
</code></pre>
<pre><code>ISCC{q92uj6w28c}
</code></pre>
<h3 id="反方向的钟">反方向的钟</h3>
<p>打开txt<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204343849-1195425736.png" alt="" loading="lazy"></p>
<pre><code>Dx8CBEkFfE1XfBQtAwknAgVN
</code></pre>
<p>010检测到有多余隐写部分</p>
<p>零宽隐写<br>
<a href="https://yuanfux.github.io/zero-width-web/" target="_blank" rel="noopener nofollow">https://yuanfux.github.io/zero-width-web/</a></p>
<p><img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204417692-1713545679.png" alt="" loading="lazy"></p>
<p>得到key,厨子xor</p>
<p><img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204430656-1643537950.png" alt="" loading="lazy"></p>
<pre><code>iscc{5Nxa6wYjzDa7}
</code></pre>
<h2 id="区域赛">区域赛</h2>
<h3 id="睡美人">睡美人</h3>
<p>ps:写之前提一嘴，爆6h密码的哥们你是真的牛。密码怎么来的我不说</p>
<p>下载图片</p>
<p>发现右下有神秘字符串，放大看</p>
<p><img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204459231-1932174150.png" alt="" loading="lazy"></p>
<pre><code>UGFzc3dvcmQgPSBzdW0oUilfc3VtKEcpX3N1bShCKQ==
</code></pre>
<p>Base64解码</p>
<pre><code>Password = sum(R)_sum(G)_sum(B)
</code></pre>
<p>跟颜色通道R,G,B有关，结合题目提示，“红红红红红红绿绿绿蓝”。红绿蓝比例为6：3：1  加权乘上并提取图片颜色通道的值，编写脚本</p>
<pre><code>from PIL import Image

# Open image (replace path)
path = r"Sleeping_Beauty_23.png"  
img = Image.open(path).convert("RGB")

wr = 0.6
wg = 0.3
wb = 0.1

sum = 0.0

w, h = img.size

# Process pixels
for y in range(h):
    for x in range(w):
        r, g, b = img.getpixel((x, y))
        # Calculate weighted value
        p = round(r*wr + g*wg + b*wb, 1)
        sum += p

sum = round(sum, 1)

print(f"Total weighted value: {sum}")
</code></pre>
<pre><code>Total weighted value: 1375729349.6   //解压密码为1375729349.6
</code></pre>
<p>binwalk分离图片中的压缩包<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204559123-997011780.png" alt="" loading="lazy"></p>
<p>用上述密码进行解压</p>
<p>得到一个wav文件</p>
<p>听一下</p>
<p><a href="https://products.aspose.ai/total/zh/speech-to-text/#google_vignette" target="_blank" rel="noopener nofollow">https://products.aspose.ai/total/zh/speech-to-text/#google_vignette</a></p>
<pre><code>There is a hidden message in this sound file. Can you find it?
</code></pre>
<p>后面还有一串声音，audacity打开<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204703043-1385286981.png" alt="" loading="lazy"></p>
<p>猜测为曼彻斯特编码，我们截取片段，对照序列，还原，最后二进制转字符<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204713045-452749993.png" alt="" loading="lazy"></p>
<pre><code>import scipy.io.wavfile as wavfile
import numpy as np

def load_audio_file(file_path):
    try:
        return wavfile.read(file_path)
    except:
        return None, None

def preprocess_audio_signal(audio_data):
    return audio_data[:, 0] if audio_data.ndim == 2 else audio_data

def analyze_audio_segment(segment, threshold=0):
    binary = (segment &gt; threshold).astype(int)
    return '0' if np.all(binary == 1) else '1' if np.any(np.diff(binary) == -1) else None

def decode_audio(audio_signal, sample_rate, start_sample, samples_per_segment):
    total_samples = len(audio_signal)
    return [
        bit
        for current_position in range(start_sample, total_samples, samples_per_segment)
        if current_position + samples_per_segment &lt;= total_samples
        for bit in [analyze_audio_segment(audio_signal[current_position:current_position + samples_per_segment])]
        if bit is not None
    ]

def binary_to_string(binary_data):
    if not binary_data:
        return ""
    binary_str = ''.join(binary_data).ljust((len(binary_data) + 7) // 8 * 8, '0')
    return ''.join(chr(int(binary_str[i:i+8], 2)) for i in range(0, len(binary_str), 8))

def decode_audio_file(file_path="normal_speech_23.wav", start_time_sec=6.0, segment_duration_sec=0.1):
    sample_rate, audio_data = load_audio_file(file_path)
    if sample_rate is None or audio_data is None:
        return ""
    audio_signal = preprocess_audio_signal(audio_data)
    start_sample = int(start_time_sec * sample_rate)
    samples_per_segment = int(segment_duration_sec * sample_rate)
    if start_sample + samples_per_segment &gt; len(audio_signal):
        return ""
    return binary_to_string(decode_audio(audio_signal, sample_rate, start_sample, samples_per_segment))

if __name__ == "__main__":
    print("Decoded String:", decode_audio_file())



#Decoded String: Enigma
</code></pre>
<pre><code>ISCC{Enigma}
</code></pre>
<h3 id="签个到吧">签个到吧</h3>
<p>010打开hint.zip，发现有png图片，我们foremost分离出来<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204754581-397658923.png" alt="" loading="lazy"></p>
<p>Stegsolve<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204804580-1419258491.png" alt="" loading="lazy"></p>
<p>根据提示“变换一次再混入点东西”,是猫脸变换</p>
<p>工具爆破<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204816887-1164351685.png" alt="" loading="lazy"></p>
<p>a=1,b=-2,shuffle times=1时得到图（工具是我自己写的）</p>
<p>再放个梭哈代码详细看blog:<a href="https://www.cnblogs.com/alexander17/p/18551089" target="_blank">https://www.cnblogs.com/alexander17/p/18551089</a></p>
<pre><code>import numpy as np
from PIL import Image

def arnold_decode_once(image: Image.Image, a: int = 1, b: int = -2, mode: str = '1'):
    image = np.array(image)
    N = image.shape[0]
    next_image = np.zeros_like(image)

    for x in range(N):
        for y in range(N):
            new_x = ((a * b + 1) * x - b * y) % N
            new_y = (-a * x + y) % N
            if mode == '1':
                next_image[new_x, new_y] = image[x, y]
            else:
                next_image[new_x, new_y, :] = image[x, y, :]

    return Image.fromarray(next_image)

if __name__ == '__main__':
    img = Image.open('1.png').convert('1')
    result_img = arnold_decode_once(img, a=1, b=-2, mode='1')
    result_img.save('output.png')
</code></pre>
<p>我们将图反色（随波逐流），再逆时针旋转90°<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204848245-501697701.png" alt="" loading="lazy"></p>
<p>最后与flag_is_not_here.jpg双图xor<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204921300-323785596.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519204948340-1044245916.png" alt="" loading="lazy"></p>
<pre><code>ISCC{rcC8S12bFKeZ}
</code></pre>
<h3 id="返校之路">返校之路</h3>
<p>Winzip打开part1<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205140184-1744252722.png" alt="" loading="lazy"></p>
<pre><code>一转眼，寒假已经过去，同学们都怀着怎样的心情踏上返校之路呢？

你是一名学生，从刚下高铁，准备乘坐19站地铁返回学校。短短的假期总是让人留恋，而返校的路似乎格外漫长。

在途中，你发现了一个神秘的压缩包，以及一张写着bfs???的纸条，这似乎隐藏着一些重要的信息。。。
</code></pre>
<p>Part2的部分加密了，根据txt内容我们进行掩码爆破<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205201595-272522390.png" alt="" loading="lazy"></p>
<p>解压压缩包</p>
<p>zsteg扫picture2.png得到<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205214075-5804968.png" alt="" loading="lazy"></p>
<pre><code>32:flag_is_MFLU4MLCKRFDITLLGA6Q====
</code></pre>
<p>base32-&gt;base64解密<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205253398-300115935.png" alt="" loading="lazy"></p>
<pre><code>icum2x2M
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205308364-422405469.png" alt="" loading="lazy"></p>
<p>第二部分分析路线图，我们需要从地铁朝阳站到地铁魏公村站，3号线转10号线再转4号</p>
<p>所以是3104,拼接上一部分</p>
<pre><code>ISCC{icum2x2M3104}
</code></pre>
<h3 id="取证分析">取证分析</h3>
<p>下载并解压hint的镜像，Lovelymem打开内存镜像</p>
<p>Vol2文件扫描，并提出一个hahaha.zip<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205339312-1601882371.png" alt="" loading="lazy"></p>
<p>文件加密了，但是没想到上一题的掩码可以爆出密码（非预期），预期应该是明文攻击<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205350802-1233018753.png" alt="" loading="lazy"></p>
<p>解密Hint.txt<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205402442-638153376.png" alt="" loading="lazy"></p>
<p>凯撒移位12位</p>
<pre><code>flag{ vigenere cipher }
</code></pre>
<p>说明flag是维吉尼亚加密的</p>
<p>再看杨辉三角</p>
<p>我们根据给定的坐标计算杨辉三角中的值，然后对 26 取模，再映射成字母得到密钥</p>
<pre><code>from math import comb

coordinates = [(2,10), (4,8), (2,4), (3,4), (11,13), (2,11), (1,1), (10,26), (5,6), (5,9)]
values = [comb(row-1, col-1) for col, row in coordinates]
mod_values = [v % 26 for v in values]
key = ''.join([chr(65 + (m-1)) for m in mod_values])
print(key)

#IICCNJAYER
</code></pre>
<p>我们将题目附件给word解压，在[Content_Types].xml中找到了密文<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205440116-1714466170.png" alt="" loading="lazy"></p>
<p>最后维吉尼亚解密<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205450427-1073291853.png" alt="" loading="lazy"></p>
<pre><code>ISCC{jwcohqxginsi}
</code></pre>
<h2 id="总决赛">总决赛</h2>
<h3 id="神经网络迷踪">神经网络迷踪</h3>
<p>非预期：解压，文件名为flag(我奶奶来了都会写)，主办方你是牛的。真的做到了题目的前两个字</p>
<p>预期解</p>
<p>下载得到模型文件</p>
<p><a href="https://netron.app/" target="_blank" rel="noopener nofollow">https://netron.app/</a></p>
<p>挂载模型（secretkey解出来的2025ISCC2025key!毛用没有！！！！）</p>
<p>我们把secret那一层的元素内容转utf-8</p>
<p>出现hint:放大/缩小255<br>
我们到output.bias<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205519422-322986848.png" alt="" loading="lazy"></p>
<p>每个值乘255转ascii</p>
<pre><code>values = [
    0.4509870111942291,
    0.38042718172073364,
    0.40395817160606384,
    0.4549211859703064
]

# 转换为整数ASCII码并映射到字符，添加ISCC{}包裹
result = 'ISCC{' + ''.join(chr(int(value * 255)) for value in values) + '}'

print(f"转换结果: {result}")    
</code></pre>
<pre><code>ISCC{sagt}
</code></pre>
<h3 id="八卦">八卦</h3>
<p>下载附件</p>
<p>是个动图，我们后缀改成gif<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205550379-1065632345.png" alt="" loading="lazy"></p>
<p>发现有内容</p>
<p>010发现末尾有个7z</p>
<p>我们手提出来<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205600656-48973188.png" alt="" loading="lazy"></p>
<p>接着puzzlersolver分离动图</p>
<p>Base64解码发现</p>
<p>乾为天 山水蒙 水雷屯 水天需</p>
<p>对分离的图片进行随波逐流<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205611318-17794941.png" alt="" loading="lazy"></p>
<p>在00B通道发现数据</p>
<p>Base64解密 坤为地</p>
<p>根据给的hint</p>
<p>我们puzzlersolver获取动图间隔帧</p>
<p><img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205621304-549536002.png" alt="" loading="lazy"></p>
<p>意指向23，指的是64卦中的23卦</p>
<p>在线网站查询</p>
<p><a href="https://lzltool.cn/tool/infozhouyi64" target="_blank" rel="noopener nofollow">https://lzltool.cn/tool/infozhouyi64</a></p>
<p>存在内容即在分离的5张图片中，存在内容即为1，不存在即为0，1235帧存在base64,46帧没有，即111010</p>
<p>111010转十进制为58，指的为58卦</p>
<p>题目中的7卦已经形成，我们在上述在线网站中找到所对应的上下卦</p>
<p><img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205632711-949796783.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205638090-2060762336.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205644408-750017871.png" alt="" loading="lazy"></p>
<p>我们按照从小到大拼接上下卦</p>
<p>得到压缩包密码</p>
<pre><code>乾乾坤坤坎震艮坎坎乾艮坤兑兑
</code></pre>
<p>（比赛结束看到烛影佬用卦写了个字典把密码硬爆破出来了，好强）<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205707132-1460116971.png" alt="" loading="lazy"></p>
<p>随波逐流梭哈（双base64)<br>
<img src="https://img2024.cnblogs.com/blog/3560748/202505/3560748-20250519205717845-1947411283.png" alt="" loading="lazy"></p>
<pre><code>ISCC{kYcLxuyyu449}
</code></pre>

</div>
<div id="MySignature" role="contentinfo">
    <p>本文来自博客园，作者：{Alexander17}，转载请注明原文链接：{https://home.cnblogs.com/u/alexander17}</p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6390598858067129" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-19 20:59">2025-05-19 20:58</span>&nbsp;
<a href="https://www.cnblogs.com/alexander17">Alexander17</a>&nbsp;
阅读(<span id="post_view_count">151</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18884879);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18884879', targetLink: 'https://www.cnblogs.com/alexander17/p/18884879', title: 'ISCC2025破阵夺旗赛三阶段Misc详解  By Alexander' })">举报</a>
</div>
        