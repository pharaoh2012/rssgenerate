
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ziyansugar/p/18657519" title="发布于 2025-01-07 14:11">
    <span role="heading" aria-level="2">C#笔记（1、钉钉机器人推送帆软报表图片）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="c笔记钉钉机器人推送帆软报表图片一">C#笔记——钉钉机器人推送帆软报表图片（一）</h1>
<blockquote>
<h2 id="1前言">1、前言</h2>
<p>​	2024年最后一个月，家里多了个小公主，在家休息了一段时间。2025年，休完假上班第一天，领导就说：哎，我看总部那边做了个每日产出的报表推送到钉钉群，来看计划达成率。我们基地这边能不能做啊。我心里默默一想，然后大声一喊能做（内心os：上家公司做过类似的功能，不过他们是自己的通讯工具，不是钉钉）。既然有了活，那就开干吧。最终忙活了几天，终于算是实现了这个功能吧，记录下整个过程，以及踩到的坑吧，最终实现效果如图。</p>
<p><img src="https://gitee.com/wind59/blog-file/raw/master/Springboot/Pictures/10.1.png" alt="image-20250107130753085" loading="lazy"></p>
</blockquote>
<blockquote>
<h2 id="2下载帆软报表图片到本地">2、下载帆软报表图片到本地</h2>
<p>因为上家做过类似的功能，那就直接借鉴下之前的代码，先把帆软报表以图片格式下载到本地。大概过程如下</p>
<p>1、在帆软的报表访问页面的url后面添加<code>&amp;format=image&amp;extype=PNG</code></p>
<p>2、使用http请求访问，下载到本地，添加动态反射以用来传帆软报表的查询条件参数</p>
<p>3、裁剪图片留白区域，添加水印等</p>
<pre><code class="language-c#">public async Task SendImageOutput()
{
    try
    {
        //string fineReportUrl = "http://localhost:8075/webroot/decision/view/report?viewlet=tzreport/E04.cpt&amp;format=image&amp;extype=PNG";
        string image_Path = "D:\\1";
        string retMsg = string.Empty;
        DateTime dateTime = DateTime.Now;
        string time = dateTime.ToString("yyyyMMdd");//当前时间格式
        string downPath = Path.Combine(image_Path, time);//下载到当前的路径 //方便删除历史的记录文件
        if (!Directory.Exists(downPath))
        {
            Directory.CreateDirectory(downPath);
        }
        string startdate = dateTime.AddDays(-7).ToString("yyyy-MM-dd");
        string enddate = dateTime.ToString("yyyy-MM-dd");
        string cSharpScript = $"string startdate= \"{startdate}\";string enddate= \"{enddate}\"; var paramlist =\"&amp;startdate=\"+startdate+\"&amp;\"+\"enddate=\"+enddate; return paramlist;";
        string urlParam = FineReportUrlParam(cSharpScript);
        string url = fineReportUrl;
        if (!string.IsNullOrEmpty(urlParam))
        {
            url += urlParam;
        }
        //下载图片
        bool downResult = HttpDownloadImage(url, "C02产出", downPath, out string imageFullpath);
        if (downResult)
        {
            //发送数据到dingding
            .......
        }
        else
        {
            retMsg = "执行失败！";
        }
    }
    catch (Exception ex)
    {
        throw ex;
    }
}

/// &lt;summary&gt;
/// http下载文件
/// &lt;/summary&gt;
/// &lt;param name="url"&gt;下载文件地址&lt;/param&gt;
/// &lt;param name="path"&gt;文件存放地址&lt;/param&gt;
/// &lt;param name="isAddSecurity"&gt;是否标密&lt;/param&gt;
/// &lt;param name="imageNamePrefix"&gt;保存的文件的前缀&lt;/param&gt;
/// &lt;param name="imageFullPath"&gt;图片保存到的本地路径&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public bool HttpDownloadImage(string url, string imageNamePrefix, string path, out string imageFullPath)
{
    try
    {
        HttpWebRequest? request = WebRequest.Create(url) as HttpWebRequest;
        //发送请求并获取相应回应数据
        HttpWebResponse? response = request.GetResponse() as HttpWebResponse;
        string fileName = imageNamePrefix + "_" + DateTime.Now.ToString("yyyyMMddHHmmssFFF") + ".png";
        string fileFullPath = Path.Combine(path, fileName);
        Stream responseStream = response.GetResponseStream();
        ImageEditDomain imageEdit = new ImageEditDomain();
        Bitmap imageBitmap = imageEdit.CutImageWhitePart(responseStream, 80, fileFullPath);
        Bitmap imageBitmapSecret = imageBitmap;
        Bitmap imageBitmapWord = imageEdit.AddWatermarkWord(imageBitmapSecret);//加有“MES系统自动发送”的图片
        imageFullPath = string.Empty;
        if (imageBitmapWord == null)
        {
            return false;
        }
        else
        {
            imageBitmapWord.Save(fileFullPath, ImageFormat.Png);
            imageFullPath = fileFullPath;
            return true;
        }
    }
    catch (Exception ex)
    {
        imageFullPath = string.Empty;
        return false;
    }
}

/// &lt;summary&gt;
/// 生成动态代码，方便调用
/// &lt;/summary&gt;
/// &lt;param name="argMethodCode"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public string GenerateCode(string argMethodCode)
{
    StringBuilder sb = new StringBuilder();
    sb.Append("using System;");
    sb.Append(Environment.NewLine);
    sb.Append("namespace FineReport");
    sb.Append(Environment.NewLine);
    sb.Append("{");
    sb.Append(Environment.NewLine);
    sb.Append("      public class UrlParam");
    sb.Append(Environment.NewLine);
    sb.Append("      {");
    sb.Append(Environment.NewLine);
    sb.Append("          public string GetParam()");
    sb.Append(Environment.NewLine);
    sb.Append("          {");
    sb.Append(Environment.NewLine);
    sb.Append(argMethodCode);
    sb.Append(Environment.NewLine);
    sb.Append("          }");
    sb.Append(Environment.NewLine);
    sb.Append("      }");
    sb.Append(Environment.NewLine);
    sb.Append("}");
    return sb.ToString();
}
/// &lt;summary&gt;
/// 获取执行动态C#代码的值
/// &lt;/summary&gt;
/// &lt;param name="argCodeStr"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public string FineReportUrlParam(string argCodeStr)
{
    if (string.IsNullOrEmpty(argCodeStr))
    {
        return string.Empty;
    }

    string code = GenerateCode(argCodeStr);
    // CSharpCodeProvider objCSharpCodePrivoder = new CSharpCodeProvider();
    //// CSharpCompilation objCSharpCodePrivoder = new CSharpCompilation();
    //  CompilerParameters objCompilerParameters = new CompilerParameters();

    // objCompilerParameters.ReferencedAssemblies.Add("System.dll");
    // //objCompilerParameters.ReferencedAssemblies.Add("Newtonsoft.Json.dll");
    // objCompilerParameters.GenerateExecutable = false;
    // objCompilerParameters.GenerateInMemory = true;
    // CompilerResults cresult = objCSharpCodePrivoder.CompileAssemblyFromSource(objCompilerParameters, code);

    // // 通过反射，执行代码
    // Assembly objAssembly = cresult.CompiledAssembly;
    // object obj = objAssembly.CreateInstance("FineReport.UrlParam");
    // MethodInfo objMI = obj.GetType().GetMethod("GetParam");
    // return objMI.Invoke(obj, null)?.ToString();
    // Parse the source code into a syntax tree.
    var syntaxTree = CSharpSyntaxTree.ParseText(code);

    // Define the references that your compiled code will need.
    var references = new[]
    {
    MetadataReference.CreateFromFile(typeof(object).Assembly.Location), // mscorlib/System.Runtime.dll
    MetadataReference.CreateFromFile(typeof(Console).Assembly.Location), // For example, if you use Console.WriteLine
    // Add other necessary references here, for example:
    // MetadataReference.CreateFromFile(typeof(Newtonsoft.Json.JsonConvert).Assembly.Location) // Newtonsoft.Json.dll
};

    // Create a compilation object with the parsed code and references.
    var compilation = CSharpCompilation.Create(
        assemblyName: Path.GetRandomFileName(),
        syntaxTrees: new[] { syntaxTree },
        references: references,
        options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

    // Emit the compiled code into a memory stream.
    using (var ms = new MemoryStream())
    {
        var result = compilation.Emit(ms);

        if (!result.Success)
        {
            var failures = result.Diagnostics.Where(diagnostic =&gt;
                diagnostic.IsWarningAsError ||
                diagnostic.Severity == DiagnosticSeverity.Error);

            throw new Exception("Compilation failed: " + string.Join(Environment.NewLine, failures.Select(d =&gt; d.ToString())));
        }
        else
        {
            ms.Seek(0, SeekOrigin.Begin);

            // Load the compiled assembly in a separate context to avoid locking issues.

            var loadContext = new AssemblyLoadContext(null, isCollectible: true);
            var assembly = loadContext.LoadFromStream(ms);
            // Use reflection to create an instance of the type and invoke its method.
            Type? type = assembly.GetType("FineReport.UrlParam");
            if (type == null)
                throw new InvalidOperationException("Type 'FineReport.UrlParam' not found.");
            object obj = Activator.CreateInstance(type)!;
            MethodInfo? methodInfo = type.GetMethod("GetParam");
            if (methodInfo == null)
                throw new InvalidOperationException("Method 'GetParam' not found.");
            return methodInfo.Invoke(obj, null)?.ToString();

        }
    }
}

</code></pre>
<pre><code class="language-c#">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DingDingTest
{
    internal class ImageEditDomain
    {

        /// &lt;summary&gt;
        /// 剪去图片空余白边
        /// &lt;/summary&gt;
        /// &lt;param name="stream"&gt;源文件&lt;/param&gt;
        /// &lt;param name="WhiteBar"&gt;保留的白边，单位为像素&lt;/param&gt;
        /// &lt;param name="fullPath"&gt;保存到本地的地址&lt;/param&gt;
        public Bitmap CutImageWhitePart(Stream stream, int WhiteBar, string fullPath)
        {
            Bitmap bmp = new Bitmap(stream);
            int top = 0, left = 0;
            int right = bmp.Width, bottom = bmp.Height;
            Color white = Color.White;
            //寻找最上面的标线,从左(0)到右，从上(0)到下
            for (int i = 0; i &lt; bmp.Height; i++)//行
            {
                bool find = false;
                for (int j = 0; j &lt; bmp.Width; j++)//列
                {
                    Color c = bmp.GetPixel(j, i);
                    if (IsWhite(c))
                    {
                        top = i;
                        find = true;
                        break;
                    }
                }
                if (find) break;
            }
            //寻找最左边的标线，从上（top位）到下，从左到右
            for (int i = 0; i &lt; bmp.Width; i++)//列
            {
                bool find = false;
                for (int j = top; j &lt; bmp.Height; j++)//行
                {
                    Color c = bmp.GetPixel(i, j);
                    if (IsWhite(c))
                    {
                        left = i;
                        find = true;
                        break;
                    }
                }
                if (find) break; ;
            }
            // 寻找最下边标线，从下到上，从左到右
            for (int i = bmp.Height - 1; i &gt;= 0; i--)//行
            {
                bool find = false;
                for (int j = left; j &lt; bmp.Width; j++)//列
                {
                    Color c = bmp.GetPixel(j, i);
                    if (IsWhite(c))
                    {
                        bottom = i;
                        find = true;
                        break;
                    }
                }
                if (find) break;
            }
            //寻找最右边的标线，从上到下，从右往左
            for (int i = bmp.Width - 1; i &gt;= 0; i--)//列
            {
                bool find = false;
                for (int j = 0; j &lt;= bottom; j++)//行
                {
                    Color c = bmp.GetPixel(i, j);
                    if (IsWhite(c))
                    {
                        right = i;
                        find = true;
                        break;
                    }
                }
                if (find) break;
            }
            int iWidth = right - left + 2;
            int iHeight = bottom - top + 2;
            bmp = Cut(bmp, left, top, iWidth, iHeight, WhiteBar);
            return bmp;
        }

        /// &lt;summary&gt;
        /// 添加文字:MES系统自动发送
        /// &lt;/summary&gt;
        /// &lt;param name="bitmap"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public Bitmap AddWatermarkWord(Bitmap bitmap)
        {
            //添加MES系统标识
            string text = "MES系统自动发送";
            int fontSize = 10;
            Graphics g = Graphics.FromImage(bitmap);
            int rectWidth = text.Length * (fontSize + 10);
            int rectHeight = fontSize + 15;

            //声明矩形域
            Rectangle rectangle = new Rectangle(bitmap.Width - 200, bitmap.Height - 25, rectWidth, rectHeight);
            Font font = new Font("微软雅黑", fontSize, FontStyle.Bold); //定义字体
            SolidBrush backbrush = new SolidBrush(Color.Transparent);
            SolidBrush sbrushRed = new SolidBrush(Color.Red);
            var stringFormat = new StringFormat();
            stringFormat.Alignment = StringAlignment.Center;
            g.FillRectangle(backbrush, rectangle);
            g.DrawString(text, font, sbrushRed, rectangle, stringFormat);
            return bitmap;
        }

        /// &lt;summary&gt;
        /// 对图片进行裁剪
        /// &lt;/summary&gt;
        /// &lt;param name="b"&gt;要裁剪的图片&lt;/param&gt;
        /// &lt;param name="StartX"&gt;裁剪的X轴&lt;/param&gt;
        /// &lt;param name="StartY"&gt;裁剪的Y轴&lt;/param&gt;
        /// &lt;param name="iWidth"&gt;要裁剪的宽度&lt;/param&gt;
        /// &lt;param name="iHeight"&gt;要裁剪的高度&lt;/param&gt;
        /// &lt;param name="WhiteBar"&gt;保留的白边&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public Bitmap Cut(Bitmap b, int StartX, int StartY, int iWidth, int iHeight, int WhiteBar)
        {
            Bitmap bmpOut = new Bitmap(iWidth + 2 * WhiteBar, iHeight + 2 * WhiteBar, PixelFormat.Format24bppRgb);

            Graphics g = Graphics.FromImage(bmpOut);
            g.FillRectangle(Brushes.White, new Rectangle(0, 0, iWidth + 2 * WhiteBar, iHeight + 2 * WhiteBar));
            g.DrawImage(b, new Rectangle(WhiteBar, WhiteBar, iWidth, iHeight), new Rectangle(StartX, StartY, iWidth, iHeight), GraphicsUnit.Pixel);
            g.Dispose();
            return bmpOut;
        }

        /// &lt;summary&gt;
        /// 判断白色与否，非纯白色
        /// &lt;/summary&gt;
        /// &lt;param name="c"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public bool IsWhite(Color c)
        {
            if (c.R &lt; 245 || c.G &lt; 245 || c.B &lt; 245)
                return true;
            else return false;
        }
    }
}

</code></pre>
</blockquote>
<blockquote>
<h2 id="3使用钉钉机器人发送图片">3、使用钉钉机器人发送图片</h2>
<p>上一步，我们将帆软图片已经下载到本地了，那么就可以用钉钉机器人推送图片了。这边过程还是比较曲折的，查阅资料，我先使用了SendMessageWithImageAsync这个方法，但是推送到钉钉，确实表情包，无法放大查看图片。</p>
<p><img src="https://gitee.com/wind59/blog-file/raw/master/Springboot/Pictures/10.2.png" alt="image-20250107133451315" loading="lazy"></p>
<p>然后，我换了个格式使用SendMessageWithMarkDownAsync方法来推送markdown，这次图片可以正常放大来查看了。</p>
<p><img src="https://gitee.com/wind59/blog-file/raw/master/Springboot/Pictures/10.3.png" alt="image-20250107133643171" loading="lazy"></p>
<p>可是，当我将url换成我本地刚下载的帆软报表图片时，却发现推送到钉钉，显示如下。问了下百度发现，钉钉群机器人目前不支持直接推送本地图片，解决方法可以将图片放到钉钉服务器可以http访问的存储服务器上。这下难办了，因为总部安全的策略，这部分只能找总部寻求帮助了。</p>
<p><img src="https://gitee.com/wind59/blog-file/raw/master/Springboot/Pictures/10.4.png" alt="image-20250107133932522" loading="lazy"></p>
<pre><code class="language-c#">using System.Text;

namespace DingDingTest
{
    public class DingTalkClient
    {
        private readonly HttpClient _httpClient;
         // 钉钉机器人的Webhook URL
 private readonly string webhookUrl = "https://oapi.dingtalk.com/robot/send?access_token={token}";
 private readonly string title = "MES报障";

        public DingTalkClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
        }

        /// &lt;summary&gt;
        /// 发送图片
        /// &lt;/summary&gt;
        /// &lt;param name="webhookUrl"&gt;&lt;/param&gt;
        /// &lt;param name="imageUrl"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public async Task SendMessageWithImageAsync(string webhookUrl, string imageUrl)
        {
            var content = new StringContent($"{{ \"msgtype\": \"image\", \"image\": {{ \"picURL\": \"{imageUrl}\" }} }}", Encoding.UTF8, "application/json");
            // 发送POST请求
            var response = await _httpClient.PostAsync(webhookUrl, content);
            // 输出结果
            Console.WriteLine(await response.Content.ReadAsStringAsync());
        }

        /// &lt;summary&gt;
        /// 发送markdown
        /// &lt;/summary&gt;
        /// &lt;param name="webhookUrl"&gt;&lt;/param&gt;
        /// &lt;param name="imageUrl"&gt;&lt;/param&gt;
        /// &lt;param name="message"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public async Task SendMessageWithMarkDownAsync(string webhookUrl, string imageUrl, string message)
        {
            var content = new StringContent($"{{ \"msgtype\": \"markdown\", \"markdown\": {{ \"title\": \"{message}\", \"text\": \"![图片]({imageUrl})\" }} }}", Encoding.UTF8, "application/json");
            // 发送POST请求
            var response = await _httpClient.PostAsync(webhookUrl, content);
            // 输出结果
            Console.WriteLine(await response.Content.ReadAsStringAsync());
        }
    }
}

</code></pre>
</blockquote>
<blockquote>
<h2 id="4上传本地图片到gitee">4、上传本地图片到gitee</h2>
<p>在总部的帮助下，最后也是成功实现了功能，但是我一想，我们平时可以把本地图片上传到gitee，然后钉钉机器人推送的地址改成gitee的图片访问路径不也行吗，说干就干。查看gitee帮助文档。上传成功。</p>
<p><img src="https://gitee.com/wind59/blog-file/raw/master/Springboot/Pictures/10.5.png" alt="image-20250107134758636" loading="lazy"></p>
<pre><code class="language-c#">// 要发送的图片URL
 string imageUrl = $"https://gitee.com/{user}/{repos}/raw/{branch}/{path}";
</code></pre>
<pre><code class="language-c#">using System.Text;

namespace DingDingTest
{
    internal class UploadImage
    {
        private const string AccessToken = {你的令牌};
        private const string Repository = {你的仓库};
        private const string Branch = {你的分支};
        private const string BasePath = "gitee.com";
        private const string ApiPath = "/api/v5/repos/{user}/{repos}/contents/{path}";
        public async Task UploadImageAsync(string imagePath, string commitMessage)
        {
            var imageFileName = Path.GetFileName(imagePath);
            try
            {
                var url = {上传地址};
                using (var request = new HttpRequestMessage(HttpMethod.Post, url))
                {
                    string contentType = "application/json";
                    // 设置请求头中的ContentType
                    request.Headers.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue(contentType));
                    var data = new
                    {
                        access_token = AccessToken,
                        content = Convert.ToBase64String(System.IO.File.ReadAllBytes(imagePath)), // 这里应该放置你的Base64编码后的图片内容
                        message = commitMessage
                    };
                    string jsonBody = Newtonsoft.Json.JsonConvert.SerializeObject(data);
                    request.Content = new StringContent(jsonBody, Encoding.UTF8, contentType);
                    var client = new HttpClient();
                    client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("token", AccessToken);
                    HttpResponseMessage response = client.Send(request);
                    response.EnsureSuccessStatusCode(); // 抛出异常如果响应不是成功的
                    string responseBody = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                    Console.WriteLine(responseBody);
                }
            }
            catch (HttpRequestException e)
            {
                Console.WriteLine("\nException Caught!");
                Console.WriteLine("Message :{0} ", e.Message);
            }
        }
    }
}

</code></pre>
</blockquote>
<blockquote>
<h2 id="5使用quartz">5、使用Quartz</h2>
<p>添加Quartz,每三分钟执行测试一下，测试OK。</p>
<pre><code class="language-c#">using Quartz;
using Quartz.Impl;
using System;
using System.Threading.Tasks;

namespace DingDingTest
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            // 1. 创建Scheduler
            IScheduler scheduler = await StdSchedulerFactory.GetDefaultScheduler();

            // 2. 开启Scheduler
            await scheduler.Start();

            // 3. 创建作业
            IJobDetail job = JobBuilder.Create&lt;TestJob&gt;()
                .WithIdentity("myJob", "group1")
                .Build();

            // 4. 创建触发器
            var trigger = TriggerBuilder.Create()
                .WithIdentity("myTrigger", "group1")
                .StartNow() // 立即启动
                .WithSimpleSchedule(x =&gt; x
                    .RepeatForever() // 重复执行
                    .WithIntervalInMinutes(3)) // 每3min执行一次
                .Build();

            // 5. 将作业和触发器添加到调度器
            await scheduler.ScheduleJob(job, trigger);

            Console.WriteLine("Press any key to close the application");
            Console.ReadKey();

            // 6. 关闭Scheduler
            await scheduler.Shutdown();
        }
    }
}

</code></pre>
</blockquote>
<blockquote>
<h2 id="6总结">6、总结</h2>
<p>整体思路最后如下：</p>
<p>1、下载帆软报表图片到本地</p>
<p>2、上传图片到公网可ping通的服务器</p>
<p>3、钉钉机器人以markdown方式推送</p>
<p>踩坑如下：</p>
<p>1、因为之前下载帆软报表图片到本地，其中帆软的参数使用的外部脚本，所以使用了using Microsoft.CSharp包的CSharpCodeProvider，来动态执行外部C#脚本代码，来拼接查询的参数，但是因为版本的问题.Net 8 中CSharpCodeProvider被废弃了，所以换成了Microsoft.CodeAnalysis.CSharp。简单使用的话，上诉代码FineReportUrlParam方法可以直接拼接下传参</p>
<p>2、钉钉机器人无法上传本地图片（也不知道百度的对不对，或许有其他方式，哈哈）</p>
<p>3、 上传到gitee上时，HttpResponseMessage response = client.Send(request);可以看到我这边没有使用SendAsync，😭这是因为我使用了异步，vs执行到这里就会崩溃，更改成Send就好了，也不知道为啥。</p>
</blockquote>
<p>最好，前后搞了两三天还是实现了该功能，特此记录分享下。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="2.86181717027662" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-07 14:11">2025-01-07 14:11</span>&nbsp;
<a href="https://www.cnblogs.com/ziyansugar">子言sugar</a>&nbsp;
阅读(<span id="post_view_count">70</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18657519" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18657519);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18657519', targetLink: 'https://www.cnblogs.com/ziyansugar/p/18657519', title: 'C#笔记（1、钉钉机器人推送帆软报表图片）' })">举报</a>
</div>
        