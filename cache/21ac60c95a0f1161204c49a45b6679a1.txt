
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/san-mu/p/18944874" title="发布于 2025-06-23 20:59">
    <span role="heading" aria-level="2">论文阅读-MD-ML: Super Fast Privacy-Preserving Machine Learning for Malicious Security with a Dishonest Majority</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>这是上交团队发表在USENIX2024上的文章。</p>
<h3 id="1-介绍">1 介绍</h3>
<h4 id="11-mpc和ppml">1.1 MPC和PPML</h4>
<p>假设一个多方的场景，参与方分别持有数据<span class="math inline">\(x,y,z,w\)</span>，如果现在想要计算某个函数<span class="math inline">\(f(x,y,z,w)\)</span>，一种想法是引入可信方，让可信方帮忙进行计算。</p>
<p>而这样的问题实际上是多方安全计算（<span class="math inline">\(\text{MPC}\)</span>）想要研究的。<span class="math inline">\(\text{MPC}\)</span>就是想要在不引入可信方的情况下，通过各方协作计算出<span class="math inline">\(f\)</span>。</p>
<p>当<span class="math inline">\(f\)</span>是一个机器学习模型时，我们称之为隐私保护机器学习（<span class="math inline">\(\text{PPML}\)</span>）。</p>
<h4 id="12-安全模型分类">1.2 安全模型分类</h4>
<p>在<span class="math inline">\(\text{PPML}\)</span>里，根据敌手的能力可以分为：</p>
<ul>
<li>
<p>敌手只是对数据好奇，但不会对数据做任何修改，这称为半诚实的敌手；</p>
</li>
<li>
<p>敌手可能主动破坏数据，这称为恶意敌手。</p>
</li>
</ul>
<p>在恶意敌手情况下，能继续进行细分。这里假设参与方总数为<span class="math inline">\(n\)</span>，破坏的参与方数量为<span class="math inline">\(t\)</span>：</p>
<ul>
<li>
<p>当<span class="math inline">\(t&lt;n/2\)</span>，称为诚实多数；</p>
</li>
<li>
<p>当<span class="math inline">\(t\ge n/2\)</span>，称为不诚实多数。</p>
</li>
</ul>
<h4 id="13-ppml协议的一般化构造">1.3 PPML协议的一般化构造</h4>
<p>要提出一个<span class="math inline">\(\text{PPML}\)</span>协议，一般需要包括两部分：第一部分是针对基本操作比如加法和乘法的底层<span class="math inline">\(\text{MPC}\)</span>协议；第二部分是针对ML中特有的一些基本操作，比如向量点积、RELU需要的比较等。</p>
<p>有了以上两部分，就能去构造复杂的ML模型。</p>
<h4 id="14-本文贡献">1.4 本文贡献</h4>
<p>本文的主要贡献是：</p>
<ul>
<li>
<p>为<span class="math inline">\(\text{PPML}\)</span>设计了高效的协议：</p>
<ul>
<li>
<p>带截断的乘法</p>
</li>
<li>
<p>向量点积</p>
</li>
<li>
<p>矩阵乘法</p>
</li>
<li>
<p>安全比较</p>
</li>
</ul>
</li>
<li>
<p>首次在通用可组合（UC）框架下严格证明了所有协议的安全性。</p>
</li>
<li>
<p>对协议进行了实现和测试。</p>
</li>
</ul>
<h3 id="2-预备知识">2 预备知识</h3>
<h4 id="21-spdz秘密分享机制">2.1 SPDZ秘密分享机制</h4>
<p>定义：</p>
<p>每个参与方持有一个MAC密钥的均匀随机加法份额<span class="math inline">\(\alpha^i\leftarrow Z_{2^s}\)</span>，将加法份额相加能得到一个全局的MAC密钥<span class="math inline">\(\alpha=\overset{n}{\sum}\limits_{i=1}\alpha^i \space \text{mod} \space 2^{k+s}\)</span>。</p>
<p>假设元素<span class="math inline">\(x\in Z_{2^k}\)</span>是被<span class="math inline">\([\cdot]_{2^k}\)</span>共享的，那么每个参与方<span class="math inline">\(P_i\)</span>持有两个值<span class="math inline">\(x^i\in Z_{2^{k+s}},m_{x}^i\in Z_{2^{k+s}}\)</span>。其中<span class="math inline">\(x=\overset{n}{\sum}\limits_{i=1} x^i \space \text{mod}\space 2^k\)</span>是被共享的元素，<span class="math inline">\(m_x=\overset{n}{\sum}\limits_{i=1}m_{x}^i\space \text{mod}\space 2^{k+s}\)</span>是消息认证码。同时消息认证码满足：<span class="math inline">\(m_x=(\overset{n}{\sum}\limits_{i=1}x^i)\cdot \alpha \space \text{mod}\space 2^{k+s}\)</span>。</p>
<p>最终记<span class="math inline">\([x]_{2^k}=((x^1,\cdots,x^n),(m_{x}^1,\cdots,m_{x}^n))\)</span>，即将元素<span class="math inline">\(x\)</span>的分享表示成所有参与方持有的<span class="math inline">\(x\)</span>份额和MAC份额组合在一起的形式。当<span class="math inline">\(2^k\)</span>较大且上下文能明确时，将<span class="math inline">\([x]_{2^k}\)</span>简记为<span class="math inline">\([x]\)</span>。</p>
<br>
<p>秘密重构：</p>
<p>各参与方使用随机共享值<span class="math inline">\([r]\)</span>对<span class="math inline">\(x\)</span>的高<span class="math inline">\(s\)</span>位进行掩码，得到<span class="math inline">\([\tilde x]=[x]+2^k[r]\)</span>。用<span class="math inline">\(\tilde x^i,m_{\tilde x}^i\)</span>表示参与方<span class="math inline">\(P_i\)</span>的share和MAC share。</p>
<p>参与方会广播<span class="math inline">\(\tilde x^i\)</span>，进而进行计算：</p>
<p></p><div class="math display">\[\begin{aligned}
\overset{n}{\sum}\limits_{i=1}\tilde x^i \space \text{mod}\space 2^k&amp;=\tilde x\space \text{mod}\space 2^k \\
&amp;=(x+2^kr)\space \text{mod}\space 2^k \\
&amp;=x \space \text{mod}\space 2^k \\
&amp;=x
\end{aligned}
\]</div><p></p><p>过程<span class="math inline">\(\pi_{\text{MACCheck}}\)</span>会用来检查<span class="math inline">\(\text{MAC}\)</span>。</p>
<br>
<p>加法：</p>
<p><span class="math inline">\([x+y]=[x]+[y]\)</span>，加法是在本地计算的。</p>
<br>
乘法：
<p>分为两个阶段进行。</p>
<p>预处理截断：生成乘法三元组<span class="math inline">\(([a],[b],[c])\)</span>。</p>
<p>在线阶段：</p>
<ul>
<li>
<p>各参与方本地计算<span class="math inline">\([\delta_x]=[a]-[x],[\delta_y]=[b]-[y]\)</span>；</p>
</li>
<li>
<p>打开<span class="math inline">\(\delta_x,\delta_y\)</span>；</p>
</li>
<li>
<p>本地计算<span class="math inline">\([z]=[c]-\delta_x\cdot[b]-\delta_y\cdot[a]+\delta_x\cdot\delta_y\)</span>。</p>
</li>
</ul>
<h4 id="22-依赖于电路的预处理技术cdp">2.2 依赖于电路的预处理技术（CDP）</h4>
<p>核心思想：</p>
<ul>
<li>
<p>预处理阶段，参与方获得每条线路<span class="math inline">\(x\)</span>对应的一个值<span class="math inline">\([\lambda_x]\)</span>；</p>
</li>
<li>
<p>在线阶段，对于每个电路门，参与方需要根据输入线路的<span class="math inline">\(\Delta\)</span>，计算并打开输出线路的<span class="math inline">\(\Delta\)</span>，其中<span class="math inline">\(\Delta x=x+\lambda_x\)</span>。</p>
</li>
</ul>
<br>
<p><span class="math inline">\(\text{TurboSpeedz}\)</span>协议：</p>
<p><span class="math inline">\(\text{CDP}\)</span>来源于<span class="math inline">\(\text{TurboSpeedz}\)</span>协议，其使用的秘密分享与<span class="math inline">\(\text{SPD}Z_{2^k}\)</span>类似，只不过数据都定义在有限域而不是环上，记作<span class="math inline">\(&lt;\cdot&gt;\)</span>。</p>
<p>在预处理阶段，参与方需要准备一些依赖于电路的材料。</p>
<p>假设用<span class="math inline">\(x,y,z\)</span>表示电路中的线路。假设对于电路中每一条线路<span class="math inline">\(z\)</span>，参与方都有一个共享值<span class="math inline">\(&lt;\lambda_z&gt;\)</span>：</p>
<ul>
<li>
<p>如果<span class="math inline">\(z\)</span>不是加法门的输出线路，那么<span class="math inline">\(\lambda_z\)</span>是一个均匀随机值；</p>
</li>
<li>
<p>如果<span class="math inline">\(z\)</span>是一个输入线路为<span class="math inline">\(x,y\)</span>的加法门的输出线路，那么<span class="math inline">\(\lambda_z\)</span>定义为<span class="math inline">\(\lambda_z=\lambda_x+\lambda_y\)</span>。</p>
</li>
</ul>
<p>对于每个乘法门，假设参与方拥有一个共享乘法三元组<span class="math inline">\((&lt;a&gt;,&lt;b&gt;,&lt;c&gt;)\)</span>以及值<span class="math inline">\(\delta_x,\delta_y\)</span>，其中<span class="math inline">\(c=ab,\delta_x=a-\lambda_x,\delta_y=b-\lambda_y\)</span>。</p>
<p>在在线阶段，各方根据预处理阶段准备的材料进行计算。</p>
<p>对线路<span class="math inline">\(x_1\)</span>上的秘密值<span class="math inline">\(x\)</span>，参与方持有<span class="math inline">\(&lt;x&gt;\)</span>，且知道<span class="math inline">\(\Delta x=x+\lambda_x\)</span>。</p>
<p>对于输入为<span class="math inline">\(x,y\)</span>的加法门：参与方可以在本地计算<span class="math inline">\(&lt;z&gt;=&lt;x&gt;+&lt;y&gt;,\Delta z=\Delta x+\Delta y\)</span>。</p>
<p>对于输入为<span class="math inline">\(x,y\)</span>的乘法门：参与方的计算公式为<span class="math inline">\(&lt;z&gt;=(\Delta x+\delta_x)(\Delta y +\delta_y)-(\Delta y +\delta_y)&lt;a&gt;-(\Delta x+\delta_x)&lt;b&gt;+&lt;c&gt;\)</span>。</p>
<p>正确性证明：</p>
<p></p><div class="math display">\[\Delta x+\delta_x=(x+\lambda_x)+(a-\lambda_x)=x+a,\Delta_y+\delta_y=y+b
\]</div><p></p><p>那么等式右边为：<span class="math inline">\((x+a)(y+b)-(y+b)a-(x+a)b+ab=xy=z\)</span>。</p>
<p>本文为了使计算在环<span class="math inline">\(Z_{2^k}\)</span>上进行，将<span class="math inline">\(\text{CDP}\)</span>过程底层的秘密分享机制从<span class="math inline">\(&lt;&gt;\)</span>改为<span class="math inline">\([]\)</span>，这两种分享其实就是把数据范围改换了一下。</p>
<br>
<p>在本文具体使用的<span class="math inline">\(\text{CDP}\)</span>协议中，会依赖<span class="math inline">\(F_{Prep}\)</span>函数。该函数有3个命令：</p>
<ul>
<li>
<p>Triple：生成一个乘法三元组</p>
</li>
<li>
<p>Rand：为所有参与方生成一个随机共享的元素</p>
</li>
<li>
<p>Input：生成一个随机共享的元素<span class="math inline">\([r]\)</span>，且某一方确切知道r</p>
</li>
</ul>
<br>
<p>本文使用的算术电路预处理协议<span class="math inline">\(\Pi_{\text{PrepArith}}\)</span>：</p>
<p>各参与方按照电路拓扑顺序进行操作，这样能保证电路输入已经在前面的门得到。</p>
<p>输入：对于参与方<span class="math inline">\(P_i\)</span>的每条输入线路<span class="math inline">\(x\)</span>，通过调用<span class="math inline">\(F_{Prep}\)</span>的Input命令，<span class="math inline">\(P_i\)</span>能知道<span class="math inline">\(\lambda_x\)</span>，所有参与方获得对应的共享值<span class="math inline">\([\lambda_x]\)</span>。</p>
<p>加法：对于输入线路为<span class="math inline">\(x,y\)</span>且输出线路为<span class="math inline">\(z\)</span>的加法门，所有参与方在本地计算<span class="math inline">\([\lambda_z]=[\lambda_x]+[\lambda_y]\)</span>。</p>
<p>乘法：对于输入线路为<span class="math inline">\(x,y\)</span>且输出线路为<span class="math inline">\(z\)</span>的乘法门，参与方执行以下操作：</p>
<ul>
<li>
<p>调用<span class="math inline">\(F_{Prep}\)</span>的Triple命令，获取乘法三元组<span class="math inline">\(([a],[b],[c])\)</span>；</p>
</li>
<li>
<p>在本地计算<span class="math inline">\([\delta_x]=[a]-[\lambda_x],[\delta_y]=[b]-[\lambda_y]\)</span>；</p>
</li>
<li>
<p>调用<span class="math inline">\(F_{Prep}\)</span>的Rand命令，获取<span class="math inline">\([\lambda_z],\lambda_z\leftarrow Z_{2^k}\)</span>；</p>
</li>
</ul>
<p>此时，对于一个乘法门，各参与方拥有<span class="math inline">\([a],[b],[c],[\lambda_z],[\delta_x],[\delta_y]\)</span>。</p>
<p>输出：各参与方公开每个乘法门的共享<span class="math inline">\([\delta]\)</span>，让所有参与方都能知道这些值。并运行<span class="math inline">\(\pi_{MACCheck}\)</span>检查已经公开值的MAC。</p>
<p><span class="math inline">\(\Pi_{\text{PrepArith}}\)</span>的目的：</p>
<ul>
<li>
<p>为每条线路生成共享的<span class="math inline">\([\lambda]\)</span>；</p>
</li>
<li>
<p>为每个乘法门生成一个共享的乘法三元组；</p>
</li>
<li>
<p>为每个乘法门生成两个公开的<span class="math inline">\(\delta\)</span>（<span class="math inline">\(\delta_x,\delta_y\)</span>）；</p>
</li>
</ul>
<br>
<p>本文使用的算术电路在线协议<span class="math inline">\(\Pi_{\text{OnlineArith}}\)</span>：</p>
<p>初始化：参与方使用电路调用<span class="math inline">\(F_{PrepArith}\)</span>，以获取<span class="math inline">\(\delta\)</span>值、共享的<span class="math inline">\([\lambda]\)</span>值以及每个门电路的乘法三元组。然后，参与方按照拓扑顺序进行操作。</p>
<p>输入：为了让参与方共享输入值<span class="math inline">\(x\)</span>，<span class="math inline">\(P_i\)</span>计算并广播<span class="math inline">\(\Delta x=x+\lambda_x\)</span>，那么所有参与方获得<span class="math inline">\(\Delta x\)</span>；</p>
<p>加法：对于输入线路为<span class="math inline">\(x,y\)</span>且输出线路为<span class="math inline">\(z\)</span>的加法门，参与方在本地计算<span class="math inline">\(\Delta z=\Delta x+\Delta y\)</span>。</p>
<p>乘法：对于输入线路为<span class="math inline">\(x,y\)</span>且输出线路为<span class="math inline">\(z\)</span>的乘法门，所有参与方执行以下操作：</p>
<ul>
<li>
<p>在本地计算<span class="math inline">\([\Delta z]=(\Delta x+\delta_x)(\Delta y+\delta_y)-(\Delta y+\delta_y)[a]-(\Delta x+\delta_x)[b]+[c]+[\lambda_z]\)</span>；</p>
</li>
<li>
<p>公开<span class="math inline">\([\Delta z]\)</span>，得到<span class="math inline">\(\Delta z\)</span>；</p>
</li>
</ul>
<p>输出：为了输出线路<span class="math inline">\(x\)</span>上的值，所有参与方执行以下操作：</p>
<ul>
<li>在本地计算<span class="math inline">\([x]=\Delta x-[\lambda_x]\)</span>并公开。</li>
</ul>
<p><span class="math inline">\(\Pi_{\text{OnlineArith}}\)</span>的目的：</p>
<ul>
<li>
<p>获取每条线路的<span class="math inline">\(\Delta\)</span>；</p>
</li>
<li>
<p>得到输入<span class="math inline">\(x\)</span>的秘密分片；</p>
</li>
</ul>
<h3 id="3-ppml协议">3 PPML协议</h3>
<p>核心思想是利用<span class="math inline">\(\text{CDP}\)</span>来改进后续的协议。</p>
<h4 id="31-带截断的乘法">3.1 带截断的乘法</h4>
<p>首先来看传统的截断，其目的是将乘法未截断的值<span class="math inline">\([z']\)</span>截断为<span class="math inline">\([z]\)</span>。其中<span class="math inline">\(z=z'/2^d\)</span>。</p>
<p>使用的方法如下：</p>
<p>预处理阶段：生成一对共享的随机值<span class="math inline">\(([r^{'}],[r])\)</span>，其中<span class="math inline">\(r=r^{'}/2^d\)</span>。</p>
<p>在线阶段：</p>
<ul>
<li>
<p>参与方计算<span class="math inline">\([c^{'}]=[z^{'}]+[r^{'}]\)</span>；</p>
</li>
<li>
<p>计算<span class="math inline">\(c=c^{'}/2^d\)</span>；</p>
</li>
<li>
<p>本地计算<span class="math inline">\([z]=c-[r]\)</span>。</p>
</li>
</ul>
<br>
<p>观察<span class="math inline">\(\Pi_{\text{OnlineArith}}\)</span>，发现已经公开了<span class="math inline">\(\Delta z^{'}=z^{'}+\lambda_z^{'}\)</span>。假设参与方拥有<span class="math inline">\([\lambda_z]\)</span>，那么可以计算：</p>
<p></p><div class="math display">\[z=\Delta z-\lambda_z=\Delta z^{'}/2^d-\lambda_z^{'}/2^d=z^{'}/2^d
\]</div><p></p><p>即将<span class="math inline">\([\lambda_z^{'}],[\lambda_z]\)</span>不仅充当掩码，还充当截断对。</p>
<p>本文使用<span class="math inline">\(F_{edaBits}\)</span>来获得该截断对。</p>
<br>
<p>具体的带截断乘法过程<span class="math inline">\(\pi_{\text{MultTrunc}}\)</span>：</p>
<p>输入线路为<span class="math inline">\(x,y\)</span>，输出线路为<span class="math inline">\(z\)</span>，目标是计算<span class="math inline">\(x,y\)</span>的乘积并进行截断。</p>
<p>预处理阶段：</p>
<ul>
<li>
<p>参与方执行<span class="math inline">\(F_{Prep}\)</span>的Triple命令获得<span class="math inline">\(([a],[b],[c])\)</span>；</p>
</li>
<li>
<p>参与方计算<span class="math inline">\([\delta_x]=[a]-[\lambda_x],[\delta_y]=[b]-[\lambda_y]\)</span>并公开<span class="math inline">\(\delta_x,\delta_y\)</span>；</p>
</li>
<li>
<p>参与方对输入<span class="math inline">\((k-d)\)</span>执行<span class="math inline">\(F_{edaBits}\)</span>，获得<span class="math inline">\([\lambda_z]\)</span>及其位分解<span class="math inline">\(\lbrace [\lambda_{z,i}]_2\rbrace_{i=0}^{k-d-1}\)</span>；</p>
</li>
<li>
<p>参与方对输入<span class="math inline">\(d\)</span>执行<span class="math inline">\(F_{edaBits}\)</span>，获得<span class="math inline">\([u]\)</span>及其位分解<span class="math inline">\(\lbrace [u_i]_2\rbrace_{i=0}^{d-1}\)</span>；</p>
</li>
<li>
<p>参与方在本地计算<span class="math inline">\([\lambda_{z^{'}}]=2^d\cdot [\lambda_z]+[u]\)</span>；</p>
</li>
</ul>
<p>在线阶段：</p>
<ul>
<li>
<p>参与方在本地计算<span class="math inline">\([\Delta z^{'}]=(\Delta x+\delta_x)(\Delta y+\delta_y)-(\Delta y+\delta y)[a]-(\Delta x+\delta x)[b]+[c]+[\lambda_{z^{'}}]\)</span>；</p>
</li>
<li>
<p>参与方公开<span class="math inline">\([\Delta z^{'}]\)</span>得到<span class="math inline">\(\Delta z^{'}\)</span>；</p>
</li>
<li>
<p>参与方在本地计算<span class="math inline">\(\Delta z=\Delta z^{'}/2^d\)</span>；</p>
</li>
</ul>
<p>之前方法需要先进行乘法，再进行截断。新方法在乘法过程中，将两个过程进行结合，计算得到<span class="math inline">\(\Delta z^{'}\)</span>并打开后，直接本地截断。</p>
<p>由于乘法通信量是2elements/party，截断通信量为1elements/patry，那么原方法通信量就是3elements/party，且需要2轮交互。而本文方法通信量为1element/party，且仅需一轮交互。</p>
<h4 id="32-向量点积">3.2 向量点积</h4>
<p>为了方便，规定可以对向量使用<span class="math inline">\([\cdot]\)</span>表示法，<span class="math inline">\([\vec \lambda]\)</span>表示向量<span class="math inline">\(\lambda\)</span>的每个元素都是通过<span class="math inline">\([\cdot]\)</span>进行秘密共享的。</p>
<p>向量乘法的目的是输入长度为<span class="math inline">\(m\)</span>的向量<span class="math inline">\(\vec x,\vec y\)</span>，输出线路<span class="math inline">\(z\)</span>的值，其中<span class="math inline">\(z=\vec x\cdot \vec y\)</span>。一种简单方法是针对每一个底层乘法执行<span class="math inline">\(\Pi_{OnlineArith}\)</span>，但这样会导致在线通信量与向量长度呈线性关系。</p>
<p>向量点积过程<span class="math inline">\(\pi_{\text{DotProduct}}\)</span>：</p>
<p>对于一个输入线路为长度为<span class="math inline">\(m\)</span>的向量<span class="math inline">\(x,y\)</span>的点积门：</p>
<p>预处理阶段：</p>
<ul>
<li>
<p>参与方执行<span class="math inline">\(F_{Prep}\)</span>的Rand方法，获得<span class="math inline">\([\lambda_z],\lambda_z\leftarrow Z_{2^k}\)</span>，随机份额将用于在线阶段对最终结果进行掩码；</p>
</li>
<li>
<p>参与方执行<span class="math inline">\(F_{Prep}\)</span>的Triple方法<span class="math inline">\(m\)</span>次获得<span class="math inline">\(m\)</span>个三元组，得到<span class="math inline">\([\vec a],[\vec b],[\vec c]\)</span>，其中第<span class="math inline">\(i\)</span>次得到的三元组是<span class="math inline">\(([\vec a[i]]),[\vec b[i]],[\vec c[i]]\)</span>；</p>
</li>
<li>
<p>参与方计算<span class="math inline">\([\vec {\delta_x}]=[\vec a]-[\vec{\lambda_x}],[\vec {\delta_y}]=[\vec b]-[\vec {\lambda_y}]\)</span>并公开；</p>
</li>
</ul>
<p>在线阶段：</p>
<ul>
<li>
<p>参与方在本地计算<span class="math inline">\([\Delta z]=\overset{m}{\sum}\limits_{i=1}((\vec {\Delta x}[i]+\vec {\delta_x}[i])(\vec {\Delta y}[i]+\vec {\delta_y}[i])-(\vec {\Delta y}[i]+\vec {\delta_y}[i])[\vec a[i]]-(\vec {\Delta x}[i]+\vec {\delta_x}[i])[\vec b[i]]+[\vec c[i]])+[\lambda_z]\)</span>；</p>
</li>
<li>
<p>参与方公开<span class="math inline">\([\Delta z]\)</span>获得<span class="math inline">\(\Delta z\)</span>；</p>
</li>
</ul>
<p>简单方法中，每对<span class="math inline">\(x_i,y_i\)</span>做乘法的通信量是2elements/party，那么长度为<span class="math inline">\(m\)</span>的向量乘法需要的通信量就是2m/elements/party。而本文方法通信量为1element/party。</p>
<p>在向量点积优化的基础上，就可以去优化其他操作，比如矩阵乘法、带截断的向量点积、带截断的矩阵乘法等。</p>
<h4 id="33-安全比较">3.3 安全比较</h4>
<p>首先介绍掩码比较技术，目的是比较<span class="math inline">\(x\)</span>与0的大小：</p>
<p>预处理阶段：</p>
<ul>
<li>参与方执行<span class="math inline">\(F_{\text{edaBits}}\)</span>得到共享随机掩码<span class="math inline">\([r]\)</span>及其位分解<span class="math inline">\(\lbrace [r_i]_2\rbrace_{i=0}^{k-1}\)</span>；</li>
</ul>
<p>在线阶段：</p>
<ul>
<li>
<p>参与方计算<span class="math inline">\([c]=[x]+[r]\)</span>并公开<span class="math inline">\([c]\)</span>；</p>
</li>
<li>
<p>参与方使用逐位比较电路来比较<span class="math inline">\(c\)</span>和<span class="math inline">\(\lbrace [r_i]_2\rbrace_{i=0}^{k-1}\)</span>，获得<span class="math inline">\([z]_2,z=(c&lt;r)=(x+r&lt;r)=(x&lt;0)\)</span>；</p>
</li>
<li>
<p>使用<span class="math inline">\(B2A\)</span>协议将<span class="math inline">\([z]_2\)</span>转为<span class="math inline">\([z]\)</span>；</p>
</li>
</ul>
<br>
<p>安全比较具体过程<span class="math inline">\(\pi_{\text{LTZ}}\)</span>：</p>
<p>参与方输入为<span class="math inline">\([\lambda_x],\Delta x(\Delta x=\lambda_x+x)\)</span>，希望得到<span class="math inline">\([\lambda_z],\Delta z\)</span>。</p>
<p><span class="math inline">\(\text{LTZ}\)</span>门的输入为线路<span class="math inline">\(x\)</span>，目的是在线路<span class="math inline">\(z\)</span>得到比较结果<span class="math inline">\(z=(x&lt;0)\)</span>。</p>
<p>预处理阶段：</p>
<ul>
<li>
<p>参与方在输入<span class="math inline">\(k\)</span>上执行<span class="math inline">\(F_{edaBits}\)</span>获得<span class="math inline">\([r]\)</span>及其位分解；</p>
</li>
<li>
<p>参与方计算<span class="math inline">\([\delta_x]=[r]-[\lambda_x]\)</span>，并公开<span class="math inline">\(\delta_x\)</span>；</p>
</li>
<li>
<p>参与方执行<span class="math inline">\(F_{Prep}\)</span>的Rand方法获得<span class="math inline">\([\lambda_z],\lambda_z\leftarrow Z_{2^k}\)</span>；</p>
</li>
</ul>
<p>在线阶段：</p>
<ul>
<li>
<p>参与方执行<span class="math inline">\(\pi_{BitLT}(\Delta x+\delta_x,\lbrace [r_i]_2\rbrace_{i=0}^{k-1})\)</span>来获得<span class="math inline">\([z]_2\)</span>；</p>
</li>
<li>
<p>参与方执行<span class="math inline">\(B2A\)</span>将<span class="math inline">\([z]_2\)</span>转为<span class="math inline">\([z]\)</span>；</p>
</li>
<li>
<p>参与方在本地计算<span class="math inline">\([\Delta z]=[\lambda_z]+[z]\)</span>；</p>
</li>
<li>
<p>参与方打开<span class="math inline">\(\Delta z\)</span>。</p>
</li>
</ul>
<h3 id="4-实验">4 实验</h3>
<p>实验聚焦两方计算场景，将MD-ML与<span class="math inline">\(\text{SPD}Z_{2^k}\)</span>进行比较。</p>
<p>在线阶段，搭建AlexNet模型在CIFAR-10, Tiny ImageNet, ImageNet上做推理，结果如下：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202506/3389949-20250623195421387-1433875894.png" width="50%"></div>
<p>搭建ResNet-18模型在CIFAR-10上做推理，由于<span class="math inline">\(\text{SPD}Z_{2^k}\)</span>没有做这组实验，仅呈现了MD-ML的效果：</p>
<div align="center"><img src="https://img2024.cnblogs.com/blog/3389949/202506/3389949-20250623195538784-641509922.png" width="50%"></div>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.009027777777777777" data-date-updated="2025-06-23 21:12">2025-06-23 20:59</span>&nbsp;
<a href="https://www.cnblogs.com/san-mu">叁沐</a>&nbsp;
阅读(<span id="post_view_count">68</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18944874);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18944874', targetLink: 'https://www.cnblogs.com/san-mu/p/18944874', title: '论文阅读-MD-ML: Super Fast Privacy-Preserving Machine Learning for Malicious Security with a Dishonest Majority' })">举报</a>
</div>
        