
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TianTianChaoFangDe/p/18766146" title="发布于 2025-03-11 21:28">
    <span role="heading" aria-level="2">【CF VP记录】Codeforces Round 1008 (Div. 2)</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><a href="https://codeforces.com/contest/2078" title="比赛链接" target="_blank" rel="noopener nofollow">比赛链接</a><br>
本文原文发布于博客园，如您在其他平台刷到此文，请前往<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18766146" title="博客园" target="_blank">博客园</a>获得更好的阅读体验。<br>
跳转链接：<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18766146" target="_blank">https://www.cnblogs.com/TianTianChaoFangDe/p/18766146</a></p>
<h2 id="开题--补题情况">开题 + 补题情况</h2>
<p>坠机场，要是赛时打了的话就又回青了，前两题很快开出来了，第三题脑残了，一开始觉得只需要构造第一个数就行了然后爽吃两发罚时。<br>
<img src="https://img2024.cnblogs.com/blog/3572902/202503/3572902-20250311212641666-93892123.png" alt="image" loading="lazy"></p>
<h2 id="a-final-verdict">A. Final Verdict</h2>
<p>瞎猜的，只要所有数的和除以 <span class="math inline">\(n\)</span> 得到的值为 <span class="math inline">\(x\)</span> 一定有解，暂时没想到如何证明，有空再来证一证。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf 2e18
#define int long long

const int N = 2e5 + 9;

void solve()
{
    int n, x;std::cin &gt;&gt; n &gt;&gt; x;
    std::vector&lt;int&gt; a(n);

    int sum = 0;
    for(auto &amp;i : a) {
        std::cin &gt;&gt; i;
        sum += i;
    }

    if(sum % n == 0 &amp;&amp; sum / n == x) {
        std::cout &lt;&lt; "YES\n";
    } else {
        std::cout &lt;&lt; "NO\n";
    }
}
</code></pre>
</details>  
<h2 id="b-vicious-labyrinth">B. Vicious Labyrinth</h2>
<p>题目要让所有人离 <span class="math inline">\(n\)</span> 的距离最小化。<br>
我们对 <span class="math inline">\(k\)</span> 分奇偶讨论：</p>
<ul>
<li>如果 <span class="math inline">\(k\)</span> 为奇数，那么我们只需要把 <span class="math inline">\(n\)</span> 传送到 <span class="math inline">\(n - 1\)</span>，其余位置传送到 <span class="math inline">\(n\)</span>，那么经过一次传送后，就只有一个人在 <span class="math inline">\(n - 1\)</span> 的位置，其他人均在 <span class="math inline">\(n\)</span> 的位置，接下来偶数次只会在这两个位置反复横跳，答案为 <span class="math inline">\(1\)</span>。</li>
<li>如果 <span class="math inline">\(k\)</span> 为偶数，那么我们把 <span class="math inline">\(n - 1\)</span> 传送到 <span class="math inline">\(n\)</span>，其余位置传送到 <span class="math inline">\(n - 1\)</span>，这样再来一次传送后，就只有一个人在 <span class="math inline">\(n - 1\)</span> 的位置，其他人均在 <span class="math inline">\(n\)</span> 的位置，接下来偶数次只会在这两个位置反复横跳，答案为 <span class="math inline">\(1\)</span>。</li>
</ul>
<p>由于不能往原位置传送，所以至少有一个人无法抵达 <span class="math inline">\(n\)</span>，因此答案至少为 <span class="math inline">\(1\)</span>，所以上述构造为最优解。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf 2e18
#define int long long

const int N = 2e5 + 9;

void solve()
{
    int n, k;std::cin &gt;&gt; n &gt;&gt; k;

    if(k &amp; 1) {
        for(int i = 1;i &lt;= n;i ++) {
            if(i == n)std::cout &lt;&lt; n - 1 &lt;&lt; ' ';
            else std::cout &lt;&lt; n &lt;&lt; ' ';
        }
    } else {
        for(int i = 1;i &lt;= n;i ++) {
            if(i == n - 1)std::cout &lt;&lt; n &lt;&lt; ' ';
            else std::cout &lt;&lt; n - 1 &lt;&lt; ' ';
        }
    }

    std::cout &lt;&lt; '\n';
}
</code></pre>
</details>  
<h2 id="c-breach-of-faith">C. Breach of Faith</h2>
<p>一开始以为只要把第一项当成未知项，然后把后面的数排一下序求一下就行了，直到我搓出了这个样例 <span class="math inline">\(2, 3, 4, 5\)</span>，这个样例按这个想法来的话，求出来的值是 <span class="math inline">\(-2\)</span>，显然不符合题意，并且除了这种情况，还有可能导致数字重复，同样不符合题意。<br>
对于此题，我们对题目中的式子进行变形：<span class="math inline">\(0 = -a_1 + a_2 -a_3 + ... +a_{2 \times n} - a_{2 \times n + 1}\)</span>。<br>
我们首先对所给 <span class="math inline">\(b\)</span> 数组进行一下从小到大排序，因为这样可以一减一加后是正数，更容易命中答案（其实这个也是猜的，为什么要排序具体的也没细证）。<br>
然后，我们对上面那个式子枚举每一项作为消失项，通过对上面的新式子进行移项求出这一项的值，然后判断一下这个值是否合法，如果合法，这就是满足题意的构造。<br>
对于移项后其他项的和，可以通过记录奇偶前缀和来快速求出。<br>
时间复杂度：<span class="math inline">\(O(n \log n)\)</span>，<span class="math inline">\(\log n\)</span> 来源于我使用了 map 记录一个数字是否出现过。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define inf 2e18
#define int long long

const int N = 2e5 + 9;

void solve()
{
    int n;std::cin &gt;&gt; n;
    std::vector&lt;int&gt; a(2 * n + 2), b(2 * n + 1);
    std::map&lt;int, bool&gt; vis;

    for(int i = 1;i &lt;= 2 * n;i ++) {
        std::cin &gt;&gt; b[i];
        vis[b[i]] = true;
    }

    sort(b.begin() + 1, b.end());

    std::vector&lt;int&gt; preodd(2 * n + 2, 0), preeve(2 * n + 2, 0);

    for(int i = 1;i &lt;= 2 * n;i ++) {
        if(i &amp; 1) {
            preodd[i] = preodd[i - 1] + b[i];
            preeve[i] = preeve[i - 1];
        }
        else {
            preodd[i] = preodd[i - 1];
            preeve[i] = preeve[i - 1] + b[i];
        } 
    }

    for(int i = 1;i &lt;= 2 * n + 1;i ++) {
        int ans = 0;

        ans += preodd[i - 1];
        ans -= preeve[i - 1];

        ans += preeve[2 * n] - preeve[i - 1];
        ans -= preodd[2 * n] - preodd[i - 1];

        if(i &amp; 1) {
            ans = -ans;
        }

        if(!vis.count(ans) &amp;&amp; ans &gt; 0) {
            for(int j = 1;j &lt; i;j ++) {
                a[j] = b[j];
            }

            a[i] = ans;

            for(int j = i;j &lt;= 2 * n;j ++) {
                a[j + 1] = b[j];
            }
            break;
        }
    }

    for(int i = 1;i &lt;= 2 * n + 1;i ++) {
        std::cout &lt;&lt; a[i] &lt;&lt; " ";
    }

    std::cout &lt;&lt; '\n';
}
</code></pre>
</details>  

</div>
<div id="MySignature" role="contentinfo">
    <!-- 版权保护 -->
<div style="background:#ffcccc; color:#0; font-size:small;">
    <p>
            作者：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>
    </p>
    <p>
            出处：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">https://www.cnblogs.com/TianTianChaoFangDe</a>
    </p>
    <p>
            关于作者：ACMer，算法竞赛爱好者
    </p>
    <p>
             本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显醒目位置给出,
             <a href="#" onclick="Curgo()" style="background:#b6ff00; color:#0; font-size:medium;">原文链接</a>
             如有问题， 可邮件（1005333612@qq.com）咨询.
    </p>
    
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5298997745960649" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-11 22:11">2025-03-11 21:28</span>&nbsp;
<a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>&nbsp;
阅读(<span id="post_view_count">16</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18766146" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18766146);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18766146', targetLink: 'https://www.cnblogs.com/TianTianChaoFangDe/p/18766146', title: '【CF VP记录】Codeforces Round 1008 (Div. 2)' })">举报</a>
</div>
        