
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/18713770" title="发布于 2025-02-13 21:16">
    <span role="heading" aria-level="2">水往低处流：最大流的最高标号预留推进算法（HLPP）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>上期回顾：<a href="https://www.cnblogs.com/ofnoname/p/18678895" target="_blank">https://www.cnblogs.com/ofnoname/p/18678895</a></p>
<p>之前我们已经介绍了最大流问题的基本定义，让从源点流出的总流量达到最大，同时不违反任何管道的运输能力限制。学习了最大流最小割定理、增广路径与残量网络的构建方法，以及如何利用这些概念实现 EK 算法。EK 算法通过每次使用 BFS 寻找从源点到汇点的最短增广路径，保证了算法在有限步内终止，但是频繁的路径搜索会导致效率不高。</p>
<p>经典 Ford-Fulkerson 方法通过不断寻找<strong>增广路径</strong>（残量网络中 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(t\)</span> 的路径）来增加流量，通过改进为 Dinic 和 ISAP 后，在随机图上很快，但在某些情况下，但其效率存在明显瓶颈：</p>
<p>例如，在 Zig-zag 图等特殊构造中，DFS/BFS 可能总是选择低效的增广路径。</p>
<p>每次增广至少增加 1 单位流量，最坏时间复杂度为 <span class="math inline">\(O(|E| \cdot |f_{max}|)\)</span>，其中 <span class="math inline">\(|f_{max}|\)</span> 是最大流量值。对于较稠密图和特殊构造的图，极容易达到最坏情况。</p>
<p>这些缺陷催生了更高效的算法 —— <strong>Push-Relabel 框架</strong>，它不再依赖增广路径搜索，而是通过局部操作直接模拟流体的重力运动。接下来我们将深入解析这一革命性的思路。</p>
<h2 id="push-relabel--像洪水一样思考">Push-Relabel —— 像洪水一样思考</h2>
<h4 id="从修水管到造瀑布">从“修水管”到“造瀑布”</h4>
<p>想象你是一名城市规划师，传统增广路算法就像在复杂的下水道系统中<strong>一节一节地拼接管道</strong>，必须找到一条完整的从水源到水库的路径才能放水。而 Push-Relabel 则是一场<strong>人为制造的洪水</strong>——你不再关心全局路径，而是直接让水从高处向低处倾泻，甚至临时造山抬高地势让水流改道！</p>
<p>这种思维的颠覆性在于：</p>
<ul>
<li><strong>局部性</strong>：每次只需关注单个节点及其邻居的状态</li>
<li><strong>异步性</strong>：不同区域的水流可以独立推进</li>
<li><strong>容错性</strong>：源点和汇点通常特殊处理，而其他节点允许暂时违反流量守恒，入大于出（后续再修正）</li>
</ul>
<hr>
<h4 id="核心概念">核心概念</h4>
<p>在执行 Push-Relabel 过程时，中间状态下每个节点有以下两个状态：</p>
<p><strong>(1) 高度函数（Height Function）——地形的海拔</strong><br>
给每个节点 <span class="math inline">\(u\)</span> 分配一个高度值 <span class="math inline">\(h(u)\)</span>，想象这是该点的海拔高度。算法运行时，水流<strong>只能从高处流向低处</strong>（严格来说是流向高度<strong>恰好低1</strong>的邻居）。惯例上，初始时，源点 <span class="math inline">\(s\)</span> 被固定到“云端”（高度为 <span class="math inline">\(|V|\)</span>），而汇点 <span class="math inline">\(t\)</span> 和其他点“海平面”（高度为0）。高度会在运行时被修改。</p>
<p><strong>(2) 超额流（Excess Flow）——节点的蓄水池</strong><br>
每个非源点汇点的节点 <span class="math inline">\(u\)</span> 维护一个超额流 <span class="math inline">\(e(u)\)</span>，表示该点当前存储的未分配水量（入减出）。只有源点 <span class="math inline">\(s\)</span> 和汇点 <span class="math inline">\(t\)</span> 可以无限产生/吸收水（<span class="math inline">\(e(s)=+\infty, e(t)=-\infty\)</span>），其他节点必须通过<strong>Push</strong>操作将超额水最终全部流向低处。<br>
<img src="https://img2024.cnblogs.com/blog/1545207/202502/1545207-20250213210810262-1607297777.png" alt="image" loading="lazy"></p>
<p>（想象节点是蓄水池，高度差形成瀑布，池子满了就会溢出）</p>
<hr>
<h4 id="两大基本操作">两大基本操作</h4>
<p><strong>操作一：Push（推送）—— 瀑布效应</strong></p>
<p>源点需要特殊处理，它可以无限往外流水。所以初始化时让源点无视高度差向所有出边灌水。</p>
<p>而当普通节点 <span class="math inline">\(u\)</span> 有超额流（<span class="math inline">\(e(u)&gt;0\)</span>），且存在邻居 <span class="math inline">\(v\)</span> 满足：</p>
<p></p><div class="math display">\[h(u) = h(v) + 1 \quad \text{且} \quad (u,v) \text{ 在残量网络中有剩余容量} 
\]</div><p></p><p>则可以将 <span class="math inline">\(\delta = \min(e(u), c_f(u,v))\)</span> 单位流量推送到 <span class="math inline">\(v\)</span>，效果相当于：</p>
<ul>
<li><span class="math inline">\(e(u) \leftarrow e(u) - \delta\)</span></li>
<li><span class="math inline">\(e(v) \leftarrow e(v) + \delta\)</span></li>
<li>更新残量网络（正向边减 <span class="math inline">\(\delta\)</span>，反向边加 <span class="math inline">\(\delta\)</span>）</li>
</ul>
<p>即每个节点都可以把自己的多余流量向周围高度刚好少 1 的节点推送完。</p>
<hr>
<p><strong>操作二：Relabel（重贴高度）—— 人造山峰</strong><br>
当节点 <span class="math inline">\(u\)</span> 有超额流，但<strong>所有邻居的海拔都不低于它</strong>（无法形成瀑布），那么他多出来的水就放不出去了，此时必须“抬高地形”：</p>
<p></p><div class="math display">\[h(u) \leftarrow 1 + \min\{ h(v) \mid (u,v) \in E_f \} 
\]</div><p></p><p>将高度修改为周围节点中的最小高度加一这相当于在 <span class="math inline">\(u\)</span> 下方突然造出一座更高的山，迫使水流找到新的出口。显然高度只会不断升高。</p>
<p><strong>戏剧性场景</strong>：</p>
<ul>
<li><span class="math inline">\(u\)</span> 当前高度3米，蓄水5吨</li>
<li>所有邻居高度 ≥3米，形成“死水”</li>
<li>Relabel 后，<span class="math inline">\(u\)</span> 高度变为（邻居最小高度+1）=4米</li>
<li>下一轮可能发现某个邻居现在高度3米，形成新的瀑布！</li>
</ul>
<p>在英语语境里常称呼节点高度为 distance label，不过算法导论里称其为高度，这是更生动的叫法，表示同一个意思。</p>
<p>设图中节点总数为 <span class="math inline">\(n\)</span>，随着高度不断增加，算法运行中可能出现 <span class="math inline">\(h(u) &gt; n\)</span> 的情况（即高过源点）。此时节点 <span class="math inline">\(u\)</span> 的高度实际上进入了“幽灵层”——它不再对应真实的地形，而是<strong>一种数学上的占位符</strong>：</p>
<ul>
<li><strong>语义转换</strong>：<span class="math inline">\(h(u) &gt; n\)</span> 意味着 <span class="math inline">\(u\)</span> 到汇点 <span class="math inline">\(t\)</span> 的路径已被完全阻塞，他的超额流量无论如何也送不到汇点了。根据高度差约束，水流只能从 <span class="math inline">\(h(u) = h(v)+1\)</span> 的边推送。若 <span class="math inline">\(h(u) &gt; n\)</span> 且汇点 <span class="math inline">\(t\)</span> 的高度始终为 0，则 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(t\)</span> 的路径上必然存在高度断层（至少需要 <span class="math inline">\(n+1\)</span> 层高度差），从而阻断正向流动。</li>
<li><strong>行为逻辑</strong>：这些节点的超额流将由高度差被迫<strong>反向流动</strong>，最终退回源点 <span class="math inline">\(s\)</span></li>
</ul>
<p>可以证明高度最高为 <span class="math inline">\(2|V|-1\)</span>。</p>
<p>如在下面的图里，首先由源点放出 <span class="math inline">\(10\)</span> 流量到 <span class="math inline">\(c\)</span>，然后 <span class="math inline">\(c\)</span> 将被反过来抬升并最终逐次送回超额流量，最终答案是<span class="math inline">\(1\)</span>。</p>
<pre><code>s → a 10
a → b 7
b → c 4
c → t 1
</code></pre>
<p>理论上，每次遍历所有节点，检查可以 push 或 relabel 的节点并操作，就可以得到答案。</p>
<h2 id="hlpp-算法">HLPP 算法</h2>
<p>基础 Push-Relabel 的 <span class="math inline">\(O(n^2m)\)</span> 时间复杂度是盲目的。例如在下图结构中，普通算法可能会反复将节点 <span class="math inline">\(u\)</span> 的水推给 <span class="math inline">\(v\)</span>，又因 <span class="math inline">\(v\)</span> 无法排水而推回 <span class="math inline">\(u\)</span>，形成“打乒乓球”现象：</p>
<pre><code>s → u (容量100)  
u → v (容量1)  
v → t (容量100)
</code></pre>
<p>HLPP 是 push-relabel 算法的一种实现。优先处理<strong>海拔最高</strong>的溢出节点，如同治水时先疏通最上游的堰塞湖，防止洪水回溯。实践上，可以通用的使用优先队列，但考虑到高度的值域和算法性质，更常使用<strong>桶（Bucket）</strong>结构按高度分层管理节点，维护一个“当前最高高度”始终指向当前最高非空桶，每一次我们都从这个大桶里取出节点，尝试 push （若能推出去）或 relabel（若推不出去）。优化后时间复杂度降至 <span class="math inline">\(O(n^2\sqrt{m})\)</span> 。</p>
<h3 id="gap-优化">GAP 优化</h3>
<p><strong>Gap 现象</strong>：在算法运行过程中，如果存在某个高度值 <span class="math inline">\(k\)</span>，使得没有任何节点高度为 <span class="math inline">\(k\)</span>，但存在高度 <span class="math inline">\(&gt;k\)</span> 的节点，则称出现一个 Gap。这相当于地形出现断层，高处的水永远无法流到断层以下的区域。</p>
<p>若在高度 <span class="math inline">\(k\)</span> 处出现 Gap，则所有高度 <span class="math inline">\(&gt;k\)</span> 的节点到汇点 <span class="math inline">\(t\)</span> 在残量网络中<strong>不可达</strong>。这些节点的超额流实际上被困在“孤岛”中，必须通过<strong>主动排水</strong>将其送回源点。</p>
<p>我们维护一个高度计数数组，当某个高度层计数降为0时，触发 Gap 检测，将所有高度 &gt;k 的节点标记为“死亡”（高度设为 <span class="math inline">\(n+1\)</span>）<br>
4。</p>
<p>假设节点高度分布为 <span class="math inline">\([5,5,4,3,3,1]\)</span>，当高度2的节点全部消失时：</p>
<ul>
<li>检测到 Gap 出现在 <span class="math inline">\(k=2\)</span></li>
<li>高度为 5、5、4 的节点被判定为“孤岛”</li>
<li>立即将这些节点高度设为 <span class="math inline">\(n+1\)</span>，其超额流将快速回流到源点</li>
</ul>
<p>所有高度大于 <span class="math inline">\(n\)</span> 的节点都意味着他们多出来的超额流量只能送回源点，假如我们只求最大流数值，不求解达成最大流时每条边的流量，那么我们可以直接不处理他们而是直接丢弃出队，他们的入大于出不会影响最终答案。</p>
<h3 id="设定初始高度">设定初始高度</h3>
<p>上文提到初始时，源点汇点以外的其他点初始高度为 0。实际上可以把他们的初始高度设置为到汇点距离，这不会影响算法正确性</p>
<p>HLPP 不是简单的启发式优化，而是通过<strong>高度拓扑排序</strong>和<strong>断层检测</strong>，严格降低了复杂度上限。这种将物理直觉与离散数学结合的思想，正是算法设计的精髓所在。</p>
<pre><code class="language-cpp">class Graph {
    struct Edge {
        int v, res, next;
        Edge(int v, int res, int next) : v(v), res(res), next(next) {}
    };

    vector&lt;int&gt; head;
    vector&lt;Edge&gt; edges;
    int n, m, s, t;

public:
    void addEdge(int u, int v, int cap) {
        // 同时添加两侧边，便于残量网络的构建
        edges.emplace_back(v, cap, head[u]);
        head[u] = edges.size() - 1;
        edges.emplace_back(u, 0, head[v]);
        head[v] = edges.size() - 1;
    }

    Graph(int n, int m, int s, int t) : n(n), m(m), s(s), t(t), head(n+1, -1) {
        edges.reserve(m * 2);
    }

    long long hlpp() {
        vector&lt;long long&gt; excess(n+1, 0);
        vector&lt;int&gt; dep(n+1, n), gap(2*n+1, 0), curHead(head);
        vector&lt;vector&lt;int&gt;&gt; buckets(2*n+1);

        int max_h = 0;
        queue&lt;int&gt; q;
        q.push(t);
        dep[t] = 0;

        while (!q.empty()) {
            int u = q.front();
            q.pop();
            gap[dep[u]]++;
            for (int i = head[u]; i != -1; i = edges[i].next) {
                int v = edges[i].v;
                if (dep[v] == n &amp;&amp; edges[i^1].res &gt; 0) {
                    dep[v] = dep[u] + 1;
                    q.push(v);
                }
            }
        }
        if (dep[s] == n) return 0; // s is not reachable from t
        dep[s] = n; // in hlpp, s &amp; t are specially handled

        // push from source
        for (int i = head[s]; i != -1; i = edges[i].next) {
            int v = edges[i].v;
            if (edges[i].res &gt; 0) {
                auto flow(edges[i].res);
                edges[i].res -= flow;
                edges[i^1].res += flow;
                excess[s] -= flow;
                excess[v] += flow;
            }
            if (v != s &amp;&amp; v != t &amp;&amp; excess[v] &gt; 0) {
                buckets[dep[v]].push_back(v);
                max_h = max(max_h, dep[v]);
            }
        }

        // get highest, push &amp; relabel
        while (max_h &gt;= 0) {
            if (buckets[max_h].empty()) { max_h--; continue; }

            int u = buckets[max_h].back(); buckets[max_h].pop_back();
            if (excess[u] == 0 || dep[u] != max_h) continue;
            while (excess[u] &gt; 0) {
                if (dep[u] &gt;= n) {
                    excess[u] = 0;
                    break;
                }

                if (curHead[u] == -1) { // relabel
                    int min_h = 2 * n;
                    for (int i = head[u]; i != -1; i = edges[i].next) {
                        if (edges[i].res &gt; 0) min_h = min(min_h, dep[edges[i].v]);
                    }
                    int old_h = dep[u];
                    int new_h = min_h + 1;
                    gap[old_h]--;
                    dep[u] = new_h;
                    gap[new_h]++;
                    if (gap[old_h] == 0 &amp;&amp; old_h &lt; n) {
                        for (int v = 0; v &lt;= n; v++) {
                            if (v == s || v == t) continue;
                            if (dep[v] &gt; old_h &amp;&amp; dep[v] &lt; n) {
                                gap[dep[v]]--;
                                dep[v] = n + 1;
                                gap[n+1]++;
                                if (excess[v] &gt; 0) buckets[dep[v]].push_back(v);
                            }
                        }
                    }
                    max_h = max(max_h, dep[u]);
                    curHead[u] = head[u];
                } else {
                    int i = curHead[u];
                    if (edges[i].res &gt; 0 &amp;&amp; dep[u] == dep[edges[i].v] + 1) {
                        auto flow(min(excess[u], (long long)edges[i].res));
                        edges[i].res -= flow;
                        edges[i^1].res += flow;
                        excess[u] -= flow;
                        excess[edges[i].v] += flow;
                        if (edges[i].v != s &amp;&amp; edges[i].v != t &amp;&amp; excess[edges[i].v] &gt; 0) {
                            buckets[dep[edges[i].v]].push_back(edges[i].v);
                            max_h = max(max_h, dep[edges[i].v]);
                        }
                    } else {
                        curHead[u] = edges[i].next;
                    }
                }
            }
        } return excess[t];
    }
};
</code></pre>
<h2 id="拓展知识">拓展知识</h2>
<h4 id="运算量和复杂度">运算量和复杂度</h4>
<ul>
<li><strong>重贴标签次数</strong>：每个节点最多被重贴标签 <span class="math inline">\(2n\)</span> 次（高度从 0 增长到 <span class="math inline">\(2n-1\)</span>）</li>
<li><strong>饱和推送次数</strong>：每条边最多触发 <span class="math inline">\(O(n)\)</span> 次饱和推送（每次推送至少抬高起点高度）</li>
<li><strong>复杂度上界</strong>：<span class="math inline">\(O(n^2\sqrt{m})\)</span>（通过最高标号优先策略压缩，其证明较困难）这个上界相对较紧。</li>
</ul>
<h4 id="与-dinic-算法的对比">与 Dinic 算法的对比</h4>
<p><strong>Dinic 算法</strong>的特点：</p>
<ul>
<li><strong>分层网络</strong>：通过 BFS 构建分层图，强制流量按层递进</li>
<li><strong>优势场景</strong>：稀疏图、边容量较小的情况</li>
<li><strong>弱点</strong>：稠密图中频繁重建分层网络代价高昂</li>
</ul>
<p><strong>HLPP 的优势</strong>：</p>
<ul>
<li><strong>免维护分层结构</strong>：高度函数动态调整，避免重复 BFS</li>
<li><strong>异步并行潜力</strong>：节点操作相互独立，适合 GPU 加速</li>
<li><strong>稠密图霸主</strong>：在完全图、网格图等场景下速度可提升 10 倍以上</li>
</ul>
<blockquote>
<p><strong>思考题</strong>：若将 HLPP 的高度差约束从 1 改为 <span class="math inline">\(k\)</span>，会对算法行为产生什么影响？（提示：考虑 <span class="math inline">\(k=0\)</span> 和 <span class="math inline">\(k=2\)</span> 的极端情况）</p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2901732908599537" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-13 21:17">2025-02-13 21:16</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">17</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18713770" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18713770);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18713770', targetLink: 'https://www.cnblogs.com/ofnoname/p/18713770', title: '水往低处流：最大流的最高标号预留推进算法（HLPP）' })">举报</a>
</div>
        