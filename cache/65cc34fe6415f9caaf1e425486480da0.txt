
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sun-10387834/p/18976844" title="发布于 2025-07-11 10:15">
    <span role="heading" aria-level="2">【锁的本质】锁本身就是共享资源，那么锁如何保证线程安全？</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>锁本身作为共享资源却能保证线程安全，以及<code>AtomicInteger</code>等原子类的线程安全实现，其根本原因都依赖于<strong>硬件层面的原子操作指令</strong>和<strong>内存屏障</strong>。下面分层解析其原理：</p>
<hr>
<h3 id="一锁如何保证自身线程安全以-reentrantlock-为例">一、锁如何保证自身线程安全（以 ReentrantLock 为例）</h3>
<h4 id="1-底层依赖cas-compare-and-swap">1. 底层依赖：CAS (Compare-And-Swap)</h4>
<pre><code class="language-java">// AQS 中的核心 CAS 操作（简化版）
protected final boolean compareAndSetState(int expect, int update) {
    // 调用 Unsafe 类的 CAS 原子操作
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
</code></pre>
<ul>
<li><strong>硬件支持</strong>：CPU 提供 <code>LOCK CMPXCHG</code> 等原子指令（x86 架构）</li>
<li><strong>操作原子性</strong>：比较-交换操作在一条指令内完成，不会被线程切换打断</li>
</ul>
<h4 id="2-锁获取流程非公平锁">2. 锁获取流程（非公平锁）</h4>
<pre><code class="language-java">final void lock() {
    if (compareAndSetState(0, 1))  // 原子操作：尝试将 state 从 0 改为 1
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
</code></pre>
<p><strong>关键保障</strong>：</p>
<ol>
<li>多个线程同时执行 CAS 时，只有<strong>一个线程</strong>能成功修改 <code>state</code> 值</li>
<li>失败线程进入 CLH 队列等待（通过 CAS 保证入队操作的线程安全）</li>
</ol>
<h4 id="3-操作系统级保障">3. 操作系统级保障</h4>
<p>当竞争激烈时（重量级锁）：</p>
<pre><code class="language-c++">// HotSpot 源码中的锁膨胀（linux 实现）
void ObjectSynchronizer::inflate(Thread* self, oop object) {
    ...
    // 创建 ObjectMonitor 对象
    ObjectMonitor* monitor = new ObjectMonitor();
    // 通过 CAS 将对象头指向 monitor
    if (Atomic::cmpxchg_ptr(monitor, object-&gt;mark_addr(), mark) == mark) {
        ...
    }
}
</code></pre>
<ul>
<li>最终依赖操作系统提供的 <strong>mutex 互斥量</strong>（如 Linux 的 <code>pthread_mutex_t</code>）</li>
<li>通过系统调用（如 <code>futex</code>）实现线程阻塞/唤醒</li>
</ul>
<hr>
<h3 id="二atomicinteger-的线程安全原理">二、AtomicInteger 的线程安全原理</h3>
<h4 id="1-核心实现jdk-源码">1. 核心实现（JDK 源码）</h4>
<pre><code class="language-java">public class AtomicInteger {
    private volatile int value;
    
    public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    }
}

// Unsafe 类中的关键操作
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset); // 读取当前值
    } while (!compareAndSwapInt(o, offset, v, v + delta)); // CAS 重试
    return v;
}
</code></pre>
<h4 id="2-关键保障机制">2. 关键保障机制</h4>
<table>
<thead>
<tr>
<th><strong>机制</strong></th>
<th><strong>作用</strong></th>
<th><strong>实现层级</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>volatile 变量</strong></td>
<td>保证内存可见性（禁止指令重排序）</td>
<td>JVM 内存屏障</td>
</tr>
<tr>
<td><strong>CAS 操作</strong></td>
<td>保证修改的原子性</td>
<td>CPU 硬件指令</td>
</tr>
<tr>
<td><strong>自旋重试</strong></td>
<td>处理竞争失败</td>
<td>Java 代码层</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="三对比-integer-的线程不安全">三、对比 Integer 的线程不安全</h3>
<h4 id="1-integer-的自增操作">1. Integer 的自增操作</h4>
<pre><code class="language-java">Integer count = 0;
count = count + 1; // 非原子操作
</code></pre>
<p>实际执行步骤：</p>
<ol>
<li>读取当前值 <code>count</code> (非原子)</li>
<li>计算 <code>count+1</code> (非原子)</li>
<li>写入新值 (非原子)</li>
</ol>
<h4 id="2-多线程下的问题">2. 多线程下的问题</h4>
<pre><code class="language-java">// 线程 A          |  // 线程 B
read count=0       |
                   | read count=0
calc 0+1=1         |
                   | calc 0+1=1
write count=1      |
                   | write count=1  // 结果应为2，实际为1
</code></pre>
<hr>
<h3 id="四根本原因对比">四、根本原因对比</h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th>锁 (ReentrantLock)</th>
<th>原子类 (AtomicInteger)</th>
<th>Integer</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>原子性保障</strong></td>
<td>CAS+队列管理</td>
<td>CAS 循环</td>
<td>无</td>
</tr>
<tr>
<td><strong>可见性保障</strong></td>
<td>AQS 的 volatile state</td>
<td>volatile 变量</td>
<td>无</td>
</tr>
<tr>
<td><strong>竞争处理</strong></td>
<td>队列阻塞</td>
<td>CPU 自旋</td>
<td>-</td>
</tr>
<tr>
<td><strong>硬件依赖</strong></td>
<td>CPU 原子指令+OS 系统调用</td>
<td>CPU 原子指令</td>
<td>无</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>复杂同步逻辑</td>
<td>单一变量原子操作</td>
<td>只读/线程局部变量</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="五硬件与操作系统协作示意图">五、硬件与操作系统协作示意图</h3>
<pre><code>+---------------------+     +---------------------+
|     Java 代码层      |     |       JVM 层         |
|   - ReentrantLock   |&lt;---&gt;| - AQS 实现          |
|   - AtomicInteger   |     | - 锁膨胀机制         |
+----------↑----------+     +----------↑----------+
           |                           |
+----------↓----------+     +----------↓----------+
|  本地方法库 (JNI)   |     |     操作系统层        |
|   - Unsafe 类       |&lt;---&gt;| - mutex 互斥量        |
|   - CAS 操作        |     | - futex 快速锁        |
+----------↑----------+     +----------↑----------+
           |                           |
+----------↓----------+     +----------↓----------+
|        CPU 层       |     |       内存子系统      |
|  - LOCK 指令前缀    |&lt;---&gt;| - 缓存一致性协议      |
|  - CMPXCHG 指令     |     | - 内存屏障           |
+---------------------+     +---------------------+
</code></pre>
<hr>
<h3 id="六关键结论">六、关键结论</h3>
<ol>
<li>
<p><strong>锁的自身安全根本原因</strong>：</p>
<ul>
<li>硬件原子指令（CAS）保证状态修改的原子性</li>
<li>内存屏障保证状态可见性</li>
<li>操作系统提供阻塞/唤醒原语</li>
</ul>
</li>
<li>
<p><strong>原子类的线程安全根本原因</strong>：</p>
<ul>
<li>volatile 保证可见性</li>
<li>CAS 循环保证原子修改</li>
<li>无锁设计避免上下文切换</li>
</ul>
</li>
<li>
<p><strong>Integer 线程不安全原因</strong>：</p>
<ul>
<li>复合操作（读-改-写）不具备原子性</li>
<li>缺乏内存可见性保障</li>
</ul>
</li>
</ol>
<blockquote>
<p>💡 <strong>设计启示</strong>：</p>
<ul>
<li>简单原子操作优先使用原子类（如 <code>AtomicInteger</code>）</li>
<li>复杂同步逻辑使用锁（如 <code>ReentrantLock</code>）</li>
<li>避免在无同步下修改共享基本类型（如 <code>int</code>）</li>
</ul>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.020833333333333332" data-date-updated="2025-07-11 10:45">2025-07-11 10:15</span>&nbsp;
<a href="https://www.cnblogs.com/sun-10387834">佛祖让我来巡山</a>&nbsp;
阅读(<span id="post_view_count">1</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18976844);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18976844', targetLink: 'https://www.cnblogs.com/sun-10387834/p/18976844', title: '【锁的本质】锁本身就是共享资源，那么锁如何保证线程安全？' })">举报</a>
</div>
        