
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangxincheng/p/18748086" title="发布于 2025-03-03 14:06">
    <span role="heading" aria-level="2">Linux系列：如何用 C#调用 C方法造成内存泄露</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景">一：背景</h2>
<h3 id="1-讲故事">1. 讲故事</h3>
<p>好久没写文章了，还是来写一点吧，今年准备多写一点 Linux平台上的东西，这篇从 C# 调用 C 这个例子开始。在 windows 平台上，我们常常在 C++ 代码中用 <code>extern "C"</code> 导出 C风格 的函数，然后在 C# 中用 DllImport 的方式引入，那在 Linux 上怎么玩的？毕竟这对研究 Linux 上的 C# 程序<code>非托管内存泄露</code>有非常大的价值，接下来我们就来看下。</p>
<h2 id="二一个简单的非托管内存泄露">二：一个简单的非托管内存泄露</h2>
<h3 id="1-构建-so-文件">1. 构建 so 文件</h3>
<p>在 Windows 平台上我们会通过 MSVC 编译器将 C代码编译出一个成品 .dll，在 Linux 上通常会借助 gcc 将 c 编译成 .so 文件，这个.so 全称 Shared Object，为了方便讲解，先上一段简单的代码：</p>
<pre><code class="language-C">
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;

#define BLOCK_SIZE (10 * 1024)              // 每个块 10K
#define TOTAL_SIZE (1 * 1024 * 1024 * 1024) // 总计 1GB
#define BLOCKS (TOTAL_SIZE / BLOCK_SIZE)    // 计算需要的块数

void heapmalloc()
{
    uint8_t *blocks[BLOCKS]; // 存储每个块的指针

    // 分配 1GB 内存，分成多个小块
    for (size_t i = 0; i &lt; BLOCKS; i++)
    {
        blocks[i] = (uint8_t *)malloc(BLOCK_SIZE);
        if (blocks[i] == NULL)
        {
            printf("内存分配失败！\n");
            return;
        }

        // 确保每个块都被实际占用
        memset(blocks[i], 20, BLOCK_SIZE);
    }

    printf("已经分配 1GB 内存在堆上！\n");
}

</code></pre>
<p>接下来使用 gcc 编译，参考如下：</p>
<pre><code class="language-bash">
gcc -shared -o libmyleak.so -fPIC myleak.c

</code></pre>
<ul>
<li>-shared: 编译成共享库</li>
<li>-fPIC:   指定共享库可以在内存任意位置被加载（地址无关性）</li>
</ul>
<p>命令执行完之后，就可以看到一个 .so 文件了，截图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202503/214741-20250303140529276-1099343723.png" alt="" loading="lazy"></p>
<p>最后可以用 nm 命令验证下 libmyleak.so 中是否有 Text 段下的 heapmalloc 导出函数。</p>
<pre><code class="language-C#">
root@ubuntu2404:/data2/c# nm libmyleak.so
0000000000004028 b completed.0
                 w __cxa_finalize@GLIBC_2.2.5
00000000000010c0 t deregister_tm_clones
0000000000001130 t __do_global_dtors_aux
0000000000003e00 d __do_global_dtors_aux_fini_array_entry
0000000000004020 d __dso_handle
0000000000003e08 d _DYNAMIC
000000000000125c t _fini
0000000000001170 t frame_dummy
0000000000003df8 d __frame_dummy_init_array_entry
00000000000020f8 r __FRAME_END__
0000000000003fe8 d _GLOBAL_OFFSET_TABLE_
                 w __gmon_start__
000000000000203c r __GNU_EH_FRAME_HDR
0000000000001179 T heapmalloc
0000000000001000 t _init
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 U malloc@GLIBC_2.2.5
                 U memset@GLIBC_2.2.5
                 U puts@GLIBC_2.2.5
00000000000010f0 t register_tm_clones
                 U __stack_chk_fail@GLIBC_2.4
0000000000004028 d __TMC_END__

</code></pre>
<h3 id="2-c-代码调用">2. C# 代码调用</h3>
<p>so构建好了之后，后面就比较好说了，使用 <code>dotnet new console -n CSharpApplication --use-program-main true</code> 新建一个CS项目。</p>
<pre><code class="language-bash">
root@ubuntu2404:/data2/csharp# dotnet new console -n CSharpApplication --use-program-main true
The template "Console App" was created successfully.

Processing post-creation actions...
Restoring /data2/csharp/CSharpApplication/CSharpApplication.csproj:
  Determining projects to restore...
  Restored /data2/csharp/CSharpApplication/CSharpApplication.csproj (in 1.7 sec).
Restore succeeded.

</code></pre>
<p>编译下 C# 项目，然后将 <code>libmyleak.so</code> 放到 C#项目的 bin目录，修改 C# 代码如下：</p>
<pre><code class="language-C#">
using System.Runtime.InteropServices;

namespace CSharpApplication;

class Program
{
    [DllImport("libmylib.so", CallingConvention = CallingConvention.Cdecl)]
    public static extern void hello();

    static void Main(string[] args)
    {
        hello();
        Console.ReadLine();
    }
}

</code></pre>
<p>最后用 <code>dotnet CSharpApplication.dll</code> 运行：</p>
<pre><code class="language-C#">
root@ubuntu2404:/data2/csharp/CSharpApplication/bin/Debug/net8.0# dotnet CSharpApplication.dll
已经分配 1GB 内存在堆上！

</code></pre>
<p>程序是跑起来了，那真的是吃了1G呢？ 可以先用 htop 观察程序，从截图看没毛病。</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202503/214741-20250303140529281-887200493.png" alt="" loading="lazy"></p>
<p>那这 1G 真的在 heap 上吗？ 可以用 maps 观察。</p>
<pre><code class="language-C#">
root@ubuntu2404:~# ps -ef | grep CSharp
root       10764   10730  0 13:35 pts/21   00:00:00 dotnet CSharpApplication.dll
root       11049   11027  0 13:41 pts/22   00:00:00 grep --color=auto CSharp

root@ubuntu2404:~# cat /proc/10764/maps
614e1f592000-614e1f598000 r--p 00000000 08:02 1479867                    /usr/lib/dotnet/dotnet
614e1f598000-614e1f5a4000 r-xp 00005000 08:02 1479867                    /usr/lib/dotnet/dotnet
614e1f5a4000-614e1f5a5000 r--p 00010000 08:02 1479867                    /usr/lib/dotnet/dotnet
614e1f5a5000-614e1f5a6000 rw-p 00010000 08:02 1479867                    /usr/lib/dotnet/dotnet
614e5b5d9000-614e9b8a8000 rw-p 00000000 00:00 0                          [heap]
...


root@ubuntu2404:~# pmap 10764
10764:   dotnet CSharpApplication.dll
0000614e1f592000     24K r---- dotnet
0000614e1f598000     48K r-x-- dotnet
0000614e1f5a4000      4K r---- dotnet
0000614e1f5a5000      4K rw--- dotnet
0000614e5b5d9000 1051452K rw---   [ anon ]
...

</code></pre>
<p>根据 linux 进程的内存布局，可执行image之后是 heap 堆，可以看到 <code>[heap]</code> 约等于<code>1G (614e9b8a8000 - 614e5b5d9000)</code>，即 pmap 中的 1051452K。</p>
<h2 id="三总结">三：总结</h2>
<p>部署在 Linux上的.NET程序同样存在 <code>非托管内存泄露</code> 的问题，这篇文章的例子虽然很简单，希望能给大家带来一些思考和观测途径吧。<br>
<img src="https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_210929020104最新消息优惠促销公众号关注二维码.jpg" width="700" height="300" alt="图片名称" align="center"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.010755042025462963" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-03 14:07">2025-03-03 14:06</span>&nbsp;
<a href="https://www.cnblogs.com/huangxincheng">一线码农</a>&nbsp;
阅读(<span id="post_view_count">13</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18748086" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18748086);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18748086', targetLink: 'https://www.cnblogs.com/huangxincheng/p/18748086', title: 'Linux系列：如何用 C#调用 C方法造成内存泄露' })">举报</a>
</div>
        