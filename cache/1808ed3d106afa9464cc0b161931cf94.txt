
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sdcb/p/19026035/unimplemented-csharp-14-features" title="发布于 2025-08-07 08:45">
    <span role="heading" aria-level="2">那些被推迟的 C# 14 特性及其背后的故事</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>C# 14 带着 <a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-14" target="_blank" rel="noopener nofollow">.NET 10</a> 一同发布了，带来了一系列诸如扩展成员、<code>field</code> 关键字、空条件赋值等不错的“生活质量”改进。但说实话，对于我们这些老鸟来说，社区的期待往往是更高的。每年我们都盼着语言能来点“核弹级”更新，结果发现，真正让我们心痒痒的那些大特性，却在官方的“工作集”和“积压项”里徘徊，成了 C# 14 的“幽灵”。</p>
<p>不过，这种克制并非停滞。恰恰相反，这正是一门成熟语言深思熟虑的体现。它告诉我们，C# 团队的核心理念是：<strong>宁愿慢一点，也要保证每一步都踩得稳、踩得准</strong>。今天，我们就来聊聊这些被推迟的“幽灵”，看看它们背后到底有哪些惊心动魄的故事，以及它们如何揭示 C# 未来的走向。</p>
<p><img src="https://img2024.cnblogs.com/blog/233608/202508/233608-20250806225653051-324153609.png" alt="image" loading="lazy"></p>
<h2 id="设计的艺术c-新特性是如何诞生的"><strong>设计的艺术：C# 新特性是如何诞生的？</strong></h2>
<p>想搞明白为什么有些特性会“跳票”，就得先了解一个 C# 特性从点子到落地的全过程。这个过程基本上是全透明的，主要围绕着 <a href="https://github.com/dotnet/csharplang" target="_blank" rel="noopener nofollow">dotnet/csharplang 这个 GitHub 仓库</a> 进行。</p>
<p>简单来说，一个想法从 Issue 开始，如果够有分量，就会有 C# 团队成员来当“拥护者”（Champion），然后进入语言设计会议（LDM）被反复捶打。LDM 可不是简单的投票，那是一群顶尖大佬进行深度设计和激烈辩论的“创意工场”。他们的<a href="https://github.com/dotnet/csharplang/blob/main/meetings/README.md" target="_blank" rel="noopener nofollow">会议纪要</a>都是公开的，是理解特性背后“为什么”的绝佳一手资料。</p>
<p>而 csharplang 仓库里的<a href="https://github.com/dotnet/csharplang/milestones" target="_blank" rel="noopener nofollow">里程碑（Milestones）</a>则清晰地表明了特性的状态：</p>
<ul>
<li><strong>Working Set</strong>：当前正在被 LDM 积极设计的特性，是下一个版本的“准候选人”。</li>
<li><strong>Backlog</strong>：有价值，但暂时没空搞，是未来版本的“潜力股”。</li>
<li><strong>Any Time</strong>：社区可以来贡献，但核心团队优先级不高。</li>
<li><strong>Likely Never</strong>：被 LDM 明确拒绝的提案。</li>
</ul>
<p>这种开放又高度策划的流程，确保了 C# 在拥抱创新的同时，不会偏离其统一的设计愿景。</p>
<h2 id="可辨识联合discriminated-unions一场未竟的史诗"><strong>可辨识联合（Discriminated Unions）：一场未竟的史诗</strong></h2>
<p>在所有被推迟的特性里，可辨识联合（Discriminated Unions, DUs）绝对是社区里呼声最高、设计最复杂、故事也最曲折的一个。它在 csharplang 仓库里是被点赞最多的 <a href="https://github.com/dotnet/csharplang/issues/113" target="_blank" rel="noopener nofollow">Issue 之一</a>，其漫长的演进史，简直就是 C# 设计哲学的一面镜子。</p>
<h3 id="为什么我们如此渴望-du"><strong>为什么我们如此渴望 DU？</strong></h3>
<p>一句话概括 DU 的核心价值：<strong>在编译时，让非法的状态变得不可表示</strong>。这是函数式编程的基石，也是构建健壮系统的终极利器。</p>
<p>举个烂熟于心的例子：表示一个定时任务触发器。它可能有几种状态：从不、每天午夜、每日特定时间、或按周期。用传统的 class 或 struct，你可能会写出这样的代码：</p>
<pre><code class="language-csharp">// 传统方式，充满了挖坑的可能性
public struct JobTrigger
{
    public bool IsNever { get; set; }
    public bool IsEveryMidnight { get; set; }
    public TimeOnly? DailyTime { get; set; }
    public TimeSpan? Period { get; set; }
    // ... 各种布尔值和可空类型
}
</code></pre>
<p>这种结构的问题简直是灾难性的：我可以轻易创建一个 <code>new JobTrigger { IsNever = true, Period = TimeSpan.FromHours(1) }</code> 这种逻辑上精神分裂的对象。你只能在运行时用一堆 <code>if-else</code> 去捕获和抛异常。</p>
<p>而一个理想的 DU 实现，则能在类型系统层面直接干掉这种可能：</p>
<pre><code class="language-csharp">// 理想中的 DU 语法（示意）
public union JobTrigger
{
    case Never;
    case EveryMidnight;
    case Daily(TimeOnly time);
    case Periodic(TimeSpan interval);
}
</code></pre>
<p>在这种设计下，一个 <code>JobTrigger</code> 实例<strong>必须</strong>是这四种情况之一，且只能是其中之一。更牛的是，当你用 <code>switch</code> 表达式处理它时，编译器会进行<strong>穷尽性检查</strong>。这意味着，如果未来你给 <code>JobTrigger</code> 增加了第五种情况，所有没处理新情况的 <code>switch</code> 都会直接编译失败，而不是等到运行时给你一个惊喜。</p>
<p>说到这里，我总会感到一阵惋惜。我们都知道，TypeScript 的编译器是用 TypeScript 写的，而 TypeScript 之父 Anders Hejlsberg 也是 C# 的缔造者。后来在新版本的 TypeScript 编译器重写时，Anders 大神选择了 Go，而不是自己的亲儿子 C#。坊间传闻，一个重要的原因可能就是当时 C# 缺乏原生的可辨识联合能力。如果 C# 早点拥有这个特性，以其卓越的类型系统和性能，或许就能成为重写 TypeScript 编译器的不二之选。唉，这或许是 .NET 生态永远的意难平了。</p>
<h3 id="设计的迷宫从语法到版本地狱"><strong>设计的迷宫：从语法到版本地狱</strong></h3>
<p>DU 虽好，但想把它完美地塞进 C# 这个庞大且极其注重向后兼容的语言里，简直是地狱级难度。</p>
<ul>
<li><strong>语法之战</strong>：用 <code>union</code> 和 <code>case</code> 关键字？还是用 <code>|</code> 符号？每种方案都可能与现有代码冲突，引入新关键字更是要慎之又慎。</li>
<li><strong>穷尽性检查的挑战</strong>：这才是真正的“大魔王”。想象一下，一个流行的 NuGet 包定义了一个公共 DU 类型 <code>Result</code>，包含 <code>Success</code> 和 <code>Failure</code>。你的代码完美处理了这两种情况。然后，包更新了，加了个 <code>Cancelled</code> 状态。你只更新了 DLL 而没重新编译，程序在运行时遇到 <code>Cancelled</code> 就直接崩溃了。这直接破坏了 .NET 生态系统“二进制兼容”的基石承诺！F# 选择建议不在公共 API 暴露 DU，但这对于 C# 来说显然不是个好答案。</li>
<li><strong>运行时与性能</strong>：底层怎么实现？是编译时检查、运行时“擦除”类型信息（类似 Java 泛型擦除，性能和互操作性堪忧），还是为每个联合生成一个真实的、带有元数据的“具体化”类型（对 CLR 改动巨大）？每一步都是艰难的权衡。</li>
</ul>
<p>面对如此巨大的复杂性，LDM 最终做出了一个关键决策：<strong>放弃“大爆炸”式发布，转而采用增量式方法</strong>。他们决定，当前阶段先集中精力搞定“<a href="https://github.com/dotnet/csharplang/issues/8928" target="_blank" rel="noopener nofollow">类联合</a>”（class unions），也就是基于现有类继承体系的、范围更小的 DU 实现。</p>
<p>这正是 C# 14 中没有 DU 的直接原因。LDM 选择了一条更务实的路径：先从最熟悉的类继承入手，发布一个 v1 版本。这很 C#，很务实。它采纳了函数式编程的理念，但通过我们面向对象开发者最熟悉的机制来实现它。</p>
<h2 id="拦截器interceptors在炼狱中挣扎的强大工具"><strong>拦截器（Interceptors）：在炼狱中挣扎的强大工具</strong></h2>
<p>如果说 DU 的故事是“慢工出细活”，那拦截器的故事就是一场关于语言哲学和“代码魔法”的激烈辩论。最终，这个特性被打上了“实验性预览”的标签，未来充满了不确定性。</p>
<p>拦截器的诞生，源于一个非常具体的需求：<strong>为 .NET 的 AOT（预先编译）场景提供高性能方案</strong>。像 ASP.NET Core Minimal APIs 大量依赖运行时反射，这和 AOT 的静态分析天生就是死对头。</p>
<p><a href="https://github.com/dotnet/csharplang/issues/7009" target="_blank" rel="noopener nofollow">拦截器</a>允许源码生成器在编译时“拦截”一个方法调用，并把它替换成另一段静态生成的、不含反射的高效代码。比如，对 <code>app.MapGet("/", ...)</code> 的调用，可以被重写为直接调用一个预生成好的处理程序。开发者体验不变，但编译产物却变得 AOT 友好了。</p>
<p>这看似完美的方案，却在 LDM 内部引发了深刻的哲学分歧：</p>
<ul>
<li><strong>务实的工具论者</strong>：认为这玩意儿就是个编译器优化工具，开发者不需要知道它的存在，只要代码能跑得快、调试体验好就行。</li>
<li><strong>通用的语言特性论者</strong>：对可能导致的“<strong>远距离幽灵行为</strong>”（spooky action at a distance）表示严重担忧。一行 <code>controller.DoSomething()</code> 的代码，实际上执行的却是另一段逻辑，这简直是代码可读性的噩梦，堪称“不受限制的 comefrom 语句”。他们坚持，必须在调用点有个明确的语法标记（比如 <code>controller.DoSomething#()</code>），告诉开发者“这里有魔法”！</li>
</ul>
<p>面对这种分歧和发布时间的压力，LDM 做出了一个“所罗门的审判”：<strong>拦截器随 .NET 8 发布，但身份是明确的、不受支持的实验性特性</strong>。</p>
<p>这个决定，一方面解了 ASP.NET 团队的燃眉之急，另一方面也为语言的长期健康留下了思考时间。LDM 成立了一个新工作组，去重新审视这个需求，看看有没有侵入性更小的方式来解决。这充分体现了 LDM 作为语言“守护者”的决心，即使面对平台内部“第一方客户”的强大需求，也绝不牺牲语言长期的清晰性和一致性。</p>
<h2 id="来自积压项的低语"><strong>来自积压项的低语</strong></h2>
<p>除了上面两个“大部头”，C# 的“积压项”里还潜藏着很多有趣的想法。</p>
<ul>
<li><strong>类型类（Type Classes）</strong>：被标记为“需要长期投入”，这是一种允许你为现有类型（即使是第三方库里的）扩展“接口”实现的能力，比扩展方法更强大。但它需要对 .NET 泛型系统和运行时进行伤筋动骨的改造，复杂性堪比当年引入泛型本身，所以只能是个遥远的愿景。</li>
<li><strong>封闭枚举（Closed Enums）</strong>：一个看起来很美好的小特性，阻止将任意整数强转为枚举，保证枚举值的安全。它之所以没被推进，很可能是被更宏大的 DU 提案“遮蔽”了光芒。LDM 可能认为，DU 已经能解决其核心问题，没必要再单独搞一个“半成品”。</li>
</ul>
<p>C# 的“积压项”并非创意的坟场，而是一个战略孵化器。它表明 C# 团队拥有一个跨越数年的前瞻性视野，他们是在进行一种高度战略化的、对语言设计进行长期组合投资的管理。</p>
<h2 id="未来展望一个更深思熟虑的-c"><strong>未来展望：一个更深思熟虑的 C#</strong></h2>
<p>剖析完这些“幽灵”特性，C# 的演进原则也清晰地浮现出来：</p>
<ol>
<li><strong>清晰性至上</strong>：对任何可能引入“魔法”、模糊代码控制流的特性都保持高度警惕。</li>
<li><strong>增量优于革命</strong>：即使是革命性的概念，也倾向于小步快跑、向后兼容的演进。</li>
<li><strong>生态系统为王</strong>：对二进制兼容性和 NuGet 生态的敬畏，是阻止激进特性的强大“制动器”。</li>
<li><strong>兼顾性能</strong>：对性能的追求，尤其是 AOT 场景，是创新的重要驱动力。</li>
</ol>
<p>那么，我们可以大胆预测：</p>
<ul>
<li><strong>C# 15</strong>：很可能会迎来“类联合”的第一个版本，这将是 C# 拥抱函数式编程的坚实一步。关于拦截器的故事也将有新进展。</li>
<li><strong>C# 16+</strong>：更复杂的 DU 形式和类型类等，依然在地平线的远方，将继续遵循其深思熟虑的节奏。</li>
</ul>
<p>一门语言的价值，不仅在于它包含了什么，更在于它明智地选择了不包含什么。C# 14 的这些“幽灵”，并非过去的遗憾，而是照亮未来的路标。它们预示着一个更加健壮、更具表达力，也更加深思熟虑的 C# 正在向我们走来。</p>
<hr>
<p>感谢阅读到这里，如果感觉本文对您有帮助，请不吝<strong>评论</strong>和<strong>点赞</strong>，这也是我持续创作的动力！<br>
也欢迎加入我的 <strong>.NET骚操作 QQ群：495782587</strong>，一起交流.NET 和 AI 的各种有趣玩法！</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-07 08:45">2025-08-07 08:45</span>&nbsp;
<a href="https://www.cnblogs.com/sdcb">.NET骚操作</a>&nbsp;
阅读(<span id="post_view_count">81</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19026035);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19026035', targetLink: 'https://www.cnblogs.com/sdcb/p/19026035/unimplemented-csharp-14-features', title: '那些被推迟的 C# 14 特性及其背后的故事' })">举报</a>
</div>
        