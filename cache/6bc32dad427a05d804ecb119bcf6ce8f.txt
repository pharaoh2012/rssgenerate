
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/TianTianChaoFangDe/p/18758849" title="发布于 2025-03-08 02:19">
    <span role="heading" aria-level="2">【杭电多校比赛记录】2025“钉耙编程”中国大学生算法设计春季联赛（1）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><a href="https://acm.hdu.edu.cn/contest/problems?cid=1150" title="比赛链接" target="_blank" rel="noopener nofollow">比赛链接</a><br>
<a href="https://www.cnblogs.com/TianTianChaoFangDe/p/18758849" title="博客园原文链接（防盗）" target="_blank">博客园原文链接（防盗）</a></p>
<h2 id="开题情况">开题情况</h2>
<p>还是很吃教训的一场比赛，被博弈论硬控两小时（很好的一个博弈论题），dijkstra被卡map，最终三题。<br>
<img src="https://img2024.cnblogs.com/blog/3572902/202503/3572902-20250308005234237-240237513.png" alt="image" loading="lazy"><br>
自己不会的东西还是太多了，还得多多练习多多长见识。</p>
<h2 id="1001---签到">1001 - 签到</h2>
<p>题如其名，签到题，问给出的字符串第一次出现的位置。</p>
<details>
<summary>点击查看代码</summary>
<pre><code class="language-cpp">void solve()
{
    int n;cin &gt;&gt; n;
    string s;cin &gt;&gt; s;

    bool ck = false;
    for(int i = 1;i &lt;= n;i ++) {
        string t;cin &gt;&gt; t;
        if(s == t) {
            cout &lt;&lt; i &lt;&lt; '\n';
            ck = true;
        }
    }

    if(!ck)cout &lt;&lt; -1 &lt;&lt; '\n';
}
</code></pre>
</details>  
<h2 id="1006---密码">1006 - 密码</h2>
<p>移项可得：<span class="math inline">\(x = (c - b) / a\)</span>，那么只要枚举一下 <span class="math inline">\(u, v, w\)</span> 的两两组合，组合起来的作差取绝对值，剩下那一个也取绝对值，若能整除则添加贡献，对于求得的所有值，贡献为 <span class="math inline">\(n\)</span> 的就是答案（注意对于每一组 <span class="math inline">\(u, v, w\)</span> 要去重一下只能算一次贡献，否则难以计数）。</p>
<details>
<summary>点击查看代码</summary>
<pre><code>void solve()
{
    map&lt;int, int&gt; mp;
    int n;cin &gt;&gt; n;
    for(int i = 1;i &lt;= n;i ++)cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];

    set&lt;int&gt; st;
    for(int i = 1;i &lt;= n;i ++) {
        st.clear();
        if(abs(a[i] - b[i]) % abs(c[i]) == 0) {
            st.insert(abs(a[i] - b[i]) / abs(c[i]));
        }

        if(abs(a[i] - c[i]) % abs(b[i]) == 0) {
            st.insert(abs(a[i] - c[i]) / abs(b[i]));
        }

        if(abs(b[i] - c[i]) % abs(a[i]) == 0) {
            st.insert(abs(b[i] - c[i]) / abs(a[i]));
        }

        for(auto &amp;i : st) {
            mp[i] ++;
        }
    }

    for(auto &amp;[u, v] : mp) {
        if(v == n) {
            cout &lt;&lt; u &lt;&lt; '\n';
            break;
        }
    }
}
</code></pre>
</details> 
<h2 id="1007---分配宝藏">1007 - 分配宝藏</h2>
<p>很好的一道博弈论题，之前遇到的博弈论，都是两个人博弈，分析必胜态和必败态就行了。<br>
这里我们要分析的就不是必胜态和必败态了，而是 <span class="math inline">\(n\)</span> 个人的诉求。<br>
关于这 <span class="math inline">\(n\)</span> 个人的诉求，题目有一句话很凝练：保证自己不被杀死的前提下企图获得更大的利益。<br>
也就是说，既要保全自己，又要尽可能让自己有尽可能多的钱。<br>
也就是说，对于船长，要尽可能给少，对于其他人，要尽可能拿多。<br>
对于此题，我们可以用类似两人博弈的思路来思考，从结局往回推。<br>
我们将所有船员从后往前编号为 <span class="math inline">\(1, 2, 3, ..., n\)</span>。<br>
对于 <span class="math inline">\(n = 1\)</span>，此时无论如何染染一定不会被杀，因此不用给钱，分到的钱为 <span class="math inline">\(0\)</span>。<br>
对于 <span class="math inline">\(n = 2\)</span>，我们必须贿赂一个船员举手不杀染染，才能保全染染，那对于 <span class="math inline">\(1\)</span> 号船员和 <span class="math inline">\(2\)</span> 号船员，贿赂谁呢？<br>
注意到，如果染染被杀，此时人数变为 <span class="math inline">\(1\)</span>，那么此时的船长就会按照 <span class="math inline">\(n = 1\)</span> 时的最优策略来分配宝藏，也就是 <span class="math inline">\(1\)</span> 号船员会分到 <span class="math inline">\(0\)</span> 元，我们死了过后，<span class="math inline">\(1\)</span> 号船员无法获得金币，因此，我们给他 <span class="math inline">\(1\)</span> 个金币，对他来说就是赚的，那他也一定不会杀掉染染，此时过半，染染存活，而对于 <span class="math inline">\(2\)</span> 号船员，如果染染死掉，他会成为船长，他可以随意选择给自己留多少金币，因此就算贿赂了他他也会杀掉染染，因此不能贿赂 <span class="math inline">\(2\)</span> 号船员，因此 <span class="math inline">\(n = 2\)</span> 时的答案为 <span class="math inline">\(0,1\)</span>。<br>
我们继续按上述思路分析，当 <span class="math inline">\(n = 3\)</span> 时，如果染染被杀，此时人数变为 <span class="math inline">\(2\)</span>，那么此时的船长就会按照 <span class="math inline">\(n = 2\)</span> 时的最优策略来分配宝藏，也就是 <span class="math inline">\(0,1\)</span>，那么回到 <span class="math inline">\(n = 3\)</span> 的情况，如果染染被杀，<span class="math inline">\(2\)</span> 号船员无法获得金币，因此，我们给他 <span class="math inline">\(1\)</span> 个金币，对他来说就是赚的，那他也一定不会杀掉染染，而对于 <span class="math inline">\(1\)</span> 号船员，如果染染被杀，他仍能获得一个金币，若要贿赂他需要花费 <span class="math inline">\(2\)</span> 金币，不优，因此不能贿赂 <span class="math inline">\(1\)</span> 号船员，对于 <span class="math inline">\(3\)</span> 号船员，如果染染死掉，他会成为船长，他可以随意选择给自己留多少金币，因此就算贿赂了他他也会杀掉染染，因此不能贿赂 <span class="math inline">\(3\)</span> 号船员，因此 <span class="math inline">\(n = 3\)</span> 时的答案为 <span class="math inline">\(0,1,0\)</span>。<br>
按这个逻辑推下去我们会发现，其实我们要贿赂的，就是染染死掉之后，得不到金币的，此时只需要花费一个金币就能贿赂到他不杀自己，并且这个数量加上染染后一定会过半（我们可以通过分析染染贿赂的人数少了过后对下一位船长的决策优越性的影响来证明这个事情，见下方），否则对于染染死后下一个船长的最优解会不成立，所以答案就构造出来了，可以发现获得金币为 <span class="math inline">\(1\)</span> 的船员的序号序列就是一个公差为 <span class="math inline">\(2\)</span> 的等差数列，只需要找好首项和末项即可。<br>
简单证明一下：首先无论奇偶，需要贿赂的人都是 <span class="math inline">\(\lfloor n / 2 \rfloor\)</span>。</p>
<ul>
<li>若 <span class="math inline">\(n\)</span> 是奇数，则 <span class="math inline">\(\lfloor n / 2 \rfloor = \lfloor (n - 1) / 2 \rfloor\)</span>，那么如果这一轮染染贿赂到的人少于 <span class="math inline">\(\lfloor n / 2 \rfloor\)</span>，那么说明染染死后下一位船长贿赂到的人就多于 <span class="math inline">\(\lfloor n / 2 \rfloor\)</span>，对下一位船长来说这个结果一定不优。</li>
<li>若 <span class="math inline">\(n\)</span> 是偶数，则 <span class="math inline">\(\lfloor n / 2 \rfloor = \lfloor (n - 1) / 2 \rfloor + 1\)</span>，由上面的分析可得，染染一定不会贿赂下一位船长，因此染染的贿赂考虑人数范围实际上是 <span class="math inline">\(n - 1\)</span> 人，这与下一位船长之后的人数相同，在这些人里面，如果染染少贿赂一个，那么说明下一位船长就多贿赂了一个，对下一位船长来说这个结果一定不优。</li>
</ul>
<p>再仔细复盘一下，其实这个和两个人的博弈是类似的，两个人的博弈，会存在一个必胜态和必败态的转化，每个人的行为都是为了让自己获胜，那在这个题里面，对于每一个人单独分析，也就存在一个杀掉船长后，自己是获利还是亏损，也就是题目说的“更大的利益”，要不要杀当前的船长，自然也就出来了，并且对于每一个船长，为了保全自己，也就是题目说的“保证自己不被杀死”，自然也就会选择最优选择，那么杀掉染染之后的分金币情况也就出来了。</p>
<p>红温记录：<br>
<img src="https://img2024.cnblogs.com/blog/3572902/202503/3572902-20250308021230139-577974863.png" alt="image" loading="lazy"></p>
<details>
<summary>点击查看代码（省略了逆元）</summary>
<pre><code class="language-cpp">void solve()
{
    int n;cin &gt;&gt; n;

    int sum = n / 2;

    int ans = 0;

    if(n &amp; 1)n --;

    ans = (n + n - (sum - 1) * 2) % M * sum % M * inv(2);

    cout &lt;&lt; (ans % M + M) % M &lt;&lt; '\n';
} 
</code></pre>
</details>
<h2 id="1005---航线">1005 - 航线</h2>
<p>很明显的dijkstra求最短路，博弈论做不出来的时候十分钟就出思路了，但是！！被卡map了...有亿点点无语啊啊啊！！！<br>
做这个题需要明确一点，dijkstra的本质是数据结构优化DP，因此状态很重要，每一个点的四个方向作为dijkstra每个点的四种状态！然后用dijkstra进行转向和移动就行，具体看代码吧，一看就懂，但是被卡map真的很难受啊啊啊啊QWQ，以后能开数组绝不用map了。</p>
<details>
<summary>点击查看代码</summary>
<pre><code>struct Node {
    int x, y, t, di;
    bool operator &lt; (const Node &amp;v) const {
        return t &gt; v.t;
    }
};

int n, m;

bool inmp(int x, int y) {
    return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m;
}

int dijk(vector&lt;vector&lt;int&gt;&gt; &amp;t, vector&lt;vector&lt;int&gt;&gt; &amp;d) {
    priority_queue&lt;Node&gt; pq;
    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; vis(n + 2, vector&lt;vector&lt;int&gt;&gt;(m + 2, vector&lt;int&gt;(4, 0)));

    pq.push({1, 1, t[1][1], 1});

    while(pq.size()) {
        auto [x, y, pret, predi] = pq.top();
        pq.pop();

        if(x == n &amp;&amp; y == m &amp;&amp; predi == 0) {
            return pret;
        }

        if(vis[x][y][predi])continue;
        vis[x][y][predi] = true;

        pq.push({x, y, pret + d[x][y], (predi + 1) % 4});
        pq.push({x, y, pret + d[x][y], (predi + 2) % 4});
        pq.push({x, y, pret + d[x][y], (predi + 3) % 4});

        if(predi == 0 &amp;&amp; inmp(x + 1, y)) {
            pq.push({x + 1, y, pret + t[x + 1][y], predi});
        }

        if(predi == 1 &amp;&amp; inmp(x, y + 1)) {
            pq.push({x, y + 1, pret + t[x][y + 1], predi});
        }

        if(predi == 2 &amp;&amp; inmp(x - 1, y)) {
            pq.push({x - 1, y, pret + t[x - 1][y], predi});
        }

        if(predi == 3 &amp;&amp; inmp(x, y - 1)) {
            pq.push({x, y - 1, pret + t[x][y - 1], predi});
        }
    }
}

void solve()
{
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt; &gt; t(n + 2, vector&lt;int&gt;(m + 2, 0)), d(n + 2, vector&lt;int&gt;(m + 2, 0));

    for(int i = 1;i &lt;= n;i ++) {
        for(int j = 1;j &lt;= m;j ++) {
            cin &gt;&gt; t[i][j];
        }
    }

    for(int i = 1;i &lt;= n;i ++) {
        for(int j = 1;j &lt;= m;j ++) {
            cin &gt;&gt; d[i][j];
        }
    }

    cout &lt;&lt; dijk(t, d) &lt;&lt; '\n';
}
</code></pre>
</details>

</div>
<div id="MySignature" role="contentinfo">
    <!-- 版权保护 -->
<div style="background:#ffcccc; color:#0; font-size:small;">
    <p>
            作者：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>
    </p>
    <p>
            出处：
            <a href="https://www.cnblogs.com/TianTianChaoFangDe">https://www.cnblogs.com/TianTianChaoFangDe</a>
    </p>
    <p>
            关于作者：ACMer，算法竞赛爱好者
    </p>
    <p>
             本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显醒目位置给出,
             <a href="#" onclick="Curgo()" style="background:#b6ff00; color:#0; font-size:medium;">原文链接</a>
             如有问题， 可邮件（1005333612@qq.com）咨询.
    </p>
    
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.2843337239988426" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-08 15:27">2025-03-08 02:19</span>&nbsp;
<a href="https://www.cnblogs.com/TianTianChaoFangDe">天天超方的</a>&nbsp;
阅读(<span id="post_view_count">102</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18758849" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18758849);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18758849', targetLink: 'https://www.cnblogs.com/TianTianChaoFangDe/p/18758849', title: '【杭电多校比赛记录】2025“钉耙编程”中国大学生算法设计春季联赛（1）' })">举报</a>
</div>
        