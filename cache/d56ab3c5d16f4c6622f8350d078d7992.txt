
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/hsyluxiaoguo/p/18902335" title="发布于 2025-05-29 11:28">
    <span role="heading" aria-level="2">在LLVM中的greedy Register Allocation pass代码详解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="llvm-贪婪寄存器分配器ragreedy详细处理流程">LLVM 贪婪寄存器分配器（RAGreedy）详细处理流程</h1>
<p><strong>日期</strong>: 2025年5月29日</p>
<h2 id="摘要">摘要</h2>
<p>本文深入分析 LLVM 贪婪寄存器分配器（RAGreedy）的处理流程，详细描述从优先级队列获取虚拟寄存器、分配物理寄存器、处理分配失败的每一步逻辑。特别聚焦于驱逐、分割、溢出、重新着色和 CSR 处理的细粒度实现细节，包括数据结构交互、条件判断和优化策略。文档适合编译器开发者深入理解 RAGreedy 的内部机制。</p>
<h2 id="目录">目录</h2>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0" rel="noopener nofollow">概述</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B" rel="noopener nofollow">处理流程</a>
<ul>
<li><a href="#1-%E8%8E%B7%E5%8F%96%E8%99%9A%E6%8B%9F%E5%AF%84%E5%AD%98%E5%99%A8" rel="noopener nofollow">1. 获取虚拟寄存器</a>
<ul>
<li><a href="#11-%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%A1%E7%AE%97%E9%80%BB%E8%BE%91" rel="noopener nofollow">1.1 优先级计算逻辑</a></li>
<li><a href="#12-%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C" rel="noopener nofollow">1.2 队列操作</a></li>
</ul>
</li>
<li><a href="#2-%E5%88%86%E9%85%8D%E7%89%A9%E7%90%86%E5%AF%84%E5%AD%98%E5%99%A8" rel="noopener nofollow">2. 分配物理寄存器</a>
<ul>
<li><a href="#21-%E5%88%86%E9%85%8D%E5%B0%9D%E8%AF%95%E9%80%BB%E8%BE%91" rel="noopener nofollow">2.1 分配尝试逻辑</a></li>
<li><a href="#22-%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%88%90%E6%9C%AC%E8%AF%84%E4%BC%B0" rel="noopener nofollow">2.2 冲突检测与成本评估</a></li>
</ul>
</li>
<li><a href="#3-%E5%A4%84%E7%90%86%E5%88%86%E9%85%8D%E5%A4%B1%E8%B4%A5" rel="noopener nofollow">3. 处理分配失败</a>
<ul>
<li><a href="#31-%E9%A9%B1%E9%80%90%E5%B9%B2%E6%89%B0" rel="noopener nofollow">3.1 驱逐干扰</a>
<ul>
<li><a href="#311-%E5%B9%B2%E6%89%B0%E8%AF%86%E5%88%AB" rel="noopener nofollow">3.1.1 干扰识别</a></li>
<li><a href="#312-%E9%A9%B1%E9%80%90%E5%80%99%E9%80%89%E9%80%89%E6%8B%A9" rel="noopener nofollow">3.1.2 驱逐候选选择</a></li>
<li><a href="#313-%E9%A9%B1%E9%80%90%E6%89%A7%E8%A1%8C" rel="noopener nofollow">3.1.3 驱逐执行</a></li>
</ul>
</li>
<li><a href="#32-%E5%88%86%E5%89%B2%E6%B4%BB%E8%B7%83%E5%8C%BA%E9%97%B4" rel="noopener nofollow">3.2 分割活跃区间</a>
<ul>
<li><a href="#321-%E5%B1%80%E9%83%A8%E5%88%86%E5%89%B2" rel="noopener nofollow">3.2.1 局部分割</a></li>
<li><a href="#322-%E5%8C%BA%E5%9F%9F%E5%88%86%E5%89%B2" rel="noopener nofollow">3.2.2 区域分割</a></li>
<li><a href="#323-%E5%9D%97%E7%BA%A7%E5%88%86%E5%89%B2" rel="noopener nofollow">3.2.3 块级分割</a></li>
<li><a href="#324-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%88%86%E5%89%B2" rel="noopener nofollow">3.2.4 指令级分割</a></li>
</ul>
</li>
<li><a href="#33-%E6%BA%A2%E5%87%BA" rel="noopener nofollow">3.3 溢出</a>
<ul>
<li><a href="#331-%E6%BA%A2%E5%87%BA%E6%9D%A1%E4%BB%B6" rel="noopener nofollow">3.3.1 溢出条件</a></li>
<li><a href="#332-%E5%BB%B6%E8%BF%9F%E6%BA%A2%E5%87%BA" rel="noopener nofollow">3.3.2 延迟溢出</a></li>
<li><a href="#333-%E6%BA%A2%E5%87%BA%E6%89%A7%E8%A1%8C" rel="noopener nofollow">3.3.3 溢出执行</a></li>
</ul>
</li>
<li><a href="#34-%E6%9C%80%E5%90%8E%E6%9C%BA%E4%BC%9A%E9%87%8D%E6%96%B0%E7%9D%80%E8%89%B2" rel="noopener nofollow">3.4 最后机会重新着色</a>
<ul>
<li><a href="#341-%E9%80%92%E5%BD%92%E6%90%9C%E7%B4%A2" rel="noopener nofollow">3.4.1 递归搜索</a></li>
<li><a href="#342-%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6" rel="noopener nofollow">3.4.2 限制条件</a></li>
<li><a href="#343-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86" rel="noopener nofollow">3.4.3 状态管理</a></li>
</ul>
</li>
<li><a href="#35-csr-%E5%A4%84%E7%90%86" rel="noopener nofollow">3.5 CSR 处理</a>
<ul>
<li><a href="#351-%E6%88%90%E6%9C%AC%E6%AF%94%E8%BE%83" rel="noopener nofollow">3.5.1 成本比较</a></li>
<li><a href="#352-csr-%E5%88%86%E9%85%8D" rel="noopener nofollow">3.5.2 CSR 分配</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E6%8F%90%E7%A4%BA%E4%BC%98%E5%8C%96" rel="noopener nofollow">4. 提示优化</a>
<ul>
<li><a href="#41-%E6%8B%B7%E8%B4%9D%E5%88%86%E6%9E%90" rel="noopener nofollow">4.1 拷贝分析</a></li>
<li><a href="#42-%E9%87%8D%E6%96%B0%E7%9D%80%E8%89%B2%E4%BC%98%E5%8C%96" rel="noopener nofollow">4.2 重新着色优化</a></li>
</ul>
</li>
<li><a href="#5-%E5%90%8E%E5%A4%84%E7%90%86%E4%B8%8E%E7%BB%9F%E8%AE%A1" rel="noopener nofollow">5. 后处理与统计</a>
<ul>
<li><a href="#51-%E5%90%8E%E5%A4%84%E7%90%86" rel="noopener nofollow">5.1 后处理</a></li>
<li><a href="#52-%E7%BB%9F%E8%AE%A1%E6%8A%A5%E5%91%8A" rel="noopener nofollow">5.2 统计报告</a></li>
<li><a href="#53-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE" rel="noopener nofollow">5.3 资源释放</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%B3%E9%94%AE%E4%BC%98%E5%8C%96%E7%82%B9" rel="noopener nofollow">关键优化点</a></li>
<li><a href="#%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90" rel="noopener nofollow">调试与分析</a></li>
<li><a href="#%E6%80%BB%E7%BB%93" rel="noopener nofollow">总结</a></li>
</ul>
<h2 id="概述">概述</h2>
<p>RAGreedy 是 LLVM 代码生成流水线中的核心寄存器分配器，采用贪婪策略为虚拟寄存器分配物理寄存器，目标是最小化内存溢出并优化性能。其核心逻辑在 <code>allocatePhysRegs</code> 函数中，通过优先级队列（<code>PriorityQueue</code>）管理虚拟寄存器，并调用 <code>selectOrSplit</code> 分配物理寄存器。分配失败时，RAGreedy 使用驱逐、分割、溢出、重新着色和 CSR 处理等策略解决问题。本文将深入每个子步骤的处理逻辑，结合伪代码和数据结构交互细节。</p>
<h2 id="处理流程">处理流程</h2>
<p>以下是 RAGreedy 的详细处理流程，分为五个主要阶段</p>
<h3 id="1-获取虚拟寄存器">1. 获取虚拟寄存器</h3>
<p>RAGreedy 使用优先级队列管理虚拟寄存器（<code>VirtReg</code>），确保高优先级的寄存器优先分配。</p>
<h4 id="11-优先级计算逻辑">1.1 优先级计算逻辑</h4>
<p>优先级由 <code>DefaultPriorityAdvisor::getPriority</code> 计算，基于以下因素：</p>
<ul>
<li><strong>活跃区间大小</strong>：通过 <code>LiveIntervals</code> 计算 <code>VirtReg</code> 的活跃区间长度（<code>LiveInterval::getSize</code>）。较大的区间优先级更高，因为溢出成本高。</li>
<li><strong>寄存器类优先级</strong>：<code>TargetRegisterInfo</code> 定义寄存器类（如 <code>GPR</code>、<code>FPR</code>）的优先级。例如，通用寄存器通常优先于专用寄存器。</li>
<li><strong>全局 vs 局部</strong>：全局区间（跨多个基本块，<code>LiveInterval::isCrossBB</code>）优先于局部区间（单基本块）。</li>
<li><strong>分配提示</strong>：通过 <code>getHints()</code> 获取提示寄存器（如拷贝指令 <code>r1 = COPY r2</code> 提示 <code>r1</code> 和 <code>r2</code> 使用同一寄存器），提示寄存器优先级更高。</li>
<li><strong>分配阶段</strong>：<code>VirtReg</code> 的阶段（<code>RS_Assign</code>、<code>RS_Split</code>、<code>RS_Spill</code>）影响优先级。例如，<code>RS_Assign</code>（初始分配）优先于 <code>RS_Split</code>（分割后）。</li>
</ul>
<p><strong>逻辑</strong>：</p>
<ul>
<li>计算权重：<code>Weight = Size * Frequency + HintBonus</code>，其中 <code>Frequency</code> 是基本块执行频率（<code>MachineBlockFrequencyInfo</code>），<code>HintBonus</code> 是提示奖励。</li>
<li>比较权重：<code>getPriority</code> 返回比较值，优先级队列按降序排序。</li>
<li>命令行选项：
<ul>
<li><code>GreedyRegClassPriorityTrumpsGlobalness</code>：优先寄存器类而非全局性。</li>
<li><code>GreedyReverseLocalAssignment</code>：优先短局部区间。</li>
</ul>
</li>
</ul>
<p><strong>伪代码</strong>：</p>
<pre><code class="language-cpp">float getPriority(VirtReg) {
  LiveInterval &amp;LI = LIS-&gt;getInterval(VirtReg);
  float Size = LI.getSize();
  float Freq = MBFI-&gt;getBlockFreq(LI.getParentBB());
  float HintBonus = hasHint(VirtReg) ? HINT_WEIGHT : 0;
  float Weight = Size * Freq + HintBonus;
  if (GreedyRegClassPriorityTrumpsGlobalness)
    Weight += RegClassPriority(LI.getRegClass());
  if (GreedyReverseLocalAssignment &amp;&amp; !LI.isCrossBB())
    Weight = 1.0 / Weight; // 短区间优先
  return Weight;
}
</code></pre>
<h4 id="12-队列操作">1.2 队列操作</h4>
<p><strong>逻辑</strong>：</p>
<ul>
<li><strong>初始化</strong>：在 <code>allocatePhysRegs</code> 中，遍历所有虚拟寄存器，调用 <code>enqueue</code> 加入队列：<pre><code class="language-cpp">for (VirtReg in VirtRegMap) {
  Queue.enqueue(VirtReg, getPriority(VirtReg));
}
</code></pre>
</li>
<li><strong>获取</strong>：循环调用 <code>dequeue</code> 获取最高优先级的 <code>VirtReg</code>：<pre><code class="language-cpp">while (Queue.hasReady()) {
  VirtReg = Queue.dequeue();
  selectOrSplit(VirtReg, NewVRegs);
}
</code></pre>
</li>
<li><strong>动态更新</strong>：新生成的虚拟寄存器（<code>NewVRegs</code>）通过 <code>enqueue</code> 重新加入队列。</li>
</ul>
<p><strong>数据结构</strong>：</p>
<ul>
<li><code>PriorityQueue</code>：基于堆的优先级队列，维护 <code>VirtReg</code> 和优先级。</li>
<li><code>LiveIntervals</code>：存储活跃区间信息。</li>
<li><code>MachineBlockFrequencyInfo</code>：提供基本块频率。</li>
</ul>
<p><strong>结果</strong>：获取优先级最高的 <code>VirtReg</code>，传递给 <code>selectOrSplit</code>。</p>
<h3 id="2-分配物理寄存器">2. 分配物理寄存器</h3>
<p><code>selectOrSplit</code> 调用 <code>selectOrSplitImpl</code> 为 <code>VirtReg</code> 分配物理寄存器，返回 <code>PhysReg</code> 或 <code>~0u</code>。</p>
<h4 id="21-分配尝试逻辑">2.1 分配尝试逻辑</h4>
<p><code>tryAssign</code> 尝试分配物理寄存器，基于寄存器类和提示。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li><strong>初始化分配顺序</strong>：
<ul>
<li>使用 <code>AllocationOrder</code> 生成物理寄存器列表：<pre><code class="language-cpp">AllocationOrder Order(VirtReg, RegClass, TRI, Hints);
</code></pre>
</li>
<li>顺序基于：
<ul>
<li>寄存器类约束（<code>RegClass</code>）。</li>
<li>提示寄存器（<code>Hints</code>）。</li>
<li>架构偏好（<code>TargetRegisterInfo::getAllocatableSet</code>）。</li>
</ul>
</li>
<li>命令行选项 <code>SplitThresholdForRegWithHint</code> 决定是否优先提示。</li>
</ul>
</li>
<li><strong>遍历物理寄存器</strong>：
<ul>
<li>调用 <code>Order.next()</code> 获取下一个 <code>PhysReg</code>。</li>
</ul>
</li>
<li><strong>冲突与分配</strong>：
<ul>
<li>调用 <code>tryAssign</code> 检查 <code>PhysReg</code> 是否可用。</li>
</ul>
</li>
</ol>
<p><strong>伪代码</strong>：</p>
<pre><code class="language-cpp">unsigned tryAssign(LiveInterval &amp;VirtReg, AllocationOrder &amp;Order, SmallVectorImpl&lt;unsigned&gt; &amp;NewVRegs) {
  while (unsigned PhysReg = Order.next()) {
    // 分配逻辑（见下文）
  }
  return ~0u;
}
</code></pre>
<h4 id="22-冲突检测与成本评估">2.2 冲突检测与成本评估</h4>
<p><strong>逻辑</strong>：</p>
<ul>
<li><strong>冲突检测</strong>：
<ul>
<li>调用 <code>LiveRegMatrix::checkInterference(VirtReg, PhysReg)</code>：<pre><code class="language-cpp">InterferenceKind IK = Matrix-&gt;checkInterference(VirtReg, PhysReg);
</code></pre>
</li>
<li>返回值：
<ul>
<li><code>IK_Free</code>：<code>PhysReg</code> 空闲。</li>
<li><code>IK_VirtReg</code>：被其他虚拟寄存器占用。</li>
<li><code>IK_PhysReg</code>：被固定物理寄存器占用。</li>
</ul>
</li>
</ul>
</li>
<li><strong>成本评估</strong>：
<ul>
<li>计算 <code>PhysReg</code> 成本（<code>RegCosts</code>）：<pre><code class="language-cpp">float Cost = calculateRegCost(PhysReg, VirtReg);
</code></pre>
</li>
<li>成本因素：
<ul>
<li>提示匹配：<code>isHint(VirtReg, PhysReg)</code> 降低成本。</li>
<li>CSR 开销：<code>CSRCost</code>（由 <code>CSRFirstTimeCost</code> 设置）。</li>
<li>别名成本：<code>TargetRegisterInfo::getAliasCost</code>。</li>
</ul>
</li>
<li>判断：
<ul>
<li>若 <code>Cost &lt;= CostPerUseLimit</code>，接受 <code>PhysReg</code>。</li>
<li>否则，尝试驱逐。</li>
</ul>
</li>
</ul>
</li>
<li><strong>分配</strong>：
<ul>
<li>若 <code>IK_Free</code> 且成本可接受：<pre><code class="language-cpp">Matrix-&gt;assign(VirtReg, PhysReg);
VRM-&gt;assignVirt2Phys(VirtReg, PhysReg);
return PhysReg;
</code></pre>
</li>
<li>若 <code>IK_VirtReg</code>，调用 <code>tryEvict</code>。</li>
</ul>
</li>
</ul>
<p><strong>伪代码</strong>：</p>
<pre><code class="language-cpp">unsigned tryAssign(LiveInterval &amp;VirtReg, AllocationOrder &amp;Order, SmallVectorImpl&lt;unsigned&gt; &amp;NewVRegs) {
  while (unsigned PhysReg = Order.next()) {
    InterferenceKind IK = Matrix-&gt;checkInterference(VirtReg, PhysReg);
    if (IK == IK_Free) {
      if (isHint(VirtReg, PhysReg) || calculateRegCost(PhysReg) &lt;= CostPerUseLimit) {
        Matrix-&gt;assign(VirtReg, PhysReg);
        VRM-&gt;assignVirt2Phys(VirtReg, PhysReg);
        return PhysReg;
      }
    } else if (IK == IK_VirtReg) {
      if (tryEvict(VirtReg, PhysReg, NewVRegs))
        return PhysReg;
    }
  }
  if (!isHintAssigned(VirtReg))
    SetOfBrokenHints.insert(VirtReg);
  return ~0u;
}
</code></pre>
<p><strong>数据结构</strong>：</p>
<ul>
<li><code>LiveRegMatrix</code>：管理干扰关系。</li>
<li><code>VirtRegMap</code>：记录虚拟到物理寄存器的映射。</li>
<li><code>InterferenceCache</code>：加速冲突检测。</li>
</ul>
<p><strong>结果</strong>：</p>
<ul>
<li>成功：返回 <code>PhysReg</code>，更新状态。</li>
<li>失败：进入失败处理。</li>
</ul>
<h3 id="3-处理分配失败">3. 处理分配失败</h3>
<p>分配失败时，RAGreedy 按以下顺序尝试策略：</p>
<h4 id="31-驱逐干扰">3.1 驱逐干扰</h4>
<p><code>tryEvict</code> 释放被占用的 <code>PhysReg</code>。</p>
<h5 id="311-干扰识别">3.1.1 干扰识别</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>使用 <code>LiveRegMatrix</code> 获取干扰寄存器：<pre><code class="language-cpp">SmallVector&lt;LiveInterval*, 8&gt; Intfs;
Matrix-&gt;getInterferences(VirtReg, PhysReg, Intfs);
</code></pre>
</li>
</ul>
<h5 id="312-驱逐候选选择">3.1.2 驱逐候选选择</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>调用 <code>EvictAdvisor::canEvictInterference</code>：<pre><code class="language-cpp">bool canEvict = EvictAdvisor-&gt;canEvictInterference(VirtReg, PhysReg);
</code></pre>
</li>
<li>条件：
<ul>
<li>干扰寄存器可重新分配（<code>canReassign</code>）。</li>
<li>驱逐成本低于 <code>CostPerUseLimit</code>：<pre><code class="language-cpp">float EvictCost = calculateEvictCost(Intfs);
if (EvictCost &gt; CostPerUseLimit) return false;
</code></pre>
</li>
</ul>
</li>
<li>优先选择低权重寄存器（<code>LiveInterval::getWeight</code>）。</li>
</ul>
<h5 id="313-驱逐执行">3.1.3 驱逐执行</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>调用 <code>evictInterference</code>：<pre><code class="language-cpp">void evictInterference(LiveInterval &amp;VirtReg, unsigned PhysReg, SmallVectorImpl&lt;unsigned&gt; &amp;NewVRegs) {
  for (LiveInterval *Intf : Intfs) {
    Matrix-&gt;unassign(Intf);
    VRM-&gt;clearVirt(Intf-&gt;reg);
    NewVRegs.push_back(Intf-&gt;reg);
  }
  ++NumEvictions;
}
</code></pre>
</li>
<li>使用级联号防止循环驱逐：<pre><code class="language-cpp">VirtReg.Cascade++;
</code></pre>
</li>
</ul>
<p><strong>伪代码</strong>：</p>
<pre><code class="language-cpp">bool tryEvict(LiveInterval &amp;VirtReg, unsigned PhysReg, SmallVectorImpl&lt;unsigned&gt; &amp;NewVRegs) {
  SmallVector&lt;LiveInterval*, 8&gt; Intfs;
  Matrix-&gt;getInterferences(VirtReg, PhysReg, Intfs);
  if (!EvictAdvisor-&gt;canEvictInterference(VirtReg, PhysReg, Intfs))
    return false;
  for (LiveInterval *Intf : Intfs) {
    Matrix-&gt;unassign(Intf);
    VRM-&gt;clearVirt(Intf-&gt;reg);
    NewVRegs.push_back(Intf-&gt;reg);
  }
  VirtReg.Cascade++;
  ++NumEvictions;
  return true;
}
</code></pre>
<p><strong>结果</strong>：</p>
<ul>
<li>成功：返回 <code>PhysReg</code>。</li>
<li>失败：尝试分割。</li>
</ul>
<h4 id="32-分割活跃区间">3.2 分割活跃区间</h4>
<p><code>trySplit</code> 分割 <code>VirtReg</code> 的活跃区间，生成子区间。</p>
<h5 id="321-局部分割">3.2.1 局部分割</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>适用：单基本块内的活跃区间。</li>
<li>计算间隙权重（<code>calcGapWeights</code>）：<pre><code class="language-cpp">SmallVector&lt;float, 16&gt; GapWeights;
calcGapWeights(VirtReg, GapWeights);
</code></pre>
</li>
<li>选择最低成本的间隙：<pre><code class="language-cpp">unsigned BestGap = findMinWeightGap(GapWeights);
</code></pre>
</li>
<li>分割：<pre><code class="language-cpp">LiveInterval *NewLI = splitLiveInterval(VirtReg, BestGap);
NewVRegs.push_back(NewLI-&gt;reg);
</code></pre>
</li>
</ul>
<h5 id="322-区域分割">3.2.2 区域分割</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>适用：跨块的全局区间。</li>
<li>使用 <code>SpillPlacement</code> 分析活跃性：<pre><code class="language-cpp">SpillPlacement-&gt;analyze(VirtReg);
</code></pre>
</li>
<li>计算分割成本（<code>calculateRegionSplitCost</code>）：<pre><code class="language-cpp">float SplitCost = calculateRegionSplitCost(VirtReg, ColdRegions);
if (SplitCost &gt;= SpillCost) return false;
</code></pre>
</li>
<li>在冷区域分割：<pre><code class="language-cpp">LiveInterval *NewLI = doRegionSplit(VirtReg, ColdRegions);
NewVRegs.push_back(NewLI-&gt;reg);
</code></pre>
</li>
</ul>
<h5 id="323-块级分割">3.2.3 块级分割</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>隔离到每个基本块：<pre><code class="language-cpp">SmallVector&lt;LiveInterval*, 4&gt; NewLIs;
splitLiveIntervalPerBlock(VirtReg, NewLIs);
for (LiveInterval *LI : NewLIs)
  NewVRegs.push_back(LI-&gt;reg);
</code></pre>
</li>
</ul>
<h5 id="324-指令级分割">3.2.4 指令级分割</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>围绕指令分割，优化受限寄存器类：<pre><code class="language-cpp">LiveInterval *NewLI = splitAroundInstruction(VirtReg, Instr);
NewVRegs.push_back(NewLI-&gt;reg);
</code></pre>
</li>
</ul>
<p><strong>综合逻辑</strong>：</p>
<ul>
<li>按顺序尝试分割类型：<pre><code class="language-cpp">unsigned trySplit(LiveInterval &amp;VirtReg, AllocationOrder &amp;Order, SmallVectorImpl&lt;unsigned&gt; &amp;NewVRegs) {
  if (tryLocalSplit(VirtReg, Order, NewVRegs)) return 0;
  if (tryRegionSplit(VirtReg, Order, NewVRegs)) return 0;
  if (tryBlockSplit(VirtReg, Order, NewVRegs)) return 0;
  if (tryInstructionSplit(VirtReg, Order, NewVRegs)) return 0;
  return ~0u;
}
</code></pre>
</li>
<li>控制复杂性：<code>GrowRegionComplexityBudget</code> 限制子区间数量。</li>
</ul>
<p><strong>结果</strong>：</p>
<ul>
<li>成功：新寄存器加入 <code>NewVRegs</code>。</li>
<li>失败：尝试溢出。</li>
</ul>
<h4 id="33-溢出">3.3 溢出</h4>
<p><code>spill</code> 将 <code>VirtReg</code> 溢出到内存。</p>
<h5 id="331-溢出条件">3.3.1 溢出条件</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>检查是否可溢出：<pre><code class="language-cpp">if (!VirtReg.isSpillable()) return ~0u;
</code></pre>
</li>
</ul>
<h5 id="332-延迟溢出">3.3.2 延迟溢出</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>若启用 <code>EnableDeferredSpilling</code>：<pre><code class="language-cpp">VirtReg.Stage = RS_Memory;
return 0;
</code></pre>
</li>
</ul>
<h5 id="333-溢出执行">3.3.3 溢出执行</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>使用 <code>SpillerInstance</code>：<pre><code class="language-cpp">SpillerInstance-&gt;spill(&amp;VirtReg, NewVRegs);
</code></pre>
</li>
<li>生成加载/存储指令，更新 <code>LiveIntervals</code> 和 <code>LiveDebugVariables</code>。</li>
<li>标记 <code>RS_Done</code>。</li>
</ul>
<p><strong>伪代码</strong>：</p>
<pre><code class="language-cpp">unsigned spill(LiveInterval &amp;VirtReg, SmallVectorImpl&lt;unsigned&gt; &amp;NewVRegs) {
  if (!VirtReg.isSpillable()) return ~0u;
  if (EnableDeferredSpilling) {
    VirtReg.Stage = RS_Memory;
    return 0;
  }
  SpillerInstance-&gt;spill(&amp;VirtReg, NewVRegs);
  VirtReg.Stage = RS_Done;
  ++NumSpills;
  return 0;
}
</code></pre>
<p><strong>结果</strong>：</p>
<ul>
<li>成功：新寄存器加入队列。</li>
<li>失败：尝试重新着色。</li>
</ul>
<h4 id="34-最后机会重新着色">3.4 最后机会重新着色</h4>
<p><code>tryLastChanceRecoloring</code> 重新分配干扰寄存器。</p>
<h5 id="341-递归搜索">3.4.1 递归搜索</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>调用 <code>tryRecoloringCandidates</code>：<pre><code class="language-cpp">bool tryRecoloringCandidates(LiveInterval &amp;VirtReg, AllocationOrder &amp;Order, SmallVectorImpl&lt;unsigned&gt; &amp;NewVRegs);
</code></pre>
</li>
<li>递归尝试为干扰寄存器分配新 <code>PhysReg</code>。</li>
</ul>
<h5 id="342-限制条件">3.4.2 限制条件</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>最大深度：<code>LastChanceRecoloringMaxDepth</code>。</li>
<li>最大干扰数量：<code>LastChanceRecoloringMaxInterference</code>。</li>
<li>若 <code>ExhaustiveSearch</code>，禁用限制。</li>
</ul>
<h5 id="343-状态管理">3.4.3 状态管理</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li><code>FixedRegisters</code>：防止重复着色。</li>
<li><code>RecolorStack</code>：记录状态，支持回滚。</li>
</ul>
<p><strong>伪代码</strong>：</p>
<pre><code class="language-cpp">unsigned tryLastChanceRecoloring(LiveInterval &amp;VirtReg, AllocationOrder &amp;Order, SmallVectorImpl&lt;unsigned&gt; &amp;NewVRegs) {
  if (RecolorStack.size() &gt;= LastChanceRecoloringMaxDepth &amp;&amp; !ExhaustiveSearch)
    return ~0u;
  RecolorStack.push(VirtReg);
  if (tryRecoloringCandidates(VirtReg, Order, NewVRegs)) {
    PhysReg = Order.getLast();
    Matrix-&gt;assign(VirtReg, PhysReg);
    VRM-&gt;assignVirt2Phys(VirtReg, PhysReg);
    RecolorStack.pop();
    return PhysReg;
  }
  RecolorStack.pop();
  return ~0u;
}
</code></pre>
<p><strong>结果</strong>：</p>
<ul>
<li>成功：返回 <code>PhysReg</code>。</li>
<li>失败：触发错误。</li>
</ul>
<h4 id="35-csr-处理">3.5 CSR 处理</h4>
<p><code>tryAssignCSRFirstTime</code> 使用未用的 CSR。</p>
<h5 id="351-成本比较">3.5.1 成本比较</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>计算 CSR 成本：<pre><code class="language-cpp">float CSRCost = getCSRCost(VirtReg);
</code></pre>
</li>
<li>比较：<pre><code class="language-cpp">if (CSRCost &gt;= SpillCost || CSRCost &gt;= SplitCost) return ~0u;
</code></pre>
</li>
</ul>
<h5 id="352-csr-分配">3.5.2 CSR 分配</h5>
<p><strong>逻辑</strong>：</p>
<ul>
<li>分配 CSR：<pre><code class="language-cpp">PhysReg = Order.getCSR();
Matrix-&gt;assign(VirtReg, PhysReg);
VRM-&gt;assignVirt2Phys(VirtReg, PhysReg);
CostPerUseLimit = 1; // 限制后续驱逐
</code></pre>
</li>
</ul>
<p><strong>伪代码</strong>：</p>
<pre><code class="language-cpp">unsigned tryAssignCSRFirstTime(LiveInterval &amp;VirtReg, AllocationOrder &amp;Order, SmallVectorImpl&lt;unsigned&gt; &amp;NewVRegs) {
  float CSRCost = getCSRCost(VirtReg);
  if (CSRCost &lt; SpillCost &amp;&amp; CSRCost &lt; SplitCost) {
    unsigned PhysReg = Order.getCSR();
    Matrix-&gt;assign(VirtReg, PhysReg);
    VRM-&gt;assignVirt2Phys(VirtReg, PhysReg);
    CostPerUseLimit = 1;
    return PhysReg;
  }
  return ~0u;
}
</code></pre>
<h3 id="4-提示优化">4. 提示优化</h3>
<p><code>tryHintsRecoloring</code> 修复未分配到提示寄存器的 <code>VirtReg</code>。</p>
<h4 id="41-拷贝分析">4.1 拷贝分析</h4>
<p><strong>逻辑</strong>：</p>
<ul>
<li>遍历 <code>SetOfBrokenHints</code>：<pre><code class="language-cpp">for (unsigned VirtReg : SetOfBrokenHints) {
  collectHintInfo(VirtReg, Copies);
}
</code></pre>
</li>
<li>收集拷贝指令（如 <code>r1 = COPY r2</code>）。</li>
</ul>
<h4 id="42-重新着色优化">4.2 重新着色优化</h4>
<p><strong>逻辑</strong>：</p>
<ul>
<li>计算成本：<pre><code class="language-cpp">float Cost = getBrokenHintFreq(Copies);
</code></pre>
</li>
<li>若重新着色降低成本：<pre><code class="language-cpp">tryHintRecoloring(VirtReg);
</code></pre>
</li>
</ul>
<p><strong>伪代码</strong>：</p>
<pre><code class="language-cpp">void tryHintsRecoloring() {
  for (unsigned VirtReg : SetOfBrokenHints) {
    SmallVector&lt;MachineInstr*, 8&gt; Copies;
    collectHintInfo(VirtReg, Copies);
    if (getBrokenHintFreq(Copies) &gt; 0) {
      tryHintRecoloring(VirtReg);
      ++NumHintRecolorings;
    }
  }
}
</code></pre>
<h3 id="5-后处理与统计">5. 后处理与统计</h3>
<h4 id="51-后处理">5.1 后处理</h4>
<p><strong>逻辑</strong>：</p>
<ul>
<li>删除冗余拷贝：<pre><code class="language-cpp">removeRedundantCopies();
</code></pre>
</li>
<li>处理溢出/重载指令。</li>
<li>更新调试信息：<pre><code class="language-cpp">LiveDebugVariables-&gt;update();
</code></pre>
</li>
</ul>
<h4 id="52-统计报告">5.2 统计报告</h4>
<p><strong>逻辑</strong>：</p>
<ul>
<li>记录统计：<pre><code class="language-cpp">++NumSpills; ++NumReloads; ++NumCopies;
</code></pre>
</li>
<li>生成报告：<pre><code class="language-cpp">MachineOptimizationRemarkMissed Report;
Report.addStatistic("Spills", NumSpills);
</code></pre>
</li>
</ul>
<h4 id="53-资源释放">5.3 资源释放</h4>
<p><strong>逻辑</strong>：</p>
<ul>
<li>释放临时数据：<pre><code class="language-cpp">SpillerInstance.reset();
GlobalCand.clear();
</code></pre>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>RAGreedy 通过优先级队列驱动的贪婪分配，结合细粒度的驱逐、分割、溢出和重新着色策略，实现高效寄存器分配。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.28439297883796294" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-29 11:28">2025-05-29 11:28</span>&nbsp;
<a href="https://www.cnblogs.com/hsyluxiaoguo">拾光、</a>&nbsp;
阅读(<span id="post_view_count">21</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18902335);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18902335', targetLink: 'https://www.cnblogs.com/hsyluxiaoguo/p/18902335', title: '在LLVM中的greedy Register Allocation pass代码详解' })">举报</a>
</div>
        