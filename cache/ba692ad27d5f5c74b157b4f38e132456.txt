
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ThinkerQAQ/p/18943971" title="发布于 2025-06-23 11:12">
    <span role="heading" aria-level="2">Java源码分析系列笔记-4.CAS</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#1-是什么" rel="noopener nofollow">1. 是什么</a><ul><li><a href="#11-乐观锁与悲观锁" rel="noopener nofollow">1.1. 乐观锁与悲观锁</a></li><li><a href="#12-cas" rel="noopener nofollow">1.2. CAS</a></li></ul></li><li><a href="#2-如何使用" rel="noopener nofollow">2. 如何使用</a><ul><li><a href="#21-atomic是什么" rel="noopener nofollow">2.1. Atomic是什么</a></li><li><a href="#22-atomic使用" rel="noopener nofollow">2.2. Atomic使用</a></li><li><a href="#23-atomic原理分析" rel="noopener nofollow">2.3. Atomic原理分析</a><ul><li><a href="#231-构造方法" rel="noopener nofollow">2.3.1. 构造方法</a></li><li><a href="#232-addandget方法" rel="noopener nofollow">2.3.2. addAndGet方法</a></li><li><a href="#233-getandincrement" rel="noopener nofollow">2.3.3. getAndIncrement</a></li><li><a href="#234-decrementandget" rel="noopener nofollow">2.3.4. decrementAndGet</a></li></ul></li><li><a href="#24-atomicinteger的问题" rel="noopener nofollow">2.4. AtomicInteger的问题</a><ul><li><a href="#241-cpu占用过高" rel="noopener nofollow">2.4.1. CPU占用过高</a></li><li><a href="#242-aba问题" rel="noopener nofollow">2.4.2. ABA问题</a><ul><li><a href="#2421-解决方案版本号" rel="noopener nofollow">2.4.2.1. 解决方案：版本号</a><ul><li><a href="#24211-原理分析" rel="noopener nofollow">2.4.2.1.1. 原理分析</a></li></ul></li></ul></li></ul></li></ul></li><li><a href="#3-参考" rel="noopener nofollow">3. 参考</a></li></ul></div><p></p>
<h2 id="1-是什么">1. 是什么</h2>
<p>要理解CAS，我们首先得了解乐观锁和悲观锁的概念。</p>
<h3 id="11-乐观锁与悲观锁">1.1. 乐观锁与悲观锁</h3>
<p>悲观锁：假设每次操作数据的时候总有人一起操作数据。因此我操作数据前先上锁，直到我操作完释放锁，别人都只能阻塞等待。<br>
乐观锁：假设每次操作数据的时候没人跟我一起操作数据。因此我只在更新的时候检查一下有没有其他人修改了数据，有则重试直到成功。</p>
<h3 id="12-cas">1.2. CAS</h3>
<p>CAS是乐观锁的一种。Java中的AQS、AtomicXXX都是基于CAS实现的。<br>
CAS全称叫compare and set，即比较并设置某个变量的值，他是原子操作。<br>
我们以CAS(A,B)为例，这里涉及了三个值，一个实际内存值A1，当前读取的值A（或者叫预期值A），及其修改值B。当且仅当A1== A时，把值修改为B</p>
<h2 id="2-如何使用">2. 如何使用</h2>
<p>JUC包中Atomic类的实现都是通过CAS实现的</p>
<h3 id="21-atomic是什么">2.1. Atomic是什么</h3>
<p>线程安全的原子类，底层使用CAS实现</p>
<h3 id="22-atomic使用">2.2. Atomic使用</h3>
<p>以AtomicInteger为例</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException
{
    AtomicInteger val = new AtomicInteger(0);
    Thread addThread = new Thread(()-&gt;{
        for (int i = 0; i &lt; 10000; i++)
        {
            val.addAndGet(1);
        }
    });

    Thread decrThread = new Thread(()-&gt;{
        for (int i = 0; i &lt; 10000; i++)
        {
            val.decrementAndGet();
        }
    });


    addThread.start();
    decrThread.start();

    addThread.join();
    decrThread.join();

    System.out.println(val.get());//0
}
</code></pre>
<h3 id="23-atomic原理分析">2.3. Atomic原理分析</h3>
<h4 id="231-构造方法">2.3.1. 构造方法</h4>
<pre><code class="language-java">//使用的是Unsafe.compareAndSwapInt 方法
private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;

//类加载的时候执行
static {
    try {
    	//valueOffset保存的是AtomicInteger value属性在内存中的地址
    	//后面调用Unsafe的CAS方法会用到这个值
        valueOffset = unsafe.objectFieldOffset
            (AtomicInteger.class.getDeclaredField("value"));
    } catch (Exception ex) { throw new Error(ex); }
}

//volatile:某线程更新后，其他线程立马看到修改后的值
private volatile int value;

public AtomicInteger(int initialValue) {
    value = initialValue;
}
</code></pre>
<p>可以看到主要有三个属性：<code>Unsafe unsafe </code>、<code>long valueOffset</code>和<code>volatile int value</code></p>
<ul>
<li>关于Unsafe类的解释参考<a href="../../Unsafe/Unsafe.md" target="_blank" rel="noopener nofollow">Unsafe.md</a>，有了这个基础后源码分析就简单多了。</li>
<li>valueOffset是value变量在内存中的地址</li>
<li>value使用volatile修饰，这样就能保证可见性和有序性</li>
</ul>
<h4 id="232-addandget方法">2.3.2. addAndGet方法</h4>
<ul>
<li>AtomicInteger.addAndGet</li>
</ul>
<pre><code class="language-java">public final int addAndGet(int delta) {
    return unsafe.getAndAddInt(this, valueOffset, delta) + delta;
}
</code></pre>
<p>调用Unsafe类的getAndAddInt方法对value增加delta<br>
由于Unsafe的方法返回value原值，所以需要加上delta才是增加后的值</p>
<ul>
<li>Unsafe.getAndAddInt</li>
</ul>
<pre><code class="language-java">//传入Unsafe.getAndAddInt的参数为（AtomicInteger实例，AtomicInteger value属性的内存地址，增加的值）
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    //死循环+cas
    do {
    	//获取对象o偏移offset地址的值，即value的值
        v = getIntVolatile(o, offset);
        //判断对象o在偏移offset地址的值 == v（刚刚获取的值）么？是的话把值+delta写入
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    //返回原来的value
    return v;
}

//以下两个都native方法，调用C/C++的方法
public final native boolean compareAndSwapInt(Object o, long offset,
                                                  int expected,
                                                  int x);

public native int getIntVolatile(Object o, long offset);

</code></pre>
<p>说明都在代码的注释上，不多说了</p>
<h4 id="233-getandincrement">2.3.3. getAndIncrement</h4>
<ul>
<li>AtomicInteger.getAndIncrement</li>
</ul>
<pre><code class="language-java">public final int getAndIncrement() {
	//同AtomicInteger.addAndGet方法，调用Unsafe类的getAndAddInt方法对value增加delta，返回value原值
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
</code></pre>
<h4 id="234-decrementandget">2.3.4. decrementAndGet</h4>
<ul>
<li>AtomicInteger.decrementAndGet</li>
</ul>
<pre><code class="language-java">public final int decrementAndGet() {
    //同AtomicInteger.addAndGet方法，调用Unsafe类的getAndAddInt方法对value增加delta，返回value原值
    //只不过传入的delta是个负数，也就是相当于减去了一个数
    return unsafe.getAndAddInt(this, valueOffset, -1) - 1;
}
</code></pre>
<h3 id="24-atomicinteger的问题">2.4. AtomicInteger的问题</h3>
<h4 id="241-cpu占用过高">2.4.1. CPU占用过高</h4>
<p>多线程并发修改如果竞争特别激烈，那么cpu消耗过大，毕竟是死循环+CAS原子操作修改</p>
<h4 id="242-aba问题">2.4.2. ABA问题</h4>
<p>假设有两个线程都要修改a的值，ThreadA和ThreadB，操作步骤如下</p>
<ul>
<li>ThreadA：</li>
</ul>
<pre><code>第1步 get a为1
第2步 失去cpu
第7步 cas（a, 1, 2）
</code></pre>
<ul>
<li>ThreadB：</li>
</ul>
<pre><code>第3步 get a为1
第4步 cas（a, 1, 3）
第5步 cas（a, 3, 1）
第6步 失去cpu
</code></pre>
<p>从上述顺序看出a的值被线程B从1改为3又改为1， 而线程A以为a的值没有变化，仍然是1，进而把它改为2</p>
<h5 id="2421-解决方案版本号">2.4.2.1. 解决方案：版本号</h5>
<p>我们可以给数据加上版本号来解决ABA问题，即更新的时候不仅比较内存值是否相等，还要比较数据的版本是否相等，只有内存值和版本号相等的情况下才进行更新。<br>
用上面的例子进行说明：</p>
<ul>
<li>ThreadA：</li>
</ul>
<pre><code>第1步 get a为(1, 1) //即数据为1，版本为1
第2步 失去cpu
第7步 cas（a, 1, 2, 1, 2）//即预期数据为1，要改为2；预期版本号为1，要改为2。这一步执行失败因为此时版本已经为3了，不为1
</code></pre>
<ul>
<li>ThreadB：</li>
</ul>
<pre><code>第3步 get a为(1, 1) //即数据为1，版本为1
第4步 cas（a, 1, 3, 1, 2）//即预期数据为1，要改为3；预期版本号为1，要改为2
第5步 cas（a, 3, 1, 2, 3） //即预期数据为3，要改为1；预期版本号为2，要改为3
第6步 失去cpu
</code></pre>
<p>Java中已经有一个类实现了版本号：AtomicStampedReference，使用如下：</p>
<pre><code class="language-java">public static void main(String[] args)
{

    //初始化版本号为0,值为0
    AtomicStampedReference&lt;Integer&gt; val = new AtomicStampedReference&lt;&gt;(0,0);
    //在版本号为0,值为0的基础上cas
    val.compareAndSet(0, 1, 0, 1)
}
</code></pre>
<h6 id="24211-原理分析">2.4.2.1.1. 原理分析</h6>
<ul>
<li>AtomicStampedReference构造方法</li>
</ul>
<pre><code class="language-java">//Pair属性用volatile修饰
private volatile Pair&lt;V&gt; pair;

public AtomicStampedReference(V initialRef, int initialStamp) {
		//使用初始值和初始版本号构造pair
        pair = Pair.of(initialRef, initialStamp);
    }

//Pair类
private static class Pair&lt;T&gt; {
	//用final修饰，一旦初始化就不能改变，保证了线程安全
    final T reference;
    final int stamp;
    private Pair(T reference, int stamp) {
        this.reference = reference;
        this.stamp = stamp;
    }
    static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) {
        return new Pair&lt;T&gt;(reference, stamp);
    }
}

//类加载的时候初始化Unsafe类和AtomicStampedReference的pair属性的内存地址
private static final sun.misc.Unsafe UNSAFE = sun.misc.Unsafe.getUnsafe();
private static final long pairOffset =
    objectFieldOffset(UNSAFE, "pair", AtomicStampedReference.class);

</code></pre>
<ul>
<li>AtomicStampedReference.compareAndSet</li>
</ul>
<pre><code class="language-java">当前：0,0,修改成：1,1 Param：(0,1,0,1):(期望值，新的值，期望的版本号，新的版本号)
public boolean compareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp) {
        Pair&lt;V&gt; current = pair;
        return
        	//期望值==实际内存值
            expectedReference == current.reference &amp;&amp;
            //期望版本号==实际内存版本号
            expectedStamp == current.stamp &amp;&amp;

            //第1种情况：值和版本号都没有改变，那么不需要做什么 
            //1.1 新值==实际内存值
            ((newReference == current.reference &amp;&amp;
              //1.2 新版本号==实际版本号
              newStamp == current.stamp) ||
              
            ||第2中情况：值或版本号有改变，那么cas设置当前pair为新的pair 
             casPair(current, Pair.of(newReference, newStamp)));
    }

private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) {
	//调用Unsafe类的方法。把pair属性从cmp修改为val
    return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);
}
</code></pre>
<h2 id="3-参考">3. 参考</h2>
<ul>
<li><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener nofollow">Java CAS 原理剖析 - 掘金</a></li>
<li><a href="https://juejin.im/post/5c87afa06fb9a049f1550b04#heading-3" target="_blank" rel="noopener nofollow">CAS原理分析及ABA问题详解 - 掘金</a></li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-06-23 11:13">2025-06-23 11:12</span>&nbsp;
<a href="https://www.cnblogs.com/ThinkerQAQ">ThinkerQAQ</a>&nbsp;
阅读(<span id="post_view_count">86</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18943971);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18943971', targetLink: 'https://www.cnblogs.com/ThinkerQAQ/p/18943971', title: 'Java源码分析系列笔记-4.CAS' })">举报</a>
</div>
        