
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18660712" title="发布于 2025-01-14 09:30">
    <span role="heading" aria-level="2">用远程代理模式轻松实现远程服务调用，打开编程新大门</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>通过<strong>远程代理</strong>来实现一个简易的<strong>远程过程调用</strong>实例。带你打开新的大门。</p>
<h2 id="socket-远程代理服务案例">Socket 远程代理服务案例</h2>
<p>基于 <strong>Socket</strong> 的远程服务，我们需要完成以下步骤：</p>
<ol>
<li><strong>服务端实现</strong>：创建一个远程服务，通过 <strong>Socket</strong> 接受客户端请求并提供计算服务。</li>
<li><strong>客户端实现</strong>：客户端通过代理类访问远程计算服务，代理通过网络与服务器交互。</li>
<li><strong>代理类</strong>：代理类会通过网络与服务器建立连接，转发请求并返回响应。</li>
</ol>
<p>看下案例类图应该就明白了</p>
<h3 id="案例类图">案例类图</h3>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250108222046172-2012914670.png" alt="image" loading="lazy"></p>
<p>客户端和服务端都共有服务接口<code>RemoteCalculationService</code>，服务端实现了该接口的具体处理逻辑，客户端通过<code>socket</code>来完成具体服务的调用。</p>
<p>在这里必须明确理解的一个点就是，客户端的<code>远程代理类</code>。这个<strong>远程代理类</strong>是一个实现了共有服务接口<code>RemoteCalculationService</code>的实现类，但是在真实的场景中，这个代理类不需要我们手工动去实现，一般由所依赖的底层去实现（比如<code>Apache CXF</code>），我们要做的事情是配置IP和端口等操作，然后调用接口内的方法即可。</p>
<p>客户端在这个过程中只需要关注这个服务接口<code>RemoteCalculationService</code>有什么方法可以使用、具体传什么参数和返回值是什么即可，<strong>给开发者的感觉就像是调用本地方法一样</strong>。</p>
<p>具体代码实现如下：</p>
<h3 id="远程服务接口">远程服务接口</h3>
<p>我们首先定义一个远程计算服务接口，它提供加法和减法功能：</p>
<pre><code class="language-java">// 远程接口
public interface RemoteCalculationService {
    int add(int a, int b);
    int subtract(int a, int b);
}
</code></pre>
<h3 id="远程服务实现">远程服务实现</h3>
<p>然后实现该接口，模拟一个远程计算服务。此服务将被远程调用：</p>
<pre><code class="language-java">public class RemoteCalculationServiceImpl implements RemoteCalculationService {

    @Override
    public int add(int a, int b) {
        return a + b;
    }

    @Override
    public int subtract(int a, int b) {
        return a - b;
    }

}
</code></pre>
<h3 id="远程服务处理器">远程服务处理器</h3>
<p>该类负责处理来自客户端的请求，它从网络中读取数据并返回计算结果：</p>
<pre><code class="language-java">import java.io.*;
import java.net.*;

public class RemoteCalculationServiceHandler implements Runnable {
    private Socket socket;

    public RemoteCalculationServiceHandler(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try (
                ObjectInputStream inputStream = new ObjectInputStream(socket.getInputStream());
                ObjectOutputStream outputStream = new ObjectOutputStream(socket.getOutputStream())
        ) {
            // 读取请求的操作
            String operation = (String) inputStream.readObject();
            int a = inputStream.readInt();
            int b = inputStream.readInt();

            RemoteCalculationServiceImpl service = new RemoteCalculationServiceImpl();
            int result = 0;
            System.out.println("执行的操作："+operation);
            // 根据操作执行相应的计算
            if ("add".equals(operation)) {
                result = service.add(a, b);
            } else if ("subtract".equals(operation)) {
                result = service.subtract(a, b);
            }
            System.out.println("执行结果："+result);
            // 发送结果回客户端
            outputStream.writeInt(result);
            outputStream.flush();
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            try {
                socket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<h3 id="远程socket服务">远程Socket服务</h3>
<pre><code class="language-java">public class RemoteServer {

    // 服务器端启动
    public static void main(String[] args) {
        try (ServerSocket serverSocket = new ServerSocket(8080)) {
            System.out.println("Server is running...");
            while (true) {
                Socket socket = serverSocket.accept();
                new Thread(new RemoteCalculationServiceHandler(socket)).start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="远程服务代理类">远程服务代理类</h3>
<p>代理类负责与远程服务通信。客户端调用代理的方法时，代理会通过 <code>Socket</code> 连接到远程服务器，将请求发送给远程服务，然后返回结果。</p>
<pre><code class="language-java">import java.io.*;
import java.net.*;

public class RemoteCalculationServiceProxy implements RemoteCalculationService {
    private String serverAddress;
    private int serverPort;

    public RemoteCalculationServiceProxy(String serverAddress, int serverPort) {
        this.serverAddress = serverAddress;
        this.serverPort = serverPort;
    }

    @Override
    public int add(int a, int b) {
        return sendRequest("add", a, b);
    }

    @Override
    public int subtract(int a, int b) {
        return sendRequest("subtract", a, b);
    }

    private int sendRequest(String operation, int a, int b) {
        try (
            Socket socket = new Socket(serverAddress, serverPort);
            ObjectOutputStream outputStream = new ObjectOutputStream(socket.getOutputStream());
            ObjectInputStream inputStream = new ObjectInputStream(socket.getInputStream())
        ) {
            // 发送操作请求
            outputStream.writeObject(operation);
            outputStream.writeInt(a);
            outputStream.writeInt(b);
            outputStream.flush();

            // 读取结果
            return inputStream.readInt();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return 0;
    }
}
</code></pre>
<h3 id="客户端">客户端</h3>
<p>客户端通过 <code>RemoteCalculationServiceProxy</code> 访问远程计算服务。代理会将请求发送到服务器并接收响应。</p>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        RemoteCalculationService service = new RemoteCalculationServiceProxy("localhost", 8080);

        // 通过代理调用远程服务
        System.out.println("add 执行结果: " + service.add(10, 5));
        System.out.println("subtract 执行结果: " + service.subtract(10, 5));
    }
}
</code></pre>
<h3 id="运行步骤">运行步骤</h3>
<p><strong>1.运行服务器端</strong></p>
<p>首先运行服务器端<code>RemoteServer</code>，这会启动一个 <code>ServerSocket</code> 来监听客户端的请求。每当接收到客户端请求时，服务器会在一个新线程中处理。</p>
<p><strong>2.运行客户端</strong></p>
<p>然后启动客户端<code>Client</code>，它通过代理类与服务器端进行交互，发送计算请求并接收结果。</p>
<h3 id="结果输出">结果输出</h3>
<p>远程服务端输出结果：</p>
<blockquote>
<p>Server is running...</p>
<p>执行的操作：add</p>
<p>执行结果：15</p>
<p>执行的操作：subtract</p>
<p>执行结果：5</p>
</blockquote>
<p>客户端输出结果</p>
<blockquote>
<p>add 执行结果: 15</p>
<p>subtract 执行结果: 5</p>
</blockquote>
<h2 id="远程代理的应用">远程代理的应用</h2>
<p>比如：<code>Apache CXF</code> 服务框架</p>
<pre><code class="language-java">import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;

public class Client {
    public static void main(String[] args) {
        JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();
        factory.setServiceClass(HelloWorldService.class);
        factory.setAddress("http://localhost:8080/hello");
        HelloWorldService service = (HelloWorldService) factory.create();
        System.out.println(service.sayHello("World"));
    }
}
</code></pre>
<p>配置服务接口class和服务路由，通过工厂模式创建对应的远程代理实例化对象，客户端只需要关注接口有什么方法即可，调用远程服务方法就像是调用本地方法一样。</p>
<p>比如：<code>RPC</code>协议框架，例如：dubbo、gRPC等。</p>
<h2 id="总结">总结</h2>
<p>通过这种实现，您可以模拟一个基于 <code>Socket</code> 的远程服务和远程代理的应用。客户端通过 <code>RemoteCalculationServiceProxy</code> 与远程服务进行通信，而远程服务通过<code>RemoteCalculationServiceImpl</code> 提供计算功能。<strong>客户端在使用代理对象进行操作时，就像是调用本地的方法一样，无感的实现远程方法的调用</strong>。这种调用方式又称为远程过程调用。常用的远程过程调用框架有CXF、Dubbo、gRPC等等，其核心思想之一都是<strong>远程代理</strong>，它实现了在本地调用远程服务时的<strong>透明性</strong>，使得远程调用看起来像本地调用。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202501/1209017-20250108222143296-1653978167.gif" alt="image" loading="lazy"></p>
<p>需要查看往期设计模式文章的，可以在个人主页中或者文章开头的集合中查看，可关注我，持续更新中。。。</p>
<hr>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5273929813518519" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-14 09:39">2025-01-14 09:30</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">184</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18660712" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18660712);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18660712', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18660712', title: '用远程代理模式轻松实现远程服务调用，打开编程新大门' })">举报</a>
</div>
        