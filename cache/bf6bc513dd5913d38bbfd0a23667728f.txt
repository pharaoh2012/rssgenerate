
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/songszh/p/18651840/Maximum-Weight-Closure-of-a-Graph" title="发布于 2025-01-05 19:53">
    <span role="heading" aria-level="2">最大权闭合图</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="0前言">0.前言</h2>
<p>参考文献：胡伯涛《最小割模型在信息学竞赛中的应用》</p>
<p>本文总结了上书最大权闭合图一章节核心内容及其应用。如有错误请指出。</p>
<h2 id="1最大权闭合图">1.最大权闭合图</h2>
<p>对于有向图 <span class="math inline">\(G = (V,E)\)</span> 的一个子图，如果其点集 <span class="math inline">\(V_1\)</span> 中点的后继都还在 <span class="math inline">\(V_1\)</span> 中，则称其为原图的一个闭合图。</p>
<p>而最大权闭合图即为原图所有闭合图中点权之和最大的闭合图。</p>
<p>根据对最大权闭合图的定义，可以发现图上的连边关系对应了各点之间的依赖性，如果要构成一个闭合图，当我们向 <span class="math inline">\(V_1\)</span> 中加入了某个点 <span class="math inline">\(u\)</span>，则 <span class="math inline">\(u\)</span> 的所有出边所连向的点 <span class="math inline">\(v\)</span> 也需要加入 <span class="math inline">\(V_1\)</span>，这样才能保证 <span class="math inline">\(G = (V_1,E_1)\)</span> 是一个闭合图。而对于最大权，则可以体现为最优贡献，闭合图点集中每个点根据其点权的正负大小，会对答案造成相应的正、负贡献。接下来需要考虑如何将此类问题与最大流最小割相联系。</p>
<p>要解决最大权闭合图一类问题，我们可以首先构造出其对应的网络 <span class="math inline">\(N = (V_N,E_N)\)</span>：</p>
<ol>
<li>建立源点 <span class="math inline">\(s\)</span> 与汇点 <span class="math inline">\(t\)</span>；</li>
<li>对于原图中的边 <span class="math inline">\((u,v)\)</span>，建立容量为 <span class="math inline">\(+\infty\)</span> 的有向边；</li>
<li>对于原图中的点 <span class="math inline">\(u\)</span>，<span class="math inline">\(w_u &gt; 0\)</span> 则建立 <span class="math inline">\((s,u)\)</span> 容量为 <span class="math inline">\(w_u\)</span>；<span class="math inline">\(w_u &lt; 0\)</span> 则建立 <span class="math inline">\((u,t)\)</span> 容量为 <span class="math inline">\(-w_u\)</span>；当 <span class="math inline">\(w_u = 0\)</span> 时无必要。</li>
</ol>
<p>我们使用常用的转化点权方式构造出了以上网络，考虑其有何性质。</p>
<ul>
<li>性质 1：网络 <span class="math inline">\(N\)</span> 的最小割一定是简单割。</li>
</ul>
<p>简单割即所有割边的一个端点为 <span class="math inline">\(s\)</span> 或 <span class="math inline">\(t\)</span>。因为除开与源汇相连的边，其余边的容量均为正无穷，那么最小割是肯定不会割掉这类边的。</p>
<ul>
<li>性质 2：网络 <span class="math inline">\(N\)</span> 的闭合图与简单割一一对应：<span class="math inline">\(V_1 \cup \{s\} = S\)</span>。</li>
</ul>
<p>证明从略。</p>
<ul>
<li>性质 3：<span class="math inline">\(||S,T|| = \sum\limits_{u \in V_1' \and w_u &gt; 0} w_u + \sum\limits_{u \in V_1 \and w_u &lt; 0} (-w_u)\)</span></li>
</ul>
<p>其中 <span class="math inline">\(V_1' = V - V_1\)</span>。<br>
因为割 <span class="math inline">\([S,T]\)</span> 其实就是源与 <span class="math inline">\(V_1'\)</span> 的连边与汇与 <span class="math inline">\(V_1\)</span> 的连边，根据网络 <span class="math inline">\(N\)</span> 的构造方式可得上式。</p>
<ul>
<li>性质 4：</li>
</ul>
<p></p><div class="math display">\[\sum\limits_{u \in V_1} w_u = \sum\limits_{u \in V_1 \and w_u &gt; 0} w_u - \sum\limits_{u \in V_1 \and w_u &lt; 0} (-w_u)\\
||S,T|| + \sum\limits_{u \in V_1} w_u = \sum\limits_{u \in V_1 \and w_u &gt; 0} w_u - \sum\limits_{u \in V_1 \and w_u &lt; 0} (-w_u) + \sum\limits_{u \in V_1' \and w_u &gt; 0} w_u + \sum\limits_{u \in V_1 \and w_u &lt; 0} (-w_u)\\
\sum\limits_{u \in V_1} w_u = \sum\limits_{u \in V \and w_u &gt; 0} w_u - ||S,T||
\]</div><p></p><p>根据性质 4，我们可以通过计算网络 <span class="math inline">\(N\)</span> 的最小割来计算最大权闭合图的权值。</p>
<h2 id="2例题">2.例题</h2>
<p><a href="https://luogu.com.cn/problem/P4174" target="_blank" rel="noopener nofollow"><strong>I.P4174 最大获利</strong></a></p>
<p>最大权闭合图板子题。<br>
对于一个用户群，他依赖两个中转站 <span class="math inline">\(a_i,b_i\)</span>，开通中转站需要一定成本，这个成本就是对我们的负贡献，而开通中转站能获得一些用户群的收益，这是正贡献，据此信息建图跑最大流即可，不难通过。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

#define int long long
#define ll long long
#define ull unsigned long long
#define db double
#define ld long double
#define rep(i,l,r) for (int i = (int)(l); i &lt;= (int)(r); ++ i )
#define rep1(i,l,r) for (int i = (int)(l); i &gt;= (int)(r); -- i )
#define il inline
#define fst first
#define snd second
#define ptc putchar
#define Yes ptc('Y'),ptc('e'),ptc('s'),puts("")
#define No ptc('N'),ptc('o'),puts("")
#define YES ptc('Y'),ptc('E'),ptc('S'),puts("")
#define NO ptc('N'),ptc('O'),puts("")
#define vi vector&lt;int&gt;
#define pb emplace_back
#define sz(x) (int)(x.size())
#define all(x) x.begin(),x.end()
#define me(a,x) memset(a,x,sizeof a)
#define get(x) ((x - 1) / len + 1)
#define debug() puts("------------")

using namespace std;
typedef pair&lt;int,int&gt; PII;
typedef pair&lt;int,PII&gt; PIII;
typedef pair&lt;ll,ll&gt; PLL;
namespace szhqwq {
    template&lt;class T&gt; il void read(T &amp;x) {
        x = 0; T f = 1; char ch = getchar();
        while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') f = -1; ch = getchar(); }
        while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); }
        x *= f;
    }
    template&lt;class T,class... Args&gt; il void read(T &amp;x,Args &amp;...x_) { read(x); read(x_...); }
    template&lt;class T&gt; il void print(T x) {
        if (x &lt; 0) ptc('-'), x = -x; 
        if (x &gt; 9) print(x / 10); ptc(x % 10 + '0');
    }
    template&lt;class T,class T_&gt; il void write(T x,T_ ch) { print(x); ptc(ch); }
    template&lt;class T,class T_&gt; il void chmax(T &amp;x,T_ y) { x = x &lt; (T)y ? (T)y : x; }
    template&lt;class T,class T_&gt; il void chmin(T &amp;x,T_ y) { x = x &gt; (T)y ? (T)y : x; }
    template&lt;class T,class T_,class T__&gt; il T qmi(T a,T_ b,T__ p) {
        T res = 1; while (b) {
            if (b &amp; 1) res = res * a % p;
            a = a * a % p; b &gt;&gt;= 1;
        } return res;
    }
    template&lt;class T&gt; il T gcd(T a,T b) { if (!b) return a; return gcd(b,a % b); }
    template&lt;class T,class T_&gt; il void exgcd(T a, T b, T_ &amp;x, T_ &amp;y) {
        if (b == 0) { x = 1; y = 0; return; }
        exgcd(b,a % b,y,x); y -= a / b * x; return ;
    }
    template&lt;class T,class T_&gt; il T getinv(T x,T_ p) { 
        T inv,y; exgcd(x,(T)p,inv,y);
        inv = (inv + p) % p; return inv;
    }
} using namespace szhqwq;
const int N = 1e6 + 10,inf = 1e9,mod = 998244353;
const ull base = 131,base_ = 233;
const ll inff = 1e18;
const db eps = 1e-6;
int n,m,s,t;
int h[N],cur[N],e[N &lt;&lt; 1],ne[N &lt;&lt; 1],idx;
ll d[N],w[N],ret; bool vis[N];

il void add(int a,int b,ll c) {
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx ++;
    return ;
}

il void add_edge(int a,int b,ll c) {
    add(a,b,c); add(b,a,0);
    return ;
}

il bool bfs() {
    rep(i,s,t) d[i] = inff,cur[i] = h[i],vis[i] = 0;
    queue&lt;int&gt; q; q.push(s); d[s] = 0;
    while (sz(q)) {
        int u = q.front(); q.pop();
        for (int i = h[u]; ~i; i = ne[i]) {
            int j = e[i];
            if (w[i] &gt; 0 &amp;&amp; d[j] == inff) {
                d[j] = d[u] + 1;
                vis[j] = 1; q.push(j);
            }
        }
    }
    return d[t] &lt; inff;
}

il ll dfs(int u,ll val) {
    if (u == t) return val;
    ll now = 0;
    for (int i = cur[u]; ~i; i = ne[i]) {
        cur[u] = i;
        int j = e[i];
        if (w[i] &gt; 0 &amp;&amp; d[j] == d[u] + 1) {
            ll x = dfs(j,min(w[i],val - now));
            if (x &lt;= 0) continue;
            now += x;
            w[i] -= x; w[i ^ 1] += x;
            if (now == val) return now;
        }
    }
    return now;
}

il void Dinic() {
    ret = 0;
    while (bfs()) ret += dfs(s,inff);
    return ;
}

il void solve() {
    //------------code------------
    read(n,m); s = 0,t = n + m + 1; me(h,-1);
    rep(i,1,n) {
        int p; read(p);
        add_edge(i + m,t,p);
    }
    ll sum = 0;
    rep(i,1,m) {
        int a,b,c; read(a,b,c);
        add_edge(s,i,c);
        add_edge(i,a + m,inf); add_edge(i,b + m,inf);
        sum += c;
    }
    Dinic();
    write(sum - ret,'\n');
    return ;
}

il void init() {
    return ;
}

signed main() {
    // init();
    int _ = 1;
    // read(_);
    while (_ -- ) solve();
    return 0;
}
</code></pre>
<p><a href="https://luogu.com.cn/problem/P2762" target="_blank" rel="noopener nofollow"><strong>II.P2762 太空飞行计划问题</strong></a></p>
<p>此题不仅需要求出最大权闭合图的最大权，还需要输出相应方案。<br>
根据<strong>性质 3</strong>，不难发现网络上割掉的边（满流的边）即为 <span class="math inline">\(V_1\)</span> 中的负贡献点向汇的连边以及 <span class="math inline">\(V_1\)</span> 补集中正贡献点向源的连边。实际上对于割 <span class="math inline">\([S,T]\)</span>，我们的方案就是集合 <span class="math inline">\(S - \{s\} = V_1\)</span>。<br>
这一点体现在代码上就是在我们不能再继续增广的时候最后一遍 bfs 分层参与分层的点即为 <span class="math inline">\(S\)</span> 集合中的点。所以做完 Dinic 后直接判断当前点是否参与分层就能输出方案。</p>
<p>这个题输入格式比较难受。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

#define int long long
#define ll long long
#define ull unsigned long long
#define rep(i,l,r) for (int i = (int)(l); i &lt;= (int)(r); ++ i )
#define rep1(i,l,r) for (int i = (int)(l); i &gt;= (int)(r); -- i )
#define il inline
#define fst first
#define snd second
#define ptc putchar
#define Yes ptc('Y'),ptc('e'),ptc('s'),puts("")
#define No ptc('N'),ptc('o'),puts("")
#define YES ptc('Y'),ptc('E'),ptc('S'),puts("")
#define NO ptc('N'),ptc('O'),puts("")
#define pb emplace_back
#define sz(x) (int)(x.size())
#define all(x) x.begin(),x.end()
#define debug() puts("------------------")

using namespace std;
typedef pair&lt;int,int&gt; PII;
typedef pair&lt;int,PII&gt; PIII;
namespace szhqwq {
    template&lt;class T&gt; il void read(T &amp;x) {
        x = 0; T f = 1; char ch = getchar();
        while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') f = -1; ch = getchar(); }
        while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); }
        x *= f;
    }
    template&lt;class T,class... Args&gt; il void read(T &amp;x,Args &amp;...x_) { read(x); read(x_...); }
    template&lt;class T&gt; il void print(T x) {
        if (x &lt; 0) ptc('-'), x = -x; 
        if (x &gt; 9) print(x / 10); ptc(x % 10 + '0');
    }
    template&lt;class T,class T_&gt; il void write(T x,T_ ch) { print(x); ptc(ch); }
    template&lt;class T,class T_&gt; il void chmax(T &amp;x,T_ y) { x = max(x,y); }
    template&lt;class T,class T_&gt; il void chmin(T &amp;x,T_ y) { x = min(x,y); }
    template&lt;class T,class T_,class T__&gt; il T qmi(T a,T_ b,T__ p) {
        T res = 1; while (b) {
            if (b &amp; 1) res = res * a % p;
            a = a * a % p; b &gt;&gt;= 1;
        } return res;
    }
    template&lt;class T&gt; il int getinv(T x,T p) { return qmi(x,p - 2,p); }
} using namespace szhqwq;
const int N = 6e6 + 10,inf = 1e9,mod = 998244353;
const ll inff = 1e18;
int n,m,s,t;
int h[N],e[N],ne[N],idx;
ll d[N],w[N];
bool vis[N];
int cur[N];
ll res;

int nail;
string str;
int read(){
    if(nail&gt;=str.size())return 0;
    int b=0;
    while(nail&lt;str.size() and (str[nail]&lt;'0' or str[nail]&gt;'9'))nail++;
    while(nail&lt;str.size() and str[nail]&gt;='0' and str[nail]&lt;='9'){
        b=b*10+str[nail]-'0';
        nail++;
    }
    return b;
}

il void add(int a,int b,ll c) {
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx ++;
}

il void add_edge(int a,int b,ll c) {
    add(a,b,c); add(b,a,0);
}

il bool bfs() {
    rep(i,s,t) vis[i] = 0,d[i] = inff,cur[i] = h[i];
    queue&lt;int&gt; q; q.push(s);
    vis[s] = 1; d[s] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = h[u]; ~i; i = ne[i]) {
            int j = e[i];
            if (d[u] + 1 &lt; d[j] &amp;&amp; w[i]) {
                d[j] = d[u] + 1;
                if (!vis[j]) {
                    vis[j] = 1;
                    q.push(j);
                }
            }
        }
    }
    if (d[t] == inff) return 0;
    return 1;
}

il ll dfs(int u,ll val) {
    if (u == t) {
        res += val;
        return val;
    }
    ll now = 0;
    for (int i = cur[u]; ~i; i = ne[i]) {
        cur[u] = i;
        int j = e[i];
        if (d[j] == d[u] + 1 &amp;&amp; w[i]) {
            ll x = dfs(j,min(w[i],val - now));
            // if (!x) d[j] = -1;
            if (x) {
                now += x;
                w[i] -= x; w[i ^ 1] += x;
                if (now == val) break;
            }
        }
    }
    return now;
}

il void Dinic() {
    while (bfs()) dfs(s,inff);
}

il void solve() {
    //------------code------------
    memset(h,-1,sizeof h);
    cin &gt;&gt; m &gt;&gt; n;
    int sum = 0;
	s = 0,t = 10002;
	getline(cin,str);
	rep(i,1,m) {
        nail = 0;
		getline(cin,str);
		int x; x = read();
        sum += x;
		add_edge(s,i,x);
		int y;
		while(1){
            y = read();
			if(!y) break;
			add_edge(i,y + m,inff);
		}
	}
	rep(i,1,n) {
		int x; cin &gt;&gt; x;
		add_edge(m + i,t,x);
	}
	Dinic();
	rep(i,1,m) if(d[i] != inff) printf("%lld ",i); puts("");
	rep(i,1,n) if(d[i + m] != inff) printf("%lld ",i); puts("");
	printf("%lld",sum - res);
    return ;
}

il void init() {
    return ;
}

signed main() {
    // init();
    int _ = 1;
    // read(_);
    while (_ -- ) solve();
    return 0;
}
</code></pre>
<h2 id="3练习题">3.练习题</h2>
<p>其实是个变式。</p>
<p><a href="https://atcoder.jp/contests/arc085/tasks/arc085_c?lang=en" target="_blank" rel="noopener nofollow"><strong>III.AT_arc085_c MUL</strong></a></p>
<p>要求最小权闭合图，所以边权取反后做最大权闭合图即可。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

#define int long long
#define ll long long
#define ull unsigned long long
#define db double
#define ld long double
#define rep(i,l,r) for (int i = (int)(l); i &lt;= (int)(r); ++ i )
#define rep1(i,l,r) for (int i = (int)(l); i &gt;= (int)(r); -- i )
#define il inline
#define fst first
#define snd second
#define ptc putchar
#define Yes ptc('Y'),ptc('e'),ptc('s'),puts("")
#define No ptc('N'),ptc('o'),puts("")
#define YES ptc('Y'),ptc('E'),ptc('S'),puts("")
#define NO ptc('N'),ptc('O'),puts("")
#define vi vector&lt;int&gt;
#define pb emplace_back
#define sz(x) (int)(x.size())
#define all(x) x.begin(),x.end()
#define me(a,x) memset(a,x,sizeof a)
#define get(x) ((x - 1) / len + 1)
#define debug() puts("------------")

using namespace std;
typedef pair&lt;int,int&gt; PII;
typedef pair&lt;int,PII&gt; PIII;
typedef pair&lt;ll,ll&gt; PLL;
namespace szhqwq {
    template&lt;class T&gt; il void read(T &amp;x) {
        x = 0; T f = 1; char ch = getchar();
        while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') f = -1; ch = getchar(); }
        while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); }
        x *= f;
    }
    template&lt;class T,class... Args&gt; il void read(T &amp;x,Args &amp;...x_) { read(x); read(x_...); }
    template&lt;class T&gt; il void print(T x) {
        if (x &lt; 0) ptc('-'), x = -x; 
        if (x &gt; 9) print(x / 10); ptc(x % 10 + '0');
    }
    template&lt;class T,class T_&gt; il void write(T x,T_ ch) { print(x); ptc(ch); }
    template&lt;class T,class T_&gt; il void chmax(T &amp;x,T_ y) { x = x &lt; (T)y ? (T)y : x; }
    template&lt;class T,class T_&gt; il void chmin(T &amp;x,T_ y) { x = x &gt; (T)y ? (T)y : x; }
    template&lt;class T,class T_,class T__&gt; il T qmi(T a,T_ b,T__ p) {
        T res = 1; while (b) {
            if (b &amp; 1) res = res * a % p;
            a = a * a % p; b &gt;&gt;= 1;
        } return res;
    }
    template&lt;class T&gt; il T gcd(T a,T b) { if (!b) return a; return gcd(b,a % b); }
    template&lt;class T,class T_&gt; il void exgcd(T a, T b, T_ &amp;x, T_ &amp;y) {
        if (b == 0) { x = 1; y = 0; return; }
        exgcd(b,a % b,y,x); y -= a / b * x; return ;
    }
    template&lt;class T,class T_&gt; il T getinv(T x,T_ p) { 
        T inv,y; exgcd(x,(T)p,inv,y);
        inv = (inv + p) % p; return inv;
    }
} using namespace szhqwq;
const int N = 2e5 + 10,inf = 1e9,mod = 998244353;
const ull base = 131,base_ = 233;
const ll inff = 1e18;
const db eps = 1e-6;
int n,m,s,t,a[N];
int h[N],cur[N],e[N &lt;&lt; 1],ne[N &lt;&lt; 1],idx;
ll d[N],w[N],ret; bool vis[N];

il void add(int a,int b,ll c) {
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx ++;
    return ;
}

il void add_edge(int a,int b,ll c) {
    add(a,b,c); add(b,a,0);
    return ;
}

il bool bfs() {
    rep(i,s,t) d[i] = inf,cur[i] = h[i],vis[i] = 0;
    queue&lt;int&gt; q; q.push(s); d[s] = 0;
    while (sz(q)) {
        int u = q.front(); q.pop();
        for (int i = h[u]; ~i; i = ne[i]) {
            int j = e[i];
            if (w[i] &gt; 0 &amp;&amp; d[j] == inf) {
                d[j] = d[u] + 1;
                vis[j] = 1; q.push(j);
            }
        }
    }
    return d[t] != inf;
}

il ll dfs(int u,ll val) {
    if (u == t) return val;
    ll now = 0;
    for (int i = cur[u]; ~i; i = ne[i]) {
        cur[u] = i;
        int j = e[i];
        if (w[i] &gt; 0 &amp;&amp; d[j] == d[u] + 1) {
            ll x = dfs(j,min(w[i],val - now));
            if (x &lt;= 0) continue;
            now += x;
            w[i] -= x; w[i ^ 1] += x;
            if (now == val) return now;
        }
    }
    return now;
}

il void Dinic() {
    ret = 0;
    while (bfs()) ret += dfs(s,inff);
    return ;
}

il void solve() {
    //------------code------------
    read(n); s = 0,t = n + 1; me(h,-1);
    rep(i,1,n) for (int x = i * 2; x &lt;= n; x += i ) add_edge(i,x,inff);
    ll sum = 0;
    rep(i,1,n) {
        read(a[i]);
        if (a[i] &lt; 0) add_edge(s,i,-a[i]);
        else add_edge(i,t,a[i]);
        sum += max(a[i],0ll);
    }
    Dinic();
    write(sum - ret,'\n');
    return ;
}

il void init() {
    return ;
}

signed main() {
    // init();
    int _ = 1;
    // read(_);
    while (_ -- ) solve();
    return 0;
}
</code></pre>
<p>完结撒花 111。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.16731848072453703" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-05 20:15">2025-01-05 19:53</span>&nbsp;
<a href="https://www.cnblogs.com/songszh">songszh</a>&nbsp;
阅读(<span id="post_view_count">13</span>)&nbsp;
评论(<span id="post_comment_count">2</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18651840" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18651840);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18651840', targetLink: 'https://www.cnblogs.com/songszh/p/18651840/Maximum-Weight-Closure-of-a-Graph', title: '最大权闭合图' })">举报</a>
</div>
        