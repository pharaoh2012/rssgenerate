
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangxincheng/p/18920461" title="发布于 2025-06-09 11:37">
    <span role="heading" aria-level="2">MinHook 如何对.NET底层的 Win32函数 进行拦截（上）</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景">一：背景</h2>
<h3 id="1-讲故事">1. 讲故事</h3>
<p>在前面的系列中，我们聊过.NET外挂 harmony，他可以对<code>.NET SDK</code>方法进行拦截，这在<code>.NET高级调试</code>领域中非常重要，但这里也有一些遗憾，就是不能对SDK领域之外的函数进行拦截，比如 Win32 函数。。。</p>
<p>这篇我们就来解决这个问题，对，它就是 MinHook，当然我也调查了<code>easyhook</code>和<code>detours</code>，前者年久失修，后者是商业库，加上我的要求相对简单，使用极简版的 minhook 就够了，而且该项目在github上也是非常活跃的：<a href="https://github.com/TsudaKageyu/minhook" target="_blank" rel="noopener nofollow">https://github.com/TsudaKageyu/minhook</a></p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202506/214741-20250609113627443-2029694779.png" alt="" loading="lazy"></p>
<ul>
<li>开箱即用，下载 <code>MinHook_134_bin.zip</code> 即可。</li>
<li>多项目融合，下载 <code>MinHook_134_lib.zip</code> 即可。</li>
</ul>
<h2 id="二minhook-案例演示">二：MinHook 案例演示</h2>
<h3 id="1-开箱即用方式">1. 开箱即用方式</h3>
<p>观察 <code>MinHook.h</code> 头文件，会发现很多的 C 导出函数，如下所示：</p>
<pre><code class="language-C">
#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);
    
    ...
}

</code></pre>
<p>有了这些导出函数，就可以通过 C# 的 PInvoke 直接调用，这里就演示一个拦截 MessageBox 方法,完整代码如下：</p>
<pre><code class="language-C#">
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ConsoleApp2
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // 安装钩子
            HookManager.InstallHook("user32.dll", "MessageBoxW",
                (IntPtr hWnd, string text, string caption, uint type) =&gt;
                {
                    Console.WriteLine($"我已成功拦截到 MessageBox：内容 {text}, 标题: {caption}");

                    var original = Marshal.GetDelegateForFunctionPointer&lt;HookManager.MessageBoxDelegate&gt;(HookManager.OriginalFunction);

                    return original(hWnd, text, caption, type);
                });

            // 测试 MessageBox 调用（钩子会捕获这个）
            MessageBox(IntPtr.Zero, "This is a test", "Test", 0);

            // 卸载钩子
            HookManager.UninstallHook();

            Console.ReadLine();
        }

        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        private static extern int MessageBox(IntPtr hWnd, string text, string caption, uint type);
    }

    public static class HookManager
    {
        // 定义 MessageBox 的委托
        [UnmanagedFunctionPointer(CallingConvention.StdCall, CharSet = CharSet.Unicode)]
        public delegate int MessageBoxDelegate(IntPtr hWnd, string text, string caption, uint type);

        // 原始函数的指针
        public static IntPtr OriginalFunction = IntPtr.Zero;

        // 当前钩子的目标函数地址
        private static IntPtr _targetFunction = IntPtr.Zero;

        public static void InstallHook(string moduleName, string functionName, MessageBoxDelegate detourFunc)
        {
            // 1. 初始化 MinHook
            var status = MinHook.MH_Initialize();
            if (status != MinHook.MH_STATUS.MH_OK)
            {
                Console.WriteLine($"MH_Initialize failed: {status}");
                return;
            }

            // 2. 获取目标函数的地址
            _targetFunction = MinHook.GetProcAddress(MinHook.GetModuleHandle(moduleName), functionName);
            if (_targetFunction == IntPtr.Zero)
            {
                Console.WriteLine($"Failed to get {functionName} address");
                return;
            }

            // 3. 创建钩子
            var detourPtr = Marshal.GetFunctionPointerForDelegate(detourFunc);
            status = MinHook.MH_CreateHook(_targetFunction, detourPtr, out OriginalFunction);

            if (status != MinHook.MH_STATUS.MH_OK)
            {
                Console.WriteLine($"MH_CreateHook failed: {status}");
                return;
            }

            // 4. 启用钩子
            status = MinHook.MH_EnableHook(_targetFunction);
            if (status != MinHook.MH_STATUS.MH_OK)
            {
                Console.WriteLine($"MH_EnableHook failed: {status}");
                return;
            }

            Console.WriteLine($"{functionName} hook installed successfully");
        }

        public static void UninstallHook()
        {
            if (_targetFunction == IntPtr.Zero)
            {
                Console.WriteLine("No active hook to uninstall");
                return;
            }

            // 1. 禁用钩子
            var status = MinHook.MH_DisableHook(_targetFunction);
            if (status != MinHook.MH_STATUS.MH_OK)
            {
                Console.WriteLine($"MH_DisableHook failed: {status}");
            }

            // 2. 移除钩子
            status = MinHook.MH_RemoveHook(_targetFunction);
            if (status != MinHook.MH_STATUS.MH_OK)
            {
                Console.WriteLine($"MH_RemoveHook failed: {status}");
            }

            // 3. 卸载 MinHook
            status = MinHook.MH_Uninitialize();
            if (status != MinHook.MH_STATUS.MH_OK)
            {
                Console.WriteLine($"MH_Uninitialize failed: {status}");
            }

            _targetFunction = IntPtr.Zero;
            OriginalFunction = IntPtr.Zero;

            Console.WriteLine("Hook uninstalled successfully");
        }
    }

    public class MinHook
    {
        // MH_STATUS 枚举
        public enum MH_STATUS
        {
            MH_UNKNOWN = -1,
            MH_OK = 0,
            MH_ERROR_ALREADY_INITIALIZED,
            MH_ERROR_NOT_INITIALIZED,
            MH_ERROR_ALREADY_CREATED,
            MH_ERROR_NOT_CREATED,
            MH_ERROR_ENABLED,
            MH_ERROR_DISABLED,
            MH_ERROR_NOT_EXECUTABLE,
            MH_ERROR_UNSUPPORTED_FUNCTION,
            MH_ERROR_MEMORY_ALLOC,
            MH_ERROR_MEMORY_PROTECT,
            MH_ERROR_MODULE_NOT_FOUND,
            MH_ERROR_FUNCTION_NOT_FOUND
        }

        public IntPtr MH_ALL_HOOKS = IntPtr.Zero;

        // 导入 MinHook 函数
        [DllImport("MinHook.x86.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern MH_STATUS MH_Initialize();

        [DllImport("MinHook.x86.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern MH_STATUS MH_Uninitialize();

        [DllImport("MinHook.x86.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern MH_STATUS MH_CreateHook(IntPtr pTarget, IntPtr pDetour, out IntPtr ppOriginal);

        [DllImport("MinHook.x86.dll", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode)]
        public static extern MH_STATUS MH_CreateHookApi(string pszModule, string pszProcName, IntPtr pDetour, out IntPtr ppOriginal);

        [DllImport("MinHook.x86.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern MH_STATUS MH_RemoveHook(IntPtr pTarget);

        [DllImport("MinHook.x86.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern MH_STATUS MH_EnableHook(IntPtr pTarget);

        [DllImport("MinHook.x86.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern MH_STATUS MH_DisableHook(IntPtr pTarget);

        [DllImport("MinHook.x86.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr MH_StatusToString(MH_STATUS status);


        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        public static extern IntPtr GetModuleHandle(string lpModuleName);

        [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
        public static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);
    }
}

</code></pre>
<p>由于这个 C# 程序是 32bit 的，所以将 <code>MinHook.x86.dll</code> 拷贝到C#程序的当前目录。</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202506/214741-20250609113627449-670575586.png" alt="" loading="lazy"></p>
<p>最后将程序运行起来，该有的都出现了。</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202506/214741-20250609113627432-1157811634.png" alt="" loading="lazy"></p>
<p>个人实践下来，我发现有两个小问题：</p>
<ol>
<li>当你用 vs 单步调试的时候，走到 <code>MH_CreateHook</code> 方法时会抛 <code>Fatal error. Internal CLR error. (0x80131506)</code>  CLR 内部错误，看起来VS调试器做了一些手脚，截图如下：</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/214741/202506/214741-20250609113627442-842545605.png" alt="" loading="lazy"></p>
<ol start="2">
<li>当你想在 InstallHook 中的 detourFunc 函数下断点，也不会被命中，截图如下：</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/214741/202506/214741-20250609113627421-1438391372.png" alt="" loading="lazy"></p>
<p>总的来说对VS调试有一点影响，但也不太大，还是可以接受的，毕竟用 C# 来调用轻车熟路，如果你熟悉 windbg 的话，用它是一点问题都没有。。。</p>
<h3 id="2-深度融合方式">2. 深度融合方式</h3>
<p>用 C# 的 Pinvoke 调用 MinHook，总感觉少了那个味，如果用原汁原味的 C 调用 MinHook 那就相当完美了，在解决一些比较复杂注入非常有必要。</p>
<p>这里我采用 <code>libMinHook.x86.lib</code> 以静态链接的方式将当前的 ConsoleApplication2 和 MinHook 合二为一，截图如下：</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202506/214741-20250609113627416-831603435.png" alt="" loading="lazy"></p>
<p>接下来做三点配置：</p>
<ol>
<li>右键属性 配置下 头文件 和 dll库 搜索路径，截图如下：</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/214741/202506/214741-20250609113627424-1584137078.png" alt="" loading="lazy"></p>
<ol start="2">
<li>右键属性 配置下 依赖文件名，截图如下：</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/214741/202506/214741-20250609113627450-916129356.png" alt="" loading="lazy"></p>
<p>最后就是完整的 C 代码。</p>
<pre><code class="language-C">
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;io.h&gt;
#include &lt;MinHook.h&gt;

typedef int (WINAPI* Real_MessageBoxW)(
	HWND hWnd,
	LPCWSTR lpText,
	LPCWSTR lpCaption,
	UINT uType
	);

Real_MessageBoxW fpMessageBoxW = NULL;

int WINAPI Hook_MessageBoxW(
	HWND hWnd,
	LPCWSTR lpText,
	LPCWSTR lpCaption,
	UINT uType)
{
	_setmode(_fileno(stdout), _O_U16TEXT);

	wprintf(L"拦截 MessageBoxW:\n");
	wprintf(L"  文本: %s\n", lpText);  // 移除 &amp;，直接使用 lpText
	wprintf(L"  标题: %s\n", lpCaption);  // 移除 &amp;，直接使用 lpCaption

	return fpMessageBoxW(
		hWnd,
		lpText,
		lpCaption,
		uType);
}

extern "C" __declspec(dllexport) void InstallHook()
{
	HMODULE hModule = GetModuleHandleW(L"user32.dll");
	Real_MessageBoxW pOrigMessageBoxW = (Real_MessageBoxW)GetProcAddress(hModule, "MessageBoxW");

	if (pOrigMessageBoxW == NULL) {
		printf("无法获取 MessageBoxW 地址\n");
		return;
	}

	if (MH_Initialize() != MH_OK) {
		printf("MinHook 初始化失败\n");
		return;
	}

	if (MH_CreateHook(pOrigMessageBoxW, &amp;Hook_MessageBoxW, (void**)&amp;fpMessageBoxW) != MH_OK) {
		printf("创建 Hook 失败\n");
		return;
	}

	if (MH_EnableHook(pOrigMessageBoxW) != MH_OK) {
		printf("启用 Hook 失败\n");
		return;
	}

	printf("MessageBoxW Hook 安装成功\n");
}

extern "C" __declspec(dllexport) void UninstallHook()
{
	MH_DisableHook(MH_ALL_HOOKS);
	MH_Uninitialize();
}

</code></pre>
<p>这是只对外公开了 InstallHook 和 UninstallHook 装卸载方法，最后就是高层的 C# 代码。</p>
<pre><code class="language-C#">
using System;
using System.Runtime.InteropServices;

namespace ConsoleApp1
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("正在安装 MessageBox 钩子...");
            InstallHook();

            Console.WriteLine("将弹出测试消息框，观察输出...");

            // 弹出测试消息框（会被钩子拦截）
            MessageBoxW(IntPtr.Zero, "这是测试内容", "测试标题", 0);

            Console.WriteLine("按任意键退出并卸载钩子...");
            Console.ReadKey();

            UninstallHook();
            Console.WriteLine("钩子已卸载");
        }

        // 导入 user32.dll 的 MessageBoxW
        [DllImport("user32.dll", CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Winapi)]
        public static extern int MessageBoxW(
            IntPtr hWnd,
            string lpText,
            string lpCaption,
            uint uType);

        // 导入DLL中的函数
        [DllImport("ConsoleApplication2.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern void InstallHook();

        [DllImport("ConsoleApplication2.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern void UninstallHook();
    }
}

</code></pre>
<p>在运行之前将 <code>ConsoleApplication2</code> 拷贝到 C# 程序的当前目录，直接运行 C# 项目即可。</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202506/214741-20250609113627442-1063290308.png" alt="" loading="lazy"></p>
<h2 id="三总结">三：总结</h2>
<p>开箱和融合两种方式都有自己的用途，下一篇我们上一个很真实的场景，让大家体会下 win32 的注入对<code>高级调试领域</code> 的强大功效。<br>
<img src="https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_210929020104最新消息优惠促销公众号关注二维码.jpg" width="700" height="300" alt="图片名称" align="center"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.19853694733680555" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-06-09 11:37">2025-06-09 11:37</span>&nbsp;
<a href="https://www.cnblogs.com/huangxincheng">一线码农</a>&nbsp;
阅读(<span id="post_view_count">155</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18920461);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18920461', targetLink: 'https://www.cnblogs.com/huangxincheng/p/18920461', title: 'MinHook 如何对.NET底层的 Win32函数 进行拦截（上）' })">举报</a>
</div>
        