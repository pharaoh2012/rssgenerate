<!----> <meta itemprop="headline" content="一个 4.7 GB 视频把浏览器拖进 OOM"> <meta itemprop="keywords" content="前端,JavaScript"> <meta itemprop="datePublished" content="2025-07-26T04:03:38.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端微白"> <meta itemprop="url" content="https://juejin.cn/user/323700845973252"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一个 4.7 GB 视频把浏览器拖进 OOM
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/323700845973252/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端微白
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-07-26T04:03:38.000Z" title="Sat Jul 26 2025 04:03:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-07-26
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    28
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><p>你给一家在线教育平台做「课程视频批量上传」功能。<br>
需求听起来很朴素：讲师后台一次性拖 20 个 4K 视频，浏览器要稳、要快、要能断网续传。<br>
你第一版直接 <code>&lt;input type="file"&gt;</code> + <code>FormData</code>，结果上线当天就炸：</p>
<ul>
<li>讲师 A 上传 4.7 GB 的 <code>.mov</code>，Chrome 直接 <strong>内存溢出</strong> 崩溃；</li>
<li>讲师 B 网断了 3 分钟，重新上传发现进度条归零，心态跟着归零；</li>
<li>运营同学疯狂 @ 前端：“你们是不是没做分片？”</li>
</ul>
<hr>
<h2 data-id="heading-0">解决方案：三层防线，把 4 GB 切成 2 MB 的“薯片”</h2>
<h3 data-id="heading-1">1. 表面用法：分片 + 并发，浏览器再也不卡</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// upload.js</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CHUNK_SIZE</span> = <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;    <span class="hljs-comment">// 🔍 2 MB 一片，内存友好</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">sliceFile</span>(<span class="hljs-params">file</span>) {
  <span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (cur &lt; file.<span class="hljs-property">size</span>) {
    <span class="hljs-keyword">yield</span> file.<span class="hljs-title function_">slice</span>(cur, cur + <span class="hljs-variable constant_">CHUNK_SIZE</span>);
    cur += <span class="hljs-variable constant_">CHUNK_SIZE</span>;
  }
}
</code></pre>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// uploader.js</span>
<span class="hljs-keyword">import</span> pLimit <span class="hljs-keyword">from</span> <span class="hljs-string">'p-limit'</span>;
<span class="hljs-keyword">const</span> limit = <span class="hljs-title function_">pLimit</span>(<span class="hljs-number">5</span>);               <span class="hljs-comment">// 🔍 最多 5 并发，防止占满带宽</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">upload</span>(<span class="hljs-params">file</span>) {
  <span class="hljs-keyword">const</span> hash = <span class="hljs-keyword">await</span> <span class="hljs-title function_">calcHash</span>(file);   <span class="hljs-comment">// 🔍 秒传、断点续传都靠它</span>
  <span class="hljs-keyword">const</span> tasks = [];
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> <span class="hljs-title function_">sliceFile</span>(file)) {
    tasks.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">limit</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">uploadChunk</span>({ hash, chunk })));
  }
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(tasks);
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">mergeChunks</span>(hash, file.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 🔍 通知后端合并</span>
}
</code></pre>
<p>逐行拆解：</p>
<ul>
<li><code>sliceFile</code> 用 <code>file.slice</code> 生成 Blob 片段，<strong>不占额外内存</strong>；</li>
<li><code>p-limit</code> 控制并发，避免 100 个请求同时打爆浏览器；</li>
<li><code>calcHash</code> 用 WebWorker 算 MD5，页面不卡顿（后面细讲）。</li>
</ul>
<h3 data-id="heading-2">2. 底层机制：断点续传到底续在哪？</h3>























<table><thead><tr><th>角色</th><th>存储位置</th><th>内容</th><th>生命周期</th></tr></thead><tbody><tr><td>前端</td><td>IndexedDB</td><td><code>hash → 已上传分片索引数组</code></td><td>浏览器本地，清缓存即失效</td></tr><tr><td>后端</td><td>Redis / MySQL</td><td><code>hash → 已接收分片索引数组</code></td><td>可配置 TTL，支持跨端续传</td></tr></tbody></table>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
    participant F as 前端
    participant B as 后端

    F-&gt;&gt;B: POST /prepare {hash, totalChunks}
    B--&gt;&gt;F: 200 OK {uploaded:[0,3,7]}

    loop 上传剩余分片
        F-&gt;&gt;B: POST /upload {hash, index, chunkData}
        B--&gt;&gt;F: 200 OK
    end

    F-&gt;&gt;B: POST /merge {hash}
    B--&gt;&gt;F: 200 OK
    Note over B: 按顺序写磁盘

</code></pre>
<ol>
<li>前端先&nbsp;<code>POST /prepare</code>&nbsp;带 hash + 总分片数；</li>
<li>后端返回已上传索引&nbsp;<code>[0, 3, 7]</code>；</li>
<li>前端跳过这 3 片，只传剩余；</li>
<li>全部完成后&nbsp;<code>POST /merge</code>，后端按顺序写磁盘。</li>
</ol>
<h3 data-id="heading-3">3. 设计哲学：把“上传”做成可插拔的协议</h3>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Uploader</span> {
  <span class="hljs-title function_">prepare</span>(<span class="hljs-attr">file</span>: <span class="hljs-title class_">File</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">PrepareResp</span>&gt;;
  <span class="hljs-title function_">upload</span>(<span class="hljs-attr">chunk</span>: <span class="hljs-title class_">Blob</span>, <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
  <span class="hljs-title function_">merge</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;;            <span class="hljs-comment">// 🔍 返回文件 URL</span>
}
</code></pre>
<p>我们实现了三套：</p>
<ul>
<li><code>BrowserUploader</code>：纯前端分片；</li>
<li><code>TusUploader</code>：遵循 tus.io 协议，天然断点续传；</li>
<li><code>AliOssUploader</code>：直传 OSS，用 OSS 的断点 SDK。</li>
</ul>

































<table><thead><tr><th>方案</th><th>并发控制</th><th>断点续传</th><th>秒传</th><th>代码量</th></tr></thead><tbody><tr><td>自研</td><td>手动</td><td>自己实现</td><td>手动</td><td>300 行</td></tr><tr><td>tus</td><td>内置</td><td>协议级</td><td>需后端</td><td>100 行</td></tr><tr><td>OSS</td><td>内置</td><td>SDK 级</td><td>自动</td><td>50 行</td></tr></tbody></table>
<hr>
<h2 data-id="heading-4">应用扩展：拿来即用的配置片段</h2>
<h3 data-id="heading-5">1. WebWorker 算 Hash（防卡顿）</h3>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// hash.worker.js</span>
importScripts(<span class="hljs-string">'spark-md5.min.js'</span>);
self.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">{ data: file }</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> spark = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SparkMD5</span>.<span class="hljs-title class_">ArrayBuffer</span>();
  <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReaderSync</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; file.<span class="hljs-property">size</span>; i += <span class="hljs-variable constant_">CHUNK_SIZE</span>) {
    spark.<span class="hljs-title function_">append</span>(reader.<span class="hljs-title function_">readAsArrayBuffer</span>(file.<span class="hljs-title function_">slice</span>(i, i + <span class="hljs-variable constant_">CHUNK_SIZE</span>)));
  }
  self.<span class="hljs-title function_">postMessage</span>(spark.<span class="hljs-title function_">end</span>());
};
</code></pre>
<h3 data-id="heading-6">2. 环境适配</h3>





















<table><thead><tr><th>环境</th><th>适配点</th></tr></thead><tbody><tr><td>浏览器</td><td>需兼容 Safari 14 以下无 <code>File.prototype.slice</code>（用 <code>webkitSlice</code> 兜底）</td></tr><tr><td>Node</td><td>用 <code>fs.createReadStream</code> 分片，Hash 用 <code>crypto.createHash('md5')</code></td></tr><tr><td>Electron</td><td>渲染进程直接走浏览器方案，主进程可复用 Node 逻辑</td></tr></tbody></table>
<hr>
<h2 data-id="heading-7">举一反三：3 个变体场景</h2>
<ol>
<li><strong>秒传</strong><br>
上传前先算 hash → 调后端 <code>/exists?hash=xxx</code> → 已存在直接返回 URL，0 流量完成。</li>
<li><strong>加密上传</strong><br>
在 <code>uploadChunk</code> 里加一层 <code>AES-GCM</code> 加密，后端存加密块，下载时由前端解密。</li>
<li><strong>P2P 协同上传</strong><br>
用 WebRTC 把同局域网学员的浏览器变成 CDN，分片互传后再统一上报，节省 70% 出口带宽。</li>
</ol>
<h2 data-id="heading-8">小结</h2>
<p>大文件上传的核心不是“传”，而是“断”。<br>
把 4 GB 切成 2 MB 的薯片，再配上一张能续命的“进度表”，浏览器就能稳稳地吃下任何体积的视频。</p></div></div>