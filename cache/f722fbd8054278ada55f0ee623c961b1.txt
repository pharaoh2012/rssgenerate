
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/zhr0102/p/18708845" title="发布于 2025-02-10 22:07">
    <span role="heading" aria-level="2">Luogu P5298 PKUWC2018 Minimax 题解 [ 紫 ] [ 树形 dp ] [ 线段树合并 ] [ 概率 dp ]</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        线段树合并优化 dp 好题。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p><a href="https://www.luogu.com.cn/problem/P5298" title="Minimax" target="_blank" rel="noopener nofollow">Minimax</a>：线段树合并优化 dp 好题。</p>
<h1 id="树形-dp">树形 dp</h1>
<p>因为要求出每一个值的出现概率，首先我们可以想到一个很暴力的 dp 式子。</p>
<p>定义 <span class="math inline">\(dp_{i,j}\)</span> 表示在节点 <span class="math inline">\(i\)</span> 时，权值 <span class="math inline">\(j\)</span> 的出现概率，设 <span class="math inline">\(l\)</span> 表示左儿子，<span class="math inline">\(r\)</span> 表示右儿子，则有如下转移：</p>
<ul>
<li>当 <span class="math inline">\(j\)</span> 在左儿子中时，<span class="math inline">\(dp_{i,j}\gets dp_{l,j}\times(p_i\times\sum_{k=1}^{j-1}dp_{r,k}+(1-p_i)\times\sum_{k=j+1}^{V}dp_{r,k})\)</span>，理解的话就是对父亲节点选大的还是选小的进行分讨。</li>
<li>当 <span class="math inline">\(j\)</span> 在右儿子中时，<span class="math inline">\(dp_{i,j}\gets dp_{r,j}\times(p_i\times\sum_{k=1}^{j-1}dp_{l,k}+(1-p_i)\times\sum_{k=j+1}^Vdp_{l,k})\)</span>。</li>
</ul>
<p>直接转移即可，时间复杂度 <span class="math inline">\(O(nV)\)</span>。</p>
<h1 id="线段树合并优化">线段树合并优化</h1>
<p>显然原来的时间复杂度会炸掉，但是我们发现<strong>每个节点最开始时最多只有一个 dp 位置是有值的</strong>，所以我们考虑用这种均摊复杂度的线段树合并来优化这个 dp。</p>
<p>因为 dp 转移的时候需要用到前缀和后缀和，所以我们进行 merge 的时候记录节点 <span class="math inline">\(x,y\)</span> 的前缀和 <span class="math inline">\(px,py\)</span> 与后缀和 <span class="math inline">\(sx,sy\)</span> 以及父亲节点的概率 <span class="math inline">\(p\)</span>。</p>
<p>梳理一下 merge 的流程：</p>
<ul>
<li>进入节点 <span class="math inline">\(x,y\)</span>。</li>
<li>如果 <span class="math inline">\(x,y\)</span> 其中之一是空树，则说明直接更新 dp 值即可。
<ul>
<li>若 <span class="math inline">\(x\)</span> 是空树，对应着上述 <span class="math inline">\(j\)</span> 在右儿子中的转移方式，则我们对 <span class="math inline">\(y\)</span> 的整颗子树内的 dp 值全部乘上 <span class="math inline">\((p\times\sum_{k=1}^{j-1}dp_{l,k}+(1-p)\times\sum_{k=j+1}^Vdp_{l,k})=(p\times px+(1-p)\times sx)\)</span> 即可。这个可以用懒标记实现区间乘。</li>
<li>若 <span class="math inline">\(y\)</span> 是空树，对应着上述 <span class="math inline">\(j\)</span> 在左儿子中的转移方式，则我们对 <span class="math inline">\(x\)</span> 的整颗子树内的 dp 值全部乘上 <span class="math inline">\((p\times\sum_{k=1}^{j-1}dp_{r,k}+(1-p)\times\sum_{k=j+1}^Vdp_{r,k})=(p\times py+(1-p)\times sy)\)</span> 即可。这个可以用懒标记实现区间乘。</li>
</ul>
</li>
<li>否则就说明要递归合并，递归左右儿子的时候记得更新 <span class="math inline">\(sx,sy,px,py\)</span> 的值。</li>
<li>最后将左右儿子的 dp 值加起来就是这个区间的 dp 值。</li>
</ul>
<p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p>
<h1 id="代码">代码</h1>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair&lt;int,int&gt;;
const int N=300005;
const ll mod=998244353;
int n,fa[N],m=0,b[N],son[N][2],cd[N],p[N],ans[N];
ll qpow(ll a,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&amp;1)res=(res*a)%mod;
        b&gt;&gt;=1;
        a=(a*a)%mod;
    }
    return res;
}
int getrk(int x)
{
    return (lower_bound(b+1,b+m+1,x)-b);
}
struct Node{
    int ls,rs;
    ll dp,tag=1;
};
struct Segtree{
    Node tr[20*N];
    int root[N],tot=0;
    void pushup(int p)
    {
        tr[p].dp=(tr[lc(p)].dp+tr[rc(p)].dp)%mod;
    }
    void pushdown(int p)
    {
        if(tr[p].tag!=1)
        {
            tr[lc(p)].tag=(tr[lc(p)].tag*tr[p].tag)%mod;
            tr[rc(p)].tag=(tr[rc(p)].tag*tr[p].tag)%mod;
            tr[lc(p)].dp=(tr[lc(p)].dp*tr[p].tag)%mod;
            tr[rc(p)].dp=(tr[rc(p)].dp*tr[p].tag)%mod;
        }
        tr[p].tag=1;
    }
    void modify(int p,int v)
    {
        tr[p].dp=(tr[p].dp*1ll*v)%mod;
        tr[p].tag=(tr[p].tag*1ll*v)%mod;
    }
    void update(int &amp;u,int ln,int rn,int x,ll k)
    {
        if(u==0)u=++tot;
        if(ln==rn){tr[u].dp+=k;return;}
        int mid=(ln+rn)&gt;&gt;1;
        if(x&lt;=mid)update(lc(u),ln,mid,x,k);
        else update(rc(u),mid+1,rn,x,k);
        pushup(u);
    }
    int merge(int x,int y,int px,int py,int sx,int sy,int p)
    {
        if(x==0&amp;&amp;y==0)return 0;
        if(x==0)
        {
            modify(y,(1ll*p*px%mod+1ll*((1-p)%mod+mod)%mod*sx)%mod);
            return y;
        }
        if(y==0)
        {
            modify(x,(1ll*p*py%mod+1ll*((1-p)%mod+mod)%mod*sy)%mod);
            return x;
        }
        pushdown(x);pushdown(y);
        int lx=tr[lc(x)].dp,rx=tr[rc(x)].dp,ly=tr[lc(y)].dp,ry=tr[rc(y)].dp;
        tr[x].ls=merge(lc(x),lc(y),px,py,(sx+rx)%mod,(sy+ry)%mod,p);
        tr[x].rs=merge(rc(x),rc(y),(px+lx)%mod,(py+ly)%mod,sx,sy,p);
        pushup(x);
        return x;
    }
    void query(int u,int ln,int rn)
    {
        if(ln==rn){ans[ln]=tr[u].dp;return;}
        int mid=(ln+rn)&gt;&gt;1;
        pushdown(u);
        query(lc(u),ln,mid);
        query(rc(u),mid+1,rn);
    }
}tr1;
void dfs1(int u)
{
    if(son[u][0]==0)
    {
        tr1.update(tr1.root[u],1,m,getrk(p[u]),1);
        return;
    }
    if(son[u][1]==0)
    {
        dfs1(son[u][0]);
        tr1.root[u]=tr1.root[son[u][0]];
        return;
    }
    dfs1(son[u][0]);
    dfs1(son[u][1]);
    tr1.root[u]=tr1.merge(tr1.root[son[u][0]],tr1.root[son[u][1]],0,0,0,0,p[u]);
}
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;fa[i];
    for(int i=1;i&lt;=n;i++)
    {
        son[fa[i]][cd[fa[i]]]=i;
        cd[fa[i]]++;
    }
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;p[i];
        if(cd[i])p[i]=p[i]*1ll*qpow(10000,mod-2)%mod;
        else b[++m]=p[i];
    }
    sort(b+1,b+m+1);
    m=unique(b+1,b+m+1)-b-1;
    dfs1(1);
    tr1.query(tr1.root[1],1,m);
    ll res=0;
    for(int i=1;i&lt;=m;i++)res=(res+1ll*i*b[i]%mod*ans[i]%mod*ans[i]%mod)%mod;
    cout&lt;&lt;res;
    return 0;
}
</code></pre>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0043686340601851855" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-10 22:08">2025-02-10 22:07</span>&nbsp;
<a href="https://www.cnblogs.com/zhr0102">KS_Fszha</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18708845" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18708845);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18708845', targetLink: 'https://www.cnblogs.com/zhr0102/p/18708845', title: 'Luogu P5298 PKUWC2018 Minimax 题解 [ 紫 ] [ 树形 dp ] [ 线段树合并 ] [ 概率 dp ]' })">举报</a>
</div>
        