
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/songyao666/p/18778668" title="发布于 2025-03-18 11:55">
    <span role="heading" aria-level="2">深入理解Base64编码原理</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>上篇文章有涉及到Base64编码的内容，今天我们再来详细了解一下<code>Base64</code>的编码原理以及应用场景。</p>
<p>通过这篇文章你能够学习到：</p>
<ul>
<li>什么是Base64，为什么需要Base64？</li>
<li>Base64的编码原理</li>
<li>Base64的应用场景</li>
</ul>
<h2 id="什么是base64">什么是Base64？</h2>
<blockquote>
<p>Base64是一种<strong>用于传输8bit字节数据的编码方式</strong>，Base64 的字符集包含 64 个字符（A-Z、a-z、0-9、+、/）以及补位的=</p>
</blockquote>
<p>⚠️需要注意的是它只是一种编码方式，并不是加密方式！！！因为对于<code>Base64</code>来讲，它没有密钥的概念，这意味着任何人都能轻松地将<code>Base64</code>编码的数据还原为原始字符。</p>
<p>尽管如此，不少人仍误将其当作加密工具来使用，这在具备基本技术知识的人眼中，无异于未加密处理...</p>
<h2 id="为什么需要base64编码">为什么需要Base64编码？</h2>
<blockquote>
<p><code>Base64</code>编码最初主要应用于邮件传输协议中，由于这些协议仅支持<code>ASCII</code>字符的传递，导致直接传输二进制文件（如图片、视频等）成为不可能。为了解决这一问题，Base64被设计出来，它能够将二进制文件内容转换成仅包含ASCII字符的编码形式，从而实现在邮件传输协议中安全、有效地传递二进制数据。</p>
</blockquote>
<h2 id="编码原理">编码原理</h2>
<blockquote>
<p>Base64 编码的核心原理是将输入数据（多为二进制形式）转换成特定字符序列。具体步骤为：首先将输入数据分割成每三个字节（共24位）一组，接着将这24位分割为四个6位的块（因为Base64中每个字符代表6位二进制数据）。最后，通过查找表将这些6位块映射为相应的Base64字符。</p>
</blockquote>
<h3 id="base64字符集">base64字符集</h3>
<p>上面我们提到标准的<code>Base64</code>一般包含64个字符再加一个补位的<code>=</code></p>
<ul>
<li>大写字母：<code>A-Z</code>（26 个字符）</li>
<li>小写字母：<code>a-z</code>（26 个字符）</li>
<li>数字：<code>0-9</code>（10 个字符）</li>
<li>特殊字符：<code>+</code> 和 <code>/</code>（2 个字符）</li>
<li>补位字符：<code>=</code></li>
</ul>
<h3 id="编码步骤">编码步骤</h3>
<ol start="0">
<li><strong>分组</strong>：将输入数据按每三个字节一组进行划分，每组组成一个24位的二进制数据块。</li>
<li><strong>分割</strong>：将每个24位的数据块进一步分割成四个6位的数据块。</li>
<li><strong>字符映射</strong>：通过查找字符集，将每个6位数据块映射为字符集中的对应字符。</li>
<li><strong>填充处理</strong>：若输入数据的字节数非3的倍数，则在数据末尾添加<code>=</code>字符作为填充，以确保编码结果的长度符合Base64规范。</li>
</ol>
<p>怎么理解这些步骤？</p>
<p>以南玖的<code>南</code>拼音为例</p>
<p><strong>首先将字符对应的二进制位表示出来</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202503/1525717-20250318115210381-518228743.png" alt="" loading="lazy"></p>
<p>刚好<code>nan</code>是3个字节，它们的二进制位正好组成了一个24位的二进制块</p>
<p><strong>接着把这个二进制块分割成4个6位的数据块</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202503/1525717-20250318115225708-1912383964.png" alt="" loading="lazy"></p>
<p><strong>最后通过查找Base64编码对照表，找到每个6位数据块对应的字符</strong></p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202503/1525717-20250318115237076-401459823.png" alt="" loading="lazy"></p>
<p>最终<code>nan</code>编码为<code>bmFu</code></p>
<p>由于<code>nan</code>的字节数正好是3的倍数，所以它不需要补位，编码后也就不会出现<code>=</code></p>
<h3 id="补位">补位</h3>
<p>如果字节数不是3的倍数，那么余数可能是1或2，所以补位也需要分两种情况。</p>
<ul>
<li>余数为1，二进制末尾补4个0，最后多出来的这个字符会编码成2个base64字符，最后再补两个<code>=</code></li>
</ul>
<p>比如宋的拼音<code>song</code>，余数为1</p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202503/1525717-20250318115250511-2074804787.png" alt="" loading="lazy"></p>
<p>在这基础上最后还得补上2个<code>=</code>，最终<code>song</code>编码为<code>c29uZw==</code></p>
<ul>
<li>余数为2，二进制末尾补2个0，编码后末尾再补1个<code>=</code></li>
</ul>
<p>比如<code>ab</code>，余数为2</p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202503/1525717-20250318115304235-1014338116.png" alt="" loading="lazy"></p>
<p>最终<code>ab</code>编码为<code>YWI=</code></p>
<p><strong>验证</strong></p>
<p>在javaScript中可以调用<code>btoa</code>来进行<code>base64</code>编码</p>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202503/1525717-20250318115318652-592520401.png" alt="" loading="lazy"></p>
<h2 id="动手实现一下base64编解码">动手实现一下Base64编解码</h2>
<h3 id="base64编码">base64编码</h3>
<pre><code>// 自定义base64编码
const customEncrypt = (str: string) =&gt; {
 &nbsp; &nbsp;// base64字符集
 &nbsp; &nbsp;const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
 &nbsp; &nbsp;// 将字符串转中的每个字符转换成8位二进制
 &nbsp; &nbsp;const binaryStr = str.split('').map(char =&gt; {
 &nbsp; &nbsp; &nbsp; &nbsp;const binary = char.charCodeAt(0).toString(2)
 &nbsp; &nbsp; &nbsp; &nbsp;return binary.padStart(8, '0')
 &nbsp;  }).join('')
​
 &nbsp; &nbsp;// 将二进制字符串按6位分割
 &nbsp; &nbsp;const binaryArr = binaryStr.match(/.{1,6}/g) || []
​
 &nbsp; &nbsp;// 如果最后一组不是6位的倍数，后面补0
 &nbsp; &nbsp;const last = binaryArr[binaryArr.length - 1]
 &nbsp; &nbsp;if(last?.length % 6 !== 0) {
 &nbsp; &nbsp; &nbsp; &nbsp;binaryArr[binaryArr.length - 1] = last.padEnd(6, '0')
 &nbsp;  }
​
 &nbsp; &nbsp;// 将6位的二进制转换成10进制
 &nbsp; &nbsp;const decimalArr = binaryArr.map(binary =&gt; parseInt(binary, 2))
​
 &nbsp; &nbsp;// 根据10进制的值获取base64字符
 &nbsp; &nbsp;let base64Str = decimalArr.map(decimal =&gt; base64Chars[decimal]).join('')
​
 &nbsp; &nbsp;// 补位
 &nbsp; &nbsp;while(base64Str.length % 4 !== 0) {
 &nbsp; &nbsp; &nbsp; &nbsp;base64Str += '='
 &nbsp;  }
 &nbsp; &nbsp;return base64Str
}
</code></pre>
<p>基本按照上面的编码步骤实现即可</p>
<p><strong>验证</strong></p>
<pre><code>console.log('btoa', btoa('song'))
console.log('自定义编码', customEncrypt('song'))
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202503/1525717-20250318115333192-1835870481.png" alt="" loading="lazy"></p>
<h3 id="base64解码">base64解码</h3>
<p>解码的过程基本就是与编码反过来</p>
<pre><code>// 自定义base64解码
const customDecrypt = (str: string) =&gt; {
 &nbsp; &nbsp;// base64字符集
 &nbsp; &nbsp;const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
 &nbsp; &nbsp;// 将base64字符转换成10进制
 &nbsp; &nbsp;const decimalArr = str.split('').map(char =&gt; base64Chars.indexOf(char))
​
 &nbsp; &nbsp;// 将10进制转换成6位二进制
 &nbsp; &nbsp;const binaryArr = decimalArr.map(decimal =&gt; decimal.toString(2).padStart(6, '0'))
​
 &nbsp; &nbsp;// 将6位的二进制拼接
 &nbsp; &nbsp;const binaryStr = binaryArr.join('')
​
 &nbsp; &nbsp;// 将8位的二进制转换成字符
 &nbsp; &nbsp;const charArr = binaryStr.match(/.{1,8}/g) || []
 &nbsp; &nbsp;return charArr.map(binary =&gt; String.fromCharCode(parseInt(binary, 2))).join('')
}
</code></pre>
<p><strong>验证</strong></p>
<pre><code>console.log('atob', atob('c29uZw=='))
console.log('自定义解码', customDecrypt('c29uZw=='))
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/1525717/202503/1525717-20250318115347981-814310982.png" alt="" loading="lazy"></p>
<p><strong>思考</strong>🤔</p>
<p>按照这个思路我们是不是可以实现一个比<code>Base64</code>更安全的<strong>伪加密方法</strong></p>
<p>比如：</p>
<ul>
<li>更换字符集</li>
<li>更换二进制分割手段</li>
</ul>
<h2 id="应用场景">应用场景</h2>
<h3 id="数据传输">数据传输</h3>
<p>Base64编码是一种在HTTP文本协议中传输二进制数据的常用方法。由于HTTP协议本质上是基于文本的，它限制了只能传输可打印的ASCII字符（范围从32到126），这包括字母、数字、标点符号和一些特殊符号。然而，二进制数据包含许多不在这个范围内的字符，因此无法直接通过HTTP协议进行传输。Base64编码不仅解决了在HTTP协议中传输二进制数据的问题，还确保了数据的完整性和可读性。</p>
<h3 id="数据存储">数据存储</h3>
<p>Base64 编码常用于存储二进制数据，如数据库中的图像、文件等，因为它将数据转换为可打印字符，避免了二进制数据在存储过程中可能出现的问题。</p>
<p>在前端页面实现中，为了提高加载效率，简单图片通常会选择直接内嵌而非加载外部资源。然而，图片是二进制数据，直接嵌入并不简单。幸运的是，现代浏览器普遍支持<code>Data URLs</code>功能，该功能通过Base64编码将图片或其他文件的二进制数据转换为文本字符串，从而可以方便地嵌入到网页中。这样，就无需进行额外的外部资源加载，有助于减少页面加载时间。</p>
<h3 id="协议编码">协议编码</h3>
<p><code>Base64</code>编码最初主要应用于邮件传输协议中，由于这些协议仅支持<code>ASCII</code>字符的传递，导致直接传输二进制文件（如图片、视频等）成为不可能。为了解决这一问题，Base64被设计出来，它能够将二进制文件内容转换成仅包含ASCII字符的编码形式，从而实现在邮件传输协议中安全、有效地传递二进制数据。</p>
<h2 id="总结">总结</h2>
<p>Base64编码是一种广泛应用的编码方法，它将二进制数据转换为可打印的ASCII字符集，特别适用于数据传输和存储场景。然而，重要的是要认识到，Base64编码本身并不具备数据加密或安全保护的功能。在需要处理敏感信息时，仅凭Base64编码是远远不够的，必须结合适当的加密技术和安全传输协议（如HTTPS）来确保信息的安全性和隐私性。</p>

</div>
<div id="MySignature" role="contentinfo">
    <div style="color: blueviolet">
<div>作者：<a href="https://bettersong.github.io/nanjiu/">前端南玖</a></div>
<div>出处：<a href="https://www.cnblogs.com/songyao666/">https://www.cnblogs.com/songyao666/
</a></div>
<div>每日面试题：<a href="https://github.com/bettersong/interview" target="new">Github</a></div>
<p>-------------------------------------------</p>
<p>如果这篇文章有帮助到你，❤️关注+点赞❤️鼓励一下作者，文章公众号首发，关注 前端南玖 第一时间获取最新的文章～</p>
<p>扫描下方二维码关注公众号，回复进群，拉你进前端学习交流群</p>
<div style="display:flex">
<img src="https://blog-static.cnblogs.com/files/songyao666/nanjiu.gif?t=2" alt="逐梦wx" width="380" height="190">
</div>
</div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.3595310655104167" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-18 11:55">2025-03-18 11:55</span>&nbsp;
<a href="https://www.cnblogs.com/songyao666">前端南玖</a>&nbsp;
阅读(<span id="post_view_count">303</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18778668" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18778668);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18778668', targetLink: 'https://www.cnblogs.com/songyao666/p/18778668', title: '深入理解Base64编码原理' })">举报</a>
</div>
        