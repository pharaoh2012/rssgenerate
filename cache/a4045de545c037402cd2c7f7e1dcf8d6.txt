<!----> <meta itemprop="headline" content="我将封装史上最优雅的 Axios "> <meta itemprop="keywords" content="前端"> <meta itemprop="datePublished" content="2025-08-06T04:40:43.000Z"> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端优雅哥"> <meta itemprop="url" content="https://juejin.cn/user/2586522652258894"></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"> <meta itemprop="width" content="180"> <meta itemprop="height" content="180"></div></div> <h1 class="article-title" data-v-61fb5e44="">
            我将封装史上最优雅的 Axios 
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2586522652258894/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端优雅哥
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-08-06T04:40:43.000Z" title="Wed Aug 06 2025 04:40:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-08-06
                  </time> <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""></path><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""></circle></svg> <span class="views-count" data-v-61fb5e44="">
                    4,257
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""></rect><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""></circle><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""></path></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""></div> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><blockquote>
<p>经过一上午的反复打磨，终于写出了这个让我满意的 HTTP 客户端封装。当我把代码发给朋友时，他竟然挑出了一堆问题！还好我都一一解决了。</p>
</blockquote>
<h2 data-id="heading-0">🎯 为什么要重新封装 Axios？</h2>
<p>我们都知道 Axios 是 JavaScript 世界里最受欢迎的 HTTP 客户端，但在实际项目中，我们总是需要：</p>
<ul>
<li>🔄 <strong>统一的错误处理</strong> - 不想在每个请求里写重复的 try-catch</li>
<li>🚫 <strong>请求取消机制</strong> - 用户快速切换页面时取消无用请求</li>
<li>🔁 <strong>自动重试功能</strong> - 网络不稳定时自动重试</li>
<li>🎨 <strong>TypeScript 完美支持</strong> - 类型安全，IDE 智能提示</li>
<li>🏗️ <strong>多实例管理</strong> - 不同 API 服务需要不同配置</li>
</ul>
<p>市面上的封装要么太简单，要么太复杂。所以我决定写一个<strong>既优雅又实用</strong>的版本。</p>
<h2 data-id="heading-1">🎨 设计理念</h2>
<p>这个封装的设计遵循几个核心原则：</p>
<ol>
<li><strong>🎯 渐进式增强</strong> - 可以像原生 Axios 一样简单使用，也可以启用高级功能</li>
<li><strong>🔒 类型安全</strong> - 完整的 TypeScript 支持，编译时发现问题</li>
<li><strong>🧩 灵活扩展</strong> - 支持多实例、自定义拦截器、业务定制</li>
<li><strong>⚡ 性能优先</strong> - 自动去重、智能重试、内存管理</li>
<li><strong>📖 文档友好</strong> - 丰富的示例和注释，上手即用</li>
</ol>
<h2 data-id="heading-2">📜 完整源码</h2>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Axios</span>, { <span class="hljs-keyword">type</span> <span class="hljs-title class_">AxiosInstance</span>, <span class="hljs-keyword">type</span> <span class="hljs-title class_">AxiosRequestConfig</span>, <span class="hljs-keyword">type</span> <span class="hljs-title class_">CustomParamsSerializer</span>, <span class="hljs-keyword">type</span> <span class="hljs-title class_">AxiosResponse</span>, <span class="hljs-keyword">type</span> <span class="hljs-title class_">InternalAxiosRequestConfig</span>, <span class="hljs-keyword">type</span> <span class="hljs-title class_">Method</span>, <span class="hljs-keyword">type</span> <span class="hljs-title class_">AxiosError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;
<span class="hljs-keyword">import</span> { stringify } <span class="hljs-keyword">from</span> <span class="hljs-string">"qs"</span>;

<span class="hljs-comment">// 基础配置</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">defaultConfig</span>: <span class="hljs-title class_">AxiosRequestConfig</span> = {
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">6000</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json;charset=utf-8"</span>
  },
  <span class="hljs-attr">paramsSerializer</span>: {
    <span class="hljs-attr">serialize</span>: stringify <span class="hljs-keyword">as</span> <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">CustomParamsSerializer</span>
  }
};

<span class="hljs-comment">// 响应数据基础结构</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BaseResponse</span> {
  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;
  message?: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// 去除与BaseResponse冲突的字段</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">OmitBaseResponse</span>&lt;T&gt; = <span class="hljs-title class_">Omit</span>&lt;T, keyof <span class="hljs-title class_">BaseResponse</span>&gt;;

<span class="hljs-comment">// 响应数据类型定义 - 避免属性冲突，确保BaseResponse优先级</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">ResponseData</span>&lt;T = <span class="hljs-built_in">any</span>&gt; = <span class="hljs-title class_">BaseResponse</span> &amp; <span class="hljs-title class_">OmitBaseResponse</span>&lt;T&gt;;

<span class="hljs-comment">// 响应数据验证函数类型</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">ResponseValidator</span>&lt;T = <span class="hljs-built_in">any</span>&gt; = <span class="hljs-function">(<span class="hljs-params">data: ResponseData&lt;T&gt;</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>;

<span class="hljs-comment">// 重试配置</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RetryConfig</span> {
  retries?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 重试次数</span>
  retryDelay?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 重试延迟（毫秒）</span>
  retryCondition?: <span class="hljs-function">(<span class="hljs-params">error: AxiosError</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 重试条件</span>
}

<span class="hljs-comment">// 拦截器配置类型</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterceptorsConfig</span> {
  requestInterceptor?: <span class="hljs-function">(<span class="hljs-params">config: InternalAxiosRequestConfig</span>) =&gt;</span> <span class="hljs-title class_">InternalAxiosRequestConfig</span>;
  requestErrorInterceptor?: <span class="hljs-function">(<span class="hljs-params">error: AxiosError</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;;
  responseInterceptor?: <span class="hljs-function">(<span class="hljs-params">response: AxiosResponse&lt;ResponseData&lt;<span class="hljs-built_in">any</span>&gt;&gt;</span>) =&gt;</span> <span class="hljs-built_in">any</span>;
  responseErrorInterceptor?: <span class="hljs-function">(<span class="hljs-params">error: AxiosError</span>) =&gt;</span> <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;;
}

<span class="hljs-comment">// 请求唯一键</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">RequestKey</span> = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>;

<span class="hljs-comment">/**
 * 增强型 HTTP 客户端，基于 Axios 封装
 * 支持拦截器配置、请求取消、多实例管理等功能
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClient</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">AxiosInstance</span>;
  <span class="hljs-keyword">private</span> requestInterceptorId?: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">private</span> responseInterceptorId?: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">abortControllers</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">RequestKey</span>, <span class="hljs-title class_">AbortController</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

  <span class="hljs-comment">/**
   * 创建 HTTP 客户端实例
   * <span class="hljs-doctag">@param</span> customConfig 自定义 Axios 配置
   * <span class="hljs-doctag">@param</span> interceptors 自定义拦截器配置
   */</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">customConfig?: AxiosRequestConfig, interceptors?: InterceptorsConfig</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = <span class="hljs-title class_">Axios</span>.<span class="hljs-title function_">create</span>({ ...defaultConfig, ...customConfig });
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initInterceptors</span>(interceptors);
  }

  <span class="hljs-comment">/** 初始化拦截器 */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">initInterceptors</span>(interceptors?: <span class="hljs-title class_">InterceptorsConfig</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initRequestInterceptor</span>(interceptors?.<span class="hljs-property">requestInterceptor</span>, interceptors?.<span class="hljs-property">requestErrorInterceptor</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initResponseInterceptor</span>(interceptors?.<span class="hljs-property">responseInterceptor</span>, interceptors?.<span class="hljs-property">responseErrorInterceptor</span>);
  }

  <span class="hljs-comment">/** 初始化请求拦截器 */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">initRequestInterceptor</span>(customInterceptor?: <span class="hljs-title class_">InterceptorsConfig</span>[<span class="hljs-string">"requestInterceptor"</span>], customErrorInterceptor?: <span class="hljs-title class_">InterceptorsConfig</span>[<span class="hljs-string">"requestErrorInterceptor"</span>]): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// 默认请求拦截器</span>
    <span class="hljs-keyword">const</span> defaultInterceptor = (<span class="hljs-attr">config</span>: <span class="hljs-title class_">InternalAxiosRequestConfig</span>): <span class="hljs-function"><span class="hljs-params">InternalAxiosRequestConfig</span> =&gt;</span> {
      <span class="hljs-comment">/* 在这里写请求拦截器的默认业务逻辑 */</span>
      <span class="hljs-comment">// 示例: 添加token</span>
      <span class="hljs-comment">// const token = localStorage.getItem('token');</span>
      <span class="hljs-comment">// if (token) {</span>
      <span class="hljs-comment">//   config.headers.Authorization = `Bearer ${token}`;</span>
      <span class="hljs-comment">// }</span>

      <span class="hljs-comment">// 示例: 添加时间戳防止缓存</span>
      <span class="hljs-comment">// if (config.method?.toUpperCase() === 'GET') {</span>
      <span class="hljs-comment">//   config.params = { ...config.params, _t: Date.now() };</span>
      <span class="hljs-comment">// }</span>

      <span class="hljs-keyword">return</span> config;
    };

    <span class="hljs-comment">// 默认请求错误拦截器</span>
    <span class="hljs-keyword">const</span> defaultErrorInterceptor = (<span class="hljs-attr">error</span>: <span class="hljs-title class_">AxiosError</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt; =&gt; {
      <span class="hljs-comment">/* 在这里写请求错误拦截器的默认业务逻辑 */</span>
      <span class="hljs-comment">// 示例: 处理请求前的错误</span>
      <span class="hljs-comment">// console.error('请求配置错误:', error);</span>

      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
    };

    <span class="hljs-comment">// 优先使用自定义拦截器，否则使用默认拦截器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestInterceptorId</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(customInterceptor || defaultInterceptor, customErrorInterceptor || defaultErrorInterceptor);
  }

  <span class="hljs-comment">/** 初始化响应拦截器 */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">initResponseInterceptor</span>(customInterceptor?: <span class="hljs-title class_">InterceptorsConfig</span>[<span class="hljs-string">"responseInterceptor"</span>], customErrorInterceptor?: <span class="hljs-title class_">InterceptorsConfig</span>[<span class="hljs-string">"responseErrorInterceptor"</span>]): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// 默认响应拦截器</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultInterceptor</span> = (<span class="hljs-params">response: AxiosResponse&lt;ResponseData&lt;<span class="hljs-built_in">any</span>&gt;&gt;</span>) =&gt; {
      <span class="hljs-keyword">const</span> requestKey = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRequestKey</span>(response.<span class="hljs-property">config</span>);
      <span class="hljs-keyword">if</span> (requestKey) <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortControllers</span>.<span class="hljs-title function_">delete</span>(requestKey);

      <span class="hljs-comment">/* 在这里写响应拦截器的默认业务逻辑 */</span>
      <span class="hljs-comment">// 示例: 处理不同的响应码</span>
      <span class="hljs-comment">// const { code, message } = response.data;</span>
      <span class="hljs-comment">// switch(code) {</span>
      <span class="hljs-comment">//   case 200:</span>
      <span class="hljs-comment">//     return response.data;</span>
      <span class="hljs-comment">//   case 401:</span>
      <span class="hljs-comment">//     // 未授权处理</span>
      <span class="hljs-comment">//     break;</span>
      <span class="hljs-comment">//   case 403:</span>
      <span class="hljs-comment">//     // 权限不足处理</span>
      <span class="hljs-comment">//     break;</span>
      <span class="hljs-comment">//   default:</span>
      <span class="hljs-comment">//     // 其他错误处理</span>
      <span class="hljs-comment">//     console.error('请求错误:', message);</span>
      <span class="hljs-comment">// }</span>

      <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;
    };

    <span class="hljs-comment">// 默认响应错误拦截器</span>
    <span class="hljs-keyword">const</span> defaultErrorInterceptor = (<span class="hljs-attr">error</span>: <span class="hljs-title class_">AxiosError</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt; =&gt; {
      <span class="hljs-keyword">if</span> (error.<span class="hljs-property">config</span>) {
        <span class="hljs-keyword">const</span> requestKey = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRequestKey</span>(error.<span class="hljs-property">config</span>);
        <span class="hljs-keyword">if</span> (requestKey) <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortControllers</span>.<span class="hljs-title function_">delete</span>(requestKey);
      }

      <span class="hljs-comment">// 处理请求被取消的情况</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Axios</span>.<span class="hljs-title function_">isCancel</span>(error)) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">"请求已被取消:"</span>, error.<span class="hljs-property">message</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"请求已被取消"</span>));
      }

      <span class="hljs-comment">// 网络错误处理</span>
      <span class="hljs-keyword">if</span> (!(error <span class="hljs-keyword">as</span> <span class="hljs-title class_">AxiosError</span>).<span class="hljs-property">response</span>) {
        <span class="hljs-keyword">if</span> ((error <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">code</span> === <span class="hljs-string">"ECONNABORTED"</span> || (error <span class="hljs-keyword">as</span> <span class="hljs-title class_">AxiosError</span>).<span class="hljs-property">message</span>?.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"timeout"</span>)) {
          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"请求超时，请稍后重试"</span>));
        }
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"网络错误，请检查网络连接"</span>));
      }

      <span class="hljs-comment">// HTTP状态码错误处理</span>
      <span class="hljs-keyword">const</span> status = (error <span class="hljs-keyword">as</span> <span class="hljs-title class_">AxiosError</span>).<span class="hljs-property">response</span>?.<span class="hljs-property">status</span>;
      <span class="hljs-keyword">const</span> <span class="hljs-attr">commonErrors</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt; = {
        <span class="hljs-number">400</span>: <span class="hljs-string">"请求参数错误"</span>,
        <span class="hljs-number">401</span>: <span class="hljs-string">"未授权，请重新登录"</span>,
        <span class="hljs-number">403</span>: <span class="hljs-string">"权限不足"</span>,
        <span class="hljs-number">404</span>: <span class="hljs-string">"请求的资源不存在"</span>,
        <span class="hljs-number">408</span>: <span class="hljs-string">"请求超时"</span>,
        <span class="hljs-number">500</span>: <span class="hljs-string">"服务器内部错误"</span>,
        <span class="hljs-number">502</span>: <span class="hljs-string">"网关错误"</span>,
        <span class="hljs-number">503</span>: <span class="hljs-string">"服务暂不可用"</span>,
        <span class="hljs-number">504</span>: <span class="hljs-string">"网关超时"</span>
      };

      <span class="hljs-keyword">const</span> message = commonErrors[status] || <span class="hljs-string">`请求失败（状态码：<span class="hljs-subst">${status}</span>）`</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message));
    };

    <span class="hljs-comment">// 优先使用自定义拦截器，否则使用默认拦截器</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">responseInterceptorId</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(customInterceptor || defaultInterceptor, customErrorInterceptor || defaultErrorInterceptor);
  }

  <span class="hljs-comment">/** 生成请求唯一标识 */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">getRequestKey</span>(<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">RequestKey</span> | <span class="hljs-literal">undefined</span> {
    <span class="hljs-keyword">if</span> (!config.<span class="hljs-property">url</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${config.method?.toUpperCase()}</span>-<span class="hljs-subst">${config.url}</span>`</span>;
  }

  <span class="hljs-comment">/** 设置取消控制器 - 用于取消重复请求或主动取消请求 */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">setupCancelController</span>(<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>, requestKey?: <span class="hljs-title class_">RequestKey</span>): <span class="hljs-title class_">AxiosRequestConfig</span> {
    <span class="hljs-keyword">const</span> key = requestKey || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRequestKey</span>(config);
    <span class="hljs-keyword">if</span> (!key) <span class="hljs-keyword">return</span> config;

    <span class="hljs-comment">// 如果已有相同key的请求，先取消它</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cancelRequest</span>(key);

    <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortControllers</span>.<span class="hljs-title function_">set</span>(key, controller);

    <span class="hljs-keyword">return</span> {
      ...config,
      <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span>
    };
  }

  <span class="hljs-comment">/** 移除请求拦截器 */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">removeRequestInterceptor</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestInterceptorId</span> !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">eject</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestInterceptorId</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestInterceptorId</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 重置ID，避免重复移除</span>
    }
  }

  <span class="hljs-comment">/** 移除响应拦截器 */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">removeResponseInterceptor</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">responseInterceptorId</span> !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">eject</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">responseInterceptorId</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">responseInterceptorId</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 重置ID，避免重复移除</span>
    }
  }

  <span class="hljs-comment">/** 动态设置请求拦截器 */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">setRequestInterceptor</span>(customInterceptor?: <span class="hljs-title class_">InterceptorsConfig</span>[<span class="hljs-string">"requestInterceptor"</span>], customErrorInterceptor?: <span class="hljs-title class_">InterceptorsConfig</span>[<span class="hljs-string">"requestErrorInterceptor"</span>]): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeRequestInterceptor</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initRequestInterceptor</span>(customInterceptor, customErrorInterceptor);
  }

  <span class="hljs-comment">/** 动态设置响应拦截器 */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">setResponseInterceptor</span>(customInterceptor?: <span class="hljs-title class_">InterceptorsConfig</span>[<span class="hljs-string">"responseInterceptor"</span>], customErrorInterceptor?: <span class="hljs-title class_">InterceptorsConfig</span>[<span class="hljs-string">"responseErrorInterceptor"</span>]): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeResponseInterceptor</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initResponseInterceptor</span>(customInterceptor, customErrorInterceptor);
  }

  <span class="hljs-comment">/** 获取 Axios 实例 */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">getInstance</span>(): <span class="hljs-title class_">AxiosInstance</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>;
  }

  <span class="hljs-comment">/**
   * 取消某个请求
   * <span class="hljs-doctag">@param</span> key 请求唯一标识
   * <span class="hljs-doctag">@param</span> message 取消原因
   * <span class="hljs-doctag">@returns</span> 是否成功取消
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">cancelRequest</span>(<span class="hljs-attr">key</span>: <span class="hljs-title class_">RequestKey</span>, message?: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> {
    <span class="hljs-keyword">const</span> controller = <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortControllers</span>.<span class="hljs-title function_">get</span>(key);
    <span class="hljs-keyword">if</span> (controller) {
      controller.<span class="hljs-title function_">abort</span>(message || <span class="hljs-string">`取消请求: <span class="hljs-subst">${<span class="hljs-built_in">String</span>(key)}</span>`</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortControllers</span>.<span class="hljs-title function_">delete</span>(key);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-comment">/**
   * 取消所有请求
   * <span class="hljs-doctag">@param</span> message 取消原因
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">cancelAllRequests</span>(message?: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortControllers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">controller, key</span>) =&gt;</span> {
      controller.<span class="hljs-title function_">abort</span>(message || <span class="hljs-string">`取消所有请求: <span class="hljs-subst">${<span class="hljs-built_in">String</span>(key)}</span>`</span>);
    });
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortControllers</span>.<span class="hljs-title function_">clear</span>();
  }

  <span class="hljs-comment">/**
   * 判断是否为取消错误
   * <span class="hljs-doctag">@param</span> error 错误对象
   * <span class="hljs-doctag">@returns</span> 是否为取消错误
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">isCancel</span>(<span class="hljs-attr">error</span>: <span class="hljs-built_in">unknown</span>): <span class="hljs-built_in">boolean</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Axios</span>.<span class="hljs-title function_">isCancel</span>(error);
  }

  <span class="hljs-comment">/**
   * 睡眠函数
   * <span class="hljs-doctag">@param</span> ms 毫秒数
   */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-attr">ms</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));
  }

  <span class="hljs-comment">/**
   * 通用请求方法
   * <span class="hljs-doctag">@param</span> method 请求方法
   * <span class="hljs-doctag">@param</span> url 请求地址
   * <span class="hljs-doctag">@param</span> config 请求配置
   * <span class="hljs-doctag">@returns</span> 响应数据
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> request&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">method</span>: <span class="hljs-title class_">Method</span>, <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>, config?: <span class="hljs-title class_">AxiosRequestConfig</span> &amp; { requestKey?: <span class="hljs-title class_">RequestKey</span>; retry?: <span class="hljs-title class_">RetryConfig</span> }): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ResponseData</span>&lt;T&gt;&gt; {
    <span class="hljs-keyword">const</span> { requestKey, retry, ...restConfig } = config || {};

    <span class="hljs-comment">// 设置合理的默认重试条件</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultRetryCondition</span> = (<span class="hljs-params">error: AxiosError</span>) =&gt; {
      <span class="hljs-comment">// 默认只重试网络错误或5xx服务器错误</span>
      <span class="hljs-keyword">return</span> !error.<span class="hljs-property">response</span> || (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">500</span> &amp;&amp; error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> &lt; <span class="hljs-number">600</span>);
    };

    <span class="hljs-keyword">const</span> retryConfig = {
      <span class="hljs-attr">retries</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">retryDelay</span>: <span class="hljs-number">1000</span>,
      <span class="hljs-attr">retryCondition</span>: defaultRetryCondition,
      ...retry
    };

    <span class="hljs-keyword">let</span> <span class="hljs-attr">lastError</span>: <span class="hljs-built_in">any</span>;
    <span class="hljs-keyword">const</span> key = requestKey || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRequestKey</span>({ ...restConfig, method, url });

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> attempt = <span class="hljs-number">0</span>; attempt &lt;= retryConfig.<span class="hljs-property">retries</span>; attempt++) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 重试前清除旧的AbortController（避免重试请求被误取消）</span>
        <span class="hljs-keyword">if</span> (attempt &gt; <span class="hljs-number">0</span> &amp;&amp; key) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortControllers</span>.<span class="hljs-title function_">delete</span>(key);
        }

        <span class="hljs-keyword">const</span> requestConfig = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupCancelController</span>({ ...restConfig, method, url }, requestKey);

        <span class="hljs-comment">/* 在这里写通用请求前的业务逻辑 */</span>
        <span class="hljs-comment">// 示例: 记录请求日志</span>
        <span class="hljs-comment">// console.log(`[${method.toUpperCase()}] ${url}:`, restConfig);</span>

        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">request</span>&lt;<span class="hljs-title class_">ResponseData</span>&lt;T&gt;&gt;(requestConfig);

        <span class="hljs-comment">/* 在这里写通用请求后的业务逻辑 */</span>
        <span class="hljs-comment">// 示例: 记录响应日志</span>
        <span class="hljs-comment">// console.log(`[${method.toUpperCase()}] ${url} 响应:`, response.data);</span>

        <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>;
      } <span class="hljs-keyword">catch</span> (error) {
        lastError = error;

        <span class="hljs-comment">// 如果是最后一次尝试或不满足重试条件或请求被取消，直接抛出错误</span>
        <span class="hljs-keyword">if</span> (attempt === retryConfig.<span class="hljs-property">retries</span> || !retryConfig.<span class="hljs-title function_">retryCondition</span>(error <span class="hljs-keyword">as</span> <span class="hljs-title class_">AxiosError</span>) || <span class="hljs-title class_">HttpClient</span>.<span class="hljs-title function_">isCancel</span>(error)) {
          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-comment">// 延迟后重试</span>
        <span class="hljs-keyword">if</span> (retryConfig.<span class="hljs-property">retryDelay</span> &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sleep</span>(retryConfig.<span class="hljs-property">retryDelay</span>);
        }
      }
    }

    <span class="hljs-comment">/* 在这里写请求异常的通用处理逻辑 */</span>
    <span class="hljs-comment">// 示例: 统一错误提示</span>
    <span class="hljs-comment">// if (lastError instanceof Error) {</span>
    <span class="hljs-comment">//   console.error('请求失败:', lastError.message);</span>
    <span class="hljs-comment">// }</span>

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(lastError);
  }

  <span class="hljs-comment">/**
   * GET 请求
   * <span class="hljs-doctag">@param</span> url 请求地址
   * <span class="hljs-doctag">@param</span> config 请求配置
   * <span class="hljs-doctag">@returns</span> 响应数据
   */</span>
  <span class="hljs-keyword">public</span> get&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>, config?: <span class="hljs-title class_">AxiosRequestConfig</span> &amp; { requestKey?: <span class="hljs-title class_">RequestKey</span>; retry?: <span class="hljs-title class_">RetryConfig</span> }): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ResponseData</span>&lt;T&gt;&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>&lt;T&gt;(<span class="hljs-string">"get"</span>, url, config);
  }

  <span class="hljs-comment">/**
   * POST 请求
   * <span class="hljs-doctag">@param</span> url 请求地址
   * <span class="hljs-doctag">@param</span> data 请求数据
   * <span class="hljs-doctag">@param</span> config 请求配置
   * <span class="hljs-doctag">@returns</span> 响应数据
   */</span>
  <span class="hljs-keyword">public</span> post&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>, data?: <span class="hljs-built_in">any</span>, config?: <span class="hljs-title class_">AxiosRequestConfig</span> &amp; { requestKey?: <span class="hljs-title class_">RequestKey</span>; retry?: <span class="hljs-title class_">RetryConfig</span> }): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ResponseData</span>&lt;T&gt;&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>&lt;T&gt;(<span class="hljs-string">"post"</span>, url, { ...config, data });
  }

  <span class="hljs-comment">/**
   * PUT 请求
   * <span class="hljs-doctag">@param</span> url 请求地址
   * <span class="hljs-doctag">@param</span> data 请求数据
   * <span class="hljs-doctag">@param</span> config 请求配置
   * <span class="hljs-doctag">@returns</span> 响应数据
   */</span>
  <span class="hljs-keyword">public</span> put&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>, data?: <span class="hljs-built_in">any</span>, config?: <span class="hljs-title class_">AxiosRequestConfig</span> &amp; { requestKey?: <span class="hljs-title class_">RequestKey</span>; retry?: <span class="hljs-title class_">RetryConfig</span> }): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ResponseData</span>&lt;T&gt;&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>&lt;T&gt;(<span class="hljs-string">"put"</span>, url, { ...config, data });
  }

  <span class="hljs-comment">/**
   * DELETE 请求
   * <span class="hljs-doctag">@param</span> url 请求地址
   * <span class="hljs-doctag">@param</span> config 请求配置
   * <span class="hljs-doctag">@returns</span> 响应数据
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">delete</span>&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>, config?: <span class="hljs-title class_">AxiosRequestConfig</span> &amp; { requestKey?: <span class="hljs-title class_">RequestKey</span>; retry?: <span class="hljs-title class_">RetryConfig</span> }): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ResponseData</span>&lt;T&gt;&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>&lt;T&gt;(<span class="hljs-string">"delete"</span>, url, config);
  }

  <span class="hljs-comment">/**
   * PATCH 请求
   * <span class="hljs-doctag">@param</span> url 请求地址
   * <span class="hljs-doctag">@param</span> data 请求数据
   * <span class="hljs-doctag">@param</span> config 请求配置
   * <span class="hljs-doctag">@returns</span> 响应数据
   */</span>
  <span class="hljs-keyword">public</span> patch&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>, data?: <span class="hljs-built_in">any</span>, config?: <span class="hljs-title class_">AxiosRequestConfig</span> &amp; { requestKey?: <span class="hljs-title class_">RequestKey</span>; retry?: <span class="hljs-title class_">RetryConfig</span> }): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ResponseData</span>&lt;T&gt;&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>&lt;T&gt;(<span class="hljs-string">"patch"</span>, url, { ...config, data });
  }
}

<span class="hljs-comment">// 默认导出实例 - 可直接使用</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> http = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpClient</span>();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HttpClient</span>;
</code></pre>
<h2 data-id="heading-3">🛠️ 使用指南</h2>
<h3 data-id="heading-4">1. 基础请求操作：GET/POST 等常用方法</h3>
<p>任何 HTTP 客户端最核心的功能都是处理基础请求，HttpClient 对常用的 HTTP 方法进行了友好封装，同时提供了完整的 TypeScript 类型支持。</p>
<p>首先定义我们需要用到的数据类型：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 用户信息接口</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">// 分页响应通用接口</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">PageResponse</span>&lt;T&gt; {
  <span class="hljs-attr">list</span>: T[];       <span class="hljs-comment">// 数据列表</span>
  <span class="hljs-attr">total</span>: <span class="hljs-built_in">number</span>;   <span class="hljs-comment">// 总条数</span>
  <span class="hljs-attr">page</span>: <span class="hljs-built_in">number</span>;    <span class="hljs-comment">// 当前页码</span>
  <span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>;    <span class="hljs-comment">// 每页条数</span>
}
</code></pre>
<p>基础请求操作示例：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">basicRequests</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 1. GET 请求（带查询参数）</span>
    <span class="hljs-keyword">const</span> userPage = <span class="hljs-keyword">await</span> http.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">PageResponse</span>&lt;<span class="hljs-title class_">User</span>&gt;&gt;(<span class="hljs-string">'/api/users'</span>, {
      <span class="hljs-attr">params</span>: { <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">10</span> }
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第<span class="hljs-subst">${userPage.page}</span>页，共<span class="hljs-subst">${userPage.total}</span>个用户:`</span>, userPage.<span class="hljs-property">list</span>);

    <span class="hljs-comment">// 2. POST 请求（提交数据）</span>
    <span class="hljs-keyword">const</span> newUser = <span class="hljs-keyword">await</span> http.<span class="hljs-property">post</span>&lt;{ <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span> }&gt;(<span class="hljs-string">'/api/users'</span>, {
      <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>,
      <span class="hljs-attr">email</span>: <span class="hljs-string">'zhangsan@example.com'</span>
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'新增用户ID:'</span>, newUser.<span class="hljs-property">id</span>);

    <span class="hljs-comment">// 3. PUT 请求（更新数据）</span>
    <span class="hljs-keyword">const</span> updatedUser = <span class="hljs-keyword">await</span> http.<span class="hljs-property">put</span>&lt;<span class="hljs-title class_">User</span>&gt;(<span class="hljs-string">'/api/users/1'</span>, {
      <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'张三三'</span>,
      <span class="hljs-attr">email</span>: <span class="hljs-string">'zhangsansan@example.com'</span>
    });

    <span class="hljs-comment">// 4. DELETE 请求</span>
    <span class="hljs-keyword">const</span> deleteRes = <span class="hljs-keyword">await</span> http.<span class="hljs-property">delete</span>&lt;{ <span class="hljs-attr">success</span>: <span class="hljs-built_in">boolean</span>; message?: <span class="hljs-built_in">string</span> }&gt;(<span class="hljs-string">'/api/users/1'</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'删除结果:'</span>, deleteRes.<span class="hljs-property">success</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 统一错误处理</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求失败:'</span>, error <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span> ? error.<span class="hljs-property">message</span> : error);
  }
}
</code></pre>
<p><strong>关键特性</strong>：</p>
<ul>
<li>泛型参数直接指定响应数据类型，获得完整的类型提示</li>
<li>统一的错误处理机制，无需在每个请求中重复编写 try-catch</li>
<li>自动处理请求参数序列化和响应数据解析</li>
</ul>
<h3 data-id="heading-5">2. 多实例管理：为不同 API 服务创建专属客户端</h3>
<p>在复杂项目中，我们常常需要与多个 API 服务交互，每个服务可能有不同的基础路径、超时设置或认证方式。HttpClient 支持创建多个独立实例，完美解决这个问题。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 定义商品数据接口</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Product</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">price</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">stock</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-comment">// 1. 创建用户服务专用实例</span>
<span class="hljs-keyword">const</span> userApi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpClient</span>({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://api.example.com/user'</span>,  <span class="hljs-comment">// 用户服务基础路径</span>
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span>                           <span class="hljs-comment">// 超时设置为10秒</span>
});

<span class="hljs-comment">// 2. 创建商品服务专用实例（带特殊请求头）</span>
<span class="hljs-keyword">const</span> productApi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpClient</span>({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://api.example.com/product'</span>,  <span class="hljs-comment">// 商品服务基础路径</span>
  <span class="hljs-attr">headers</span>: { <span class="hljs-string">'X-Product-Token'</span>: <span class="hljs-string">'special-token'</span> }  <span class="hljs-comment">// 商品服务需要的特殊头部</span>
});

<span class="hljs-comment">// 使用多实例处理不同服务的请求</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useMultiInstances</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 调用用户服务API</span>
  <span class="hljs-keyword">const</span> userPage = <span class="hljs-keyword">await</span> userApi.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">PageResponse</span>&lt;<span class="hljs-title class_">User</span>&gt;&gt;(<span class="hljs-string">'/list'</span>);
  
  <span class="hljs-comment">// 调用商品服务API</span>
  <span class="hljs-keyword">const</span> productPage = <span class="hljs-keyword">await</span> productApi.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">PageResponse</span>&lt;<span class="hljs-title class_">Product</span>&gt;&gt;(<span class="hljs-string">'/list'</span>);
  
  <span class="hljs-comment">// 两个实例的配置完全隔离，不会相互影响</span>
}
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>前后端分离项目中对接多个微服务</li>
<li>同时需要访问内部API和第三方API</li>
<li>不同接口有不同的超时需求（如普通接口5秒，文件上传60秒）</li>
</ul>
<h3 data-id="heading-6">3. 自定义拦截器：业务逻辑与请求处理的解耦</h3>
<p>拦截器是处理请求/响应公共逻辑的最佳方式，HttpClient 允许在初始化时配置自定义拦截器，将认证、日志等横切关注点与业务逻辑分离。</p>
<p>最常见的场景是处理认证逻辑：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 创建带权限验证的HTTP客户端实例</span>
<span class="hljs-keyword">const</span> authHttp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpClient</span>(
  { <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://api.example.com/auth'</span> },  <span class="hljs-comment">// 基础配置</span>
  {
    <span class="hljs-comment">// 请求拦截器：添加认证Token</span>
    <span class="hljs-attr">requestInterceptor</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'token'</span>);
      <span class="hljs-keyword">if</span> (token) {
        config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>;
      }
      <span class="hljs-keyword">return</span> config;
    },
    
    <span class="hljs-comment">// 响应拦截器：处理认证失败</span>
    <span class="hljs-attr">responseInterceptor</span>: <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
      <span class="hljs-comment">// 未授权，自动跳转到登录页</span>
      <span class="hljs-keyword">if</span> (response.<span class="hljs-property">code</span> === <span class="hljs-number">401</span>) {
        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'token'</span>);
        <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">'/login'</span>;
      }
      <span class="hljs-keyword">return</span> response;
    }
  }
);
</code></pre>
<p><strong>拦截器的典型用途</strong>：</p>
<ul>
<li>添加全局认证信息（Token、API Key等）</li>
<li>统一处理错误码（如401未授权、403权限不足）</li>
<li>实现请求/响应日志记录</li>
<li>添加请求时间戳防止缓存</li>
</ul>
<h3 data-id="heading-7">4. 动态修改拦截器：运行时灵活调整请求行为</h3>
<p>有时候我们需要在运行时根据业务场景动态改变请求/响应处理逻辑，HttpClient 提供了动态修改拦截器的能力。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 定义日志数据接口</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">LogData</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">timestamp</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">content</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">dynamicInterceptors</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 场景1：临时添加日志拦截器</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">logInterceptor</span> = (<span class="hljs-params">response: AxiosResponse&lt;ResponseData&lt;PageResponse&lt;LogData&gt;&gt;&gt;</span>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`请求[<span class="hljs-subst">${response.config.url}</span>]返回<span class="hljs-subst">${response.data.total}</span>条日志`</span>);
    <span class="hljs-keyword">return</span> response;
  };

  <span class="hljs-comment">// 设置新的响应拦截器</span>
  http.<span class="hljs-title function_">setResponseInterceptor</span>(logInterceptor);
  
  <span class="hljs-comment">// 发送请求时会执行新的拦截器</span>
  <span class="hljs-keyword">await</span> http.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">PageResponse</span>&lt;<span class="hljs-title class_">LogData</span>&gt;&gt;(<span class="hljs-string">'/api/logs'</span>);

  <span class="hljs-comment">// 场景2：完成日志收集后，恢复默认拦截器</span>
  http.<span class="hljs-title function_">setResponseInterceptor</span>();

  <span class="hljs-comment">// 场景3：动态更新认证信息（如Token刷新后）</span>
  <span class="hljs-keyword">const</span> newToken = <span class="hljs-string">'new-auth-token'</span>;
  http.<span class="hljs-title function_">setRequestInterceptor</span>(<span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
    config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">${newToken}</span>`</span>;
    <span class="hljs-keyword">return</span> config;
  });
}
</code></pre>
<p><strong>实用场景</strong>：</p>
<ul>
<li>临时开启调试日志</li>
<li>Token过期后动态更新认证信息</li>
<li>特定页面需要特殊的请求头</li>
<li>A/B测试时切换不同的API处理逻辑</li>
</ul>
<h3 data-id="heading-8">5. 请求取消：优化用户体验的关键技巧</h3>
<p>在用户快速操作或页面切换时，取消无用的请求可以显著提升性能和用户体验。HttpClient 提供了多种灵活的请求取消方式。</p>
<h4 data-id="heading-9">5.1 主动取消单个请求</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cancelSingleRequest</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> requestKey = <span class="hljs-string">'user-list'</span>;  <span class="hljs-comment">// 定义唯一标识</span>

  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 发起请求时指定requestKey</span>
    <span class="hljs-keyword">const</span> promise = http.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">PageResponse</span>&lt;<span class="hljs-title class_">User</span>&gt;&gt;(<span class="hljs-string">'/api/users'</span>, { requestKey });

    <span class="hljs-comment">// 模拟：200ms后取消请求（例如用户快速切换了页面）</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      http.<span class="hljs-title function_">cancelRequest</span>(requestKey, <span class="hljs-string">'数据已过时'</span>);
    }, <span class="hljs-number">200</span>);

    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> promise;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 判断是否为取消错误</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">HttpClient</span>.<span class="hljs-title function_">isCancel</span>(error)) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'请求已取消:'</span>, error.<span class="hljs-property">message</span>);
    }
  }
}
</code></pre>
<h4 data-id="heading-10">5.2 自动取消重复请求</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cancelDuplicate</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 连续发起相同参数的请求</span>
  http.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">PageResponse</span>&lt;<span class="hljs-title class_">User</span>&gt;&gt;(<span class="hljs-string">'/api/users'</span>, { <span class="hljs-attr">params</span>: { <span class="hljs-attr">page</span>: <span class="hljs-number">1</span> } }); <span class="hljs-comment">// 被取消</span>
  http.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">PageResponse</span>&lt;<span class="hljs-title class_">User</span>&gt;&gt;(<span class="hljs-string">'/api/users'</span>, { <span class="hljs-attr">params</span>: { <span class="hljs-attr">page</span>: <span class="hljs-number">1</span> } }); <span class="hljs-comment">// 被取消</span>
  <span class="hljs-keyword">const</span> latestData = <span class="hljs-keyword">await</span> http.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">PageResponse</span>&lt;<span class="hljs-title class_">User</span>&gt;&gt;(<span class="hljs-string">'/api/users'</span>, { <span class="hljs-attr">params</span>: { <span class="hljs-attr">page</span>: <span class="hljs-number">1</span> } }); <span class="hljs-comment">// 最终生效</span>
}
</code></pre>
<h4 data-id="heading-11">5.3 页面卸载时取消所有请求</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 在React/Vue等框架的组件卸载钩子中调用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">onPageUnmount</span>(<span class="hljs-params"></span>) {
  http.<span class="hljs-title function_">cancelAllRequests</span>(<span class="hljs-string">'页面已关闭'</span>);
}

<span class="hljs-comment">// 或者监听页面关闭事件</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'beforeunload'</span>, <span class="hljs-function">() =&gt;</span> {
  http.<span class="hljs-title function_">cancelAllRequests</span>(<span class="hljs-string">'用户离开页面'</span>);
});
</code></pre>
<p><strong>带来的好处</strong>：</p>
<ul>
<li>减少不必要的网络请求和服务器负载</li>
<li>避免过时数据覆盖最新数据</li>
<li>防止页面跳转后仍弹出错误提示</li>
<li>减少内存占用和潜在的内存泄漏</li>
</ul>
<h3 data-id="heading-12">6. 文件上传：大文件处理的最佳实践</h3>
<p>文件上传是前端开发中的常见需求，尤其需要注意超时设置和数据格式。HttpClient 可以轻松配置适合文件上传的参数。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 定义上传结果接口</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">UploadResult</span> {
  <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>;      <span class="hljs-comment">// 上传后的文件URL</span>
  <span class="hljs-attr">filename</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 文件名</span>
  <span class="hljs-attr">size</span>: <span class="hljs-built_in">number</span>;     <span class="hljs-comment">// 文件大小</span>
}

<span class="hljs-comment">// 处理文件上传</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">uploadFile</span>(<span class="hljs-params">file: File</span>) {
  <span class="hljs-comment">// 创建FormData对象</span>
  <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();
  formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'file'</span>, file);
  
  <span class="hljs-comment">// 可选：添加其他表单字段</span>
  formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'category'</span>, <span class="hljs-string">'document'</span>);
  formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">'description'</span>, <span class="hljs-string">'用户上传的文档'</span>);

  <span class="hljs-comment">// 创建上传专用实例（配置更长的超时）</span>
  <span class="hljs-keyword">const</span> uploadHttp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpClient</span>({
    <span class="hljs-attr">timeout</span>: <span class="hljs-number">60000</span>,  <span class="hljs-comment">// 上传超时设为60秒</span>
    <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'multipart/form-data'</span> }
  });

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> uploadHttp.<span class="hljs-property">post</span>&lt;<span class="hljs-title class_">UploadResult</span>&gt;(<span class="hljs-string">'/api/upload'</span>, formData);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件上传成功，访问地址:'</span>, result.<span class="hljs-property">url</span>);
    <span class="hljs-keyword">return</span> result.<span class="hljs-property">url</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'文件上传失败:'</span>, error);
    <span class="hljs-keyword">throw</span> error;
  }
}
</code></pre>
<p><strong>上传优化建议</strong>：</p>
<ul>
<li>大文件上传使用专门的实例，设置较长超时</li>
<li>配合进度条展示上传进度（可通过 Axios 的 onUploadProgress 实现）</li>
<li>考虑分片上传大文件（超过100MB的文件）</li>
<li>重要文件上传可配置重试机制</li>
</ul>
<h3 data-id="heading-13">7. 并发请求处理：高效获取多源数据</h3>
<p>实际开发中经常需要同时请求多个接口，然后汇总处理数据。HttpClient 结合 Promise API 可以优雅地处理并发请求。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 使用Promise.all处理并发请求</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleConcurrentRequests</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 同时发起多个请求</span>
    <span class="hljs-keyword">const</span> [userRes, productRes] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
      http.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">User</span>&gt;(<span class="hljs-string">'/api/users/1'</span>),                <span class="hljs-comment">// 获取用户详情</span>
      http.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">PageResponse</span>&lt;<span class="hljs-title class_">Product</span>&gt;&gt;(<span class="hljs-string">'/api/products'</span>) <span class="hljs-comment">// 获取商品列表</span>
    ]);

    <span class="hljs-comment">// 所有请求成功后处理数据</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'用户详情:'</span>, userRes);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'商品列表:'</span>, productRes.<span class="hljs-property">list</span>);
    
    <span class="hljs-comment">// 可以在这里进行数据整合</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">user</span>: userRes,
      <span class="hljs-attr">products</span>: productRes.<span class="hljs-property">list</span>
    };
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 任何一个请求失败都会进入这里</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'并发请求失败:'</span>, error);
    <span class="hljs-keyword">throw</span> error;
  }
}
</code></pre>
<p><strong>并发处理技巧</strong>：</p>
<ul>
<li>使用 <code>Promise.all</code> 处理相互依赖的并发请求（一失败全失败）</li>
<li>使用 <code>Promise.allSettled</code> 处理可以独立失败的请求</li>
<li>对大量并发请求进行分批处理，避免浏览器限制</li>
<li>结合请求取消机制，在某个关键请求失败时取消其他请求</li>
</ul>
<h3 data-id="heading-14">8. 请求重试：提升网络不稳定场景的可靠性</h3>
<p>网络波动是前端请求失败的常见原因，HttpClient 内置的重试机制可以自动处理这类问题，提升用户体验。</p>
<h4 data-id="heading-15">8.1 基础重试配置（使用默认策略）</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 使用默认重试条件</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">basicRetryWithDefaults</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> http.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">User</span>&gt;(<span class="hljs-string">'/api/users/1'</span>, {
      <span class="hljs-attr">retry</span>: {
        <span class="hljs-attr">retries</span>: <span class="hljs-number">3</span>,       <span class="hljs-comment">// 最多重试3次</span>
        <span class="hljs-attr">retryDelay</span>: <span class="hljs-number">1000</span>  <span class="hljs-comment">// 每次重试间隔1秒</span>
        <span class="hljs-comment">// 默认策略：只重试网络错误或5xx服务器错误</span>
      }
    });
    <span class="hljs-keyword">return</span> result;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'所有重试都失败了:'</span>, error);
    <span class="hljs-keyword">throw</span> error;
  }
}
</code></pre>
<h4 data-id="heading-16">8.2 自定义重试条件</h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 自定义重试逻辑</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">customRetryCondition</span>(<span class="hljs-params">userData: User</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> http.<span class="hljs-property">post</span>&lt;<span class="hljs-title class_">User</span>&gt;(<span class="hljs-string">'/api/users'</span>, userData, {
      <span class="hljs-attr">retry</span>: {
        <span class="hljs-attr">retries</span>: <span class="hljs-number">2</span>,       <span class="hljs-comment">// 重试2次</span>
        <span class="hljs-attr">retryDelay</span>: <span class="hljs-number">500</span>,  <span class="hljs-comment">// 重试间隔500ms</span>
        <span class="hljs-attr">retryCondition</span>: <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
          <span class="hljs-comment">// 自定义条件：网络错误、超时或5xx错误才重试</span>
          <span class="hljs-keyword">return</span> !error.<span class="hljs-property">response</span> || 
                 error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">408</span> || 
                 (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">500</span> &amp;&amp; error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> &lt; <span class="hljs-number">600</span>);
        }
      }
    });
    <span class="hljs-keyword">return</span> result;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'重试失败:'</span>, error);
    <span class="hljs-keyword">throw</span> error;
  }
}
</code></pre>
<p><strong>重试策略建议</strong>：</p>
<ul>
<li>读操作（GET）适合重试，写操作（POST/PUT）需谨慎</li>
<li>重试次数不宜过多（通常2-3次），避免加重服务器负担</li>
<li>使用指数退避策略（retryDelay 逐渐增加）</li>
<li>对明确的客户端错误（如400、401、403）不重试</li>
</ul>
<h3 data-id="heading-17">9. 访问原始 Axios 实例：兼容特殊需求</h3>
<p>虽然 HttpClient 封装了常用功能，但某些特殊场景可能需要直接使用 Axios 原生 API。HttpClient 提供了获取原始实例的方法。</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 获取原始Axios实例</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getOriginalAxiosInstance</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> axiosInstance = http.<span class="hljs-title function_">getInstance</span>();
  
  <span class="hljs-comment">// 示例1：使用Axios的cancelToken（旧版取消方式）</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">CancelToken</span> = <span class="hljs-title class_">Axios</span>.<span class="hljs-property">CancelToken</span>;
  <span class="hljs-keyword">const</span> source = <span class="hljs-title class_">CancelToken</span>.<span class="hljs-title function_">source</span>();
  
  axiosInstance.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/special'</span>, {
    <span class="hljs-attr">cancelToken</span>: source.<span class="hljs-property">token</span>
  });
  
  <span class="hljs-comment">// 取消请求</span>
  source.<span class="hljs-title function_">cancel</span>(<span class="hljs-string">'Operation canceled by the user.'</span>);
  
  <span class="hljs-comment">// 示例2：使用Axios的拦截器API</span>
  <span class="hljs-keyword">const</span> myInterceptor = axiosInstance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
    <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response,
    <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  );
  
  <span class="hljs-comment">// 移除拦截器</span>
  axiosInstance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">eject</span>(myInterceptor);
}
</code></pre>
<p><strong>适用场景</strong>：</p>
<ul>
<li>使用一些 HttpClient 未封装的 Axios 特性</li>
<li>集成依赖原始 Axios 实例的第三方库</li>
<li>处理极特殊的请求场景</li>
<li>平滑迁移现有基于 Axios 的代码</li>
</ul>
<h2 data-id="heading-18">🤔 插曲：朋友的无情嘲笑</h2>
<p>在我们完成本次封装前，还有一个小插曲：我得意洋洋地把这个"史上最优雅"的封装发给朋友炫耀，心想着他肯定会夸我两句。结果他发来了一大段文字...</p>
<h3 data-id="heading-19">第一轮攻击：类型定义问题</h3>
<p><strong>朋友</strong>: "你这代码有点问题啊 😏 你这个 <code>ResponseData</code> 类型扩展性不足："</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 你的问题代码</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">ResponseData</span>&lt;T = <span class="hljs-built_in">any</span>&gt; = <span class="hljs-title class_">BaseResponse</span> &amp; T;

<span class="hljs-comment">// 当 T 中包含 code 或 message 字段时会冲突</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserWithCode</span> {
  <span class="hljs-attr">code</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 与BaseResponse冲突</span>
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}
<span class="hljs-keyword">type</span> <span class="hljs-title class_">TestType</span> = <span class="hljs-title class_">ResponseData</span>&lt;<span class="hljs-title class_">UserWithCode</span>&gt;; <span class="hljs-comment">// code字段变成never类型！</span>
</code></pre>
<p><strong>我</strong>: "不可能！绝对不可能！（曹操.gif）"</p>
<p>然后我测试了一下，果然报错了... 😅</p>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 修复后的版本</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">OmitBaseResponse</span>&lt;T&gt; = <span class="hljs-title class_">Omit</span>&lt;T, keyof <span class="hljs-title class_">BaseResponse</span>&gt;;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">ResponseData</span>&lt;T = <span class="hljs-built_in">any</span>&gt; = <span class="hljs-title class_">BaseResponse</span> &amp; <span class="hljs-title class_">OmitBaseResponse</span>&lt;T&gt;;
</code></pre>
<h3 data-id="heading-20">第二轮攻击：请求取消逻辑缺陷</h3>
<p><strong>朋友</strong>: "还有你这个 <code>setupCancelController</code> 未处理自定义 <code>requestKey</code> 冲突，当用户传入自定义 <code>requestKey</code> 时，若与内部生成的键重复，会导致取消逻辑混乱。"</p>
<p><strong>我</strong>: "这... 这应该不会吧？"</p>
<p><strong>朋友</strong>: "你看，你的代码是这样的：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">private</span> <span class="hljs-title function_">setupCancelController</span>(<span class="hljs-params">config: AxiosRequestConfig, requestKey?: RequestKey</span>) {
  <span class="hljs-keyword">const</span> key = requestKey || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRequestKey</span>(config);
  <span class="hljs-comment">// 直接取消，但没有冲突警告</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cancelRequest</span>(key);
}
</code></pre>
<p>如果有重复key怎么办？建议加个警告。"</p>
<p><strong>我</strong>: "但是我这里直接取消重复请求不是挺好的吗？这是防重复机制啊！"</p>
<p><strong>朋友</strong>: "嗯...这个倒是有道理。那算了，这个问题不大。"</p>
<h3 data-id="heading-21">第三轮攻击：重试机制边界问题</h3>
<p><strong>朋友</strong>: "但是你这个重试逻辑有问题！重试时未重置 <code>AbortController</code>："</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 你的问题代码</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> attempt = <span class="hljs-number">0</span>; attempt &lt;= retryConfig.<span class="hljs-property">retries</span>; attempt++) {
  <span class="hljs-comment">// 每次都会调用setupCancelController，创建新的controller</span>
  <span class="hljs-comment">// 但旧的还在Map中，可能导致重试请求被误取消</span>
  <span class="hljs-keyword">const</span> requestConfig = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupCancelController</span>({...restConfig, method, url}, requestKey);
}
</code></pre>
<p><strong>我</strong>: "这... 这是边缘情况！"</p>
<p><strong>朋友</strong>: "边缘情况也是情况啊！还有你的 <code>retryCondition</code> 默认值缺失，当用户未配置时，会默认重试所有错误（包括400等客户端错误），不符合预期。"</p>
<p><strong>我</strong>: "好吧好吧，我改还不行吗... 😤"</p>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 修复后的版本</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultRetryCondition</span> = (<span class="hljs-params">error: AxiosError</span>) =&gt; {
  <span class="hljs-comment">// 默认只重试网络错误或5xx服务器错误</span>
  <span class="hljs-keyword">return</span> !error.<span class="hljs-property">response</span> || (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">500</span> &amp;&amp; error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> &lt; <span class="hljs-number">600</span>);
};

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> attempt = <span class="hljs-number">0</span>; attempt &lt;= retryConfig.<span class="hljs-property">retries</span>; attempt++) {
  <span class="hljs-comment">// 重试前清除旧控制器</span>
  <span class="hljs-keyword">if</span> (attempt &gt; <span class="hljs-number">0</span> &amp;&amp; key) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">abortControllers</span>.<span class="hljs-title function_">delete</span>(key);
  }
  <span class="hljs-keyword">const</span> requestConfig = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupCancelController</span>({...restConfig, method, url}, requestKey);
}
</code></pre>
<h3 data-id="heading-22">第四轮攻击：拦截器管理问题</h3>
<p><strong>朋友</strong>: "还有你的拦截器移除逻辑不严谨，只通过 <code>interceptorId</code> 移除，但未重置 <code>interceptorId</code>，可能导致后续重复移除无效："</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 你的问题代码</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">removeRequestInterceptor</span>(): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestInterceptorId</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">eject</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestInterceptorId</span>);
    <span class="hljs-comment">// 没有重置ID！</span>
  }
}
</code></pre>
<p><strong>我</strong>: "这... 好吧，确实应该重置一下。"</p>
<p><strong>解决方案</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 修复后的版本</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">removeRequestInterceptor</span>(): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestInterceptorId</span> !== <span class="hljs-literal">undefined</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">eject</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestInterceptorId</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestInterceptorId</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 重置ID</span>
  }
}
</code></pre>
<h3 data-id="heading-23">第五轮攻击：其他细节问题</h3>
<p><strong>朋友</strong>: "哈哈，别急。不过你还有几个问题：</p>
<ol>
<li>
<p><strong><code>Content-Type</code> 硬编码问题</strong> - 默认强制设置为 <code>application/json</code>，但上传文件时需要 <code>multipart/form-data</code>，需手动覆盖，不够灵活。</p>
</li>
<li>
<p><strong>错误信息处理冗余</strong> - 响应错误拦截器中对错误信息的包装会丢失原始错误的详细信息，不利于调试。</p>
</li>
<li>
<p><strong><code>requestKey</code> 类型声明不明确</strong> - 定义为 <code>string | symbol</code>，但用户传入 <code>symbol</code> 时，调试信息显示不友好。"</p>
</li>
</ol>
<p><strong>我</strong>: "停停停！你这是在 code review 还是在找茬？！"</p>
<p><strong>朋友</strong>: "当然是 code review 啦，不过后面这几个确实比较鸡蛋里挑骨头，前面几个确实需要修复。"</p>
<h3 data-id="heading-24">我的反击与分析</h3>
<p>经过一番"友好"的讨论（主要是我被教育），我冷静分析了一下：</p>
<p><strong>确实有价值的问题（必须修复）：</strong></p>
<ul>
<li>✅ <strong>ResponseData 类型冲突</strong> - 很重要！确实会导致 <code>never</code> 类型问题</li>
<li>✅ <strong>重试机制的默认条件缺失</strong> - 重要！应该有合理的默认重试条件</li>
<li>✅ <strong>拦截器ID重置问题</strong> - 中等重要，确实应该重置ID</li>
<li>✅ <strong>重试时AbortController重置</strong> - 中等重要，理论上存在问题</li>
</ul>
<p><strong>过于苛刻或设计选择问题：</strong></p>
<ul>
<li>❌ <strong>requestKey冲突警告</strong> - 当前设计已经通过取消旧请求处理了，警告是多余的</li>
<li>❌ <strong>Content-Type硬编码</strong> - 这是常见的默认设置，Axios会自动覆盖FormData</li>
<li>❌ <strong>错误信息包装</strong> - 保留原始错误是好的，但当前设计也合理</li>
<li>❌ <strong>拦截器组合模式</strong> - 当前的覆盖模式是主流设计，组合模式会增加复杂性</li>
</ul>
<p><strong>主观性问题：</strong></p>
<ul>
<li>🤔 <strong>requestKey类型限制</strong> - symbol支持是特性，不是缺陷</li>
</ul>
<p>最终我不得不承认：<strong>朋友的技术功底是不错的，提出了一些确实存在的边缘问题。但有些建议过于"完美主义"，可能会让代码变得过于复杂。</strong></p>
<p>修复了前4个重要问题后，朋友终于点头说："现在看起来像个正经的封装了！不过你得承认，好的代码不仅要能跑，还要经得起同行的审视。" 😂</p>
<h2 data-id="heading-25">🚀 写在最后</h2>
<p>经过这一上午的"激情"编码 + 朋友的"无情"嘲笑 + 我的"不服气"修复，这个 HTTP 客户端封装终于变得更加健壮了。</p>
<p>从最初的自我感觉良好，到被朋友无情打脸，再到最后的虚心修复，这个过程让我深刻体会到：</p>
<ol>
<li><strong>没有完美的代码</strong> - 总有你想不到的边缘情况</li>
<li><strong>Code Review 很重要</strong> - 别人的视角能发现你的盲点</li>
<li><strong>保持开放心态</strong> - 被指出问题是好事，不是坏事</li>
<li><strong>朋友很重要</strong> - 能"嘲笑"你代码的朋友才是真朋友 😄</li>
</ol>
<p>现在这个封装不仅解决了日常开发中的痛点，还具备了企业级项目的稳定性。</p>
<p><strong>核心优势：</strong></p>
<ul>
<li>🎯 <strong>开箱即用</strong> - 无需复杂配置，默认就很好用</li>
<li>🔧 <strong>高度可定制</strong> - 支持各种业务场景的定制需求</li>
<li>🛡️ <strong>类型安全</strong> - TypeScript 完美支持，减少运行时错误</li>
<li>⚡ <strong>性能出色</strong> - 智能去重、重试、取消机制</li>
<li>📚 <strong>文档完善</strong> - 详细的示例和注释</li>
</ul>
<p>如果你也在为 HTTP 请求封装而苦恼，不妨试试这个方案。记住，<strong>好的代码是改出来的，不是写出来的</strong>！</p>
<hr>
<p><strong>你有过类似被朋友"嘲笑"代码的经历吗？你觉得这个封装怎么样？欢迎在评论区分享你的故事！</strong> 🤗</p>
<h2 data-id="heading-26">其他精彩文章</h2>
<p><a href="https://juejin.cn/post/7538701316909596691" target="_blank" title="https://juejin.cn/post/7538701316909596691">优雅！太优雅！斯巴拉西！怎么让AI写出最优雅的代码</a></p></div></div>