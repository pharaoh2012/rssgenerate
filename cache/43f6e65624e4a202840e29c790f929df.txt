
		<h2>
			<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/lmy5215006/p/18736066" title="发布于 2025-03-03 13:30">
    <span role="heading" aria-level="2">重生之数据结构与算法----数组&amp;链表</span>
    

</a>

		</h2>
		<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="简介">简介</h1>
<p>数据结构的本质，只有两种结构，<code>数组与链表</code>。其它的都是它的衍生与组合<br>
算法的本质就是<code>穷举</code>。</p>
<h1 id="数组">数组</h1>
<p>数组可以分为两大类，<code>静态数组</code>与<code>动态数组</code>。<br>
静态数组的本质是<code>一段连续的内存</code>，因为是连续的，所以我们可以采用偏移量的方式来对元素实现快速访问。<br>
而动态数组则是对静态数组的封装，使得更加方便操作元素。有了动态数组，后续的栈，哈希，队列都能更加优雅的实现。</p>
<h2 id="静态数组">静态数组</h2>
<ol>
<li>
<p>数组的超能力<br>
随机访问。只要任意一个索引，都能推测出元素的内存地址，而计算机的内存寻址能力为Log(1),所以数组的随机访问时间复杂度也同样为Log(1)</p>
</li>
<li>
<p>数组的局限性<br>
由于数组的大小是固定的，所以当数组满了，或者需要在中间插入/删除时。都需要移动元素，这时候时间复杂度就上升为Log(N)</p>
</li>
</ol>
<h2 id="动态数组">动态数组</h2>
<p>动态数组无法解决静态数组Log(N)的问题，它只是帮你隐藏了动态扩容与元素搬移的过程，以及更加易用的API。</p>
<blockquote>
<p>数组随机访问的超能力源于数组连续的内存空间，而连续的内存空间就不可避免地面对元素搬移和扩缩容的问题</p>
</blockquote>
<h3 id="一个简单的动态数组">一个简单的动态数组</h3>
<pre><code>public class MyList&lt;T&gt;()
    
{
    //真正存储数据的底层
    private T[] arr = new T[5];
    //记录元素的数量
    public int Count { get; private set; }



    /// &lt;summary&gt;
    /// 增
    /// &lt;/summary&gt;
    /// &lt;param name="item"&gt;&lt;/param&gt;
    public void Add(T item)
    {
        if (Count == arr.Length)
        {
            //扩容
            Resize(Count * 2);
        }

        arr[Count] = item;
        Count++;
    }
    /// &lt;summary&gt;
    /// 删
    /// &lt;/summary&gt;
    /// &lt;param name="idx"&gt;&lt;/param&gt;
    public void RemoveAt(int idx)
    {
        if (Count == arr.Length / 4)
        {
            //缩容
            Resize(arr.Length / 2);
        }
        Count--;
        for (int i = idx; i &lt; Count; i++)
        {
            arr[i] = arr[i + 1];
        }
        
        arr[Count] = default(T);
        
    }
    public void Remove(T item)
    {
        var idx = FindIndex(item);
        RemoveAt(idx);
    }

    /// &lt;summary&gt;
    /// 改
    /// &lt;/summary&gt;
    /// &lt;param name="idx"&gt;&lt;/param&gt;
    /// &lt;param name="newItem"&gt;&lt;/param&gt;
    public void Put(int idx,T newItem)
    {
        arr[idx] = newItem;
    }

    /// &lt;summary&gt;
    /// 查
    /// &lt;/summary&gt;
    /// &lt;param name="item"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public int FindIndex(T item)
    {
        for(int i = 0; i &lt; arr.Length; i++)
        {
            if (item.Equals(arr[i]))
                return i;
        }

        return -1;
    }
    
    /// &lt;summary&gt;
    /// 扩容/缩容操作
    /// &lt;/summary&gt;
    /// &lt;param name="initCapacity"&gt;&lt;/param&gt;
    private void Resize(int initCapacity)
    {
        var newArray=new T[initCapacity];

        for(var i = 0; i &lt; Count; i++)
        {
            newArray[i] = arr[i];
        }

        arr = newArray;
    }
    
}
</code></pre>
<h2 id="数组的变种环形数组">数组的变种：环形数组</h2>
<p>有人可能会问了？数组不是一段连续的内存吗？怎么可能是环形的？<br>
从物理角度出发，这确实不可能。但从<code>逻辑角度</code>出发，这是有可能的。<br>
其核心内容就是利用<code>求模运算</code></p>
<pre><code>        public static void Run()
        {
            var arr = new int[] { 1, 2, 3, 4, 5, 6 };
            var i = 0;
            while (arr.Length &gt; 0)
            {
                Console.WriteLine(arr[i]);
                //关键代码在此，当i遍历到末尾时，i+1与arr.Length去余数变成0
                //从逻辑上完成了闭环
                i = (i + 1) % arr.Length;


                if ((i % arr.Length) == 0)
                {
                    Console.WriteLine("完成了一次循环，i归零");
                    Thread.Sleep(1000);
                }
            }
        }
</code></pre>
<blockquote>
<p>环形数组的关键在于，它维护了两个指针 start 和 end，start 指向第一个有效元素的索引，end 指向最后一个有效元素的下一个位置索引<br>
环形数组解决了什么问题？数组在头部增删从O(N)，优化为O(1)</p>
</blockquote>
<h1 id="链表">链表</h1>
<p>链表分为<code>单链表</code>与<code>双链表</code>，单链表只有一个指针，指向next元素。双链表有两个指针，分别指向previous与next。<br>
除此之外并无其它区别。主要功能区别在于能否向前遍历。</p>
<h2 id="为什么需要链表">为什么需要链表</h2>
<p>前面说到，数组的本质是<code>一段连续的内存</code>，当元素移动/扩容时，需要one by one 移动，花销很大。<br>
那有没有一种能突破<code>内存限制</code>的数据结构呢？链表就应运而生。链表<code>不需要连续内存</code>，它们可以分配在天南海北，它们之间的联系靠next/prev链接，将<code>零散的元素</code>串成一个链式结构。</p>
<p>这么做有两个好处</p>
<ol>
<li>提高内存利用率，分配在哪都可以。所以可以降低内存碎片</li>
<li>方便扩容与移动，只需要重新指向next/previous 即可实现增，删，改等操作，无需移动元素与扩容。</li>
</ol>
<p>但万物皆有代价，因为链表的不连续性，所以无法利用快速随机访问来定位元素，只能一个一个的遍历来确定元素。因此链表的查询复杂度为Log(N)</p>
<h2 id="一个简单的链表">一个简单的链表</h2>
<pre><code>public class MyLinkedList&lt;T&gt;
{
    public static void Run()
    {
        var linked = new MyLinkedList&lt;string&gt;();

        linked.AddLast("a");
        linked.AddLast("b");
        linked.AddLast("c");
        linked.AddLast("d");


        linked.Add(1, "bc");
        linked.Put(1, "aaaa");
        Console.WriteLine(linked.ToString()) ;
    }
    /// &lt;summary&gt;
    /// 虚拟头尾节点,有两个好处
    /// 1.无论链表是否为空， 两个虚拟节点都存在，避免很多边界值处理的情况。
    /// 2.如果要在尾部插入数据，如果不知道尾节点，那么需要复杂度退化成O(N),因为要从头开始遍历到尾部。
    /// &lt;/summary&gt;
    private Node _head, _tail; 
    public int Count { get; private set; }

    public MyLinkedList()
    {
        _tail = new Node();
        _head = new Node();

        _head.Next = _tail;
        _tail.Prev = _head;
    }

    public void AddLast(T item)
    {
        var prev = _tail.Prev;
        var next = _tail;
        var node = new Node(item);

        node.Next = next;
        node.Prev = prev;

        prev.Next = node;
        next.Prev = node;

        Count++;
    }

    public void AddFirst(T item)
    {
        var prev = _head;
        var next = _head.Next;
        var node=new Node(item);

        node.Prev= prev;
        node.Next= next;

        prev.Next= node;
        next.Prev = node;

        Count++;
    }

    public void Add(int idx,T item)
    {
        var t = Get(idx);
        var next = t.Next;
        var prev = t;

        var node = new Node(item);
        node.Next = next;
        node.Prev = prev;

        prev.Next = node;
        next.Prev = node;

    }

    public void Remove(int idx)
    {
        var t = Get(idx);

        var prev = t.Prev;
        var next = t.Next;

        prev.Next = next;
        next.Prev = next;

        t = null;
        Count--;
    }

    public void Put(int idx,T item)
    {
        var t = Get(idx);
        t.Value= item;
    }

    private Node? Get(int idx)
    {
        var node = _head.Next;
        //这里有个优化空间，可以通过idx在Count的哪个区间。从而决定从head还是从tail开始遍历
        for (int i = 0; i &lt; idx; i++)
        {
            node = node.Next;
        }
        return node;
    }
    

    public override string ToString()
    {
        var sb = new StringBuilder();
        var node = _head.Next;
        while (node != null &amp;&amp; node.Value != null)
        {
            sb.Append($"{node.Value}&lt;-&gt;");
            node = node.Next;
        }
        sb.Append("null");
        return sb.ToString();
    }
    private class Node
    {
        public T? Value { get; set; }
        public Node Next { get; set; }
        public Node Prev { get; set; }

        public Node()
        {
            Value=default(T);
        }
        public Node(T value)
        {
            Value = value;
        }
    }
}
</code></pre>
<h1 id="链表的变种跳表">链表的变种：跳表</h1>
<p>在上面简单的例子中，查询的复杂度为O(N),插入的复杂度为O(1).<br>
主要消耗在查询操作，只能从头结点开始，逐个遍历到目标节点。<br>
所以我们优化的重点就在于优化查询。</p>
<p>上面的例子中，我们使用了<code>虚拟头尾节点</code>来空间换时间，提高插入效率。同样的，我们也可以采用这个思路来提高查询效率</p>
<h2 id="跳表核心原理">跳表核心原理</h2>
<pre><code>index  0  1  2  3  4  5  6  7  8  9
node   a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;g-&gt;h-&gt;i-&gt;j
</code></pre>
<p>此时此刻，你想拿到h的节点，你需要从<code>0开始遍历直到7</code>。<br>
这时候你就想，如果我能提前知道6的位置就好了，这样我就只需要Next就能<code>快速得到h</code></p>
<p>调表就是如此</p>
<pre><code>indexLevel   0-----------------------8-----10
indexLevel   0-----------4-----------8-----10
indexLevel   0-----2-----4-----6-----8-----10
indexLevel   0--1--2--3--4--5--6--7--8--9--10
nodeLevel    a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;g-&gt;h-&gt;i-&gt;j-&gt;k
</code></pre>
<p>调表在原链表的基础上，增加了多层索引，每向上一层，索引减少一半，所以索引的高度是O(log N)</p>
<ol>
<li>首先从最高层索引开始往下搜，索引7在[0,8]区间</li>
<li>从节点0开始，发现7在【4,8】，拿到节点4的地址</li>
<li>从节点4开始，发现7在【6,8】，拿到节点6的地址</li>
<li>从节点6开始，发现7在【6,7】，最终找到节点7</li>
</ol>
<p>在搜索的过程中，会经过O(log N)层索引，所以时间复杂度为O(log N)</p>
<blockquote>
<p>调表实现比较复杂，当新增与删除时，还需考虑索引的动态调整，需要保证尽可能的二分，否则时间复杂度又会退化为O(N)<br>
有点类似自平衡的二叉搜索数，不过相对来说比较简单。</p>
</blockquote>

</div>
<div class="clear"></div>

		<p class="postfoot">
			posted on 
<span id="post-date" data-last-update-days="0.6966884275740741" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-03-03 13:31">2025-03-03 13:30</span>&nbsp;
<a href="https://www.cnblogs.com/lmy5215006">叫我安不理</a>&nbsp;
阅读(<span id="post_view_count">89</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18736066" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18736066);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18736066', targetLink: 'https://www.cnblogs.com/lmy5215006/p/18736066', title: '重生之数据结构与算法----数组&amp;amp;链表' })">举报</a>

		</p>
	