
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/pigke/p/18682640" title="发布于 2025-01-20 23:03">
    <span role="heading" aria-level="2">某Websocket反爬逆向分析+请求加解密+还原html</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        <img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225819884-1602579673.png" alt="某Websocket反爬逆向分析+请求加解密+还原html" class="desc_img">
        JS逆向分析Websocket，请求加解密，二进制消息解析
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="网址">网址</h1>
<p><code>aHR0cHM6Ly93d3cueWR4Zi5nb3YuY24vTmV3cy9zaG93TGlzdC80L3BhZ2VfMS5odG1s</code></p>
<h1 id="前言">前言</h1>
<p>工作中遇到的某websocket反爬，比混淆网站还恶心，看到也有其他人在问这个</p>
<p>之前看到其他大佬也弄过这个websocket反爬，但是只是说了下加解密，个人觉得最重要的还是还原最终的html，所以来分享一下过程</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328950-1343209987.png" alt="" loading="lazy"></p>
<h1 id="目标">目标</h1>
<ul>
<li>过无限debugger</li>
<li><code>session</code>请求加解密</li>
<li><code>websocket</code>通信</li>
<li>消息结构解析还原成<code>html</code></li>
<li>使用Python还原算法</li>
</ul>
<h1 id="分析过程">分析过程</h1>
<h2 id="无限debugger">无限debugger</h2>
<ol>
<li>首先打开F12，刷新页面发现会被断住</li>
<li>右键js文件替换内容</li>
<li>看堆栈往上先随便点几个看看</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328884-1238724679.png" alt="" loading="lazy"></p>
<ol>
<li>可以直接找到通过正则检测代码格式化的检测点，这里是个自执行函数，我们需要把整个函数干掉，然后保存刷新页面</li>
<li>发现还是会被断住，老套路直接看堆栈往上找检测点</li>
</ol>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328680-1645864317.png" alt="" loading="lazy"></p>
<ol>
<li>可以清楚看到定时器在不断检测，直接干掉就行了</li>
<li>刷新页面，到此为止无限debugger就过了，这个站的检测还是很简单的对吧</li>
</ol>
<h2 id="session请求加解密">session请求加解密</h2>
<ul>
<li>XHR</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328408-1857217435.png" alt="" loading="lazy"></p>
<ul>
<li>Payload</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328833-535869976.png" alt="" loading="lazy"></p>
<ul>
<li>Response</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328062-1177149958.png" alt="" loading="lazy"></p>
<h3 id="payload加密">Payload加密</h3>
<p>直接看xhr的堆栈</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328782-1157297182.png" alt="" loading="lazy"></p>
<p>这个比较简单我就不废话了，看截图就行</p>
<p>跟进去函数后可以看到用到了iv，iv生成就在上面一个函数</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328757-1145505101.png" alt="" loading="lazy"></p>
<p>往下继续跟，进入这个解密函数，这个解密函数计算iv的时候也用到这个函数</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328790-1723477875.png" alt="" loading="lazy"></p>
<p>直接跟到下图这个位置可以看到是个AES加密，差不多就结束了，这个是个标准<code>AES-128-CBC</code>，直接引库就行了</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328672-233011253.png" alt="" loading="lazy"></p>
<h3 id="response解密">Response解密</h3>
<p>跟加密算法一致，用同一个key解密就行，这里就不再写具体流程了</p>
<h3 id="python实现">Python实现</h3>
<ul>
<li>AES-128-CBC</li>
</ul>
<p>代码抄了晨哥的 😛</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328428-425664620.png" alt="" loading="lazy"></p>
<ul>
<li>构造请求&amp;加解密</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328451-748410835.png" alt="" loading="lazy"></p>
<ul>
<li>运行结果</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225329020-397993957.png" alt="" loading="lazy"></p>
<h2 id="websocket">Websocket</h2>
<h3 id="wss链接分析">wss链接分析</h3>
<p><code>wss://www.xxxx.cn/1ywuKELSO2ahQuWZ/pr/rSakD15JVxHzfnpXyZpkf4J5HNjv_CSciPJFAMMxKE0%3D/c/ws/zpgffq9z89/a0c20283-d62c-411a-820b-33e42f1c6082</code></p>
<ul>
<li><code>1ywuKELSO2ahQuWZ</code>：固定值</li>
<li><code>rSakD15JVxHzfnpXyZpkf4J5HNjv_CSciPJFAMMxKE0%3D</code>：session返回的token值</li>
<li><code>zpgffq9z89</code>：网站tab_id，与请求时保持一致，随机字符串（可固定）</li>
<li><code>a0c20283-d62c-411a-820b-33e42f1c6082</code>：uuid，可固定</li>
</ul>
<h3 id="python连接websocket">Python连接Websocket</h3>
<ul>
<li>第三方库：<code>websocket-client</code>、<code>msgpack</code></li>
<li>代码</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225329007-1814397699.png" alt="" loading="lazy"></p>
<ul>
<li>结果</li>
</ul>
<p>这里返回的结果通过msgpack进行解包了，这里就不再赘述了，有兴趣的可以看我晨哥的分析文章讲到了这个<a href="https://mp.weixin.qq.com/s/o5UCJFhBg-4JFdS0aEwDuw" target="_blank" rel="noopener nofollow">https://mp.weixin.qq.com/s/o5UCJFhBg-4JFdS0aEwDuw</a></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328858-267613149.png" alt="" loading="lazy"></p>
<h2 id="消息结构解析">消息结构解析</h2>
<p>重点来了，这个网站最难的不是<code>session</code>的加解密和<code>websocket</code>连接，而是websocket收发的消息，页面的内容均是通过websocket返回的<code>特殊指令</code>渲染出来的，因此我们从websocket中取想要的数据可能会比较复杂，并且不能通用，我们这里会讲到如何将收到的指令还原成原本的<code>html</code>，从而通过<code>pyquery</code>或者<code>bs4</code>等html解析库来提取数据</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328815-490016413.png" alt="" loading="lazy"></p>
<h3 id="定位websocket接收消息函数">定位websocket接收消息函数</h3>
<p>找到ws连接请求，进入第一个调用堆栈</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328731-917107959.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328681-1947736154.png" alt="" loading="lazy"></p>
<p>在连接下面找到消息回调函数，直接下断点后跟进去</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328818-1702716390.png" alt="" loading="lazy"></p>
<p>这样我们就找到了ws消息回调函数了</p>
<h3 id="分析接收到的数据">分析接收到的数据</h3>
<p>单步跟着走一遍</p>
<p>可以直接把指令表拿出来，这样比较清晰，也可以根据对应名称来猜指令的作用</p>
<pre><code class="language-jsx">CommandCodes = {
    "TAB_OPS": 0,
    "DOM_EVENT": 4,
    "DOM_METHOD": 5,
    "RESET_DOM": 6,
    "ADD_DOC_TYPE": 7,
    "ADD_HTML_ELEMENT": 8,
    "ADD_SVG_ELEMENT": 9,
    "ADD_NS_ELEMENT": 10,
    "MOVE_ELEMENT": 11,
    "SHUFFLE_CHILDREN": 12,
    "EDIT_ELEMENT": 13,
    "DELETE_ELEMENT": 14,
    "ADD_STYLE": 15,
    "ADD_TEXT": 16,
    "MODIFY_TEXT": 17,
    "MODIFY_PROPERTY": 18,
    "MODIFY_ATTRIBUTES": 19,
    "SET_SELECTIONS": 20,
    "INSERT_RULE": 21,
    "DELETE_RULE": 22,
    "DISABLED_STYLE": 24,
    "SET_CANVAS_DATA": 23,
    "REPLACE_SYNC": 25,
    "WEBRTC": 30,
    "NAVIGATE": 31,
    "SYNC": 32,
    "SYNC_COOKIE": 34,
    "FILE": 35,
    "TAB_ACTIVE": 42,
    "NATIVE_METHOD": 44,
    "MODIFY_DOC_TYPE": 47,
    "CHANGE_BLOCK": 48,
    "RELOAD": 49,
    "SYNC_ALL_COOKIE": 50,
    "SYNC_WRITE_COOKIE": 51,
    "MEDIA_STATE": 52,
    "DOM_READY": 53,
    "AUGMENT_CSS": 54,
    "MULTI_CMD": 55,
    "REDIRECT_REQUEST": 56,
    "TEXTAREA_RESIZE": 57,
    "SIMPLE_HTML": 58,
    "RENDER_STATE": 59,
    "SYNC_CONFIG_TO_CLIENT_WIC": 60,
    "SYNC_CONFIG_TO_CLIENT_AIC": 61,
    "SYNC_CONFIG_TO_CLIENT_EIC": 62,
    "FRAME_PUSH_STATE": 63
}
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328723-999119980.png" alt="" loading="lazy"></p>
<p>断到一个53指令码，根据码表来看应该是dom相关的指令，继续单步跟</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328843-774395556.png" alt="" loading="lazy"></p>
<p>这里将数据传送到其他回调函数了，继续跟进去</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328655-206532379.png" alt="" loading="lazy"></p>
<p>大概跟了几个函数就跟到这里了，这里比较重要，我们慢慢看</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328867-1504907438.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328644-1221633993.png" alt="" loading="lazy"></p>
<p>这个应该是将数组形式的消息转换为对象形式，这个消息太短了，看不出效果，我们多接收几个消息看一下</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328639-2099931066.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328639-410971651.png" alt="" loading="lazy"></p>
<p>这个55指令码对应的指令名是<code>"MULTI_CMD": 55</code> ，应该是多条指令的集合，我们还需要对content的多条指令进行转换，才能拿到最终的对象</p>
<p>单步跟了一下后发现会进入到另外一个接收函数</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328680-2128877361.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328946-1436915738.png" alt="" loading="lazy"></p>
<p>这里就是根据不同指令码来执行不同操作的地方了</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328666-622208.png" alt="" loading="lazy"></p>
<p>可以看到这个<code>55</code>指令码实际上会进行递归执行指令</p>
<p>后面会根据不同指令码来走不同的分支，我这里就直接给结果吧，<code>"ADD_DOC_TYPE": 7</code></p>
<p>这个指令操作会给在html中添加一个dom元素，它这里实际上是将这个指令都放到一个指令队列里面，然后再根据指令队列循环操作dom树来渲染页面元素</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328745-377009571.png" alt="" loading="lazy"></p>
<h3 id="将websocket消息转换为对象">将websocket消息转换为对象</h3>
<p>单步跟进之前那个转换指令的函数</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328631-758019779.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328533-1465112590.png" alt="" loading="lazy"></p>
<p>这里会根据e的指令码映射拿到对应的指令处理器，再执行转换命令</p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328812-213908267.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328807-178913703.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328736-1585778211.png" alt="" loading="lazy"></p>
<p>不同的指令对应不同的转换器，所以这里如果要还原得一个一个抠下来才行</p>
<h3 id="使用python还原指令解析算法">使用Python还原指令解析算法</h3>
<p>基本上只要对照js来还原就行了</p>
<ul>
<li>指令转换器</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328649-1235492207.png" alt="" loading="lazy"></p>
<ul>
<li>消息解析</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225329031-202003662.png" alt="" loading="lazy"></p>
<ul>
<li>运行结果</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328647-946330592.png" alt="" loading="lazy"></p>
<h3 id="使用pyquery还原html">使用Pyquery还原HTML</h3>
<p>我们需要将上一步转换后的指令队列转换为HTML代码</p>
<ul>
<li>转换代码</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328697-2024206660.png" alt="" loading="lazy"></p>
<ul>
<li>运行结果</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328783-458325568.png" alt="" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328616-443625653.png" alt="" loading="lazy"></p>
<ul>
<li>列表页</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328761-1222040126.png" alt="" loading="lazy"></p>
<ul>
<li>详情页</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250120225328606-1465975295.png" alt="" loading="lazy"></p>
<p>有了html代码后就可以用xpath大法来拿内容了</p>
<h1 id="微信公众号">微信公众号</h1>
<p>公众号更新比较快，欢迎关注！<br>
<img src="https://img2024.cnblogs.com/blog/2281573/202501/2281573-20250104230616341-1563051605.png" alt="image" loading="lazy"></p>
<h1 id="完整源代码">完整源代码</h1>
<p>欢迎各位大佬一起完善，有问题可以一起讨论，希望有更好的方案能带俺一手😁<br>
<a href="https://github.com/Meteo-Pig/CommandSpider" target="_blank" rel="noopener nofollow">https://github.com/Meteo-Pig/CommandSpider</a></p>
<blockquote>
<p>码字不易，动起你的发财的小手点个赞吧~~</p>
</blockquote>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03861100227662037" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-20 23:22">2025-01-20 23:03</span>&nbsp;
<a href="https://www.cnblogs.com/pigke">流星Studio</a>&nbsp;
阅读(<span id="post_view_count">10</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18682640" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18682640);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18682640', targetLink: 'https://www.cnblogs.com/pigke/p/18682640', title: '某Websocket反爬逆向分析+请求加解密+还原html' })">举报</a>
</div>
        