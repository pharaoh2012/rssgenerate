
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/pretttyboy/p/18830437" title="发布于 2025-04-17 10:56">
    <span role="heading" aria-level="2">即时通信SSE和WebSocket对比</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        即时通信SSE和WebSocket对比
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Server-Sent Events (SSE) 和 WebSocket 都是用于实现服务器与客户端实时通信的技术，但它们在设计目标、协议特性和适用场景上有显著区别。以下是两者的详细对比：</p>
<hr>
<h3 id="一核心区别总结"><strong>一、核心区别总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>SSE (Server-Sent Events)</strong></th>
<th><strong>WebSocket</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>通信方向</strong></td>
<td>单向（服务器 → 客户端）</td>
<td>全双工（服务器 ↔ 客户端）</td>
</tr>
<tr>
<td><strong>协议基础</strong></td>
<td>基于HTTP</td>
<td>独立协议（<code>ws://</code> 或 <code>wss://</code>）</td>
</tr>
<tr>
<td><strong>数据格式</strong></td>
<td>纯文本（事件流格式）</td>
<td>二进制或文本</td>
</tr>
<tr>
<td><strong>自动重连</strong></td>
<td>内置支持</td>
<td>需手动实现</td>
</tr>
<tr>
<td><strong>浏览器兼容性</strong></td>
<td>除IE外主流浏览器支持</td>
<td>所有现代浏览器支持</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>服务器向客户端推送实时数据（如股票行情、新闻）</td>
<td>双向交互场景（如聊天、游戏、协同编辑）</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="二技术细节对比"><strong>二、技术细节对比</strong></h3>
<h4 id="1-连接建立">1. <strong>连接建立</strong></h4>
<ul>
<li>
<p><strong>SSE</strong>：</p>
<pre><code class="language-javascript">// 客户端代码
const eventSource = new EventSource("/sse-endpoint");
eventSource.onmessage = (e) =&gt; console.log(e.data);
</code></pre>
<ul>
<li>使用标准HTTP请求，头部包含：<pre><code>Accept: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>WebSocket</strong>：</p>
<pre><code class="language-javascript">// 客户端代码
const socket = new WebSocket("ws://example.com/ws");
socket.onmessage = (e) =&gt; console.log(e.data);
</code></pre>
<ul>
<li>通过HTTP Upgrade切换协议：<pre><code>GET /ws HTTP/1.1
Upgrade: websocket
Connection: Upgrade
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="2-数据传输">2. <strong>数据传输</strong></h4>
<ul>
<li>
<p><strong>SSE</strong>：</p>
<ul>
<li>服务器响应格式：<pre><code>event: priceUpdate
data: {"symbol":"AAPL","price":182.73}
\n\n
</code></pre>
</li>
<li>支持事件类型（<code>event</code>字段）和重试时间（<code>retry</code>字段）</li>
</ul>
</li>
<li>
<p><strong>WebSocket</strong>：</p>
<ul>
<li>二进制或文本帧自由传输：<pre><code class="language-javascript">// 发送文本
socket.send("Hello Server!");
// 发送二进制数据（如文件）
socket.send(arrayBuffer);
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-连接维护">3. <strong>连接维护</strong></h4>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>SSE</strong></th>
<th><strong>WebSocket</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>心跳检测</td>
<td>依赖HTTP长连接</td>
<td>需手动实现Ping/Pong帧</td>
</tr>
<tr>
<td>断线重连</td>
<td>自动（客户端默认3秒重试）</td>
<td>需手动重连</td>
</tr>
<tr>
<td>连接状态管理</td>
<td>简单（HTTP状态码控制）</td>
<td>复杂（需处理多种帧类型）</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="三选择建议"><strong>三、选择建议</strong></h3>
<h4 id="使用sse的场景-"><strong>使用SSE的场景</strong> ✅</h4>
<ol>
<li>
<p><strong>服务器单向推送</strong></p>
<ul>
<li>实时监控（服务器指标、日志流）</li>
<li>新闻/股票行情推送</li>
<li>长轮询替代方案</li>
</ul>
</li>
<li>
<p><strong>需要简单实现</strong></p>
<ul>
<li>无需额外协议，复用HTTP基础设施</li>
<li>自动重连和事件ID支持</li>
</ul>
</li>
<li>
<p><strong>文本数据为主</strong></p>
<ul>
<li>结构化数据（JSON）传输</li>
</ul>
</li>
</ol>
<h4 id="使用websocket的场景-"><strong>使用WebSocket的场景</strong> ✅</h4>
<ol>
<li>
<p><strong>双向交互需求</strong></p>
<ul>
<li>在线聊天室</li>
<li>多人在线游戏</li>
<li>实时协作编辑</li>
</ul>
</li>
<li>
<p><strong>低延迟通信</strong></p>
<ul>
<li>高频双向数据交换（如视频会议信令）</li>
</ul>
</li>
<li>
<p><strong>二进制数据传输</strong></p>
<ul>
<li>文件传输、音视频流</li>
</ul>
</li>
</ol>
<hr>
<h3 id="四代码示例对比"><strong>四、代码示例对比</strong></h3>
<h4 id="sse实现spring-boot"><strong>SSE实现（Spring Boot）</strong></h4>
<pre><code class="language-java">@GetMapping("/sse")
public SseEmitter streamData() {
    SseEmitter emitter = new SseEmitter();
    executor.execute(() -&gt; {
        try {
            for (int i = 0; i &lt; 10; i++) {
                emitter.send(
                    SseEmitter.event()
                        .name("update")
                        .data("Event #" + i)
                );
                Thread.sleep(1000);
            }
            emitter.complete();
        } catch (Exception e) {
            emitter.completeWithError(e);
        }
    });
    return emitter;
}
</code></pre>
<h4 id="websocket实现spring-boot"><strong>WebSocket实现（Spring Boot）</strong></h4>
<pre><code class="language-java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/ws")
                .setAllowedOrigins("*");
    }

    @Bean
    public WebSocketHandler myHandler() {
        return new TextWebSocketHandler() {
            @Override
            protected void handleTextMessage(WebSocketSession session, TextMessage message) {
                // 处理客户端消息
                session.sendMessage(new TextMessage("ECHO: " + message.getPayload()));
            }
        };
    }
}
</code></pre>
<hr>
<h3 id="五性能与资源消耗"><strong>五、性能与资源消耗</strong></h3>
<table>
<thead>
<tr>
<th><strong>指标</strong></th>
<th><strong>SSE</strong></th>
<th><strong>WebSocket</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>连接开销</td>
<td>较高（HTTP头重复传输）</td>
<td>低（连接后无额外开销）</td>
</tr>
<tr>
<td>服务器内存占用</td>
<td>每个连接独立线程/连接</td>
<td>更高效的连接管理</td>
</tr>
<tr>
<td>适合连接数</td>
<td>适合中低并发（数千连接）</td>
<td>适合高并发（数万连接）</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="六兼容性解决方案"><strong>六、兼容性解决方案</strong></h3>
<p>当需要兼容老旧浏览器时：</p>
<ul>
<li><strong>SSE降级方案</strong>：使用长轮询（Long Polling）</li>
<li><strong>WebSocket降级方案</strong>：使用SockJS库<pre><code class="language-javascript">const sock = new SockJS('/ws-endpoint');
sock.onmessage = (e) =&gt; console.log(e.data);
</code></pre>
</li>
</ul>
<hr>
<h3 id="总结"><strong>总结</strong></h3>
<ul>
<li><strong>SSE</strong>是<strong>简单、单向</strong>实时通信的理想选择，尤其适合已有HTTP架构的项目。</li>
<li><strong>WebSocket</strong>在需要<strong>双向、低延迟</strong>交互时不可或缺，但实现复杂度更高。</li>
</ul>
<p>根据你的应用场景选择：</p>
<ul>
<li><strong>只需接收服务器更新？</strong> → 用SSE</li>
<li><strong>需要双向对话？</strong> → 用WebSocket</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.14297928628125" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-17 10:57">2025-04-17 10:56</span>&nbsp;
<a href="https://www.cnblogs.com/pretttyboy">想念泡凤爪的味道</a>&nbsp;
阅读(<span id="post_view_count">116</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18830437);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18830437', targetLink: 'https://www.cnblogs.com/pretttyboy/p/18830437', title: '即时通信SSE和WebSocket对比' })">举报</a>
</div>
        