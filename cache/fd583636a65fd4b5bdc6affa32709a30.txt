
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dennyLee2025/p/18634330" title="发布于 2024-12-26 22:31">
    <span role="heading" aria-level="2">掌握设计模式--装饰模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="装饰模式decorator-pattern">装饰模式（Decorator Pattern）</h2>
<p><strong>装饰模式</strong>是一种结构型设计模式，旨在在不改变原有对象结构的情况下动态地为对象添加功能。通过将对象封装到一系列装饰器类中，可以以灵活和透明的方式扩展功能。</p>
<p>如果要扩展功能，装饰模式提供了<code>比继承</code>更有弹性的替代方案，装饰模式强调的是功能的扩展和灵活<code>组合</code>。</p>
<p><strong>装饰模式强调</strong>的是<code>扩展对象的功能</code>及<code>扩展功能的组合</code>。比如，对象A，需要扩展X、Y的功能，这些扩展功能按不同的顺序组合可以实现不同的效果，先执行X再执行Y扩展功能或者先执行Y再执行X扩展功能。而继承实现的只是单一的顺序扩展功能，并且继承是单一的。看后面的例子就很好理解了。</p>
<h2 id="结构">结构</h2>
<p>通常包含<code>一个核心对象</code>和<code>若干装饰对象</code>，这些装饰对象通过引用同一接口或抽象类实现功能的叠加。</p>
<p>装饰模式包含以下主要角色：</p>
<ol>
<li>
<p><strong>Component（组件接口）</strong><br>
定义核心对象的公共接口，允许动态添加行为。</p>
</li>
<li>
<p><strong>ConcreteComponent（具体组件）</strong><br>
具体实现了 <code>Component</code> 接口的类，表示被装饰的核心对象。</p>
</li>
<li>
<p><strong>Decorator（装饰器抽象类）</strong><br>
实现 <code>Component</code> 接口，同时持有一个 <code>Component</code> 的引用，表示对该对象的包装。</p>
</li>
<li>
<p><strong>ConcreteDecorator（具体装饰器）</strong><br>
在装饰器抽象类的基础上，添加具体的功能。</p>
</li>
</ol>
<h2 id="代码示例">代码示例</h2>
<p>实现对<code>Socket</code>报文的<code>多层加密</code>，加密顺序可<code>随意组合</code>。示例中使用到了国密SM4加密和Base64编码。Socket 报文可以先加密再编码，也可以先编码在加密，跟根据不同组合来实现不同的增强。</p>
<h3 id="类图">类图</h3>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202412/1209017-20241226222951313-171300243.png" alt="image" loading="lazy"></p>
<h3 id="定义核心接口">定义核心接口</h3>
<pre><code class="language-java">public interface SocketStream {
    void writeData(String data) throws IOException;
    String readData() throws IOException;
    void close() throws IOException;
}
</code></pre>
<h3 id="被装饰的核心对象">被装饰的核心对象</h3>
<pre><code class="language-java">public class SimpleSocketStream implements SocketStream {
    private Socket socket;
    private OutputStream outputStream;
    private InputStream inputStream;
    public SimpleSocketStream(Socket socket){
        this.socket = socket;
        try {
            this.outputStream = socket.getOutputStream();
            this.inputStream = socket.getInputStream();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }


    @Override
    public void writeData(String data) throws IOException {
        outputStream.write(data.getBytes(StandardCharsets.UTF_8));
        outputStream.flush();
        socket.shutdownOutput();
    }

    @Override
    public String readData() throws IOException {
        // 读取客户端请求并解密
        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
        String message = reader.readLine();
        return message;
    }

    @Override
    public void close() throws IOException {
        if(inputStream!=null)
            inputStream.close();
        if(outputStream!=null)
            outputStream.close();
        if(socket!=null)
            socket.close();
    }
}
</code></pre>
<h3 id="抽象装饰器">抽象装饰器</h3>
<pre><code class="language-java">public abstract class SocketStreamDecorator implements SocketStream{
    private SocketStream socketStream;

    public SocketStreamDecorator(SocketStream socketStream){
        this.socketStream = socketStream;
    }

    @Override
    public void writeData(String data) throws IOException {
        socketStream.writeData(data);
    }

    @Override
    public String readData() throws IOException {
        return socketStream.readData();
    }

    @Override
    public void close() throws IOException {
        socketStream.close();
    }
}
</code></pre>
<h3 id="具体装饰器1--sm4-加密处理">具体装饰器1--SM4 加密处理</h3>
<pre><code class="language-java">public class SM4CipherSocketStreamDecorator extends SocketStreamDecorator{

    public SM4CipherSocketStreamDecorator(SocketStream socketStream) {
        super(socketStream);
    }

    @Override
    public void writeData(String data) throws IOException {
        // 加密
        String sm4Encrypt = SM4EncryptUtil.sm4Encrypt(data);
        System.out.println("--SM4加密数据："+sm4Encrypt);
        super.writeData(sm4Encrypt);
    }

    @Override
    public String readData() throws IOException {
        String readData = super.readData();
        // 解密
        System.out.println("--SM4解密前数据："+readData);
        String sm4Decrypt = SM4EncryptUtil.sm4Decrypt(readData);
        return sm4Decrypt;
    }
}
</code></pre>
<p><strong>工具类</strong></p>
<pre><code class="language-java">public class SM4EncryptUtil {
    // 秘钥
    private static final String key = "1234567812345678";

    static {
        // 添加安全提供者（SM2，SM3，SM4等加密算法，CBC、CFB等加密模式，PKCS7Padding等填充方式，不在Java标准库中，由BouncyCastleProvider实现）
        Security.addProvider(new BouncyCastleProvider());
    }

    /**
     * 输入：待加密的字符串，16或24或32位字符串密码
     * 输出：16进制字符串或Base64编码的字符串密文（常用）
     */
    public static String sm4Encrypt(String encrypt) {
        String cipherString = null;
        try {
            // 指定加密算法
            String algorithm = "SM4";
            // 创建密钥规范
            SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), algorithm);
            // 获取Cipher对象实例（BC中SM4默认使用ECB模式和PKCS5Padding填充方式，因此下列模式和填充方式无需指定）
            Cipher cipher = Cipher.getInstance(algorithm + "/ECB/PKCS5Padding");
            // 初始化Cipher为加密模式
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
            // 获取加密byte数组
            byte[] cipherBytes = cipher.doFinal(encrypt.getBytes(StandardCharsets.UTF_8));
            // 输出为Base64编码
            cipherString = Base64.getEncoder().encodeToString(cipherBytes);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return cipherString;
    }

    /**
     * 输入：密文，16或24或32位字符串密码
     * 输出：明文
     */
    public static String sm4Decrypt(String cipherString) {
        String plainString = null;
        try {
            // 指定加密算法
            String algorithm = "SM4";
            // 创建密钥规范
            SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), algorithm);
            // 获取Cipher对象实例（BC中SM4默认使用ECB模式和PKCS5Padding填充方式，因此下列模式和填充方式无需指定）
            Cipher cipher = Cipher.getInstance(algorithm + "/ECB/PKCS5Padding");
            // 初始化Cipher为解密模式
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
            // 获取加密byte数组
            byte[] cipherBytes = cipher.doFinal(Base64.getDecoder().decode(cipherString));
            // 输出为字符串
            plainString = new String(cipherBytes);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return plainString;
    }

}
</code></pre>
<h3 id="具体装饰器2--base64-编码处理">具体装饰器2--Base64 编码处理</h3>
<pre><code class="language-java">public class Base64SocketStreamDecorator extends SocketStreamDecorator{

    public Base64SocketStreamDecorator(SocketStream socketStream) {
        super(socketStream);
    }

    @Override
    public void writeData(String data) throws IOException {
        String encode = this.encode(data);
        System.out.println("--base64编码后的数据：" + encode);
        super.writeData(encode);
    }

    @Override
    public String readData() throws IOException {
        String readData = super.readData();
        System.out.println("--base64解密前的数据：" + readData);
        String decode = this.decode(readData);
        return decode;
    }
    /**
     * base64编码
     */
    public String encode(String str) {
        if (str == null || str.isEmpty()) {
            return "";
        }
        // String 转 byte[]
        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);
        // 编码（base64字符串）
        return Base64.getEncoder().encodeToString(bytes);
    }

    /**
     * base64解码
     */
    public String decode(String base64Str) {
        if (base64Str == null || base64Str.isEmpty()) {
            return "";
        }
        // 编码
        byte[] base64Bytes = Base64.getDecoder().decode(base64Str);
        // byte[] 转 String（解码后的字符串）
        return new String(base64Bytes, StandardCharsets.UTF_8);
    }

}
</code></pre>
<h3 id="测试代码">测试代码</h3>
<p>测试Socket 服务端代码</p>
<pre><code class="language-java">public class SM4SocketServer {

    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println("Server started...");

        while (true) {
            try (Socket socket = serverSocket.accept()) {
                System.out.println("Client connected...\n");

                // 加密数据流
                SocketStream socketStreamDecorator = new Base64SocketStreamDecorator(
                                                        new SM4CipherSocketStreamDecorator(
                                                          new SimpleSocketStream(socket)));
                // 读取客户端请求并解密
                String message = socketStreamDecorator.readData();
                System.out.println("服务端读取数据: " + message);

                // 处理请求并加密响应
                String response = "我来自服务端！";
                System.out.println("服务端发送数据: " + response);
                socketStreamDecorator.writeData(response);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p>测试Socket 客户端代码</p>
<pre><code class="language-java">public class SM4SocketClient {

    public static void main(String[] args) throws IOException {
        // 连接到服务器
        try (Socket socket = new Socket("localhost", 9999)) {
            System.out.println("Connected to server...\n");

            // 读取服务器的响应并解密
            SocketStream socketStreamDecorator = new Base64SocketStreamDecorator(
                                                    new SM4CipherSocketStreamDecorator(
                                                      new SimpleSocketStream(socket)));
            // 要发送的消息
            String message = "我来自客户端！";
            System.out.println("客户端发送数据: " + message);

            // 使用加密流将消息发送到服务器
            socketStreamDecorator.writeData(message);

            // 读取客户端请求并解密
            String readData = socketStreamDecorator.readData();
            System.out.println("客户端读取数据: " + readData);
            socketStreamDecorator.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="测试结果分析">测试结果分析</h3>
<p>先启动Socket服务，再发起Socket请求。</p>
<p>客户端输出结果</p>
<blockquote>
<p>Connected to server...</p>
<p>客户端发送数据: 我来自客户端！</p>
<p>--base64编码后的数据：5oiR5p2l6Ieq5a6i5oi356uv77yB</p>
<p>--SM4加密数据：anTSZv18wcQOxQtA82w9ap2j8DjagsX9QqRVjzFCjWU=</p>
<p>--SM4解密前数据：5azwyKP7MB6jSyG3eDlJmfOYx5y+woud2WgE2Jjf5lA=</p>
<p>--base64解密前的数据：5oiR5p2l6Ieq5pyN5Yqh56uv77yB</p>
<p>客户端读取数据: 我来自服务端！</p>
</blockquote>
<p>服务端输出结果</p>
<blockquote>
<p>Server started...</p>
<p>Client connected...</p>
<p>--SM4解密前数据：anTSZv18wcQOxQtA82w9ap2j8DjagsX9QqRVjzFCjWU=</p>
<p>--base64解密前的数据：5oiR5p2l6Ieq5a6i5oi356uv77yB</p>
<p>服务端读取数据: 我来自客户端！</p>
<p>服务端发送数据: 我来自服务端！</p>
<p>--base64编码后的数据：5oiR5p2l6Ieq5pyN5Yqh56uv77yB</p>
<p>--SM4加密数据：5azwyKP7MB6jSyG3eDlJmfOYx5y+woud2WgE2Jjf5lA=</p>
</blockquote>
<p>这行代码new的先后顺序决定代码执行的先后顺序：<code>new Base64SocketStreamDecorator(new SM4CipherSocketStreamDecorator(new SimpleSocketStream(socket)));</code> ，所以文中的案例测试执行顺序如下：</p>
<p><strong>数据流方向</strong></p>
<ul>
<li><strong>写入数据时</strong>：外层到内层逐步加工数据。
<ul>
<li>数据先经过 <code>Base64</code> 编码，再经过 <code>SM4</code> 加密，最后写入 <code>SimpleSocketStream</code>。</li>
</ul>
</li>
<li><strong>读取数据时</strong>：内层到外层逐步还原数据。
<ul>
<li>数据从 <code>SimpleSocketStream</code> 读取后，先解密（SM4），再解码（Base64）。</li>
</ul>
</li>
</ul>
<p><strong>代码层面的调用顺序</strong></p>
<ul>
<li><strong>构造阶段</strong>：
<ul>
<li><code>SimpleSocketStream(socket)</code> → <code>SM4CipherSocketStreamDecorator</code> → <code>Base64SocketStreamDecorator</code>。</li>
</ul>
</li>
<li><strong>方法调用阶段</strong>（如 <code>write(data)</code> 或 <code>read()</code>）：
<ul>
<li>调用 <code>Base64SocketStreamDecorator.write(data)</code>。</li>
<li>该方法内部会调用 <code>SM4CipherSocketStreamDecorator.write(data)</code>。</li>
<li>最终调用 <code>SimpleSocketStream.write(data)</code> 执行实际的数据写入。</li>
</ul>
</li>
</ul>
<h3 id="调整组合顺序测试">调整组合顺序测试</h3>
<p>如果哪天有需求要改为先执行SM4加密，再执行Base64编码，则代码只需要修改为<code>new SM4CipherSocketStreamDecorator(new Base64SocketStreamDecorator(new SimpleSocketStream(socket)));</code></p>
<p>测试结果变为：</p>
<p>客户端输出结果</p>
<blockquote>
<p>客户端发送数据: 我来自客户端！</p>
<p>--SM4加密数据：YoNCZhEm1shIjPWO5vyhsFRWq+XUdHPggFiE325GCKc=</p>
<p>--base64编码后的数据：WW9OQ1poRW0xc2hJalBXTzV2eWhzRlJXcStYVWRIUGdnRmlFMzI1R0NLYz0=</p>
<p>--base64解密前的数据：OUJTQ0ZLUVFIa2dxSGs0WTd2enB1RlJXcStYVWRIUGdnRmlFMzI1R0NLYz0=</p>
<p>--SM4解密前数据：9BSCFKQQHkgqHk4Y7vzpuFRWq+XUdHPggFiE325GCKc=</p>
<p>客户端读取数据: 我来自服务端！</p>
</blockquote>
<p>服务端输出结果变为</p>
<blockquote>
<p>--base64解密前的数据：WW9OQ1poRW0xc2hJalBXTzV2eWhzRlJXcStYVWRIUGdnRmlFMzI1R0NLYz0=</p>
<p>--SM4解密前数据：YoNCZhEm1shIjPWO5vyhsFRWq+XUdHPggFiE325GCKc=</p>
<p>服务端读取数据: 我来自客户端！</p>
<p>服务端发送数据: 我来自服务端！</p>
<p>--SM4加密数据：9BSCFKQQHkgqHk4Y7vzpuFRWq+XUdHPggFiE325GCKc=</p>
<p>--base64编码后的数据：OUJTQ0ZLUVFIa2dxSGs0WTd2enB1RlJXcStYVWRIUGdnRmlFMzI1R0NLYz0=</p>
</blockquote>
<h2 id="装饰模式的应用">装饰模式的应用</h2>
<p>Java标准库中的装饰模式之一：<strong>IO流体系</strong></p>
<p>示例代码</p>
<pre><code class="language-java">BufferedReader bufferedReader = new BufferedReader(
                                          new InputStreamReader(
                                            new FileInputStream(
                                              new File("test.txt"))));
</code></pre>
<p><strong>逐步增强功能</strong>：IO流的增强组合有顺序要求</p>
<ul>
<li>每一层包装器都增加了功能：
<ul>
<li><code>File</code>：创建一个表示文件的对象 <code>test.txt</code>；</li>
<li><code>FileInputStream</code>：从文件中读取字节；</li>
<li><code>InputStreamReader</code>：将字节流转换为字符流；</li>
<li><code>BufferedReader</code>：提供字符缓冲功能，支持高效读取和按行读取。</li>
</ul>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>装饰模式是一种灵活的结构型模式，允许我们在不修改现有类的情况下，动态地添加功能。它尤其适合于功能可以按需组合叠加、扩展的场景，但需要权衡复杂性与性能开销。</p>
<p><img src="https://img2024.cnblogs.com/blog/1209017/202412/1209017-20241226223007703-965492480.gif" alt="image" loading="lazy"></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485977&amp;idx=1&amp;sn=1fcbbbe778bc863c176ba1ed3088f43f&amp;chksm=ec62ca84db154392e0f7ea45ce4f332653578bb3b59dcff9bbc35a5cfba07fbbc009be57651d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">什么是设计模式？</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486033&amp;idx=1&amp;sn=9c2d6e06e9146e19fa6c8f2d20aaf40a&amp;chksm=ec62caccdb1543da80271cd2e558127d9880d1f5b8d5ba9d8af29c67f42e8fa9d11524212b2e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">单例模式及其思想</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486104&amp;idx=1&amp;sn=9bc3a4f1046186e36fd8c9cdfae41e1e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">设计模式--原型模式及其编程思想</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486123&amp;idx=1&amp;sn=c67702624f1a2c981cee5982de78fbf9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">掌握设计模式之生成器模式</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486132&amp;idx=1&amp;sn=4dde3fe1150bb631ef4f192aef92c8e1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">掌握设计模式之简单工厂模式</a></p>
<p><a href="https://mp.weixin.qq.com/s/aprejSsOC7EP5ZC3r7QVFg" target="_blank" rel="noopener nofollow">掌握设计模式之工厂方法模式</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247486066&amp;idx=1&amp;sn=e8c7423105ddd0562f50892010941efc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">超实用的SpringAOP实战之日志记录</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485873&amp;idx=1&amp;sn=08b58de61c716e5c57ff2fddb947f0d8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">2023年下半年软考考试重磅消息</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485909&amp;idx=1&amp;sn=e20f3b7b413310ca78f90c13305972ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">通过软考后却领取不到实体证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485802&amp;idx=1&amp;sn=863cf239124b98d39ec551b6cb67845c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">计算机算法设计与分析（第5版）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485015&amp;idx=1&amp;sn=862bc2b379726b89cdb396ec0d325cc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">Java全栈学习路线、学习资源和面试题一条龙</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485956&amp;idx=1&amp;sn=57407d9f7921254ba19ed70fa3bd6a2d&amp;chksm=ec62ca99db15438f13f2cf96d17a3e282028fa7960af56126caec68fb6eafd46d6e04a10ad0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考证书=职称证书？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDM5NDM1NA==&amp;mid=2247485837&amp;idx=1&amp;sn=b9b17dfd252882468b8eea31012df6fc&amp;scene=21#wechat_redirect" target="_blank" rel="noopener nofollow">软考中级--软件设计师毫无保留的备考分享</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.07633073251041667" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2024-12-26 22:31">2024-12-26 22:31</span>&nbsp;
<a href="https://www.cnblogs.com/dennyLee2025">渊渟岳</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18634330" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18634330);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18634330', targetLink: 'https://www.cnblogs.com/dennyLee2025/p/18634330', title: '掌握设计模式--装饰模式' })">举报</a>
</div>
        