
        <div class="postTitle">
            <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/mysticbinary/p/18684461" title="发布于 2025-04-28 16:43">
    <span role="heading" aria-level="2">什么是流密码？</span>
    

</a>

        </div>
        <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#流密码的定义" rel="noopener nofollow">流密码的定义</a></li><li><a href="#流密码的原理" rel="noopener nofollow">流密码的原理</a></li><li><a href="#为什么需要一次一密" rel="noopener nofollow">为什么需要一次一密？</a></li><li><a href="#流密码如何防止恢复密钥流" rel="noopener nofollow">流密码如何防止恢复密钥流？</a></li><li><a href="#rc4算法的简介" rel="noopener nofollow">RC4算法的简介</a><ul><li><a href="#s盒是什么" rel="noopener nofollow"><strong>S盒是什么？</strong></a></li><li><a href="#取模介绍" rel="noopener nofollow"><strong>取模介绍</strong></a></li><li><a href="#加密解密" rel="noopener nofollow"><strong>加密、解密</strong></a></li><li><a href="#复用库的rc4用法" rel="noopener nofollow"><strong>复用库的RC4用法</strong></a></li><li><a href="#总结" rel="noopener nofollow"><strong>总结</strong></a></li></ul></li><li><a href="#reference" rel="noopener nofollow">Reference</a></li></ul></div><p></p>
<hr>
<h1 id="流密码的定义">流密码的定义</h1>
<p>流密码是一种对称密钥加密算法，它将明文消息按字符或比特逐位进行加密。加密方式基于异或的加密算法。</p>
<h1 id="流密码的原理">流密码的原理</h1>
<p>首先，通信双方需要协商并确定一个共享的密钥。这个密钥是保密的，只有通信双方知道。同时，可能还会选择一个初始化向量，它通常是公开的，但要保证每次加密时使用的初始化向量不同，以增加密码的安全性。</p>
<p>将明文消息与密钥流进行逐位的异或运算，得到密文。由于密钥流是伪随机的，且与明文消息长度相同，所以对于每一位明文，加密时都使用了不同的密钥流位，从而增加了密码的安全性。</p>
<p><img src="https://img2024.cnblogs.com/blog/1552062/202504/1552062-20250424180215910-389445293.png" alt="image" loading="lazy"></p>
<p>将明文消息逐位与生成的密钥流进行异或运算。例如，对于明文比特流P = p1p2p3...pn和密钥流K = k1k2k3...kn，密文C = c1c2c3...cn，其中ci = pi ⊕ ki（⊕表示异或运算）。这样，每一位明文都与对应的密钥流位进行异或，得到密文。</p>
<p>加密流程如下图所示：<br>
<img src="https://img2024.cnblogs.com/blog/1552062/202504/1552062-20250424180236250-1239228807.png" alt="image" loading="lazy"></p>
<hr>
<h1 id="为什么需要一次一密">为什么需要一次一密？</h1>
<p>流密码常见的问题如果多次使用相同秘钥进行加密，攻击者可以不使用密码也可以获得密文。</p>
<h1 id="流密码如何防止恢复密钥流">流密码如何防止恢复密钥流？</h1>
<p>流密码的安全性依赖于密钥流的随机性和不可预测性。如果密钥流能够被攻击者预测或分析出来，那么密文就很容易被破解。</p>
<hr>
<h1 id="rc4算法的简介">RC4算法的简介</h1>
<p>RC4 算法是一种流密码算法，是一种可变密钥长度的流密码，它的密钥长度可以在 1 到 256 字节之间变化。</p>
<p>加密流程用文字说明太绕，直接跟着调试器看代码吧！<br>
<strong>CODE:</strong></p>
<pre><code class="language-python">def crypt(data, key):  # data为明文或密文，key为密钥
    """RC4 algorithm"""
    x = 0
    # box = range(256)   #初始化S盒
    box = list(range(256))  # 使用 list(range(256)) 创建可修改的列表
    for i in range(256):
        x = (x + box[i] + ord(key[i % len(key)])) % 256
        box[i], box[x] = box[x], box[i]
    x = y = 0
    out = []
    for char in data:
        x = (x + 1) % 256
        y = (y + box[x]) % 256
        box[x], box[y] = box[y], box[x]
        out.append(chr(ord(char) ^ box[(box[x] + box[y]) % 256]))
        # 对称密码，加密解密算法一样
    return ''.join(out)

# 加密
encrypted_str = crypt("Hello", "123")  # 假设返回字符串
encrypted_bytes = encrypted_str.encode("latin-1")  # 转字节（确保无损）
hex_result = encrypted_bytes.hex()  #转16进制 .hex()
print("加密结果:", hex_result)

# 解密
decrypted = crypt(bytes.fromhex(hex_result).decode("latin-1"), "123")
print("解密结果:", decrypted)

</code></pre>
<h2 id="s盒是什么"><strong>S盒是什么？</strong></h2>
<p>在 RC4 算法中，S 盒是一个长度为 256 的字节数组，用于存储和操作加密过程中的数据。</p>
<p><strong>作用：</strong></p>
<ul>
<li>
<p><strong>打乱数据顺序</strong>：S 盒的主要作用是通过特定的初始化过程，将其内部的元素顺序打乱。这个打乱过程基于密钥进行，使得 S 盒的状态与密钥相关联。这样，不同的密钥会导致 S 盒具有不同的初始状态，从而为加密提供了不同的 “混淆” 方式，增加了密码的安全性。</p>
</li>
<li>
<p><strong>生成密钥流</strong>：在密钥流生成阶段，通过对 S 盒的操作来生成伪随机的密钥流字节。算法根据特定的规则对 S 盒进行索引和元素交换，然后根据 S 盒的状态计算出密钥流字节。由于 S 盒的状态是由密钥决定的，所以生成的密钥流也与密钥紧密相关，并且具有一定的随机性和不可预测性。</p>
</li>
<li>
<p><strong>纯线性操作易被破解</strong>（如线性密码分析），<strong>非线性变换（如 S 盒）可增加复杂度</strong>。</p>
</li>
</ul>
<p><strong>初始化代码</strong>：</p>
<pre><code class="language-python">    for i in range(256):
        x = (x + box[i] + ord(key[i % len(key)])) % 256
        box[i], box[x] = box[x], box[i]
</code></pre>
<p>初始化的S盒：<br>
<img src="https://img2024.cnblogs.com/blog/1552062/202504/1552062-20250428155535537-1961684889.png" alt="image" loading="lazy"></p>
<p>规律：基于秘钥生成，同一个秘钥所生成的S盒都是一样的。</p>
<h2 id="取模介绍"><strong>取模介绍</strong></h2>
<p>取模运算，也叫取余运算，其原理是在整数除法中，被除数不能被除数整除时，就会产生余数，这个余数就是取模运算的结果。</p>
<p>被除数 小于 除数时，余数是被除数。</p>
<p>代码: <code>x = (x + box[i] + ord(key[i % len(key)])) % 256</code> 中，<code>% 256</code> 是 取模运算，它的核心目的是确保计算结果 x 的值始终落在 0 到 255 的范围内。</p>
<h2 id="加密解密"><strong>加密、解密</strong></h2>
<p><img src="https://img2024.cnblogs.com/blog/1552062/202504/1552062-20250428162233595-1234391662.png" alt="image" loading="lazy"></p>
<p><img src="https://img2024.cnblogs.com/blog/1552062/202504/1552062-20250428162939106-58257825.png" alt="image" loading="lazy"></p>
<h2 id="复用库的rc4用法"><strong>复用库的RC4用法</strong></h2>
<p>python中Crypto库中有该算法，具体用法如下：</p>
<pre><code class="language-python">from Crypto.Cipher import *
data = "kangel"
key = "key"
cipher = ARC4.new(key)    #加载密钥
m = cipher.decrypt(key)   #用该密钥解密
print m
</code></pre>
<h2 id="总结"><strong>总结</strong></h2>
<p>总而言之就是<strong>两个步骤</strong>：</p>
<ol>
<li>基于秘钥生成一个256位的S盒；</li>
<li>逐个将明文与S盒内的某位数做异或操作。</li>
</ol>
<hr>
<h1 id="reference">Reference</h1>
<p>逆向踩坑之RC4<br>
<a href="https://j-kangel.github.io/2019/04/09/RC4/#%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener nofollow">https://j-kangel.github.io/2019/04/09/RC4/#简介</a></p>
<p><a href="https://www.cnblogs.com/huangming-zzz/p/10725295.html" target="_blank">https://www.cnblogs.com/huangming-zzz/p/10725295.html</a></p>
<p><a href="https://www.cnblogs.com/cyssmile/p/12829098.html" target="_blank">https://www.cnblogs.com/cyssmile/p/12829098.html</a></p>

</div>
<div class="clear"></div>

        <div class="postDesc">posted on 
<span id="post-date" data-last-update-days="0.05577243588194444" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-28 19:10">2025-04-28 16:43</span>&nbsp;
<a href="https://www.cnblogs.com/mysticbinary">Mysticbinary</a>&nbsp;
阅读(<span id="post_view_count">85</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18684461);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18684461', targetLink: 'https://www.cnblogs.com/mysticbinary/p/18684461', title: '什么是流密码？' })">举报</a>
</div>
    