
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ihave2carryon/p/18834790" title="发布于 2025-04-18 23:04">
    <span role="heading" aria-level="2">Spring Security认证与授权</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="什么是spring-security">什么是Spring Security</h1>
<blockquote>
<p>Spring Security是基于Spring框架,提供了一套Web应用安全性框架.专门为Java应用提供<strong>用户认证(Authentication)和用户授权(Authorization),支持单体应用到微服务的全场景安全防护</strong></p>
</blockquote>
<h2 id="认证authentication">认证(Authentication)</h2>
<ul>
<li>验证某个用户是否为系统中的合法主体,即确认该用户是否可以访问此系统.认证一般需要用户提供用户名与密码,提供校验用户名与密码完成认证过程</li>
<li>简单来说→<strong>认证是判断该用户是否能登录;</strong></li>
<li>关键要素:1.<code>Principal</code>:用户主体(如用户名)2.<code>Credentials</code>:验证凭证(如用户密码)3.<code>Authorities</code>:用户权限集合</li>
</ul>
<h2 id="授权authorization">授权(Authorization)</h2>
<ul>
<li>是指某个用户是否有权限执行某个操作.在同一系统中,不同用户所具有的权限是不同的.如对某一文件,有些用户只能读不能修改,而有些用户既可读也可以修改.某个角色都有一系列的权限</li>
<li>简单来说→<strong>授权是判断该用户是否有权限去做特定的操作;</strong></li>
<li>关键要素:1.角色(<code>Role</code>):用户分组标识2.权限(<code>Permission</code>):具体操作权限</li>
</ul>
<h2 id="优势和缺点">优势和缺点</h2>
<ul>
<li>优势
<ul>
<li>深度与Spring整合:无缝支持<code>Spring Boot、Spring MVC、Spring Data</code>等框架</li>
<li>企业级安全方案:支持O<code>Auth2,SAML,LDAP,JWT</code>等协议,满足复杂安全需求</li>
<li>旧版本无法脱离Web环境</li>
<li>新版本对框架进行分层提取,分为核心板块和Web板块,</li>
</ul>
</li>
<li>缺点
<ul>
<li>性能开销:默认开启CSRF,Session管理等特性,对高性能场景需手动优化</li>
<li>配置复杂度高:默认配置覆盖大量安全规则,需要显式覆盖才能简化</li>
</ul>
</li>
</ul>
<h2 id="与shiro对比">与Shiro对比</h2>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>Spring Security</th>
<th><strong>Shiro</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>生态整合</td>
<td>深度集成 Spring 技术栈</td>
<td>需手动整合Spring,对非 Spring 项目更友好</td>
</tr>
<tr>
<td>微服务支持</td>
<td>天然支持 Spring Cloud Security</td>
<td>需自行实现分布式会话和权限管理</td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>企业级应用,微服务架构,需要 OAuth2 的 SaaS 系统</td>
<td>中小型 Web 应用,移动端后台,快速开发项目</td>
</tr>
</tbody>
</table>
<ul>
<li>一般来说常见的安全管理技术栈组合是这样:
<ul>
<li>SSM+Shiro</li>
<li>Spring Boot/Spring Cloud+Spring Security</li>
</ul>
</li>
</ul>
<h1 id="spring-security实现原理">Spring Security实现原理</h1>
<blockquote>
<p>对Web资源最好的保护是Filter,对方法调用的最好方法是AOP</p>
</blockquote>
<ul>
<li>Spring Security进行认证和权限检验时就是通过一系列的Filter来进行拦截</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3423316/202504/3423316-20250418230006948-984612877.png" alt="" loading="lazy"></p>
<ul>
<li>如图所示:一个请求要访问到后端,就要从左到右经过这些过滤器.<strong>其中绿色的过滤器是负责认证的过滤器,蓝色部分是负责异常处理的过滤器,橙色是负责权限校验的拦截器.</strong></li>
<li>对于我们而言,只需关注<strong><code>UserNamePasswordAuthenticationFilter**-&gt;</code></strong>负责登入认证和<code>FilterSecurityInterceptor</code><strong>-&gt;</strong>负责授权**</li>
</ul>
<p>对于Spring Security,掌握了过滤器和组件就完全掌握了Spring Security.其使用方法就是对过滤器和组件进行扩展</p>
<h2 id="spring-security入门">Spring Security入门</h2>
<ul>
<li>
<p>添加Spring Security相关依赖</p>
<pre><code class="language-xml">				&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
            &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;
            &lt;version&gt;0.12.6&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
            &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;
            &lt;version&gt;0.12.6&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
            &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;
            &lt;version&gt;0.12.6&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
</ul>
<blockquote>
<p>编写UserController进行测试</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3423316/202504/3423316-20250418230024279-885543378.png" alt="" loading="lazy"></p>
<blockquote>
<p>启动项目,访问localhost:8080进行测试,其会自动跳转到localhost:8080/login登入页面</p>
</blockquote>
<p><img src="https://img2024.cnblogs.com/blog/3423316/202504/3423316-20250418230037268-1880310225.png" alt="" loading="lazy"></p>
<ul>
<li>默认的用户名:user</li>
<li>其密码会在项目启动时打印在控制台</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3423316/202504/3423316-20250418230051012-858934494.png" alt="" loading="lazy"></p>
<ul>
<li>输入正确的用户名和密码时,即可成功访问UserController中的get方法→说明Spring Security保护生效</li>
<li>当然在实际开发中,这种默认配置是不存在的,我们需要扩展这些组件</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3423316/202504/3423316-20250418230102347-363188978.png" alt="" loading="lazy"></p>
<h2 id="用户认证">用户认证</h2>
<p>用户认证的流程</p>
<p><img src="https://img2024.cnblogs.com/blog/3423316/202504/3423316-20250418230112983-125779963.png" alt="" loading="lazy"></p>
<p>核心接口:</p>
<ul>
<li>
<p><code>Authentication</code>接口,表示当前访问系统的用户,封装了用户的信息,其实现类为<code>UsernamePasswordAuthenticationToken</code></p>
</li>
<li>
<p><code>AuthenticationManager</code>接口,其定义了Authentication的方法</p>
</li>
<li>
<p><code>UserDetailsService</code>接口,加载用户特定数据的核心接口,其中定义了一个根据用户名查询用户信息的方法</p>
</li>
<li>
<p><code>UserDetails</code>接口,提供核心用户信息.将UserDetailsService中获取的信息封装为<code>UserDetails</code>对象返回.并将其封装至Authentication对象中</p>
<p>UserDetails中的基本方法:</p>
</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3423316/202504/3423316-20250418230121737-2142544357.png" alt="" loading="lazy"></p>
<p>用于认证的核心组件:</p>
<blockquote>
<p>对于系统来说,同一时间会有多个用户正在使用,那么如何确认哪个用户正在请求登录接口是登录认证的核心目的.Spring Security提出了:<strong>当前登录用户/当前认证用户</strong>,Spring Security中使用<code>Authentication</code>来存储认证信息,表示当前用户</p>
</blockquote>
<blockquote>
<p>在Spring boot中使用安全上下文<code>SecurityContext</code>来获取<code>Authentication</code>,<code>SecurityContext</code>交有<code>SecurityContextHolder</code>来管理,使用以下方法即可获取<code>Authentication</code></p>
</blockquote>
<pre><code class="language-java">Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

</code></pre>
<ul>
<li>Spring Security三个认证核心组件为:
<ol>
<li><code>Authentication</code>:存储认证信息的上下文,代表当前用户</li>
<li><code>SecurityContext</code>:上下文对象,用来获取<code>Authentication</code></li>
<li><code>SecurityContextHolder</code>:上下文管理对象,用来获取SecurityContext</li>
</ol>
</li>
</ul>
<h3 id="认证逻辑">认证逻辑</h3>
<ul>
<li>
<p><code>AuthenticationManager</code>是Spring Security用于执行身份验证的组件,其<code>authenticate</code>方法可以完成认证.Spring Security默认的认证方法是在<code>UsernamePasswordAuthenticationFilter</code>这个过滤器中进行认证的</p>
<p>关键代码如下:</p>
<pre><code class="language-java">        // 创建用户认证令牌，使用用户名和密码作为凭证
        UsernamePasswordAuthenticationToken token =
                new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword());

        // 通过认证管理器执行Spring Security认证流程，返回包含用户详情的认证对象
        Authentication authenticate = authenticationManager.authenticate(token);
</code></pre>
</li>
</ul>
<h3 id="加密器passwordencoder">加密器PasswordEncoder</h3>
<ul>
<li><code>passwordEncoder</code>在Spring Security中用于处理密码加密存储和验证.</li>
<li>它可以负责将用户提交的明文密码转换为不可逆的加密字符串(如BCrypt算法),之后便将密码存储到数据库中</li>
<li>在用户登录时,验证用户输入的明文密码是否与存储的加密密码一致</li>
</ul>
<blockquote>
<p>若需要自定义加密方法,我们可以编写自定义加密器<code>CustomPasswordEncoder</code></p>
</blockquote>
<pre><code class="language-java">public class CustomPasswordEncoder implements PasswordEncoder {
    // 自定义密码加密方式，使用MD5加密算法
    @Override
    public boolean matches(CharSequence rawPassword, String encodedPassword) {
        return Arrays.toString(DigestUtils.md5Digest(rawPassword.toString().getBytes())).equals(encodedPassword);
    }

    // 自定义密码加密方式，使用MD5加密算法
    @Override
    public String encode(CharSequence rawPassword) {
        return Arrays.toString(DigestUtils.md5Digest(rawPassword.toString().getBytes()));
    }
}

</code></pre>
<blockquote>
<p>并在SecurityConfig中注册新的加密器</p>
</blockquote>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfiguration {

    // 密码加密器
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new CustomPasswordEncoder();
    }
}

</code></pre>
<blockquote>
<p>直接使用<code>BCryptPasswordEncoder</code>加密器</p>
</blockquote>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfiguration {

    // 密码加密器
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
</code></pre>
<h2 id="自定义登录接口">自定义登录接口</h2>
<ul>
<li>首先要重写<code>SecuritySpring</code>中的方法,可以自己写使用@Bean注册,也可以重写<code>WebSecurityConfigurerAdapter</code>接口的方法</li>
</ul>
<blockquote>
<p>由于Spring Security会对每一个接口都会进行认证,有些接口需要放行,直接让用户访问,我们就得在<code>config()</code>中进行放行</p>
</blockquote>
<ul>
<li>接着需要把<code>AuthenticationManager</code>注入容器→因为要使用其的authenticate方法进行验证</li>
</ul>
<pre><code class="language-java">public class SecurityConfig extends WebSecurityConfigurerAdapter {

    /**
     * 配置密码编码器
     *
     * @return
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new CustomPasswordEncoder();
    }

    /**
     * 配置HTTP安全设置
     *
     * @param http
     * @throws Exception
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                // 禁用CSRF保护（常用于API场景）
                .csrf().disable()
                // 配置会话管理为无状态（不创建和使用HTTP Session）
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                // 配置请求授权规则
                .authorizeRequests()
                // 允许匿名访问登录端点
                .antMatchers("/user/login").permitAll()
                // 所有其他请求需要认证
                .anyRequest().authenticated();
    }

    /**
     * 暴露AuthenticationManager
     *
     * @return
     * @throws Exception
     */
    @Bean
    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }
    
}
</code></pre>
<ul>
<li>
<p>IUserService</p>
<ul>
<li>在其中编写<code>login()</code>方法来实现登录逻辑</li>
</ul>
<pre><code class="language-java">public interface ISysUserService extends IService&lt;SysUser&gt; {

    /**
     * @description: 登录
     * @author: HYJ
     * @date: 2025/4/15 0:01
     * @param: [user]
     * @return: edu.ptu.springsecurity.common.AjaxResult
     **/
    AjaxResult login(SysUser user);
}
</code></pre>
</li>
<li>
<p>LoginUser</p>
<ul>
<li><code>LoginUser</code>实现<code>UserDetails</code>接口,重写其中的方法.将业务数据衔接到Spring Security的认证体系中</li>
</ul>
<pre><code class="language-java">// 忽略未知的属性，避免序列化时出现异常
@JsonIgnoreProperties(ignoreUnknown = true)
public class LoginUser implements UserDetails {

    // 用户信息
    private SysUser user;

    /**
     * @description: 账号是否未过期
     * @author: HYJ
     * @date: 2025/4/15 0:02
     * @param: []
     * @return: boolean
     **/
    @Override
    public boolean isEnabled() {
        return true;
    }

    /**
     * @description: 密码是否未过期
     * @author: HYJ
     * @date: 2025/4/15 0:02
     * @param: []
     * @return: boolean
     **/
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    /**
     * @description: 账号是否未锁定
     * @author: HYJ
     * @date: 2025/4/15 0:02
     * @param: []
     * @return: boolean
     **/
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    /**
     * @description: 账号是否未过期
     * @author: HYJ
     * @date: 2025/4/15 0:02
     * @param: []
     * @return: boolean
     **/
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    /**
     * @description: 获取用户名
     * @author: HYJ
     * @date: 2025/4/15 0:02
     * @param: []
     * @return: java.lang.String
     **/
    @Override
    public String getUsername() {
        return user.getUsername();
    }

    /**
     * @description: 获取密码
     * @author: HYJ
     * @date: 2025/4/15 0:02
     * @param: []
     * @return: java.lang.String
     **/
    @Override
    public String getPassword() {
        return user.getPassword();
    }

    /**
     * @description: 获取权限
     * @author: HYJ
     * @date: 2025/4/15 0:02
     * @param: []
     * @return: java.util.Collection&lt;? extends org.springframework.security.core.GrantedAuthority&gt;
     **/
    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        return null;
    }
}

</code></pre>
<ul>
<li>我们还可以使用另一种写法,更加贴合实际的开发环境,若觉得实现<code>UserDetails</code>接口比较繁琐,我们可以继承Spring Security提供的<code>org.springframework.security.core.userdetails.User</code>类.其内部已经帮我们实现了<code>UserDetails</code>接口,省去了大量重写工作</li>
</ul>
<pre><code class="language-java">@Getter
@Setter
public class LoginUser extends User {

    private SysUser user;

    /**
     * 构造函数
     *
     * @param user        用户信息
     * @param authorities 权限列表
     */
    public LoginUser(SysUser user, Collection&lt;? extends GrantedAuthority&gt; authorities) {
        super(user.getUsername(), user.getPassword(), authorities);
        this.user = user;
    }

}

</code></pre>
<ul>
<li>推荐使用实现<code>UserDetails</code>接口的方法.继承User类会受父类牵制</li>
</ul>
</li>
<li>
<p>UserDetailsServiceImpl</p>
<ul>
<li><code>UserDetailsServiceImpl</code>实现<code>UserDetails</code>了,扮演着 <strong>用户数据与认证流程之间的桥梁</strong>角色,其中重写<code>loadUserByUsernmae()</code>核心方法来实现从DB中获取用户信息,并将其封装为 Spring Security可识别的安全对象→<code>UserDetails</code></li>
</ul>
<pre><code class="language-java">@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    @Resource
    private UserServiceImpl userService;

    /**
     * @description: 加载用户信息
     * @author: HYJ
     * @date: 2025/4/15 0:01
     * @param: [username]
     * @return: org.springframework.security.core.userdetails.UserDetails
     **/
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {

        LambdaQueryWrapper&lt;SysUser&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();

        // 构建查询条件，根据用户名查询用户信息
        wrapper.eq(SysUser::getUsername, username);
        SysUser user = userService.getOne(wrapper);

        // 检查用户是否存在
        if (Objects.isNull(user)) {
            throw new RuntimeException("用户不存在");
        }

        // 返回包含用户详细信息的 LoginUser 对象
        return new LoginUser(user);
    }
}
</code></pre>
</li>
<li>
<p>UserServiceImpl</p>
<ul>
<li>实现login的底层操作</li>
</ul>
<pre><code class="language-java">@Service("userService")
public class UserServiceImpl extends ServiceImpl&lt;SysUserMapper, SysUser&gt; implements ISysUserService {

    // 注入认证管理器，用于处理用户认证流程
    @Resource
    private AuthenticationManager authenticationManager;

    // 注入Redis工具类，用于操作Redis缓存
    @Resource
    private RedisUtil redisUtil;

    @Override
    public AjaxResult login(SysUser user) {

        // 创建用户认证令牌，使用用户名和密码作为凭证
        UsernamePasswordAuthenticationToken token =
                new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword());

        // 通过认证管理器执行Spring Security认证流程，返回包含用户详情的认证对象
        Authentication authenticate = authenticationManager.authenticate(token);

        // 判断认证是否成功
        if (Objects.isNull(authenticate)) {
            throw new RuntimeException("登录失败,认证信息为空");
        }

        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();

        // 生成JWT令牌
        String jwt = JWTUtil.createToken(loginUser.getUser());

        // 认证成功，将用户信息存入Redis缓存
        redisUtil.setCacheObject("user:" + user.getUserId(), user);

        return AjaxResult.success("登录成功", jwt);

    }
}

</code></pre>
</li>
</ul>
<h2 id="用户授权">用户授权</h2>
<ul>
<li>用户授权是系统在确认用户身份后,根据其角色或者权限(Permissions)决定其能允许访问的资源或操作.</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/3423316/202504/3423316-20250418230216418-1421280938.png" alt="" loading="lazy"></p>
<h2 id="loginuser改造">LoginUser改造</h2>
<ul>
<li>在LoginUser中添加permissions字段→用于存储用户权限信息,authorities字段→存储springsecurity中所需的集合</li>
</ul>
<pre><code class="language-java">
    private SysUser user;

    // 存储用户权限信息
    private List&lt;String&gt; permissions;

    //防止出现序列化问题

    @JsonIgnore
    // 存储SpringSecurity所需要的权限信息的集合
    private List&lt;GrantedAuthority&gt; authorities;

    public LoginUser(List&lt;String&gt; permissions, SysUser user) {
        this.permissions = permissions;
        this.user = user;
    }

</code></pre>
<ul>
<li>重写<code>getAuthorities()</code>方法用于将permissions中的权限封装为GrantedAuthority对象</li>
</ul>
<pre><code class="language-java">    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        if (Objects.isNull(authorities)) {
            authorities = new ArrayList&lt;&gt;();
        }
        // 将权限字符串封装成GrantedAuthority对象
        permissions.forEach(permission -&gt;
                authorities.add(new SimpleGrantedAuthority(permission)));

        return authorities;
    }
</code></pre>
<h2 id="构建查询权限的mapper">构建查询权限的mapper</h2>
<ul>
<li>在userMapper下创建<code>findUserPermListByUserId()</code>方法用于获取用户权限</li>
</ul>
<pre><code class="language-java">public interface UserMapper extends BaseMapper&lt;SysUser&gt; {
    /**
     * 根据用户id查询权限列表
     *
     * @param userId 用户id
     * @return permList 权限列表
     */
    List&lt;String&gt; findUserPermListByUserId(Long userId);
}
</code></pre>
<h2 id="改造userdetailsserviceimpl">改造UserDetailsServiceImpl</h2>
<ul>
<li>调用<code>findUserPermListByUserId()</code>查询权限信息,放回到LoginUser中</li>
</ul>
<pre><code class="language-java">        List&lt;String&gt; userPermList = userMapper.findUserPermListByUserId(sysUser.getUserId());

        // 返回用户信息和权限列表
        return new LoginUser(userPermList, sysUser);
</code></pre>
<h2 id="授权实现">授权实现</h2>
<h3 id="在启动类进行配置">在启动类进行配置</h3>
<ul>
<li>在启动类上配置注解启动,<strong>来判断用户对某个控制层的方法是否具有访问权限</strong></li>
</ul>
<pre><code class="language-java">@SpringBootApplication
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SpringSecurityApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringSecurityApplication.class, args);
    }
}
</code></pre>
<h2 id="在controller的方法进行配置">在controller的方法进行配置</h2>
<ul>
<li>在方法上加上<code>@PreAuthorize</code>标签控制接口权限</li>
</ul>
<h3 id="自定义验证方法的实现方法">自定义验证方法的实现方法</h3>
<ul>
<li>编写<code>AuthPermissonUtils</code>方法实现权限验证逻辑</li>
</ul>
<pre><code class="language-java">@Component("auth")
public class AuthPermissionUtils {
    /**
     * 判断是否有该权限
     *
     * @param permission 权限字符串
     * @return true 有该权限 false 没有该权限
     */
    public boolean hasPermission(String permission) {
        // 获取当前用户的权限信息
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

        LoginUser loginUser = (LoginUser) authentication.getPrincipal();
        // 判断用户是否有该权限
        List&lt;String&gt; permissions = loginUser.getPermissions();
        return permissions.contains(permission);
    }
}
</code></pre>
<pre><code class="language-java">@RestController
@RequestMapping("/user")
public class UserController {

    @Resource
    private IUserService sysUserService;

    @GetMapping("/living")
    @PreAuthorize("@auth.hasPermission('living')")
    public Result living() {
        return Result.success("可以开房");
    }

    @GetMapping("/upgrade")
    @PreAuthorize("@auth.hasPermission('upgrade')")
    public Result upgrade() {
        return Result.success("可以升级房型");
    }

    @GetMapping("/freeBreakfast")
    @PreAuthorize("@auth.hasPermission('freeBreakfast')")
    public Result freeBreakfast() {
        return Result.success("有免费早餐");
    }

    @PostMapping("/login")
    public Result login(@RequestBody LoginRequest request) {
        return sysUserService.login(request);
    }
}
</code></pre>
<h1 id="异常处理方法">异常处理方法</h1>
<ul>
<li>
<p>在遇到认证失败和授权失败时,我们希望可以放回与接口相同的json结构,这样可以让前端进行统一处理</p>
</li>
<li>
<p>如果<strong>认证过程</strong>中出现异常会被封装成AuthenticationException如何调用<strong><code>AuthenticationEntryPoint</code></strong>对象的方法去进行异常处理</p>
<pre><code class="language-java">@Component
public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {

        response.setContentType("application/json;charset=utf-8");
        response.getWriter().write(
                JSON.toJSONString(Result.fail(401, "用户身份认证不通过"))
        );
    }
}
</code></pre>
</li>
<li>
<p>如果授权过程中出现的异常就会被封装AccessDeniedException然后调用<strong>AuthenticationEntryPoint</strong>对象的方法进行异常处理</p>
<pre><code class="language-java">@Component
public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {

        response.setContentType("application/json;charset=utf-8");
        response.getWriter().write(
                JSON.toJSONString(Result.fail(401, "用户身份认证不通过"))
        );
    }
}
</code></pre>
<h2 id="在securityconfig中进行配置">在SecurityConfig中进行配置</h2>
<ul>
<li>注入处理器</li>
</ul>
<pre><code class="language-java">    @Resource
    private AccessDeniedHandlerImpl accessDeniedHandler;

    @Resource
    private AuthenticationEntryPointImpl authenticationEntryPoint;
</code></pre>
<ul>
<li>在使用http进行配置</li>
</ul>
<pre><code class="language-java">        // 配置异常处理器
        http
                .exceptionHandling()
                .accessDeniedHandler(accessDeniedHandler)
                .authenticationEntryPoint(authenticationEntryPoint);
</code></pre>
</li>
</ul>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.4171866943900463" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-04-18 23:04">2025-04-18 23:04</span>&nbsp;
<a href="https://www.cnblogs.com/ihave2carryon">ihav2carryon</a>&nbsp;
阅读(<span id="post_view_count">6</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18834790);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18834790', targetLink: 'https://www.cnblogs.com/ihave2carryon/p/18834790', title: 'Spring Security认证与授权' })">举报</a>
</div>
        