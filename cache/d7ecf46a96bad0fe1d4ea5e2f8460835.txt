
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yanshajiuzhou/p/18656536" title="发布于 2025-01-06 23:29">
    <span role="heading" aria-level="2">解释器模式</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        解释器模式为特定的语言定义文法（文法就是语法、规则的意思），并提供一个解释器来解析输入的语言（通常是字符串或符号序列）并执行相应的操作。解释器模式适用于需要处理复杂语法的场景，常见于编程语言的解释器、表达式计算器、配置文件解析等。
    </div>
<div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>解释器（Interpreter）模式属于<strong>行为型</strong>模式的一种。</p>
<p>解释器模式为特定的语言定义文法（文法就是语法、规则的意思），并提供一个解释器来解析输入的语言（通常是字符串或符号序列）并执行相应的操作。</p>
<p>解释器模式适用于需要处理<strong>复杂语法</strong>的场景，常见于编程语言的解释器、表达式计算器、配置文件解析等。</p>
<p>解释器模式的实现通常非常复杂，且一般只能解决一类特定问题。</p>
<p>解释器模式通常有以下组成部分：&nbsp;</p>
<ul>
<li>抽象表达式（AbstractExpression）：这是一个接口或抽象类，通常定义一个 interpret() 方法，所有的具体表达式类都需要实现该方法来解释和执行相应的操作。</li>
<li>终结符表达式（TerminalExpression）：用于表示文法中的基本元素，通常对应语言中的终结符号。每个终结符都通过自身的 interpret() 方法来解释。</li>
<li>非终结符表达式（NonTerminalExpression）：表示文法中的非终结符，通常是由其他表达式组合而成的规则。非终结符表达式通常会包含其他表达式的引用，并通过递归调用其子表达式的 interpret() 方法来解释。</li>
<li>客户端（Client）：客户端通常负责构建解释器并传入需要解释的输入，它通过解释器进行解释和处理。</li>
</ul>
<p>PS：终结符表示是<strong>最终</strong>的符号，不会被进一步替代或分解。非终结符不是语言的最终元素，它们用来表示更复杂、范围更大的其他符号组成。终结符是基本元素或符号，非终结符是更复杂一些的<strong>抽象</strong>符号。现实生活中类比，鸡蛋（食材）、锅（工具）、油（调味料）、盐（调味料），这些属于终结符；炒蛋（复杂动作，包含了“打蛋”、“翻炒”等多个步骤）、调味（包括加盐、加鸡精等具体动作），这些属于非终结符。</p>
<p>假如我们要解释和计算形如“1 + 2 + 3”这样的加法表达式。</p>
<p>1、定义抽象表达式</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="3" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22%2F%2F%20%E6%8A%BD%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8E%A5%E5%8F%A3%5Cnpublic%20interface%20Expression%20%7B%5Cn%20%20%20%20int%20interpret()%3B%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-comment">// 抽象表达式接口
<span class="hljs-keyword">public <span class="hljs-keyword">interface <span class="hljs-title class_">Expression {
    <span class="hljs-type">int <span class="hljs-title function_">interpret<span class="hljs-params">();
}
</span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1171560/202501/1171560-20250106232951889-370743079.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<p>2、定义终结符表达式</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="2" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22%2F%2F%20%E7%BB%88%E7%BB%93%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B1%BB%EF%BC%8C%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%AD%97%5Cnpublic%20class%20NumberExpression%20implements%20Expression%20%7B%5Cn%20%20%20%20private%20int%20number%3B%5Cn%20%20%20%20%5Cn%20%20%20%20public%20NumberExpression(int%20number)%20%7B%5Cn%20%20%20%20%20%20%20%20this.number%20%3D%20number%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20int%20interpret()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20this.number%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-comment">// 终结符表达式类，表示数字
<span class="hljs-keyword">public <span class="hljs-keyword">class <span class="hljs-title class_">NumberExpression <span class="hljs-keyword">implements <span class="hljs-title class_">Expression {
    <span class="hljs-keyword">private <span class="hljs-type">int number;
    
    <span class="hljs-keyword">public <span class="hljs-title function_">NumberExpression<span class="hljs-params">(<span class="hljs-type">int number) {
        <span class="hljs-built_in">this.number = number;
    }

    <span class="hljs-meta">@Override
    <span class="hljs-keyword">public <span class="hljs-type">int <span class="hljs-title function_">interpret<span class="hljs-params">() {
        <span class="hljs-keyword">return <span class="hljs-built_in">this.number;
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1171560/202501/1171560-20250106232951889-370743079.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<p>3、定义非终结符表达式</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="1" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22%2F%2F%20%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%B1%BB%EF%BC%8C%E8%A1%A8%E7%A4%BA%E5%8A%A0%E6%B3%95%E6%93%8D%E4%BD%9C%5Cnpublic%20class%20AddExpression%20implements%20Expression%20%7B%5Cn%20%20%20%20private%20Expression%20left%3B%5Cn%20%20%20%20private%20Expression%20right%3B%5Cn%20%20%20%20%5Cn%20%20%20%20public%20AddExpression(Expression%20left%2C%20Expression%20right)%20%7B%5Cn%20%20%20%20%20%20%20%20this.left%20%3D%20left%3B%5Cn%20%20%20%20%20%20%20%20this.right%20%3D%20right%3B%5Cn%20%20%20%20%7D%5Cn%5Cn%20%20%20%20%40Override%5Cn%20%20%20%20public%20int%20interpret()%20%7B%5Cn%20%20%20%20%20%20%20%20return%20left.interpret()%20%2B%20right.interpret()%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-comment">// 非终结符表达式类，表示加法操作
<span class="hljs-keyword">public <span class="hljs-keyword">class <span class="hljs-title class_">AddExpression <span class="hljs-keyword">implements <span class="hljs-title class_">Expression {
    <span class="hljs-keyword">private Expression left;
    <span class="hljs-keyword">private Expression right;
    
    <span class="hljs-keyword">public <span class="hljs-title function_">AddExpression<span class="hljs-params">(Expression left, Expression right) {
        <span class="hljs-built_in">this.left = left;
        <span class="hljs-built_in">this.right = right;
    }

    <span class="hljs-meta">@Override
    <span class="hljs-keyword">public <span class="hljs-type">int <span class="hljs-title function_">interpret<span class="hljs-params">() {
        <span class="hljs-keyword">return left.interpret() + right.interpret();
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1171560/202501/1171560-20250106232951889-370743079.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<p>4、客户端</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="0" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22java%22%2C%22code%22%3A%22public%20class%20InterpreterClient%20%7B%5Cn%20%20%20%20public%20static%20void%20main(String%5B%5D%20args)%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E6%9E%84%E5%BB%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A1%20%2B%202%20%2B%203%5Cn%20%20%20%20%20%20%20%20Expression%20number1%20%3D%20new%20NumberExpression(1)%3B%5Cn%20%20%20%20%20%20%20%20Expression%20number2%20%3D%20new%20NumberExpression(2)%3B%5Cn%20%20%20%20%20%20%20%20Expression%20number3%20%3D%20new%20NumberExpression(3)%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E5%88%9B%E5%BB%BA%E5%8A%A0%E6%B3%95%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%5Cn%20%20%20%20%20%20%20%20Expression%20addition1%20%3D%20new%20AddExpression(number1%2C%20number2)%3B%5Cn%20%20%20%20%20%20%20%20Expression%20addition2%20%3D%20new%20AddExpression(addition1%2C%20number3)%3B%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%5Cn%20%20%20%20%20%20%20%20int%20result%20%3D%20addition2.interpret()%3B%5Cn%20%20%20%20%20%20%20%20System.out.println(%5C%22Result%3A%20%5C%22%20%2B%20result)%3B%20%20%2F%2F%20%E8%BE%93%E5%87%BA%3A%20Result%3A%206%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-java hljs"><span class="hljs-keyword">public <span class="hljs-keyword">class <span class="hljs-title class_">InterpreterClient {
    <span class="hljs-keyword">public <span class="hljs-keyword">static <span class="hljs-keyword">void <span class="hljs-title function_">main<span class="hljs-params">(String[] args) {
        <span class="hljs-comment">// 构建表达式：1 + 2 + 3
        <span class="hljs-type">Expression <span class="hljs-variable">number1 <span class="hljs-operator">= <span class="hljs-keyword">new <span class="hljs-title class_">NumberExpression(<span class="hljs-number">1);
        <span class="hljs-type">Expression <span class="hljs-variable">number2 <span class="hljs-operator">= <span class="hljs-keyword">new <span class="hljs-title class_">NumberExpression(<span class="hljs-number">2);
        <span class="hljs-type">Expression <span class="hljs-variable">number3 <span class="hljs-operator">= <span class="hljs-keyword">new <span class="hljs-title class_">NumberExpression(<span class="hljs-number">3);
        
        <span class="hljs-comment">// 创建加法表达式树
        <span class="hljs-type">Expression <span class="hljs-variable">addition1 <span class="hljs-operator">= <span class="hljs-keyword">new <span class="hljs-title class_">AddExpression(number1, number2);
        <span class="hljs-type">Expression <span class="hljs-variable">addition2 <span class="hljs-operator">= <span class="hljs-keyword">new <span class="hljs-title class_">AddExpression(addition1, number3);
        
        <span class="hljs-comment">// 计算结果
        <span class="hljs-type">int <span class="hljs-variable">result <span class="hljs-operator">= addition2.interpret();
        System.out.println(<span class="hljs-string">"Result: " + result);  <span class="hljs-comment">// 输出: Result: 6
    }
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2024.cnblogs.com/blog/1171560/202501/1171560-20250106232951889-370743079.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1"></span></div>
<p>解释器模式的<strong>优缺点。</strong></p>
<p>优点：</p>
<ul>
<li>易于扩展：解释器模式通过组合不同的表达式来表示复杂的语法规则，易于扩展。例如，可以通过增加新的表达式类来扩展支持的语法。</li>
<li>文法表达清晰：通过定义抽象表达式和具体表达式类，文法规则得以明确的表达，代码结构清晰。</li>
<li>递归结构：对于复杂的表达式，递归结构可以很自然地进行实现，并且表达式的求值过程也符合递归的思维方式。</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能问题：由于解释器模式涉及到多个类和递归调用，当表达式过于复杂时，可能会导致性能问题。</li>
<li>代码复杂性：对于一个简单的语法解析，使用解释器模式可能显得过于复杂和繁琐。大量的类和对象可能导致代码过于冗长，尤其是当语法规则较简单时，使用这种模式不一定是最优选择。</li>
<li>维护性差：对于更复杂的语言和规则，解释器模式可能需要构建大量的表达式类，增加了代码的复杂度和维护难度。</li>
</ul>
<p>解释器模式是一个强大的行为型设计模式，适用于有复杂语法规则的场景。在某些场景下，可能会显得过于复杂，选择使用时需要根据情况评估。</p>
<p style="text-align: right"><span style="color: rgba(0, 204, 255, 1)">生活是一场无硝烟的战争，枪林弹雨之中，不会给你喘息的机会，一旦停下来，就体无完肤。 -- 烟沙九洲</span></p>
<span data-cke-copybin-start="1"><span data-cke-copybin-end="1">​</span></span>
<div>
<div style="position: fixed; right: 0; top: 0; width: 18px; height: 100%; z-index: 99999; pointer-events: none; background-image: url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAKeCAYAAACoI0vdAAAAAXNSR0IArs4c6QAAAeFJREFUeF7t0qENAAAIBDHYf2lGqEEe+oJofufp9unP9MiSGWVkARftKCMLuGhHGVnARTvKyAIu2lFGFnDRjjKygIt2lJEFXLSjjCzgoh1lZAEX7SgjC7hoRxlZwEU7ysgCLtpRRhZw0Y4ysoCLdpSRBVy0o4ws4KIdZWQBF+0oIwu4aEcZWcBFO8rIAi7aUUYWcNGOMrKAi3aUkQVctKOMLOCiHWVkARftKCMLuGhHGVnARTvKyAIu2lFGFnDRjjKygIt2lJEFXLSjjCzgoh1lZAEX7SgjC7hoRxlZwEU7ysgCLtpRRhZw0Y4ysoCLdpSRBVy0o4ws4KIdZWQBF+0oIwu4aEcZWcBFO8rIAi7aUUYWcNGOMrKAi3aUkQVctKOMLOCiHWVkARftKCMLuGhHGVnARTvKyAIu2lFGFnDRjjKygIt2lJEFXLSjjCzgoh1lZAEX7SgjC7hoRxlZwEU7ysgCLtpRRhZw0Y4ysoCLdpSRBVy0o4ws4KIdZWQBF+0oIwu4aEcZWcBFO8rIAi7aUUYWcNGOMrKAi3aUkQVctKOMLOCiHWVkARftKCMLuGhHGVnARTvKyAIu2lFGFnDRjjKygIt2lJEFXLSjjCzgoh1lZAEX7SgjC7hoRxlZwMUBMJwCnyNbHuwAAAAASUVORK5CYII=&quot;); background-size: 100% 100%; background-repeat: no-repeat">&nbsp;</div>
<button class="move-button" style="position: fixed; right: 18px; left: auto; top: 50%; z-index: 99999; display: none">◀</button></div>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.19681782950115742" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-06 23:30">2025-01-06 23:29</span>&nbsp;
<a href="https://www.cnblogs.com/yanshajiuzhou">烟沙九洲</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18656536" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18656536);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18656536', targetLink: 'https://www.cnblogs.com/yanshajiuzhou/p/18656536', title: '解释器模式' })">举报</a>
</div>
        