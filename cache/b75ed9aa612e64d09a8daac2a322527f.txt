
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/wang_yb/p/18869274" title="发布于 2025-05-10 08:55">
    <span role="heading" aria-level="2">『Plotly实战指南』--Plotly与Pandas的深度融合</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>在数据分析的世界中，<strong>数据处理</strong>与<strong>可视化</strong>是密不可分的两个环节。</p>
<p><code>Pandas</code>作为<code>Python</code><strong>数据处理</strong>的核心工具，以其强大的数据清洗、转换和分析能力，成为数据科学家和分析师的必备利器；</p>
<p>而<code>Plotly</code>则是交互式<strong>可视化</strong>的佼佼者，能够将复杂的数据以直观、动态的方式呈现出来。</p>
<p>当我们将<code>Pandas</code>与<code>Plotly</code>深度融合时，就能无缝衔接数据清洗、分析与可视化的全流程，大幅提升数据分析的效率和效果。</p>
<h1 id="1-从pandas数据结构到plotly图表">1. 从Pandas数据结构到Plotly图表</h1>
<h2 id="11-series-与-dataframe-数据创建图表">1.1. Series 与 DataFrame 数据创建图表</h2>
<p><code>Plotly</code>提供了强大的<code>plotly.express</code>模块，能够直接读取<code>Pandas</code>的数据结构，如<code>Series</code>和<code>DataFrame</code>，并快速生成各种交互式图表。</p>
<p>例如，使用<code>px.line(df)</code>可以将一个时间序列的<code>DataFrame</code>转换为折线图，而<code>px.bar(series)</code>则可以将一个<code>Series</code>转换为条形图。</p>
<pre><code class="language-python">import pandas as pd
import numpy as np
import plotly.express as px

# 创建一个示例 DataFrame
data = {
    "date": pd.date_range(start="2024-01-01", periods=100),
    "sales": np.random.randint(100, 500, size=100),
}
df = pd.DataFrame(data)

# 使用 Plotly Express 创建折线图
fig = px.line(df, x="date", y="sales", title="时间序列销售数据")
fig.show()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202505/83005-20250510085355126-931062511.png" alt="" loading="lazy"></p>
<p>在这个例子中，<code>x='date'</code>和<code>y='sales'</code>将<code>DataFrame</code>的<strong>列名</strong>映射到了图表的坐标轴上。</p>
<p>将数据中的某个列（<code>Series</code>）取出来，可以直接绘制条形图。</p>
<pre><code class="language-python">series = df["sales"]
fig = px.bar(series)
fig.show()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202505/83005-20250510085355106-800202094.png" alt="" loading="lazy"></p>
<h2 id="12-索引与绘图的关联">1.2. 索引与绘图的关联</h2>
<p><code>Pandas</code>的<strong>索引</strong>（如时间戳、分类标签）在绘图中也扮演着重要角色。</p>
<p>我们可以直接将<code>Pandas</code>索引作为图表的坐标轴，从而简化数据处理过程。</p>
<p>比如，如果一个<code>DataFrame</code>的索引是时间戳，那么它默认就成为<strong>X轴</strong>。</p>
<pre><code class="language-python">data = {
    "date": pd.date_range(start="2024-01-01", periods=100),
    "sales": np.random.randint(100, 500, size=100),
}
df = pd.DataFrame(data)

# 将日期设置为索引
df.set_index('date', inplace=True)

# 绘制图表，不需要指定X轴
fig = px.line(df, y='sales', title='以索引为时间轴的销售数据')
fig.show()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202505/83005-20250510085355069-396705514.png" alt="" loading="lazy"></p>
<p>对于<strong>多级索引</strong>（<code>MultiIndex</code>）数据，<code>Plotly</code>也提供了强大的支持。</p>
<p>我们可以利用<strong>多级索引</strong>来生成<strong>分面图</strong>（<code>Facet Plot</code>）或动态筛选图表。</p>
<pre><code class="language-python"># 创建多级索引
df = df.reset_index()
df["region"] = ["North", "South"] * 50
df.set_index(["region", "date"], inplace=True)

# 绘制分面图
fig = px.line(
    df.reset_index(),
    x="date",
    y="sales",
    facet_col="region",
    title="按地区分面的销售数据",
)
fig.show()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202505/83005-20250510085355146-1835443688.png" alt="" loading="lazy"></p>
<p>在处理多级索引时，需要注意索引重置与列名转换的问题。</p>
<p>上面的示例中，我们先将<code>date</code>索引转换为普通列，然后把普通列<code>region</code>和<code>date</code>一起转换为多级索引。</p>
<h1 id="2-数据预处理与可视化的交响曲">2. 数据预处理与可视化的交响曲</h1>
<h2 id="21-数据清洗与验证可视化">2.1. 数据清洗与验证可视化</h2>
<p>在实际的数据分析中，数据往往存在<strong>缺失值</strong>和<strong>异常值</strong>。</p>
<p><code>Pandas</code>提供了丰富的数据清洗工具，而<code>Plotly</code>可以将清洗前后的数据可视化出来，让我们更好的把握数据的变化。</p>
<p>首先，生成包含客户年龄（含<strong>缺失值</strong>和<strong>异常值</strong>）、销售额（对数正态分布）和区域的模拟数据集。</p>
<pre><code class="language-python">import pandas as pd
import numpy as np
import plotly.express as px

# 模拟含噪声数据
np.random.seed(42)
dates = pd.date_range('2023-01-01', periods=100)

# Customer_Age 年龄包含异常值（生成平均40，标准差30的数据）
df = pd.DataFrame({
    'Date': dates,
    'Customer_Age': np.random.normal(40, 30, 100),  
})

# 人为添加缺失值
df.loc[np.random.choice(100, 15), 'Customer_Age'] = np.nan
</code></pre>
<p>故意添加<code>15%</code>的年龄缺失值，并设置年龄范围异常（生成年龄的部分中有异常的年龄）。</p>
<p>然后，绘制原始数据的分布图：</p>
<pre><code class="language-python"># 原始数据分布
raw_hist = px.histogram(
    df,
    x='Customer_Age',
    title='原始数据分布（含缺失值与异常值）',
    labels={'Customer_Age': '客户年龄'},
    nbins=20
)
raw_hist.show()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202505/83005-20250510085355047-1175912108.png" alt="" loading="lazy"></p>
<p>接下来，开始清洗数据：</p>
<ol>
<li><code>dropna()</code>：删除年龄缺失的行</li>
<li><code>query()</code>：过滤年龄异常值（保留18-65岁）</li>
</ol>
<pre><code class="language-python"># 清洗数据
clean_df = (
    df
    .dropna(subset=['Customer_Age'])  # 删除缺失值
    .query('18 &lt;= Customer_Age &lt;= 65')  # 过滤异常值
)
</code></pre>
<p>清洗之后再次绘制分布图：</p>
<pre><code class="language-python"># 清洗后分布
clean_hist = px.histogram(
    clean_df,
    x='Customer_Age',
    title='清洗后数据分布',
    labels={'Customer_Age': '客户年龄'},
    nbins=20,
    color_discrete_sequence=['#2ca02c']
)
clean_hist.show()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202505/83005-20250510085355116-1194351275.png" alt="" loading="lazy"></p>
<p>通过这种方式，我们可以直观地看到数据清洗的效果，从而更好地评估数据的质量。</p>
<h2 id="22-数据聚合与高级可视化">2.2. 数据聚合与高级可视化</h2>
<p><code>Pandas</code>的<code>groupby()</code>和<code>pivot_table()</code>是数据聚合的强大工具。</p>
<p>我们可以利用<code>Pandas</code>进行数据重塑，然后用<code>Plotly</code>来绘制重塑之后数据的高级可视化，甚至是通过自定义动画控制按钮增强交互体验。</p>
<p>下面的示例中，我们先生成一些销售示例数据：</p>
<pre><code class="language-python"># 模拟数据
np.random.seed(42)
dates = pd.date_range('2023-01-01', periods=100)
df = pd.DataFrame({
    'Date': dates,
    'Sales': np.random.lognormal(3, 0.5, 100),
    'Region': np.random.choice(['北部', '南部', '东部', '西部'], 100)
})

# 对销售额进行对数转换（解决右偏分布）
df["Sales"] = np.log(df["Sales"])
</code></pre>
<p>然后，生成透视数据并绘制热力图。</p>
<pre><code class="language-python"># 生成透视数据
pivot_df = df.pivot_table(
    index=pd.Grouper(key='Date', freq='W'),  # 按周聚合
    columns='Region',
    values='Sales',
    aggfunc='mean'
).ffill()  # 前向填充缺失值

# 热力图
heatmap = px.imshow(
    pivot_df.T,  # 转置使时间为X轴
    x=pivot_df.index.strftime('%Y-%m-%d'),
    y=pivot_df.columns,
    labels={'x': '日期', 'y': '区域'},
    color_continuous_scale='RdBu_r',
    title='区域周均销售额热力图'
)
heatmap.update_layout(height=500)
heatmap.show()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202505/83005-20250510085355398-663641464.png" alt="" loading="lazy"></p>
<p>最后，按照月份聚合数据，并生成动态分层柱状图，看各个区域随着时间变化销售额是如何变化的。</p>
<pre><code class="language-python"># 动态分层柱状图
# 生成聚合数据
agg_df = (
    df
    .assign(Year_Month=lambda x: x['Date'].dt.to_period('M'))
    .groupby(['Year_Month', 'Region'], as_index=False)
    ['Sales'].mean()
    .assign(Year_Month=lambda x: x['Year_Month'].dt.to_timestamp())
)

# 创建动画图表
animated_bar = px.bar(
    agg_df,
    x='Region',
    y='Sales',
    animation_frame=agg_df['Year_Month'].dt.strftime('%Y-%m'),
    range_y=[agg_df['Sales'].min()*0.9, agg_df['Sales'].max()*1.1],
    labels={'Sales': '平均销售额（对数）'},
    title='区域销售趋势动态演示',
    color='Region',
    color_discrete_sequence=px.colors.qualitative.Pastel
)

# 优化动画设置
animated_bar.update_layout(
    xaxis={'categoryorder': 'total descending'},
    hovermode='x unified',
    updatemenus=[{
        "buttons": [
            {
                "args": [None, {"frame": {"duration": 500, "redraw": True},
                                "fromcurrent": True,
                                "transition": {"duration": 300}}],
                "label": "播放",
                "method": "animate"
            },
            {
                "args": [[None], {"frame": {"duration": 0, "redraw": True},
                                "mode": "immediate",
                                "transition": {"duration": 0}}],
                "label": "暂停",
                "method": "animate"
            }
        ],
        "direction": "left",
        "pad": {"r": 10, "t": 87},
        "showactive": False,
        "type": "buttons",
        "x": 0.1,
        "xanchor": "right",
        "y": 0,
        "yanchor": "top"
    }]
)
animated_bar.show()
</code></pre>
<p><img src="https://img2024.cnblogs.com/blog/83005/202505/83005-20250510085355410-1901913240.gif" alt="" loading="lazy"></p>
<h1 id="3-总结">3. 总结</h1>
<p><code>Plotly</code>与<code>Pandas</code>的深度融合为数据分析提供了一个强大的工具链。</p>
<p>从脏数据到洞察力，<code>Pandas</code> 负责数据的清洗和预处理，而 <code>Plotly</code> 则负责将处理后的数据以直观、动态的方式呈现出来。</p>
<p>这种协同工作模式不仅提升了数据分析的效率，还帮助我们更好地理解数据背后的含义。</p>
<p>在实际应用中，数据处理与可视化的不可分割性至关重要。</p>
<p>高质量的图表依赖于高质量的数据，而 <code>Plotly</code> 与 <code>Pandas</code> 的结合正是实现这一目标的最佳选择。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.48087950377314814" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-10 08:55">2025-05-10 08:55</span>&nbsp;
<a href="https://www.cnblogs.com/wang_yb">wang_yb</a>&nbsp;
阅读(<span id="post_view_count">67</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18869274);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18869274', targetLink: 'https://www.cnblogs.com/wang_yb/p/18869274', title: '『Plotly实战指南』--Plotly与Pandas的深度融合' })">举报</a>
</div>
        