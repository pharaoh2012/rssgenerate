
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/dafanjoy/p/18696257" title="发布于 2025-02-01 14:08">
    <span role="heading" aria-level="2">分布式事务之2PC两阶段提交</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="1-分布式事务概述"><strong>1. 分布式事务概述</strong></h2>
<h3 id="11-问题背景"><strong>1.1 问题背景</strong></h3>
<p>在分布式系统中，业务操作可能跨越多个服务或数据库（如订单服务、库存服务、支付服务），传统单机事务（ACID）无法满足跨网络节点的数据一致性需求。</p>
<ul>
<li><strong>网络不可靠</strong>：服务间调用可能失败或超时。</li>
<li><strong>数据一致性</strong>：不同节点间的状态需最终一致。</li>
<li><strong>性能与可用性</strong>：避免长时间锁资源导致系统阻塞。</li>
</ul>
<p>分布式事务的核心目标是确保&nbsp;<strong>跨服务/数据库的操作要么全部成功，要么全部回滚</strong>。</p>
<h2 id="2-两阶段提交2pc"><strong>2. 两阶段提交（2PC）</strong></h2>
<h4 id="原理"><strong>原理</strong></h4>
<ul>
<li><strong>阶段一（Prepare）</strong>：协调者询问所有参与者是否可提交，参与者锁定资源并返回“同意”或“拒绝”。</li>
<li><strong>阶段二（Commit/Rollback）</strong>：若所有参与者同意，协调者发送提交命令；否则发送回滚命令。</li>
</ul>
<p>以下是一个简化的&nbsp;<strong>Java 两阶段提交（2PC）</strong>&nbsp;具体实现示例，包含协调者（Coordinator）和参与者（Participant）的核心逻辑。代码通过模拟数据库操作展示2PC的关键流程：</p>
<hr>
<h3 id="1-参与者participant实现"><strong>1. 参与者（Participant）实现</strong></h3>
<p>每个参与者代表一个独立的数据库或服务，需支持准备（Prepare）、提交（Commit）、回滚（Rollback）操作。</p>
<pre><code class="language-java">import java.util.concurrent.atomic.AtomicBoolean;

/**
 * 参与者（如数据库或服务）
 */
public class Participant {
    private String name;          // 参与者名称（如"DB1"）
    private AtomicBoolean prepared = new AtomicBoolean(false);  // 准备状态
    private AtomicBoolean committed = new AtomicBoolean(false); // 提交状态

    public Participant(String name) {
        this.name = name;
    }

    /**
     * 阶段一：准备操作（锁定资源）
     * @return true表示准备成功，false表示失败
     */
    public boolean prepare() {
        try {
            // 模拟资源锁定，实际可能为操作数据库
            System.out.println(name + ": Trying to prepare...");
            Thread.sleep(100);  // 模拟网络延迟
            boolean success = Math.random() &gt; 0.2;  // 80%概率成功
            if (success) {
                prepared.set(true);
                System.out.println(name + ": Prepared successfully.");
                return true;
            } else {
                System.out.println(name + ": Prepare failed.");
                return false;
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }

    /**
     * 阶段二：提交操作
     */
    public void commit() {
        if (prepared.get()) {
            // 实际提交事务（如更新数据库）
            committed.set(true);
            System.out.println(name + ": Committed.");
        } else {
            System.out.println(name + ": Cannot commit without preparation.");
        }
    }

    /**
     * 阶段二：回滚操作
     */
    public void rollback() {
        if (prepared.get()) {
            // 实际回滚事务（如恢复数据）
            prepared.set(false);
            System.out.println(name + ": Rolled back.");
        } else {
            System.out.println(name + ": No need to rollback.");
        }
    }

    // 检查是否已提交
    public boolean isCommitted() {
        return committed.get();
    }
}
</code></pre>
<hr>
<h3 id="2-协调者coordinator实现"><strong>2. 协调者（Coordinator）实现</strong></h3>
<p>协调者负责管理所有参与者，驱动两阶段提交流程。</p>
<pre><code class="language-java">import java.util.List;

/**
 * 协调者（事务管理器）
 */
public class Coordinator {
    private List&lt;Participant&gt; participants;

    public Coordinator(List&lt;Participant&gt; participants) {
        this.participants = participants;
    }

    /**
     * 执行两阶段提交事务
     * @return true表示事务成功提交，false表示失败
     */
    public boolean executeTransaction() {
        System.out.println("===== Phase 1: Prepare =====");
        boolean allPrepared = participants.stream()
                .allMatch(Participant::prepare);

        System.out.println("===== Phase 2: Commit/Rollback =====");
        if (allPrepared) {
            participants.forEach(Participant::commit);
            System.out.println("Transaction committed successfully.");
            return true;
        } else {
            participants.forEach(Participant::rollback);
            System.out.println("Transaction rolled back due to failures.");
            return false;
        }
    }
}
</code></pre>
<hr>
<h3 id="3-客户端测试代码"><strong>3. 客户端测试代码</strong></h3>
<p>模拟包含两个参与者的分布式事务场景。</p>
<pre><code class="language-java">import java.util.Arrays;

public class TwoPhaseCommitDemo {
    public static void main(String[] args) {
        // 创建两个参与者（如数据库DB1和DB2）
        Participant db1 = new Participant("DB1");
        Participant db2 = new Participant("DB2");

        // 创建协调者并关联参与者
        Coordinator coordinator = new Coordinator(Arrays.asList(db1, db2));

        // 执行两阶段提交事务
        boolean success = coordinator.executeTransaction();

        // 输出最终状态
        System.out.println("\nFinal Status:");
        System.out.println("DB1 Committed: " + db1.isCommitted());
        System.out.println("DB2 Committed: " + db2.isCommitted());
        System.out.println("Transaction Result: " + (success ? "SUCCESS" : "FAILURE"));
    }
}
</code></pre>
<hr>
<h3 id="4-运行结果示例"><strong>4. 运行结果示例</strong></h3>
<h4 id="成功场景所有参与者准备成功"><strong>成功场景（所有参与者准备成功）</strong></h4>
<pre><code class="language-java">===== Phase 1: Prepare =====
DB1: Trying to prepare...
DB1: Prepared successfully.
DB2: Trying to prepare...
DB2: Prepared successfully.
===== Phase 2: Commit/Rollback =====
DB1: Committed.
DB2: Committed.
Transaction committed successfully.

Final Status:
DB1 Committed: true
DB2 Committed: true
Transaction Result: SUCCESS
</code></pre>
<h4 id="失败场景某一参与者准备失败"><strong>失败场景（某一参与者准备失败）</strong></h4>
<pre><code class="language-java">===== Phase 1: Prepare =====
DB1: Trying to prepare...
DB1: Prepared successfully.
DB2: Trying to prepare...
DB2: Prepare failed.
===== Phase 2: Commit/Rollback =====
DB1: Rolled back.
DB2: No need to rollback.
Transaction rolled back due to failures.

Final Status:
DB1 Committed: false
DB2 Committed: false
Transaction Result: FAILURE
</code></pre>
<hr>
<h3 id="5-关键点说明"><strong>5. 关键点说明</strong></h3>
<ol>
<li>
<p><strong>阶段一（Prepare）</strong></p>
<ul>
<li>协调者询问所有参与者是否可以提交。</li>
<li>参与者锁定资源并记录操作日志。</li>
<li>任一参与者失败则整个事务回滚。</li>
</ul>
</li>
<li>
<p><strong>阶段二（Commit/Rollback）</strong></p>
<ul>
<li>若所有参与者准备成功，协调者发送提交命令。</li>
<li>若任一参与者失败，协调者发送回滚命令。</li>
</ul>
</li>
<li>
<p><strong>代码简化说明</strong></p>
<ul>
<li>实际应用中需处理网络超时、重试和持久化日志。</li>
<li>分布式场景下需使用RPC或HTTP替代本地方法调用。</li>
<li>生产环境建议使用成熟的XA协议实现（如Atomikos、Narayana）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-2pc的局限性"><strong>6. 2PC的局限性</strong></h3>
<ul>
<li><strong>同步阻塞</strong>：参与者在Prepare阶段后需阻塞等待协调者指令。</li>
<li><strong>单点故障</strong>：协调者宕机可能导致事务悬挂。</li>
<li><strong>数据不一致</strong>：协调者与参与者在Commit阶段同时宕机时，可能部分提交。</li>
</ul>
<hr>
<h1 id="关注微信公众号查看更多技术文章">关注微信公众号，查看更多技术文章。</h1>
<p><img src="https://img2024.cnblogs.com/blog/780676/202411/780676-20241107103425857-1781474315.png" alt="image" loading="lazy"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="2.005841632372685" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-01 14:12">2025-02-01 14:08</span>&nbsp;
<a href="https://www.cnblogs.com/dafanjoy">DaFanJoy</a>&nbsp;
阅读(<span id="post_view_count">104</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18696257" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18696257);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18696257', targetLink: 'https://www.cnblogs.com/dafanjoy/p/18696257', title: '分布式事务之2PC两阶段提交' })">举报</a>
</div>
        