
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18960989" title="发布于 2025-07-02 09:59">
    <span role="heading" aria-level="2">用好索引的10条军规</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>在大型系统性能瓶颈中，索引设计不当导致的性能问题占比超过60%。</p>
<p>经过多年的工作经历，我处理过多起数据库性能事故。</p>
<p>总结出索引设计的核心原则：<strong>索引不是越多越好，而是越精准越好</strong>。</p>
<p>这篇文章跟大家一起聊聊设计索引的10条军规，希望对你会有所帮助。</p>
<p>更多精彩内容，可以查看我博客园的首页，里面有我发表过的历史文章。</p>
<h2 id="一理解业务场景">一、理解业务场景</h2>
<p>理解业务场景，它是索引设计的基石。</p>
<h3 id="错误示例盲目添加索引">错误示例：盲目添加索引</h3>
<pre><code class="language-sql">-- 未分析业务场景就创建索引
CREATE INDEX idx_all_columns ON orders (customer_id, product_id, status, create_time);
</code></pre>
<h3 id="正确实践业务场景分析矩阵">正确实践：业务场景分析矩阵</h3>
<table>
<thead>
<tr>
<th>查询类型</th>
<th>频率</th>
<th>响应要求</th>
<th>数据量</th>
<th>索引策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户订单查询</td>
<td>高</td>
<td>&lt;100ms</td>
<td>百万级</td>
<td>(user_id, status)</td>
</tr>
<tr>
<td>商品订单统计</td>
<td>中</td>
<td>&lt;1s</td>
<td>千万级</td>
<td>(product_id)</td>
</tr>
<tr>
<td>订单状态更新</td>
<td>极高</td>
<td>&lt;50ms</td>
<td>百万级</td>
<td>(status)</td>
</tr>
</tbody>
</table>
<p>业务场景分析流程图如下：<br>
<img alt="" loading="lazy" data-src="https://files.mdnice.com/user/5303/c0781b6e-e73d-4986-8c06-52e28dd9abec.png" class="lazyload"></p>
<p><strong>深度洞察</strong>：某电商系统通过业务分析，将订单查询性能从2s优化到50ms，TPS提升300%。</p>
<h2 id="二最左前缀原则">二、最左前缀原则</h2>
<p>最左前缀原则，它是复合索引的灵魂。</p>
<h3 id="索引结构解析">索引结构解析</h3>
<p><img alt="" loading="lazy" data-src="https://files.mdnice.com/user/5303/0d960c78-be71-43ec-a0fa-d1bebdc37d78.png" class="lazyload"></p>
<h3 id="查询匹配规则">查询匹配规则：</h3>
<pre><code class="language-sql">-- 命中索引
SELECT * FROM orders 
WHERE user_id = 1001 AND status = 'PAID';

-- 命中索引（最左前缀）
SELECT * FROM orders 
WHERE user_id = 1001;

-- 未命中索引（违反最左前缀）
SELECT * FROM orders 
WHERE status = 'PAID';
</code></pre>
<p><strong>原理剖析</strong>：复合索引按声明顺序构建B+树，缺失左侧列时将无法使用索引结构。</p>
<h2 id="三避免过度索引">三、避免过度索引</h2>
<p>避免过度索引，它是写操作的隐形杀手。</p>
<h3 id="索引代价计算公式">索引代价计算公式：</h3>
<pre><code>写操作代价 = 数据写入 + ∑(索引写入)
</code></pre>
<h3 id="索引影响对比实验">索引影响对比实验：</h3>
<pre><code class="language-sql">-- 测试表
CREATE TABLE test_table (
    id INT PRIMARY KEY,
    col1 VARCHAR(20),
    col2 VARCHAR(20),
    col3 VARCHAR(20)
);

-- 添加索引前后写入性能对比
INSERT INTO test_table VALUES (...) -- 无索引：0.5ms
CREATE INDEX idx1 ON test_table(col1);
INSERT INTO test_table VALUES (...) -- 单索引：0.8ms
CREATE INDEX idx2 ON test_table(col2);
CREATE INDEX idx3 ON test_table(col3);
INSERT INTO test_table VALUES (...) -- 三索引：1.8ms
</code></pre>
<p>索引写入耗时如下图所示：<br>
<img alt="" loading="lazy" data-src="https://files.mdnice.com/user/5303/02af5ec3-9df0-40ff-a02d-04b618696146.png" class="lazyload"></p>
<p><strong>黄金法则</strong>：单表索引不超过5个，单个索引字段不超过3列。</p>
<h2 id="四覆盖索引">四、覆盖索引</h2>
<p>覆盖索引，它是查询性能的终极大招。</p>
<h3 id="未使用覆盖索引">未使用覆盖索引：</h3>
<pre><code class="language-sql">EXPLAIN SELECT order_no, amount 
FROM orders
WHERE user_id = 1001 AND status = 'PAID';

</code></pre>
<p>执行计划：</p>
<pre><code>| id | select_type | table  | type | key               | Extra       |
|----|-------------|--------|------|-------------------|-------------|
| 1  | SIMPLE      | orders | ref  | idx_user_status   | Using where|
</code></pre>
<h3 id="使用覆盖索引">使用覆盖索引：</h3>
<pre><code class="language-sql">-- 创建覆盖索引
CREATE INDEX idx_covering ON orders(user_id, status, order_no, amount);

EXPLAIN SELECT order_no, amount 
FROM orders
WHERE user_id = 1001 AND status = 'PAID';
</code></pre>
<p>执行计划：</p>
<pre><code>| id | select_type | table  | type | key          | Extra                    |
|----|-------------|--------|------|--------------|--------------------------|
| 1  | SIMPLE      | orders | ref  | idx_covering | Using index              |
</code></pre>
<p><strong>性能对比</strong>：覆盖索引减少磁盘I/O，查询速度提升5-10倍。</p>
<h2 id="五数据类型优化">五、数据类型优化</h2>
<p>数据类型优化，它是索引大小的隐形杠杆。</p>
<h3 id="常见类型空间占用">常见类型空间占用：</h3>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>字节数</th>
<th>索引大小（百万行）</th>
</tr>
</thead>
<tbody>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>15MB</td>
</tr>
<tr>
<td>INT</td>
<td>4</td>
<td>7.5MB</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>5.6MB</td>
</tr>
<tr>
<td>CHAR(32)</td>
<td>32</td>
<td>61MB</td>
</tr>
<tr>
<td>VARCHAR(32)</td>
<td>变长</td>
<td>20-50MB</td>
</tr>
</tbody>
</table>
<h3 id="优化案例">优化案例：</h3>
<pre><code class="language-sql">-- 优化前：使用字符串存储IP
CREATE TABLE access_log (
    id BIGINT,
    ip VARCHAR(15),
    INDEX idx_ip (ip)
);

-- 优化后：转换为整型存储
CREATE TABLE access_log (
    id BIGINT,
    ip INT UNSIGNED,
    INDEX idx_ip (ip)
);
</code></pre>
<p><strong>空间节省</strong>：IP字段索引大小从78MB降至12MB，内存命中率提升40%。</p>
<h2 id="六函数陷阱">六、函数陷阱</h2>
<p>函数陷阱，它是索引失效的元凶。</p>
<h3 id="索引失效案例">索引失效案例：</h3>
<pre><code class="language-sql">-- 创建索引
CREATE INDEX idx_create_time ON orders(create_time);

-- 索引失效查询
SELECT * FROM orders
WHERE DATE_FORMAT(create_time, '%Y-%m-%d') = '2023-06-01';

-- 优化后查询
SELECT * FROM orders
WHERE create_time BETWEEN '2023-06-01 00:00:00' AND '2023-06-01 23:59:59';
</code></pre>
<h3 id="函数使用原则">函数使用原则：</h3>
<div class="mermaid">graph LR
    A[查询条件] --&gt; B{是否包含函数}
    B --&gt;|是| C[索引可能失效]
    B --&gt;|否| D[正常使用索引]
    C --&gt; E[重写条件]
    E --&gt; D
</div><p><strong>性能对比</strong>：日期范围查询优化后，执行时间从1200ms降至15ms。</p>
<h2 id="七前缀索引">七、前缀索引</h2>
<p>前缀索引，它是大文本字段的救星。</p>
<h3 id="创建方法">创建方法：</h3>
<pre><code class="language-sql">-- 原始字段索引
CREATE INDEX idx_product_desc ON products(description); -- 无法创建，text字段过大

-- 前缀索引
CREATE INDEX idx_product_desc_prefix ON products(description(20));
</code></pre>
<h3 id="长度选择算法">长度选择算法：</h3>
<pre><code class="language-sql">-- 计算最佳前缀长度
SELECT 
  COUNT(DISTINCT LEFT(description, 10)) / COUNT(*) AS selectivity10,
  COUNT(DISTINCT LEFT(description, 20)) / COUNT(*) AS selectivity20,
  COUNT(DISTINCT LEFT(description, 30)) / COUNT(*) AS selectivity30
FROM products;
</code></pre>
<p>前缀长和区分度对比：</p>
<table>
<thead>
<tr>
<th>前缀长度</th>
<th>区分度</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>0.65</td>
<td>不足</td>
</tr>
<tr>
<td>20</td>
<td>0.92</td>
<td>推荐</td>
</tr>
<tr>
<td>30</td>
<td>0.95</td>
<td>边际收益低</td>
</tr>
</tbody>
</table>
<p><strong>空间节省</strong>：500万行数据的描述字段，索引从1.2GB降至120MB。</p>
<h2 id="八null值处理">八、NULL值处理</h2>
<p>NULL值处理，它是索引中的幽灵。</p>
<h3 id="null值索引问题">NULL值索引问题：</h3>
<pre><code class="language-sql">-- 包含NULL的索引
CREATE INDEX idx_email ON users(email);

-- 查询问题
SELECT * FROM users WHERE email IS NULL; -- 可能不走索引

-- 优化方案
ALTER TABLE users MODIFY email VARCHAR(255) NOT NULL DEFAULT '';
</code></pre>
<h3 id="null值索引存储结构">NULL值索引存储结构：</h3>
<p><img alt="" loading="lazy" data-src="https://files.mdnice.com/user/5303/579a2e03-4bea-451b-9ae0-5ef56cefc215.png" class="lazyload"></p>
<p><strong>最佳实践</strong>：重要查询字段设置<code>NOT NULL DEFAULT</code>，默认值根据业务设置如0、''、'N/A'等。</p>
<h2 id="九索引维护">九、索引维护</h2>
<p>索引维护，它是性能稳定的守护者。</p>
<h3 id="维护脚本示例">维护脚本示例：</h3>
<pre><code class="language-sql">-- 重建碎片化索引
ALTER TABLE orders REBUILD INDEX idx_user_status;

-- 更新统计信息
ANALYZE TABLE orders UPDATE HISTOGRAM ON status WITH 32 BUCKETS;

-- 监控脚本
SELECT 
  index_name,
  ROUND(stat_value * @@innodb_page_size / 1024 / 1024, 2) AS size_mb,
  index_type,
  table_rows
FROM mysql.innodb_index_stats
WHERE table_name = 'orders';
</code></pre>
<h3 id="碎片化影响曲线">碎片化影响曲线：</h3>
<p><img alt="" loading="lazy" data-src="https://files.mdnice.com/user/5303/2b5c004d-ebbb-401a-b105-be84c2ba03ca.png" class="lazyload"></p>
<p><strong>维护建议</strong>：每月对核心表执行索引维护，碎片率超过30%必须重建。</p>
<h2 id="十监控与调优">十、监控与调优</h2>
<p>监控与调优，它是索引的生命周期管理。</p>
<h3 id="索引使用分析">索引使用分析：</h3>
<pre><code class="language-sql">-- 查看未使用索引
SELECT 
  object_schema,
  object_name,
  index_name
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE index_name IS NOT NULL
AND count_star = 0
AND object_schema NOT IN ('mysql', 'sys');
</code></pre>
<h3 id="索引监控体系">索引监控体系：</h3>
<p><img alt="" loading="lazy" data-src="https://files.mdnice.com/user/5303/d58c9cff-2840-4938-a6f1-0892c7f18843.png" class="lazyload"></p>
<p><strong>真实案例</strong>：某金融系统通过索引监控，清理200+无效索引，写性能提升50%。</p>
<h2 id="总结">总结</h2>
<ol>
<li><strong>业务驱动</strong>：索引设计始于业务场景分析</li>
<li><strong>左前缀优先</strong>：复合索引必须遵守最左前缀原则</li>
<li><strong>适度精简</strong>：警惕过度索引的写放大效应</li>
<li><strong>覆盖为王</strong>：优先考虑覆盖索引解决方案</li>
<li><strong>类型优化</strong>：用小而精的数据类型降低索引体积</li>
<li><strong>函数规避</strong>：避免在索引列上使用函数</li>
<li><strong>前缀压缩</strong>：大文本字段使用前缀索引</li>
<li><strong>NULL处理</strong>：重要字段避免NULL值</li>
<li><strong>定期维护</strong>：建立索引维护机制</li>
<li><strong>持续监控</strong>：构建索引生命周期管理体系</li>
</ol>
<blockquote>
<p><strong>优秀的索引设计，是在查询效率与维护成本间找到完美平衡点</strong>。</p>
</blockquote>
<p>索引是一把双刃剑，用得好所向披靡，用不好反伤己身。</p>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的10万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>
<p>本文收录于我的技术网站：<a href="http://www.susan.net.cn" target="_blank" rel="noopener nofollow">http://www.susan.net.cn</a></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.010416666666666666" data-date-updated="2025-07-02 10:14">2025-07-02 09:59</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">72</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18960989);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18960989', targetLink: 'https://www.cnblogs.com/12lisu/p/18960989', title: '用好索引的10条军规' })">举报</a>
</div>
        