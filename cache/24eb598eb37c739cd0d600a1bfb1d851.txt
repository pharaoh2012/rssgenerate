
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/1312mn/p/18650335" title="发布于 2025-01-06 10:56">
    <span role="heading" aria-level="2">C#+ WPF 实现蓝牙转WIFI计步上位机</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<h2><span style="font-size: 16px">前言</span></h2>
<p><span style="font-size: 16px">一个WIFI上位机，接收底层MPU6050数据，途中转蓝牙从机透传，到蓝牙主机直连WIFI，PC端UDP通信，实现三轴加速度数据传送和计步功能。</span></p>
<h2><span style="font-size: 16px">项目介绍</span></h2>
<p><span style="font-size: 16px">本项目基于.NET平台，使用WPF开发了一个应用程序，用于实现MPU6050传感器数据从蓝牙模块传输到主机，并通过WiFi以UDP协议接收这些数据并进行可视化展示。</span></p>
<p><span style="font-size: 16px">具体而言，MPU6050作为从设备通过蓝牙连接到主控设备（蓝牙主机），再由主控设备经由WiFi网络将数据以UDP包的形式发送至服务器或客户端进行处理和图形化显示。</span></p>
<p><img src="https://img2024.cnblogs.com/blog/576536/202501/576536-20250103161030960-1962689606.jpg" width="700" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<h2><span style="font-size: 16px">项目运行环境</span></h2>
<p><span style="font-size: 16px">1、开发平台</span></p>
<p><span style="font-size: 16px">项目基于.NET Framework，采用 WPF 开发用户界面。</span></p>
<p><span style="font-size: 16px">2、集成开发环境</span></p>
<p><span style="font-size: 16px">Visual Studio 2019，确保已安装 C# 开发工作负载以支持项目开发与运行。</span></p>
<p><span style="font-size: 16px">3、启动项目</span></p>
<p><span style="font-size: 16px">获取源代码后，通过打开 BluetoothPC.sln 解决方案文件即可。确保所有依赖项正确配置后，直接运行解决方案，应用程序应能正常启动。</span></p>
<p><span style="font-size: 16px">4、用户界面特色</span></p>
<p><span style="font-size: 16px">应用程序配备了一个直观且美观的用户界面，图标设计精心，提供优秀的用户体验和视觉享受。</span></p>
<p><img src="https://img2024.cnblogs.com/blog/576536/202501/576536-20250103162006451-411890032.png" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<h2><span style="font-size: 16px">项目设计流程</span></h2>
<p><strong><span style="font-size: 16px">1、设计框架</span></strong></p>
<p><span style="font-size: 16px">前台XAML的UI设计不过多介绍，主要看设计需求，逃不开模板、触发器、动画、样式之类的技术。</span></p>
<p><span style="font-size: 16px">后台C#在UI主线程下开了三个子线程：</span></p>
<p><span style="font-size: 16px">1、UDP数据监听接收线程。</span></p>
<p><span style="font-size: 16px">2、三轴数据UI更新线程。</span></p>
<p><span style="font-size: 16px">3、计步和进度条数据更新线程。</span></p>
<p><span style="font-size: 16px">因没有碰到多个线程访问同一个UI控件或写同一个UI控件，所以没用到锁，但内部加了异步延迟，让UI更新顺滑一些。</span></p>
<p><strong><span style="font-size: 16px">2、服务器连接设计</span></strong></p>
<p><span style="font-size: 16px">UDP端IP地址和端口号需正常且有效，加了错误弹窗，若出现下图请重新输入：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/576536/202501/576536-20250103162138420-1551943097.jpg" alt="" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p><img src="https://img2024.cnblogs.com/blog/576536/202501/576536-20250103162155022-338774023.png" width="700" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p><strong><span style="font-size: 16px">3、三轴加速度显示</span></strong></p>
<p><span style="font-size: 16px">有硬件：成功连接上之后需配合底层硬件，这里是接收UDP发过来的3轴加速度值。</span></p>
<p><span style="font-size: 16px">无硬件：如果没有硬件也行，自行找个网络调试助手，开个UDP服务，本机连接就行，发送的数据需包含以下格式：</span></p>
<p><span style="font-size: 16px">任意字符（：1.23938 mG）任意字符。</span></p>
<p><span style="font-size: 16px">解释：</span></p>
<p><span style="font-size: 16px">发送过来的数据必须包含在 ：xxxx mG 内，冒号和mG不能少，可任意多组，每组代表一轴数据。</span></p>
<p><img src="https://img2024.cnblogs.com/blog/576536/202501/576536-20250103162243078-2052604697.png" width="700" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p><strong><span style="font-size: 16px">4、计步显示</span></strong></p>
<p><span style="font-size: 16px">利用三轴加速度提供的数据处理步数。需打开左下角计步控制按钮。</span></p>
<p><span style="font-size: 16px">打开后弹出提示：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/576536/202501/576536-20250103162326039-1182432051.png" width="700" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p><img src="https://img2024.cnblogs.com/blog/576536/202501/576536-20250103162355622-325153383.png" width="700" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p><span style="font-size: 16px">本计步算法仅支持手臂摆动的峰峰值计步，若有更好的算法请分享，万分感谢！！！</span></p>
<p><span style="font-size: 16px">计步程序如下</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">
 * valueNum - 存放三轴数据(x,y,z)的个数
 * tempValue - 用于存放计算阈值的波峰波谷差值的数组(在这个方法里存放值数组长度为5)
 * isDirectionUp - 是否上升的标志位
 * continueUpCount - 持续上升的次数
 * continueUpFormerCount - 上一点的持续上升的次数，为了记录波峰的上升次数
 * lastStatus - 上一点的状态，上升还是下降
 * peakOfWave - 波峰值
 * valleyOfWave - 波谷值
 * timeOfThisPeak - 此次波峰的时间
 * timeOfLastPeak - 上次波峰的时间
 * timeOfNow - 当前的时间
 * gravityOld - 上次传感器的值
 * initialValue - 动态阈值需要动态的数据，这个值用于这些动态数据的阈值,这个值是由大量数据得来的
 * ThreadValue - 初始阈值,这个值是由大量数据得来的
 * minValue - 初始最小值 计算出来的xyz数值乘重力加速度（9.8）,此为手机拿在手里（不摆臂）(由自己多次测试得出的值)
 * maxValue - 初始最大值 自己设定的最大值（我们定位2）乘重力加速度（9.8）,此为手机拿在手里（不摆臂）(由自己多次测试得出的值)
 * g - 重力加速度（9.8）
 * thisSteps 步数
</span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">int</span> valueNum = <span style="color: rgba(128, 0, 128, 1)">5</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">private double[] tempValue;</span>
<span style="color: rgba(0, 0, 255, 1)">private</span> List&lt;<span style="color: rgba(0, 0, 255, 1)">double</span>&gt; tempValue = <span style="color: rgba(0, 0, 255, 1)">new</span> List&lt;<span style="color: rgba(0, 0, 255, 1)">double</span>&gt;<span style="color: rgba(0, 0, 0, 1)">();
</span><span style="color: rgba(0, 0, 255, 1)">private</span> Boolean isDirectionUp = <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">int</span> continueUpCount = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">int</span> continueUpFormerCount = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> Boolean lastStatus = <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> peakOfWave = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> valleyOfWave = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> timeOfThisPeak = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> timeOfLastPeak = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> timeOfNow = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> gravityOld = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> initialValue = <span style="color: rgba(128, 0, 128, 1)">1.7</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> ThreadValue = <span style="color: rgba(128, 0, 128, 1)">2.0</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> minValue = <span style="color: rgba(128, 0, 128, 1)">11</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> maxValue = <span style="color: rgba(128, 0, 128, 1)">19.6</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> g = <span style="color: rgba(128, 0, 128, 1)">9.8</span><span style="color: rgba(0, 0, 0, 1)">;
</span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> thisSteps = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;   
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">当前步数</span>

<span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">double</span> StepsCopy = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;   
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">步数复制</span>

<span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 监测新的步数 如果检测到了波峰，并且符合时间差以及阈值的条件，则判定为1步
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 符合时间差条件，波峰波谷差值大于initialValue，则将该差值纳入阈值的计算中
</span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="_values"&gt;</span><span style="color: rgba(0, 128, 0, 1)">加速传感器三轴的平均值</span><span style="color: rgba(128, 128, 128, 1)">&lt;/param&gt;</span>
<span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> detectorNewStep(<span style="color: rgba(0, 0, 255, 1)">double</span><span style="color: rgba(0, 0, 0, 1)"> _values)
{
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (gravityOld == <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)
    {
        gravityOld </span>=<span style="color: rgba(0, 0, 0, 1)"> _values;
    }
    </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
    {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (detectorPeak(_values, gravityOld))
        {
            timeOfLastPeak </span>=<span style="color: rgba(0, 0, 0, 1)"> timeOfThisPeak;
            timeOfNow </span>= Convert.ToInt64((DateTime.UtcNow - <span style="color: rgba(0, 0, 255, 1)">new</span> DateTime(<span style="color: rgba(128, 0, 128, 1)">1970</span>, <span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span>, <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)).TotalMilliseconds);
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">时间差大于200ms，小于2s</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (((timeOfNow - timeOfLastPeak) &gt;= <span style="color: rgba(128, 0, 128, 1)">200</span>) &amp;&amp; ((timeOfNow - timeOfLastPeak) &lt;= <span style="color: rgba(128, 0, 128, 1)">2000</span>) &amp;&amp; ((peakOfWave - valleyOfWave) &gt;=<span style="color: rgba(0, 0, 0, 1)"> ThreadValue))
            {
                timeOfThisPeak </span>=<span style="color: rgba(0, 0, 0, 1)"> timeOfNow;
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">增加步数</span>
                thisSteps++<span style="color: rgba(0, 0, 0, 1)">;
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">增加步数复制</span>
                StepsCopy++<span style="color: rgba(0, 0, 0, 1)">;
            }
            </span><span style="color: rgba(0, 0, 255, 1)">if</span>(((timeOfNow - timeOfLastPeak) &gt;= <span style="color: rgba(128, 0, 128, 1)">200</span>) &amp;&amp; ((peakOfWave - valleyOfWave) &gt;=<span style="color: rgba(0, 0, 0, 1)"> initialValue))
            {
                timeOfThisPeak </span>=<span style="color: rgba(0, 0, 0, 1)"> timeOfNow;
                </span><span style="color: rgba(0, 0, 255, 1)">double</span> _diffWaveVal = peakOfWave -<span style="color: rgba(0, 0, 0, 1)"> valleyOfWave;
                ThreadValue </span>=<span style="color: rgba(0, 0, 0, 1)"> peak_Valley_Thread(_diffWaveVal);
            }
        }
        gravityOld </span>=<span style="color: rgba(0, 0, 0, 1)"> _values;
    }
}
</span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 监测波峰
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 以下四个条件判断为波峰
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 1.目前点为下降的趋势：isDirectionUp为false
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 2.之前的点为上升的趋势：lastStatus为true
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 3.到波峰为止，持续上升大于等于2次
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 4.波峰值大于minValue,小于maxValue
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 记录波谷值
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 1.观察波形图，可以发现在出现步子的地方，波谷的下一个就是波峰，有比较明显的特征以及差值
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 2.所以要记录每次的波谷值，为了和下次的波峰作对比
</span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="_newValue"&gt;&lt;/param&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="_oldValue"&gt;&lt;/param&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;&lt;/returns&gt;</span>
<span style="color: rgba(0, 0, 255, 1)">public</span> Boolean detectorPeak(<span style="color: rgba(0, 0, 255, 1)">double</span> _newValue, <span style="color: rgba(0, 0, 255, 1)">double</span><span style="color: rgba(0, 0, 0, 1)"> _oldValue)
{
    lastStatus </span>=<span style="color: rgba(0, 0, 0, 1)"> isDirectionUp;
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (_newValue &gt;=<span style="color: rgba(0, 0, 0, 1)"> _oldValue)
    {
        isDirectionUp </span>= <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
        continueUpCount</span>++<span style="color: rgba(0, 0, 0, 1)">;
    }
    </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
    {
        continueUpFormerCount </span>=<span style="color: rgba(0, 0, 0, 1)"> continueUpCount;
        continueUpCount </span>= <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
        isDirectionUp </span>= <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
    }

    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!isDirectionUp &amp;&amp; lastStatus &amp;&amp; (continueUpFormerCount &gt;= <span style="color: rgba(128, 0, 128, 1)">2</span> &amp;&amp; (_oldValue &gt;= minValue &amp;&amp; _oldValue &lt;<span style="color: rgba(0, 0, 0, 1)"> maxValue)))
    {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">满足上面波峰的四个条件，此时为波峰状态</span>
        peakOfWave =<span style="color: rgba(0, 0, 0, 1)"> _oldValue;
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
    }
    </span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span> (!lastStatus &amp;&amp;<span style="color: rgba(0, 0, 0, 1)"> isDirectionUp)
    {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">满足波谷条件，此时为波谷状态</span>
        valleyOfWave =<span style="color: rgba(0, 0, 0, 1)"> _oldValue;
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
    }
    </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
    {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
    }
}
</span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 阈值的计算
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 1.通过波峰波谷的差值计算阈值
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 2.记录4个值，存入tempValue[] 数组中
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 3.在将数组传入函数averageValue中计算阈值
</span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="_value"&gt;&lt;/param&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;&lt;/returns&gt;</span>
<span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">double</span> peak_Valley_Thread(<span style="color: rgba(0, 0, 255, 1)">double</span><span style="color: rgba(0, 0, 0, 1)"> _value)
{
    </span><span style="color: rgba(0, 0, 255, 1)">double</span> _tempThread =<span style="color: rgba(0, 0, 0, 1)"> ThreadValue;
    List</span>&lt;<span style="color: rgba(0, 0, 255, 1)">double</span>&gt; _tempValue = <span style="color: rgba(0, 0, 255, 1)">new</span> List&lt;<span style="color: rgba(0, 0, 255, 1)">double</span>&gt;<span style="color: rgba(0, 0, 0, 1)">(tempValue);
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (tempValue.Count &lt;<span style="color: rgba(0, 0, 0, 1)"> valueNum)
    {
        tempValue.Add(_value);
    }
    </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
    {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">tempValue数组长度=valueNum=5</span>
        _tempThread =<span style="color: rgba(0, 0, 0, 1)"> averageValue(tempValue);

        _tempValue.RemoveAt(</span><span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">);
        _tempValue.Add(_value);
        tempValue </span>=<span style="color: rgba(0, 0, 0, 1)"> _tempValue;
    }
    </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> _tempThread;
}
</span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;summary&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 梯度化阈值
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 1.计算数组的均值
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 2.通过均值将阈值梯度化在一个范围里
</span><span style="color: rgba(128, 128, 128, 1)">///</span><span style="color: rgba(0, 128, 0, 1)"> 这些数据是通过大量的统计得到的
</span><span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;/summary&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;param name="_value"&gt;&lt;/param&gt;</span>
<span style="color: rgba(128, 128, 128, 1)">///</span> <span style="color: rgba(128, 128, 128, 1)">&lt;returns&gt;&lt;/returns&gt;</span>
<span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">double</span> averageValue(List&lt;<span style="color: rgba(0, 0, 255, 1)">double</span>&gt;<span style="color: rgba(0, 0, 0, 1)"> _value)
{
    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (_value.Count != <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">)
    {
        </span><span style="color: rgba(0, 0, 255, 1)">double</span> _ave = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">foreach</span> (<span style="color: rgba(0, 0, 255, 1)">double</span> i <span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> _value)
            _ave </span>+=<span style="color: rgba(0, 0, 0, 1)"> i;
        _ave </span>= _ave /<span style="color: rgba(0, 0, 0, 1)"> _value.Count;
        </span><span style="color: rgba(0, 0, 255, 1)">if</span>(_ave &gt;= <span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">)
        {
            _ave </span>= <span style="color: rgba(128, 0, 128, 1)">4.3</span><span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span> (_ave &gt;= <span style="color: rgba(128, 0, 128, 1)">7</span> &amp;&amp; _ave &lt; <span style="color: rgba(128, 0, 128, 1)">8</span><span style="color: rgba(0, 0, 0, 1)">)
        {
            _ave </span>= <span style="color: rgba(128, 0, 128, 1)">3.3</span><span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span> (_ave &gt;= <span style="color: rgba(128, 0, 128, 1)">4</span> &amp;&amp; _ave &lt; <span style="color: rgba(128, 0, 128, 1)">7</span><span style="color: rgba(0, 0, 0, 1)">)
        {
            _ave </span>= <span style="color: rgba(128, 0, 128, 1)">2.3</span><span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">else</span> <span style="color: rgba(0, 0, 255, 1)">if</span> (_ave &gt;= <span style="color: rgba(128, 0, 128, 1)">3</span> &amp;&amp; _ave &lt; <span style="color: rgba(128, 0, 128, 1)">4</span><span style="color: rgba(0, 0, 0, 1)">)
        {
            _ave </span>= <span style="color: rgba(128, 0, 128, 1)">2.0</span><span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
        {
            _ave </span>= <span style="color: rgba(128, 0, 128, 1)">1.7</span><span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> _ave;
    }
    </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)">
    {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">1.7</span><span style="color: rgba(0, 0, 0, 1)">;
    }
}</span></pre>
</div>
<p><span style="font-size: 16px">计步效果如下所示：</span></p>
<p><img src="https://img2024.cnblogs.com/blog/576536/202501/576536-20250103162432686-1398022760.png" width="700" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<p><span style="font-size: 16px">开启步数控制按钮后总步数累加，进度条进度为50步，每到达50步距离弹出提示框，计步结束也弹提示框通知。</span></p>
<p><strong><span style="font-size: 16px">5、倾力UI按钮设计</span></strong></p>
<p><span style="font-size: 16px">设计了一组拟物化按钮，目前无任何功能，有需要的小伙伴自行更改设计功能。</span></p>
<p><img src="https://img2024.cnblogs.com/blog/576536/202501/576536-20250103162538968-383678942.jpg" width="700" loading="lazy" style="display: block; margin-left: auto; margin-right: auto"></p>
<h2><span style="font-size: 16px">项目地址</span></h2>
<p><span style="font-size: 16px"><strong>Gitee：</strong><a href="https://gitee.com/tytokongjian/StepCountingUpperPC" rel="noopener nofollow" target="_blank">https://gitee.com/tytokongjian/StepCountingUpperPC</a></span></p>
<h2><span style="font-size: 16px">总结</span></h2>
<p><span style="font-size: 16px">以上仅展示了蓝牙转WIFI计步上位机的部分功能。更多实用特性和详细信息，请大家访问项目地址。</span></p>
<p><span style="font-size: 16px">希望通过本文能为上位机机开发方面提供有价值的参考。欢迎在评论区留言交流，分享您的宝贵经验和建议。</span></p>
<h2><span class="md-plain md-expand" style="font-size: 16px">最后</span></h2>
<p><span style="font-size: 16px">如果你觉得这篇文章对你有帮助，不妨点个赞支持一下！你的支持是我继续分享知识的动力。如果有任何疑问或需要进一步的帮助，欢迎随时留言。</span></p>
<p><span style="font-size: 16px">也可以加入微信公众号<strong>[DotNet技术匠]</strong>&nbsp;社区，与其他热爱技术的同行一起交流心得，共同成长！<strong>优秀是一种习惯，欢迎大家留言学习！</strong></span></p>
<p><img src="https://img2024.cnblogs.com/blog/576536/202408/576536-20240814113403514-910171896.png" alt="" style="display: block; margin-left: auto; margin-right: auto"></p>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.9207897240659723" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-06 10:57">2025-01-06 10:56</span>&nbsp;
<a href="https://www.cnblogs.com/1312mn">小码编匠</a>&nbsp;
阅读(<span id="post_view_count">473</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18650335" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18650335);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18650335', targetLink: 'https://www.cnblogs.com/1312mn/p/18650335', title: 'C#+ WPF 实现蓝牙转WIFI计步上位机' })">举报</a>
</div>
        