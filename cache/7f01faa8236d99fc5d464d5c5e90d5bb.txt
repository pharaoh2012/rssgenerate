
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/t0213/p/18722269" title="发布于 2025-02-18 16:30">
    <span role="heading" aria-level="2">挑战分库分表后实现跨分页查询</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>想象你有一个图书馆（单库单表），所有书按顺序放在书架上。当你要找第100-110本书时，直接数到第100本就能拿到。但图书馆的书爆炸式增长后，馆长决定：</p>
<ol>
<li>
<p><strong>分库</strong>：把书分到10个房间（10个数据库）</p>
</li>
<li>
<p><strong>分表</strong>：每个房间再分成20个书架（20张表）<br>每个书架只放特定规则的书（比如按ID取模：<code>ID % 200</code>）</p>
</li>
</ol>
<p><strong>问题来了</strong>：<br>当用户要求「按时间倒序排列，显示第1000-1010条数据」时：</p>
<ul>
<li>
<p>每个房间的书架都是独立排序的</p>
</li>
<li>
<p>无法直接知道全局第1000条数据在哪里</p>
</li>
</ul>
<p><strong>解决方案：</strong></p>
<p>想象你管理10个快递分拣站（分库分表），每个站点有自己的包裹编号。现在要找出全国第1000-1010个发出的包裹：</p>
<ul>
<li>
<p><strong>笨方法</strong>：让所有站点把前1010个包裹发到总部，总部排序后挑出需要的（全局排序法）</p>
</li>
<li>
<p><strong>聪明方法</strong>：</p>
<ol>
<li>
<p>先问每个站点第1010个包裹的发货时间</p>
</li>
<li>
<p>找到全国第1010个包裹的时间</p>
</li>
<li>
<p>让各站点只发送比这个时间晚的包裹，再次排序（二次查询法）</p>
</li>
</ol>
</li>
<li>
<p><strong>最懒但有效的方法</strong>：把所有包裹信息抄一份到总部的智能黑板（Elasticsearch），随时查黑板即可！</p>
</li>
</ul>
<p>下面具体说下各个方案、优缺点和做法：</p>
<table class=" cke_show_border">
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>技术实现难度</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>全局排序法</td>
<td>数据量小，分片少</td>
<td>低</td>
<td>性能差，深分页爆炸</td>
</tr>
<tr>
<td>二次查询法</td>
<td>排序字段有索引，分片较多</td>
<td>中</td>
<td>需要两次查询</td>
</tr>
<tr>
<td>游标分页法</td>
<td>有全局有序字段（如ID、时间戳）</td>
<td>低</td>
<td>不支持随机跳页</td>
</tr>
<tr>
<td>搜索引擎辅助</td>
<td>高频复杂查询，容忍秒级延迟</td>
<td>高</td>
<td>
<p>维护成本高，数据延迟</p>
</td>
</tr>
</tbody>
</table>
<h3><strong>（1）全局排序法（简单但低效）</strong></h3>
<p><strong>实现步骤</strong>：</p>
<ol>
<li>
<p>每个分片独立执行<code>ORDER BY create_time DESC LIMIT 0, 1010</code></p>
</li>
<li>
<p>把所有分片的结果汇总到一个中心节点</p>
</li>
<li>
<p>中心节点对所有数据进行全局排序，再取第1000-1010条</p>
</li>
</ol>
<p><strong>缺点</strong>：</p>
<ul>
<li>
<p>分片数越多，数据传输量指数级增长</p>
</li>
<li>
<p>深分页（offset很大）时性能灾难（例如：offset=100万）</p>
</li>
</ul>
<h3><strong>（2）二次查询法（优化性能）</strong></h3>
<p><strong>核心思路</strong>：避免全量数据传输，分两次查询缩小范围</p>
<p><strong>步骤示例</strong>（查询第1000-1010条）：</p>
<ol>
<li>
<p><strong>第一次查询</strong>：每个分片返回前1010条数据的<strong>最小时间戳</strong></p>
<ul>
<li>
<p>例如分片1的最小时间戳是T1，分片2是T2...</p>
</li>
</ul>
</li>
<li>
<p>取所有分片中第1010小的全局时间戳T_global</p>
</li>
<li>
<p><strong>第二次查询</strong>：各分片查询<code>create_time &gt;= T_global</code>的数据</p>
</li>
<li>
<p>汇总后再次排序取最终结果</p>
</li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li>
<p>大幅减少数据传输量</p>
</li>
<li>
<p>适合排序字段有索引的情况（如时间戳）</p>
</li>
</ul>
<h3><strong>（3）游标分页法（避免深分页）</strong></h3>
<p><strong>核心思路</strong>：用连续且唯一的字段（如自增ID、时间戳）作为游标</p>
<p><strong>优势</strong>：</p>
<ul>
<li>
<p>完全避免<code>offset</code>带来的性能问题</p>
</li>
<li>
<p>天然适合分库分表，每个分片只需按游标条件过滤</p>
</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>
<p>必须有一个全局有序且唯一的字段</p>
</li>
<li>
<p>用户无法直接跳转到任意页码（如第1000页）</p>
</li>
</ul>
<p>（4）<strong>搜索引擎辅助（终极武器）</strong></p>
<p><strong>适用场景</strong>：高频复杂分页查询<br><strong>实现方式</strong>：</p>
<ol>
<li>
<p>将分库分表的数据实时同步到Elasticsearch/Solr</p>
</li>
<li>
<p>所有分页查询直接走搜索引擎</p>
</li>
<li>
<p>搜索引擎内部维护全局排序</p>
</li>
</ol>
<p><strong>优势</strong>：</p>
<ul>
<li>
<p>完全屏蔽分库分表复杂性</p>
</li>
<li>
<p>支持复杂条件过滤+高并发查询</p>
</li>
</ul>
<p><strong>代价</strong>：</p>
<ul>
<li>
<p>需要维护额外系统，数据一致性延迟增加</p>
</li>
</ul>
<h3><strong>实际开发中的建议</strong></h3>
<ol>
<li>
<p><strong>优先使用游标分页</strong>：</p>
<ul>
<li>
<p>如App的瀑布流页面，用户只会不断下滑，不需要跳页</p>
</li>
</ul>
</li>
<li>
<p><strong>限制最大分页深度</strong>：</p>
<ul>
<li>
<p>例如最多允许查看前100页，防止恶意深分页攻击</p>
</li>
</ul>
</li>
<li>
<p><strong>结合业务优化</strong>：</p>
<ul>
<li>
<p>电商按价格排序时，可预先对价格分段（0-100元、100-200元...）</p>
</li>
</ul>
</li>
<li>
<p><strong>终极方案</strong>：</p>
<ul>
<li>
<p>分库分表+Elasticsearch组合，牺牲一定实时性换取高性能查询</p>
</li>
</ul>
</li>
</ol>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.5710227691921296" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-02-18 16:31">2025-02-18 16:30</span>&nbsp;
<a href="https://www.cnblogs.com/t0213">无界行者</a>&nbsp;
阅读(<span id="post_view_count">236</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18722269" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18722269);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18722269', targetLink: 'https://www.cnblogs.com/t0213/p/18722269', title: '挑战分库分表后实现跨分页查询' })">举报</a>
</div>
        