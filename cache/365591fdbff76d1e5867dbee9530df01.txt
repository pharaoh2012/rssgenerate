
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/ofnoname/p/19034868" title="发布于 2025-08-18 17:53">
    <span role="heading" aria-level="2">块状数组超级兵器：区间动态排名问题</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>上期回顾：<a href="https://www.cnblogs.com/ofnoname/p/18994725" target="_blank">https://www.cnblogs.com/ofnoname/p/18994725</a>，<a href="https://www.cnblogs.com/ofnoname/p/19034861" target="_blank">https://www.cnblogs.com/ofnoname/p/19034861</a></p>
<p>我们学习了如何把一维数组“分块”，在每块里维护额外信息，从而在查询与修改之间取得平衡。通过解决区间众数问题，我们还发现分块不只是切切数组，它还能在块的层次上维护结构化的信息。</p>
<h2 id="动态区间第-k-小--排名问题">动态区间第 k 小 / 排名问题</h2>
<p>这次，我们要解决了另一个经典的问题是维护一个随时要查询排名的数组：</p>
<ul>
<li>数组是可变的，存在单点修改操作。</li>
<li>我们需要在区间上回答一系列查询，包括：某段区间的第 k 小、某值的排名和某数前驱 / 后继</li>
<li>而且值域可能很大。</li>
</ul>
<p>参考题目：<a href="https://www.luogu.com.cn/problem/P3380" target="_blank" rel="noopener nofollow">https://www.luogu.com.cn/problem/P3380</a>。虽然题目名称是“树套树”，但是块状数组也是正确的做法。</p>
<p>相比基础的“求和/最值”类问题，这里涉及排名、顺序统计、前驱后继，已经非常接近数据结构的“核心需求”。能解决它，意味着我们真正把块状数组推向了“动态序列查询”的前沿。</p>
<p>为了应对挑战，我们会展示两种思路：</p>
<ol>
<li>
<p><strong>位置分块 + 块内有序数组</strong><br>
使用最原始暴力的思路。借助块内排序和二分，我们可以高效实现排名、前驱后继，并通过“二分值域 + 排名”解决第 k 小。</p>
</li>
<li>
<p><strong>位置分块 + 值域分块（两层分块）</strong><br>
再进一步，把值域也分块，像之前的区间众数问题一样，预处理数字的出现个数，并维护两层前缀计数。彻底摆脱值域二分。</p>
</li>
</ol>
<h2 id="思路一位置分块--块内有序数组">思路一：位置分块 + 块内有序数组</h2>
<p>将数组分块切割的同时，每个块再维护一个有序数组。这样一来：</p>
<ul>
<li>修改时：在块内删除旧值、插入新值（同样也更改相应的有序数组）。</li>
<li>查询时：中间完整块可以挨个用二分在有序数组里快速处理。</li>
</ul>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202508/1545207-20250818115741710-224170938.png" alt="image" loading="lazy"></p>
<hr>
<h3 id="操作拆解">操作拆解</h3>
<h4 id="区间内某值的排名">区间内某值的排名</h4>
<p>查询排名即查找 <code>&lt; z</code> 的数字的个数，边界块直接计数，中间块每一块都二分查找一次。假定 <span class="math inline">\(B\)</span> 为块长，<span class="math inline">\(T = \lceil\frac NB\rceil\)</span>，总复杂度<span class="math inline">\(O(B + T\log B)\)</span>，若块长取根号，则为<span class="math inline">\(O(\sqrt n\ \log n)\)</span></p>
<pre><code class="language-cpp">auto get_rank = [&amp;](int x, int y, int z) {
    int p = b[x], q = b[y], res = 1;
    if (q - p &lt;= 1) {
        for (int i = x; i &lt;= y; i++) res += a[i] &lt; z;
        return res;
    }

    for (int i = x; i &lt;= R[p]; i++) res += a[i] &lt; z;
    for (int i = L[q]; i &lt;= y; i++) res += a[i] &lt; z;
    for (int i = p + 1; i &lt; q; i++) {
        res += upper_bound(sorted[i].begin(), sorted[i].end(), z - 1) - sorted[i].begin();
    }
    return res;
};
</code></pre>
<h4 id="单点修改">单点修改</h4>
<p>将 a 和 sorted 对应位置都修改就好。在对应块内删除旧值，再用二分找到位置插入新值。注意有序数组仅修改了一个数字，无需重新排序。效率<span class="math inline">\(O(B)\)</span></p>
<pre><code class="language-cpp">auto &amp;t = sorted[b[--x]]; // 例题是 1-based
t.erase(lower_bound(t.begin(), t.end(), a[x]));
t.insert(lower_bound(t.begin(), t.end(), y), y);
a[x] = y;
continue;
</code></pre>
<h4 id="前驱--后继">前驱 / 后继</h4>
<p>以前驱为例，边界块暴力寻找前驱。中间块在有序数组里二分查找前驱，取最大的一个前驱即可。复杂度和查排名显然相同。</p>
<pre><code class="language-cpp">int ans = INT_MIN + 1;
int p = b[x], q = b[y];
if (p == q) {
    for (int i = x; i &lt;= y; i++) {
        if (a[i] &lt; z) ans = max(ans, a[i]);
    }
} else {
    for (int i = x; i &lt;= R[p]; i++) {
        if (a[i] &lt; z) ans = max(ans, a[i]);
    }
    for (int i = L[q]; i &lt;= y; i++) {
        if (a[i] &lt; z) ans = max(ans, a[i]);
    }
    for (int i = p + 1; i &lt; q; i++) {
        auto &amp;vec = sorted[i];
        int pos = lower_bound(vec.begin(), vec.end(), z) - vec.begin();
        if (pos &gt; 0) ans = max(ans, vec[pos - 1]);
    }
}
cout &lt;&lt; ans &lt;&lt; "\n";
</code></pre>
<h4 id="区间第-k-小--难点">区间第 k 小 —— 难点</h4>
<p>之前的几个操作都顺理成章非常简单，但区间第 k 小却不能简单得出。因为这个问题不能直接用块内二分，需要先确定答案值。</p>
<p>所以只能退而求其次，既然可以实现某数的排名，那么可以倒过来用二分答案法来<strong>二分值域</strong>，每次调用 opt1 的“排名函数”，判定“≤ mid 的数量”是否 ≥ k。最终得到答案。</p>
<p>这是耗时最高的操作，若 <span class="math inline">\(V\)</span> 是值域大小，一次查询最多需要 <span class="math inline">\(O(\log V)\)</span> 次排名调用，总计 <span class="math inline">\(O((B + T\log B)\log V)\)</span>。</p>
<pre><code class="language-cpp">int k = z;
long long lo = (long long)INT_MIN + 1, hi = (long long)INT_MAX - 1;
while (lo &lt; hi) {
    long long mid = (lo + hi) &gt;&gt; 1;
    int cnt = get_rank(x, y, (int)mid + 1) - 1; // ≤ mid 的数量
    if (cnt &gt;= k) hi = mid;
    else lo = mid + 1;
}
cout &lt;&lt; (int)lo &lt;&lt; "\n";
</code></pre>
<hr>
<h3 id="复杂度分析">复杂度分析</h3>
<p>之前的问题里，我们总是习惯性的将块长设置为根号，这是通常的最优选择，但是这道题目可能不一样。我们设：</p>
<ul>
<li><strong>边界代价</strong>：<span class="math inline">\(O(B)\)</span>，因为每次要扫两端最多 2B ，平均 B 个元素。</li>
<li><strong>完整块代价</strong>：每块二分 <span class="math inline">\(O(\log B)\)</span>，共 <span class="math inline">\(O(\frac nB·\log B)\)</span>。</li>
</ul>
<p>每次查询总代价：</p>
<p></p><div class="math display">\[  O( B + \frac nB·\log B )
\]</div><p></p><p>说到底，由于边界代价和完整块代价不均衡（多一个二分查找），取根号不再是最佳大小。</p>
<p>不过，上式的最值不能直接简单求出。经过枚举，<span class="math inline">\(n = 50000\)</span> 时，<span class="math inline">\(B = 1368\)</span> 达到最小，实际上，考虑到两项的系数比，还可以再大一些。在运行时间测试里，这比取<span class="math inline">\(\sqrt n = 223\)</span> 快了大约四至五倍。</p>
<h2 id="思路二位置分块--值域分块">思路二：位置分块 + 值域分块</h2>
<p>思路一最大的瓶颈是 <strong>opt 2（区间第 k 小）</strong> 必须二分整个值域，每次调用一次排名函数，总复杂度带上了一个 <span class="math inline">\(\log V\)</span>。当值域很大时，这就是拖慢速度的根源。</p>
<p>如果允许离线或者保证值域范围较小，我们还有一个思路，那就是“值域分块”。他可以找到第 k 小。并顺带优化了其他操作的复杂度。</p>
<h3 id="数据结构设计">数据结构设计</h3>
<ol>
<li>
<p><strong>坐标压缩</strong>：将值域分块要求值域足够小，若值域大但是允许离线（如本题），首先把所有可能出现的值（初始值、修改值、查询参数）离散化，映射到 <code>[0..vn-1]</code>。vn 的数量级为 <span class="math inline">\(O(n + m)\)</span>。</p>
</li>
<li>
<p><strong>值域分块</strong>：除了按数组下标的分块之外，再把离散值 <code>[0..vn-1]</code> 按块长 <code>vB</code> 划分为值块。这样每一个值还有了一个所属的值块。</p>
</li>
</ol>
<ul>
<li>维护 <code>cnt[i][val]</code>：从位置块 0 到位置块 <code>i</code> 为止，具体值 <code>val</code> 出现的次数，这需要 <span class="math inline">\(O(T(n + m))\)</span>。</li>
<li>维护 <code>vcnt[i][vb]</code>：从位置块 0 到位置块 <code>i</code> 为止，值块 <code>vb</code> 内元素的总次数，这需要 <span class="math inline">\(O(n + TT_{val})\)</span>，比上面小得多可略去。</li>
</ul>
<pre><code class="language-cpp">// 到块 i（含）为止，具体值 val 的出现次数：cnt[i][val]
vector&lt;vector&lt;int&gt;&gt; cnt(T, vector&lt;int&gt;(vn, 0));
for (int i = 0; i &lt; T; i++) {
    if (i) cnt[i] = cnt[i - 1];
    for (int j = L[i]; j &lt;= R[i]; j++) {
        cnt[i][ a[j] ]++;
    }
}

// 到块 i（含）为止，值块 VB 的出现次数：vcnt[i][VB]
vector&lt;vector&lt;int&gt;&gt; vcnt(T, vector&lt;int&gt;(vT, 0));
for (int i = 0; i &lt; T; i++) {
    if (i) vcnt[i] = vcnt[i - 1];
    for (int j = L[i]; j &lt;= R[i]; j++) {
        vcnt[i][ vb[a[j]] ]++;
    }
}

auto get_cnt_val_in_full_blocks = [&amp;](int pblk, int qblk, int val)-&gt;int {
    // 完整块范围 (pblk+1 .. qblk-1) 内 某具体值 val 的出现次数
    if (pblk + 1 &gt; qblk - 1) return 0;
    return cnt[qblk - 1][val] - (pblk &gt;= 0 ? cnt[pblk][val] : 0);
};

auto get_cnt_vb_in_full_blocks = [&amp;](int pblk, int qblk, int VB)-&gt;int {
    // 完整块范围 (pblk+1 .. qblk-1) 内 值块 VB 的出现次数
    if (pblk + 1 &gt; qblk - 1) return 0;
    return vcnt[qblk - 1][VB] - (pblk &gt;= 0 ? vcnt[pblk][VB] : 0);
};
</code></pre>
<p>假定 m 和 n 同阶，且简单根号分块的话，复杂度为 <span class="math inline">\(O(n\sqrt n)\)</span>。有了这两个数组，我们就可以用前缀相减 <span class="math inline">\(O(1)\)</span> 查询连续块内的某值或某值块出现次数了。这时我们发现，可以像处理通常的块状数组一样来处理这个值域。</p>
<p><img src="https://img2024.cnblogs.com/blog/1545207/202508/1545207-20250818142432374-1493763176.png" alt="image" loading="lazy"></p>
<h3 id="操作拆解-1">操作拆解</h3>
<h4 id="排名">排名</h4>
<p>零散部分暴力。而对于中间完整块：</p>
<ul>
<li>值块 <code>&lt; vb(z)</code> 的贡献用 <code>vcnt</code> 一次性加。</li>
<li>z 所在值块的 <code>&lt; z</code> 部分，用 <code>cnt</code> 精确加。</li>
</ul>
<p>这样，就把值域也拆解为“边界块”和“完整快”了，时间：<span class="math inline">\(O(B + T_{val}+B_{val})\)</span>。</p>
<pre><code class="language-cpp">int zid = id[z];
int res = 1;
if (qblk - p &lt;= 1) {
    for (int i = x; i &lt;= y; ++i) res += (a[i] &lt; zid);
} else {
    // 边界段
    for (int i = x; i &lt;= R[p]; ++i) res += (a[i] &lt; zid);
    for (int i = L[qblk]; i &lt;= y; ++i) res += (a[i] &lt; zid);

    int vm = vb[zid]; // 完整块：先加值块，再加该值块内的具体值
    for (int V = 0; V &lt; vm; ++V) res += get_cnt_vb_in_full_blocks(p, qblk, V); // 值块 &lt; vm 的整体贡献
    for (int v = VL[vm]; v &lt; zid; ++v) res += get_cnt_val_in_full_blocks(p, qblk, v); // vm 内 &lt; zid 的具体值
}
cout &lt;&lt; res &lt;&lt; "\n";
</code></pre>
<h4 id="第-k-小">第 k 小</h4>
<p>在这种情况下，第 k 小就非常简单。先在值块层面累加值块桶，累加时累积排名，逐个遍历获取目标排名在哪个值块。再在该值块内逐个具体值，用 <code>cnt</code> 精确扫描，直到累计到 k。</p>
<p>对于零散部分，为他们也创建一个值块桶，累加时和逐个遍历时也算上即可。复杂度与上相同。</p>
<pre><code class="language-cpp">// 先统计边界段在“值块层面”的出现次数
vector&lt;int&gt; addVB(vT, 0);
vector&lt;int&gt; tmpIds; tmpIds.reserve(2*B);

for (int i = x; i &lt;= min(y, R[p]); ++i) {
    ++addVB[ vb[a[i]] ];
    tmpIds.push_back(a[i]);
}
if (p != qblk) {
    for (int i = L[qblk]; i &lt;= y; ++i) {
        ++addVB[ vb[a[i]] ];
        tmpIds.push_back(a[i]);
    }
}

int acc = 0, Bstar = -1;
for (int V = 0; V &lt; vT; ++V) {
    int have = get_cnt_vb_in_full_blocks(p, qblk, V) + addVB[V];
    if (acc + have &gt;= z) { Bstar = V; break; }
    acc += have;
}

// 在值块 Bstar 内精确到具体值
vector&lt;int&gt; addVAL(vB, 0);
for (int idv : tmpIds) if (VL[Bstar] &lt;= idv &amp;&amp; idv &lt;= VR[Bstar]) ++addVAL[idv - VL[Bstar]];

int ansId = -1;
for (int val = VL[Bstar]; val &lt;= VR[Bstar] &amp;&amp; val &lt; vn; ++val) {
    int have = get_cnt_val_in_full_blocks(p, qblk, val) + addVAL[val - VL[Bstar]];
    if (acc + have &gt;= z) { ansId = val; break; }
    acc += have;
}
cout &lt;&lt; raw[ansId] &lt;&lt; "\n";
</code></pre>
<h4 id="前驱后继">前驱/后继</h4>
<p>以前驱为例，零散部分暴力。完整块我们先在 z 所在的值块的 z 的左半边里扫具体值。若有则是答案；若没有，再向左逐个值块找：</p>
<ul>
<li>先用 <code>vcnt</code> 判断该值块是否可能含解；</li>
<li>若可能，再在块内用 <code>cnt</code> + 边界桶检查精确位置。</li>
</ul>
<p>复杂度仍然与上相同。</p>
<pre><code class="language-cpp">int zid = id[z], vm = vb[zid], res = INT_MIN + 1;
if (qblk - p &lt;= 1) {
    for (int i = x; i &lt;= y; ++i)
        if (a[i] &lt; zid) res = max(res, a[i]);
}
else {
    for (int i = zid - 1; i &gt;= VL[vm]; --i)
        if (get_cnt_val_in_full_blocks(p, qblk, i) &gt; 0) {
            res = i; goto opt4;
        }
    for (int i = vm-1; i &gt;= 0; --i)
        if (get_cnt_vb_in_full_blocks(p, qblk, i) &gt; 0) {
            // 该值块内找最大
            for (int v = VR[i]; v &gt;= VL[i]; --v)
                if (get_cnt_val_in_full_blocks(p, qblk, v) &gt; 0) {
                    res = v; goto opt4;
                }
        }
    // 处理边界
    opt4: for (int i = x; i &lt;= R[p]; ++i)
            if (a[i] &lt; zid) res = max(res, a[i]);
        for (int i = L[qblk]; i &lt;= y; ++i)
            if (a[i] &lt; zid) res = max(res, a[i]);
}
cout &lt;&lt; (res == INT_MIN + 1 ? INT_MIN + 1 : raw[res]) &lt;&lt; "\n";
</code></pre>
<h4 id="修改">修改</h4>
<p>直接把旧值删掉，新值加上即可。不过，我们维护的是前缀数组，所以需要对所有后续位置块的 <code>cnt</code> 和 <code>vcnt</code> 修正。一共是 <span class="math inline">\(O(T)\)</span>。</p>
<pre><code class="language-cpp">int old = a[--x];
y = id[y];
if (old == y) continue; // 无需修改
int pblk = b[x];
// 从该位置块开始，所有后缀块前缀都要修正一次
for (int i = pblk; i &lt; T; i++) {
    cnt[i][old]--; cnt[i][y]++;
    vcnt[i][ vb[old] ]--; vcnt[i][ vb[y] ]++;
}
a[x] = y;
continue;
</code></pre>
<hr>
<p>思路二的关键在于，直接获取连续块里的值域信息。而处理值域时，<strong>先定位值块</strong>，再块内精确。就像“先确定答案在第几本书，再翻那本书找页码”，效率高很多。</p>
<h3 id="复杂度分析-1">复杂度分析</h3>
<p>原题目的 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(m\)</span> 相等，且值域稀疏（<span class="math inline">\(n + m\)</span>），我们直接对位置和值域都以根号分块，这样可以简明看出预处理为 <span class="math inline">\(O(n\sqrt n)\)</span>，所有单次操作均为 <span class="math inline">\(O(\sqrt n)\)</span> 更加优秀。接下来我们考虑其他情况。</p>
<p><strong>值块长度</strong>仅影响查询，根据均值不等式显然应该直接取根号，独立最优。</p>
<p>而<strong>位置块的长度</strong>影响修改（<span class="math inline">\(O(B)\)</span>）和查询（<span class="math inline">\(O(\frac nB)\)</span>）形成均值不等式，所以若修改操作和查询操作相当，则取根号最优；若修改操作偏多，则块长应加大，反之亦然。</p>
<p>若 <span class="math inline">\(m\)</span> 很大，则预处理时间会被查询和更新淹没，但若 <span class="math inline">\(m\)</span> 不是很大，把预处理也纳入考虑（<span class="math inline">\(O(\frac nB(n + m)\)</span>)），则块长增加时，预处理和修改效率提高但查询效率降低，根据<span class="math inline">\(\frac nm\)</span> 的值可以找到一个效率极大值。</p>
<p>另外，将频次数组设计为前缀数组，就是为了可以 <span class="math inline">\(O(1)\)</span> 查询，这样查询极快但修改时的修改量大。若修改操作明显过多，除了增加块长，还可以：</p>
<ul>
<li>改用树状数组来维护，这样修改的时间将大幅减少到 <span class="math inline">\(O(\log T)\)</span>，但查询时会也多出一个 <span class="math inline">\(O(\log T)\)</span>。</li>
<li>“时间分块”摊薄更新。每一个时间块里的所有修改只记成“挂起变更”（存一个列表），在查询时将所有挂起的变更考虑上，而每个时间块结束后，才统一更新一次</li>
</ul>
<p>回到本题，假定所有操作数量相同，<span class="math inline">\(n\)</span> 和 <span class="math inline">\(m\)</span> 相等，那么查询操作实际上是修改的大约 4 倍。我们可以大致求解下面式子的最小值：</p>
<p></p><div class="math display">\[\frac nB(n+m) + (\frac 45B + \frac {n}{5B})m = (\frac {11n}{5B} + \frac 45B )n
\]</div><p></p><p>得到最优的位置块长是 <span class="math inline">\(B = \sqrt{\frac{11n}4}\)</span>，n 最大时约 371。得到了很不错的运行结果</p>
<h2 id="总结">总结</h2>
<p>解决了这个典型的“带修改的区间排名查询”问题，我们新学，深化了很多对<strong>块状数组</strong>的理解。通过两个不同的思路，我们不仅解决了具体问题，还学到了更通用的算法思想：</p>
<ol>
<li>
<p><strong>块长选择</strong>：<br>
块长并不是总是 <span class="math inline">\(\sqrt{n}\)</span>，有时需要重新计算最优块长保证折中。</p>
</li>
<li>
<p><strong>值域压缩与双层分块</strong>：<br>
当值域巨大时，单纯位置分块已经不够用。我们通过离线+坐标压缩，把问题转化到 <span class="math inline">\([0..vn-1]\)</span>，再引入“值域分块 + 位置分块”的双层结构，使得查询复杂度进一步下降，展示了“维度扩展”的思想。</p>
</li>
<li>
<p><strong>预处理与修改的权衡</strong>：<br>
值域分块方案在查询几乎常数的同时，修改代价显著增加；而如果修改很多，则应考虑 BIT 或其他动态结构。我们看到了一种很重要的思想：<strong>不能孤立看待复杂度，而是要结合实际操作分布来权衡</strong>。</p>
</li>
</ol>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.013194444444444444" data-date-updated="2025-08-18 18:12">2025-08-18 17:53</span>&nbsp;
<a href="https://www.cnblogs.com/ofnoname">Ofnoname</a>&nbsp;
阅读(<span id="post_view_count">122</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19034868);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19034868', targetLink: 'https://www.cnblogs.com/ofnoname/p/19034868', title: '块状数组超级兵器：区间动态排名问题' })">举报</a>
</div>
        