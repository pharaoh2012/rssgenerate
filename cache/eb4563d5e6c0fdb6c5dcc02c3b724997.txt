
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cwkiller/p/18999458" title="发布于 2025-07-22 20:17">
    <span role="heading" aria-level="2">突破WAF！帆软模板注入漏洞利用新姿势</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        突破WAF！帆软模板注入漏洞利用新姿势
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="前言">前言</h2>
<p>24年9月份的时候打攻防遇到一个帆软报表版本为v11，从<code>/webroot/decision/system/info</code>可以看到细的版本号为模版注入修复前的版本。于是直接使用<code>/webroot/decision/view/ReportServer?test=exp</code>进行利用发现被WAF拦截，经过测试这个地方很难用常规的方法绕过<code>WAF</code>。</p>
<h2 id="分析源码">分析源码</h2>
<p>因为比较难从传统的办法绕过<code>WAF</code>，于是转而分析源码看是否存在一些其他的绕过方式。<br>
其实之前就对这个漏洞进行过分析，从公开的POC路由可以直接搜索<code>/view/ReportServer</code></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202507/858505-20250722201658033-1036194260.png" alt="" loading="lazy"><br>
然后再搜索<code>com.fr.web.controller.ViewRequestConstants#REPORT_VIEW_PATH_COMPATIBLE</code>哪里被调用</p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202507/858505-20250722201658586-802399724.png" alt="" loading="lazy"><br>
找到对应实现类和方法，正常来说的话这里可以直接在<code>idea</code>里两下<code>shift</code>直接查找路由但是不知道为啥<code>idea</code>没识别到，猜测可能是帆软改了<code>Controller</code>注解的包名导致的。<code>com.fr.web.controller.ReportRequestCompatibleService#preview</code></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202507/858505-20250722201659021-1307113599.png" alt="" loading="lazy"><br>
这里直接使用的<code>getQueryString</code>获取我们输入的查询参数且不会URL解码所以有很多特殊字符也不能输入，所以想从这个地方找到一些绕过<code>WAF</code>的办法比较难，除非去看还有哪些比较的特殊的模板方法能用来编码解码。但是经过测试发现<code>WAF</code>对于<code>${..}</code>特别敏感就算找到一些特殊的模板方法估计也没用。因为帆软报表以前也出过这个类型的模版注入，想着应该还有其他地方可以前台触发这个漏洞。于是通过<code>jadx</code>直接搜索<code>com.fr.base.TemplateUtils#render(java.lang.String)、com.fr.base.TemplateUtils#renderParameter4Tpl</code>这类<code>sink</code>发现搜索结果有点多找起来的话比较麻烦。在阅读源码的过程中发现大多数进入这两个<code>sink</code>的字符串都符合如下正则特征<code>"\$\{.*\}.*\+</code>于是使用<code>jadx</code>直接搜索。</p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202507/858505-20250722201700016-1982415100.png" alt="" loading="lazy"><br>
排除参数不可控、以及也是使用<code>getQueryString</code>的很快定位到<code>com.fr.nx.app.web.v9.handler.handler.PDFPrintPrintForIEHandler#handleRequest</code></p>
<pre><code>    protected void handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception {
        String var3 = SessionPoolManager.getOrGenerateSessionIDWithCheckRegister(var1, var2);
        if (var3 != null) {
            VersionTransition.saveCalculatorContext(var1, "/view/report");
            String var4 = "${servletURL}?op=export&amp;sessionID=" + var3 + "&amp;format=pdf&amp;frandom=" + Math.random() + System.currentTimeMillis() + "&amp;isPDFPrint=true&amp;extype=ori";
            String var6 = WebUtils.getHTTPRequestParameter(var1, "codebase");
            String var5;
            if ("true".equals(var6)) {
                var5 = "&lt;OBJECT ID='PDFReader' WIDTH='100%' HEIGHT='100%' CLASSID='CLSID:CA8A9780-280D-11CF-A24D-444553540000'";
                var5 = var5 + " codebase=\"${servletURL}?op=resource&amp;resource=/AdobeReader.exe\"&gt;";
                var5 = var5 + "&lt;param name='src' value='" + var4 + "'&gt;&lt;/OBJECT&gt;";
            } else {
                var5 = "&lt;OBJECT ID='PDFReader' WIDTH='0' HEIGHT='0' CLASSID='CLSID:CA8A9780-280D-11CF-A24D-444553540000'&gt;&lt;param name='src' value='" + var4 + "'&gt;&lt;/OBJECT&gt;";
            }

            PrintWriter var7 = WebUtils.createPrintWriter(var2);
            var7.print(TemplateUtils.render(var5));
            var7.flush();
            var7.close();
        }
    }
</code></pre>
<p>先从请求中获取<code>sessionID</code>然后拼接进<code>var4</code>再拼接进<code>var5</code>最后进入<code>render</code>触发模版注入。然后我们查找在哪里使用了<code>PDFPrintPrintForIEHandler</code></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202507/858505-20250722201700422-2125740299.png" alt="" loading="lazy"><br>
找到入口方法<code>com.fr.nx.app.web.controller.NXController#pdfPrintForIEV9</code>其路由为<code>/webroot/decision/nx/report/v9/print/ie/pdf</code></p>
<p><img src="https://img2024.cnblogs.com/blog/858505/202507/858505-20250722201700823-1199635126.png" alt="" loading="lazy"><br>
设置了请求方式仅为<code>GET</code>其实我本来是想找<code>POST</code>的这类路由的因为<code>POST</code>肯定比较好绕一点。但是后面查看获取<code>sessionID</code>的方式时发现这里存在多种编码方式可以绕过<code>WAF</code>。我们跟入<code>com.fr.web.core.SessionPoolManager#getOrGenerateSessionIDWithCheckRegister</code>查看如何获取<code>sessionID</code></p>
<pre><code>    public static String getOrGenerateSessionIDWithCheckRegister(HttpServletRequest var0, HttpServletResponse var1) throws Exception {
        String var2 = NetworkHelper.getHTTPRequestSessionIDParameter(var0);
        if (var2 == null) {
            var2 = generateSessionIDWithCheckRegister(var0, var1);
        }

        return var2;
    }
</code></pre>
<p>一直跟下去最后会到<code>getHTTPRequestEncodeParameter</code></p>
<pre><code>public static String getHTTPRequestEncodeParameter(HttpServletRequest var0, String var1, boolean var2) {
        ExtraClassManagerProvider var3 = (ExtraClassManagerProvider)PluginModule.getAgent(PluginModule.ExtraCore);
        Object var4;
        if (var3 == null) {
            var4 = DefaultRequestParameterHandler.getInstance();
        } else {
            var4 = (RequestParameterHandler)var3.getSingle("RequestParameterHandler");
            if (var4 == null) {
                var4 = DefaultRequestParameterHandler.getInstance();
            }
        }

        Object var5 = ((RequestParameterHandler)var4).getParameterFromHeader(var0, var1);
        if (var5 == null) {
            var5 = ((RequestParameterHandler)var4).getParameterFromRequest(var0, var1);
        }

        if (var5 == null) {
            var5 = ((RequestParameterHandler)var4).getParameterFromAttribute(var0, var1);
        }

        if (var5 == null) {
            var5 = ((RequestParameterHandler)var4).getParameterFromJSONParameters(var0, var1);
        }

        if (var5 == null) {
            var5 = ((RequestParameterHandler)var4).getParameterFromSession(var0, var1);
        }

        if (var5 == null) {
            var1 = CodeUtils.cjkEncode(var1);
            var5 = ((RequestParameterHandler)var4).getParameterFromRequest(var0, var1);
            if (var5 == null) {
                var5 = ((RequestParameterHandler)var4).getParameterFromAttribute(var0, var1);
                if (var5 == null) {
                    var5 = ((RequestParameterHandler)var4).getParameterFromSession(var0, var1);
                }
            }
        }

        return var2 ? checkURLDecode(var5) : GeneralUtils.objectToString(var5);
    }
</code></pre>
<p>这里<code>var1=sessionID,var2=true</code>这个方法里通过多种方式获取参数值。</p>
<ul>
<li>Request.getHeader里获取</li>
<li>Request.getParameter获取</li>
<li>Session.getAttribute获取</li>
<li>getParameterFromJSONParameters</li>
<li>Request.getAttribute获取</li>
</ul>
<p>所以我们这里可以用来获取的途径有三种<code>getHeader|getParameter|getParameterFromJSONParameters</code>注意到最后<code>return</code>的时候<code>var2=true</code>就会进入<code>checkURLDecode</code></p>
<pre><code>    private static String checkURLDecode(Object var0) {
        if (var0 == null) {
            return null;
        } else {
            String var1 = CommonCodeUtils.decodeText(String.valueOf(var0));

            try {
                return URLDecoder.decode(var1, "UTF-8");
            } catch (UnsupportedEncodingException var3) {
                return null;
            } catch (IllegalArgumentException var4) {
                return var1;
            }
        }
    }
</code></pre>
<p>这里会先调用<code>decodeText</code>进行解码再调用<code>URLDecoder</code>解码。跟入<code>decodeText</code>最后会调用<code>com.fr.stable.CommonCodeUtils#cjkDecode</code>进行解码</p>
<pre><code>    public static @NotNull String cjkDecode(@Nullable String text) {
        if (text == null) {
            return "";
        } else if (!isCJKEncoded(text)) {
            return text;
        } else {
            StringBuilder newTextBuf = new StringBuilder();

            for(int i = 0; i &lt; text.length(); ++i) {
                char ch = text.charAt(i);
                if (ch == '[') {
                    int rightIdx = text.indexOf(93, i + 1);
                    if (rightIdx &gt; i + 1) {
                        String subText = text.substring(i + 1, rightIdx);
                        if (subText.length() &gt; 0) {
                            ch = (char)Integer.parseInt(subText, 16);
                        }

                        i = rightIdx;
                    }
                }

                newTextBuf.append(ch);
            }

            return newTextBuf.toString();
        }
    }
</code></pre>
<p>对应的编码方法为<code>com.fr.stable.CommonCodeUtils#cjkEncode</code></p>
<pre><code>    public static @NotNull String cjkEncode(@Nullable String text) {
        if (text == null) {
            return "";
        } else {
            StringBuilder newTextBuf = new StringBuilder();
            int i = 0;

            for(int len = text.length(); i &lt; len; ++i) {
                char ch = text.charAt(i);
                if (needToEncode(ch)) {
                    newTextBuf.append('[');
                    newTextBuf.append(Integer.toString(ch, 16));
                    newTextBuf.append(']');
                } else {
                    newTextBuf.append(ch);
                }
            }

            return newTextBuf.toString();
        }
    }
</code></pre>
<p>所以我们可以将我们的<code>payload</code>先URL编码再使用<code>cjkEncode</code>编码进行利用从而绕过<code>WAF</code>进行模版注入。按照上述思路进行测试后发现生成的<code>payload</code>长度太长了，我们这个新找的接口是GET型的所以<code>payload</code>长度太长的话会直接导致<code>tomcat</code>报错。于是换了一个简短一些的写文件马，以及在<code>cjkEncode</code>编码的时候只编码非字母非数字字符，然后将<code>payload</code>放入<code>header</code>中，成功绕过<code>WAF</code>写入文件。<br>
<img src="https://img2024.cnblogs.com/blog/858505/202507/858505-20250722201701301-1309593049.png" alt="" loading="lazy"><br>
<img src="https://img2024.cnblogs.com/blog/858505/202507/858505-20250722201702191-753315502.png" alt="" loading="lazy"><br>
但是发现<code>webshell</code>没有正常解析，应该是<code>windows</code>然后使用<code>Anchor</code>师傅的解决办法，使用<code>/webroot/decision/file</code>接口初始化<code>JasperInitializer</code><br>
<img src="https://img2024.cnblogs.com/blog/858505/202507/858505-20250722201703205-436561835.png" alt="" loading="lazy"><br>
再次访问<code>webshell</code>成功解析<br>
<img src="https://img2024.cnblogs.com/blog/858505/202507/858505-20250722201704177-1181737214.png" alt="" loading="lazy"></p>
<p>上面的编码方式实际上在帆软的大多数获取参数值的场景都可以使用。</p>
<h2 id="总结">总结</h2>
<p>在<code>WAF</code>越来越强且使用越来越广的高对抗情况下，我们除了使用传统的绕过方法还可以从漏洞代码出发寻找其他漏洞利用路径以及可能存在的某种编码方式或解析差异绕过<code>WAF</code>进行攻击。对于<code>0day</code>挖掘人员在进行漏洞挖掘利用的过程中也应深入源码查看是否有某种特定的方式可以使得我们的<code>payload</code>不具备明显特征，这样在利用的过程中也能减少被发现的可能，提高<code>0day</code>的存活时间。<br>
<strong>如需编码脚本进行研究可关注公众号<code>漫漫安全路</code>，回复<code>fr</code>得到下载地址。</strong></p>
<hr>
<p><em>本文仅供安全研究和学习使用，由于传播、利用此文档提供的信息而造成任何直接或间接的后果及损害，均由使用本人负责，公众号及文章作者不为此承担任何责任。</em></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.0006944444444444445" data-date-updated="2025-07-22 20:18">2025-07-22 20:17</span>&nbsp;
<a href="https://www.cnblogs.com/cwkiller">cwkiller</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18999458);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18999458', targetLink: 'https://www.cnblogs.com/cwkiller/p/18999458', title: '突破WAF！帆软模板注入漏洞利用新姿势' })">举报</a>
</div>
        