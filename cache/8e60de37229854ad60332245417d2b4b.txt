
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/huangxincheng/p/18883360" title="发布于 2025-05-19 10:19">
    <span role="heading" aria-level="2">.NET外挂系列：2. 了解强大的 harmony 注解特性</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="一背景">一：背景</h2>
<h3 id="1-讲故事">1. 讲故事</h3>
<p>上一篇我们简单的聊了下<code>harmony外挂</code>的基本玩法，让大家宏观上感受到了外挂在 <code>.NET高级调试</code> 领域的威力，这一篇我们从 <code>注解特性</code> 这个角度继续展开。</p>
<h2 id="二harmony-注解特性">二：harmony 注解特性</h2>
<h3 id="1-harmonypatch-解读">1. HarmonyPatch 解读</h3>
<p>在harmony支持的众多特性中，HarmonyPatch算是最基础的一个，注解特性简单来说就是<code>harmony</code>和 <code>目标类</code> 沟通的桥梁，为了让沟通更加简洁，harmony 提供了 20 个重载，参考如下：</p>
<pre><code class="language-C#">
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Delegate, AllowMultiple = true)]
public class HarmonyPatch : HarmonyAttribute
{
    public HarmonyPatch();
    public HarmonyPatch(Type declaringType);
    public HarmonyPatch(Type declaringType, Type[] argumentTypes);
    public HarmonyPatch(Type declaringType, string methodName);
    public HarmonyPatch(Type declaringType, string methodName, params Type[] argumentTypes);
    public HarmonyPatch(Type declaringType, string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyPatch(Type declaringType, MethodType methodType);
    public HarmonyPatch(Type declaringType, MethodType methodType, params Type[] argumentTypes);
    public HarmonyPatch(Type declaringType, MethodType methodType, Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyPatch(Type declaringType, string methodName, MethodType methodType);
    public HarmonyPatch(string methodName);
    public HarmonyPatch(string methodName, params Type[] argumentTypes);
    public HarmonyPatch(string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyPatch(string methodName, MethodType methodType);
    public HarmonyPatch(MethodType methodType);
    public HarmonyPatch(MethodType methodType, params Type[] argumentTypes);
    public HarmonyPatch(MethodType methodType, Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyPatch(Type[] argumentTypes);
    public HarmonyPatch(Type[] argumentTypes, ArgumentType[] argumentVariations);
    public HarmonyPatch(string typeName, string methodName, MethodType methodType = MethodType.Normal);
}

</code></pre>
<p>上面的20个重载方法都是从各种角度灵活定位到 <code>目标方法</code>，基本上能覆盖95%的场景，非常的强大，接下来我们使用这些特性优化上一篇的案例，一个洞察为什么突然的线程暴涨，参考代码如下：</p>
<pre><code class="language-C#">
    internal class Program
    {
        static void Main(string[] args)
        {
            // 创建 Harmony 实例
            var harmony = new Harmony("com.example.threadhook");

            // 应用补丁
            harmony.PatchAll();

            Task.Factory.StartNew(() =&gt; { Test(); });

            Console.ReadLine();
        }

        static void Test()
        {
            // 测试线程
            var thread = new Thread(() =&gt; Console.WriteLine("线程正在运行"));
            thread.Start();
        }
    }

    [HarmonyPatch(typeof(Thread), "Start", new Type[] { })]
    public class ThreadStartHook
    {
        // 前缀补丁 - 在原始方法执行前运行
        public static void Prefix(Thread __instance)
        {
            Console.WriteLine("----------------------------");
            Console.WriteLine($"即将启动线程: {__instance.ManagedThreadId}");
            Console.WriteLine(Environment.StackTrace);
            Console.WriteLine("----------------------------");
        }
    }

</code></pre>
<h2 id="三案例优化">三：案例优化</h2>
<h3 id="1-如何实现多start监控">1. 如何实现多Start监控</h3>
<p>上面的例子只是对 <code>无参Start</code> 进行的监控，可能会漏掉那些 <code>有参Start</code> 的情况，所以保守起见新增一个监控，代码如下：</p>
<pre><code class="language-C#">
    [HarmonyPatch(typeof(Thread), "Start", new Type[] { })]
    public class ThreadStartHook
    {
        // 前缀补丁 - 在原始方法执行前运行
        public static void Prefix(Thread __instance)
        {
            Console.WriteLine("----------------------------");
            Console.WriteLine($"即将启动线程: {__instance.ManagedThreadId}");
            Console.WriteLine(Environment.StackTrace);
            Console.WriteLine("----------------------------");
        }
    }

    [HarmonyPatch(typeof(Thread), "Start", new Type[] { typeof(object) })]
    public class ThreadStartWithParamHook
    {
        // 前缀补丁 - 在原始方法执行前运行
        public static void Prefix(Thread __instance)
        {
            Console.WriteLine("----------------------------");
            Console.WriteLine($"即将启动线程: {__instance.ManagedThreadId}");
            Console.WriteLine(Environment.StackTrace);
            Console.WriteLine("----------------------------");
        }
    }

</code></pre>
<p>为了对 <code>Start(object)</code> 监控，我新增了一个 <code>ThreadStartWithParamHook</code> 类，虽然可以实现，但代码显的有些凌乱和累赘，那如何优化呢？这时候就可以使用新的 <code>HarmonyPrefix</code> 特性以及利用 <code>注解的层级特点</code> 来解决问题，优化之后的代码如下：</p>
<pre><code class="language-C#">
    [HarmonyPatch(typeof(Thread), "Start")]
    public class ThreadStartHook
    {
        [HarmonyPrefix]
        [HarmonyPatch(new Type[] { })]
        public static void Start(Thread __instance)
        {
            Console.WriteLine("----------------------------");
            Console.WriteLine($"即将启动线程: {__instance.ManagedThreadId}");
            Console.WriteLine(Environment.StackTrace);
            Console.WriteLine("----------------------------");
        }

        [HarmonyPrefix]
        [HarmonyPatch(new Type[] { typeof(object) })]
        public static void StartWithParam(Thread __instance)
        {
            Console.WriteLine("----------------------------");
            Console.WriteLine($"即将启动线程: {__instance.ManagedThreadId}");
            Console.WriteLine(Environment.StackTrace);
            Console.WriteLine("----------------------------");
        }
    }

</code></pre>
<p>大家可以对比下代码，是不是好很多，这里稍微解释下：</p>
<ol>
<li>
<p>我们将 <code> [HarmonyPatch(typeof(Thread), "Start", new Type[] { typeof(object) })]</code> 拆成了 <code>[HarmonyPatch(typeof(Thread), "Start")] + [HarmonyPatch(new Type[] { })]</code> 的模式，这就是层次性。</p>
</li>
<li>
<p>由于 Prefix 是 harmony 默认的前缀方法，如果不想用这个方法名，就必须使用 <code>HarmonyPrefix</code> 标注到你自定义的方法名上。</p>
</li>
</ol>
<p>到这里可能有些人要反驳我，如果我的 Start 有10个重载，是不是也要对应的写10个hook方法？这样搞的话还是太麻烦了，有没有更加简洁的方式？ 我要告诉你的是，肯定是可以的，你所焦虑的事情别人早就考虑到了，答案就是 harmony 在底层开了一个口子，让你通过自定义代码返回要 patch 的方法，参考代码如下：</p>
<pre><code class="language-C#">
    [HarmonyPatch]
    public class ThreadStartHook
    {
        //harmony 开的口子，返回要注入的方法。
        static IEnumerable&lt;MethodBase&gt; TargetMethods()
        {
            var methodlist = typeof(Thread).GetMethods()
                                           .Where(method =&gt; method.Name.StartsWith("Start"))
                                           .Cast&lt;MethodBase&gt;();
            return methodlist;
        }

        public static void Prefix(Thread __instance, MethodBase __originalMethod)
        {
            var parameters = __originalMethod.GetParameters().Select(i =&gt; i.ParameterType.Name);

            Console.WriteLine("----------------------------");
            Console.WriteLine($"{__originalMethod.Name} ({string.Join(",", parameters)})");
            Console.WriteLine(Environment.StackTrace);
            Console.WriteLine("----------------------------");
        }
    }

</code></pre>
<p>代码中的 TargetMethods 方法就像一把利剑一样，批量的注入Start方法，你也可以根据你的需要灵活筛选，最后上一张图，</p>
<p><img src="https://img2024.cnblogs.com/blog/214741/202505/214741-20250519101832767-1953347009.png" alt="" loading="lazy"></p>
<h2 id="四总结">四：总结</h2>
<p>通过不断的对 <code>Thread.Start</code> 方法进行注入优化，相信大家也感受到了harmony的异常强大，最后就是希望给训练营里的朋友一些思考和资料参考吧。<br>
<img src="https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_210929020104最新消息优惠促销公众号关注二维码.jpg" width="700" height="300" alt="图片名称" align="center"></p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.6683379227557871" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-19 10:19">2025-05-19 10:19</span>&nbsp;
<a href="https://www.cnblogs.com/huangxincheng">一线码农</a>&nbsp;
阅读(<span id="post_view_count">360</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18883360);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18883360', targetLink: 'https://www.cnblogs.com/huangxincheng/p/18883360', title: '.NET外挂系列：2. 了解强大的 harmony 注解特性' })">举报</a>
</div>
        