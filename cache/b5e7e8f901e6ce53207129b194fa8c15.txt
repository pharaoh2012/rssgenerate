
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/rust-tech/p/19032792" title="发布于 2025-08-26 18:30">
    <span role="heading" aria-level="2">Rust从入门到精通07-trait</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>Rust 语言中，trait 是一个非常重要的概念，可以包含：函数、常量、类型等。</p>
<p>通俗一点理解，trait 以一种抽象的方式定义共享的行为，可以被认为是一些语言的接口，但是与接口也有一定区别，下面会介绍。</p>
<h3 id="1成员方法">1、成员方法</h3>
<p>trait 中可以定义方法。</p>
<pre><code class="language-rust">trait Shape {
    fn area(&amp;self) -&gt; f64;
}
</code></pre>
<p>我们在一个名为 Shape 的 trait 中定义了一个方法 area。</p>
<h4 id="11-方法参数">1.1 方法参数</h4>
<p>看上面定义的 Shape，方法的参数是 &amp;self。</p>
<p>其实对于每个 trait 都有一个隐藏的类型 Self(大写的 S)，代表实现此 trait 的具体类型。</p>
<p>Rust 中 Self 和 self 都是关键字，大写的Self是类型名，小写的 self 是变量名。</p>
<p>其实 area(&amp;self) 等价于 area(self : &amp;Self)，只不过 rust 提供了简化的写法。</p>
<p>下面几种情况都是等价的。</p>
<pre><code class="language-rust">trait T {
    fn method1(self : Self);
    fn method2(self : &amp;Self);
    fn method3(self : &amp;mut Self);
}
//等价于下面方法定义
trait T {
    fn method1(self);
    fn method2(&amp;self);
    fn method3(&amp;mut self);
}
</code></pre>
<h4 id="12-调用实例">1.2 调用实例</h4>
<p>可以参考如下例子：</p>
<pre><code class="language-rust">trait Shape {
    fn area(&amp;self) -&gt; f64;
}

struct Circle {
    radius : f64,
}

impl Shape for Circle {
    // Self 的类型就是 Circle
    fn area(self : &amp;Self) -&gt; f64{
        // 可以通过self.radius访问成员变量
        std::f64::consts::PI * self.radius * self.radius
    }
}

fn main() {
    let circle = Circle{ radius : 2f64};
    println!("The area is {}",circle.area())

}
</code></pre>
<p>①、通过 self.成员变量 来访问成员变量；</p>
<p>②、通过 实例.成员方法 来调用成员方法；</p>
<h3 id="2匿名-trait">2、匿名 trait</h3>
<pre><code class="language-rust">impl Circle {
    fn get_radius(&amp;self) -&gt; f64 {
        self.radius
    }
}
</code></pre>
<p>impl 关键字后面直接接类型，没有 trait 的名字。</p>
<p>可以将上面代码看成是为 Circle 实现了一个匿名的 trait。</p>
<h3 id="3-静态方法">3、 静态方法</h3>
<blockquote>
<p>静态方法：第一个参数不是 self 参数的方法。</p>
</blockquote>
<pre><code class="language-rust">impl Circle {
    // 普通方法
    fn get_radius(&amp;self) -&gt; f64 {
        self.radius
    }

    // 静态方法
    fn get_area(this : &amp;Self) -&gt;f64 {
        std::f64::consts::PI * this.radius * this.radius
    }
}

fn main() {
    let c = Circle{ radius : 2f64};
    // 调用普通方法
    println!("The radius is {}",c.radius);
    // 调用静态方法
    println!("The area is {}",Circle::get_area(&amp;c))

}
</code></pre>
<p>注意和普通方法的区别，参数命名不同，以及调用方式不同（普通方法是小数 实例.方法 ，静态方法是 类型::方法 ）。</p>
<p>静态方法的调用可以 Type::FunctionName()。</p>
<h3 id="4扩展方法">4、扩展方法</h3>
<p>利用 trait 给其它类型添加方法。</p>
<p>比如我们给内置类型 i32 添加一个方法：</p>
<pre><code class="language-rust">// 扩展方法
trait Double {
    fn double(&amp;self) -&gt; Self;
}
impl Double for i32 {
    fn double(&amp;self) -&gt; i32{
        self * 2
    }
}

fn main() {
    let x : i32 = 10.double();
    println!("x double is {}",x);//20

}
</code></pre>
<h3 id="5泛型约束">5、泛型约束</h3>
<p>在Rust中，静态分发（Static Dispatch）和动态分发（Dynamic Dispatch）是用于选择和调用函数的两种不同的机制。</p>
<h4 id="51-静态分发">5.1 静态分发</h4>
<p>在编译时确定函数调用的具体实现。</p>
<p>它通过在编译阶段解析函数调用并选择正确的函数实现，从而实现高效的调用。</p>
<p>静态分发通常适用于使用泛型的情况，其中编译器可以根据具体的类型参数确定调用的函数。</p>
<pre><code class="language-rust">fn main() {
    fn myPrint&lt;T: ToString&gt;(v: T) {
        v.to_string();
    }
    
    let c = 'a';
    let s = String::from("hello");
    
    myPrint::&lt;char&gt;(c);
    myPrint::&lt;String&gt;(s);
}
</code></pre>
<p>等价于：</p>
<pre><code class="language-rust">fn myPrint(c:char){
    c.to_string();
}
fn myPrint(str:String){
    str.to_string();
}
</code></pre>
<h4 id="52-动态分发">5.2 动态分发</h4>
<p>在运行时根据对象的实际类型来选择函数的实现。</p>
<p>它适用于使用trait对象（通过使用<code>dyn</code>关键字）的情况，其中编译器在编译阶段无法确定具体的函数实现。</p>
<p>在运行时，程序会根据trait对象所包含的实际类型来动态地选择要调用的函数。</p>
<p>动态分发提供了更大的灵活性，但相对于静态分发，它可能会带来一些运行时开销。</p>
<p>下面代码分别演示静态分发和动态分发的区别：</p>
<pre><code class="language-rust">trait Animal {
    fn make_sound(&amp;self);
}

struct Cat;
struct Dog;

impl Animal for Cat {
    fn make_sound(&amp;self) {
        println!("Meow!");
    }
}

impl Animal for Dog {
    fn make_sound(&amp;self) {
        println!("Woof!");
    }
}

fn static_dispatch(animal: &amp;impl Animal) {
    animal.make_sound();
}

fn dynamic_dispatch(animal: &amp;dyn Animal) {
    animal.make_sound();
}

fn main() {
    let cat = Cat;
    let dog = Dog;

    // 静态分发
    static_dispatch(&amp;cat);
    static_dispatch(&amp;dog);

    // 动态分发
    dynamic_dispatch(&amp;cat as &amp;dyn Animal);
    dynamic_dispatch(&amp;dog as &amp;dyn Animal);
}
</code></pre>
<h2 id="5一致性原则">5、一致性原则</h2>
<p>一致性原则，也称为孤儿原则（Orphan Rule）：</p>
<blockquote>
<p>Impl 块要么与 trait 块的声明在同一个 crate 中，要么与类型的声明在同一个 crate 中。</p>
</blockquote>
<p>孤儿原则（Orphan Rule）是Rust语言中的一项重要设计原则，它有助于确保trait实现的可控性和可追溯性。遵守孤儿原则可以提高代码的可读性和可维护性，并降低潜在的冲突和混乱。</p>
<p>也就是说如果 trait 来自外部，而且类型也来自外部 crate，编译器是不允许你为这个类型 impl 这个 trait。它们当中至少有一个是在当前 crate 中定义的。</p>
<p>比如下面两种情况都是可以的：</p>
<pre><code class="language-rust">use std::fmt::Display;

struct A;
impl Display for A {}
</code></pre>
<pre><code class="language-rust">trait TraitA {}
impl TraitA for u32 {}
</code></pre>
<p>但是下面这种情况就不可以：</p>
<pre><code class="language-rust">use std::fmt::Display;

impl Display for u32 {}
</code></pre>
<p><img alt="" loading="lazy" data-src="https://itcoke-pic.oss-cn-hangzhou.aliyuncs.com/itcoke-202312/image-07-01.png" class="lazyload"></p>
<p>这也给我们提供了一个标准：上游开发者在写库的时候，一些比较常用的标准 trait，如 Display/Debug/ToString/Default 等，应该尽可能的提供好。</p>
<p>否则下游使用这个库的开发者是没法帮我们实现这些 trait 的。</p>
<h2 id="6trait-和-接口区别">6、trait 和 接口区别</h2>
<p>开篇我们说为了便于理解 trait，可以想象为其它语言，比如Java中的接口。但是实际上他们还是有很大的区别的。</p>
<p>因为 rust 是一种用户可以对内存有着精确控制的强类型语言。在目前 Rust 版本中规定：</p>
<blockquote>
<p>函数传参类型，返回值类型等都是要在编译期确定大小的。</p>
</blockquote>
<p>而 trait 本身既不是具体类型，也不是指针类型，它只是定义了针对类型的、抽象的约束。不同的类型可以实现同一个 trait，满足同一个 trait 的类型可能具有不同的大小。</p>
<p>所以 trait 在编译阶段没有固定的大小，我们不能直接使用 trait 作为实例变量、参数以及返回值。</p>
<p>类似下面的写法都是错误的：</p>
<pre><code class="language-rust">trait Shape {
    fn area(&amp;self) -&gt; f64;
}

impl Circle {
    //错误1： trait（Shape）不能做参数的类型
    fn use_shape(arg : Shape){

    }
    //错误2： trait（Shape）不能做返回值的类型
    fn ret_shape() -&gt; Shape{

    }
}
fn main() {
    // 错误3：trait（Shape）不能做局部变量的类型
    let x : Shape = Circle::new();
}
</code></pre>
<p>可以看到编译器的错误提示：</p>
<p><img alt="" loading="lazy" data-src="https://itcoke-pic.oss-cn-hangzhou.aliyuncs.com/rust/image-07-00.png" class="lazyload"></p>
<h2 id="7derive">7、derive</h2>
<p>Rust 标准库内部实现了一些逻辑较为固定的 trait，通过 derive 配置可以帮助我们自动 impl 某些 trait，而无需手动编写对应的代码。</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Foo {
    data : i32,
}
fn main() {
    let v1 = Foo{data : 0};
    println!("{:?}",v1)
}
</code></pre>
<p>加上 Debug 的trait 实现，便于格式化打印 struct。</p>
<h1 id="derivedebug-等价于-impl-debug-for-foo-">[derive(Debug)] 等价于 impl Debug for Foo {}</h1>
<p>目前，Rust 支持的可以自动 derive 的 trait 有如下：</p>
<pre><code>Copy,Clone,Default,Hash,
Debug,PartialEq,Eq,PartialOrd,
Ord,RustcEncodable,RustcDecodable,
FromPrimitive,Send,Sync
</code></pre>
<h2 id="8标准库中常见-trait">8、标准库中常见 trait</h2>
<p>在介绍 derive 时，我们说明了内置的一些 trait，这都是标准库中比较常见的 trait，下面我们分别介绍这些 trait 是干什么的。</p>
<h3 id="81-display-和-debug">8.1 Display 和 Debug</h3>
<p>可以分别看下源码定义：</p>
<p>【Display】</p>
<pre><code class="language-rust">pub trait Display {
    /// Formats the value using the given formatter.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::fmt;
    ///
    /// struct Position {
    ///     longitude: f32,
    ///     latitude: f32,
    /// }
    ///
    /// impl fmt::Display for Position {
    ///     fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
    ///         write!(f, "({}, {})", self.longitude, self.latitude)
    ///     }
    /// }
    ///
    /// assert_eq!("(1.987, 2.983)",
    ///            format!("{}", Position { longitude: 1.987, latitude: 2.983, }));
    /// ```
    #[stable(feature = "rust1", since = "1.0.0")]
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result;
}
</code></pre>
<p>【Debug】</p>
<pre><code class="language-rust">pub trait Debug {
    /// Formats the value using the given formatter.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::fmt;
    ///
    /// struct Position {
    ///     longitude: f32,
    ///     latitude: f32,
    /// }
    ///
    /// impl fmt::Debug for Position {
    ///     fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
    ///         f.debug_tuple("")
    ///          .field(&amp;self.longitude)
    ///          .field(&amp;self.latitude)
    ///          .finish()
    ///     }
    /// }
    ///
    /// let position = Position { longitude: 1.987, latitude: 2.983 };
    /// assert_eq!(format!("{:?}", position), "(1.987, 2.983)");
    ///
    /// assert_eq!(format!("{:#?}", position), "(
    ///     1.987,
    ///     2.983,
    /// )");
    /// ```
    #[stable(feature = "rust1", since = "1.0.0")]
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result;
}
</code></pre>
<blockquote>
<p>①、只有实现了 Display trait 的类型，才能够用 {} 格式打印出来。</p>
<p>②、只有实现了 Debug trait 的类型，才能够用{:?} {:#?} 格式打印出来。</p>
</blockquote>
<p>这两者区别如下：</p>
<p>1、Display 假定了这个类型可以用 utf-8 格式的字符串表示，它是准备给最终用户看的，并不是所有的类型都应该或者能够实现这个 trait。这个 trait 的 fmt 应该如何格式化字符串，完全取决于程序员自己，编译器不提供自动 derive 的功能。</p>
<p>2、标准库中还有一个常用 trait 叫作 std::string::ToString，对于所有实现了 Display trait 的类型，都自动实现了这个 ToString trait 。它包含了一个方法 to_string(&amp;self) -&gt; String。任何一个实现了 Display trait 的类型，我们都可以对它调用 to_string() 方法格式化出一个字符串。</p>
<p>3、Debug 则主要是为了调试使用，建议所有的作为 API 的“公开”类型都应该实现这个 trait，以方便调试。它打印出来的字符串不是以“美观易读”为标准，编译器提供了自动 derive 的功能。</p>
<pre><code class="language-rust">struct Color{
    r:u8,
    g:u8,
    b:u8,
}

impl Default for Color{
    fn default() -&gt; Self{
        Self{r:0,g:0,b:0}
    }
}
</code></pre>
<p>等价于：</p>
<pre><code class="language-rust">#[derive(Default)]
struct Color{
    r:u8,
    g:u8,
    b:u8,
}
</code></pre>
<h3 id="82-tostring">8.2 ToString</h3>
<p><code>ToString</code> 是 Rust 标准库中定义的一个非常常用的 trait，它的目的是将任何实现了它的类型<strong>转换为 <code>String</code> 类型的文本表示</strong></p>
<pre><code class="language-rust">#[cfg_attr(not(test), rustc_diagnostic_item = "ToString")]
#[stable(feature = "rust1", since = "1.0.0")]
pub trait ToString {
    /// Converts the given value to a `String`.
    ///
    /// # Examples
    ///
    /// ```
    /// let i = 5;
    /// let five = String::from("5");
    ///
    /// assert_eq!(five, i.to_string());
    /// ```
    #[rustc_conversion_suggestion]
    #[stable(feature = "rust1", since = "1.0.0")]
    #[cfg_attr(not(test), rustc_diagnostic_item = "to_string_method")]
    fn to_string(&amp;self) -&gt; String;
}
</code></pre>
<h4 id="自动实现">自动实现</h4>
<p>虽然 <code>ToString</code> 是一个 trait，但你<strong>几乎不需要手动实现它</strong>，因为标准库中已经为所有实现了 <code>Display</code> 的类型，自动实现了 <code>ToString</code>。</p>
<p>也就是说：</p>
<blockquote>
<p>实现了 <code>Display</code> ⇒ 自动拥有 <code>.to_string()</code> 方法。</p>
<p><code>to_string()</code> 本质上等价于 <code>format!("{}", value)</code>。</p>
</blockquote>
<pre><code class="language-rust">#[cfg(not(no_global_oom_handling))]
#[stable(feature = "rust1", since = "1.0.0")]
impl&lt;T: fmt::Display + ?Sized&gt; ToString for T {
    #[inline]
    fn to_string(&amp;self) -&gt; String {
        &lt;Self as SpecToString&gt;::spec_to_string(self)
    }
}


impl&lt;T: fmt::Display + ?Sized&gt; SpecToString for T {
    // A common guideline is to not inline generic functions. However,
    // removing `#[inline]` from this method causes non-negligible regressions.
    // See &lt;https://github.com/rust-lang/rust/pull/74852&gt;, the last attempt
    // to try to remove it.
    #[inline]
    default fn spec_to_string(&amp;self) -&gt; String {
        let mut buf = String::new();
        let mut formatter =
            core::fmt::Formatter::new(&amp;mut buf, core::fmt::FormattingOptions::new());
        // Bypass format_args!() to avoid write_str with zero-length strs
        fmt::Display::fmt(self, &amp;mut formatter)
            .expect("a Display implementation returned an error unexpectedly");
        buf
    }
}
</code></pre>
<h3 id="83-paritialeqeq">8.3 ParitialEq/Eq</h3>
<p>在Rust中，<code>PartialOrd</code>、<code>Ord</code>、<code>PartialEq</code>和<code>Eq</code>是用于比较和排序的trait。通过使用<code>derive</code>宏，可以自动为结构体或枚举实现这些trait的默认行为。</p>
<p>下面是对这些trait的简要解释：</p>
<ol>
<li><code>PartialOrd</code> trait：用于部分顺序比较，即可以进行比较但不一定可以完全排序。它定义了<code>partial_cmp</code>方法，用于比较两个值并返回一个<code>Option&lt;Ordering&gt;</code>枚举，表示比较结果。</li>
<li><code>Ord</code> trait：用于完全顺序比较，即可以进行完全排序。它是<code>PartialOrd</code> trait的超集，定义了<code>cmp</code>方法，用于比较两个值并返回<code>Ordering</code>枚举，表示比较结果。</li>
<li><code>PartialEq</code> trait：用于部分相等性比较。它定义了<code>eq</code>、<code>ne</code>、<code>lt</code>、<code>le</code>、<code>gt</code>和<code>ge</code>等方法，用于比较两个值是否相等、不相等、小于、小于等于、大于、大于等于。</li>
<li><code>Eq</code> trait：用于完全相等性比较，即可以进行完全相等性判断。它是<code>PartialEq</code> trait的超集，无需手动实现，通过自动实现<code>PartialEq</code> trait即可获得<code>Eq</code> trait的默认实现。</li>
</ol>
<p>Eq定义为PartialEq的subtrait</p>
<pre><code class="language-rust">#[derive(PartialEq, Debug)]    // 注意这一句
struct Point {
    x: i32,
    y: i32,
}
fn example_assert(p1: Point, p2: Point) {
    assert_eq!(p1, p2);        // 比较
}
</code></pre>
<h3 id="84-partialordord">8.4 PartialOrd/Ord</h3>
<p>PartialOrd和PartialEq差不多，PartialEq只判断相等或不相等，PartialOrd在这个基础上进一步判断是小于、小于等于、大于还是大于等于。可以看到，它就是为排序功能准备的。</p>
<p>PartialOrd被定义为 PartialEq的subtrait。它们在类型上可以用过程宏一起derive实现。</p>
<pre><code class="language-rust">#[derive(PartialEq, PartialOrd)]
struct Point {
    x: i32,
    y: i32,
}

#[derive(PartialEq, PartialOrd)]
enum Stoplight {
    Red,
    Yellow,
    Green,
}
</code></pre>
<h3 id="85-clone">8.5 Clone</h3>
<p>这个trait给目标类型提供了clone()方法用来完整地克隆实例。</p>
<pre><code class="language-rust">#[stable(feature = "rust1", since = "1.0.0")]
#[lang = "clone"]
#[rustc_diagnostic_item = "Clone"]
#[rustc_trivial_field_reads]
pub trait Clone: Sized {
    /// Returns a copy of the value.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![allow(noop_method_call)]
    /// let hello = "Hello"; // &amp;str implements Clone
    ///
    /// assert_eq!("Hello", hello.clone());
    /// ```
    #[stable(feature = "rust1", since = "1.0.0")]
    #[must_use = "cloning is often expensive and is not expected to have side effects"]
    // Clone::clone is special because the compiler generates MIR to implement it for some types.
    // See InstanceKind::CloneShim.
    #[lang = "clone_fn"]
    fn clone(&amp;self) -&gt; Self;

    /// Performs copy-assignment from `source`.
    ///
    /// `a.clone_from(&amp;b)` is equivalent to `a = b.clone()` in functionality,
    /// but can be overridden to reuse the resources of `a` to avoid unnecessary
    /// allocations.
    #[inline]
    #[stable(feature = "rust1", since = "1.0.0")]
    fn clone_from(&amp;mut self, source: &amp;Self) {
        *self = source.clone()
    }
}
</code></pre>
<p>通过方法的签名，可以看到方法使用的是实例的不可变引用。</p>
<pre><code class="language-rust">fn clone(&amp;self) -&gt; Self;
</code></pre>
<p>比如：</p>
<pre><code class="language-rust">#[derive(Clone)]
struct Point {
    x: u32,
    y: u32,
}
</code></pre>
<p>因为每一个字段（u32类型）都实现了Clone，所以通过derive，自动为Point类型实现了Clone trait。实现后，Point的实例 point 使用 point.clone() 就可以把自己克隆一份了。</p>
<p>注意：clone() 是对象的深度拷贝，可能会有比较大的额外负载，但是就大多数情况来说其实还好。不要担心在Rust中使用clone()，先把程序功能跑通最重要。Rust的代码，性能一般都不会太差，毕竟起点很高。</p>
<h3 id="86-copy">8.6 Copy</h3>
<pre><code class="language-rust">#[rustc_unsafe_specialization_marker]
#[rustc_diagnostic_item = "Copy"]
pub trait Copy: Clone {
    // Empty.
}
</code></pre>
<p>定义为Clone的subtrait，并且不包含任何内容，仅仅是一个标记（marker）。</p>
<p>Rust标准库提供了Copy过程宏，可以让我们自动为目标类型实现Copy trait。</p>
<h3 id="87-toowned">8.7 ToOwned</h3>
<p>ToOwned相当于是Clone更宽泛的版本。ToOwned给类型提供了一个 <code>to_owned()</code> 方法，可以将引用转换为所有权实例。</p>
<pre><code class="language-rust">let a: &amp;str = "123456";
let s: String = a.to_owned();
</code></pre>
<h3 id="88-drop">8.8 Drop</h3>
<p>Drop trait用于给类型做自定义垃圾清理（回收）。</p>
<pre><code class="language-rust">trait Drop {
    fn drop(&amp;mut self);
}
</code></pre>
<p>实现了这个trait的类型的实例在走出作用域的时候，触发调用drop()方法，这个调用发生在这个实例被销毁之前。</p>
<pre><code class="language-rust">#[derive(PartialEq, Debug, Clone)]    // 注意这一句
struct Point {
    x: i32,
    y: i32,
}

impl Drop for Point {
    fn drop(&amp;mut self) {
        println!("Dropping point ({},{})",self.x,self.y);
    }
}
fn main() {
    let p = Point { x: 1, y: 2 };
    println!("{:?}", p);
}
</code></pre>
<p>输出结果：</p>
<p><img alt="" loading="lazy" data-src="https://itcoke-pic.oss-cn-hangzhou.aliyuncs.com/202507/image-20250512222627396.png" class="lazyload"></p>
<p>一般来说，我们不需要为自己的类型实现这个trait，除非遇到特殊情况，比如我们要调用外部的C库函数，然后在C那边分配了资源，由C库里的函数负责释放，这个时候我们就要在Rust的包装类型（对C库中类型的包装）上实现Drop，并调用那个C库中释放资源的函数。</p>
<h3 id="89-fromt-和-intot">8.9 <code>From&lt;T&gt;</code> 和 <code>Into&lt;T&gt;</code></h3>
<p>这两个 trait 用于类型转换。</p>
<p><code>From&lt;T&gt;</code> 可以把类型T转为自己，而 <code>Into&lt;T&gt;</code> 可以把自己转为类型T。</p>
<pre><code class="language-rust">trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
trait Into&lt;T&gt; {
    fn into(self) -&gt; T;
}
</code></pre>
<p>可以看到它们是互逆的trait。实际上，Rust只允许我们实现 <code>From&lt;T&gt;</code>，因为实现了From后，自动就实现了Into，请看标准库里的这个实现。</p>
<pre><code class="language-rust">impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}
</code></pre>
<h3 id="810-tryfrom-tryinto">8.10 TryFrom TryInto</h3>
<p><code>TryFrom&lt;T&gt;</code> 和 <code>TryInto&lt;T&gt;</code> 是 <code>From&lt;T&gt;</code> 和 <code>Into&lt;T&gt;</code> 的可失败版本。如果你认为转换可能会出现失败的情况，就选择这两个trait来实现。</p>
<pre><code class="language-rust">trait TryFrom&lt;T&gt; {
    type Error;
    fn try_from(value: T) -&gt; Result&lt;Self, Self::Error&gt;;
}

trait TryInto&lt;T&gt; {
    type Error;
    fn try_into(self) -&gt; Result&lt;T, Self::Error&gt;;
}
</code></pre>
<p>可以看到，调用 <code>try_from()</code> 和 <code>try_into()</code> 后返回的是Result，你需要对Result进行处理。</p>
<h3 id="811-fromstr">8.11 FromStr</h3>
<p>从字符串类型转换到自身。</p>
<pre><code class="language-rust">trait FromStr {
    type Err;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;
}
</code></pre>
<p>比如字符串的 <code>parse()</code> 方法：</p>
<pre><code class="language-rust">use std::str::FromStr;

fn example&lt;T: FromStr&gt;(s: &amp;str) {
    // 下面4种表达等价
    let t: Result&lt;T, _&gt; = FromStr::from_str(s);
    let t = T::from_str(s);
    let t: Result&lt;T, _&gt; = s.parse();
    let t = s.parse::&lt;T&gt;(); // 最常用的写法
}
</code></pre>
<h3 id="812-as_ref">8.12 as_ref</h3>
<pre><code class="language-rust">trait AsRef&lt;T&gt; {
    fn as_ref(&amp;self) -&gt; &amp;T;
}
</code></pre>
<p>它把自身的引用转换成目标类型的引用。和Deref的区别是， <code>deref()</code> 是隐式调用的，而 <code>as_ref()</code> 需要你显式地调用。所以代码会更清晰，出错的机会也会更少。</p>
<p><code>AsRef&lt;T&gt;</code> 可以让函数参数中传入的类型更加多样化，不管是引用类型还是具有所有权的类型，都可以传递。比如；</p>
<pre><code class="language-rust">// 使用 &amp;str 作为参数可以接收下面两种类型
//  - &amp;str
//  - &amp;String
fn takes_str(s: &amp;str) {
    // use &amp;str
}
// 使用 AsRef&lt;str&gt; 作为参数可以接受下面三种类型
//  - &amp;str
//  - &amp;String
//  - String
fn takes_asref_str&lt;S: AsRef&lt;str&gt;&gt;(s: S) {
    let s: &amp;str = s.as_ref();
    // use &amp;str
}
fn example(slice: &amp;str, borrow: &amp;String, owned: String) {
    takes_str(slice);
    takes_str(borrow);
    takes_str(owned); // ❌
    takes_asref_str(slice);
    takes_asref_str(borrow);
    takes_asref_str(owned); // ✅
}
</code></pre>
<p>在这个例子里，具有所有权的String字符串也可以直接传入参数中了，相对于 &amp;str 的参数类型表达更加扩展了一步。</p>
<p>你可以把 Deref 看成是隐式化（或自动化）+弱化版本的 <code>AsRef&lt;T&gt;</code>。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-08-26 18:30">2025-08-26 18:30</span>&nbsp;
<a href="https://www.cnblogs.com/rust-tech">Rust技术指南</a>&nbsp;
阅读(<span id="post_view_count">4</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(19032792);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '19032792', targetLink: 'https://www.cnblogs.com/rust-tech/p/19032792', title: 'Rust从入门到精通07-trait' })">举报</a>
</div>
        