
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/12lisu/p/18865897" title="发布于 2025-05-08 11:08">
    <span role="heading" aria-level="2">排行榜的5种实现方案！</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h2 id="引言">引言</h2>
<p>在工作的这些年中，我见证过太多团队在实现排行榜功能时踩过的坑。</p>
<p>今天我想和大家分享 6 种不同的排行榜实现方案，从简单到复杂，从单机到分布式，希望能帮助大家在实际工作中做出更合适的选择。</p>
<p>有些小伙伴在工作中可能会觉得：不就是个排行榜吗？搞个数据库排序不就完了？</p>
<p>但实际情况远比这复杂得多。</p>
<p>当数据量达到百万级、千万级时，简单的数据库查询可能就会成为系统的瓶颈。</p>
<p>接下来，我将为大家详细剖析 6 种不同的实现方案，希望对你会有所帮助。</p>
<h2 id="方案一数据库直接排序">方案一：数据库直接排序</h2>
<p><strong>适用场景</strong>：数据量小（万级以下），实时性要求不高</p>
<p>这是最简单直接的方案，几乎每个开发者最先想到的方法。</p>
<p>示例代码如下：</p>
<pre><code class="language-java">public List&lt;UserScore&gt; getRankingList() {
    String sql = "SELECT user_id, score FROM user_scores ORDER BY score DESC LIMIT 100";
    return jdbcTemplate.query(sql, new UserScoreRowMapper());
}
</code></pre>
<p><strong>优点</strong>：</p>
<ul>
<li>实现简单</li>
<li>代码维护成本低</li>
<li>适合数据量小的场景</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>数据量大时性能急剧下降</li>
<li>每次查询都需要全表扫描</li>
<li>高并发下数据库压力大</li>
</ul>
<p><strong>架构图如下</strong>：</p>
<p><img src="https://files.mdnice.com/user/5303/7e52582f-f4ad-4029-aa1c-d4ce58662c8f.png" alt="" loading="lazy"></p>
<h2 id="方案二缓存定时任务">方案二：缓存+定时任务</h2>
<p><strong>适用场景</strong>：数据量中等（十万级），可以接受分钟级延迟</p>
<p>这个方案在方案一的基础上引入了缓存机制。</p>
<p>示例代码如下：</p>
<pre><code class="language-java">@Scheduled(fixedRate = 60000) // 每分钟执行一次
public void updateRankingCache() {
    List&lt;UserScore&gt; rankings = userScoreDao.getTop1000Scores();
    redisTemplate.opsForValue().set("ranking_list", rankings);
}

public List&lt;UserScore&gt; getRankingList() {
    return (List&lt;UserScore&gt;) redisTemplate.opsForValue().get("ranking_list");
}
</code></pre>
<p><strong>优点</strong>：</p>
<ul>
<li>减轻数据库压力</li>
<li>查询速度快（O(1)）</li>
<li>实现相对简单</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>数据有延迟（取决于定时任务频率）</li>
<li>内存占用较高</li>
<li>排行榜更新不及时</li>
</ul>
<p><strong>架构图如下</strong>：</p>
<p><img src="https://files.mdnice.com/user/5303/388439aa-e43e-4857-acc5-934033869232.png" alt="" loading="lazy"></p>
<h2 id="方案三redis有序集合">方案三：Redis有序集合</h2>
<p><strong>适用场景</strong>：数据量大（百万级），需要实时更新</p>
<p>Redis的有序集合(Sorted Set)是实现排行榜的利器。</p>
<p>示例代码如下：</p>
<pre><code class="language-java">public void addUserScore(String userId, double score) {
    redisTemplate.opsForZSet().add("ranking", userId, score);
}

public List&lt;String&gt; getTopUsers(int topN) {
    return redisTemplate.opsForZSet().reverseRange("ranking", 0, topN - 1);
}

public Long getUserRank(String userId) {
    return redisTemplate.opsForZSet().reverseRank("ranking", userId) + 1;
}
</code></pre>
<p><strong>优点</strong>：</p>
<ul>
<li>高性能（O(log(N))时间复杂度）</li>
<li>支持实时更新</li>
<li>天然支持分页</li>
<li>可以获取用户排名</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>单机Redis内存有限</li>
<li>需要考虑Redis持久化</li>
<li>分布式环境下需要额外处理</li>
</ul>
<p><strong>架构图如下</strong>：<br>
<img src="https://files.mdnice.com/user/5303/6f19eaa7-067d-48c8-8a0c-5629dd60e3ae.png" alt="" loading="lazy"></p>
<h2 id="方案四分片redis集群">方案四：分片+Redis集群</h2>
<p><strong>适用场景</strong>：超大规模数据（千万级以上），高并发场景</p>
<p>当单机Redis无法满足需求时，可以采用分片方案。</p>
<p>示例代码如下：</p>
<pre><code class="language-java">// 
public void addUserScore(String userId, double score) {
    RScoredSortedSet&lt;String&gt; set = redisson.getScoredSortedSet("ranking:" + getShard(userId));
    set.add(score, userId);
}

private String getShard(String userId) {
    // 简单哈希分片
    int shard = Math.abs(userId.hashCode()) % 16;
    return "shard_" + shard;
}
</code></pre>
<p>在这里我们以Redisson客户端为例。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>水平扩展能力强</li>
<li>可以支持超大规模数据</li>
<li>高并发下性能稳定</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>架构复杂度高</li>
<li>跨分片查询困难</li>
<li>需要维护分片策略</li>
</ul>
<p><strong>架构图如下</strong>：</p>
<p><img src="https://files.mdnice.com/user/5303/4f27b81e-0f1c-475d-8b7a-097c4ce07ea4.png" alt="" loading="lazy"></p>
<h2 id="方案五预计算分层缓存">方案五：预计算+分层缓存</h2>
<p><strong>适用场景</strong>：排行榜更新不频繁，但访问量极大</p>
<p>这种方案结合了预计算和多级缓存。</p>
<p>示例代码如下：</p>
<pre><code class="language-java">@Scheduled(cron = "0 0 * * * ?") // 每小时计算一次
public void precomputeRanking() {
    Map&lt;String, Integer&gt; rankings = calculateRankings();
    redisTemplate.opsForHash().putAll("ranking:hourly", rankings);
    
    // 同步到本地缓存
    localCache.putAll(rankings);
}

public Integer getUserRank(String userId) {
    // 1. 先查本地缓存
    Integer rank = localCache.get(userId);
    if (rank != null) return rank;
    
    // 2. 再查Redis
    rank = (Integer) redisTemplate.opsForHash().get("ranking:hourly", userId);
    if (rank != null) {
        localCache.put(userId, rank); // 回填本地缓存
        return rank;
    }
    
    // 3. 最后查DB
    return userScoreDao.getUserRank(userId);
}
</code></pre>
<p><strong>优点</strong>：</p>
<ul>
<li>访问性能极高（本地缓存O(1)）</li>
<li>减轻Redis压力</li>
<li>适合读多写少场景</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>数据实时性差</li>
<li>预计算资源消耗大</li>
<li>实现复杂度高</li>
</ul>
<p><strong>架构图如下</strong>：</p>
<p><img src="https://files.mdnice.com/user/5303/2d8d721e-6d56-4dad-825e-a68ab4baed4b.png" alt="" loading="lazy"></p>
<h2 id="方案六实时计算流处理">方案六：实时计算+流处理</h2>
<p><strong>适用场景</strong>：需要实时更新且数据量极大的社交平台</p>
<p>这种方案采用流处理技术实现实时排行榜。</p>
<p>使用Apache Flink示例如下：</p>
<pre><code class="language-java">DataStream&lt;UserAction&gt; actions = env.addSource(new UserActionSource());

DataStream&lt;Tuple2&lt;String, Double&gt;&gt; scores = actions
    .keyBy(UserAction::getUserId)
    .process(new ProcessFunction&lt;UserAction, Tuple2&lt;String, Double&gt;&gt;() {
        private MapState&lt;String, Double&gt; userScores;
        
        public void open(Configuration parameters) {
            MapStateDescriptor&lt;String, Double&gt; descriptor = 
                new MapStateDescriptor&lt;&gt;("userScores", String.class, Double.class);
            userScores = getRuntimeContext().getMapState(descriptor);
        }
        
        public void processElement(UserAction action, Context ctx, Collector&lt;Tuple2&lt;String, Double&gt;&gt; out) {
            double newScore = userScores.getOrDefault(action.getUserId(), 0.0) + calculateScore(action);
            userScores.put(action.getUserId(), newScore);
            out.collect(new Tuple2&lt;&gt;(action.getUserId(), newScore));
        }
    });

scores.keyBy(0)
      .process(new RankProcessFunction())
      .addSink(new RankingSink());
</code></pre>
<p><strong>优点</strong>：</p>
<ul>
<li>真正的实时更新</li>
<li>可处理超高并发</li>
<li>支持复杂计算逻辑</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>架构复杂度高</li>
<li>运维成本高</li>
<li>需要专业团队维护</li>
</ul>
<p><strong>架构图如下</strong>：</p>
<p><img src="https://files.mdnice.com/user/5303/2859f769-dd6a-46eb-a4a2-c53923334cb6.png" alt="" loading="lazy"></p>
<h2 id="方案对比与选择">方案对比与选择</h2>
<table>
<thead>
<tr>
<th>方案</th>
<th>数据量</th>
<th>实时性</th>
<th>复杂度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库排序</td>
<td>小</td>
<td>低</td>
<td>低</td>
<td>个人项目、小规模应用</td>
</tr>
<tr>
<td>缓存+定时任务</td>
<td>中</td>
<td>中</td>
<td>中</td>
<td>中小型应用，可接受延迟</td>
</tr>
<tr>
<td>Redis有序集合</td>
<td>大</td>
<td>高</td>
<td>中</td>
<td>大型应用，需要实时更新</td>
</tr>
<tr>
<td>分片+Redis集群</td>
<td>超大</td>
<td>高</td>
<td>高</td>
<td>超大型应用，超高并发</td>
</tr>
<tr>
<td>预计算+分层缓存</td>
<td>大</td>
<td>中高</td>
<td>高</td>
<td>读多写少，访问量极大</td>
</tr>
<tr>
<td>实时计算+流处理</td>
<td>超大</td>
<td>实时</td>
<td>极高</td>
<td>社交平台，需要实时排名</td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2>
<p>在选择排行榜实现方案时，我们需要综合考虑以下几个因素：</p>
<ol>
<li><strong>数据规模</strong>：数据量大小直接决定了我们选择哪种方案</li>
<li><strong>实时性要求</strong>：是否需要秒级更新，还是分钟级甚至小时级都可以接受</li>
<li><strong>并发量</strong>：系统的预期访问量是多少</li>
<li><strong>开发资源</strong>：团队是否有足够的技术能力维护复杂方案</li>
<li><strong>业务需求</strong>：排行榜的计算逻辑是否复杂</li>
</ol>
<p>对于大多数中小型应用，方案二（缓存+定时任务）或方案三（Redis有序集合）已经足够。如</p>
<p>果业务增长迅速，可以逐步演进到方案四（分片+Redis集群）。</p>
<p>而对于社交平台等需要实时更新的场景，则需要考虑方案五（预计算+分层缓存）或方案六（实时计算+流处理），但要做好技术储备和架构设计。</p>
<p>最后，无论选择哪种方案，都要做好监控和性能测试。排行榜作为高频访问的功能，其性能直接影响用户体验。</p>
<p>建议在实际环境中进行压测，根据测试结果调整方案。</p>
<p>希望这六种方案的详细解析能帮助大家在工作中做出更合适的选择。</p>
<blockquote>
<p>记住，没有最好的方案，只有最适合的方案。</p>
</blockquote>
<h2 id="最后说一句求关注别白嫖我">最后说一句(求关注，别白嫖我)</h2>
<p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下我的同名公众号：苏三说技术，您的支持是我坚持写作最大的动力。<br>
求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：进大厂，可以免费获取我最近整理的50万字的面试宝典，好多小伙伴靠这个宝典拿到了多家大厂的offer。</p>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.46615524825810184" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-05-08 11:09">2025-05-08 11:08</span>&nbsp;
<a href="https://www.cnblogs.com/12lisu">苏三说技术</a>&nbsp;
阅读(<span id="post_view_count">284</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18865897);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18865897', targetLink: 'https://www.cnblogs.com/12lisu/p/18865897', title: '排行榜的5种实现方案！' })">举报</a>
</div>
        