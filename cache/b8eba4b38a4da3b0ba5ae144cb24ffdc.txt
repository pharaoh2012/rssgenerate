
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/cikiss/p/18659540" title="发布于 2025-01-08 13:31">
    <span role="heading" aria-level="2">Servlet详解</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="概念">概念</h1>
<ul>
<li>Servlet是运行在服务端的小程序（Server Applet)，可以处理客户端的请求并返回响应，主要用于构建动态的Web应用，是SpringMVC的基础。</li>
</ul>
<hr>
<h1 id="生命周期">生命周期</h1>
<h2 id="加载和初始化">加载和初始化</h2>
<ul>
<li>懒加载（默认在客户端第一次请求加载到容器中），通过反射实例化，并调用<code>init()</code>，且<code>init()</code>只能被调用一次，因此每个Servlet是单例的，需注意线程安全。</li>
</ul>
<h2 id="请求处理">请求处理</h2>
<ul>
<li>Servlet 容器收到url请求后，路由到对应的Servlet，调用<code>service()</code>方法处理客户端请求，并返回响应。</li>
<li>每次服务器收到一个请求时，Servlet 容器都会分配一个线程并调用<code>service()</code>方法，根据请求类型，执行对应的方法，也会存在线程安全问题，避免使用全局变量、非同步数据结构等。</li>
</ul>
<h2 id="销毁">销毁</h2>
<ul>
<li><code>destroy()</code>只会被调用一次，当容器被正常关闭时，释放一些使用了的资源。</li>
<li>异常终止情况，不会调用destroy()。</li>
</ul>
<hr>
<h1 id="流程图">流程图</h1>
<p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/70b3541ac32a4a4aa179d6ab3e2b5166~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgU2xhY2tDbGltYg==:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiODY5MDc1Mjk1NDEwMDA5In0%3D&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1736400495&amp;x-orig-sign=09KeAigAQIvWOoWRfaCpPKi%2BHWA%3D" alt="" loading="lazy"></p>
<h1 id="其他应用">其他应用</h1>
<h2 id="1-过滤器filter"><strong>1. 过滤器（Filter）</strong></h2>
<h3 id="11-作用"><strong>1.1 作用</strong></h3>
<ul>
<li>对请求和响应进行预处理和后处理。</li>
<li>典型应用场景：</li>
</ul>

<ul>
<li>
<ul>
<li>权限验证。</li>
<li>请求参数编码处理。</li>
<li>日志记录。</li>
<li>防止 XSS 和 SQL 注入。</li>
</ul>
</li>
</ul>
<h3 id="12-工作流程"><strong>1.2 工作流程</strong></h3>
<ul>
<li>过滤器在 Servlet 执行之前运行，可以拦截并修改请求。</li>
<li>过滤器在 Servlet 执行之后运行，可以修改响应。</li>
</ul>
<h3 id="13-关键接口"><strong>1.3 关键接口</strong></h3>
<p><code>javax.servlet.Filter</code> 接口，核心方法：</p>
<ol>
<li><code>init(FilterConfig filterConfig)</code>：在容器启动时初始化过滤器。</li>
<li><code>doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</code>：</li>
</ol>
<ul>
<li>
<ul>
<li>进行请求/响应的过滤处理。</li>
<li>调用 <code>chain.doFilter()</code> 将请求传递到下一个过滤器或目标 Servlet。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><code>destroy()</code>：在容器关闭时释放资源。</li>
</ol>
<h3 id="14-示例"><strong>1.4 示例</strong></h3>
<h4 id="过滤器实现">过滤器实现</h4>
<pre><code>@WebFilter(urlPatterns = "/*") // 拦截所有请求
public class LoggingFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("过滤器初始化");
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        System.out.println("请求到达过滤器");
        chain.doFilter(request, response); // 将请求传递到下一个过滤器或 Servlet
        System.out.println("响应从过滤器返回");
    }

    @Override
    public void destroy() {
        System.out.println("过滤器销毁");
    }
}
</code></pre>
<hr>
<h2 id="2-监听器listener"><strong>2. 监听器（Listener）</strong></h2>
<h3 id="21-作用"><strong>2.1 作用</strong></h3>
<ul>
<li>监听 Web 应用中对象（如请求、会话、上下文）生命周期事件或属性变化。</li>
<li>典型应用场景：</li>
</ul>

<ul>
<li>
<ul>
<li>统计在线人数。</li>
<li>初始化全局资源。</li>
<li>监控会话销毁以释放资源。</li>
</ul>
</li>
</ul>
<h3 id="22-关键接口"><strong>2.2 关键接口</strong></h3>
<p>Servlet 提供了多种监听器接口：</p>
<ol>
<li><strong>应用上下文监听器</strong>：</li>
</ol>
<ul>
<li>
<ul>
<li><code>ServletContextListener</code>：监听应用启动和销毁事件。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>会话监听器</strong>：</li>
</ol>
<ul>
<li>
<ul>
<li><code>HttpSessionListener</code>：监听会话创建和销毁事件。</li>
<li><code>HttpSessionAttributeListener</code>：监听会话属性变化。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>请求监听器</strong>：</li>
</ol>
<ul>
<li>
<ul>
<li><code>ServletRequestListener</code>：监听请求创建和销毁事件。</li>
<li><code>ServletRequestAttributeListener</code>：监听请求属性变化。</li>
</ul>
</li>
</ul>
<h3 id="23-示例"><strong>2.3 示例</strong></h3>
<h4 id="在线人数统计">在线人数统计</h4>
<pre><code>@WebListener
public class OnlineUserListener implements HttpSessionListener {
    private static int onlineUsers = 0;

    @Override
    public void sessionCreated(HttpSessionEvent se) {
        onlineUsers++;
        System.out.println("用户上线，当前在线人数：" + onlineUsers);
    }

    @Override
    public void sessionDestroyed(HttpSessionEvent se) {
        onlineUsers--;
        System.out.println("用户下线，当前在线人数：" + onlineUsers);
    }
}
</code></pre>
<hr>
<h2 id="3-异步处理"><strong>3. 异步处理</strong></h2>
<h3 id="31-作用"><strong>3.1 作用</strong></h3>
<ul>
<li>Servlet 3.0 引入异步处理，用于提高性能和响应速度。</li>
<li>异步处理允许在 Servlet 请求线程结束后继续处理任务，释放容器线程资源。</li>
</ul>
<h3 id="32-核心方法"><strong>3.2 核心方法</strong></h3>
<ol>
<li>在 Servlet 中启动异步支持：</li>
</ol>
<pre><code>@WebServlet(urlPatterns = "/async", asyncSupported = true)
public class AsyncServlet extends HttpServlet {
}
</code></pre>
<ol start="2">
<li>异步请求处理逻辑：</li>
</ol>
<pre><code>@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    AsyncContext asyncContext = req.startAsync();
    asyncContext.start(() -&gt; {
        try {
            Thread.sleep(2000); // 模拟耗时操作
            asyncContext.getResponse().getWriter().write("异步请求完成");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            asyncContext.complete(); // 完成异步处理
        }
    });
}
</code></pre>
<hr>
<h2 id="4-文件上传与下载"><strong>4. 文件上传与下载</strong></h2>
<h3 id="41-文件上传"><strong>4.1 文件上传</strong></h3>
<h4 id="配置文件上传支持">配置文件上传支持</h4>
<p>Servlet 3.0 引入了对文件上传的直接支持，通过 <code>@MultipartConfig</code> 注解。</p>
<h4 id="示例">示例</h4>
<pre><code>@WebServlet("/upload")
@MultipartConfig(location = "/tmp", fileSizeThreshold = 1024 * 1024, maxFileSize = 5 * 1024 * 1024)
public class FileUploadServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        Part filePart = req.getPart("file"); // 获取上传文件的部分
        String fileName = filePart.getSubmittedFileName();
        filePart.write("/uploads/" + fileName); // 保存文件
        resp.getWriter().write("文件上传成功：" + fileName);
    }
}
</code></pre>
<h3 id="42-文件下载"><strong>4.2 文件下载</strong></h3>
<h4 id="示例-1">示例</h4>
<pre><code>@WebServlet("/download")
public class FileDownloadServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String fileName = "example.txt";
        resp.setContentType("application/octet-stream");
        resp.setHeader("Content-Disposition", "attachment;filename=" + fileName);
        try (InputStream in = new FileInputStream("/uploads/" + fileName);
             OutputStream out = resp.getOutputStream()) {
            byte[] buffer = new byte[1024];
            int len;
            while ((len = in.read(buffer)) != -1) {
                out.write(buffer, 0, len);
            }
        }
    }
}
</code></pre>
<hr>

</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0.03378170046180556" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2025-01-08 13:32">2025-01-08 13:31</span>&nbsp;
<a href="https://www.cnblogs.com/cikiss">SlackClimb</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=18659540" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18659540);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18659540', targetLink: 'https://www.cnblogs.com/cikiss/p/18659540', title: 'Servlet详解' })">举报</a>
</div>
        