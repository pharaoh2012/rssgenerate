
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/sizeof127/p/18967138" title="发布于 2025-07-05 12:56">
    <span role="heading" aria-level="2">2025 FJCPC 复建 VP</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        准大学生复建
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<p>按开题顺序写 <span class="math inline">\(BCDEFGHIJKLA(D?)\)</span>，<span class="math inline">\(M\)</span> 送的不写</p>
<h3 id="b">B</h3>
<p>首先发现铜铁本质等价（铜铁的转换不影响 <span class="math inline">\(val\)</span> ），所以考虑枚举最后金和银的数量 <span class="math inline">\(gold, silver\)</span>，那么约束条件为：</p>
<p></p><div class="math display">\[val=n-4g-s\ge p
\]</div><p></p><p></p><div class="math display">\[8g+4s\le n
\]</div><p></p><p>那么考虑剩余铁牌全合成同和全不合成情况，每合成一个铜牌那么总牌数减一，即 <span class="math inline">\(g, s\)</span> 对 <span class="math inline">\(i\in[g+s+\left \lfloor \frac{(n-8g-4s+1)}{2} \right \rfloor, g+s+(n-8g-4s)]\)</span> 的 <span class="math inline">\(ans_{i}\)</span> 有 1 的贡献。</p>
<p>拆开下取整得 <span class="math inline">\([\left \lfloor \frac{(n+1)}{2} \right \rfloor-3g-s, n-7g-3s]\)</span></p>
<p>我们枚举 <span class="math inline">\(g\)</span> 时，需要加的区间 <span class="math inline">\([l, r]\)</span> 随着 <span class="math inline">\(s\)</span> 的变化，左右端点分别为公差为 1/3 的等差数列。</p>
<p>将区间 +1 操作变为差分，那么对于某个 <span class="math inline">\(g\)</span> 上述区间的贡献可以相当于一个等差数列下标组 +1，另一个等差数列下标组 -1，二阶差分数组可以解决。</p>
<p>关键代码：</p>
<pre><code class="language-cpp">	for(int i=0, x, s0; i&lt;=n; ++i){
		s0=min(n-4*i-p, (n-8*i)/4);if(s0&lt;0) break;
		x=(n+1)/2-3*i;del[0][x-s0]++, del[0][x+1]--;
		x=n-7*i+1;del[1][x-3*s0]--, del[1][x+3]++;
	}
	for(int i=0; i&lt;=n; ++i){
		if(i) del[0][i]+=del[0][i-1];
		if(i&gt;2) del[1][i]+=del[1][i-3];
		ans[i]=del[0][i]+del[1][i];
	}
</code></pre>
<h3 id="c">C</h3>
<p>贪心策略不好处理，考虑二分答案。，那么序列可视为 0/1 序列。</p>
<p>只有两个数是比较容易做贪心的，压缩 000 和 001 即可。</p>
<p>关键代码：</p>
<pre><code class="language-cpp">bool check(int v){
	int top=0, c[2]={0, 0};
	for(int i=1; i&lt;=n; ++i){
		bool x=a[i]&gt;=v;//printf("%d", x);
		if(!top){t[++top]={1, x};continue;}
		if(t[top].nd==x){
			++t[top].st;
			if((!t[top].nd)&amp;&amp;t[top].st==3) t[top].st=1;
		}
		else{ 
			t[++top]={1, x};
			if(t[top].nd&amp;&amp;top&gt;1&amp;&amp;t[top-1].st==2){
				--top;t[top].st=1;
			}
		}
	}
	for(int i=1; i&lt;=top; ++i) c[t[i].nd]+=t[i].st;
	return c[1]&gt;=c[0];
}
</code></pre>
<h3 id="e">E</h3>
<p>等价于 <span class="math inline">\(\min |\sum (-1)^{i}a_{i}|\)</span></p>
<p>操作相当于任选一段长度为偶数的区间使系数 <span class="math inline">\((-1)^i\)</span> 正负翻转</p>
<p>如果翻转 <span class="math inline">\([l, r]\)</span> 则 <span class="math inline">\(ans=|sum_{n}-2sum_{r}+2sum_{l-1}|\)</span>，<span class="math inline">\(sum_{i}\)</span> 是带系数的前缀和。</p>
<p>即找到距离 <span class="math inline">\(2sum_{r}\)</span> 最近的 <span class="math inline">\(sum_{n}+2sum_{l-1}\)</span>，set 维护即可。</p>
<p>最后的答案 <span class="math inline">\(ans'=\frac{\sum^{n}_{i=1} a_{n}-ans}{2}\)</span>， 需要注意注意 <span class="math inline">\(l, r\)</span> 奇偶性相反。</p>
<p>关键代码：</p>
<pre><code class="language-cpp">	for(int i=1; i&lt;=n; ++i){
		int op=i&amp;1;ll p=-2LL*sum[i];
		if(S[op^1].size()){
			auto it=S[op^1].lower_bound(-p);
			if(it!=S[op^1].end()) t=min(t, (*it)+p);
		}S[op].insert(sum[n]+2LL*sum[i-1]);
		if(T[op^1].size()){
			auto it=T[op^1].lower_bound(p);
			if(it!=T[op^1].end()) t=min(t, (*it)-p);
		}T[op].insert(-2LL*sum[i-1]-sum[n]);
	}
</code></pre>
<h3 id="f">F</h3>
<p>考虑得到 <span class="math inline">\(l_i, r_{i}\)</span> 为 <span class="math inline">\(i\)</span> 号点左右能让它被肘飞的点（默认 <span class="math inline">\(l_{i}=0, r_{i}=n+1\)</span>）</p>
<p>那么即数 <span class="math inline">\([L, R]\)</span> 中 <span class="math inline">\(l_{i}&lt;L, R&lt;r_{i}\)</span> 的 <span class="math inline">\(i\)</span> 的个数，</p>
<p>那么点 <span class="math inline">\(i\)</span> 对 <span class="math inline">\([[l_{i}+1, i], [i, r_{i}-1]]\)</span> 的询问有贡献，视为矩形加，询问单点值，扫描线解决。</p>
<p>求 <span class="math inline">\(l_{i}, r_i\)</span>： 按 <span class="math inline">\(x_{i}\)</span> 关键字排逆序在线段树上依次插入 <span class="math inline">\(i, y_{i}\)</span>，查询 <span class="math inline">\(l_{i}\)</span> 即找到 <span class="math inline">\([1, i]\)</span> 最右边 <span class="math inline">\(y_x&gt;y_{i}\)</span> 的部分并返回，<span class="math inline">\(r_i\)</span> 同理，线段树二分即可。</p>
<p>关键代码：</p>
<pre><code class="language-cpp">int queryL(int k, int l, int r, int x){
	if(l&gt;x||Mx(x, tr[k])==x) return 0;
	if(l==r) return tr[k];int res=queryL(rs, mid+1, r, x);
	return res?res:queryL(ls, l, mid, x);
}
int queryR(int k, int l, int r, int x){
	if(r&lt;x||Mx(x, tr[k])==x) return n+1;
	if(l==r) return tr[k]?tr[k]:n+1;int res=queryR(ls, l, mid, x);
	return (res&lt;=n)?res:queryR(rs, mid+1, r, x);
}
</code></pre>
<h3 id="g">G</h3>
<p>只会在一个单调不降段开头买入结尾卖出，等价于 <span class="math inline">\(a_{i}&gt;a_{i-1}\)</span> 的有 <span class="math inline">\(a_{i}-a_{i-1}\)</span> 的贡献，前缀和即可。</p>
<h3 id="h">H</h3>
<p>假设最短路是 <span class="math inline">\(d\)</span>, 设 <span class="math inline">\(d=kr+d'\)</span>。</p>
<p>如果 <span class="math inline">\(l&lt;r\)</span> 则在最后一步必然可以使用 与 <span class="math inline">\(d'\)</span> 奇偶性相同的值在走到终点后反复横跳，<span class="math inline">\(ans=k+1\)</span>。</p>
<p>那么 <span class="math inline">\(l=r\)</span> 的情况也同理分奇偶考虑，偶数情况是简单的，只能考虑长度为偶数的最短路。奇数情况，两种奇偶性最短路都要考虑，并且如果消耗时间*步数与奇偶性不同还要额外 +1 。</p>
<p>关键代码：</p>
<pre><code class="language-cpp">	if(L&lt;R){
		p=min(dis[0][id(n, m)], dis[1][id(n, m)]);
		if(p!=INF) printf("%d\n", (p+R-1)/R);
		else puts("-1");
	} 
	else if(L%2){//奇数
		int u=dis[0][id(n, m)], v=dis[1][id(n, m)];
		if(u!=INF){u=(u+L-1)/L;if((u&amp;1)==1) ++u;}
		if(v!=INF){v=(v+R-1)/R;if((v&amp;1)==0) ++v;}
		if(min(u, v)==INF) puts("-1");
		else printf("%d\n", min(u, v));
	}
	else{
		p=dis[0][id(n, m)];
		if(p!=INF) printf("%d\n", (p+L-1)/L);
		else puts("-1");
	}
</code></pre>
<h3 id="i">I</h3>
<p>从特殊情况入手，全是割点无解，因为 <span class="math inline">\(n\)</span> 至少需要两条出边连向同一个连通块，这连个出边的点就不嫩是割点。</p>
<p>一个非割点同理，构造链考虑，如果 <span class="math inline">\(n-1\)</span> 是非割点则可以和 <span class="math inline">\(n\)</span> 一起连到 <span class="math inline">\(n-2\)</span>，否则无解。</p>
<p>度数的 <span class="math inline">\(\ge\)</span> 条件引导我们构造一连串的等于条件，容易想到 环 和 链中间 的点都满足度数为 <span class="math inline">\(2\)</span>，且环上是非割点而链是割点，于是让 1 作为环和链的交点，<span class="math inline">\(n\)</span> 作为链的另一头。</p>
<h3 id="j">J</h3>
<p>lowbit 二进制构造。</p>
<h3 id="k">K</h3>
<p>先待定 <span class="math inline">\(b_1=0\)</span>，那么可以推算得 <span class="math inline">\(b_{i}=x_{i}+c_ib_{1}, c_{i}=1/-1\)</span> ，根据深度以及 <span class="math inline">\(b_{i}\)</span> 正负性简单分讨即可。</p>
<h3 id="l">L</h3>
<p>前缀子集 <span class="math inline">\(\min+\max\)</span> 的众数</p>
<p>对于前缀 <span class="math inline">\([1, i]\)</span>，一共有 <span class="math inline">\(2^i-1\)</span> 种情况，其中最大值+最小值保底有 <span class="math inline">\(2^{i-2}\)</span> 种，容易发现只有 <span class="math inline">\(1, 2, 2,..., 2\)</span> 时才会实现反超。</p>
<h3 id="a">A</h3>
<p>题面一坨，可读性不如代码。。。</p>
<p>考虑 DAG 剖，每个结点维护一个 ds 二元组集合统计 <span class="math inline">\((mx, cnt)\)</span>，转移时轻边直接暴力取出所有元素加入，重边则继承出点的 ds。ds 使用线段树，复杂度 <span class="math inline">\(O(n\log ^2 n)\)</span>。</p>
<details> 
<summary><font size="3" color="blue">参考代码</font></summary> 
<pre><code class="language-cpp">#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <cctype>
#include <vector>
#include <queue>
#include <set>
#define vi vector<int>
#define pb push_back
#define mp make_pair
#define st first
#define nd second
using namespace std;
typedef long long ll;
typedef pair <int, int=""> Pii;
const int INF=0x3f3f3f3f;
const int cp=998244353;
inline int mod(int x){return x+(x&lt;0?cp:0)-(x&gt;=cp?cp:0);}
inline void plust(int &amp;x, int y){x=mod(x+y);return ;}
inline void minut(int &amp;x, int y){x=mod(x-y);return ;}
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)){x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0';ch=getchar();}
	return x*f;
}
inline void write(int x){
    if(x&lt;0) putchar('-'), x=-x;
    if(x&gt;9) write(x/10);
    putchar(x%10+'0');
}
inline int ksm(int a, int b=cp-2){
	int ret=1;
	for(; b; b&gt;&gt;=1, a=1ll*a*a%cp)
		if(b&amp;1) ret=1ll*ret*a%cp;
	return ret;
}
const int N=2e5+5;
char s[N];int n;
namespace SAM{
	const int Nc=N&lt;&lt;1;//SAM 实际点数卡满 2n-1
	const int Mc=(N&lt;&lt;1)+N;//SAM 实际边数卡满 3n-4
	int ndc, lst, siz[Nc], c[Nc], out[Nc], in[Nc], dfn[Nc], bac[Nc];
	ll f[Nc], g[Nc];vi dag[Nc], inv[Nc], G[Nc];
	struct node{int fa, len, nxt[26];}sam[Nc];
	int clear(int x){sam[x]=sam[0], siz[x]=0;return x;}
	void remake(){clear(ndc=lst=1), dfn[0]=0;}
	int insert(char c){
		int cur=clear(++ndc), p=lst, cc=c-'a';siz[cur]=1;
		sam[cur].len=sam[lst].len+1;
		for(; p&amp;&amp;!sam[p].nxt[cc]; p=sam[p].fa)
			sam[p].nxt[cc]=cur;
		int q=sam[p].nxt[cc];
		if(!q) sam[cur].fa=1;
		else if(sam[q].len==sam[p].len+1) sam[cur].fa=q;
		else{
			int nex=clear(++ndc);sam[nex]=sam[q], sam[nex].len=sam[p].len+1;
			for(; p&amp;&amp;sam[p].nxt[cc]==q; p=sam[p].fa) 
				sam[p].nxt[cc]=nex;
			sam[cur].fa=sam[q].fa=nex;
		}
		return lst=cur;
	}
	void dfs(int x){bac[dfn[x]=++dfn[0]]=x;for(auto v:dag[x]) if(!dfn[v]) dfs(v);}
	void dfs2(int x){for(auto v:G[x]) dfs2(v), siz[x]+=siz[v];}
	inline bool heavy(int u, int v){return (2ll*f[u]&gt;f[v])&amp;&amp;(2ll*g[v]&gt;g[u]);}
	#define ls(p) tr[p].lc
	#define rs(p) tr[p].rc
	#define C(p) tr[p].cnt
	#define S(p) tr[p].sum
	#define mid ((l+r)&gt;&gt;1)
	const int M=Nc*30;
	const int P=2e5;
	struct seg{int lc, rc;ll cnt, sum;};
	int m, rt[Nc];seg tr[M];
	vi bin;
	inline int newnd(){
		int t=0;if(!bin.size()) t=++m;
		else{ 
			t=bin.back(), bin.pop_back();
			if(ls(t)) bin.pb(ls(t));
			if(rs(t)) bin.pb(rs(t));
		}
		tr[t]=(seg){0, 0, 0, 0};return t;
	}
	void update(int &amp;k, int l, int r, int u, ll c){
		if(!c) return ;
		if(!k) k=newnd();if(l==r){C(k)+=c, S(k)+=c*mid;return ;}
		if(u&lt;=mid) update(ls(k), l, mid, u, c);else update(rs(k), mid+1, r, u, c);
		C(k)=C(ls(k))+C(rs(k)), S(k)=S(ls(k))+S(rs(k));
	}
	ll cover(int &amp;k, int l, int r, int U){//查询且覆盖
		if(!k) return 0;if(l&gt;=U) return 0;
		if(r<u){ll res="C(k);bin.pb(k)," k="0;return" res;}="" ll="" l,="" mid,="" u)+cover(rs(k),="" mid+1,="" r,="" u);="" c(k)="C(ls(k))+C(rs(k))," s(k)="S(ls(k))+S(rs(k));return" res;="" }="" void="" copy(int="" &x,="" int="" y,="" r){="" 轻边合并="" if(!y)="" return="" ;if(!x)="" x="newnd();C(x)+=C(y)," s(x)+="S(y);if(l==r)" ;="" copy(ls(x),="" ls(y),="" mid);copy(rs(x),="" rs(y),="" r);="" #undef="" ls="" rs="" c="" s="" mid="" init(){="" remake();="" for(int="" i="1;" i<="n;" ++i)="" insert(s[i]);="" ++i){="" if(sam[i].fa)="" g[sam[i].fa].pb(i);="" v;="" c<26;="" ++c)="" if((v="sam[i].nxt[c]))" ++in[v],="" ++out[i],="" dag[i].pb(v),="" inv[v].pb(i);="" dfs(1);dfs2(1);siz[1]="m=0;" c[bac[i]]="read();" queue="" <int=""> Q;Q.push(f[1]=1);vi topo;
		while(!Q.empty()){
			int x=Q.front();Q.pop();topo.pb(x);
			for(auto v:dag[x]){
				f[v]+=f[x];--in[v];
				if(!in[v]) Q.push(v);
			}
		}
		for(int i=ndc; i&gt;=1; --i) 
			if(!out[i]) Q.push(i), g[i]=1;
		while(!Q.empty()){
			int x=Q.front();Q.pop();
			for(auto v:inv[x]){
				g[v]+=g[x];--out[v];
				if(!out[v]) Q.push(v);
			}
		}
		ll ans=0;update(rt[1], 1, P, c[1], 1);
		for(auto x:topo){
			int son=0;ll p=cover(rt[x], 1, P, c[x]);update(rt[x], 1, P, c[x], p);
			ans+=tr[rt[x]].sum*siz[x];
			for(auto v:dag[x]) 
				if(!heavy(x, v)) copy(rt[v], rt[x], 1, P);else son=v;
			if(son) swap(rt[son], rt[x]), copy(rt[son], rt[x], 1, P);
		}
		printf("%lld\n", ans);bin.clear();
		for(int i=1; i&lt;=ndc; ++i) 
			dag[i].clear(), inv[i].clear(), G[i].clear(),
			f[i]=g[i]=in[i]=dfn[i]=bac[i]=out[i]=rt[i]=siz[i]=c[i]=0;
	}
}
void solve(){
	scanf("%s", s+1);n=strlen(s+1);SAM :: init();
}
signed main(){
	for(int T=read(); T; --T) solve();
	return 0;
}</u){ll></int,></int></set></queue></vector></cctype></string.h></algorithm></stdio.h></code>
</pre> </details>
</div>
<div class="clear"></div>

            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="0" data-date-updated="2025-07-05 12:57">2025-07-05 12:56</span>&nbsp;
<a href="https://www.cnblogs.com/sizeof127">127_127_127</a>&nbsp;
阅读(<span id="post_view_count">39</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(18967138);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '18967138', targetLink: 'https://www.cnblogs.com/sizeof127/p/18967138', title: '2025 FJCPC 复建 VP' })">举报</a>
</div>
        